commit 45ca9f7a9efdf5d191f1f23e08cb719edf3a8fe9
Author: Robert Griesemer <gri@golang.org>
Date:   Tue Dec 15 15:41:46 2009 -0800

    1) Change default gofmt default settings for
       parsing and printing to new syntax.
    
       Use -oldparser to parse the old syntax,
       use -oldprinter to print the old syntax.
    
    2) Change default gofmt formatting settings
       to use tabs for indentation only and to use
       spaces for alignment. This will make the code
       alignment insensitive to an editor's tabwidth.
    
       Use -spaces=false to use tabs for alignment.
    
    3) Manually changed src/exp/parser/parser_test.go
       so that it doesn't try to parse the parser's
       source files using the old syntax (they have
       new syntax now).
    
    4) gofmt -w src misc test/bench
    
    5th and last set of files.
    
    R=rsc
    CC=golang-dev
    https://golang.org/cl/180050
---
 src/pkg/syslog/syslog.go              |   82 +-
 src/pkg/syslog/syslog_test.go         |   64 +-
 src/pkg/tabwriter/tabwriter.go        |  246 +-
 src/pkg/tabwriter/tabwriter_test.go   |   82 +-
 src/pkg/template/format.go            |   42 +-
 src/pkg/template/template.go          |  520 ++--
 src/pkg/template/template_test.go     |  194 +-
 src/pkg/testing/benchmark.go          |   88 +-
 src/pkg/testing/iotest/logger.go      |   22 +-
 src/pkg/testing/iotest/reader.go      |   34 +-
 src/pkg/testing/iotest/writer.go      |   16 +-
 src/pkg/testing/quick/quick.go        |  188 +-
 src/pkg/testing/quick/quick_test.go   |  114 +-
 src/pkg/testing/regexp.go             |  680 ++---
 src/pkg/testing/regexp_test.go        |  122 +-
 src/pkg/testing/script/script.go      |  190 +-
 src/pkg/testing/script/script_test.go |   42 +-
 src/pkg/testing/testing.go            |   94 +-
 src/pkg/time/sleep.go                 |    6 +-
 src/pkg/time/tick.go                  |   30 +-
 src/pkg/time/tick_test.go             |   26 +-
 src/pkg/time/time.go                  |  272 +-
 src/pkg/time/time_test.go             |   46 +-
 src/pkg/time/zoneinfo.go              |  136 +-
 src/pkg/unicode/digit.go              |    4 +-
 src/pkg/unicode/digit_test.go         |    4 +-
 src/pkg/unicode/letter.go             |  104 +-
 src/pkg/unicode/letter_test.go        |   16 +-
 src/pkg/unicode/maketables.go         |  456 +--
 src/pkg/unicode/script_test.go        |   22 +-
 src/pkg/unicode/tables.go             |  316 +--
 src/pkg/utf8/utf8.go                  |  150 +-
 src/pkg/utf8/utf8_test.go             |   90 +-
 src/pkg/websocket/client.go           |   76 +-
 src/pkg/websocket/server.go           |   40 +-
 src/pkg/websocket/websocket.go        |   74 +-
 src/pkg/websocket/websocket_test.go   |   48 +-
 src/pkg/xgb/example.go                |   64 +-
 src/pkg/xgb/xgb.go                    |  282 +-
 src/pkg/xgb/xproto.go                 | 4912 ++++++++++++++++-----------------
 src/pkg/xml/read.go                   |  134 +-
 src/pkg/xml/read_test.go              |   50 +-
 src/pkg/xml/xml.go                    |  498 ++--
 src/pkg/xml/xml_test.go               |   42 +-
 test/bench/binary-tree-freelist.go    |   66 +-
 test/bench/binary-tree.go             |   36 +-
 test/bench/chameneosredux.go          |   96 +-
 test/bench/fannkuch.go                |   52 +-
 test/bench/fasta.go                   |   88 +-
 test/bench/k-nucleotide.go            |   90 +-
 test/bench/mandelbrot.go              |   62 +-
 test/bench/meteor-contest.go          |  242 +-
 test/bench/nbody.go                   |  120 +-
 test/bench/pidigits.go                |   66 +-
 test/bench/regex-dna.go               |   38 +-
 test/bench/reverse-complement.go      |   44 +-
 test/bench/spectral-norm-parallel.go  |   48 +-
 test/bench/spectral-norm.go           |   38 +-
 test/bench/threadring.go              |   30 +-
 59 files changed, 5917 insertions(+), 5917 deletions(-)

diff --git a/src/pkg/syslog/syslog.go b/src/pkg/syslog/syslog.go
index ef17e68628..527321f576 100644
--- a/src/pkg/syslog/syslog.go
+++ b/src/pkg/syslog/syslog.go
@@ -9,10 +9,10 @@
 package syslog
 
 import (
-	"fmt";
-	"log";
-	"net";
-	"os";
+	"fmt"
+	"log"
+	"net"
+	"os"
 )
 
 type Priority int
@@ -20,21 +20,21 @@ type Priority int
 const (
 	// From /usr/include/sys/syslog.h.
 	// These are the same on Linux, BSD, and OS X.
-	LOG_EMERG	Priority	= iota;
-	LOG_ALERT;
-	LOG_CRIT;
-	LOG_ERR;
-	LOG_WARNING;
-	LOG_NOTICE;
-	LOG_INFO;
-	LOG_DEBUG;
+	LOG_EMERG Priority = iota
+	LOG_ALERT
+	LOG_CRIT
+	LOG_ERR
+	LOG_WARNING
+	LOG_NOTICE
+	LOG_INFO
+	LOG_DEBUG
 )
 
 // A Writer is a connection to a syslog server.
 type Writer struct {
-	priority	Priority;
-	prefix		string;
-	conn		net.Conn;
+	priority Priority
+	prefix   string
+	conn     net.Conn
 }
 
 // New establishes a new connection to the system log daemon.
@@ -52,23 +52,23 @@ func Dial(network, raddr string, priority Priority, prefix string) (w *Writer, e
 	if prefix == "" {
 		prefix = os.Args[0]
 	}
-	var conn net.Conn;
+	var conn net.Conn
 	if network == "" {
 		conn, err = unixSyslog()
 	} else {
 		conn, err = net.Dial(network, "", raddr)
 	}
-	return &Writer{priority, prefix, conn}, err;
+	return &Writer{priority, prefix, conn}, err
 }
 
 func unixSyslog() (conn net.Conn, err os.Error) {
-	logTypes := []string{"unixgram", "unix"};
-	logPaths := []string{"/dev/log", "/var/run/syslog"};
-	var raddr string;
+	logTypes := []string{"unixgram", "unix"}
+	logPaths := []string{"/dev/log", "/var/run/syslog"}
+	var raddr string
 	for _, network := range logTypes {
 		for _, path := range logPaths {
-			raddr = path;
-			conn, err := net.Dial(network, "", raddr);
+			raddr = path
+			conn, err := net.Dial(network, "", raddr)
 			if err != nil {
 				continue
 			} else {
@@ -76,7 +76,7 @@ func unixSyslog() (conn net.Conn, err os.Error) {
 			}
 		}
 	}
-	return nil, os.ErrorString("Unix syslog delivery error");
+	return nil, os.ErrorString("Unix syslog delivery error")
 }
 
 // Write sends a log message to the syslog daemon.
@@ -84,51 +84,51 @@ func (w *Writer) Write(b []byte) (int, os.Error) {
 	if w.priority > LOG_DEBUG || w.priority < LOG_EMERG {
 		return 0, os.EINVAL
 	}
-	return fmt.Fprintf(w.conn, "<%d>%s: %s\n", w.priority, w.prefix, b);
+	return fmt.Fprintf(w.conn, "<%d>%s: %s\n", w.priority, w.prefix, b)
 }
 
 func (w *Writer) writeString(p Priority, s string) (int, os.Error) {
 	return fmt.Fprintf(w.conn, "<%d>%s: %s\n", p, w.prefix, s)
 }
 
-func (w *Writer) Close() os.Error	{ return w.conn.Close() }
+func (w *Writer) Close() os.Error { return w.conn.Close() }
 
 // Emerg logs a message using the LOG_EMERG priority.
 func (w *Writer) Emerg(m string) (err os.Error) {
-	_, err = w.writeString(LOG_EMERG, m);
-	return err;
+	_, err = w.writeString(LOG_EMERG, m)
+	return err
 }
 // Crit logs a message using the LOG_CRIT priority.
 func (w *Writer) Crit(m string) (err os.Error) {
-	_, err = w.writeString(LOG_CRIT, m);
-	return err;
+	_, err = w.writeString(LOG_CRIT, m)
+	return err
 }
 // ERR logs a message using the LOG_ERR priority.
 func (w *Writer) Err(m string) (err os.Error) {
-	_, err = w.writeString(LOG_ERR, m);
-	return err;
+	_, err = w.writeString(LOG_ERR, m)
+	return err
 }
 
 // Warning logs a message using the LOG_WARNING priority.
 func (w *Writer) Warning(m string) (err os.Error) {
-	_, err = w.writeString(LOG_WARNING, m);
-	return err;
+	_, err = w.writeString(LOG_WARNING, m)
+	return err
 }
 
 // Notice logs a message using the LOG_NOTICE priority.
 func (w *Writer) Notice(m string) (err os.Error) {
-	_, err = w.writeString(LOG_NOTICE, m);
-	return err;
+	_, err = w.writeString(LOG_NOTICE, m)
+	return err
 }
 // Info logs a message using the LOG_INFO priority.
 func (w *Writer) Info(m string) (err os.Error) {
-	_, err = w.writeString(LOG_INFO, m);
-	return err;
+	_, err = w.writeString(LOG_INFO, m)
+	return err
 }
 // Debug logs a message using the LOG_DEBUG priority.
 func (w *Writer) Debug(m string) (err os.Error) {
-	_, err = w.writeString(LOG_DEBUG, m);
-	return err;
+	_, err = w.writeString(LOG_DEBUG, m)
+	return err
 }
 
 // NewLogger provides an object that implements the full log.Logger interface,
@@ -136,9 +136,9 @@ func (w *Writer) Debug(m string) (err os.Error) {
 // priority will be used for all messages sent using this interface.
 // All messages are logged with priority p.
 func NewLogger(p Priority, flag int) *log.Logger {
-	s, err := New(p, "");
+	s, err := New(p, "")
 	if err != nil {
 		return nil
 	}
-	return log.New(s, nil, "", flag);
+	return log.New(s, nil, "", flag)
 }
diff --git a/src/pkg/syslog/syslog_test.go b/src/pkg/syslog/syslog_test.go
index 7ecb289b5e..a2801c502d 100644
--- a/src/pkg/syslog/syslog_test.go
+++ b/src/pkg/syslog/syslog_test.go
@@ -4,91 +4,91 @@
 package syslog
 
 import (
-	"io";
-	"log";
-	"net";
-	"testing";
+	"io"
+	"log"
+	"net"
+	"testing"
 )
 
 var serverAddr string
 
 func runSyslog(c net.PacketConn, done chan<- string) {
-	var buf [4096]byte;
-	var rcvd string = "";
+	var buf [4096]byte
+	var rcvd string = ""
 	for {
-		n, _, err := c.ReadFrom(&buf);
+		n, _, err := c.ReadFrom(&buf)
 		if err != nil || n == 0 {
 			break
 		}
-		rcvd += string(buf[0:n]);
+		rcvd += string(buf[0:n])
 	}
-	done <- rcvd;
+	done <- rcvd
 }
 
 func startServer(done chan<- string) {
-	c, e := net.ListenPacket("udp", ":0");
+	c, e := net.ListenPacket("udp", ":0")
 	if e != nil {
 		log.Exitf("net.ListenPacket failed udp :0 %v", e)
 	}
-	serverAddr = c.LocalAddr().String();
-	c.SetReadTimeout(10e6);	// 10ms
-	go runSyslog(c, done);
+	serverAddr = c.LocalAddr().String()
+	c.SetReadTimeout(10e6) // 10ms
+	go runSyslog(c, done)
 }
 
 func TestNew(t *testing.T) {
-	s, err := New(LOG_INFO, "");
+	s, err := New(LOG_INFO, "")
 	if err != nil {
 		t.Fatalf("New() failed: %s", err)
 	}
 	// Don't send any messages.
-	s.Close();
+	s.Close()
 }
 
 func TestNewLogger(t *testing.T) {
-	f := NewLogger(LOG_INFO, 0);
+	f := NewLogger(LOG_INFO, 0)
 	if f == nil {
 		t.Errorf("NewLogger() failed\n")
 	}
 }
 
 func TestDial(t *testing.T) {
-	l, err := Dial("", "", LOG_ERR, "syslog_test");
+	l, err := Dial("", "", LOG_ERR, "syslog_test")
 	if err != nil {
 		t.Fatalf("Dial() failed: %s", err)
 	}
-	l.Close();
+	l.Close()
 }
 
 func TestUDPDial(t *testing.T) {
-	done := make(chan string);
-	startServer(done);
-	l, err := Dial("udp", serverAddr, LOG_INFO, "syslog_test");
+	done := make(chan string)
+	startServer(done)
+	l, err := Dial("udp", serverAddr, LOG_INFO, "syslog_test")
 	if err != nil {
 		t.Fatalf("syslog.Dial() failed: %s", err)
 	}
-	msg := "udp test";
-	l.Info(msg);
-	expected := "<6>syslog_test: udp test\n";
-	rcvd := <-done;
+	msg := "udp test"
+	l.Info(msg)
+	expected := "<6>syslog_test: udp test\n"
+	rcvd := <-done
 	if rcvd != expected {
 		t.Fatalf("s.Info() = '%q', but wanted '%q'", rcvd, expected)
 	}
 }
 
 func TestWrite(t *testing.T) {
-	done := make(chan string);
-	startServer(done);
-	l, err := Dial("udp", serverAddr, LOG_ERR, "syslog_test");
+	done := make(chan string)
+	startServer(done)
+	l, err := Dial("udp", serverAddr, LOG_ERR, "syslog_test")
 	if err != nil {
 		t.Fatalf("syslog.Dial() failed: %s", err)
 	}
-	msg := "write test";
-	_, err = io.WriteString(l, msg);
+	msg := "write test"
+	_, err = io.WriteString(l, msg)
 	if err != nil {
 		t.Fatalf("WriteString() failed: %s", err)
 	}
-	expected := "<3>syslog_test: write test\n";
-	rcvd := <-done;
+	expected := "<3>syslog_test: write test\n"
+	rcvd := <-done
 	if rcvd != expected {
 		t.Fatalf("s.Info() = '%q', but wanted '%q'", rcvd, expected)
 	}
diff --git a/src/pkg/tabwriter/tabwriter.go b/src/pkg/tabwriter/tabwriter.go
index 316950c233..1f3ed9e33c 100644
--- a/src/pkg/tabwriter/tabwriter.go
+++ b/src/pkg/tabwriter/tabwriter.go
@@ -11,11 +11,11 @@
 package tabwriter
 
 import (
-	"bytes";
-	"container/vector";
-	"io";
-	"os";
-	"utf8";
+	"bytes"
+	"container/vector"
+	"io"
+	"os"
+	"utf8"
 )
 
 
@@ -28,9 +28,9 @@ import (
 // ('\t') terminated cell.
 //
 type cell struct {
-	size	int;	// cell size in bytes
-	width	int;	// cell width in runes
-	htab	bool;	// true if the cell is terminated by an htab ('\t')
+	size  int  // cell size in bytes
+	width int  // cell width in runes
+	htab  bool // true if the cell is terminated by an htab ('\t')
 }
 
 
@@ -78,38 +78,38 @@ type cell struct {
 //
 type Writer struct {
 	// configuration
-	output		io.Writer;
-	minwidth	int;
-	tabwidth	int;
-	padding		int;
-	padbytes	[8]byte;
-	flags		uint;
+	output   io.Writer
+	minwidth int
+	tabwidth int
+	padding  int
+	padbytes [8]byte
+	flags    uint
 
 	// current state
-	buf	bytes.Buffer;		// collected text excluding tabs or line breaks
-	pos	int;			// buffer position up to which cell.width of incomplete cell has been computed
-	cell	cell;			// current incomplete cell; cell.width is up to buf[pos] excluding ignored sections
-	endChar	byte;			// terminating char of escaped sequence (Escape for escapes, '>', ';' for HTML tags/entities, or 0)
-	lines	vector.Vector;		// list of lines; each line is a list of cells
-	widths	vector.IntVector;	// list of column widths in runes - re-used during formatting
+	buf     bytes.Buffer     // collected text excluding tabs or line breaks
+	pos     int              // buffer position up to which cell.width of incomplete cell has been computed
+	cell    cell             // current incomplete cell; cell.width is up to buf[pos] excluding ignored sections
+	endChar byte             // terminating char of escaped sequence (Escape for escapes, '>', ';' for HTML tags/entities, or 0)
+	lines   vector.Vector    // list of lines; each line is a list of cells
+	widths  vector.IntVector // list of column widths in runes - re-used during formatting
 }
 
 
-func (b *Writer) addLine()	{ b.lines.Push(new(vector.Vector)) }
+func (b *Writer) addLine() { b.lines.Push(new(vector.Vector)) }
 
 
-func (b *Writer) line(i int) *vector.Vector	{ return b.lines.At(i).(*vector.Vector) }
+func (b *Writer) line(i int) *vector.Vector { return b.lines.At(i).(*vector.Vector) }
 
 
 // Reset the current state.
 func (b *Writer) reset() {
-	b.buf.Reset();
-	b.pos = 0;
-	b.cell = cell{};
-	b.endChar = 0;
-	b.lines.Resize(0, 0);
-	b.widths.Resize(0, 0);
-	b.addLine();
+	b.buf.Reset()
+	b.pos = 0
+	b.cell = cell{}
+	b.endChar = 0
+	b.lines.Resize(0, 0)
+	b.widths.Resize(0, 0)
+	b.addLine()
 }
 
 
@@ -141,23 +141,23 @@ func (b *Writer) reset() {
 const (
 	// Ignore html tags and treat entities (starting with '&'
 	// and ending in ';') as single characters (width = 1).
-	FilterHTML	uint	= 1 << iota;
+	FilterHTML uint = 1 << iota
 
 	// Force right-alignment of cell content.
 	// Default is left-alignment.
-	AlignRight;
+	AlignRight
 
 	// Handle empty columns as if they were not present in
 	// the input in the first place.
-	DiscardEmptyColumns;
+	DiscardEmptyColumns
 
 	// Always use tabs for indentation columns (i.e., padding of
 	// leading empty cells on the left) independent of padchar.
-	TabIndent;
+	TabIndent
 
 	// Print a vertical bar ('|') between columns (after formatting).
 	// Discarded colums appear as zero-width columns ("||").
-	Debug;
+	Debug
 )
 
 
@@ -185,10 +185,10 @@ func (b *Writer) Init(output io.Writer, minwidth, tabwidth, padding int, padchar
 	if minwidth < 0 || tabwidth < 0 || padding < 0 {
 		panic("negative minwidth, tabwidth, or padding")
 	}
-	b.output = output;
-	b.minwidth = minwidth;
-	b.tabwidth = tabwidth;
-	b.padding = padding;
+	b.output = output
+	b.minwidth = minwidth
+	b.tabwidth = tabwidth
+	b.padding = padding
 	for i := range b.padbytes {
 		b.padbytes[i] = padchar
 	}
@@ -196,37 +196,37 @@ func (b *Writer) Init(output io.Writer, minwidth, tabwidth, padding int, padchar
 		// tab padding enforces left-alignment
 		flags &^= AlignRight
 	}
-	b.flags = flags;
+	b.flags = flags
 
-	b.reset();
+	b.reset()
 
-	return b;
+	return b
 }
 
 
 // debugging support (keep code around)
 func (b *Writer) dump() {
-	pos := 0;
+	pos := 0
 	for i := 0; i < b.lines.Len(); i++ {
-		line := b.line(i);
-		print("(", i, ") ");
+		line := b.line(i)
+		print("(", i, ") ")
 		for j := 0; j < line.Len(); j++ {
-			c := line.At(j).(cell);
-			print("[", string(b.buf.Bytes()[pos:pos+c.size]), "]");
-			pos += c.size;
+			c := line.At(j).(cell)
+			print("[", string(b.buf.Bytes()[pos:pos+c.size]), "]")
+			pos += c.size
 		}
-		print("\n");
+		print("\n")
 	}
-	print("\n");
+	print("\n")
 }
 
 
 func (b *Writer) write0(buf []byte) os.Error {
-	n, err := b.output.Write(buf);
+	n, err := b.output.Write(buf)
 	if n != len(buf) && err == nil {
 		err = os.EIO
 	}
-	return err;
+	return err
 }
 
 
@@ -235,15 +235,15 @@ func (b *Writer) writeN(src []byte, n int) os.Error {
 		if err := b.write0(src); err != nil {
 			return err
 		}
-		n -= len(src);
+		n -= len(src)
 	}
-	return b.write0(src[0:n]);
+	return b.write0(src[0:n])
 }
 
 
 var (
-	newline	= []byte{'\n'};
-	tabs	= []byte{'\t', '\t', '\t', '\t', '\t', '\t', '\t', '\t'};
+	newline = []byte{'\n'}
+	tabs    = []byte{'\t', '\t', '\t', '\t', '\t', '\t', '\t', '\t'}
 )
 
 
@@ -251,34 +251,34 @@ func (b *Writer) writePadding(textw, cellw int, useTabs bool) os.Error {
 	if b.padbytes[0] == '\t' || useTabs {
 		// padding is done with tabs
 		if b.tabwidth == 0 {
-			return nil	// tabs have no width - can't do any padding
+			return nil // tabs have no width - can't do any padding
 		}
 		// make cellw the smallest multiple of b.tabwidth
-		cellw = (cellw + b.tabwidth - 1) / b.tabwidth * b.tabwidth;
-		n := cellw - textw;	// amount of padding
+		cellw = (cellw + b.tabwidth - 1) / b.tabwidth * b.tabwidth
+		n := cellw - textw // amount of padding
 		if n < 0 {
 			panic("internal error")
 		}
-		return b.writeN(tabs, (n+b.tabwidth-1)/b.tabwidth);
+		return b.writeN(tabs, (n+b.tabwidth-1)/b.tabwidth)
 	}
 
 	// padding is done with non-tab characters
-	return b.writeN(&b.padbytes, cellw-textw);
+	return b.writeN(&b.padbytes, cellw-textw)
 }
 
 
 var vbar = []byte{'|'}
 
 func (b *Writer) writeLines(pos0 int, line0, line1 int) (pos int, err os.Error) {
-	pos = pos0;
+	pos = pos0
 	for i := line0; i < line1; i++ {
-		line := b.line(i);
+		line := b.line(i)
 
 		// if TabIndent is set, use tabs to pad leading empty cells
-		useTabs := b.flags&TabIndent != 0;
+		useTabs := b.flags&TabIndent != 0
 
 		for j := 0; j < line.Len(); j++ {
-			c := line.At(j).(cell);
+			c := line.At(j).(cell)
 
 			if j > 0 && b.flags&Debug != 0 {
 				if err = b.write0(vbar); err != nil {
@@ -295,18 +295,18 @@ func (b *Writer) writeLines(pos0 int, line0, line1 int) (pos int, err os.Error)
 				}
 			} else {
 				// non-empty cell
-				useTabs = false;
-				if b.flags&AlignRight == 0 {	// align left
+				useTabs = false
+				if b.flags&AlignRight == 0 { // align left
 					if err = b.write0(b.buf.Bytes()[pos : pos+c.size]); err != nil {
 						return
 					}
-					pos += c.size;
+					pos += c.size
 					if j < b.widths.Len() {
 						if err = b.writePadding(c.width, b.widths.At(j), false); err != nil {
 							return
 						}
 					}
-				} else {	// align right
+				} else { // align right
 					if j < b.widths.Len() {
 						if err = b.writePadding(c.width, b.widths.At(j), false); err != nil {
 							return
@@ -315,7 +315,7 @@ func (b *Writer) writeLines(pos0 int, line0, line1 int) (pos int, err os.Error)
 					if err = b.write0(b.buf.Bytes()[pos : pos+c.size]); err != nil {
 						return
 					}
-					pos += c.size;
+					pos += c.size
 				}
 			}
 		}
@@ -326,7 +326,7 @@ func (b *Writer) writeLines(pos0 int, line0, line1 int) (pos int, err os.Error)
 			if err = b.write0(b.buf.Bytes()[pos : pos+b.cell.size]); err != nil {
 				return
 			}
-			pos += b.cell.size;
+			pos += b.cell.size
 		} else {
 			// not the last line - write newline
 			if err = b.write0(newline); err != nil {
@@ -334,7 +334,7 @@ func (b *Writer) writeLines(pos0 int, line0, line1 int) (pos int, err os.Error)
 			}
 		}
 	}
-	return;
+	return
 }
 
 
@@ -344,10 +344,10 @@ func (b *Writer) writeLines(pos0 int, line0, line1 int) (pos int, err os.Error)
 // line1 and an error, if any.
 //
 func (b *Writer) format(pos0 int, line0, line1 int) (pos int, err os.Error) {
-	pos = pos0;
-	column := b.widths.Len();
+	pos = pos0
+	column := b.widths.Len()
 	for this := line0; this < line1; this++ {
-		line := b.line(this);
+		line := b.line(this)
 
 		if column < line.Len()-1 {
 			// cell exists in this column => this line
@@ -361,16 +361,16 @@ func (b *Writer) format(pos0 int, line0, line1 int) (pos int, err os.Error) {
 			if pos, err = b.writeLines(pos, line0, this); err != nil {
 				return
 			}
-			line0 = this;
+			line0 = this
 
 			// column block begin
-			width := b.minwidth;	// minimal column width
-			discardable := true;	// true if all cells in this column are empty and "soft"
+			width := b.minwidth // minimal column width
+			discardable := true // true if all cells in this column are empty and "soft"
 			for ; this < line1; this++ {
-				line = b.line(this);
+				line = b.line(this)
 				if column < line.Len()-1 {
 					// cell exists in this column
-					c := line.At(column).(cell);
+					c := line.At(column).(cell)
 					// update width
 					if w := c.width + b.padding; w > width {
 						width = w
@@ -392,29 +392,29 @@ func (b *Writer) format(pos0 int, line0, line1 int) (pos int, err os.Error) {
 
 			// format and print all columns to the right of this column
 			// (we know the widths of this column and all columns to the left)
-			b.widths.Push(width);
-			pos, err = b.format(pos, line0, this);
-			b.widths.Pop();
-			line0 = this;
+			b.widths.Push(width)
+			pos, err = b.format(pos, line0, this)
+			b.widths.Pop()
+			line0 = this
 		}
 	}
 
 	// print unprinted lines until end
-	return b.writeLines(pos, line0, line1);
+	return b.writeLines(pos, line0, line1)
 }
 
 
 // Append text to current cell.
 func (b *Writer) append(text []byte) {
-	b.buf.Write(text);
-	b.cell.size += len(text);
+	b.buf.Write(text)
+	b.cell.size += len(text)
 }
 
 
 // Update the cell width.
 func (b *Writer) updateWidth() {
-	b.cell.width += utf8.RuneCount(b.buf.Bytes()[b.pos:b.buf.Len()]);
-	b.pos = b.buf.Len();
+	b.cell.width += utf8.RuneCount(b.buf.Bytes()[b.pos:b.buf.Len()])
+	b.pos = b.buf.Len()
 }
 
 
@@ -450,12 +450,12 @@ func (b *Writer) endEscape() {
 	switch b.endChar {
 	case Escape:
 		b.updateWidth()
-	case '>':	// tag of zero width
+	case '>': // tag of zero width
 	case ';':
-		b.cell.width++	// entity, count as one rune
+		b.cell.width++ // entity, count as one rune
 	}
-	b.pos = b.buf.Len();
-	b.endChar = 0;
+	b.pos = b.buf.Len()
+	b.endChar = 0
 }
 
 
@@ -463,11 +463,11 @@ func (b *Writer) endEscape() {
 // current line. Returns the number of cells in that line.
 //
 func (b *Writer) terminateCell(htab bool) int {
-	b.cell.htab = htab;
-	line := b.line(b.lines.Len() - 1);
-	line.Push(b.cell);
-	b.cell = cell{};
-	return line.Len();
+	b.cell.htab = htab
+	line := b.line(b.lines.Len() - 1)
+	line.Push(b.cell)
+	b.cell = cell{}
+	return line.Len()
 }
 
 
@@ -483,16 +483,16 @@ func (b *Writer) Flush() os.Error {
 			// inside escape - terminate it even if incomplete
 			b.endEscape()
 		}
-		b.terminateCell(false);
+		b.terminateCell(false)
 	}
 
 	// format contents of buffer
-	_, err := b.format(0, 0, b.lines.Len());
+	_, err := b.format(0, 0, b.lines.Len())
 
 	// reset, even in the presence of errors
-	b.reset();
+	b.reset()
 
-	return err;
+	return err
 }
 
 
@@ -502,20 +502,20 @@ func (b *Writer) Flush() os.Error {
 //
 func (b *Writer) Write(buf []byte) (n int, err os.Error) {
 	// split text into cells
-	n = 0;
+	n = 0
 	for i, ch := range buf {
 		if b.endChar == 0 {
 			// outside escape
 			switch ch {
 			case '\t', '\v', '\n', '\f':
 				// end of cell
-				b.append(buf[n:i]);
-				b.updateWidth();
-				n = i + 1;	// ch consumed
-				ncells := b.terminateCell(ch == '\t');
+				b.append(buf[n:i])
+				b.updateWidth()
+				n = i + 1 // ch consumed
+				ncells := b.terminateCell(ch == '\t')
 				if ch == '\n' || ch == '\f' {
 					// terminate line
-					b.addLine();
+					b.addLine()
 					if ch == '\f' || ncells == 1 {
 						// A '\f' always forces a flush. Otherwise, if the previous
 						// line has only one cell which does not have an impact on
@@ -530,19 +530,19 @@ func (b *Writer) Write(buf []byte) (n int, err os.Error) {
 
 			case Escape:
 				// start of escaped sequence
-				b.append(buf[n:i]);
-				b.updateWidth();
-				n = i + 1;	// exclude Escape
-				b.startEscape(Escape);
+				b.append(buf[n:i])
+				b.updateWidth()
+				n = i + 1 // exclude Escape
+				b.startEscape(Escape)
 
 			case '<', '&':
 				// possibly an html tag/entity
 				if b.flags&FilterHTML != 0 {
 					// begin of tag/entity
-					b.append(buf[n:i]);
-					b.updateWidth();
-					n = i;
-					b.startEscape(ch);
+					b.append(buf[n:i])
+					b.updateWidth()
+					n = i
+					b.startEscape(ch)
 				}
 			}
 
@@ -550,21 +550,21 @@ func (b *Writer) Write(buf []byte) (n int, err os.Error) {
 			// inside escape
 			if ch == b.endChar {
 				// end of tag/entity
-				j := i + 1;
+				j := i + 1
 				if ch == Escape {
-					j = i	// exclude Escape
+					j = i // exclude Escape
 				}
-				b.append(buf[n:j]);
-				n = i + 1;	// ch consumed
-				b.endEscape();
+				b.append(buf[n:j])
+				n = i + 1 // ch consumed
+				b.endEscape()
 			}
 		}
 	}
 
 	// append leftover text
-	b.append(buf[n:]);
-	n = len(buf);
-	return;
+	b.append(buf[n:])
+	n = len(buf)
+	return
 }
 
 
diff --git a/src/pkg/tabwriter/tabwriter_test.go b/src/pkg/tabwriter/tabwriter_test.go
index 8503ddd249..c8823cfef4 100644
--- a/src/pkg/tabwriter/tabwriter_test.go
+++ b/src/pkg/tabwriter/tabwriter_test.go
@@ -5,43 +5,43 @@
 package tabwriter
 
 import (
-	"io";
-	"os";
-	"testing";
+	"io"
+	"os"
+	"testing"
 )
 
 
 type buffer struct {
-	a []byte;
+	a []byte
 }
 
 
-func (b *buffer) init(n int)	{ b.a = make([]byte, n)[0:0] }
+func (b *buffer) init(n int) { b.a = make([]byte, n)[0:0] }
 
 
-func (b *buffer) clear()	{ b.a = b.a[0:0] }
+func (b *buffer) clear() { b.a = b.a[0:0] }
 
 
 func (b *buffer) Write(buf []byte) (written int, err os.Error) {
-	n := len(b.a);
-	m := len(buf);
+	n := len(b.a)
+	m := len(buf)
 	if n+m <= cap(b.a) {
-		b.a = b.a[0 : n+m];
+		b.a = b.a[0 : n+m]
 		for i := 0; i < m; i++ {
 			b.a[n+i] = buf[i]
 		}
 	} else {
 		panicln("buffer.Write: buffer too small", n, m, cap(b.a))
 	}
-	return len(buf), nil;
+	return len(buf), nil
 }
 
 
-func (b *buffer) String() string	{ return string(b.a) }
+func (b *buffer) String() string { return string(b.a) }
 
 
 func write(t *testing.T, testname string, w *Writer, src string) {
-	written, err := io.WriteString(w, src);
+	written, err := io.WriteString(w, src)
 	if err != nil {
 		t.Errorf("--- test: %s\n--- src:\n%s\n--- write error: %v\n", testname, src, err)
 	}
@@ -52,12 +52,12 @@ func write(t *testing.T, testname string, w *Writer, src string) {
 
 
 func verify(t *testing.T, testname string, w *Writer, b *buffer, src, expected string) {
-	err := w.Flush();
+	err := w.Flush()
 	if err != nil {
 		t.Errorf("--- test: %s\n--- src:\n%s\n--- flush error: %v\n", testname, src, err)
 	}
 
-	res := b.String();
+	res := b.String()
 	if res != expected {
 		t.Errorf("--- test: %s\n--- src:\n%s\n--- found:\n%s\n--- expected:\n%s\n", testname, src, res, expected)
 	}
@@ -65,43 +65,43 @@ func verify(t *testing.T, testname string, w *Writer, b *buffer, src, expected s
 
 
 func check(t *testing.T, testname string, minwidth, tabwidth, padding int, padchar byte, flags uint, src, expected string) {
-	var b buffer;
-	b.init(1000);
+	var b buffer
+	b.init(1000)
 
-	var w Writer;
-	w.Init(&b, minwidth, tabwidth, padding, padchar, flags);
+	var w Writer
+	w.Init(&b, minwidth, tabwidth, padding, padchar, flags)
 
 	// write all at once
-	b.clear();
-	write(t, testname, &w, src);
-	verify(t, testname, &w, &b, src, expected);
+	b.clear()
+	write(t, testname, &w, src)
+	verify(t, testname, &w, &b, src, expected)
 
 	// write byte-by-byte
-	b.clear();
+	b.clear()
 	for i := 0; i < len(src); i++ {
 		write(t, testname, &w, src[i:i+1])
 	}
-	verify(t, testname, &w, &b, src, expected);
+	verify(t, testname, &w, &b, src, expected)
 
 	// write using Fibonacci slice sizes
-	b.clear();
+	b.clear()
 	for i, d := 0, 0; i < len(src); {
-		write(t, testname, &w, src[i:i+d]);
-		i, d = i+d, d+1;
+		write(t, testname, &w, src[i:i+d])
+		i, d = i+d, d+1
 		if i+d > len(src) {
 			d = len(src) - i
 		}
 	}
-	verify(t, testname, &w, &b, src, expected);
+	verify(t, testname, &w, &b, src, expected)
 }
 
 
 type entry struct {
-	testname			string;
-	minwidth, tabwidth, padding	int;
-	padchar				byte;
-	flags				uint;
-	src, expected			string;
+	testname                    string
+	minwidth, tabwidth, padding int
+	padchar                     byte
+	flags                       uint
+	src, expected               string
 }
 
 
@@ -144,7 +144,7 @@ var tests = []entry{
 	entry{
 		"1e esc",
 		8, 0, 1, '.', 0,
-		"abc\xff\tdef",	// unterminated escape
+		"abc\xff\tdef", // unterminated escape
 		"abc\tdef",
 	},
 
@@ -165,14 +165,14 @@ var tests = []entry{
 	entry{
 		"4a",
 		8, 0, 1, '.', 0,
-		"\t",	// '\t' terminates an empty cell on last line - nothing to print
+		"\t", // '\t' terminates an empty cell on last line - nothing to print
 		"",
 	},
 
 	entry{
 		"4b",
 		8, 0, 1, '.', AlignRight,
-		"\t",	// '\t' terminates an empty cell on last line - nothing to print
+		"\t", // '\t' terminates an empty cell on last line - nothing to print
 		"",
 	},
 
@@ -294,7 +294,7 @@ var tests = []entry{
 	entry{
 		"9b",
 		1, 0, 0, '.', FilterHTML,
-		"1\t2<!---\f--->\t3\t4\n" +	// \f inside HTML is ignored
+		"1\t2<!---\f--->\t3\t4\n" + // \f inside HTML is ignored
 			"11\t222\t3333\t44444\n",
 
 		"1.2<!---\f--->..3...4\n" +
@@ -304,7 +304,7 @@ var tests = []entry{
 	entry{
 		"9c",
 		1, 0, 0, '.', 0,
-		"1\t2\t3\t4\f" +	// \f causes a newline and flush
+		"1\t2\t3\t4\f" + // \f causes a newline and flush
 			"11\t222\t3333\t44444\n",
 
 		"1234\n" +
@@ -314,7 +314,7 @@ var tests = []entry{
 	entry{
 		"9c debug",
 		1, 0, 0, '.', Debug,
-		"1\t2\t3\t4\f" +	// \f causes a newline and flush
+		"1\t2\t3\t4\f" + // \f causes a newline and flush
 			"11\t222\t3333\t44444\n",
 
 		"1|2|3|4\n" +
@@ -489,7 +489,7 @@ var tests = []entry{
 	entry{
 		"15b",
 		4, 0, 0, '.', DiscardEmptyColumns,
-		"a\t\tb",	// htabs - do not discard column
+		"a\t\tb", // htabs - do not discard column
 		"a.......b",
 	},
 
@@ -558,7 +558,7 @@ var tests = []entry{
 	entry{
 		"16c",
 		100, 100, 0, '\t', DiscardEmptyColumns,
-		"a\tb\t\td\n" +	// hard tabs - do not discard column
+		"a\tb\t\td\n" + // hard tabs - do not discard column
 			"a\tb\t\td\te\n" +
 			"a\n" +
 			"a\tb\tc\td\n" +
@@ -574,7 +574,7 @@ var tests = []entry{
 	entry{
 		"16c debug",
 		100, 100, 0, '\t', DiscardEmptyColumns | Debug,
-		"a\tb\t\td\n" +	// hard tabs - do not discard column
+		"a\tb\t\td\n" + // hard tabs - do not discard column
 			"a\tb\t\td\te\n" +
 			"a\n" +
 			"a\tb\tc\td\n" +
diff --git a/src/pkg/template/format.go b/src/pkg/template/format.go
index f357ab2a1b..dd49b1bb5a 100644
--- a/src/pkg/template/format.go
+++ b/src/pkg/template/format.go
@@ -7,10 +7,10 @@
 package template
 
 import (
-	"bytes";
-	"fmt";
-	"io";
-	"strings";
+	"bytes"
+	"fmt"
+	"io"
+	"strings"
 )
 
 // StringFormatter formats into the default string representation.
@@ -19,25 +19,25 @@ import (
 // under the name "" in your custom formatter map.
 func StringFormatter(w io.Writer, value interface{}, format string) {
 	if b, ok := value.([]byte); ok {
-		w.Write(b);
-		return;
+		w.Write(b)
+		return
 	}
-	fmt.Fprint(w, value);
+	fmt.Fprint(w, value)
 }
 
 var (
-	esc_quot	= strings.Bytes("&#34;");	// shorter than "&quot;"
-	esc_apos	= strings.Bytes("&#39;");	// shorter than "&apos;"
-	esc_amp		= strings.Bytes("&amp;");
-	esc_lt		= strings.Bytes("&lt;");
-	esc_gt		= strings.Bytes("&gt;");
+	esc_quot = strings.Bytes("&#34;") // shorter than "&quot;"
+	esc_apos = strings.Bytes("&#39;") // shorter than "&apos;"
+	esc_amp  = strings.Bytes("&amp;")
+	esc_lt   = strings.Bytes("&lt;")
+	esc_gt   = strings.Bytes("&gt;")
 )
 
 // HTMLEscape writes to w the properly escaped HTML equivalent
 // of the plain text data s.
 func HTMLEscape(w io.Writer, s []byte) {
-	var esc []byte;
-	last := 0;
+	var esc []byte
+	last := 0
 	for i, c := range s {
 		switch c {
 		case '"':
@@ -53,16 +53,16 @@ func HTMLEscape(w io.Writer, s []byte) {
 		default:
 			continue
 		}
-		w.Write(s[last:i]);
-		w.Write(esc);
-		last = i + 1;
+		w.Write(s[last:i])
+		w.Write(esc)
+		last = i + 1
 	}
-	w.Write(s[last:]);
+	w.Write(s[last:])
 }
 
 // HTMLFormatter formats arbitrary values for HTML
 func HTMLFormatter(w io.Writer, value interface{}, format string) {
-	var b bytes.Buffer;
-	fmt.Fprint(&b, value);
-	HTMLEscape(w, b.Bytes());
+	var b bytes.Buffer
+	fmt.Fprint(&b, value)
+	HTMLEscape(w, b.Bytes())
 }
diff --git a/src/pkg/template/template.go b/src/pkg/template/template.go
index 9bba532c62..8e39d802ee 100644
--- a/src/pkg/template/template.go
+++ b/src/pkg/template/template.go
@@ -57,23 +57,23 @@
 package template
 
 import (
-	"container/vector";
-	"fmt";
-	"io";
-	"os";
-	"reflect";
-	"runtime";
-	"strings";
+	"container/vector"
+	"fmt"
+	"io"
+	"os"
+	"reflect"
+	"runtime"
+	"strings"
 )
 
 // Errors returned during parsing and execution.  Users may extract the information and reformat
 // if they desire.
 type Error struct {
-	Line	int;
-	Msg	string;
+	Line int
+	Msg  string
 }
 
-func (e *Error) String() string	{ return fmt.Sprintf("line %d: %s", e.Line, e.Msg) }
+func (e *Error) String() string { return fmt.Sprintf("line %d: %s", e.Line, e.Msg) }
 
 // Most of the literals are aces.
 var lbrace = []byte{'{'}
@@ -83,15 +83,15 @@ var tab = []byte{'\t'}
 
 // The various types of "tokens", which are plain text or (usually) brace-delimited descriptors
 const (
-	tokAlternates	= iota;
-	tokComment;
-	tokEnd;
-	tokLiteral;
-	tokOr;
-	tokRepeated;
-	tokSection;
-	tokText;
-	tokVariable;
+	tokAlternates = iota
+	tokComment
+	tokEnd
+	tokLiteral
+	tokOr
+	tokRepeated
+	tokSection
+	tokText
+	tokVariable
 )
 
 // FormatterMap is the type describing the mapping from formatter
@@ -110,59 +110,59 @@ var builtins = FormatterMap{
 
 // Plain text.
 type textElement struct {
-	text []byte;
+	text []byte
 }
 
 // A literal such as .meta-left or .meta-right
 type literalElement struct {
-	text []byte;
+	text []byte
 }
 
 // A variable to be evaluated
 type variableElement struct {
-	linenum		int;
-	name		string;
-	formatter	string;	// TODO(r): implement pipelines
+	linenum   int
+	name      string
+	formatter string // TODO(r): implement pipelines
 }
 
 // A .section block, possibly with a .or
 type sectionElement struct {
-	linenum	int;	// of .section itself
-	field	string;	// cursor field for this block
-	start	int;	// first element
-	or	int;	// first element of .or block
-	end	int;	// one beyond last element
+	linenum int    // of .section itself
+	field   string // cursor field for this block
+	start   int    // first element
+	or      int    // first element of .or block
+	end     int    // one beyond last element
 }
 
 // A .repeated block, possibly with a .or and a .alternates
 type repeatedElement struct {
-	sectionElement;		// It has the same structure...
-	altstart	int;	// ... except for alternates
-	altend		int;
+	sectionElement     // It has the same structure...
+	altstart       int // ... except for alternates
+	altend         int
 }
 
 // Template is the type that represents a template definition.
 // It is unchanged after parsing.
 type Template struct {
-	fmap	FormatterMap;	// formatters for variables
+	fmap FormatterMap // formatters for variables
 	// Used during parsing:
-	ldelim, rdelim	[]byte;		// delimiters; default {}
-	buf		[]byte;		// input text to process
-	p		int;		// position in buf
-	linenum		int;		// position in input
-	error		os.Error;	// error during parsing (only)
+	ldelim, rdelim []byte   // delimiters; default {}
+	buf            []byte   // input text to process
+	p              int      // position in buf
+	linenum        int      // position in input
+	error          os.Error // error during parsing (only)
 	// Parsed results:
-	elems	*vector.Vector;
+	elems *vector.Vector
 }
 
 // Internal state for executing a Template.  As we evaluate the struct,
 // the data item descends into the fields associated with sections, etc.
 // Parent is used to walk upwards to find variables higher in the tree.
 type state struct {
-	parent	*state;		// parent in hierarchy
-	data	reflect.Value;	// the driver data for this section etc.
-	wr	io.Writer;	// where to send output
-	errors	chan os.Error;	// for reporting errors during execute
+	parent *state        // parent in hierarchy
+	data   reflect.Value // the driver data for this section etc.
+	wr     io.Writer     // where to send output
+	errors chan os.Error // for reporting errors during execute
 }
 
 func (parent *state) clone(data reflect.Value) *state {
@@ -172,18 +172,18 @@ func (parent *state) clone(data reflect.Value) *state {
 // New creates a new template with the specified formatter map (which
 // may be nil) to define auxiliary functions for formatting variables.
 func New(fmap FormatterMap) *Template {
-	t := new(Template);
-	t.fmap = fmap;
-	t.ldelim = lbrace;
-	t.rdelim = rbrace;
-	t.elems = new(vector.Vector);
-	return t;
+	t := new(Template)
+	t.fmap = fmap
+	t.ldelim = lbrace
+	t.rdelim = rbrace
+	t.elems = new(vector.Vector)
+	return t
 }
 
 // Report error and stop executing.  The line number must be provided explicitly.
 func (t *Template) execError(st *state, line int, err string, args ...) {
-	st.errors <- &Error{line, fmt.Sprintf(err, args)};
-	runtime.Goexit();
+	st.errors <- &Error{line, fmt.Sprintf(err, args)}
+	runtime.Goexit()
 }
 
 // Report error, save in Template to terminate parsing.
@@ -195,12 +195,12 @@ func (t *Template) parseError(err string, args ...) {
 // -- Lexical analysis
 
 // Is c a white space character?
-func white(c uint8) bool	{ return c == ' ' || c == '\t' || c == '\r' || c == '\n' }
+func white(c uint8) bool { return c == ' ' || c == '\t' || c == '\r' || c == '\n' }
 
 // Safely, does s[n:n+len(t)] == t?
 func equal(s []byte, n int, t []byte) bool {
-	b := s[n:];
-	if len(t) > len(b) {	// not enough space left for a match.
+	b := s[n:]
+	if len(t) > len(b) { // not enough space left for a match.
 		return false
 	}
 	for i, c := range t {
@@ -208,7 +208,7 @@ func equal(s []byte, n int, t []byte) bool {
 			return false
 		}
 	}
-	return true;
+	return true
 }
 
 // nextItem returns the next item from the input buffer.  If the returned
@@ -218,179 +218,179 @@ func equal(s []byte, n int, t []byte) bool {
 // Action tokens on a line by themselves drop the white space on
 // either side, up to and including the newline.
 func (t *Template) nextItem() []byte {
-	sawLeft := false;	// are we waiting for an opening delimiter?
-	special := false;	// is this a {.foo} directive, which means trim white space?
+	sawLeft := false // are we waiting for an opening delimiter?
+	special := false // is this a {.foo} directive, which means trim white space?
 	// Delete surrounding white space if this {.foo} is the only thing on the line.
-	trim_white := t.p == 0 || t.buf[t.p-1] == '\n';
-	only_white := true;	// we have seen only white space so far
-	var i int;
-	start := t.p;
+	trim_white := t.p == 0 || t.buf[t.p-1] == '\n'
+	only_white := true // we have seen only white space so far
+	var i int
+	start := t.p
 Loop:
 	for i = t.p; i < len(t.buf); i++ {
 		switch {
 		case t.buf[i] == '\n':
-			t.linenum++;
-			i++;
-			break Loop;
+			t.linenum++
+			i++
+			break Loop
 		case white(t.buf[i]):
 			// white space, do nothing
-		case !sawLeft && equal(t.buf, i, t.ldelim):	// sawLeft checked because delims may be equal
+		case !sawLeft && equal(t.buf, i, t.ldelim): // sawLeft checked because delims may be equal
 			// anything interesting already on the line?
 			if !only_white {
 				break Loop
 			}
 			// is it a directive or comment?
-			j := i + len(t.ldelim);	// position after delimiter
+			j := i + len(t.ldelim) // position after delimiter
 			if j+1 < len(t.buf) && (t.buf[j] == '.' || t.buf[j] == '#') {
-				special = true;
+				special = true
 				if trim_white && only_white {
 					start = i
 				}
-			} else if i > t.p {	// have some text accumulated so stop before delimiter
+			} else if i > t.p { // have some text accumulated so stop before delimiter
 				break Loop
 			}
-			sawLeft = true;
-			i = j - 1;
+			sawLeft = true
+			i = j - 1
 		case equal(t.buf, i, t.rdelim):
 			if !sawLeft {
-				t.parseError("unmatched closing delimiter");
-				return nil;
+				t.parseError("unmatched closing delimiter")
+				return nil
 			}
-			sawLeft = false;
-			i += len(t.rdelim);
-			break Loop;
+			sawLeft = false
+			i += len(t.rdelim)
+			break Loop
 		default:
 			only_white = false
 		}
 	}
 	if sawLeft {
-		t.parseError("unmatched opening delimiter");
-		return nil;
+		t.parseError("unmatched opening delimiter")
+		return nil
 	}
-	item := t.buf[start:i];
+	item := t.buf[start:i]
 	if special && trim_white {
 		// consume trailing white space
 		for ; i < len(t.buf) && white(t.buf[i]); i++ {
 			if t.buf[i] == '\n' {
-				t.linenum++;
-				i++;
-				break;	// stop after newline
+				t.linenum++
+				i++
+				break // stop after newline
 			}
 		}
 	}
-	t.p = i;
-	return item;
+	t.p = i
+	return item
 }
 
 // Turn a byte array into a white-space-split array of strings.
 func words(buf []byte) []string {
-	s := make([]string, 0, 5);
-	p := 0;	// position in buf
+	s := make([]string, 0, 5)
+	p := 0 // position in buf
 	// one word per loop
 	for i := 0; ; i++ {
 		// skip white space
 		for ; p < len(buf) && white(buf[p]); p++ {
 		}
 		// grab word
-		start := p;
+		start := p
 		for ; p < len(buf) && !white(buf[p]); p++ {
 		}
-		if start == p {	// no text left
+		if start == p { // no text left
 			break
 		}
 		if i == cap(s) {
-			ns := make([]string, 2*cap(s));
+			ns := make([]string, 2*cap(s))
 			for j := range s {
 				ns[j] = s[j]
 			}
-			s = ns;
+			s = ns
 		}
-		s = s[0 : i+1];
-		s[i] = string(buf[start:p]);
+		s = s[0 : i+1]
+		s[i] = string(buf[start:p])
 	}
-	return s;
+	return s
 }
 
 // Analyze an item and return its token type and, if it's an action item, an array of
 // its constituent words.
 func (t *Template) analyze(item []byte) (tok int, w []string) {
 	// item is known to be non-empty
-	if !equal(item, 0, t.ldelim) {	// doesn't start with left delimiter
-		tok = tokText;
-		return;
+	if !equal(item, 0, t.ldelim) { // doesn't start with left delimiter
+		tok = tokText
+		return
 	}
-	if !equal(item, len(item)-len(t.rdelim), t.rdelim) {	// doesn't end with right delimiter
-		t.parseError("internal error: unmatched opening delimiter");	// lexing should prevent this
-		return;
+	if !equal(item, len(item)-len(t.rdelim), t.rdelim) { // doesn't end with right delimiter
+		t.parseError("internal error: unmatched opening delimiter") // lexing should prevent this
+		return
 	}
-	if len(item) <= len(t.ldelim)+len(t.rdelim) {	// no contents
-		t.parseError("empty directive");
-		return;
+	if len(item) <= len(t.ldelim)+len(t.rdelim) { // no contents
+		t.parseError("empty directive")
+		return
 	}
 	// Comment
 	if item[len(t.ldelim)] == '#' {
-		tok = tokComment;
-		return;
+		tok = tokComment
+		return
 	}
 	// Split into words
-	w = words(item[len(t.ldelim) : len(item)-len(t.rdelim)]);	// drop final delimiter
+	w = words(item[len(t.ldelim) : len(item)-len(t.rdelim)]) // drop final delimiter
 	if len(w) == 0 {
-		t.parseError("empty directive");
-		return;
+		t.parseError("empty directive")
+		return
 	}
 	if len(w) == 1 && w[0][0] != '.' {
-		tok = tokVariable;
-		return;
+		tok = tokVariable
+		return
 	}
 	switch w[0] {
 	case ".meta-left", ".meta-right", ".space", ".tab":
-		tok = tokLiteral;
-		return;
+		tok = tokLiteral
+		return
 	case ".or":
-		tok = tokOr;
-		return;
+		tok = tokOr
+		return
 	case ".end":
-		tok = tokEnd;
-		return;
+		tok = tokEnd
+		return
 	case ".section":
 		if len(w) != 2 {
-			t.parseError("incorrect fields for .section: %s", item);
-			return;
+			t.parseError("incorrect fields for .section: %s", item)
+			return
 		}
-		tok = tokSection;
-		return;
+		tok = tokSection
+		return
 	case ".repeated":
 		if len(w) != 3 || w[1] != "section" {
-			t.parseError("incorrect fields for .repeated: %s", item);
-			return;
+			t.parseError("incorrect fields for .repeated: %s", item)
+			return
 		}
-		tok = tokRepeated;
-		return;
+		tok = tokRepeated
+		return
 	case ".alternates":
 		if len(w) != 2 || w[1] != "with" {
-			t.parseError("incorrect fields for .alternates: %s", item);
-			return;
+			t.parseError("incorrect fields for .alternates: %s", item)
+			return
 		}
-		tok = tokAlternates;
-		return;
+		tok = tokAlternates
+		return
 	}
-	t.parseError("bad directive: %s", item);
-	return;
+	t.parseError("bad directive: %s", item)
+	return
 }
 
 // -- Parsing
 
 // Allocate a new variable-evaluation element.
 func (t *Template) newVariable(name_formatter string) (v *variableElement) {
-	name := name_formatter;
-	formatter := "";
-	bar := strings.Index(name_formatter, "|");
+	name := name_formatter
+	formatter := ""
+	bar := strings.Index(name_formatter, "|")
 	if bar >= 0 {
-		name = name_formatter[0:bar];
-		formatter = name_formatter[bar+1:];
+		name = name_formatter[0:bar]
+		formatter = name_formatter[bar+1:]
 	}
 	// Probably ok, so let's build it.
-	v = &variableElement{t.linenum, name, formatter};
+	v = &variableElement{t.linenum, name, formatter}
 
 	// We could remember the function address here and avoid the lookup later,
 	// but it's more dynamic to let the user change the map contents underfoot.
@@ -406,24 +406,24 @@ func (t *Template) newVariable(name_formatter string) (v *variableElement) {
 	if _, ok := builtins[formatter]; ok {
 		return
 	}
-	t.parseError("unknown formatter: %s", formatter);
-	return;
+	t.parseError("unknown formatter: %s", formatter)
+	return
 }
 
 // Grab the next item.  If it's simple, just append it to the template.
 // Otherwise return its details.
 func (t *Template) parseSimple(item []byte) (done bool, tok int, w []string) {
-	tok, w = t.analyze(item);
+	tok, w = t.analyze(item)
 	if t.error != nil {
 		return
 	}
-	done = true;	// assume for simplicity
+	done = true // assume for simplicity
 	switch tok {
 	case tokComment:
 		return
 	case tokText:
-		t.elems.Push(&textElement{item});
-		return;
+		t.elems.Push(&textElement{item})
+		return
 	case tokLiteral:
 		switch w[0] {
 		case ".meta-left":
@@ -435,40 +435,40 @@ func (t *Template) parseSimple(item []byte) (done bool, tok int, w []string) {
 		case ".tab":
 			t.elems.Push(&literalElement{tab})
 		default:
-			t.parseError("internal error: unknown literal: %s", w[0]);
-			return;
+			t.parseError("internal error: unknown literal: %s", w[0])
+			return
 		}
-		return;
+		return
 	case tokVariable:
-		t.elems.Push(t.newVariable(w[0]));
-		return;
+		t.elems.Push(t.newVariable(w[0]))
+		return
 	}
-	return false, tok, w;
+	return false, tok, w
 }
 
 // parseRepeated and parseSection are mutually recursive
 
 func (t *Template) parseRepeated(words []string) *repeatedElement {
-	r := new(repeatedElement);
-	t.elems.Push(r);
-	r.linenum = t.linenum;
-	r.field = words[2];
+	r := new(repeatedElement)
+	t.elems.Push(r)
+	r.linenum = t.linenum
+	r.field = words[2]
 	// Scan section, collecting true and false (.or) blocks.
-	r.start = t.elems.Len();
-	r.or = -1;
-	r.altstart = -1;
-	r.altend = -1;
+	r.start = t.elems.Len()
+	r.or = -1
+	r.altstart = -1
+	r.altend = -1
 Loop:
 	for t.error == nil {
-		item := t.nextItem();
+		item := t.nextItem()
 		if t.error != nil {
 			break
 		}
 		if len(item) == 0 {
-			t.parseError("missing .end for .repeated section");
-			break;
+			t.parseError("missing .end for .repeated section")
+			break
 		}
-		done, tok, w := t.parseSimple(item);
+		done, tok, w := t.parseSimple(item)
 		if t.error != nil {
 			break
 		}
@@ -480,28 +480,28 @@ Loop:
 			break Loop
 		case tokOr:
 			if r.or >= 0 {
-				t.parseError("extra .or in .repeated section");
-				break Loop;
+				t.parseError("extra .or in .repeated section")
+				break Loop
 			}
-			r.altend = t.elems.Len();
-			r.or = t.elems.Len();
+			r.altend = t.elems.Len()
+			r.or = t.elems.Len()
 		case tokSection:
 			t.parseSection(w)
 		case tokRepeated:
 			t.parseRepeated(w)
 		case tokAlternates:
 			if r.altstart >= 0 {
-				t.parseError("extra .alternates in .repeated section");
-				break Loop;
+				t.parseError("extra .alternates in .repeated section")
+				break Loop
 			}
 			if r.or >= 0 {
-				t.parseError(".alternates inside .or block in .repeated section");
-				break Loop;
+				t.parseError(".alternates inside .or block in .repeated section")
+				break Loop
 			}
-			r.altstart = t.elems.Len();
+			r.altstart = t.elems.Len()
 		default:
-			t.parseError("internal error: unknown repeated section item: %s", item);
-			break Loop;
+			t.parseError("internal error: unknown repeated section item: %s", item)
+			break Loop
 		}
 	}
 	if t.error != nil {
@@ -510,29 +510,29 @@ Loop:
 	if r.altend < 0 {
 		r.altend = t.elems.Len()
 	}
-	r.end = t.elems.Len();
-	return r;
+	r.end = t.elems.Len()
+	return r
 }
 
 func (t *Template) parseSection(words []string) *sectionElement {
-	s := new(sectionElement);
-	t.elems.Push(s);
-	s.linenum = t.linenum;
-	s.field = words[1];
+	s := new(sectionElement)
+	t.elems.Push(s)
+	s.linenum = t.linenum
+	s.field = words[1]
 	// Scan section, collecting true and false (.or) blocks.
-	s.start = t.elems.Len();
-	s.or = -1;
+	s.start = t.elems.Len()
+	s.or = -1
 Loop:
 	for t.error == nil {
-		item := t.nextItem();
+		item := t.nextItem()
 		if t.error != nil {
 			break
 		}
 		if len(item) == 0 {
-			t.parseError("missing .end for .section");
-			break;
+			t.parseError("missing .end for .section")
+			break
 		}
-		done, tok, w := t.parseSimple(item);
+		done, tok, w := t.parseSimple(item)
 		if t.error != nil {
 			break
 		}
@@ -544,10 +544,10 @@ Loop:
 			break Loop
 		case tokOr:
 			if s.or >= 0 {
-				t.parseError("extra .or in .section");
-				break Loop;
+				t.parseError("extra .or in .section")
+				break Loop
 			}
-			s.or = t.elems.Len();
+			s.or = t.elems.Len()
 		case tokSection:
 			t.parseSection(w)
 		case tokRepeated:
@@ -561,20 +561,20 @@ Loop:
 	if t.error != nil {
 		return nil
 	}
-	s.end = t.elems.Len();
-	return s;
+	s.end = t.elems.Len()
+	return s
 }
 
 func (t *Template) parse() {
 	for t.error == nil {
-		item := t.nextItem();
+		item := t.nextItem()
 		if t.error != nil {
 			break
 		}
 		if len(item) == 0 {
 			break
 		}
-		done, tok, w := t.parseSimple(item);
+		done, tok, w := t.parseSimple(item)
 		if done {
 			continue
 		}
@@ -603,34 +603,34 @@ func (st *state) findVar(s string) reflect.Value {
 	if s == "@" {
 		return st.data
 	}
-	data := st.data;
-	elems := strings.Split(s, ".", 0);
+	data := st.data
+	elems := strings.Split(s, ".", 0)
 	for i := 0; i < len(elems); i++ {
 		// Look up field; data must be a struct or map.
-		data = reflect.Indirect(data);
+		data = reflect.Indirect(data)
 		if data == nil {
 			return nil
 		}
 
 		switch typ := data.Type().(type) {
 		case *reflect.StructType:
-			field, ok := typ.FieldByName(elems[i]);
+			field, ok := typ.FieldByName(elems[i])
 			if !ok {
 				return nil
 			}
-			data = data.(*reflect.StructValue).FieldByIndex(field.Index);
+			data = data.(*reflect.StructValue).FieldByIndex(field.Index)
 		case *reflect.MapType:
 			data = data.(*reflect.MapValue).Elem(reflect.NewValue(elems[i]))
 		default:
 			return nil
 		}
 	}
-	return data;
+	return data
 }
 
 // Is there no data to look at?
 func empty(v reflect.Value) bool {
-	v = reflect.Indirect(v);
+	v = reflect.Indirect(v)
 	if v == nil {
 		return true
 	}
@@ -646,63 +646,63 @@ func empty(v reflect.Value) bool {
 	case *reflect.SliceValue:
 		return v.Len() == 0
 	}
-	return true;
+	return true
 }
 
 // Look up a variable, up through the parent if necessary.
 func (t *Template) varValue(name string, st *state) reflect.Value {
-	field := st.findVar(name);
+	field := st.findVar(name)
 	if field == nil {
 		if st.parent == nil {
 			t.execError(st, t.linenum, "name not found: %s", name)
 		}
-		return t.varValue(name, st.parent);
+		return t.varValue(name, st.parent)
 	}
-	return field;
+	return field
 }
 
 // Evaluate a variable, looking up through the parent if necessary.
 // If it has a formatter attached ({var|formatter}) run that too.
 func (t *Template) writeVariable(v *variableElement, st *state) {
-	formatter := v.formatter;
-	val := t.varValue(v.name, st).Interface();
+	formatter := v.formatter
+	val := t.varValue(v.name, st).Interface()
 	// is it in user-supplied map?
 	if t.fmap != nil {
 		if fn, ok := t.fmap[formatter]; ok {
-			fn(st.wr, val, formatter);
-			return;
+			fn(st.wr, val, formatter)
+			return
 		}
 	}
 	// is it in builtin map?
 	if fn, ok := builtins[formatter]; ok {
-		fn(st.wr, val, formatter);
-		return;
+		fn(st.wr, val, formatter)
+		return
 	}
-	t.execError(st, v.linenum, "missing formatter %s for variable %s", formatter, v.name);
+	t.execError(st, v.linenum, "missing formatter %s for variable %s", formatter, v.name)
 }
 
 // Execute element i.  Return next index to execute.
 func (t *Template) executeElement(i int, st *state) int {
 	switch elem := t.elems.At(i).(type) {
 	case *textElement:
-		st.wr.Write(elem.text);
-		return i + 1;
+		st.wr.Write(elem.text)
+		return i + 1
 	case *literalElement:
-		st.wr.Write(elem.text);
-		return i + 1;
+		st.wr.Write(elem.text)
+		return i + 1
 	case *variableElement:
-		t.writeVariable(elem, st);
-		return i + 1;
+		t.writeVariable(elem, st)
+		return i + 1
 	case *sectionElement:
-		t.executeSection(elem, st);
-		return elem.end;
+		t.executeSection(elem, st)
+		return elem.end
 	case *repeatedElement:
-		t.executeRepeated(elem, st);
-		return elem.end;
+		t.executeRepeated(elem, st)
+		return elem.end
 	}
-	e := t.elems.At(i);
-	t.execError(st, 0, "internal error: bad directive in execute: %v %T\n", reflect.NewValue(e).Interface(), e);
-	return 0;
+	e := t.elems.At(i)
+	t.execError(st, 0, "internal error: bad directive in execute: %v %T\n", reflect.NewValue(e).Interface(), e)
+	return 0
 }
 
 // Execute the template.
@@ -715,12 +715,12 @@ func (t *Template) execute(start, end int, st *state) {
 // Execute a .section
 func (t *Template) executeSection(s *sectionElement, st *state) {
 	// Find driver data for this section.  It must be in the current struct.
-	field := t.varValue(s.field, st);
+	field := t.varValue(s.field, st)
 	if field == nil {
 		t.execError(st, s.linenum, ".section: cannot find field %s in %s", s.field, reflect.Indirect(st.data).Type())
 	}
-	st = st.clone(field);
-	start, end := s.start, s.or;
+	st = st.clone(field)
+	start, end := s.start, s.or
 	if !empty(field) {
 		// Execute the normal block.
 		if end < 0 {
@@ -728,7 +728,7 @@ func (t *Template) executeSection(s *sectionElement, st *state) {
 		}
 	} else {
 		// Execute the .or block.  If it's missing, do nothing.
-		start, end = s.or, s.end;
+		start, end = s.or, s.end
 		if start < 0 {
 			return
 		}
@@ -741,42 +741,42 @@ func (t *Template) executeSection(s *sectionElement, st *state) {
 // Return the result of calling the Iter method on v, or nil.
 func iter(v reflect.Value) *reflect.ChanValue {
 	for j := 0; j < v.Type().NumMethod(); j++ {
-		mth := v.Type().Method(j);
-		fv := v.Method(j);
-		ft := fv.Type().(*reflect.FuncType);
+		mth := v.Type().Method(j)
+		fv := v.Method(j)
+		ft := fv.Type().(*reflect.FuncType)
 		// TODO(rsc): NumIn() should return 0 here, because ft is from a curried FuncValue.
 		if mth.Name != "Iter" || ft.NumIn() != 1 || ft.NumOut() != 1 {
 			continue
 		}
-		ct, ok := ft.Out(0).(*reflect.ChanType);
+		ct, ok := ft.Out(0).(*reflect.ChanType)
 		if !ok || ct.Dir()&reflect.RecvDir == 0 {
 			continue
 		}
-		return fv.Call(nil)[0].(*reflect.ChanValue);
+		return fv.Call(nil)[0].(*reflect.ChanValue)
 	}
-	return nil;
+	return nil
 }
 
 // Execute a .repeated section
 func (t *Template) executeRepeated(r *repeatedElement, st *state) {
 	// Find driver data for this section.  It must be in the current struct.
-	field := t.varValue(r.field, st);
+	field := t.varValue(r.field, st)
 	if field == nil {
 		t.execError(st, r.linenum, ".repeated: cannot find field %s in %s", r.field, reflect.Indirect(st.data).Type())
 	}
 
-	start, end := r.start, r.or;
+	start, end := r.start, r.or
 	if end < 0 {
 		end = r.end
 	}
 	if r.altstart >= 0 {
 		end = r.altstart
 	}
-	first := true;
+	first := true
 
 	if array, ok := field.(reflect.ArrayOrSliceValue); ok {
 		for j := 0; j < array.Len(); j++ {
-			newst := st.clone(array.Elem(j));
+			newst := st.clone(array.Elem(j))
 
 			// .alternates between elements
 			if !first && r.altstart >= 0 {
@@ -784,7 +784,7 @@ func (t *Template) executeRepeated(r *repeatedElement, st *state) {
 					i = t.executeElement(i, newst)
 				}
 			}
-			first = false;
+			first = false
 
 			for i := start; i < end; {
 				i = t.executeElement(i, newst)
@@ -792,11 +792,11 @@ func (t *Template) executeRepeated(r *repeatedElement, st *state) {
 		}
 	} else if ch := iter(field); ch != nil {
 		for {
-			e := ch.Recv();
+			e := ch.Recv()
 			if ch.Closed() {
 				break
 			}
-			newst := st.clone(e);
+			newst := st.clone(e)
 
 			// .alternates between elements
 			if !first && r.altstart >= 0 {
@@ -804,7 +804,7 @@ func (t *Template) executeRepeated(r *repeatedElement, st *state) {
 					i = t.executeElement(i, newst)
 				}
 			}
-			first = false;
+			first = false
 
 			for i := start; i < end; {
 				i = t.executeElement(i, newst)
@@ -817,14 +817,14 @@ func (t *Template) executeRepeated(r *repeatedElement, st *state) {
 
 	if first {
 		// Empty. Execute the .or block, once.  If it's missing, do nothing.
-		start, end := r.or, r.end;
+		start, end := r.or, r.end
 		if start >= 0 {
-			newst := st.clone(field);
+			newst := st.clone(field)
 			for i := start; i < end; {
 				i = t.executeElement(i, newst)
 			}
 		}
-		return;
+		return
 	}
 }
 
@@ -838,7 +838,7 @@ func validDelim(d []byte) bool {
 			return false
 		}
 	}
-	return true;
+	return true
 }
 
 // -- Public interface
@@ -853,25 +853,25 @@ func (t *Template) Parse(s string) os.Error {
 	if !validDelim(t.ldelim) || !validDelim(t.rdelim) {
 		return &Error{1, fmt.Sprintf("bad delimiter strings %q %q", t.ldelim, t.rdelim)}
 	}
-	t.buf = strings.Bytes(s);
-	t.p = 0;
-	t.linenum = 1;
-	t.parse();
-	return t.error;
+	t.buf = strings.Bytes(s)
+	t.p = 0
+	t.linenum = 1
+	t.parse()
+	return t.error
 }
 
 // Execute applies a parsed template to the specified data object,
 // generating output to wr.
 func (t *Template) Execute(data interface{}, wr io.Writer) os.Error {
 	// Extract the driver data.
-	val := reflect.NewValue(data);
-	errors := make(chan os.Error);
+	val := reflect.NewValue(data)
+	errors := make(chan os.Error)
 	go func() {
-		t.p = 0;
-		t.execute(0, t.elems.Len(), &state{nil, val, wr, errors});
-		errors <- nil;	// clean return;
-	}();
-	return <-errors;
+		t.p = 0
+		t.execute(0, t.elems.Len(), &state{nil, val, wr, errors})
+		errors <- nil // clean return;
+	}()
+	return <-errors
 }
 
 // SetDelims sets the left and right delimiters for operations in the
@@ -880,8 +880,8 @@ func (t *Template) Execute(data interface{}, wr io.Writer) os.Error {
 // delimiters are very rarely invalid and Parse has the necessary
 // error-handling interface already.
 func (t *Template) SetDelims(left, right string) {
-	t.ldelim = strings.Bytes(left);
-	t.rdelim = strings.Bytes(right);
+	t.ldelim = strings.Bytes(left)
+	t.rdelim = strings.Bytes(right)
 }
 
 // Parse creates a Template with default parameters (such as {} for
@@ -890,19 +890,19 @@ func (t *Template) SetDelims(left, right string) {
 // for formatting variables.  The template is returned. If any errors
 // occur, err will be non-nil.
 func Parse(s string, fmap FormatterMap) (t *Template, err os.Error) {
-	t = New(fmap);
-	err = t.Parse(s);
+	t = New(fmap)
+	err = t.Parse(s)
 	if err != nil {
 		t = nil
 	}
-	return;
+	return
 }
 
 // MustParse is like Parse but panics if the template cannot be parsed.
 func MustParse(s string, fmap FormatterMap) *Template {
-	t, err := Parse(s, fmap);
+	t, err := Parse(s, fmap)
 	if err != nil {
 		panic("template parse error: ", err.String())
 	}
-	return t;
+	return t
 }
diff --git a/src/pkg/template/template_test.go b/src/pkg/template/template_test.go
index 4dfdd71e0a..aa156d2f8f 100644
--- a/src/pkg/template/template_test.go
+++ b/src/pkg/template/template_test.go
@@ -5,65 +5,65 @@
 package template
 
 import (
-	"bytes";
-	"container/vector";
-	"fmt";
-	"io";
-	"strings";
-	"testing";
+	"bytes"
+	"container/vector"
+	"fmt"
+	"io"
+	"strings"
+	"testing"
 )
 
 type Test struct {
-	in, out, err string;
+	in, out, err string
 }
 
 type T struct {
-	item	string;
-	value	string;
+	item  string
+	value string
 }
 
 type U struct {
-	mp map[string]int;
+	mp map[string]int
 }
 
 type S struct {
-	header		string;
-	integer		int;
-	raw		string;
-	innerT		T;
-	innerPointerT	*T;
-	data		[]T;
-	pdata		[]*T;
-	empty		[]*T;
-	emptystring	string;
-	null		[]*T;
-	vec		*vector.Vector;
-	true		bool;
-	false		bool;
-	mp		map[string]string;
-	innermap	U;
-	bytes		[]byte;
+	header        string
+	integer       int
+	raw           string
+	innerT        T
+	innerPointerT *T
+	data          []T
+	pdata         []*T
+	empty         []*T
+	emptystring   string
+	null          []*T
+	vec           *vector.Vector
+	true          bool
+	false         bool
+	mp            map[string]string
+	innermap      U
+	bytes         []byte
 }
 
 var t1 = T{"ItemNumber1", "ValueNumber1"}
 var t2 = T{"ItemNumber2", "ValueNumber2"}
 
 func uppercase(v interface{}) string {
-	s := v.(string);
-	t := "";
+	s := v.(string)
+	t := ""
 	for i := 0; i < len(s); i++ {
-		c := s[i];
+		c := s[i]
 		if 'a' <= c && c <= 'z' {
 			c = c + 'A' - 'a'
 		}
-		t += string(c);
+		t += string(c)
 	}
-	return t;
+	return t
 }
 
 func plus1(v interface{}) string {
-	i := v.(int);
-	return fmt.Sprint(i + 1);
+	i := v.(int)
+	return fmt.Sprint(i + 1)
 }
 
 func writer(f func(interface{}) string) (func(io.Writer, interface{}, string)) {
@@ -306,36 +306,36 @@ var tests = []*Test{
 }
 
 func TestAll(t *testing.T) {
-	s := new(S);
+	s := new(S)
 	// initialized by hand for clarity.
-	s.header = "Header";
-	s.integer = 77;
-	s.raw = "&<>!@ #$%^";
-	s.innerT = t1;
-	s.data = []T{t1, t2};
-	s.pdata = []*T{&t1, &t2};
-	s.empty = []*T{};
-	s.null = nil;
-	s.vec = new(vector.Vector);
-	s.vec.Push("elt1");
-	s.vec.Push("elt2");
-	s.true = true;
-	s.false = false;
-	s.mp = make(map[string]string);
-	s.mp["mapkey"] = "Ahoy!";
-	s.innermap.mp = make(map[string]int);
-	s.innermap.mp["innerkey"] = 55;
-	s.bytes = strings.Bytes("hello");
-
-	var buf bytes.Buffer;
+	s.header = "Header"
+	s.integer = 77
+	s.raw = "&<>!@ #$%^"
+	s.innerT = t1
+	s.data = []T{t1, t2}
+	s.pdata = []*T{&t1, &t2}
+	s.empty = []*T{}
+	s.null = nil
+	s.vec = new(vector.Vector)
+	s.vec.Push("elt1")
+	s.vec.Push("elt2")
+	s.true = true
+	s.false = false
+	s.mp = make(map[string]string)
+	s.mp["mapkey"] = "Ahoy!"
+	s.innermap.mp = make(map[string]int)
+	s.innermap.mp["innerkey"] = 55
+	s.bytes = strings.Bytes("hello")
+
+	var buf bytes.Buffer
 	for _, test := range tests {
-		buf.Reset();
-		tmpl, err := Parse(test.in, formatters);
+		buf.Reset()
+		tmpl, err := Parse(test.in, formatters)
 		if err != nil {
-			t.Error("unexpected parse error:", err);
-			continue;
+			t.Error("unexpected parse error:", err)
+			continue
 		}
-		err = tmpl.Execute(s, &buf);
+		err = tmpl.Execute(s, &buf)
 		if test.err == "" {
 			if err != nil {
 				t.Error("unexpected execute error:", err)
@@ -352,60 +352,60 @@ func TestAll(t *testing.T) {
 }
 
 func TestMapDriverType(t *testing.T) {
-	mp := map[string]string{"footer": "Ahoy!"};
-	tmpl, err := Parse("template: {footer}", nil);
+	mp := map[string]string{"footer": "Ahoy!"}
+	tmpl, err := Parse("template: {footer}", nil)
 	if err != nil {
 		t.Error("unexpected parse error:", err)
 	}
-	var b bytes.Buffer;
-	err = tmpl.Execute(mp, &b);
+	var b bytes.Buffer
+	err = tmpl.Execute(mp, &b)
 	if err != nil {
 		t.Error("unexpected execute error:", err)
 	}
-	s := b.String();
-	expected := "template: Ahoy!";
+	s := b.String()
+	expected := "template: Ahoy!"
 	if s != expected {
 		t.Errorf("failed passing string as data: expected %q got %q", "template: Ahoy!", s)
 	}
 }
 
 func TestStringDriverType(t *testing.T) {
-	tmpl, err := Parse("template: {@}", nil);
+	tmpl, err := Parse("template: {@}", nil)
 	if err != nil {
 		t.Error("unexpected parse error:", err)
 	}
-	var b bytes.Buffer;
-	err = tmpl.Execute("hello", &b);
+	var b bytes.Buffer
+	err = tmpl.Execute("hello", &b)
 	if err != nil {
 		t.Error("unexpected execute error:", err)
 	}
-	s := b.String();
+	s := b.String()
 	if s != "template: hello" {
 		t.Errorf("failed passing string as data: expected %q got %q", "template: hello", s)
 	}
 }
 
 func TestTwice(t *testing.T) {
-	tmpl, err := Parse("template: {@}", nil);
+	tmpl, err := Parse("template: {@}", nil)
 	if err != nil {
 		t.Error("unexpected parse error:", err)
 	}
-	var b bytes.Buffer;
-	err = tmpl.Execute("hello", &b);
+	var b bytes.Buffer
+	err = tmpl.Execute("hello", &b)
 	if err != nil {
 		t.Error("unexpected parse error:", err)
 	}
-	s := b.String();
-	text := "template: hello";
+	s := b.String()
+	text := "template: hello"
 	if s != text {
 		t.Errorf("failed passing string as data: expected %q got %q", text, s)
 	}
-	err = tmpl.Execute("hello", &b);
+	err = tmpl.Execute("hello", &b)
 	if err != nil {
 		t.Error("unexpected parse error:", err)
 	}
-	s = b.String();
-	text += text;
+	s = b.String()
+	text += text
 	if s != text {
 		t.Errorf("failed passing string as data: expected %q got %q", text, s)
 	}
@@ -415,29 +415,29 @@ func TestCustomDelims(t *testing.T) {
 	// try various lengths.  zero should catch error.
 	for i := 0; i < 7; i++ {
 		for j := 0; j < 7; j++ {
-			tmpl := New(nil);
+			tmpl := New(nil)
 			// first two chars deliberately the same to test equal left and right delims
-			ldelim := "$!#$%^&"[0:i];
-			rdelim := "$*&^%$!"[0:j];
-			tmpl.SetDelims(ldelim, rdelim);
+			ldelim := "$!#$%^&"[0:i]
+			rdelim := "$*&^%$!"[0:j]
+			tmpl.SetDelims(ldelim, rdelim)
 			// if braces, this would be template: {@}{.meta-left}{.meta-right}
 			text := "template: " +
 				ldelim + "@" + rdelim +
 				ldelim + ".meta-left" + rdelim +
-				ldelim + ".meta-right" + rdelim;
-			err := tmpl.Parse(text);
+				ldelim + ".meta-right" + rdelim
+			err := tmpl.Parse(text)
 			if err != nil {
-				if i == 0 || j == 0 {	// expected
+				if i == 0 || j == 0 { // expected
 					continue
 				}
-				t.Error("unexpected parse error:", err);
+				t.Error("unexpected parse error:", err)
 			} else if i == 0 || j == 0 {
-				t.Errorf("expected parse error for empty delimiter: %d %d %q %q", i, j, ldelim, rdelim);
-				continue;
+				t.Errorf("expected parse error for empty delimiter: %d %d %q %q", i, j, ldelim, rdelim)
+				continue
 			}
-			var b bytes.Buffer;
-			err = tmpl.Execute("hello", &b);
-			s := b.String();
+			var b bytes.Buffer
+			err = tmpl.Execute("hello", &b)
+			s := b.String()
 			if s != "template: hello"+ldelim+rdelim {
 				t.Errorf("failed delim check(%q %q) %q got %q", ldelim, rdelim, text, s)
 			}
@@ -447,21 +447,21 @@ func TestCustomDelims(t *testing.T) {
 
 // Test that a variable evaluates to the field itself and does not further indirection
 func TestVarIndirection(t *testing.T) {
-	s := new(S);
+	s := new(S)
 	// initialized by hand for clarity.
-	s.innerPointerT = &t1;
+	s.innerPointerT = &t1
 
-	var buf bytes.Buffer;
-	input := "{.section @}{innerPointerT}{.end}";
-	tmpl, err := Parse(input, nil);
+	var buf bytes.Buffer
+	input := "{.section @}{innerPointerT}{.end}"
+	tmpl, err := Parse(input, nil)
 	if err != nil {
 		t.Fatal("unexpected parse error:", err)
 	}
-	err = tmpl.Execute(s, &buf);
+	err = tmpl.Execute(s, &buf)
 	if err != nil {
 		t.Fatal("unexpected execute error:", err)
 	}
-	expect := fmt.Sprintf("%v", &t1);	// output should be hex address of t1
+	expect := fmt.Sprintf("%v", &t1) // output should be hex address of t1
 	if buf.String() != expect {
 		t.Errorf("for %q: expected %q got %q", input, expect, buf.String())
 	}
diff --git a/src/pkg/testing/benchmark.go b/src/pkg/testing/benchmark.go
index b552a13201..6d95c90df0 100644
--- a/src/pkg/testing/benchmark.go
+++ b/src/pkg/testing/benchmark.go
@@ -5,10 +5,10 @@
 package testing
 
 import (
-	"flag";
-	"fmt";
-	"os";
-	"time";
+	"flag"
+	"fmt"
+	"os"
+	"time"
 )
 
 var matchBenchmarks = flag.String("benchmarks", "", "regular expression to select benchmarks to run")
@@ -16,24 +16,24 @@ var matchBenchmarks = flag.String("benchmarks", "", "regular expression to selec
 // An internal type but exported because it is cross-package; part of the implementation
 // of gotest.
 type Benchmark struct {
-	Name	string;
-	F	func(b *B);
+	Name string
+	F    func(b *B)
 }
 
 // B is a type passed to Benchmark functions to manage benchmark
 // timing and to specify the number of iterations to run.
 type B struct {
-	N		int;
-	benchmark	Benchmark;
-	ns		int64;
-	bytes		int64;
-	start		int64;
+	N         int
+	benchmark Benchmark
+	ns        int64
+	bytes     int64
+	start     int64
 }
 
 // StartTimer starts timing a test.  This function is called automatically
 // before a benchmark starts, but it can also used to resume timing after
 // a call to StopTimer.
-func (b *B) StartTimer()	{ b.start = time.Nanoseconds() }
+func (b *B) StartTimer() { b.start = time.Nanoseconds() }
 
 // StopTimer stops timing a test.  This can be used to pause the timer
 // while performing complex initialization that you don't
@@ -42,68 +42,68 @@ func (b *B) StopTimer() {
 	if b.start > 0 {
 		b.ns += time.Nanoseconds() - b.start
 	}
-	b.start = 0;
+	b.start = 0
 }
 
 // ResetTimer stops the timer and sets the elapsed benchmark time to zero.
 func (b *B) ResetTimer() {
-	b.start = 0;
-	b.ns = 0;
+	b.start = 0
+	b.ns = 0
 }
 
 // SetBytes records the number of bytes processed in a single operation.
 // If this is called, the benchmark will report ns/op and MB/s.
-func (b *B) SetBytes(n int64)	{ b.bytes = n }
+func (b *B) SetBytes(n int64) { b.bytes = n }
 
 func (b *B) nsPerOp() int64 {
 	if b.N <= 0 {
 		return 0
 	}
-	return b.ns / int64(b.N);
+	return b.ns / int64(b.N)
 }
 
 // runN runs a single benchmark for the specified number of iterations.
 func (b *B) runN(n int) {
-	b.N = n;
-	b.ResetTimer();
-	b.StartTimer();
-	b.benchmark.F(b);
-	b.StopTimer();
+	b.N = n
+	b.ResetTimer()
+	b.StartTimer()
+	b.benchmark.F(b)
+	b.StopTimer()
 }
 
 func min(x, y int) int {
 	if x > y {
 		return y
 	}
-	return x;
+	return x
 }
 
 // roundDown10 rounds a number down to the nearest power of 10.
 func roundDown10(n int) int {
-	var tens = 0;
+	var tens = 0
 	// tens = floor(log_10(n))
 	for n > 10 {
-		n = n / 10;
-		tens++;
+		n = n / 10
+		tens++
 	}
 	// result = 10^tens
-	result := 1;
+	result := 1
 	for i := 0; i < tens; i++ {
 		result *= 10
 	}
-	return result;
+	return result
 }
 
 // roundUp rounds x up to a number of the form [1eX, 2eX, 5eX].
 func roundUp(n int) int {
-	base := roundDown10(n);
+	base := roundDown10(n)
 	if n < (2 * base) {
 		return 2 * base
 	}
 	if n < (5 * base) {
 		return 5 * base
 	}
-	return 10 * base;
+	return 10 * base
 }
 
 // run times the benchmark function.  It gradually increases the number
@@ -112,11 +112,11 @@ func roundUp(n int) int {
 //		testing.BenchmarkHello	100000		19 ns/op
 func (b *B) run() {
 	// Run the benchmark for a single iteration in case it's expensive.
-	n := 1;
-	b.runN(n);
+	n := 1
+	b.runN(n)
 	// Run the benchmark for at least a second.
 	for b.ns < 1e9 && n < 1e9 {
-		last := n;
+		last := n
 		// Predict iterations/sec.
 		if b.nsPerOp() == 0 {
 			n = 1e9
@@ -125,17 +125,17 @@ func (b *B) run() {
 		}
 		// Run more iterations than we think we'll need for a second (1.5x).
 		// Don't grow too fast in case we had timing errors previously.
-		n = min(int(1.5*float(n)), 100*last);
+		n = min(int(1.5*float(n)), 100*last)
 		// Round up to something easy to read.
-		n = roundUp(n);
-		b.runN(n);
+		n = roundUp(n)
+		b.runN(n)
 	}
-	ns := b.nsPerOp();
-	mb := "";
+	ns := b.nsPerOp()
+	mb := ""
 	if ns > 0 && b.bytes > 0 {
 		mb = fmt.Sprintf("\t%7.2f MB/s", (float64(b.bytes)/1e6)/(float64(ns)/1e9))
 	}
-	fmt.Printf("%s\t%8d\t%10d ns/op%s\n", b.benchmark.Name, b.N, b.nsPerOp(), mb);
+	fmt.Printf("%s\t%8d\t%10d ns/op%s\n", b.benchmark.Name, b.N, b.nsPerOp(), mb)
 }
 
 // An internal function but exported because it is cross-package; part of the implementation
@@ -145,16 +145,16 @@ func RunBenchmarks(benchmarks []Benchmark) {
 	if len(*matchBenchmarks) == 0 {
 		return
 	}
-	re, err := CompileRegexp(*matchBenchmarks);
+	re, err := CompileRegexp(*matchBenchmarks)
 	if err != "" {
-		println("invalid regexp for -benchmarks:", err);
-		os.Exit(1);
+		println("invalid regexp for -benchmarks:", err)
+		os.Exit(1)
 	}
 	for _, Benchmark := range benchmarks {
 		if !re.MatchString(Benchmark.Name) {
 			continue
 		}
-		b := &B{benchmark: Benchmark};
-		b.run();
+		b := &B{benchmark: Benchmark}
+		b.run()
 	}
 }
diff --git a/src/pkg/testing/iotest/logger.go b/src/pkg/testing/iotest/logger.go
index 86812d7e60..5e511bdf6e 100644
--- a/src/pkg/testing/iotest/logger.go
+++ b/src/pkg/testing/iotest/logger.go
@@ -5,24 +5,24 @@
 package iotest
 
 import (
-	"io";
-	"log";
-	"os";
+	"io"
+	"log"
+	"os"
 )
 
 type writeLogger struct {
-	prefix	string;
-	w	io.Writer;
+	prefix string
+	w      io.Writer
 }
 
 func (l *writeLogger) Write(p []byte) (n int, err os.Error) {
-	n, err = l.w.Write(p);
+	n, err = l.w.Write(p)
 	if err != nil {
 		log.Stdoutf("%s %x: %v", l.prefix, p[0:n], err)
 	} else {
 		log.Stdoutf("%s %x", l.prefix, p[0:n])
 	}
-	return;
+	return
 }
 
 // NewWriteLogger returns a writer that behaves like w except
@@ -33,18 +33,18 @@ func NewWriteLogger(prefix string, w io.Writer) io.Writer {
 }
 
 type readLogger struct {
-	prefix	string;
-	r	io.Reader;
+	prefix string
+	r      io.Reader
 }
 
 func (l *readLogger) Read(p []byte) (n int, err os.Error) {
-	n, err = l.r.Read(p);
+	n, err = l.r.Read(p)
 	if err != nil {
 		log.Stdoutf("%s %x: %v", l.prefix, p[0:n], err)
 	} else {
 		log.Stdoutf("%s %x", l.prefix, p[0:n])
 	}
-	return;
+	return
 }
 
 // NewReadLogger returns a reader that behaves like r except
diff --git a/src/pkg/testing/iotest/reader.go b/src/pkg/testing/iotest/reader.go
index 0a1a3f6b3c..647520a09f 100644
--- a/src/pkg/testing/iotest/reader.go
+++ b/src/pkg/testing/iotest/reader.go
@@ -7,31 +7,31 @@
 package iotest
 
 import (
-	"io";
-	"os";
+	"io"
+	"os"
 )
 
 // OneByteReader returns a Reader that implements
 // each non-empty Read by reading one byte from r.
-func OneByteReader(r io.Reader) io.Reader	{ return &oneByteReader{r} }
+func OneByteReader(r io.Reader) io.Reader { return &oneByteReader{r} }
 
 type oneByteReader struct {
-	r io.Reader;
+	r io.Reader
 }
 
 func (r *oneByteReader) Read(p []byte) (int, os.Error) {
 	if len(p) == 0 {
 		return 0, nil
 	}
-	return r.r.Read(p[0:1]);
+	return r.r.Read(p[0:1])
 }
 
 // HalfReader returns a Reader that implements Read
 // by reading half as many requested bytes from r.
-func HalfReader(r io.Reader) io.Reader	{ return &halfReader{r} }
+func HalfReader(r io.Reader) io.Reader { return &halfReader{r} }
 
 type halfReader struct {
-	r io.Reader;
+	r io.Reader
 }
 
 func (r *halfReader) Read(p []byte) (int, os.Error) {
@@ -42,12 +42,12 @@ func (r *halfReader) Read(p []byte) (int, os.Error) {
 // DataErrReader returns a Reader that returns the final
 // error with the last data read, instead of by itself with
 // zero bytes of data.
-func DataErrReader(r io.Reader) io.Reader	{ return &dataErrReader{r, nil, make([]byte, 1024)} }
+func DataErrReader(r io.Reader) io.Reader { return &dataErrReader{r, nil, make([]byte, 1024)} }
 
 type dataErrReader struct {
-	r	io.Reader;
-	unread	[]byte;
-	data	[]byte;
+	r      io.Reader
+	unread []byte
+	data   []byte
 }
 
 func (r *dataErrReader) Read(p []byte) (n int, err os.Error) {
@@ -55,15 +55,15 @@ func (r *dataErrReader) Read(p []byte) (n int, err os.Error) {
 	// one to get data and a second to look for an error.
 	for {
 		if len(r.unread) == 0 {
-			n1, err1 := r.r.Read(r.data);
-			r.unread = r.data[0:n1];
-			err = err1;
+			n1, err1 := r.r.Read(r.data)
+			r.unread = r.data[0:n1]
+			err = err1
 		}
 		if n > 0 {
 			break
 		}
-		n = copy(p, r.unread);
-		r.unread = r.unread[n:];
+		n = copy(p, r.unread)
+		r.unread = r.unread[n:]
 	}
-	return;
+	return
 }
diff --git a/src/pkg/testing/iotest/writer.go b/src/pkg/testing/iotest/writer.go
index 54468a6fe2..71f504ce2a 100644
--- a/src/pkg/testing/iotest/writer.go
+++ b/src/pkg/testing/iotest/writer.go
@@ -5,8 +5,8 @@
 package iotest
 
 import (
-	"io";
-	"os";
+	"io"
+	"os"
 )
 
 // TruncateWriter returns a Writer that writes to w
@@ -16,8 +16,8 @@ func TruncateWriter(w io.Writer, n int64) io.Writer {
 }
 
 type truncateWriter struct {
-	w	io.Writer;
-	n	int64;
+	w io.Writer
+	n int64
 }
 
 func (t *truncateWriter) Write(p []byte) (n int, err os.Error) {
@@ -25,14 +25,14 @@ func (t *truncateWriter) Write(p []byte) (n int, err os.Error) {
 		return len(p), nil
 	}
 	// real write
-	n = len(p);
+	n = len(p)
 	if int64(n) > t.n {
 		n = int(t.n)
 	}
-	n, err = t.w.Write(p[0:n]);
-	t.n -= int64(n);
+	n, err = t.w.Write(p[0:n])
+	t.n -= int64(n)
 	if err == nil {
 		n = len(p)
 	}
-	return;
+	return
 }
diff --git a/src/pkg/testing/quick/quick.go b/src/pkg/testing/quick/quick.go
index 8fe895ee06..ae5cff6e22 100644
--- a/src/pkg/testing/quick/quick.go
+++ b/src/pkg/testing/quick/quick.go
@@ -6,13 +6,13 @@
 package quick
 
 import (
-	"flag";
-	"fmt";
-	"math";
-	"os";
-	"rand";
-	"reflect";
-	"strings";
+	"flag"
+	"fmt"
+	"math"
+	"os"
+	"rand"
+	"reflect"
+	"strings"
 )
 
 var defaultMaxCount *int = flag.Int("quickchecks", 100, "The default number of iterations for each check")
@@ -21,29 +21,29 @@ var defaultMaxCount *int = flag.Int("quickchecks", 100, "The default number of i
 type Generator interface {
 	// Generate returns a random instance of the type on which it is a
 	// method using the size as a size hint.
-	Generate(rand *rand.Rand, size int) reflect.Value;
+	Generate(rand *rand.Rand, size int) reflect.Value
 }
 
 // randFloat32 generates a random float taking the full range of a float32.
 func randFloat32(rand *rand.Rand) float32 {
-	f := rand.Float64() * math.MaxFloat32;
+	f := rand.Float64() * math.MaxFloat32
 	if rand.Int()&1 == 1 {
 		f = -f
 	}
-	return float32(f);
+	return float32(f)
 }
 
 // randFloat64 generates a random float taking the full range of a float64.
 func randFloat64(rand *rand.Rand) float64 {
-	f := rand.Float64();
+	f := rand.Float64()
 	if rand.Int()&1 == 1 {
 		f = -f
 	}
-	return f;
+	return f
 }
 
 // randInt64 returns a random integer taking half the range of an int64.
-func randInt64(rand *rand.Rand) int64	{ return rand.Int63() - 1<<62 }
+func randInt64(rand *rand.Rand) int64 { return rand.Int63() - 1<<62 }
 
 // complexSize is the maximum length of arbitrary values that contain other
 // values.
@@ -81,53 +81,53 @@ func Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool) {
 	case *reflect.IntType:
 		return reflect.NewValue(int(randInt64(rand))), true
 	case *reflect.MapType:
-		numElems := rand.Intn(complexSize);
-		m := reflect.MakeMap(concrete);
+		numElems := rand.Intn(complexSize)
+		m := reflect.MakeMap(concrete)
 		for i := 0; i < numElems; i++ {
-			key, ok1 := Value(concrete.Key(), rand);
-			value, ok2 := Value(concrete.Elem(), rand);
+			key, ok1 := Value(concrete.Key(), rand)
+			value, ok2 := Value(concrete.Elem(), rand)
 			if !ok1 || !ok2 {
 				return nil, false
 			}
-			m.SetElem(key, value);
+			m.SetElem(key, value)
 		}
-		return m, true;
+		return m, true
 	case *reflect.PtrType:
-		v, ok := Value(concrete.Elem(), rand);
+		v, ok := Value(concrete.Elem(), rand)
 		if !ok {
 			return nil, false
 		}
-		p := reflect.MakeZero(concrete);
-		p.(*reflect.PtrValue).PointTo(v);
-		return p, true;
+		p := reflect.MakeZero(concrete)
+		p.(*reflect.PtrValue).PointTo(v)
+		return p, true
 	case *reflect.SliceType:
-		numElems := rand.Intn(complexSize);
-		s := reflect.MakeSlice(concrete, numElems, numElems);
+		numElems := rand.Intn(complexSize)
+		s := reflect.MakeSlice(concrete, numElems, numElems)
 		for i := 0; i < numElems; i++ {
-			v, ok := Value(concrete.Elem(), rand);
+			v, ok := Value(concrete.Elem(), rand)
 			if !ok {
 				return nil, false
 			}
-			s.Elem(i).SetValue(v);
+			s.Elem(i).SetValue(v)
 		}
-		return s, true;
+		return s, true
 	case *reflect.StringType:
-		numChars := rand.Intn(complexSize);
-		codePoints := make([]int, numChars);
+		numChars := rand.Intn(complexSize)
+		codePoints := make([]int, numChars)
 		for i := 0; i < numChars; i++ {
 			codePoints[i] = rand.Intn(0x10ffff)
 		}
-		return reflect.NewValue(string(codePoints)), true;
+		return reflect.NewValue(string(codePoints)), true
 	case *reflect.StructType:
-		s := reflect.MakeZero(t).(*reflect.StructValue);
+		s := reflect.MakeZero(t).(*reflect.StructValue)
 		for i := 0; i < s.NumField(); i++ {
-			v, ok := Value(concrete.Field(i).Type, rand);
+			v, ok := Value(concrete.Field(i).Type, rand)
 			if !ok {
 				return nil, false
 			}
-			s.Field(i).SetValue(v);
+			s.Field(i).SetValue(v)
 		}
-		return s, true;
+		return s, true
 	case *reflect.Uint16Type:
 		return reflect.NewValue(uint16(randInt64(rand))), true
 	case *reflect.Uint32Type:
@@ -144,24 +144,24 @@ func Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool) {
 		return nil, false
 	}
 
-	return;
+	return
 }
 
 // A Config structure contains options for running a test.
 type Config struct {
 	// MaxCount sets the maximum number of iterations. If zero,
 	// MaxCountScale is used.
-	MaxCount	int;
+	MaxCount int
 	// MaxCountScale is a non-negative scale factor applied to the default
 	// maximum. If zero, the default is unchanged.
-	MaxCountScale	float;
+	MaxCountScale float
 	// If non-nil, rand is a source of random numbers. Otherwise a default
 	// pseudo-random source will be used.
-	Rand	*rand.Rand;
+	Rand *rand.Rand
 	// If non-nil, Values is a function which generates a slice of arbitrary
 	// Values that are congruent with the arguments to the function being
 	// tested. Otherwise, Values is used to generate the values.
-	Values	func([]reflect.Value, *rand.Rand);
+	Values func([]reflect.Value, *rand.Rand)
 }
 
 var defaultConfig Config
@@ -171,13 +171,13 @@ func (c *Config) getRand() *rand.Rand {
 	if c.Rand == nil {
 		return rand.New(rand.NewSource(0))
 	}
-	return c.Rand;
+	return c.Rand
 }
 
 // getMaxCount returns the maximum number of iterations to run for a given
 // Config.
 func (c *Config) getMaxCount() (maxCount int) {
-	maxCount = c.MaxCount;
+	maxCount = c.MaxCount
 	if maxCount == 0 {
 		if c.MaxCountScale != 0 {
 			maxCount = int(c.MaxCountScale * float(*defaultMaxCount))
@@ -186,19 +186,19 @@ func (c *Config) getMaxCount() (maxCount int) {
 		}
 	}
 
-	return;
+	return
 }
 
 // A SetupError is the result of an error in the way that check is being
 // used, independent of the functions being tested.
 type SetupError string
 
-func (s SetupError) String() string	{ return string(s) }
+func (s SetupError) String() string { return string(s) }
 
 // A CheckError is the result of Check finding an error.
 type CheckError struct {
-	Count	int;
-	In	[]interface{};
+	Count int
+	In    []interface{}
 }
 
 func (s *CheckError) String() string {
@@ -207,9 +207,9 @@ func (s *CheckError) String() string {
 
 // A CheckEqualError is the result CheckEqual finding an error.
 type CheckEqualError struct {
-	CheckError;
-	Out1	[]interface{};
-	Out2	[]interface{};
+	CheckError
+	Out1 []interface{}
+	Out2 []interface{}
 }
 
 func (s *CheckEqualError) String() string {
@@ -236,38 +236,38 @@ func Check(function interface{}, config *Config) (err os.Error) {
 		config = &defaultConfig
 	}
 
-	f, fType, ok := functionAndType(function);
+	f, fType, ok := functionAndType(function)
 	if !ok {
-		err = SetupError("argument is not a function");
-		return;
+		err = SetupError("argument is not a function")
+		return
 	}
 
 	if fType.NumOut() != 1 {
-		err = SetupError("function returns more than one value.");
-		return;
+		err = SetupError("function returns more than one value.")
+		return
 	}
 	if _, ok := fType.Out(0).(*reflect.BoolType); !ok {
-		err = SetupError("function does not return a bool");
-		return;
+		err = SetupError("function does not return a bool")
+		return
 	}
 
-	arguments := make([]reflect.Value, fType.NumIn());
-	rand := config.getRand();
-	maxCount := config.getMaxCount();
+	arguments := make([]reflect.Value, fType.NumIn())
+	rand := config.getRand()
+	maxCount := config.getMaxCount()
 
 	for i := 0; i < maxCount; i++ {
-		err = arbitraryValues(arguments, fType, config, rand);
+		err = arbitraryValues(arguments, fType, config, rand)
 		if err != nil {
 			return
 		}
 
 		if !f.Call(arguments)[0].(*reflect.BoolValue).Get() {
-			err = &CheckError{i + 1, toInterfaces(arguments)};
-			return;
+			err = &CheckError{i + 1, toInterfaces(arguments)}
+			return
 		}
 	}
 
-	return;
+	return
 }
 
 // CheckEqual looks for an input on which f and g return different results.
@@ -279,85 +279,85 @@ func CheckEqual(f, g interface{}, config *Config) (err os.Error) {
 		config = &defaultConfig
 	}
 
-	x, xType, ok := functionAndType(f);
+	x, xType, ok := functionAndType(f)
 	if !ok {
-		err = SetupError("f is not a function");
-		return;
+		err = SetupError("f is not a function")
+		return
 	}
-	y, yType, ok := functionAndType(g);
+	y, yType, ok := functionAndType(g)
 	if !ok {
-		err = SetupError("g is not a function");
-		return;
+		err = SetupError("g is not a function")
+		return
 	}
 
 	if xType != yType {
-		err = SetupError("functions have different types");
-		return;
+		err = SetupError("functions have different types")
+		return
 	}
 
-	arguments := make([]reflect.Value, xType.NumIn());
-	rand := config.getRand();
-	maxCount := config.getMaxCount();
+	arguments := make([]reflect.Value, xType.NumIn())
+	rand := config.getRand()
+	maxCount := config.getMaxCount()
 
 	for i := 0; i < maxCount; i++ {
-		err = arbitraryValues(arguments, xType, config, rand);
+		err = arbitraryValues(arguments, xType, config, rand)
 		if err != nil {
 			return
 		}
 
-		xOut := toInterfaces(x.Call(arguments));
-		yOut := toInterfaces(y.Call(arguments));
+		xOut := toInterfaces(x.Call(arguments))
+		yOut := toInterfaces(y.Call(arguments))
 
 		if !reflect.DeepEqual(xOut, yOut) {
-			err = &CheckEqualError{CheckError{i + 1, toInterfaces(arguments)}, xOut, yOut};
-			return;
+			err = &CheckEqualError{CheckError{i + 1, toInterfaces(arguments)}, xOut, yOut}
+			return
 		}
 	}
 
-	return;
+	return
 }
 
 // arbitraryValues writes Values to args such that args contains Values
 // suitable for calling f.
 func arbitraryValues(args []reflect.Value, f *reflect.FuncType, config *Config, rand *rand.Rand) (err os.Error) {
 	if config.Values != nil {
-		config.Values(args, rand);
-		return;
+		config.Values(args, rand)
+		return
 	}
 
 	for j := 0; j < len(args); j++ {
-		var ok bool;
-		args[j], ok = Value(f.In(j), rand);
+		var ok bool
+		args[j], ok = Value(f.In(j), rand)
 		if !ok {
-			err = SetupError(fmt.Sprintf("cannot create arbitrary value of type %s for argument %d", f.In(j), j));
-			return;
+			err = SetupError(fmt.Sprintf("cannot create arbitrary value of type %s for argument %d", f.In(j), j))
+			return
 		}
 	}
 
-	return;
+	return
 }
 
 func functionAndType(f interface{}) (v *reflect.FuncValue, t *reflect.FuncType, ok bool) {
-	v, ok = reflect.NewValue(f).(*reflect.FuncValue);
+	v, ok = reflect.NewValue(f).(*reflect.FuncValue)
 	if !ok {
 		return
 	}
-	t = v.Type().(*reflect.FuncType);
-	return;
+	t = v.Type().(*reflect.FuncType)
+	return
 }
 
 func toInterfaces(values []reflect.Value) []interface{} {
-	ret := make([]interface{}, len(values));
+	ret := make([]interface{}, len(values))
 	for i, v := range values {
 		ret[i] = v.Interface()
 	}
-	return ret;
+	return ret
 }
 
 func toString(interfaces []interface{}) string {
-	s := make([]string, len(interfaces));
+	s := make([]string, len(interfaces))
 	for i, v := range interfaces {
 		s[i] = fmt.Sprintf("%#v", v)
 	}
-	return strings.Join(s, ", ");
+	return strings.Join(s, ", ")
 }
diff --git a/src/pkg/testing/quick/quick_test.go b/src/pkg/testing/quick/quick_test.go
index b4037ab550..c7bff962b9 100644
--- a/src/pkg/testing/quick/quick_test.go
+++ b/src/pkg/testing/quick/quick_test.go
@@ -5,60 +5,60 @@
 package quick
 
 import (
-	"rand";
-	"reflect";
-	"testing";
-	"os";
+	"rand"
+	"reflect"
+	"testing"
+	"os"
 )
 
-func fBool(a bool) bool	{ return a }
+func fBool(a bool) bool { return a }
 
-func fFloat32(a float32) float32	{ return a }
+func fFloat32(a float32) float32 { return a }
 
-func fFloat64(a float64) float64	{ return a }
+func fFloat64(a float64) float64 { return a }
 
-func fFloat(a float) float	{ return a }
+func fFloat(a float) float { return a }
 
-func fInt16(a int16) int16	{ return a }
+func fInt16(a int16) int16 { return a }
 
-func fInt32(a int32) int32	{ return a }
+func fInt32(a int32) int32 { return a }
 
-func fInt64(a int64) int64	{ return a }
+func fInt64(a int64) int64 { return a }
 
-func fInt8(a int8) int8	{ return a }
+func fInt8(a int8) int8 { return a }
 
-func fInt(a int) int	{ return a }
+func fInt(a int) int { return a }
 
-func fUInt8(a uint8) uint8	{ return a }
+func fUInt8(a uint8) uint8 { return a }
 
-func fMap(a map[int]int) map[int]int	{ return a }
+func fMap(a map[int]int) map[int]int { return a }
 
-func fSlice(a []byte) []byte	{ return a }
+func fSlice(a []byte) []byte { return a }
 
-func fString(a string) string	{ return a }
+func fString(a string) string { return a }
 
 type TestStruct struct {
-	A	int;
-	B	string;
+	A int
+	B string
 }
 
-func fStruct(a TestStruct) TestStruct	{ return a }
+func fStruct(a TestStruct) TestStruct { return a }
 
-func fUint16(a uint16) uint16	{ return a }
+func fUint16(a uint16) uint16 { return a }
 
-func fUint32(a uint32) uint32	{ return a }
+func fUint32(a uint32) uint32 { return a }
 
-func fUint64(a uint64) uint64	{ return a }
+func fUint64(a uint64) uint64 { return a }
 
-func fUint8(a uint8) uint8	{ return a }
+func fUint8(a uint8) uint8 { return a }
 
-func fUint(a uint) uint	{ return a }
+func fUint(a uint) uint { return a }
 
-func fUintptr(a uintptr) uintptr	{ return a }
+func fUintptr(a uintptr) uintptr { return a }
 
 func fIntptr(a *int) *int {
-	b := *a;
-	return &b;
+	b := *a
+	return &b
 }
 
 func reportError(property string, err os.Error, t *testing.T) {
@@ -68,49 +68,49 @@ func reportError(property string, err os.Error, t *testing.T) {
 }
 
 func TestCheckEqual(t *testing.T) {
-	reportError("fBool", CheckEqual(fBool, fBool, nil), t);
-	reportError("fFloat32", CheckEqual(fFloat32, fFloat32, nil), t);
-	reportError("fFloat64", CheckEqual(fFloat64, fFloat64, nil), t);
-	reportError("fFloat", CheckEqual(fFloat, fFloat, nil), t);
-	reportError("fInt16", CheckEqual(fInt16, fInt16, nil), t);
-	reportError("fInt32", CheckEqual(fInt32, fInt32, nil), t);
-	reportError("fInt64", CheckEqual(fInt64, fInt64, nil), t);
-	reportError("fInt8", CheckEqual(fInt8, fInt8, nil), t);
-	reportError("fInt", CheckEqual(fInt, fInt, nil), t);
-	reportError("fUInt8", CheckEqual(fUInt8, fUInt8, nil), t);
-	reportError("fInt32", CheckEqual(fInt32, fInt32, nil), t);
-	reportError("fMap", CheckEqual(fMap, fMap, nil), t);
-	reportError("fSlice", CheckEqual(fSlice, fSlice, nil), t);
-	reportError("fString", CheckEqual(fString, fString, nil), t);
-	reportError("fStruct", CheckEqual(fStruct, fStruct, nil), t);
-	reportError("fUint16", CheckEqual(fUint16, fUint16, nil), t);
-	reportError("fUint32", CheckEqual(fUint32, fUint32, nil), t);
-	reportError("fUint64", CheckEqual(fUint64, fUint64, nil), t);
-	reportError("fUint8", CheckEqual(fUint8, fUint8, nil), t);
-	reportError("fUint", CheckEqual(fUint, fUint, nil), t);
-	reportError("fUintptr", CheckEqual(fUintptr, fUintptr, nil), t);
-	reportError("fIntptr", CheckEqual(fIntptr, fIntptr, nil), t);
+	reportError("fBool", CheckEqual(fBool, fBool, nil), t)
+	reportError("fFloat32", CheckEqual(fFloat32, fFloat32, nil), t)
+	reportError("fFloat64", CheckEqual(fFloat64, fFloat64, nil), t)
+	reportError("fFloat", CheckEqual(fFloat, fFloat, nil), t)
+	reportError("fInt16", CheckEqual(fInt16, fInt16, nil), t)
+	reportError("fInt32", CheckEqual(fInt32, fInt32, nil), t)
+	reportError("fInt64", CheckEqual(fInt64, fInt64, nil), t)
+	reportError("fInt8", CheckEqual(fInt8, fInt8, nil), t)
+	reportError("fInt", CheckEqual(fInt, fInt, nil), t)
+	reportError("fUInt8", CheckEqual(fUInt8, fUInt8, nil), t)
+	reportError("fInt32", CheckEqual(fInt32, fInt32, nil), t)
+	reportError("fMap", CheckEqual(fMap, fMap, nil), t)
+	reportError("fSlice", CheckEqual(fSlice, fSlice, nil), t)
+	reportError("fString", CheckEqual(fString, fString, nil), t)
+	reportError("fStruct", CheckEqual(fStruct, fStruct, nil), t)
+	reportError("fUint16", CheckEqual(fUint16, fUint16, nil), t)
+	reportError("fUint32", CheckEqual(fUint32, fUint32, nil), t)
+	reportError("fUint64", CheckEqual(fUint64, fUint64, nil), t)
+	reportError("fUint8", CheckEqual(fUint8, fUint8, nil), t)
+	reportError("fUint", CheckEqual(fUint, fUint, nil), t)
+	reportError("fUintptr", CheckEqual(fUintptr, fUintptr, nil), t)
+	reportError("fIntptr", CheckEqual(fIntptr, fIntptr, nil), t)
 }
 
 // This tests that ArbitraryValue is working by checking that all the arbitrary
 // values of type MyStruct have x = 42.
 type myStruct struct {
-	x int;
+	x int
 }
 
 func (m myStruct) Generate(r *rand.Rand, _ int) reflect.Value {
 	return reflect.NewValue(myStruct{x: 42})
 }
 
-func myStructProperty(in myStruct) bool	{ return in.x == 42 }
+func myStructProperty(in myStruct) bool { return in.x == 42 }
 
 func TestCheckProperty(t *testing.T) {
 	reportError("myStructProperty", Check(myStructProperty, nil), t)
 }
 
 func TestFailure(t *testing.T) {
-	f := func(x int) bool { return false };
-	err := Check(f, nil);
+	f := func(x int) bool { return false }
+	err := Check(f, nil)
 	if err == nil {
 		t.Errorf("Check didn't return an error")
 	}
@@ -118,7 +118,7 @@ func TestFailure(t *testing.T) {
 		t.Errorf("Error was not a CheckError: %s", err)
 	}
 
-	err = CheckEqual(fUint, fUint32, nil);
+	err = CheckEqual(fUint, fUint32, nil)
 	if err == nil {
 		t.Errorf("#1 CheckEqual didn't return an error")
 	}
@@ -126,7 +126,7 @@ func TestFailure(t *testing.T) {
 		t.Errorf("#1 Error was not a SetupError: %s", err)
 	}
 
-	err = CheckEqual(func(x, y int) {}, func(x int) {}, nil);
+	err = CheckEqual(func(x, y int) {}, func(x int) {}, nil)
 	if err == nil {
 		t.Errorf("#2 CheckEqual didn't return an error")
 	}
@@ -134,7 +134,7 @@ func TestFailure(t *testing.T) {
 		t.Errorf("#2 Error was not a SetupError: %s", err)
 	}
 
-	err = CheckEqual(func(x int) int { return 0 }, func(x int) int32 { return 0 }, nil);
+	err = CheckEqual(func(x int) int { return 0 }, func(x int) int32 { return 0 }, nil)
 	if err == nil {
 		t.Errorf("#3 CheckEqual didn't return an error")
 	}
diff --git a/src/pkg/testing/regexp.go b/src/pkg/testing/regexp.go
index 3100136cd6..a21d14e6b0 100644
--- a/src/pkg/testing/regexp.go
+++ b/src/pkg/testing/regexp.go
@@ -26,137 +26,137 @@
 package testing
 
 import (
-	"utf8";
+	"utf8"
 )
 
 var debug = false
 
 // Error codes returned by failures to parse an expression.
 var (
-	ErrInternal		= "internal error";
-	ErrUnmatchedLpar	= "unmatched ''";
-	ErrUnmatchedRpar	= "unmatched ''";
-	ErrUnmatchedLbkt	= "unmatched '['";
-	ErrUnmatchedRbkt	= "unmatched ']'";
-	ErrBadRange		= "bad range in character class";
-	ErrExtraneousBackslash	= "extraneous backslash";
-	ErrBadClosure		= "repeated closure **, ++, etc.";
-	ErrBareClosure		= "closure applies to nothing";
-	ErrBadBackslash		= "illegal backslash escape";
+	ErrInternal            = "internal error"
+	ErrUnmatchedLpar       = "unmatched ''"
+	ErrUnmatchedRpar       = "unmatched ''"
+	ErrUnmatchedLbkt       = "unmatched '['"
+	ErrUnmatchedRbkt       = "unmatched ']'"
+	ErrBadRange            = "bad range in character class"
+	ErrExtraneousBackslash = "extraneous backslash"
+	ErrBadClosure          = "repeated closure **, ++, etc."
+	ErrBareClosure         = "closure applies to nothing"
+	ErrBadBackslash        = "illegal backslash escape"
 )
 
 // An instruction executed by the NFA
 type instr interface {
-	kind() int;	// the type of this instruction: _CHAR, _ANY, etc.
-	next() instr;	// the instruction to execute after this one
-	setNext(i instr);
-	index() int;
-	setIndex(i int);
-	print();
+	kind() int   // the type of this instruction: _CHAR, _ANY, etc.
+	next() instr // the instruction to execute after this one
+	setNext(i instr)
+	index() int
+	setIndex(i int)
+	print()
 }
 
 // Fields and methods common to all instructions
 type common struct {
-	_next	instr;
-	_index	int;
+	_next  instr
+	_index int
 }
 
-func (c *common) next() instr		{ return c._next }
-func (c *common) setNext(i instr)	{ c._next = i }
-func (c *common) index() int		{ return c._index }
-func (c *common) setIndex(i int)	{ c._index = i }
+func (c *common) next() instr     { return c._next }
+func (c *common) setNext(i instr) { c._next = i }
+func (c *common) index() int      { return c._index }
+func (c *common) setIndex(i int)  { c._index = i }
 
 // The representation of a compiled regular expression.
 // The public interface is entirely through methods.
 type Regexp struct {
-	expr	string;	// the original expression
-	inst	[]instr;
-	start	instr;
-	nbra	int;	// number of brackets in expression, for subexpressions
+	expr  string // the original expression
+	inst  []instr
+	start instr
+	nbra  int // number of brackets in expression, for subexpressions
 }
 
 const (
-	_START		= iota;	// beginning of program
-	_END;		// end of program: success
-	_BOT;		// '^' beginning of text
-	_EOT;		// '$' end of text
-	_CHAR;		// 'a' regular character
-	_CHARCLASS;	// [a-z] character class
-	_ANY;		// '.' any character including newline
-	_NOTNL;		// [^\n] special case: any character but newline
-	_BRA;		// '(' parenthesized expression
-	_EBRA;		// ')'; end of '(' parenthesized expression
-	_ALT;		// '|' alternation
-	_NOP;		// do nothing; makes it easy to link without patching
+	_START     = iota // beginning of program
+	_END       // end of program: success
+	_BOT       // '^' beginning of text
+	_EOT       // '$' end of text
+	_CHAR      // 'a' regular character
+	_CHARCLASS // [a-z] character class
+	_ANY       // '.' any character including newline
+	_NOTNL     // [^\n] special case: any character but newline
+	_BRA       // '(' parenthesized expression
+	_EBRA      // ')'; end of '(' parenthesized expression
+	_ALT       // '|' alternation
+	_NOP       // do nothing; makes it easy to link without patching
 )
 
 // --- START start of program
 type _Start struct {
-	common;
+	common
 }
 
-func (start *_Start) kind() int	{ return _START }
-func (start *_Start) print()	{ print("start") }
+func (start *_Start) kind() int { return _START }
+func (start *_Start) print()    { print("start") }
 
 // --- END end of program
 type _End struct {
-	common;
+	common
 }
 
-func (end *_End) kind() int	{ return _END }
-func (end *_End) print()	{ print("end") }
+func (end *_End) kind() int { return _END }
+func (end *_End) print()    { print("end") }
 
 // --- BOT beginning of text
 type _Bot struct {
-	common;
+	common
 }
 
-func (bot *_Bot) kind() int	{ return _BOT }
-func (bot *_Bot) print()	{ print("bot") }
+func (bot *_Bot) kind() int { return _BOT }
+func (bot *_Bot) print()    { print("bot") }
 
 // --- EOT end of text
 type _Eot struct {
-	common;
+	common
 }
 
-func (eot *_Eot) kind() int	{ return _EOT }
-func (eot *_Eot) print()	{ print("eot") }
+func (eot *_Eot) kind() int { return _EOT }
+func (eot *_Eot) print()    { print("eot") }
 
 // --- CHAR a regular character
 type _Char struct {
-	common;
-	char	int;
+	common
+	char int
 }
 
-func (char *_Char) kind() int	{ return _CHAR }
-func (char *_Char) print()	{ print("char ", string(char.char)) }
+func (char *_Char) kind() int { return _CHAR }
+func (char *_Char) print()    { print("char ", string(char.char)) }
 
 func newChar(char int) *_Char {
-	c := new(_Char);
-	c.char = char;
-	return c;
+	c := new(_Char)
+	c.char = char
+	return c
 }
 
 // --- CHARCLASS [a-z]
 
 type _CharClass struct {
-	common;
-	char	int;
-	negate	bool;	// is character class negated? ([^a-z])
+	common
+	char   int
+	negate bool // is character class negated? ([^a-z])
 	// stored pairwise: [a-z] is (a,z); x is (x,x):
-	ranges	[]int;
+	ranges []int
 }
 
-func (cclass *_CharClass) kind() int	{ return _CHARCLASS }
+func (cclass *_CharClass) kind() int { return _CHARCLASS }
 
 func (cclass *_CharClass) print() {
-	print("charclass");
+	print("charclass")
 	if cclass.negate {
 		print(" (negated)")
 	}
 	for i := 0; i < len(cclass.ranges); i += 2 {
-		l := cclass.ranges[i];
-		r := cclass.ranges[i+1];
+		l := cclass.ranges[i]
+		r := cclass.ranges[i+1]
 		if l == r {
 			print(" [", string(l), "]")
 		} else {
@@ -167,215 +167,215 @@ func (cclass *_CharClass) print() {
 
 func (cclass *_CharClass) addRange(a, b int) {
 	// range is a through b inclusive
-	n := len(cclass.ranges);
+	n := len(cclass.ranges)
 	if n >= cap(cclass.ranges) {
-		nr := make([]int, n, 2*n);
+		nr := make([]int, n, 2*n)
 		for i, j := range nr {
 			nr[i] = j
 		}
-		cclass.ranges = nr;
+		cclass.ranges = nr
 	}
-	cclass.ranges = cclass.ranges[0 : n+2];
-	cclass.ranges[n] = a;
-	n++;
-	cclass.ranges[n] = b;
-	n++;
+	cclass.ranges = cclass.ranges[0 : n+2]
+	cclass.ranges[n] = a
+	n++
+	cclass.ranges[n] = b
+	n++
 }
 
 func (cclass *_CharClass) matches(c int) bool {
 	for i := 0; i < len(cclass.ranges); i = i + 2 {
-		min := cclass.ranges[i];
-		max := cclass.ranges[i+1];
+		min := cclass.ranges[i]
+		max := cclass.ranges[i+1]
 		if min <= c && c <= max {
 			return !cclass.negate
 		}
 	}
-	return cclass.negate;
+	return cclass.negate
 }
 
 func newCharClass() *_CharClass {
-	c := new(_CharClass);
-	c.ranges = make([]int, 0, 20);
-	return c;
+	c := new(_CharClass)
+	c.ranges = make([]int, 0, 20)
+	return c
 }
 
 // --- ANY any character
 type _Any struct {
-	common;
+	common
 }
 
-func (any *_Any) kind() int	{ return _ANY }
-func (any *_Any) print()	{ print("any") }
+func (any *_Any) kind() int { return _ANY }
+func (any *_Any) print()    { print("any") }
 
 // --- NOTNL any character but newline
 type _NotNl struct {
-	common;
+	common
 }
 
-func (notnl *_NotNl) kind() int	{ return _NOTNL }
-func (notnl *_NotNl) print()	{ print("notnl") }
+func (notnl *_NotNl) kind() int { return _NOTNL }
+func (notnl *_NotNl) print()    { print("notnl") }
 
 // --- BRA parenthesized expression
 type _Bra struct {
-	common;
-	n	int;	// subexpression number
+	common
+	n int // subexpression number
 }
 
-func (bra *_Bra) kind() int	{ return _BRA }
-func (bra *_Bra) print()	{ print("bra", bra.n) }
+func (bra *_Bra) kind() int { return _BRA }
+func (bra *_Bra) print()    { print("bra", bra.n) }
 
 // --- EBRA end of parenthesized expression
 type _Ebra struct {
-	common;
-	n	int;	// subexpression number
+	common
+	n int // subexpression number
 }
 
-func (ebra *_Ebra) kind() int	{ return _EBRA }
-func (ebra *_Ebra) print()	{ print("ebra ", ebra.n) }
+func (ebra *_Ebra) kind() int { return _EBRA }
+func (ebra *_Ebra) print()    { print("ebra ", ebra.n) }
 
 // --- ALT alternation
 type _Alt struct {
-	common;
-	left	instr;	// other branch
+	common
+	left instr // other branch
 }
 
-func (alt *_Alt) kind() int	{ return _ALT }
-func (alt *_Alt) print()	{ print("alt(", alt.left.index(), ")") }
+func (alt *_Alt) kind() int { return _ALT }
+func (alt *_Alt) print()    { print("alt(", alt.left.index(), ")") }
 
 // --- NOP no operation
 type _Nop struct {
-	common;
+	common
 }
 
-func (nop *_Nop) kind() int	{ return _NOP }
-func (nop *_Nop) print()	{ print("nop") }
+func (nop *_Nop) kind() int { return _NOP }
+func (nop *_Nop) print()    { print("nop") }
 
 func (re *Regexp) add(i instr) instr {
-	n := len(re.inst);
-	i.setIndex(len(re.inst));
+	n := len(re.inst)
+	i.setIndex(len(re.inst))
 	if n >= cap(re.inst) {
-		ni := make([]instr, n, 2*n);
+		ni := make([]instr, n, 2*n)
 		for i, j := range re.inst {
 			ni[i] = j
 		}
-		re.inst = ni;
+		re.inst = ni
 	}
-	re.inst = re.inst[0 : n+1];
-	re.inst[n] = i;
-	return i;
+	re.inst = re.inst[0 : n+1]
+	re.inst[n] = i
+	return i
 }
 
 type parser struct {
-	re	*Regexp;
-	error	string;
-	nlpar	int;	// number of unclosed lpars
-	pos	int;
-	ch	int;
+	re    *Regexp
+	error string
+	nlpar int // number of unclosed lpars
+	pos   int
+	ch    int
 }
 
 const endOfFile = -1
 
-func (p *parser) c() int	{ return p.ch }
+func (p *parser) c() int { return p.ch }
 
 func (p *parser) nextc() int {
 	if p.pos >= len(p.re.expr) {
 		p.ch = endOfFile
 	} else {
-		c, w := utf8.DecodeRuneInString(p.re.expr[p.pos:]);
-		p.ch = c;
-		p.pos += w;
+		c, w := utf8.DecodeRuneInString(p.re.expr[p.pos:])
+		p.ch = c
+		p.pos += w
 	}
-	return p.ch;
+	return p.ch
 }
 
 func newParser(re *Regexp) *parser {
-	p := new(parser);
-	p.re = re;
-	p.nextc();	// load p.ch
-	return p;
+	p := new(parser)
+	p.re = re
+	p.nextc() // load p.ch
+	return p
 }
 
 func special(c int) bool {
-	s := `\.+*?()|[]^$`;
+	s := `\.+*?()|[]^$`
 	for i := 0; i < len(s); i++ {
 		if c == int(s[i]) {
 			return true
 		}
 	}
-	return false;
+	return false
 }
 
 func specialcclass(c int) bool {
-	s := `\-[]`;
+	s := `\-[]`
 	for i := 0; i < len(s); i++ {
 		if c == int(s[i]) {
 			return true
 		}
 	}
-	return false;
+	return false
 }
 
 func (p *parser) charClass() instr {
-	cc := newCharClass();
+	cc := newCharClass()
 	if p.c() == '^' {
-		cc.negate = true;
-		p.nextc();
+		cc.negate = true
+		p.nextc()
 	}
-	left := -1;
+	left := -1
 	for {
 		switch c := p.c(); c {
 		case ']', endOfFile:
 			if left >= 0 {
-				p.error = ErrBadRange;
-				return nil;
+				p.error = ErrBadRange
+				return nil
 			}
 			// Is it [^\n]?
 			if cc.negate && len(cc.ranges) == 2 &&
 				cc.ranges[0] == '\n' && cc.ranges[1] == '\n' {
-				nl := new(_NotNl);
-				p.re.add(nl);
-				return nl;
+				nl := new(_NotNl)
+				p.re.add(nl)
+				return nl
 			}
-			p.re.add(cc);
-			return cc;
-		case '-':	// do this before backslash processing
-			p.error = ErrBadRange;
-			return nil;
+			p.re.add(cc)
+			return cc
+		case '-': // do this before backslash processing
+			p.error = ErrBadRange
+			return nil
 		case '\\':
-			c = p.nextc();
+			c = p.nextc()
 			switch {
 			case c == endOfFile:
-				p.error = ErrExtraneousBackslash;
-				return nil;
+				p.error = ErrExtraneousBackslash
+				return nil
 			case c == 'n':
 				c = '\n'
 			case specialcclass(c):
 			// c is as delivered
 			default:
-				p.error = ErrBadBackslash;
-				return nil;
+				p.error = ErrBadBackslash
+				return nil
 			}
-			fallthrough;
+			fallthrough
 		default:
-			p.nextc();
+			p.nextc()
 			switch {
-			case left < 0:	// first of pair
-				if p.c() == '-' {	// range
-					p.nextc();
-					left = c;
-				} else {	// single char
+			case left < 0: // first of pair
+				if p.c() == '-' { // range
+					p.nextc()
+					left = c
+				} else { // single char
 					cc.addRange(c, c)
 				}
-			case left <= c:	// second of pair
-				cc.addRange(left, c);
-				left = -1;
+			case left <= c: // second of pair
+				cc.addRange(left, c)
+				left = -1
 			default:
-				p.error = ErrBadRange;
-				return nil;
+				p.error = ErrBadRange
+				return nil
 			}
 		}
 	}
-	return nil;
+	return nil
 }
 
 func (p *parser) term() (start, end instr) {
@@ -390,126 +390,126 @@ func (p *parser) term() (start, end instr) {
 	case '|', endOfFile:
 		return nil, nil
 	case '*', '+':
-		p.error = ErrBareClosure;
-		return;
+		p.error = ErrBareClosure
+		return
 	case ')':
 		if p.nlpar == 0 {
-			p.error = ErrUnmatchedRpar;
-			return;
+			p.error = ErrUnmatchedRpar
+			return
 		}
-		return nil, nil;
+		return nil, nil
 	case ']':
-		p.error = ErrUnmatchedRbkt;
-		return;
+		p.error = ErrUnmatchedRbkt
+		return
 	case '^':
-		p.nextc();
-		start = p.re.add(new(_Bot));
-		return start, start;
+		p.nextc()
+		start = p.re.add(new(_Bot))
+		return start, start
 	case '$':
-		p.nextc();
-		start = p.re.add(new(_Eot));
-		return start, start;
+		p.nextc()
+		start = p.re.add(new(_Eot))
+		return start, start
 	case '.':
-		p.nextc();
-		start = p.re.add(new(_Any));
-		return start, start;
+		p.nextc()
+		start = p.re.add(new(_Any))
+		return start, start
 	case '[':
-		p.nextc();
-		start = p.charClass();
+		p.nextc()
+		start = p.charClass()
 		if p.error != "" {
 			return
 		}
 		if p.c() != ']' {
-			p.error = ErrUnmatchedLbkt;
-			return;
+			p.error = ErrUnmatchedLbkt
+			return
 		}
-		p.nextc();
-		return start, start;
+		p.nextc()
+		return start, start
 	case '(':
-		p.nextc();
-		p.nlpar++;
-		p.re.nbra++;	// increment first so first subexpr is \1
-		nbra := p.re.nbra;
-		start, end = p.regexp();
+		p.nextc()
+		p.nlpar++
+		p.re.nbra++ // increment first so first subexpr is \1
+		nbra := p.re.nbra
+		start, end = p.regexp()
 		if p.c() != ')' {
-			p.error = ErrUnmatchedLpar;
-			return;
+			p.error = ErrUnmatchedLpar
+			return
 		}
-		p.nlpar--;
-		p.nextc();
-		bra := new(_Bra);
-		p.re.add(bra);
-		ebra := new(_Ebra);
-		p.re.add(ebra);
-		bra.n = nbra;
-		ebra.n = nbra;
+		p.nlpar--
+		p.nextc()
+		bra := new(_Bra)
+		p.re.add(bra)
+		ebra := new(_Ebra)
+		p.re.add(ebra)
+		bra.n = nbra
+		ebra.n = nbra
 		if start == nil {
 			if end == nil {
-				p.error = ErrInternal;
-				return;
+				p.error = ErrInternal
+				return
 			}
-			start = ebra;
+			start = ebra
 		} else {
 			end.setNext(ebra)
 		}
-		bra.setNext(start);
-		return bra, ebra;
+		bra.setNext(start)
+		return bra, ebra
 	case '\\':
-		c = p.nextc();
+		c = p.nextc()
 		switch {
 		case c == endOfFile:
-			p.error = ErrExtraneousBackslash;
-			return;
+			p.error = ErrExtraneousBackslash
+			return
 		case c == 'n':
 			c = '\n'
 		case special(c):
 		// c is as delivered
 		default:
-			p.error = ErrBadBackslash;
-			return;
+			p.error = ErrBadBackslash
+			return
 		}
-		fallthrough;
+		fallthrough
 	default:
-		p.nextc();
-		start = newChar(c);
-		p.re.add(start);
-		return start, start;
+		p.nextc()
+		start = newChar(c)
+		p.re.add(start)
+		return start, start
 	}
-	panic("unreachable");
+	panic("unreachable")
 }
 
 func (p *parser) closure() (start, end instr) {
-	start, end = p.term();
+	start, end = p.term()
 	if start == nil || p.error != "" {
 		return
 	}
 	switch p.c() {
 	case '*':
 		// (start,end)*:
-		alt := new(_Alt);
-		p.re.add(alt);
-		end.setNext(alt);	// after end, do alt
-		alt.left = start;	// alternate brach: return to start
-		start = alt;		// alt becomes new (start, end)
-		end = alt;
+		alt := new(_Alt)
+		p.re.add(alt)
+		end.setNext(alt) // after end, do alt
+		alt.left = start // alternate brach: return to start
+		start = alt      // alt becomes new (start, end)
+		end = alt
 	case '+':
 		// (start,end)+:
-		alt := new(_Alt);
-		p.re.add(alt);
-		end.setNext(alt);	// after end, do alt
-		alt.left = start;	// alternate brach: return to start
-		end = alt;		// start is unchanged; end is alt
+		alt := new(_Alt)
+		p.re.add(alt)
+		end.setNext(alt) // after end, do alt
+		alt.left = start // alternate brach: return to start
+		end = alt        // start is unchanged; end is alt
 	case '?':
 		// (start,end)?:
-		alt := new(_Alt);
-		p.re.add(alt);
-		nop := new(_Nop);
-		p.re.add(nop);
-		alt.left = start;	// alternate branch is start
-		alt.setNext(nop);	// follow on to nop
-		end.setNext(nop);	// after end, go to nop
-		start = alt;		// start is now alt
-		end = nop;		// end is nop pointed to by both branches
+		alt := new(_Alt)
+		p.re.add(alt)
+		nop := new(_Nop)
+		p.re.add(nop)
+		alt.left = start // alternate branch is start
+		alt.setNext(nop) // follow on to nop
+		end.setNext(nop) // after end, go to nop
+		start = alt      // start is now alt
+		end = nop        // end is nop pointed to by both branches
 	default:
 		return
 	}
@@ -517,34 +517,34 @@ func (p *parser) closure() (start, end instr) {
 	case '*', '+', '?':
 		p.error = ErrBadClosure
 	}
-	return;
+	return
 }
 
 func (p *parser) concatenation() (start, end instr) {
 	for {
-		nstart, nend := p.closure();
+		nstart, nend := p.closure()
 		if p.error != "" {
 			return
 		}
 		switch {
-		case nstart == nil:	// end of this concatenation
-			if start == nil {	// this is the empty string
-				nop := p.re.add(new(_Nop));
-				return nop, nop;
+		case nstart == nil: // end of this concatenation
+			if start == nil { // this is the empty string
+				nop := p.re.add(new(_Nop))
+				return nop, nop
 			}
-			return;
-		case start == nil:	// this is first element of concatenation
+			return
+		case start == nil: // this is first element of concatenation
 			start, end = nstart, nend
 		default:
-			end.setNext(nstart);
-			end = nend;
+			end.setNext(nstart)
+			end = nend
 		}
 	}
-	panic("unreachable");
+	panic("unreachable")
 }
 
 func (p *parser) regexp() (start, end instr) {
-	start, end = p.concatenation();
+	start, end = p.concatenation()
 	if p.error != "" {
 		return
 	}
@@ -553,145 +553,145 @@ func (p *parser) regexp() (start, end instr) {
 		default:
 			return
 		case '|':
-			p.nextc();
-			nstart, nend := p.concatenation();
+			p.nextc()
+			nstart, nend := p.concatenation()
 			if p.error != "" {
 				return
 			}
-			alt := new(_Alt);
-			p.re.add(alt);
-			alt.left = start;
-			alt.setNext(nstart);
-			nop := new(_Nop);
-			p.re.add(nop);
-			end.setNext(nop);
-			nend.setNext(nop);
-			start, end = alt, nop;
+			alt := new(_Alt)
+			p.re.add(alt)
+			alt.left = start
+			alt.setNext(nstart)
+			nop := new(_Nop)
+			p.re.add(nop)
+			end.setNext(nop)
+			nend.setNext(nop)
+			start, end = alt, nop
 		}
 	}
-	panic("unreachable");
+	panic("unreachable")
 }
 
 func unNop(i instr) instr {
 	for i.kind() == _NOP {
 		i = i.next()
 	}
-	return i;
+	return i
 }
 
 func (re *Regexp) eliminateNops() {
 	for i := 0; i < len(re.inst); i++ {
-		inst := re.inst[i];
+		inst := re.inst[i]
 		if inst.kind() == _END {
 			continue
 		}
-		inst.setNext(unNop(inst.next()));
+		inst.setNext(unNop(inst.next()))
 		if inst.kind() == _ALT {
-			alt := inst.(*_Alt);
-			alt.left = unNop(alt.left);
+			alt := inst.(*_Alt)
+			alt.left = unNop(alt.left)
 		}
 	}
 }
 
 func (re *Regexp) doParse() string {
-	p := newParser(re);
-	start := new(_Start);
-	re.add(start);
-	s, e := p.regexp();
+	p := newParser(re)
+	start := new(_Start)
+	re.add(start)
+	s, e := p.regexp()
 	if p.error != "" {
 		return p.error
 	}
-	start.setNext(s);
-	re.start = start;
-	e.setNext(re.add(new(_End)));
-	re.eliminateNops();
-	return p.error;
+	start.setNext(s)
+	re.start = start
+	e.setNext(re.add(new(_End)))
+	re.eliminateNops()
+	return p.error
 }
 
 // CompileRegexp parses a regular expression and returns, if successful, a Regexp
 // object that can be used to match against text.
 func CompileRegexp(str string) (regexp *Regexp, error string) {
-	regexp = new(Regexp);
-	regexp.expr = str;
-	regexp.inst = make([]instr, 0, 20);
-	error = regexp.doParse();
-	return;
+	regexp = new(Regexp)
+	regexp.expr = str
+	regexp.inst = make([]instr, 0, 20)
+	error = regexp.doParse()
+	return
 }
 
 // MustCompileRegexp is like CompileRegexp but panics if the expression cannot be parsed.
 // It simplifies safe initialization of global variables holding compiled regular
 // expressions.
 func MustCompile(str string) *Regexp {
-	regexp, error := CompileRegexp(str);
+	regexp, error := CompileRegexp(str)
 	if error != "" {
 		panicln(`regexp: compiling "`, str, `": `, error)
 	}
-	return regexp;
+	return regexp
 }
 
 type state struct {
-	inst	instr;	// next instruction to execute
-	match	[]int;	// pairs of bracketing submatches. 0th is start,end
+	inst  instr // next instruction to execute
+	match []int // pairs of bracketing submatches. 0th is start,end
 }
 
 // Append new state to to-do list.  Leftmost-longest wins so avoid
 // adding a state that's already active.
 func addState(s []state, inst instr, match []int) []state {
-	index := inst.index();
-	l := len(s);
-	pos := match[0];
+	index := inst.index()
+	l := len(s)
+	pos := match[0]
 	// TODO: Once the state is a vector and we can do insert, have inputs always
 	// go in order correctly and this "earlier" test is never necessary,
 	for i := 0; i < l; i++ {
-		if s[i].inst.index() == index &&	// same instruction
-			s[i].match[0] < pos {	// earlier match already going; lefmost wins
+		if s[i].inst.index() == index && // same instruction
+			s[i].match[0] < pos { // earlier match already going; lefmost wins
 			return s
 		}
 	}
 	if l == cap(s) {
-		s1 := make([]state, 2*l)[0:l];
+		s1 := make([]state, 2*l)[0:l]
 		for i := 0; i < l; i++ {
 			s1[i] = s[i]
 		}
-		s = s1;
+		s = s1
 	}
-	s = s[0 : l+1];
-	s[l].inst = inst;
-	s[l].match = match;
-	return s;
+	s = s[0 : l+1]
+	s[l].inst = inst
+	s[l].match = match
+	return s
 }
 
 // Accepts either string or bytes - the logic is identical either way.
 // If bytes == nil, scan str.
 func (re *Regexp) doExecute(str string, bytes []byte, pos int) []int {
-	var s [2][]state;	// TODO: use a vector when state values (not ptrs) can be vector elements
-	s[0] = make([]state, 10)[0:0];
-	s[1] = make([]state, 10)[0:0];
-	in, out := 0, 1;
-	var final state;
-	found := false;
-	end := len(str);
+	var s [2][]state // TODO: use a vector when state values (not ptrs) can be vector elements
+	s[0] = make([]state, 10)[0:0]
+	s[1] = make([]state, 10)[0:0]
+	in, out := 0, 1
+	var final state
+	found := false
+	end := len(str)
 	if bytes != nil {
 		end = len(bytes)
 	}
 	for pos <= end {
 		if !found {
 			// prime the pump if we haven't seen a match yet
-			match := make([]int, 2*(re.nbra+1));
+			match := make([]int, 2*(re.nbra+1))
 			for i := 0; i < len(match); i++ {
-				match[i] = -1	// no match seen; catches cases like "a(b)?c" on "ac"
+				match[i] = -1 // no match seen; catches cases like "a(b)?c" on "ac"
 			}
-			match[0] = pos;
-			s[out] = addState(s[out], re.start.next(), match);
+			match[0] = pos
+			s[out] = addState(s[out], re.start.next(), match)
 		}
-		in, out = out, in;	// old out state is new in state
-		s[out] = s[out][0:0];	// clear out state
+		in, out = out, in    // old out state is new in state
+		s[out] = s[out][0:0] // clear out state
 		if len(s[in]) == 0 {
 			// machine has completed
 			break
 		}
-		charwidth := 1;
-		c := endOfFile;
+		charwidth := 1
+		c := endOfFile
 		if pos < end {
 			if bytes == nil {
 				c, charwidth = utf8.DecodeRuneInString(str[pos:end])
@@ -700,7 +700,7 @@ func (re *Regexp) doExecute(str string, bytes []byte, pos int) []int {
 			}
 		}
 		for i := 0; i < len(s[in]); i++ {
-			st := s[in][i];
+			st := s[in][i]
 			switch s[in][i].inst.kind() {
 			case _BOT:
 				if pos == 0 {
@@ -727,38 +727,38 @@ func (re *Regexp) doExecute(str string, bytes []byte, pos int) []int {
 					s[out] = addState(s[out], st.inst.next(), st.match)
 				}
 			case _BRA:
-				n := st.inst.(*_Bra).n;
-				st.match[2*n] = pos;
-				s[in] = addState(s[in], st.inst.next(), st.match);
+				n := st.inst.(*_Bra).n
+				st.match[2*n] = pos
+				s[in] = addState(s[in], st.inst.next(), st.match)
 			case _EBRA:
-				n := st.inst.(*_Ebra).n;
-				st.match[2*n+1] = pos;
-				s[in] = addState(s[in], st.inst.next(), st.match);
+				n := st.inst.(*_Ebra).n
+				st.match[2*n+1] = pos
+				s[in] = addState(s[in], st.inst.next(), st.match)
 			case _ALT:
-				s[in] = addState(s[in], st.inst.(*_Alt).left, st.match);
+				s[in] = addState(s[in], st.inst.(*_Alt).left, st.match)
 				// give other branch a copy of this match vector
-				s1 := make([]int, 2*(re.nbra+1));
+				s1 := make([]int, 2*(re.nbra+1))
 				for i := 0; i < len(s1); i++ {
 					s1[i] = st.match[i]
 				}
-				s[in] = addState(s[in], st.inst.next(), s1);
+				s[in] = addState(s[in], st.inst.next(), s1)
 			case _END:
 				// choose leftmost longest
-				if !found ||	// first
-					st.match[0] < final.match[0] ||	// leftmost
-					(st.match[0] == final.match[0] && pos > final.match[1]) {	// longest
-					final = st;
-					final.match[1] = pos;
+				if !found || // first
+					st.match[0] < final.match[0] || // leftmost
+					(st.match[0] == final.match[0] && pos > final.match[1]) { // longest
+					final = st
+					final.match[1] = pos
 				}
-				found = true;
+				found = true
 			default:
-				st.inst.print();
-				panic("unknown instruction in execute");
+				st.inst.print()
+				panic("unknown instruction in execute")
 			}
 		}
-		pos += charwidth;
+		pos += charwidth
 	}
-	return final.match;
+	return final.match
 }
 
 
@@ -781,17 +781,17 @@ func (re *Regexp) ExecuteString(s string) (a []int) {
 //    b[a[2*i]:a[2*i+1]] for i > 0 is the subslice matched by the ith parenthesized subexpression.
 // A negative value means the subexpression did not match any element of the slice.
 // An empty array means "no match".
-func (re *Regexp) Execute(b []byte) (a []int)	{ return re.doExecute("", b, 0) }
+func (re *Regexp) Execute(b []byte) (a []int) { return re.doExecute("", b, 0) }
 
 
 // MatchString returns whether the Regexp matches the string s.
 // The return value is a boolean: true for match, false for no match.
-func (re *Regexp) MatchString(s string) bool	{ return len(re.doExecute(s, nil, 0)) > 0 }
+func (re *Regexp) MatchString(s string) bool { return len(re.doExecute(s, nil, 0)) > 0 }
 
 
 // Match returns whether the Regexp matches the byte slice b.
 // The return value is a boolean: true for match, false for no match.
-func (re *Regexp) Match(b []byte) bool	{ return len(re.doExecute("", b, 0)) > 0 }
+func (re *Regexp) Match(b []byte) bool { return len(re.doExecute("", b, 0)) > 0 }
 
 
 // MatchStrings matches the Regexp against the string s.
@@ -800,17 +800,17 @@ func (re *Regexp) Match(b []byte) bool	{ return len(re.doExecute("", b, 0)) > 0
 //    a[i] for i > 0 is the substring matched by the ith parenthesized subexpression.
 // An empty array means ``no match''.
 func (re *Regexp) MatchStrings(s string) (a []string) {
-	r := re.doExecute(s, nil, 0);
+	r := re.doExecute(s, nil, 0)
 	if r == nil {
 		return nil
 	}
-	a = make([]string, len(r)/2);
+	a = make([]string, len(r)/2)
 	for i := 0; i < len(r); i += 2 {
-		if r[i] != -1 {	// -1 means no match for this subexpression
+		if r[i] != -1 { // -1 means no match for this subexpression
 			a[i/2] = s[r[i]:r[i+1]]
 		}
 	}
-	return;
+	return
 }
 
 // MatchSlices matches the Regexp against the byte slice b.
@@ -819,37 +819,37 @@ func (re *Regexp) MatchStrings(s string) (a []string) {
 //    a[i] for i > 0 is the subslice matched by the ith parenthesized subexpression.
 // An empty array means ``no match''.
 func (re *Regexp) MatchSlices(b []byte) (a [][]byte) {
-	r := re.doExecute("", b, 0);
+	r := re.doExecute("", b, 0)
 	if r == nil {
 		return nil
 	}
-	a = make([][]byte, len(r)/2);
+	a = make([][]byte, len(r)/2)
 	for i := 0; i < len(r); i += 2 {
-		if r[i] != -1 {	// -1 means no match for this subexpression
+		if r[i] != -1 { // -1 means no match for this subexpression
 			a[i/2] = b[r[i]:r[i+1]]
 		}
 	}
-	return;
+	return
 }
 
 // MatchString checks whether a textual regular expression
 // matches a string.  More complicated queries need
 // to use Compile and the full Regexp interface.
 func MatchString(pattern string, s string) (matched bool, error string) {
-	re, err := CompileRegexp(pattern);
+	re, err := CompileRegexp(pattern)
 	if err != "" {
 		return false, err
 	}
-	return re.MatchString(s), "";
+	return re.MatchString(s), ""
 }
 
 // Match checks whether a textual regular expression
 // matches a byte slice.  More complicated queries need
 // to use Compile and the full Regexp interface.
 func Match(pattern string, b []byte) (matched bool, error string) {
-	re, err := CompileRegexp(pattern);
+	re, err := CompileRegexp(pattern)
 	if err != "" {
 		return false, err
 	}
-	return re.Match(b), "";
+	return re.Match(b), ""
 }
diff --git a/src/pkg/testing/regexp_test.go b/src/pkg/testing/regexp_test.go
index 66139ea1e3..51b632ee25 100644
--- a/src/pkg/testing/regexp_test.go
+++ b/src/pkg/testing/regexp_test.go
@@ -5,7 +5,7 @@
 package testing
 
 import (
-	"strings";
+	"strings"
 )
 
 var good_re = []string{
@@ -30,8 +30,8 @@ var good_re = []string{
 
 // TODO: nice to do this with a map
 type stringError struct {
-	re	string;
-	err	string;
+	re  string
+	err string
 }
 
 var bad_re = []stringError{
@@ -52,9 +52,9 @@ var bad_re = []stringError{
 type vec []int
 
 type tester struct {
-	re	string;
-	text	string;
-	match	vec;
+	re    string
+	text  string
+	match vec
 }
 
 var matches = []tester{
@@ -87,15 +87,15 @@ var matches = []tester{
 }
 
 func compileTest(t *T, expr string, error string) *Regexp {
-	re, err := CompileRegexp(expr);
+	re, err := CompileRegexp(expr)
 	if err != error {
 		t.Error("compiling `", expr, "`; unexpected error: ", err)
 	}
-	return re;
+	return re
 }
 
 func printVec(t *T, m []int) {
-	l := len(m);
+	l := len(m)
 	if l == 0 {
 		t.Log("\t<no match>")
 	} else {
@@ -106,7 +106,7 @@ func printVec(t *T, m []int) {
 }
 
 func printStrings(t *T, m []string) {
-	l := len(m);
+	l := len(m)
 	if l == 0 {
 		t.Log("\t<no match>")
 	} else {
@@ -117,7 +117,7 @@ func printStrings(t *T, m []string) {
 }
 
 func printBytes(t *T, b [][]byte) {
-	l := len(b);
+	l := len(b)
 	if l == 0 {
 		t.Log("\t<no match>")
 	} else {
@@ -128,7 +128,7 @@ func printBytes(t *T, b [][]byte) {
 }
 
 func equal(m1, m2 []int) bool {
-	l := len(m1);
+	l := len(m1)
 	if l != len(m2) {
 		return false
 	}
@@ -137,11 +137,11 @@ func equal(m1, m2 []int) bool {
 			return false
 		}
 	}
-	return true;
+	return true
 }
 
 func equalStrings(m1, m2 []string) bool {
-	l := len(m1);
+	l := len(m1)
 	if l != len(m2) {
 		return false
 	}
@@ -150,11 +150,11 @@ func equalStrings(m1, m2 []string) bool {
 			return false
 		}
 	}
-	return true;
+	return true
 }
 
 func equalBytes(m1 [][]byte, m2 []string) bool {
-	l := len(m1);
+	l := len(m1)
 	if l != len(m2) {
 		return false
 	}
@@ -163,28 +163,28 @@ func equalBytes(m1 [][]byte, m2 []string) bool {
 			return false
 		}
 	}
-	return true;
+	return true
 }
 
 func executeTest(t *T, expr string, str string, match []int) {
-	re := compileTest(t, expr, "");
+	re := compileTest(t, expr, "")
 	if re == nil {
 		return
 	}
-	m := re.ExecuteString(str);
+	m := re.ExecuteString(str)
 	if !equal(m, match) {
-		t.Error("ExecuteString failure on `", expr, "` matching `", str, "`:");
-		printVec(t, m);
-		t.Log("should be:");
-		printVec(t, match);
+		t.Error("ExecuteString failure on `", expr, "` matching `", str, "`:")
+		printVec(t, m)
+		t.Log("should be:")
+		printVec(t, match)
 	}
 	// now try bytes
-	m = re.Execute(strings.Bytes(str));
+	m = re.Execute(strings.Bytes(str))
 	if !equal(m, match) {
-		t.Error("Execute failure on `", expr, "` matching `", str, "`:");
-		printVec(t, m);
-		t.Log("should be:");
-		printVec(t, match);
+		t.Error("Execute failure on `", expr, "` matching `", str, "`:")
+		printVec(t, m)
+		t.Log("should be:")
+		printVec(t, match)
 	}
 }
 
@@ -202,22 +202,22 @@ func TestBadCompile(t *T) {
 
 func TestExecute(t *T) {
 	for i := 0; i < len(matches); i++ {
-		test := &matches[i];
-		executeTest(t, test.re, test.text, test.match);
+		test := &matches[i]
+		executeTest(t, test.re, test.text, test.match)
 	}
 }
 
 func matchTest(t *T, expr string, str string, match []int) {
-	re := compileTest(t, expr, "");
+	re := compileTest(t, expr, "")
 	if re == nil {
 		return
 	}
-	m := re.MatchString(str);
+	m := re.MatchString(str)
 	if m != (len(match) > 0) {
 		t.Error("MatchString failure on `", expr, "` matching `", str, "`:", m, "should be", len(match) > 0)
 	}
 	// now try bytes
-	m = re.Match(strings.Bytes(str));
+	m = re.Match(strings.Bytes(str))
 	if m != (len(match) > 0) {
 		t.Error("Match failure on `", expr, "` matching `", str, "`:", m, "should be", len(match) > 0)
 	}
@@ -225,46 +225,46 @@ func matchTest(t *T, expr string, str string, match []int) {
 
 func TestMatch(t *T) {
 	for i := 0; i < len(matches); i++ {
-		test := &matches[i];
-		matchTest(t, test.re, test.text, test.match);
+		test := &matches[i]
+		matchTest(t, test.re, test.text, test.match)
 	}
 }
 
 func matchStringsTest(t *T, expr string, str string, match []int) {
-	re := compileTest(t, expr, "");
+	re := compileTest(t, expr, "")
 	if re == nil {
 		return
 	}
-	strs := make([]string, len(match)/2);
+	strs := make([]string, len(match)/2)
 	for i := 0; i < len(match); i++ {
 		strs[i/2] = str[match[i]:match[i+1]]
 	}
-	m := re.MatchStrings(str);
+	m := re.MatchStrings(str)
 	if !equalStrings(m, strs) {
-		t.Error("MatchStrings failure on `", expr, "` matching `", str, "`:");
-		printStrings(t, m);
-		t.Log("should be:");
-		printStrings(t, strs);
+		t.Error("MatchStrings failure on `", expr, "` matching `", str, "`:")
+		printStrings(t, m)
+		t.Log("should be:")
+		printStrings(t, strs)
 	}
 	// now try bytes
-	s := re.MatchSlices(strings.Bytes(str));
+	s := re.MatchSlices(strings.Bytes(str))
 	if !equalBytes(s, strs) {
-		t.Error("MatchSlices failure on `", expr, "` matching `", str, "`:");
-		printBytes(t, s);
-		t.Log("should be:");
-		printStrings(t, strs);
+		t.Error("MatchSlices failure on `", expr, "` matching `", str, "`:")
+		printBytes(t, s)
+		t.Log("should be:")
+		printStrings(t, strs)
 	}
 }
 
 func TestMatchStrings(t *T) {
 	for i := 0; i < len(matches); i++ {
-		test := &matches[i];
-		matchTest(t, test.re, test.text, test.match);
+		test := &matches[i]
+		matchTest(t, test.re, test.text, test.match)
 	}
 }
 
 func matchFunctionTest(t *T, expr string, str string, match []int) {
-	m, err := MatchString(expr, str);
+	m, err := MatchString(expr, str)
 	if err == "" {
 		return
 	}
@@ -275,15 +275,15 @@ func matchFunctionTest(t *T, expr string, str string, match []int) {
 
 func TestMatchFunction(t *T) {
 	for i := 0; i < len(matches); i++ {
-		test := &matches[i];
-		matchFunctionTest(t, test.re, test.text, test.match);
+		test := &matches[i]
+		matchFunctionTest(t, test.re, test.text, test.match)
 	}
 }
 
 func BenchmarkSimpleMatch(b *B) {
-	b.StopTimer();
-	re, _ := CompileRegexp("a");
-	b.StartTimer();
+	b.StopTimer()
+	re, _ := CompileRegexp("a")
+	b.StartTimer()
 
 	for i := 0; i < b.N; i++ {
 		re.MatchString("a")
@@ -291,9 +291,9 @@ func BenchmarkSimpleMatch(b *B) {
 }
 
 func BenchmarkUngroupedMatch(b *B) {
-	b.StopTimer();
-	re, _ := CompileRegexp("[a-z]+ [0-9]+ [a-z]+");
-	b.StartTimer();
+	b.StopTimer()
+	re, _ := CompileRegexp("[a-z]+ [0-9]+ [a-z]+")
+	b.StartTimer()
 
 	for i := 0; i < b.N; i++ {
 		re.MatchString("word 123 other")
@@ -301,9 +301,9 @@ func BenchmarkUngroupedMatch(b *B) {
 }
 
 func BenchmarkGroupedMatch(b *B) {
-	b.StopTimer();
-	re, _ := CompileRegexp("([a-z]+) ([0-9]+) ([a-z]+)");
-	b.StartTimer();
+	b.StopTimer()
+	re, _ := CompileRegexp("([a-z]+) ([0-9]+) ([a-z]+)")
+	b.StartTimer()
 
 	for i := 0; i < b.N; i++ {
 		re.MatchString("word 123 other")
diff --git a/src/pkg/testing/script/script.go b/src/pkg/testing/script/script.go
index 623685efd5..9a41a467f3 100644
--- a/src/pkg/testing/script/script.go
+++ b/src/pkg/testing/script/script.go
@@ -6,37 +6,37 @@
 package script
 
 import (
-	"fmt";
-	"os";
-	"rand";
-	"reflect";
-	"strings";
+	"fmt"
+	"os"
+	"rand"
+	"reflect"
+	"strings"
 )
 
 // An Event is an element in a partially ordered set that either sends a value
 // to a channel or expects a value from a channel.
 type Event struct {
-	name		string;
-	occurred	bool;
-	predecessors	[]*Event;
-	action		action;
+	name         string
+	occurred     bool
+	predecessors []*Event
+	action       action
 }
 
 type action interface {
 	// getSend returns nil if the action is not a send action.
-	getSend() sendAction;
+	getSend() sendAction
 	// getRecv returns nil if the action is not a receive action.
-	getRecv() recvAction;
+	getRecv() recvAction
 	// getChannel returns the channel that the action operates on.
-	getChannel() interface{};
+	getChannel() interface{}
 }
 
 type recvAction interface {
-	recvMatch(interface{}) bool;
+	recvMatch(interface{}) bool
 }
 
 type sendAction interface {
-	send();
+	send()
 }
 
 // isReady returns true if all the predecessors of an Event have occurred.
@@ -47,87 +47,87 @@ func (e Event) isReady() bool {
 		}
 	}
 
-	return true;
+	return true
 }
 
 // A Recv action reads a value from a channel and uses reflect.DeepMatch to
 // compare it with an expected value.
 type Recv struct {
-	Channel		interface{};
-	Expected	interface{};
+	Channel  interface{}
+	Expected interface{}
 }
 
-func (r Recv) getRecv() recvAction	{ return r }
+func (r Recv) getRecv() recvAction { return r }
 
-func (Recv) getSend() sendAction	{ return nil }
+func (Recv) getSend() sendAction { return nil }
 
-func (r Recv) getChannel() interface{}	{ return r.Channel }
+func (r Recv) getChannel() interface{} { return r.Channel }
 
 func (r Recv) recvMatch(chanEvent interface{}) bool {
-	c, ok := chanEvent.(channelRecv);
+	c, ok := chanEvent.(channelRecv)
 	if !ok || c.channel != r.Channel {
 		return false
 	}
 
-	return reflect.DeepEqual(c.value, r.Expected);
+	return reflect.DeepEqual(c.value, r.Expected)
 }
 
 // A RecvMatch action reads a value from a channel and calls a function to
 // determine if the value matches.
 type RecvMatch struct {
-	Channel	interface{};
-	Match	func(interface{}) bool;
+	Channel interface{}
+	Match   func(interface{}) bool
 }
 
-func (r RecvMatch) getRecv() recvAction	{ return r }
+func (r RecvMatch) getRecv() recvAction { return r }
 
-func (RecvMatch) getSend() sendAction	{ return nil }
+func (RecvMatch) getSend() sendAction { return nil }
 
-func (r RecvMatch) getChannel() interface{}	{ return r.Channel }
+func (r RecvMatch) getChannel() interface{} { return r.Channel }
 
 func (r RecvMatch) recvMatch(chanEvent interface{}) bool {
-	c, ok := chanEvent.(channelRecv);
+	c, ok := chanEvent.(channelRecv)
 	if !ok || c.channel != r.Channel {
 		return false
 	}
 
-	return r.Match(c.value);
+	return r.Match(c.value)
 }
 
 // A Closed action matches if the given channel is closed. The closing is
 // treated as an event, not a state, thus Closed will only match once for a
 // given channel.
 type Closed struct {
-	Channel interface{};
+	Channel interface{}
 }
 
-func (r Closed) getRecv() recvAction	{ return r }
+func (r Closed) getRecv() recvAction { return r }
 
-func (Closed) getSend() sendAction	{ return nil }
+func (Closed) getSend() sendAction { return nil }
 
-func (r Closed) getChannel() interface{}	{ return r.Channel }
+func (r Closed) getChannel() interface{} { return r.Channel }
 
 func (r Closed) recvMatch(chanEvent interface{}) bool {
-	c, ok := chanEvent.(channelClosed);
+	c, ok := chanEvent.(channelClosed)
 	if !ok || c.channel != r.Channel {
 		return false
 	}
 
-	return true;
+	return true
 }
 
 // A Send action sends a value to a channel. The value must match the
 // type of the channel exactly unless the channel if of type chan interface{}.
 type Send struct {
-	Channel	interface{};
-	Value	interface{};
+	Channel interface{}
+	Value   interface{}
 }
 
-func (Send) getRecv() recvAction	{ return nil }
+func (Send) getRecv() recvAction { return nil }
 
-func (s Send) getSend() sendAction	{ return s }
+func (s Send) getSend() sendAction { return s }
 
-func (s Send) getChannel() interface{}	{ return s.Channel }
+func (s Send) getChannel() interface{} { return s.Channel }
 
 func newEmptyInterface(args ...) reflect.Value {
 	return reflect.NewValue(args).(*reflect.StructValue).Field(0)
@@ -137,53 +137,53 @@ func (s Send) send() {
 	// With reflect.ChanValue.Send, we must match the types exactly. So, if
 	// s.Channel is a chan interface{} we convert s.Value to an interface{}
 	// first.
-	c := reflect.NewValue(s.Channel).(*reflect.ChanValue);
-	var v reflect.Value;
+	c := reflect.NewValue(s.Channel).(*reflect.ChanValue)
+	var v reflect.Value
 	if iface, ok := c.Type().(*reflect.ChanType).Elem().(*reflect.InterfaceType); ok && iface.NumMethod() == 0 {
 		v = newEmptyInterface(s.Value)
 	} else {
 		v = reflect.NewValue(s.Value)
 	}
-	c.Send(v);
+	c.Send(v)
 }
 
 // A Close action closes the given channel.
 type Close struct {
-	Channel interface{};
+	Channel interface{}
 }
 
-func (Close) getRecv() recvAction	{ return nil }
+func (Close) getRecv() recvAction { return nil }
 
-func (s Close) getSend() sendAction	{ return s }
+func (s Close) getSend() sendAction { return s }
 
-func (s Close) getChannel() interface{}	{ return s.Channel }
+func (s Close) getChannel() interface{} { return s.Channel }
 
-func (s Close) send()	{ reflect.NewValue(s.Channel).(*reflect.ChanValue).Close() }
+func (s Close) send() { reflect.NewValue(s.Channel).(*reflect.ChanValue).Close() }
 
 // A ReceivedUnexpected error results if no active Events match a value
 // received from a channel.
 type ReceivedUnexpected struct {
-	Value	interface{};
-	ready	[]*Event;
+	Value interface{}
+	ready []*Event
 }
 
 func (r ReceivedUnexpected) String() string {
-	names := make([]string, len(r.ready));
+	names := make([]string, len(r.ready))
 	for i, v := range r.ready {
 		names[i] = v.name
 	}
-	return fmt.Sprintf("received unexpected value on one of the channels: %#v. Runnable events: %s", r.Value, strings.Join(names, ", "));
+	return fmt.Sprintf("received unexpected value on one of the channels: %#v. Runnable events: %s", r.Value, strings.Join(names, ", "))
 }
 
 // A SetupError results if there is a error with the configuration of a set of
 // Events.
 type SetupError string
 
-func (s SetupError) String() string	{ return string(s) }
+func (s SetupError) String() string { return string(s) }
 
 func NewEvent(name string, predecessors []*Event, action action) *Event {
-	e := &Event{name, false, predecessors, action};
-	return e;
+	e := &Event{name, false, predecessors, action}
+	return e
 }
 
 // Given a set of Events, Perform repeatedly iterates over the set and finds the
@@ -220,20 +220,20 @@ func NewEvent(name string, predecessors []*Event, action action) *Event {
 // thus Perform may see a value from a channel that is not in the current ready
 // set and fail.
 func Perform(seed int64, events []*Event) (err os.Error) {
-	r := rand.New(rand.NewSource(seed));
+	r := rand.New(rand.NewSource(seed))
 
-	channels, err := getChannels(events);
+	channels, err := getChannels(events)
 	if err != nil {
 		return
 	}
-	multiplex := make(chan interface{});
+	multiplex := make(chan interface{})
 	for _, channel := range channels {
 		go recvValues(multiplex, channel)
 	}
 
 Outer:
 	for {
-		ready, err := readyEvents(events);
+		ready, err := readyEvents(events)
 		if err != nil {
 			return err
 		}
@@ -243,113 +243,113 @@ Outer:
 			break
 		}
 
-		event := ready[r.Intn(len(ready))];
+		event := ready[r.Intn(len(ready))]
 		if send := event.action.getSend(); send != nil {
-			send.send();
-			event.occurred = true;
-			continue;
+			send.send()
+			event.occurred = true
+			continue
 		}
 
-		v := <-multiplex;
+		v := <-multiplex
 		for _, event := range ready {
 			if recv := event.action.getRecv(); recv != nil && recv.recvMatch(v) {
-				event.occurred = true;
-				continue Outer;
+				event.occurred = true
+				continue Outer
 			}
 		}
 
-		return ReceivedUnexpected{v, ready};
+		return ReceivedUnexpected{v, ready}
 	}
 
-	return nil;
+	return nil
 }
 
 // getChannels returns all the channels listed in any receive events.
 func getChannels(events []*Event) ([]interface{}, os.Error) {
-	channels := make([]interface{}, len(events));
+	channels := make([]interface{}, len(events))
 
-	j := 0;
+	j := 0
 	for _, event := range events {
 		if recv := event.action.getRecv(); recv == nil {
 			continue
 		}
-		c := event.action.getChannel();
+		c := event.action.getChannel()
 		if _, ok := reflect.NewValue(c).(*reflect.ChanValue); !ok {
 			return nil, SetupError("one of the channel values is not a channel")
 		}
 
-		duplicate := false;
+		duplicate := false
 		for _, other := range channels[0:j] {
 			if c == other {
-				duplicate = true;
-				break;
+				duplicate = true
+				break
 			}
 		}
 
 		if !duplicate {
-			channels[j] = c;
-			j++;
+			channels[j] = c
+			j++
 		}
 	}
 
-	return channels[0:j], nil;
+	return channels[0:j], nil
 }
 
 // recvValues is a multiplexing helper function. It reads values from the given
 // channel repeatedly, wrapping them up as either a channelRecv or
 // channelClosed structure, and forwards them to the multiplex channel.
 func recvValues(multiplex chan<- interface{}, channel interface{}) {
-	c := reflect.NewValue(channel).(*reflect.ChanValue);
+	c := reflect.NewValue(channel).(*reflect.ChanValue)
 
 	for {
-		v := c.Recv();
+		v := c.Recv()
 		if c.Closed() {
-			multiplex <- channelClosed{channel};
-			return;
+			multiplex <- channelClosed{channel}
+			return
 		}
 
-		multiplex <- channelRecv{channel, v.Interface()};
+		multiplex <- channelRecv{channel, v.Interface()}
 	}
 }
 
 type channelClosed struct {
-	channel interface{};
+	channel interface{}
 }
 
 type channelRecv struct {
-	channel	interface{};
-	value	interface{};
+	channel interface{}
+	value   interface{}
 }
 
 // readyEvents returns the subset of events that are ready.
 func readyEvents(events []*Event) ([]*Event, os.Error) {
-	ready := make([]*Event, len(events));
+	ready := make([]*Event, len(events))
 
-	j := 0;
-	eventsWaiting := false;
+	j := 0
+	eventsWaiting := false
 	for _, event := range events {
 		if event.occurred {
 			continue
 		}
 
-		eventsWaiting = true;
+		eventsWaiting = true
 		if event.isReady() {
-			ready[j] = event;
-			j++;
+			ready[j] = event
+			j++
 		}
 	}
 
 	if j == 0 && eventsWaiting {
-		names := make([]string, len(events));
+		names := make([]string, len(events))
 		for _, event := range events {
 			if event.occurred {
 				continue
 			}
-			names[j] = event.name;
+			names[j] = event.name
 		}
 
-		return nil, SetupError("dependency cycle in events. These events are waiting to run but cannot: " + strings.Join(names, ", "));
+		return nil, SetupError("dependency cycle in events. These events are waiting to run but cannot: " + strings.Join(names, ", "))
 	}
 
-	return ready[0:j], nil;
+	return ready[0:j], nil
 }
diff --git a/src/pkg/testing/script/script_test.go b/src/pkg/testing/script/script_test.go
index 359218c603..e9ab142c2b 100644
--- a/src/pkg/testing/script/script_test.go
+++ b/src/pkg/testing/script/script_test.go
@@ -5,37 +5,37 @@
 package script
 
 import (
-	"testing";
+	"testing"
 )
 
 func TestNoop(t *testing.T) {
-	err := Perform(0, nil);
+	err := Perform(0, nil)
 	if err != nil {
 		t.Errorf("Got error: %s", err)
 	}
 }
 
 func TestSimple(t *testing.T) {
-	c := make(chan int);
-	defer close(c);
+	c := make(chan int)
+	defer close(c)
 
-	a := NewEvent("send", nil, Send{c, 1});
-	b := NewEvent("recv", []*Event{a}, Recv{c, 1});
+	a := NewEvent("send", nil, Send{c, 1})
+	b := NewEvent("recv", []*Event{a}, Recv{c, 1})
 
-	err := Perform(0, []*Event{a, b});
+	err := Perform(0, []*Event{a, b})
 	if err != nil {
 		t.Errorf("Got error: %s", err)
 	}
 }
 
 func TestFail(t *testing.T) {
-	c := make(chan int);
-	defer close(c);
+	c := make(chan int)
+	defer close(c)
 
-	a := NewEvent("send", nil, Send{c, 2});
-	b := NewEvent("recv", []*Event{a}, Recv{c, 1});
+	a := NewEvent("send", nil, Send{c, 2})
+	b := NewEvent("recv", []*Event{a}, Recv{c, 1})
 
-	err := Perform(0, []*Event{a, b});
+	err := Perform(0, []*Event{a, b})
 	if err == nil {
 		t.Errorf("Failed to get expected error")
 	} else if _, ok := err.(ReceivedUnexpected); !ok {
@@ -44,12 +44,12 @@ func TestFail(t *testing.T) {
 }
 
 func TestClose(t *testing.T) {
-	c := make(chan int);
+	c := make(chan int)
 
-	a := NewEvent("close", nil, Close{c});
-	b := NewEvent("closed", []*Event{a}, Closed{c});
+	a := NewEvent("close", nil, Close{c})
+	b := NewEvent("closed", []*Event{a}, Closed{c})
 
-	err := Perform(0, []*Event{a, b});
+	err := Perform(0, []*Event{a, b})
 	if err != nil {
 		t.Errorf("Got error: %s", err)
 	}
@@ -59,16 +59,16 @@ func matchOne(v interface{}) bool {
 	if i, ok := v.(int); ok && i == 1 {
 		return true
 	}
-	return false;
+	return false
 }
 
 func TestRecvMatch(t *testing.T) {
-	c := make(chan int);
+	c := make(chan int)
 
-	a := NewEvent("send", nil, Send{c, 1});
-	b := NewEvent("recv", []*Event{a}, RecvMatch{c, matchOne});
+	a := NewEvent("send", nil, Send{c, 1})
+	b := NewEvent("recv", []*Event{a}, RecvMatch{c, matchOne})
 
-	err := Perform(0, []*Event{a, b});
+	err := Perform(0, []*Event{a, b})
 	if err != nil {
 		t.Errorf("Got error: %s", err)
 	}
diff --git a/src/pkg/testing/testing.go b/src/pkg/testing/testing.go
index 654d344c0c..77f9942d8b 100644
--- a/src/pkg/testing/testing.go
+++ b/src/pkg/testing/testing.go
@@ -39,10 +39,10 @@
 package testing
 
 import (
-	"flag";
-	"fmt";
-	"os";
-	"runtime";
+	"flag"
+	"fmt"
+	"os"
+	"runtime"
 )
 
 // Report as tests are run; default is silent for success.
@@ -52,44 +52,44 @@ var match = flag.String("match", "", "regular expression to select tests to run"
 
 // Insert final newline if needed and tabs after internal newlines.
 func tabify(s string) string {
-	n := len(s);
+	n := len(s)
 	if n > 0 && s[n-1] != '\n' {
-		s += "\n";
-		n++;
+		s += "\n"
+		n++
 	}
-	for i := 0; i < n-1; i++ {	// -1 to avoid final newline
+	for i := 0; i < n-1; i++ { // -1 to avoid final newline
 		if s[i] == '\n' {
 			return s[0:i+1] + "\t" + tabify(s[i+1:n])
 		}
 	}
-	return s;
+	return s
 }
 
 // T is a type passed to Test functions to manage test state and support formatted test logs.
 // Logs are accumulated during execution and dumped to standard error when done.
 type T struct {
-	errors	string;
-	failed	bool;
-	ch	chan *T;
+	errors string
+	failed bool
+	ch     chan *T
 }
 
 // Fail marks the Test function as having failed but continues execution.
-func (t *T) Fail()	{ t.failed = true }
+func (t *T) Fail() { t.failed = true }
 
 // Failed returns whether the Test function has failed.
-func (t *T) Failed() bool	{ return t.failed }
+func (t *T) Failed() bool { return t.failed }
 
 // FailNow marks the Test function as having failed and stops its execution.
 // Execution will continue at the next Test.
 func (t *T) FailNow() {
-	t.Fail();
-	t.ch <- t;
-	runtime.Goexit();
+	t.Fail()
+	t.ch <- t
+	runtime.Goexit()
 }
 
 // Log formats its arguments using default formatting, analogous to Print(),
 // and records the text in the error log.
-func (t *T) Log(args ...)	{ t.errors += "\t" + tabify(fmt.Sprintln(args)) }
+func (t *T) Log(args ...) { t.errors += "\t" + tabify(fmt.Sprintln(args)) }
 
 // Log formats its arguments according to the format, analogous to Printf(),
 // and records the text in the error log.
@@ -99,52 +99,52 @@ func (t *T) Logf(format string, args ...) {
 
 // Error is equivalent to Log() followed by Fail().
 func (t *T) Error(args ...) {
-	t.Log(args);
-	t.Fail();
+	t.Log(args)
+	t.Fail()
 }
 
 // Errorf is equivalent to Logf() followed by Fail().
 func (t *T) Errorf(format string, args ...) {
-	t.Logf(format, args);
-	t.Fail();
+	t.Logf(format, args)
+	t.Fail()
 }
 
 // Fatal is equivalent to Log() followed by FailNow().
 func (t *T) Fatal(args ...) {
-	t.Log(args);
-	t.FailNow();
+	t.Log(args)
+	t.FailNow()
 }
 
 // Fatalf is equivalent to Logf() followed by FailNow().
 func (t *T) Fatalf(format string, args ...) {
-	t.Logf(format, args);
-	t.FailNow();
+	t.Logf(format, args)
+	t.FailNow()
 }
 
 // An internal type but exported because it is cross-package; part of the implementation
 // of gotest.
 type Test struct {
-	Name	string;
-	F	func(*T);
+	Name string
+	F    func(*T)
 }
 
 func tRunner(t *T, test *Test) {
-	test.F(t);
-	t.ch <- t;
+	test.F(t)
+	t.ch <- t
 }
 
 // An internal function but exported because it is cross-package; part of the implementation
 // of gotest.
 func Main(tests []Test) {
-	flag.Parse();
-	ok := true;
+	flag.Parse()
+	ok := true
 	if len(tests) == 0 {
 		println("testing: warning: no tests to run")
 	}
-	re, err := CompileRegexp(*match);
+	re, err := CompileRegexp(*match)
 	if err != "" {
-		println("invalid regexp for -match:", err);
-		os.Exit(1);
+		println("invalid regexp for -match:", err)
+		os.Exit(1)
 	}
 	for i := 0; i < len(tests); i++ {
 		if !re.MatchString(tests[i].Name) {
@@ -153,22 +153,22 @@ func Main(tests []Test) {
 		if *chatty {
 			println("=== RUN ", tests[i].Name)
 		}
-		t := new(T);
-		t.ch = make(chan *T);
-		go tRunner(t, &tests[i]);
-		<-t.ch;
+		t := new(T)
+		t.ch = make(chan *T)
+		go tRunner(t, &tests[i])
+		<-t.ch
 		if t.failed {
-			println("--- FAIL:", tests[i].Name);
-			print(t.errors);
-			ok = false;
+			println("--- FAIL:", tests[i].Name)
+			print(t.errors)
+			ok = false
 		} else if *chatty {
-			println("--- PASS:", tests[i].Name);
-			print(t.errors);
+			println("--- PASS:", tests[i].Name)
+			print(t.errors)
 		}
 	}
 	if !ok {
-		println("FAIL");
-		os.Exit(1);
+		println("FAIL")
+		os.Exit(1)
 	}
-	println("PASS");
+	println("PASS")
 }
diff --git a/src/pkg/time/sleep.go b/src/pkg/time/sleep.go
index e94057a16c..79ca3b6ca3 100644
--- a/src/pkg/time/sleep.go
+++ b/src/pkg/time/sleep.go
@@ -5,10 +5,10 @@
 package time
 
 import (
-	"os";
-	"syscall";
+	"os"
+	"syscall"
 )
 
 // Sleep pauses the current goroutine for ns nanoseconds.
 // It returns os.EINTR if interrupted.
-func Sleep(ns int64) os.Error	{ return os.NewSyscallError("sleep", syscall.Sleep(ns)) }
+func Sleep(ns int64) os.Error { return os.NewSyscallError("sleep", syscall.Sleep(ns)) }
diff --git a/src/pkg/time/tick.go b/src/pkg/time/tick.go
index cd247d3674..a37e8ea4c4 100644
--- a/src/pkg/time/tick.go
+++ b/src/pkg/time/tick.go
@@ -23,19 +23,19 @@ package time
 // A Ticker holds a synchronous channel that delivers `ticks' of a clock
 // at intervals.
 type Ticker struct {
-	C		<-chan int64;	// The channel on which the ticks are delivered.
-	ns		int64;
-	shutdown	bool;
+	C        <-chan int64 // The channel on which the ticks are delivered.
+	ns       int64
+	shutdown bool
 }
 
 // Stop turns off a ticker.  After Stop, no more ticks will be delivered.
-func (t *Ticker) Stop()	{ t.shutdown = true }
+func (t *Ticker) Stop() { t.shutdown = true }
 
 func (t *Ticker) ticker(c chan<- int64) {
-	now := Nanoseconds();
-	when := now;
+	now := Nanoseconds()
+	when := now
 	for !t.shutdown {
-		when += t.ns;	// next alarm
+		when += t.ns // next alarm
 
 		// if c <- now took too long, skip ahead
 		if when < now {
@@ -47,12 +47,12 @@ func (t *Ticker) ticker(c chan<- int64) {
 			when += t.ns
 		}
 
-		Sleep(when - now);
-		now = Nanoseconds();
+		Sleep(when - now)
+		now = Nanoseconds()
 		if t.shutdown {
 			return
 		}
-		c <- now;
+		c <- now
 	}
 }
 
@@ -62,7 +62,7 @@ func Tick(ns int64) <-chan int64 {
 	if ns <= 0 {
 		return nil
 	}
-	return NewTicker(ns).C;
+	return NewTicker(ns).C
 }
 
 // Ticker returns a new Ticker containing a synchronous channel that will
@@ -72,8 +72,8 @@ func NewTicker(ns int64) *Ticker {
 	if ns <= 0 {
 		return nil
 	}
-	c := make(chan int64);
-	t := &Ticker{c, ns, false};
-	go t.ticker(c);
-	return t;
+	c := make(chan int64)
+	t := &Ticker{c, ns, false}
+	go t.ticker(c)
+	return t
 }
diff --git a/src/pkg/time/tick_test.go b/src/pkg/time/tick_test.go
index 4d1f717edb..e15793aea3 100644
--- a/src/pkg/time/tick_test.go
+++ b/src/pkg/time/tick_test.go
@@ -5,31 +5,31 @@
 package time_test
 
 import (
-	"testing";
-	. "time";
+	"testing"
+	. "time"
 )
 
 func TestTicker(t *testing.T) {
 	const (
-		Delta	= 100 * 1e6;
-		Count	= 10;
+		Delta = 100 * 1e6
+		Count = 10
 	)
-	ticker := NewTicker(Delta);
-	t0 := Nanoseconds();
+	ticker := NewTicker(Delta)
+	t0 := Nanoseconds()
 	for i := 0; i < Count; i++ {
 		<-ticker.C
 	}
-	ticker.Stop();
-	t1 := Nanoseconds();
-	ns := t1 - t0;
-	target := int64(Delta * Count);
-	slop := target * 2 / 10;
+	ticker.Stop()
+	t1 := Nanoseconds()
+	ns := t1 - t0
+	target := int64(Delta * Count)
+	slop := target * 2 / 10
 	if ns < target-slop || ns > target+slop {
 		t.Fatalf("%d ticks of %g ns took %g ns, expected %g", Count, float64(Delta), float64(ns), float64(target))
 	}
 	// Now test that the ticker stopped
-	Sleep(2 * Delta);
-	_, received := <-ticker.C;
+	Sleep(2 * Delta)
+	_, received := <-ticker.C
 	if received {
 		t.Fatalf("Ticker did not shut down")
 	}
diff --git a/src/pkg/time/time.go b/src/pkg/time/time.go
index 1418d521e6..e41ca2dc6d 100644
--- a/src/pkg/time/time.go
+++ b/src/pkg/time/time.go
@@ -7,48 +7,48 @@
 package time
 
 import (
-	"os";
+	"os"
 )
 
 // Seconds reports the number of seconds since the Unix epoch,
 // January 1, 1970 00:00:00 UTC.
 func Seconds() int64 {
-	sec, _, err := os.Time();
+	sec, _, err := os.Time()
 	if err != nil {
 		panic("time: os.Time: ", err.String())
 	}
-	return sec;
+	return sec
 }
 
 // Nanoseconds reports the number of nanoseconds since the Unix epoch,
 // January 1, 1970 00:00:00 UTC.
 func Nanoseconds() int64 {
-	sec, nsec, err := os.Time();
+	sec, nsec, err := os.Time()
 	if err != nil {
 		panic("time: os.Time: ", err.String())
 	}
-	return sec*1e9 + nsec;
+	return sec*1e9 + nsec
 }
 
 // Days of the week.
 const (
-	Sunday	= iota;
-	Monday;
-	Tuesday;
-	Wednesday;
-	Thursday;
-	Friday;
-	Saturday;
+	Sunday = iota
+	Monday
+	Tuesday
+	Wednesday
+	Thursday
+	Friday
+	Saturday
 )
 
 // Time is the struct representing a parsed time value.
 type Time struct {
-	Year			int64;	// 2008 is 2008
-	Month, Day		int;	// Sep-17 is 9, 17
-	Hour, Minute, Second	int;	// 10:43:12 is 10, 43, 12
-	Weekday			int;	// Sunday, Monday, ...
-	ZoneOffset		int;	// seconds east of UTC
-	Zone			string;
+	Year                 int64 // 2008 is 2008
+	Month, Day           int   // Sep-17 is 9, 17
+	Hour, Minute, Second int   // 10:43:12 is 10, 43, 12
+	Weekday              int   // Sunday, Monday, ...
+	ZoneOffset           int   // seconds east of UTC
+	Zone                 string
 }
 
 var nonleapyear = []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
@@ -58,37 +58,37 @@ func months(year int64) []int {
 	if year%4 == 0 && (year%100 != 0 || year%400 == 0) {
 		return leapyear
 	}
-	return nonleapyear;
+	return nonleapyear
 }
 
 const (
-	secondsPerDay	= 24 * 60 * 60;
-	daysPer400Years	= 365*400 + 97;
-	daysPer100Years	= 365*100 + 24;
-	daysPer4Years	= 365*4 + 1;
-	days1970To2001	= 31*365 + 8;
+	secondsPerDay   = 24 * 60 * 60
+	daysPer400Years = 365*400 + 97
+	daysPer100Years = 365*100 + 24
+	daysPer4Years   = 365*4 + 1
+	days1970To2001  = 31*365 + 8
 )
 
 // SecondsToUTC converts sec, in number of seconds since the Unix epoch,
 // into a parsed Time value in the UTC time zone.
 func SecondsToUTC(sec int64) *Time {
-	t := new(Time);
+	t := new(Time)
 
 	// Split into time and day.
-	day := sec / secondsPerDay;
-	sec -= day * secondsPerDay;
+	day := sec / secondsPerDay
+	sec -= day * secondsPerDay
 	if sec < 0 {
-		day--;
-		sec += secondsPerDay;
+		day--
+		sec += secondsPerDay
 	}
 
 	// Time
-	t.Hour = int(sec / 3600);
-	t.Minute = int((sec / 60) % 60);
-	t.Second = int(sec % 60);
+	t.Hour = int(sec / 3600)
+	t.Minute = int((sec / 60) % 60)
+	t.Second = int(sec % 60)
 
 	// Day 0 = January 1, 1970 was a Thursday
-	t.Weekday = int((day + Thursday) % 7);
+	t.Weekday = int((day + Thursday) % 7)
 	if t.Weekday < 0 {
 		t.Weekday += 7
 	}
@@ -96,78 +96,78 @@ func SecondsToUTC(sec int64) *Time {
 	// Change day from 0 = 1970 to 0 = 2001,
 	// to make leap year calculations easier
 	// (2001 begins 4-, 100-, and 400-year cycles ending in a leap year.)
-	day -= days1970To2001;
+	day -= days1970To2001
 
-	year := int64(2001);
+	year := int64(2001)
 	if day < 0 {
 		// Go back enough 400 year cycles to make day positive.
-		n := -day/daysPer400Years + 1;
-		year -= 400 * n;
-		day += daysPer400Years * n;
+		n := -day/daysPer400Years + 1
+		year -= 400 * n
+		day += daysPer400Years * n
 	}
 
 	// Cut off 400 year cycles.
-	n := day / daysPer400Years;
-	year += 400 * n;
-	day -= daysPer400Years * n;
+	n := day / daysPer400Years
+	year += 400 * n
+	day -= daysPer400Years * n
 
 	// Cut off 100-year cycles
-	n = day / daysPer100Years;
-	if n > 3 {	// happens on last day of 400th year
+	n = day / daysPer100Years
+	if n > 3 { // happens on last day of 400th year
 		n = 3
 	}
-	year += 100 * n;
-	day -= daysPer100Years * n;
+	year += 100 * n
+	day -= daysPer100Years * n
 
 	// Cut off 4-year cycles
-	n = day / daysPer4Years;
-	if n > 24 {	// happens on last day of 100th year
+	n = day / daysPer4Years
+	if n > 24 { // happens on last day of 100th year
 		n = 24
 	}
-	year += 4 * n;
-	day -= daysPer4Years * n;
+	year += 4 * n
+	day -= daysPer4Years * n
 
 	// Cut off non-leap years.
-	n = day / 365;
-	if n > 3 {	// happens on last day of 4th year
+	n = day / 365
+	if n > 3 { // happens on last day of 4th year
 		n = 3
 	}
-	year += n;
-	day -= 365 * n;
+	year += n
+	day -= 365 * n
 
-	t.Year = year;
+	t.Year = year
 
 	// If someone ever needs yearday,
 	// tyearday = day (+1?)
 
-	months := months(year);
-	var m int;
-	yday := int(day);
+	months := months(year)
+	var m int
+	yday := int(day)
 	for m = 0; m < 12 && yday >= months[m]; m++ {
 		yday -= months[m]
 	}
-	t.Month = m + 1;
-	t.Day = yday + 1;
-	t.Zone = "UTC";
+	t.Month = m + 1
+	t.Day = yday + 1
+	t.Zone = "UTC"
 
-	return t;
+	return t
 }
 
 // UTC returns the current time as a parsed Time value in the UTC time zone.
-func UTC() *Time	{ return SecondsToUTC(Seconds()) }
+func UTC() *Time { return SecondsToUTC(Seconds()) }
 
 // SecondsToLocalTime converts sec, in number of seconds since the Unix epoch,
 // into a parsed Time value in the local time zone.
 func SecondsToLocalTime(sec int64) *Time {
-	z, offset := lookupTimezone(sec);
-	t := SecondsToUTC(sec + int64(offset));
-	t.Zone = z;
-	t.ZoneOffset = offset;
-	return t;
+	z, offset := lookupTimezone(sec)
+	t := SecondsToUTC(sec + int64(offset))
+	t.Zone = z
+	t.ZoneOffset = offset
+	return t
 }
 
 // LocalTime returns the current time as a parsed Time value in the local time zone.
-func LocalTime() *Time	{ return SecondsToLocalTime(Seconds()) }
+func LocalTime() *Time { return SecondsToLocalTime(Seconds()) }
 
 // Seconds returns the number of seconds since January 1, 1970 represented by the
 // parsed Time value.
@@ -176,56 +176,56 @@ func (t *Time) Seconds() int64 {
 	// Using 2001 instead of 1970 makes the leap-year
 	// handling easier (see SecondsToUTC), because
 	// it is at the beginning of the 4-, 100-, and 400-year cycles.
-	day := int64(0);
+	day := int64(0)
 
 	// Rewrite year to be >= 2001.
-	year := t.Year;
+	year := t.Year
 	if year < 2001 {
-		n := (2001-year)/400 + 1;
-		year += 400 * n;
-		day -= daysPer400Years * n;
+		n := (2001-year)/400 + 1
+		year += 400 * n
+		day -= daysPer400Years * n
 	}
 
 	// Add in days from 400-year cycles.
-	n := (year - 2001) / 400;
-	year -= 400 * n;
-	day += daysPer400Years * n;
+	n := (year - 2001) / 400
+	year -= 400 * n
+	day += daysPer400Years * n
 
 	// Add in 100-year cycles.
-	n = (year - 2001) / 100;
-	year -= 100 * n;
-	day += daysPer100Years * n;
+	n = (year - 2001) / 100
+	year -= 100 * n
+	day += daysPer100Years * n
 
 	// Add in 4-year cycles.
-	n = (year - 2001) / 4;
-	year -= 4 * n;
-	day += daysPer4Years * n;
+	n = (year - 2001) / 4
+	year -= 4 * n
+	day += daysPer4Years * n
 
 	// Add in non-leap years.
-	n = year - 2001;
-	day += 365 * n;
+	n = year - 2001
+	day += 365 * n
 
 	// Add in days this year.
-	months := months(t.Year);
+	months := months(t.Year)
 	for m := 0; m < t.Month-1; m++ {
 		day += int64(months[m])
 	}
-	day += int64(t.Day - 1);
+	day += int64(t.Day - 1)
 
 	// Convert days to seconds since January 1, 2001.
-	sec := day * secondsPerDay;
+	sec := day * secondsPerDay
 
 	// Add in time elapsed today.
-	sec += int64(t.Hour) * 3600;
-	sec += int64(t.Minute) * 60;
-	sec += int64(t.Second);
+	sec += int64(t.Hour) * 3600
+	sec += int64(t.Minute) * 60
+	sec += int64(t.Second)
 
 	// Convert from seconds since 2001 to seconds since 1970.
-	sec += days1970To2001 * secondsPerDay;
+	sec += days1970To2001 * secondsPerDay
 
 	// Account for local time zone.
-	sec -= int64(t.ZoneOffset);
-	return sec;
+	sec -= int64(t.ZoneOffset)
+	return sec
 }
 
 var longDayNames = []string{
@@ -275,86 +275,86 @@ func decimal(dst []byte, n int) {
 		n = 0
 	}
 	for i := len(dst) - 1; i >= 0; i-- {
-		dst[i] = byte(n%10 + '0');
-		n /= 10;
+		dst[i] = byte(n%10 + '0')
+		n /= 10
 	}
 }
 
 func addString(buf []byte, bp int, s string) int {
-	n := len(s);
-	copy(buf[bp:bp+n], s);
-	return bp + n;
+	n := len(s)
+	copy(buf[bp:bp+n], s)
+	return bp + n
 }
 
 // Just enough of strftime to implement the date formats below.
 // Not exported.
 func format(t *Time, fmt string) string {
-	buf := make([]byte, 128);
-	bp := 0;
+	buf := make([]byte, 128)
+	bp := 0
 
 	for i := 0; i < len(fmt); i++ {
 		if fmt[i] == '%' {
-			i++;
+			i++
 			switch fmt[i] {
-			case 'A':	// %A full weekday name
+			case 'A': // %A full weekday name
 				bp = addString(buf, bp, longDayNames[t.Weekday])
-			case 'a':	// %a abbreviated weekday name
+			case 'a': // %a abbreviated weekday name
 				bp = addString(buf, bp, shortDayNames[t.Weekday])
-			case 'b':	// %b abbreviated month name
+			case 'b': // %b abbreviated month name
 				bp = addString(buf, bp, shortMonthNames[t.Month])
-			case 'd':	// %d day of month (01-31)
-				decimal(buf[bp:bp+2], t.Day);
-				bp += 2;
-			case 'e':	// %e day of month ( 1-31)
+			case 'd': // %d day of month (01-31)
+				decimal(buf[bp:bp+2], t.Day)
+				bp += 2
+			case 'e': // %e day of month ( 1-31)
 				if t.Day >= 10 {
 					decimal(buf[bp:bp+2], t.Day)
 				} else {
-					buf[bp] = ' ';
-					buf[bp+1] = byte(t.Day + '0');
+					buf[bp] = ' '
+					buf[bp+1] = byte(t.Day + '0')
 				}
-				bp += 2;
-			case 'H':	// %H hour 00-23
-				decimal(buf[bp:bp+2], t.Hour);
-				bp += 2;
-			case 'M':	// %M minute 00-59
-				decimal(buf[bp:bp+2], t.Minute);
-				bp += 2;
-			case 'S':	// %S second 00-59
-				decimal(buf[bp:bp+2], t.Second);
-				bp += 2;
-			case 'Y':	// %Y year 2008
-				decimal(buf[bp:bp+4], int(t.Year));
-				bp += 4;
-			case 'y':	// %y year 08
-				decimal(buf[bp:bp+2], int(t.Year%100));
-				bp += 2;
+				bp += 2
+			case 'H': // %H hour 00-23
+				decimal(buf[bp:bp+2], t.Hour)
+				bp += 2
+			case 'M': // %M minute 00-59
+				decimal(buf[bp:bp+2], t.Minute)
+				bp += 2
+			case 'S': // %S second 00-59
+				decimal(buf[bp:bp+2], t.Second)
+				bp += 2
+			case 'Y': // %Y year 2008
+				decimal(buf[bp:bp+4], int(t.Year))
+				bp += 4
+			case 'y': // %y year 08
+				decimal(buf[bp:bp+2], int(t.Year%100))
+				bp += 2
 			case 'Z':
 				bp = addString(buf, bp, t.Zone)
 			default:
-				buf[bp] = '%';
-				buf[bp+1] = fmt[i];
-				bp += 2;
+				buf[bp] = '%'
+				buf[bp+1] = fmt[i]
+				bp += 2
 			}
 		} else {
-			buf[bp] = fmt[i];
-			bp++;
+			buf[bp] = fmt[i]
+			bp++
 		}
 	}
-	return string(buf[0:bp]);
+	return string(buf[0:bp])
 }
 
 // Asctime formats the parsed time value in the style of
 // ANSI C asctime: Sun Nov  6 08:49:37 1994
-func (t *Time) Asctime() string	{ return format(t, "%a %b %e %H:%M:%S %Y") }
+func (t *Time) Asctime() string { return format(t, "%a %b %e %H:%M:%S %Y") }
 
 // RFC850 formats the parsed time value in the style of
 // RFC 850: Sunday, 06-Nov-94 08:49:37 UTC
-func (t *Time) RFC850() string	{ return format(t, "%A, %d-%b-%y %H:%M:%S %Z") }
+func (t *Time) RFC850() string { return format(t, "%A, %d-%b-%y %H:%M:%S %Z") }
 
 // RFC1123 formats the parsed time value in the style of
 // RFC 1123: Sun, 06 Nov 1994 08:49:37 UTC
-func (t *Time) RFC1123() string	{ return format(t, "%a, %d %b %Y %H:%M:%S %Z") }
+func (t *Time) RFC1123() string { return format(t, "%a, %d %b %Y %H:%M:%S %Z") }
 
 // String formats the parsed time value in the style of
 // date(1) - Sun Nov  6 08:49:37 UTC 1994
-func (t *Time) String() string	{ return format(t, "%a %b %e %H:%M:%S %Z %Y") }
+func (t *Time) String() string { return format(t, "%a %b %e %H:%M:%S %Z %Y") }
diff --git a/src/pkg/time/time_test.go b/src/pkg/time/time_test.go
index 88b16ee26a..23040d8ed1 100644
--- a/src/pkg/time/time_test.go
+++ b/src/pkg/time/time_test.go
@@ -5,10 +5,10 @@
 package time_test
 
 import (
-	"os";
-	"testing";
-	"testing/quick";
-	. "time";
+	"os"
+	"testing"
+	"testing/quick"
+	. "time"
 )
 
 func init() {
@@ -19,8 +19,8 @@ func init() {
 }
 
 type TimeTest struct {
-	seconds	int64;
-	golden	Time;
+	seconds int64
+	golden  Time
 }
 
 var utctests = []TimeTest{
@@ -55,42 +55,42 @@ func same(t, u *Time) bool {
 
 func TestSecondsToUTC(t *testing.T) {
 	for i := 0; i < len(utctests); i++ {
-		sec := utctests[i].seconds;
-		golden := &utctests[i].golden;
-		tm := SecondsToUTC(sec);
-		newsec := tm.Seconds();
+		sec := utctests[i].seconds
+		golden := &utctests[i].golden
+		tm := SecondsToUTC(sec)
+		newsec := tm.Seconds()
 		if newsec != sec {
 			t.Errorf("SecondsToUTC(%d).Seconds() = %d", sec, newsec)
 		}
 		if !same(tm, golden) {
-			t.Errorf("SecondsToUTC(%d):", sec);
-			t.Errorf("  want=%+v", *golden);
-			t.Errorf("  have=%+v", *tm);
+			t.Errorf("SecondsToUTC(%d):", sec)
+			t.Errorf("  want=%+v", *golden)
+			t.Errorf("  have=%+v", *tm)
 		}
 	}
 }
 
 func TestSecondsToLocalTime(t *testing.T) {
 	for i := 0; i < len(localtests); i++ {
-		sec := localtests[i].seconds;
-		golden := &localtests[i].golden;
-		tm := SecondsToLocalTime(sec);
-		newsec := tm.Seconds();
+		sec := localtests[i].seconds
+		golden := &localtests[i].golden
+		tm := SecondsToLocalTime(sec)
+		newsec := tm.Seconds()
 		if newsec != sec {
 			t.Errorf("SecondsToLocalTime(%d).Seconds() = %d", sec, newsec)
 		}
 		if !same(tm, golden) {
-			t.Errorf("SecondsToLocalTime(%d):", sec);
-			t.Errorf("  want=%+v", *golden);
-			t.Errorf("  have=%+v", *tm);
+			t.Errorf("SecondsToLocalTime(%d):", sec)
+			t.Errorf("  want=%+v", *golden)
+			t.Errorf("  have=%+v", *tm)
 		}
 	}
 }
 
 func TestSecondsToUTCAndBack(t *testing.T) {
-	f := func(sec int64) bool { return SecondsToUTC(sec).Seconds() == sec };
-	f32 := func(sec int32) bool { return f(int64(sec)) };
-	cfg := &quick.Config{MaxCount: 10000};
+	f := func(sec int64) bool { return SecondsToUTC(sec).Seconds() == sec }
+	f32 := func(sec int32) bool { return f(int64(sec)) }
+	cfg := &quick.Config{MaxCount: 10000}
 
 	// Try a reasonable date first, then the huge ones.
 	if err := quick.Check(f32, cfg); err != nil {
diff --git a/src/pkg/time/zoneinfo.go b/src/pkg/time/zoneinfo.go
index 8d8048aa05..98d816b101 100644
--- a/src/pkg/time/zoneinfo.go
+++ b/src/pkg/time/zoneinfo.go
@@ -10,50 +10,50 @@
 package time
 
 import (
-	"io/ioutil";
-	"once";
-	"os";
+	"io/ioutil"
+	"once"
+	"os"
 )
 
 const (
-	headerSize	= 4 + 16 + 4*7;
-	zoneDir		= "/usr/share/zoneinfo/";
+	headerSize = 4 + 16 + 4*7
+	zoneDir    = "/usr/share/zoneinfo/"
 )
 
 // Simple I/O interface to binary blob of data.
 type data struct {
-	p	[]byte;
-	error	bool;
+	p     []byte
+	error bool
 }
 
 
 func (d *data) read(n int) []byte {
 	if len(d.p) < n {
-		d.p = nil;
-		d.error = true;
-		return nil;
+		d.p = nil
+		d.error = true
+		return nil
 	}
-	p := d.p[0:n];
-	d.p = d.p[n:];
-	return p;
+	p := d.p[0:n]
+	d.p = d.p[n:]
+	return p
 }
 
 func (d *data) big4() (n uint32, ok bool) {
-	p := d.read(4);
+	p := d.read(4)
 	if len(p) < 4 {
-		d.error = true;
-		return 0, false;
+		d.error = true
+		return 0, false
 	}
-	return uint32(p[0])<<24 | uint32(p[1])<<16 | uint32(p[2])<<8 | uint32(p[3]), true;
+	return uint32(p[0])<<24 | uint32(p[1])<<16 | uint32(p[2])<<8 | uint32(p[3]), true
 }
 
 func (d *data) byte() (n byte, ok bool) {
-	p := d.read(1);
+	p := d.read(1)
 	if len(p) < 1 {
-		d.error = true;
-		return 0, false;
+		d.error = true
+		return 0, false
 	}
-	return p[0], true;
+	return p[0], true
 }
 
 
@@ -64,24 +64,24 @@ func byteString(p []byte) string {
 			return string(p[0:i])
 		}
 	}
-	return string(p);
+	return string(p)
 }
 
 // Parsed representation
 type zone struct {
-	utcoff	int;
-	isdst	bool;
-	name	string;
+	utcoff int
+	isdst  bool
+	name   string
 }
 
 type zonetime struct {
-	time		int32;	// transition time, in seconds since 1970 GMT
-	zone		*zone;	// the zone that goes into effect at that time
-	isstd, isutc	bool;	// ignored - no idea what these mean
+	time         int32 // transition time, in seconds since 1970 GMT
+	zone         *zone // the zone that goes into effect at that time
+	isstd, isutc bool  // ignored - no idea what these mean
 }
 
 func parseinfo(bytes []byte) (zt []zonetime, ok bool) {
-	d := data{bytes, false};
+	d := data{bytes, false}
 
 	// 4-byte magic "TZif"
 	if magic := d.read(4); string(magic) != "TZif" {
@@ -89,7 +89,7 @@ func parseinfo(bytes []byte) (zt []zonetime, ok bool) {
 	}
 
 	// 1-byte version, then 15 bytes of padding
-	var p []byte;
+	var p []byte
 	if p = d.read(16); len(p) != 16 || p[0] != 0 && p[0] != '2' {
 		return nil, false
 	}
@@ -102,46 +102,46 @@ func parseinfo(bytes []byte) (zt []zonetime, ok bool) {
 	//	number of local time zones
 	//	number of characters of time zone abbrev strings
 	const (
-		NUTCLocal	= iota;
-		NStdWall;
-		NLeap;
-		NTime;
-		NZone;
-		NChar;
+		NUTCLocal = iota
+		NStdWall
+		NLeap
+		NTime
+		NZone
+		NChar
 	)
-	var n [6]int;
+	var n [6]int
 	for i := 0; i < 6; i++ {
-		nn, ok := d.big4();
+		nn, ok := d.big4()
 		if !ok {
 			return nil, false
 		}
-		n[i] = int(nn);
+		n[i] = int(nn)
 	}
 
 	// Transition times.
-	txtimes := data{d.read(n[NTime] * 4), false};
+	txtimes := data{d.read(n[NTime] * 4), false}
 
 	// Time zone indices for transition times.
-	txzones := d.read(n[NTime]);
+	txzones := d.read(n[NTime])
 
 	// Zone info structures
-	zonedata := data{d.read(n[NZone] * 6), false};
+	zonedata := data{d.read(n[NZone] * 6), false}
 
 	// Time zone abbreviations.
-	abbrev := d.read(n[NChar]);
+	abbrev := d.read(n[NChar])
 
 	// Leap-second time pairs
-	d.read(n[NLeap] * 8);
+	d.read(n[NLeap] * 8)
 
 	// Whether tx times associated with local time types
 	// are specified as standard time or wall time.
-	isstd := d.read(n[NStdWall]);
+	isstd := d.read(n[NStdWall])
 
 	// Whether tx times associated with local time types
 	// are specified as UTC or local time.
-	isutc := d.read(n[NUTCLocal]);
+	isutc := d.read(n[NUTCLocal])
 
-	if d.error {	// ran out of data
+	if d.error { // ran out of data
 		return nil, false
 	}
 
@@ -152,38 +152,38 @@ func parseinfo(bytes []byte) (zt []zonetime, ok bool) {
 	// Now we can build up a useful data structure.
 	// First the zone information.
 	//	utcoff[4] isdst[1] nameindex[1]
-	z := make([]zone, n[NZone]);
+	z := make([]zone, n[NZone])
 	for i := 0; i < len(z); i++ {
-		var ok bool;
-		var n uint32;
+		var ok bool
+		var n uint32
 		if n, ok = zonedata.big4(); !ok {
 			return nil, false
 		}
-		z[i].utcoff = int(n);
-		var b byte;
+		z[i].utcoff = int(n)
+		var b byte
 		if b, ok = zonedata.byte(); !ok {
 			return nil, false
 		}
-		z[i].isdst = b != 0;
+		z[i].isdst = b != 0
 		if b, ok = zonedata.byte(); !ok || int(b) >= len(abbrev) {
 			return nil, false
 		}
-		z[i].name = byteString(abbrev[b:]);
+		z[i].name = byteString(abbrev[b:])
 	}
 
 	// Now the transition time info.
-	zt = make([]zonetime, n[NTime]);
+	zt = make([]zonetime, n[NTime])
 	for i := 0; i < len(zt); i++ {
-		var ok bool;
-		var n uint32;
+		var ok bool
+		var n uint32
 		if n, ok = txtimes.big4(); !ok {
 			return nil, false
 		}
-		zt[i].time = int32(n);
+		zt[i].time = int32(n)
 		if int(txzones[i]) >= len(z) {
 			return nil, false
 		}
-		zt[i].zone = &z[txzones[i]];
+		zt[i].zone = &z[txzones[i]]
 		if i < len(isstd) {
 			zt[i].isstd = isstd[i] != 0
 		}
@@ -191,15 +191,15 @@ func parseinfo(bytes []byte) (zt []zonetime, ok bool) {
 			zt[i].isutc = isutc[i] != 0
 		}
 	}
-	return zt, true;
+	return zt, true
 }
 
 func readinfofile(name string) ([]zonetime, bool) {
-	buf, err := ioutil.ReadFile(name);
+	buf, err := ioutil.ReadFile(name)
 	if err != nil {
 		return nil, false
 	}
-	return parseinfo(buf);
+	return parseinfo(buf)
 }
 
 var zones []zonetime
@@ -210,7 +210,7 @@ func setupZone() {
 	// $TZ="" means use UTC.
 	// $TZ="foo" means use /usr/share/zoneinfo/foo.
 
-	tz, err := os.Getenverror("TZ");
+	tz, err := os.Getenverror("TZ")
 	switch {
 	case err == os.ENOENV:
 		zones, _ = readinfofile("/etc/localtime")
@@ -222,21 +222,21 @@ func setupZone() {
 }
 
 func lookupTimezone(sec int64) (zone string, offset int) {
-	once.Do(setupZone);
+	once.Do(setupZone)
 	if len(zones) == 0 {
 		return "UTC", 0
 	}
 
 	// Binary search for entry with largest time <= sec
-	tz := zones;
+	tz := zones
 	for len(tz) > 1 {
-		m := len(tz) / 2;
+		m := len(tz) / 2
 		if sec < int64(tz[m].time) {
 			tz = tz[0:m]
 		} else {
 			tz = tz[m:]
 		}
 	}
-	z := tz[0].zone;
-	return z.name, z.utcoff;
+	z := tz[0].zone
+	return z.name, z.utcoff
 }
diff --git a/src/pkg/unicode/digit.go b/src/pkg/unicode/digit.go
index b12ada2d63..471c4dfdc5 100644
--- a/src/pkg/unicode/digit.go
+++ b/src/pkg/unicode/digit.go
@@ -6,8 +6,8 @@ package unicode
 
 // IsDigit reports whether the rune is a decimal digit.
 func IsDigit(rune int) bool {
-	if rune < 0x100 {	// quick ASCII (Latin-1, really) check
+	if rune < 0x100 { // quick ASCII (Latin-1, really) check
 		return '0' <= rune && rune <= '9'
 	}
-	return Is(Digit, rune);
+	return Is(Digit, rune)
 }
diff --git a/src/pkg/unicode/digit_test.go b/src/pkg/unicode/digit_test.go
index 3031eafc87..57a625b022 100644
--- a/src/pkg/unicode/digit_test.go
+++ b/src/pkg/unicode/digit_test.go
@@ -5,8 +5,8 @@
 package unicode_test
 
 import (
-	"testing";
-	. "unicode";
+	"testing"
+	. "unicode"
 )
 
 var testDigit = []int{
diff --git a/src/pkg/unicode/letter.go b/src/pkg/unicode/letter.go
index b249f2389b..8020cd0cf2 100644
--- a/src/pkg/unicode/letter.go
+++ b/src/pkg/unicode/letter.go
@@ -6,17 +6,17 @@
 package unicode
 
 const (
-	MaxRune		= 0x10FFFF;	// Maximum valid Unicode code point.
-	ReplacementChar	= 0xFFFD;	// Represents invalid code points.
+	MaxRune         = 0x10FFFF // Maximum valid Unicode code point.
+	ReplacementChar = 0xFFFD   // Represents invalid code points.
 )
 
 
 // The representation of a range of Unicode code points.  The range runs from Lo to Hi
 // inclusive and has the specified stride.
 type Range struct {
-	Lo	int;
-	Hi	int;
-	Stride	int;
+	Lo     int
+	Hi     int
+	Stride int
 }
 
 // The representation of a range of Unicode code points for case conversion.
@@ -29,26 +29,26 @@ type Range struct {
 //	{UpperLower, UpperLower, UpperLower}
 // The constant UpperLower has an otherwise impossible delta value.
 type CaseRange struct {
-	Lo	int;
-	Hi	int;
-	Delta	d;
+	Lo    int
+	Hi    int
+	Delta d
 }
 
 // Indices into the Delta arrays inside CaseRanges for case mapping.
 const (
-	UpperCase	= iota;
-	LowerCase;
-	TitleCase;
-	MaxCase;
+	UpperCase = iota
+	LowerCase
+	TitleCase
+	MaxCase
 )
 
-type d [MaxCase]int32	// to make the CaseRanges text shorter
+type d [MaxCase]int32 // to make the CaseRanges text shorter
 
 // If the Delta field of a CaseRange is UpperLower or LowerUpper, it means
 // this CaseRange represents a sequence of the form (say)
 // Upper Lower Upper Lower.
 const (
-	UpperLower = MaxRune + 1;	// (Cannot be a valid delta.)
+	UpperLower = MaxRune + 1 // (Cannot be a valid delta.)
 )
 
 // Is tests whether rune is in the specified table of ranges.
@@ -62,17 +62,17 @@ func Is(ranges []Range, rune int) bool {
 			if rune < r.Lo {
 				return false
 			}
-			return (rune-r.Lo)%r.Stride == 0;
+			return (rune-r.Lo)%r.Stride == 0
 		}
-		return false;
+		return false
 	}
 
 	// binary search over ranges
-	lo := 0;
-	hi := len(ranges);
+	lo := 0
+	hi := len(ranges)
 	for lo < hi {
-		m := lo + (hi-lo)/2;
-		r := ranges[m];
+		m := lo + (hi-lo)/2
+		r := ranges[m]
 		if r.Lo <= rune && rune <= r.Hi {
 			return (rune-r.Lo)%r.Stride == 0
 		}
@@ -82,67 +82,67 @@ func Is(ranges []Range, rune int) bool {
 			lo = m + 1
 		}
 	}
-	return false;
+	return false
 }
 
 // IsUpper reports whether the rune is an upper case letter.
 func IsUpper(rune int) bool {
-	if rune < 0x80 {	// quick ASCII check
+	if rune < 0x80 { // quick ASCII check
 		return 'A' <= rune && rune <= 'Z'
 	}
-	return Is(Upper, rune);
+	return Is(Upper, rune)
 }
 
 // IsLower reports whether the rune is a lower case letter.
 func IsLower(rune int) bool {
-	if rune < 0x80 {	// quick ASCII check
+	if rune < 0x80 { // quick ASCII check
 		return 'a' <= rune && rune <= 'z'
 	}
-	return Is(Lower, rune);
+	return Is(Lower, rune)
 }
 
 // IsTitle reports whether the rune is a title case letter.
 func IsTitle(rune int) bool {
-	if rune < 0x80 {	// quick ASCII check
+	if rune < 0x80 { // quick ASCII check
 		return false
 	}
-	return Is(Title, rune);
+	return Is(Title, rune)
 }
 
 // IsLetter reports whether the rune is a letter.
 func IsLetter(rune int) bool {
-	if rune < 0x80 {	// quick ASCII check
-		rune &^= 'a' - 'A';
-		return 'A' <= rune && rune <= 'Z';
+	if rune < 0x80 { // quick ASCII check
+		rune &^= 'a' - 'A'
+		return 'A' <= rune && rune <= 'Z'
 	}
-	return Is(Letter, rune);
+	return Is(Letter, rune)
 }
 
 // IsSpace reports whether the rune is a white space character.
 func IsSpace(rune int) bool {
-	if rune <= 0xFF {	// quick Latin-1 check
+	if rune <= 0xFF { // quick Latin-1 check
 		switch rune {
 		case '\t', '\n', '\v', '\f', '\r', ' ', 0x85, 0xA0:
 			return true
 		}
-		return false;
+		return false
 	}
-	return Is(White_Space, rune);
+	return Is(White_Space, rune)
 }
 
 // To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase
 func To(_case int, rune int) int {
 	if _case < 0 || MaxCase <= _case {
-		return ReplacementChar	// as reasonable an error as any
+		return ReplacementChar // as reasonable an error as any
 	}
 	// binary search over ranges
-	lo := 0;
-	hi := len(CaseRanges);
+	lo := 0
+	hi := len(CaseRanges)
 	for lo < hi {
-		m := lo + (hi-lo)/2;
-		r := CaseRanges[m];
+		m := lo + (hi-lo)/2
+		r := CaseRanges[m]
 		if r.Lo <= rune && rune <= r.Hi {
-			delta := int(r.Delta[_case]);
+			delta := int(r.Delta[_case])
 			if delta > MaxRune {
 				// In an Upper-Lower sequence, which always starts with
 				// an UpperCase letter, the real deltas always look like:
@@ -156,7 +156,7 @@ func To(_case int, rune int) int {
 				// is odd so we take the low bit from _case.
 				return r.Lo + ((rune-r.Lo)&^1 | _case&1)
 			}
-			return rune + delta;
+			return rune + delta
 		}
 		if rune < r.Lo {
 			hi = m
@@ -164,38 +164,38 @@ func To(_case int, rune int) int {
 			lo = m + 1
 		}
 	}
-	return rune;
+	return rune
 }
 
 // ToUpper maps the rune to upper case
 func ToUpper(rune int) int {
-	if rune < 0x80 {	// quick ASCII check
+	if rune < 0x80 { // quick ASCII check
 		if 'a' <= rune && rune <= 'z' {
 			rune -= 'a' - 'A'
 		}
-		return rune;
+		return rune
 	}
-	return To(UpperCase, rune);
+	return To(UpperCase, rune)
 }
 
 // ToLower maps the rune to lower case
 func ToLower(rune int) int {
-	if rune < 0x80 {	// quick ASCII check
+	if rune < 0x80 { // quick ASCII check
 		if 'A' <= rune && rune <= 'Z' {
 			rune += 'a' - 'A'
 		}
-		return rune;
+		return rune
 	}
-	return To(LowerCase, rune);
+	return To(LowerCase, rune)
 }
 
 // ToTitle maps the rune to title case
 func ToTitle(rune int) int {
-	if rune < 0x80 {	// quick ASCII check
-		if 'a' <= rune && rune <= 'z' {	// title case is upper case for ASCII
+	if rune < 0x80 { // quick ASCII check
+		if 'a' <= rune && rune <= 'z' { // title case is upper case for ASCII
 			rune -= 'a' - 'A'
 		}
-		return rune;
+		return rune
 	}
-	return To(TitleCase, rune);
+	return To(TitleCase, rune)
 }
diff --git a/src/pkg/unicode/letter_test.go b/src/pkg/unicode/letter_test.go
index 8e4f5373e8..f39fced665 100644
--- a/src/pkg/unicode/letter_test.go
+++ b/src/pkg/unicode/letter_test.go
@@ -5,8 +5,8 @@
 package unicode_test
 
 import (
-	"testing";
-	. "unicode";
+	"testing"
+	. "unicode"
 )
 
 var upperTest = []int{
@@ -107,7 +107,7 @@ var spaceTest = []int{
 }
 
 type caseT struct {
-	cas, in, out int;
+	cas, in, out int
 }
 
 var caseTest = []caseT{
@@ -258,12 +258,12 @@ func caseString(c int) string {
 	case TitleCase:
 		return "TitleCase"
 	}
-	return "ErrorCase";
+	return "ErrorCase"
 }
 
 func TestTo(t *testing.T) {
 	for _, c := range caseTest {
-		r := To(c.cas, c.in);
+		r := To(c.cas, c.in)
 		if c.out != r {
 			t.Errorf("To(U+%04X, %s) = U+%04X want U+%04X\n", c.in, caseString(c.cas), r, c.out)
 		}
@@ -275,7 +275,7 @@ func TestToUpperCase(t *testing.T) {
 		if c.cas != UpperCase {
 			continue
 		}
-		r := ToUpper(c.in);
+		r := ToUpper(c.in)
 		if c.out != r {
 			t.Errorf("ToUpper(U+%04X) = U+%04X want U+%04X\n", c.in, r, c.out)
 		}
@@ -287,7 +287,7 @@ func TestToLowerCase(t *testing.T) {
 		if c.cas != LowerCase {
 			continue
 		}
-		r := ToLower(c.in);
+		r := ToLower(c.in)
 		if c.out != r {
 			t.Errorf("ToLower(U+%04X) = U+%04X want U+%04X\n", c.in, r, c.out)
 		}
@@ -299,7 +299,7 @@ func TestToTitleCase(t *testing.T) {
 		if c.cas != TitleCase {
 			continue
 		}
-		r := ToTitle(c.in);
+		r := ToTitle(c.in)
 		if c.out != r {
 			t.Errorf("ToTitle(U+%04X) = U+%04X want U+%04X\n", c.in, r, c.out)
 		}
diff --git a/src/pkg/unicode/maketables.go b/src/pkg/unicode/maketables.go
index 486742e64f..75d16418ef 100644
--- a/src/pkg/unicode/maketables.go
+++ b/src/pkg/unicode/maketables.go
@@ -8,26 +8,26 @@
 package main
 
 import (
-	"bufio";
-	"flag";
-	"fmt";
-	"http";
-	"log";
-	"os";
-	"sort";
-	"strconv";
-	"strings";
-	"regexp";
-	"unicode";
+	"bufio"
+	"flag"
+	"fmt"
+	"http"
+	"log"
+	"os"
+	"sort"
+	"strconv"
+	"strings"
+	"regexp"
+	"unicode"
 )
 
 func main() {
-	flag.Parse();
-	loadChars();	// always needed
-	printCategories();
-	printScriptOrProperty(false);
-	printScriptOrProperty(true);
-	printCases();
+	flag.Parse()
+	loadChars() // always needed
+	printCategories()
+	printScriptOrProperty(false)
+	printScriptOrProperty(true)
+	printCases()
 }
 
 var dataURL = flag.String("data", "", "full URL for UnicodeData.txt; defaults to --url/UnicodeData.txt")
@@ -53,7 +53,7 @@ var test = flag.Bool("test",
 var scriptRe = regexp.MustCompile(`([0-9A-F]+)(\.\.[0-9A-F]+)? *; ([A-Za-z_]+)`)
 var die = log.New(os.Stderr, nil, "", log.Lexit|log.Lshortfile)
 
-var category = map[string]bool{"letter": true}	// Nd Lu etc. letter is a special case
+var category = map[string]bool{"letter": true} // Nd Lu etc. letter is a special case
 
 // UnicodeData.txt has form:
 //	0037;DIGIT SEVEN;Nd;0;EN;;7;7;7;N;;;;;
@@ -61,24 +61,24 @@ var category = map[string]bool{"letter": true}	// Nd Lu etc. letter is a special
 // See http://www.unicode.org/Public/5.1.0/ucd/UCD.html for full explanation
 // The fields:
 const (
-	FCodePoint	= iota;
-	FName;
-	FGeneralCategory;
-	FCanonicalCombiningClass;
-	FBidiClass;
-	FDecompositionType;
-	FDecompositionMapping;
-	FNumericType;
-	FNumericValue;
-	FBidiMirrored;
-	FUnicode1Name;
-	FISOComment;
-	FSimpleUppercaseMapping;
-	FSimpleLowercaseMapping;
-	FSimpleTitlecaseMapping;
-	NumField;
-
-	MaxChar	= 0x10FFFF;	// anything above this shouldn't exist
+	FCodePoint = iota
+	FName
+	FGeneralCategory
+	FCanonicalCombiningClass
+	FBidiClass
+	FDecompositionType
+	FDecompositionMapping
+	FNumericType
+	FNumericValue
+	FBidiMirrored
+	FUnicode1Name
+	FISOComment
+	FSimpleUppercaseMapping
+	FSimpleLowercaseMapping
+	FSimpleTitlecaseMapping
+	NumField
+
+	MaxChar = 0x10FFFF // anything above this shouldn't exist
 )
 
 var fieldName = []string{
@@ -101,12 +101,12 @@ var fieldName = []string{
 
 // This contains only the properties we're interested in.
 type Char struct {
-	field		[]string;	// debugging only; could be deleted if we take out char.dump()
-	codePoint	uint32;		// if zero, this index is not a valid code point.
-	category	string;
-	upperCase	int;
-	lowerCase	int;
-	titleCase	int;
+	field     []string // debugging only; could be deleted if we take out char.dump()
+	codePoint uint32   // if zero, this index is not a valid code point.
+	category  string
+	upperCase int
+	lowerCase int
+	titleCase int
 }
 
 // Scripts.txt has form:
@@ -115,13 +115,13 @@ type Char struct {
 // See http://www.unicode.org/Public/5.1.0/ucd/UCD.html for full explanation
 
 type Script struct {
-	lo, hi	uint32;	// range of code points
-	script	string;
+	lo, hi uint32 // range of code points
+	script string
 }
 
 var chars = make([]Char, MaxChar+1)
 var scripts = make(map[string][]Script)
-var props = make(map[string][]Script)	// a property looks like a script; can share the format
+var props = make(map[string][]Script) // a property looks like a script; can share the format
 
 var lastChar uint32 = 0
 
@@ -132,40 +132,40 @@ var lastChar uint32 = 0
 type State int
 
 const (
-	SNormal	State	= iota;	// known to be zero for the type
-	SFirst;
-	SLast;
-	SMissing;
+	SNormal State = iota // known to be zero for the type
+	SFirst
+	SLast
+	SMissing
 )
 
 func parseCategory(line string) (state State) {
-	field := strings.Split(line, ";", -1);
+	field := strings.Split(line, ";", -1)
 	if len(field) != NumField {
 		die.Logf("%5s: %d fields (expected %d)\n", line, len(field), NumField)
 	}
-	point, err := strconv.Btoui64(field[FCodePoint], 16);
+	point, err := strconv.Btoui64(field[FCodePoint], 16)
 	if err != nil {
 		die.Log("%.5s...:", err)
 	}
-	lastChar = uint32(point);
+	lastChar = uint32(point)
 	if point == 0 {
-		return	// not interesting and we use 0 as unset
+		return // not interesting and we use 0 as unset
 	}
 	if point > MaxChar {
 		return
 	}
-	char := &chars[point];
-	char.field = field;
+	char := &chars[point]
+	char.field = field
 	if char.codePoint != 0 {
 		die.Logf("point U+%04x reused\n")
 	}
-	char.codePoint = lastChar;
-	char.category = field[FGeneralCategory];
-	category[char.category] = true;
+	char.codePoint = lastChar
+	char.category = field[FGeneralCategory]
+	category[char.category] = true
 	switch char.category {
 	case "Nd":
 		// Decimal digit
-		_, err := strconv.Atoi(field[FNumericValue]);
+		_, err := strconv.Atoi(field[FNumericValue])
 		if err != nil {
 			die.Log("U+%04x: bad numeric field: %s", point, err)
 		}
@@ -184,66 +184,66 @@ func parseCategory(line string) (state State) {
 	case strings.Index(field[FName], ", Last>") > 0:
 		state = SLast
 	}
-	return;
+	return
 }
 
 func (char *Char) dump(s string) {
-	fmt.Print(s, " ");
+	fmt.Print(s, " ")
 	for i := 0; i < len(char.field); i++ {
 		fmt.Printf("%s:%q ", fieldName[i], char.field[i])
 	}
-	fmt.Print("\n");
+	fmt.Print("\n")
 }
 
 func (char *Char) letter(u, l, t string) {
-	char.upperCase = char.letterValue(u, "U");
-	char.lowerCase = char.letterValue(l, "L");
-	char.titleCase = char.letterValue(t, "T");
+	char.upperCase = char.letterValue(u, "U")
+	char.lowerCase = char.letterValue(l, "L")
+	char.titleCase = char.letterValue(t, "T")
 }
 
 func (char *Char) letterValue(s string, cas string) int {
 	if s == "" {
 		return 0
 	}
-	v, err := strconv.Btoui64(s, 16);
+	v, err := strconv.Btoui64(s, 16)
 	if err != nil {
-		char.dump(cas);
-		die.Logf("U+%04x: bad letter(%s): %s", char.codePoint, s, err);
+		char.dump(cas)
+		die.Logf("U+%04x: bad letter(%s): %s", char.codePoint, s, err)
 	}
-	return int(v);
+	return int(v)
 }
 
 func allCategories() []string {
-	a := make([]string, len(category));
-	i := 0;
+	a := make([]string, len(category))
+	i := 0
 	for k := range category {
-		a[i] = k;
-		i++;
+		a[i] = k
+		i++
 	}
-	return a;
+	return a
 }
 
 func all(scripts map[string][]Script) []string {
-	a := make([]string, len(scripts));
-	i := 0;
+	a := make([]string, len(scripts))
+	i := 0
 	for k := range scripts {
-		a[i] = k;
-		i++;
+		a[i] = k
+		i++
 	}
-	return a;
+	return a
 }
 
 // Extract the version number from the URL
 func version() string {
 	// Break on slashes and look for the first numeric field
-	fields := strings.Split(*url, "/", 0);
+	fields := strings.Split(*url, "/", 0)
 	for _, f := range fields {
 		if len(f) > 0 && '0' <= f[0] && f[0] <= '9' {
 			return f
 		}
 	}
-	die.Log("unknown version");
-	return "Unknown";
+	die.Log("unknown version")
+	return "Unknown"
 }
 
 func letterOp(code int) bool {
@@ -251,29 +251,29 @@ func letterOp(code int) bool {
 	case "Lu", "Ll", "Lt", "Lm", "Lo":
 		return true
 	}
-	return false;
+	return false
 }
 
 func loadChars() {
 	if *dataURL == "" {
 		flag.Set("data", *url+"UnicodeData.txt")
 	}
-	resp, _, err := http.Get(*dataURL);
+	resp, _, err := http.Get(*dataURL)
 	if err != nil {
 		die.Log(err)
 	}
 	if resp.StatusCode != 200 {
 		die.Log("bad GET status for UnicodeData.txt", resp.Status)
 	}
-	input := bufio.NewReader(resp.Body);
-	var first uint32 = 0;
+	input := bufio.NewReader(resp.Body)
+	var first uint32 = 0
 	for {
-		line, err := input.ReadString('\n');
+		line, err := input.ReadString('\n')
 		if err != nil {
 			if err == os.EOF {
 				break
 			}
-			die.Log(err);
+			die.Log(err)
 		}
 		switch parseCategory(line[0 : len(line)-1]) {
 		case SNormal:
@@ -284,19 +284,19 @@ func loadChars() {
 			if first != 0 {
 				die.Logf("bad state first at U+%04X", lastChar)
 			}
-			first = lastChar;
+			first = lastChar
 		case SLast:
 			if first == 0 {
 				die.Logf("bad state last at U+%04X", lastChar)
 			}
 			for i := first + 1; i <= lastChar; i++ {
-				chars[i] = chars[first];
-				chars[i].codePoint = i;
+				chars[i] = chars[first]
+				chars[i].codePoint = i
 			}
-			first = 0;
+			first = 0
 		}
 	}
-	resp.Body.Close();
+	resp.Body.Close()
 }
 
 func printCategories() {
@@ -304,13 +304,13 @@ func printCategories() {
 		return
 	}
 	// Find out which categories to dump
-	list := strings.Split(*tablelist, ",", 0);
+	list := strings.Split(*tablelist, ",", 0)
 	if *tablelist == "all" {
 		list = allCategories()
 	}
 	if *test {
-		fullCategoryTest(list);
-		return;
+		fullCategoryTest(list)
+		return
 	}
 	fmt.Printf(
 		"// Generated by running\n"+
@@ -318,22 +318,22 @@ func printCategories() {
 			"// DO NOT EDIT\n\n"+
 			"package unicode\n\n",
 		*tablelist,
-		*dataURL);
+		*dataURL)
 
-	fmt.Println("// Version is the Unicode edition from which the tables are derived.");
-	fmt.Printf("const Version = %q\n\n", version());
+	fmt.Println("// Version is the Unicode edition from which the tables are derived.")
+	fmt.Printf("const Version = %q\n\n", version())
 
 	if *tablelist == "all" {
-		fmt.Println("// Categories is the set of Unicode data tables.");
-		fmt.Println("var Categories = map[string] []Range {");
+		fmt.Println("// Categories is the set of Unicode data tables.")
+		fmt.Println("var Categories = map[string] []Range {")
 		for k, _ := range category {
 			fmt.Printf("\t%q: %s,\n", k, k)
 		}
-		fmt.Printf("}\n\n");
+		fmt.Printf("}\n\n")
 	}
 
-	decl := make(sort.StringArray, len(list));
-	ndecl := 0;
+	decl := make(sort.StringArray, len(list))
+	ndecl := 0
 	for _, name := range list {
 		if _, ok := category[name]; !ok {
 			die.Log("unknown category", name)
@@ -342,7 +342,7 @@ func printCategories() {
 		// name to store the data.  This stops godoc dumping all the tables but keeps them
 		// available to clients.
 		// Cases deserving special comments
-		varDecl := "";
+		varDecl := ""
 		switch name {
 		case "letter":
 			varDecl = "\tLetter = letter;	// Letter is the set of Unicode letters.\n"
@@ -360,24 +360,24 @@ func printCategories() {
 				"\t%s = _%s;	// %s is the set of Unicode characters in category %s.\n",
 				name, name, name, name)
 		}
-		decl[ndecl] = varDecl;
-		ndecl++;
-		if name == "letter" {	// special case
+		decl[ndecl] = varDecl
+		ndecl++
+		if name == "letter" { // special case
 			dumpRange(
 				"var letter = []Range {\n",
-				letterOp);
-			continue;
+				letterOp)
+			continue
 		}
 		dumpRange(
 			fmt.Sprintf("var _%s = []Range {\n", name),
-			func(code int) bool { return chars[code].category == name });
+			func(code int) bool { return chars[code].category == name })
 	}
-	decl.Sort();
-	fmt.Println("var (");
+	decl.Sort()
+	fmt.Println("var (")
 	for _, d := range decl {
 		fmt.Print(d)
 	}
-	fmt.Println(")\n");
+	fmt.Println(")\n")
 }
 
 type Op func(code int) bool
@@ -385,8 +385,8 @@ type Op func(code int) bool
 const format = "\tRange{0x%04x, 0x%04x, %d},\n"
 
 func dumpRange(header string, inCategory Op) {
-	fmt.Print(header);
-	next := 0;
+	fmt.Print(header)
+	next := 0
 	// one Range for each iteration
 	for {
 		// look for start of range
@@ -399,22 +399,22 @@ func dumpRange(header string, inCategory Op) {
 		}
 
 		// start of range
-		lo := next;
-		hi := next;
-		stride := 1;
+		lo := next
+		hi := next
+		stride := 1
 		// accept lo
-		next++;
+		next++
 		// look for another character to set the stride
 		for next < len(chars) && !inCategory(next) {
 			next++
 		}
 		if next >= len(chars) {
 			// no more characters
-			fmt.Printf(format, lo, hi, stride);
-			break;
+			fmt.Printf(format, lo, hi, stride)
+			break
 		}
 		// set stride
-		stride = next - lo;
+		stride = next - lo
 		// check for length of run. next points to first jump in stride
 		for i := next; i < len(chars); i++ {
 			if inCategory(i) == (((i - lo) % stride) == 0) {
@@ -427,11 +427,11 @@ func dumpRange(header string, inCategory Op) {
 				break
 			}
 		}
-		fmt.Printf(format, lo, hi, stride);
+		fmt.Printf(format, lo, hi, stride)
 		// next range: start looking where this range ends
-		next = hi + 1;
+		next = hi + 1
 	}
-	fmt.Print("}\n\n");
+	fmt.Print("}\n\n")
 }
 
 func fullCategoryTest(list []string) {
@@ -439,7 +439,7 @@ func fullCategoryTest(list []string) {
 		if _, ok := category[name]; !ok {
 			die.Log("unknown category", name)
 		}
-		r, ok := unicode.Categories[name];
+		r, ok := unicode.Categories[name]
 		if !ok {
 			die.Log("unknown table", name)
 		}
@@ -456,8 +456,8 @@ func fullCategoryTest(list []string) {
 
 func verifyRange(name string, inCategory Op, table []unicode.Range) {
 	for i := range chars {
-		web := inCategory(i);
-		pkg := unicode.Is(table, i);
+		web := inCategory(i)
+		pkg := unicode.Is(table, i)
 		if web != pkg {
 			fmt.Fprintf(os.Stderr, "%s: U+%04X: web=%t pkg=%t\n", name, i, web, pkg)
 		}
@@ -465,61 +465,61 @@ func verifyRange(name string, inCategory Op, table []unicode.Range) {
 }
 
 func parseScript(line string, scripts map[string][]Script) {
-	comment := strings.Index(line, "#");
+	comment := strings.Index(line, "#")
 	if comment >= 0 {
 		line = line[0:comment]
 	}
-	line = strings.TrimSpace(line);
+	line = strings.TrimSpace(line)
 	if len(line) == 0 {
 		return
 	}
-	field := strings.Split(line, ";", -1);
+	field := strings.Split(line, ";", -1)
 	if len(field) != 2 {
 		die.Logf("%s: %d fields (expected 2)\n", line, len(field))
 	}
-	matches := scriptRe.MatchStrings(line);
+	matches := scriptRe.MatchStrings(line)
 	if len(matches) != 4 {
 		die.Logf("%s: %d matches (expected 3)\n", line, len(matches))
 	}
-	lo, err := strconv.Btoui64(matches[1], 16);
+	lo, err := strconv.Btoui64(matches[1], 16)
 	if err != nil {
 		die.Log("%.5s...:", err)
 	}
-	hi := lo;
-	if len(matches[2]) > 2 {	// ignore leading ..
-		hi, err = strconv.Btoui64(matches[2][2:], 16);
+	hi := lo
+	if len(matches[2]) > 2 { // ignore leading ..
+		hi, err = strconv.Btoui64(matches[2][2:], 16)
 		if err != nil {
 			die.Log("%.5s...:", err)
 		}
 	}
-	name := matches[3];
-	s, ok := scripts[name];
+	name := matches[3]
+	s, ok := scripts[name]
 	if !ok || len(s) == cap(s) {
-		ns := make([]Script, len(s), len(s)+100);
+		ns := make([]Script, len(s), len(s)+100)
 		for i, sc := range s {
 			ns[i] = sc
 		}
-		s = ns;
+		s = ns
 	}
-	s = s[0 : len(s)+1];
-	s[len(s)-1] = Script{uint32(lo), uint32(hi), name};
-	scripts[name] = s;
+	s = s[0 : len(s)+1]
+	s[len(s)-1] = Script{uint32(lo), uint32(hi), name}
+	scripts[name] = s
 }
 
 // The script tables have a lot of adjacent elements. Fold them together.
 func foldAdjacent(r []Script) []unicode.Range {
-	s := make([]unicode.Range, 0, len(r));
-	j := 0;
+	s := make([]unicode.Range, 0, len(r))
+	j := 0
 	for i := 0; i < len(r); i++ {
 		if j > 0 && int(r[i].lo) == s[j-1].Hi+1 {
 			s[j-1].Hi = int(r[i].hi)
 		} else {
-			s = s[0 : j+1];
-			s[j] = unicode.Range{int(r[i].lo), int(r[i].hi), 1};
-			j++;
+			s = s[0 : j+1]
+			s[j] = unicode.Range{int(r[i].lo), int(r[i].hi), 1}
+			j++
 		}
 	}
-	return s;
+	return s
 }
 
 func fullScriptTest(list []string, installed map[string][]unicode.Range, scripts map[string][]Script) {
@@ -527,7 +527,7 @@ func fullScriptTest(list []string, installed map[string][]unicode.Range, scripts
 		if _, ok := scripts[name]; !ok {
 			die.Log("unknown script", name)
 		}
-		_, ok := installed[name];
+		_, ok := installed[name]
 		if !ok {
 			die.Log("unknown table", name)
 		}
@@ -543,50 +543,50 @@ func fullScriptTest(list []string, installed map[string][]unicode.Range, scripts
 
 // PropList.txt has the same format as Scripts.txt so we can share its parser.
 func printScriptOrProperty(doProps bool) {
-	flag := "scripts";
-	flaglist := *scriptlist;
-	file := "Scripts.txt";
-	table := scripts;
-	installed := unicode.Scripts;
+	flag := "scripts"
+	flaglist := *scriptlist
+	file := "Scripts.txt"
+	table := scripts
+	installed := unicode.Scripts
 	if doProps {
-		flag = "props";
-		flaglist = *proplist;
-		file = "PropList.txt";
-		table = props;
-		installed = unicode.Properties;
+		flag = "props"
+		flaglist = *proplist
+		file = "PropList.txt"
+		table = props
+		installed = unicode.Properties
 	}
 	if flaglist == "" {
 		return
 	}
-	var err os.Error;
-	resp, _, err := http.Get(*url + file);
+	var err os.Error
+	resp, _, err := http.Get(*url + file)
 	if err != nil {
 		die.Log(err)
 	}
 	if resp.StatusCode != 200 {
 		die.Log("bad GET status for ", file, ":", resp.Status)
 	}
-	input := bufio.NewReader(resp.Body);
+	input := bufio.NewReader(resp.Body)
 	for {
-		line, err := input.ReadString('\n');
+		line, err := input.ReadString('\n')
 		if err != nil {
 			if err == os.EOF {
 				break
 			}
-			die.Log(err);
+			die.Log(err)
 		}
-		parseScript(line[0:len(line)-1], table);
+		parseScript(line[0:len(line)-1], table)
 	}
-	resp.Body.Close();
+	resp.Body.Close()
 
 	// Find out which scripts to dump
-	list := strings.Split(flaglist, ",", 0);
+	list := strings.Split(flaglist, ",", 0)
 	if flaglist == "all" {
 		list = all(table)
 	}
 	if *test {
-		fullScriptTest(list, installed, table);
-		return;
+		fullScriptTest(list, installed, table)
+		return
 	}
 
 	fmt.Printf(
@@ -595,23 +595,23 @@ func printScriptOrProperty(doProps bool) {
 			"// DO NOT EDIT\n\n",
 		flag,
 		flaglist,
-		*url);
+		*url)
 	if flaglist == "all" {
 		if doProps {
-			fmt.Println("// Properties is the set of Unicode property tables.");
-			fmt.Println("var Properties = map[string] []Range {");
+			fmt.Println("// Properties is the set of Unicode property tables.")
+			fmt.Println("var Properties = map[string] []Range {")
 		} else {
-			fmt.Println("// Scripts is the set of Unicode script tables.");
-			fmt.Println("var Scripts = map[string] []Range {");
+			fmt.Println("// Scripts is the set of Unicode script tables.")
+			fmt.Println("var Scripts = map[string] []Range {")
 		}
 		for k, _ := range table {
 			fmt.Printf("\t%q: %s,\n", k, k)
 		}
-		fmt.Printf("}\n\n");
+		fmt.Printf("}\n\n")
 	}
 
-	decl := make(sort.StringArray, len(list));
-	ndecl := 0;
+	decl := make(sort.StringArray, len(list))
+	ndecl := 0
 	for _, name := range list {
 		if doProps {
 			decl[ndecl] = fmt.Sprintf(
@@ -622,36 +622,36 @@ func printScriptOrProperty(doProps bool) {
 				"\t%s = _%s;\t// %s is the set of Unicode characters in script %s.\n",
 				name, name, name, name)
 		}
-		ndecl++;
-		fmt.Printf("var _%s = []Range {\n", name);
-		ranges := foldAdjacent(table[name]);
+		ndecl++
+		fmt.Printf("var _%s = []Range {\n", name)
+		ranges := foldAdjacent(table[name])
 		for _, s := range ranges {
 			fmt.Printf(format, s.Lo, s.Hi, s.Stride)
 		}
-		fmt.Printf("}\n\n");
+		fmt.Printf("}\n\n")
 	}
-	decl.Sort();
-	fmt.Println("var (");
+	decl.Sort()
+	fmt.Println("var (")
 	for _, d := range decl {
 		fmt.Print(d)
 	}
-	fmt.Println(")\n");
+	fmt.Println(")\n")
 }
 
 const (
-	CaseUpper	= 1 << iota;
-	CaseLower;
-	CaseTitle;
-	CaseNone	= 0;	// must be zero
-	CaseMissing	= -1;	// character not present; not a valid case state
+	CaseUpper = 1 << iota
+	CaseLower
+	CaseTitle
+	CaseNone    = 0  // must be zero
+	CaseMissing = -1 // character not present; not a valid case state
 )
 
 type caseState struct {
-	point		int;
-	_case		int;
-	deltaToUpper	int;
-	deltaToLower	int;
-	deltaToTitle	int;
+	point        int
+	_case        int
+	deltaToUpper int
+	deltaToLower int
+	deltaToTitle int
 }
 
 // Is d a continuation of the state of c?
@@ -660,9 +660,9 @@ func (c *caseState) adjacent(d *caseState) bool {
 		c, d = d, c
 	}
 	switch {
-	case d.point != c.point+1:	// code points not adjacent (shouldn't happen)
+	case d.point != c.point+1: // code points not adjacent (shouldn't happen)
 		return false
-	case d._case != c._case:	// different cases
+	case d._case != c._case: // different cases
 		return c.upperLowerAdjacent(d)
 	case c._case == CaseNone:
 		return false
@@ -675,7 +675,7 @@ func (c *caseState) adjacent(d *caseState) bool {
 	case d.deltaToTitle != c.deltaToTitle:
 		return false
 	}
-	return true;
+	return true
 }
 
 // Is d the same as c, but opposite in upper/lower case? this would make it
@@ -709,7 +709,7 @@ func (c *caseState) upperLowerAdjacent(d *caseState) bool {
 	case d.deltaToTitle != -1:
 		return false
 	}
-	return true;
+	return true
 }
 
 // Does this character start an UpperLower sequence?
@@ -724,7 +724,7 @@ func (c *caseState) isUpperLower() bool {
 	case c.deltaToTitle != 0:
 		return false
 	}
-	return true;
+	return true
 }
 
 // Does this character start a LowerUpper sequence?
@@ -739,16 +739,16 @@ func (c *caseState) isLowerUpper() bool {
 	case c.deltaToTitle != -1:
 		return false
 	}
-	return true;
+	return true
 }
 
 func getCaseState(i int) (c *caseState) {
-	c = &caseState{point: i, _case: CaseNone};
-	ch := &chars[i];
+	c = &caseState{point: i, _case: CaseNone}
+	ch := &chars[i]
 	switch int(ch.codePoint) {
 	case 0:
-		c._case = CaseMissing;	// Will get NUL wrong but that doesn't matter
-		return;
+		c._case = CaseMissing // Will get NUL wrong but that doesn't matter
+		return
 	case ch.upperCase:
 		c._case = CaseUpper
 	case ch.lowerCase:
@@ -765,7 +765,7 @@ func getCaseState(i int) (c *caseState) {
 	if ch.titleCase != 0 {
 		c.deltaToTitle = ch.titleCase - i
 	}
-	return;
+	return
 }
 
 func printCases() {
@@ -773,8 +773,8 @@ func printCases() {
 		return
 	}
 	if *test {
-		fullCaseTest();
-		return;
+		fullCaseTest()
+		return
 	}
 	fmt.Printf(
 		"// Generated by running\n"+
@@ -784,25 +784,25 @@ func printCases() {
 			"// non-self mappings.\n"+
 			"var CaseRanges = _CaseRanges\n"+
 			"var _CaseRanges = []CaseRange {\n",
-		*dataURL);
+		*dataURL)
 
-	var startState *caseState;	// the start of a run; nil for not active
-	var prevState = &caseState{};	// the state of the previous character
+	var startState *caseState    // the start of a run; nil for not active
+	var prevState = &caseState{} // the state of the previous character
 	for i := range chars {
-		state := getCaseState(i);
+		state := getCaseState(i)
 		if state.adjacent(prevState) {
-			prevState = state;
-			continue;
+			prevState = state
+			continue
 		}
 		// end of run (possibly)
-		printCaseRange(startState, prevState);
-		startState = nil;
+		printCaseRange(startState, prevState)
+		startState = nil
 		if state._case != CaseMissing && state._case != CaseNone {
 			startState = state
 		}
-		prevState = state;
+		prevState = state
 	}
-	fmt.Printf("}\n");
+	fmt.Printf("}\n")
 }
 
 func printCaseRange(lo, hi *caseState) {
@@ -818,9 +818,9 @@ func printCaseRange(lo, hi *caseState) {
 		fmt.Printf("\tCaseRange{0x%04X, 0x%04X, d{UpperLower, UpperLower, UpperLower}},\n",
 			lo.point, hi.point)
 	case hi.point > lo.point && lo.isLowerUpper():
-		die.Log("LowerUpper sequence: should not happen: U+%04X.  If it's real, need to fix To()", lo.point);
+		die.Log("LowerUpper sequence: should not happen: U+%04X.  If it's real, need to fix To()", lo.point)
 		fmt.Printf("\tCaseRange{0x%04X, 0x%04X, d{LowerUpper, LowerUpper, LowerUpper}},\n",
-			lo.point, hi.point);
+			lo.point, hi.point)
 	default:
 		fmt.Printf("\tCaseRange{0x%04X, 0x%04X, d{%d, %d, %d}},\n",
 			lo.point, hi.point,
@@ -833,23 +833,23 @@ func caseIt(rune, cased int) int {
 	if cased == 0 {
 		return rune
 	}
-	return cased;
+	return cased
 }
 
 func fullCaseTest() {
 	for i, c := range chars {
-		lower := unicode.ToLower(i);
-		want := caseIt(i, c.lowerCase);
+		lower := unicode.ToLower(i)
+		want := caseIt(i, c.lowerCase)
 		if lower != want {
 			fmt.Fprintf(os.Stderr, "lower U+%04X should be U+%04X is U+%04X\n", i, want, lower)
 		}
-		upper := unicode.ToUpper(i);
-		want = caseIt(i, c.upperCase);
+		upper := unicode.ToUpper(i)
+		want = caseIt(i, c.upperCase)
 		if upper != want {
 			fmt.Fprintf(os.Stderr, "upper U+%04X should be U+%04X is U+%04X\n", i, want, upper)
 		}
-		title := unicode.ToTitle(i);
-		want = caseIt(i, c.titleCase);
+		title := unicode.ToTitle(i)
+		want = caseIt(i, c.titleCase)
 		if title != want {
 			fmt.Fprintf(os.Stderr, "title U+%04X should be U+%04X is U+%04X\n", i, want, title)
 		}
diff --git a/src/pkg/unicode/script_test.go b/src/pkg/unicode/script_test.go
index 316de2d25f..b3e980b1c9 100644
--- a/src/pkg/unicode/script_test.go
+++ b/src/pkg/unicode/script_test.go
@@ -5,13 +5,13 @@
 package unicode_test
 
 import (
-	"testing";
-	. "unicode";
+	"testing"
+	. "unicode"
 )
 
 type T struct {
-	rune	int;
-	script	string;
+	rune   int
+	script string
 }
 
 // Hand-chosen tests from Unicode 5.1.0, mostly to discover when new
@@ -112,7 +112,7 @@ var inTest = []T{
 	T{0xa216, "Yi"},
 }
 
-var outTest = []T{	// not really worth being thorough
+var outTest = []T{ // not really worth being thorough
 	T{0x20, "Telugu"},
 }
 
@@ -185,7 +185,7 @@ var inPropTest = []T{
 }
 
 func TestScripts(t *testing.T) {
-	notTested := make(map[string]bool);
+	notTested := make(map[string]bool)
 	for k := range Scripts {
 		notTested[k] = true
 	}
@@ -196,7 +196,7 @@ func TestScripts(t *testing.T) {
 		if !Is(Scripts[test.script], test.rune) {
 			t.Errorf("IsScript(%#x, %s) = false, want true\n", test.rune, test.script)
 		}
-		notTested[test.script] = false, false;
+		notTested[test.script] = false, false
 	}
 	for _, test := range outTest {
 		if Is(Scripts[test.script], test.rune) {
@@ -209,7 +209,7 @@ func TestScripts(t *testing.T) {
 }
 
 func TestCategories(t *testing.T) {
-	notTested := make(map[string]bool);
+	notTested := make(map[string]bool)
 	for k := range Categories {
 		notTested[k] = true
 	}
@@ -220,7 +220,7 @@ func TestCategories(t *testing.T) {
 		if !Is(Categories[test.script], test.rune) {
 			t.Errorf("IsCategory(%#x, %s) = false, want true\n", test.rune, test.script)
 		}
-		notTested[test.script] = false, false;
+		notTested[test.script] = false, false
 	}
 	for k := range notTested {
 		t.Error("not tested:", k)
@@ -228,7 +228,7 @@ func TestCategories(t *testing.T) {
 }
 
 func TestProperties(t *testing.T) {
-	notTested := make(map[string]bool);
+	notTested := make(map[string]bool)
 	for k := range Properties {
 		notTested[k] = true
 	}
@@ -239,7 +239,7 @@ func TestProperties(t *testing.T) {
 		if !Is(Properties[test.script], test.rune) {
 			t.Errorf("IsCategory(%#x, %s) = false, want true\n", test.rune, test.script)
 		}
-		notTested[test.script] = false, false;
+		notTested[test.script] = false, false
 	}
 	for k := range notTested {
 		t.Error("not tested:", k)
diff --git a/src/pkg/unicode/tables.go b/src/pkg/unicode/tables.go
index 4a4dbe02b5..10e4fae6da 100644
--- a/src/pkg/unicode/tables.go
+++ b/src/pkg/unicode/tables.go
@@ -1921,40 +1921,40 @@ var _Lo = []Range{
 }
 
 var (
-	Cc	= _Cc;		// Cc is the set of Unicode characters in category Cc.
-	Cf	= _Cf;		// Cf is the set of Unicode characters in category Cf.
-	Co	= _Co;		// Co is the set of Unicode characters in category Co.
-	Cs	= _Cs;		// Cs is the set of Unicode characters in category Cs.
-	Digit	= _Nd;		// Digit is the set of Unicode characters with the "decimal digit" property.
-	Nd	= _Nd;		// Nd is the set of Unicode characters in category Nd.
-	Letter	= letter;	// Letter is the set of Unicode letters.
-	Lm	= _Lm;		// Lm is the set of Unicode characters in category Lm.
-	Lo	= _Lo;		// Lo is the set of Unicode characters in category Lo.
-	Lower	= _Ll;		// Lower is the set of Unicode lower case letters.
-	Ll	= _Ll;		// Ll is the set of Unicode characters in category Ll.
-	Mc	= _Mc;		// Mc is the set of Unicode characters in category Mc.
-	Me	= _Me;		// Me is the set of Unicode characters in category Me.
-	Mn	= _Mn;		// Mn is the set of Unicode characters in category Mn.
-	Nl	= _Nl;		// Nl is the set of Unicode characters in category Nl.
-	No	= _No;		// No is the set of Unicode characters in category No.
-	Pc	= _Pc;		// Pc is the set of Unicode characters in category Pc.
-	Pd	= _Pd;		// Pd is the set of Unicode characters in category Pd.
-	Pe	= _Pe;		// Pe is the set of Unicode characters in category Pe.
-	Pf	= _Pf;		// Pf is the set of Unicode characters in category Pf.
-	Pi	= _Pi;		// Pi is the set of Unicode characters in category Pi.
-	Po	= _Po;		// Po is the set of Unicode characters in category Po.
-	Ps	= _Ps;		// Ps is the set of Unicode characters in category Ps.
-	Sc	= _Sc;		// Sc is the set of Unicode characters in category Sc.
-	Sk	= _Sk;		// Sk is the set of Unicode characters in category Sk.
-	Sm	= _Sm;		// Sm is the set of Unicode characters in category Sm.
-	So	= _So;		// So is the set of Unicode characters in category So.
-	Title	= _Lt;		// Title is the set of Unicode title case letters.
-	Lt	= _Lt;		// Lt is the set of Unicode characters in category Lt.
-	Upper	= _Lu;		// Upper is the set of Unicode upper case letters.
-	Lu	= _Lu;		// Lu is the set of Unicode characters in category Lu.
-	Zl	= _Zl;		// Zl is the set of Unicode characters in category Zl.
-	Zp	= _Zp;		// Zp is the set of Unicode characters in category Zp.
-	Zs	= _Zs;		// Zs is the set of Unicode characters in category Zs.
+	Cc     = _Cc    // Cc is the set of Unicode characters in category Cc.
+	Cf     = _Cf    // Cf is the set of Unicode characters in category Cf.
+	Co     = _Co    // Co is the set of Unicode characters in category Co.
+	Cs     = _Cs    // Cs is the set of Unicode characters in category Cs.
+	Digit  = _Nd    // Digit is the set of Unicode characters with the "decimal digit" property.
+	Nd     = _Nd    // Nd is the set of Unicode characters in category Nd.
+	Letter = letter // Letter is the set of Unicode letters.
+	Lm     = _Lm    // Lm is the set of Unicode characters in category Lm.
+	Lo     = _Lo    // Lo is the set of Unicode characters in category Lo.
+	Lower  = _Ll    // Lower is the set of Unicode lower case letters.
+	Ll     = _Ll    // Ll is the set of Unicode characters in category Ll.
+	Mc     = _Mc    // Mc is the set of Unicode characters in category Mc.
+	Me     = _Me    // Me is the set of Unicode characters in category Me.
+	Mn     = _Mn    // Mn is the set of Unicode characters in category Mn.
+	Nl     = _Nl    // Nl is the set of Unicode characters in category Nl.
+	No     = _No    // No is the set of Unicode characters in category No.
+	Pc     = _Pc    // Pc is the set of Unicode characters in category Pc.
+	Pd     = _Pd    // Pd is the set of Unicode characters in category Pd.
+	Pe     = _Pe    // Pe is the set of Unicode characters in category Pe.
+	Pf     = _Pf    // Pf is the set of Unicode characters in category Pf.
+	Pi     = _Pi    // Pi is the set of Unicode characters in category Pi.
+	Po     = _Po    // Po is the set of Unicode characters in category Po.
+	Ps     = _Ps    // Ps is the set of Unicode characters in category Ps.
+	Sc     = _Sc    // Sc is the set of Unicode characters in category Sc.
+	Sk     = _Sk    // Sk is the set of Unicode characters in category Sk.
+	Sm     = _Sm    // Sm is the set of Unicode characters in category Sm.
+	So     = _So    // So is the set of Unicode characters in category So.
+	Title  = _Lt    // Title is the set of Unicode title case letters.
+	Lt     = _Lt    // Lt is the set of Unicode characters in category Lt.
+	Upper  = _Lu    // Upper is the set of Unicode upper case letters.
+	Lu     = _Lu    // Lu is the set of Unicode characters in category Lu.
+	Zl     = _Zl    // Zl is the set of Unicode characters in category Zl.
+	Zp     = _Zp    // Zp is the set of Unicode characters in category Zp.
+	Zs     = _Zs    // Zs is the set of Unicode characters in category Zs.
 )
 
 // Generated by running
@@ -2990,98 +2990,98 @@ var _Gothic = []Range{
 }
 
 var (
-	Arabic			= _Arabic;			// Arabic is the set of Unicode characters in script Arabic.
-	Armenian		= _Armenian;			// Armenian is the set of Unicode characters in script Armenian.
-	Avestan			= _Avestan;			// Avestan is the set of Unicode characters in script Avestan.
-	Balinese		= _Balinese;			// Balinese is the set of Unicode characters in script Balinese.
-	Bamum			= _Bamum;			// Bamum is the set of Unicode characters in script Bamum.
-	Bengali			= _Bengali;			// Bengali is the set of Unicode characters in script Bengali.
-	Bopomofo		= _Bopomofo;			// Bopomofo is the set of Unicode characters in script Bopomofo.
-	Braille			= _Braille;			// Braille is the set of Unicode characters in script Braille.
-	Buginese		= _Buginese;			// Buginese is the set of Unicode characters in script Buginese.
-	Buhid			= _Buhid;			// Buhid is the set of Unicode characters in script Buhid.
-	Canadian_Aboriginal	= _Canadian_Aboriginal;		// Canadian_Aboriginal is the set of Unicode characters in script Canadian_Aboriginal.
-	Carian			= _Carian;			// Carian is the set of Unicode characters in script Carian.
-	Cham			= _Cham;			// Cham is the set of Unicode characters in script Cham.
-	Cherokee		= _Cherokee;			// Cherokee is the set of Unicode characters in script Cherokee.
-	Common			= _Common;			// Common is the set of Unicode characters in script Common.
-	Coptic			= _Coptic;			// Coptic is the set of Unicode characters in script Coptic.
-	Cuneiform		= _Cuneiform;			// Cuneiform is the set of Unicode characters in script Cuneiform.
-	Cypriot			= _Cypriot;			// Cypriot is the set of Unicode characters in script Cypriot.
-	Cyrillic		= _Cyrillic;			// Cyrillic is the set of Unicode characters in script Cyrillic.
-	Deseret			= _Deseret;			// Deseret is the set of Unicode characters in script Deseret.
-	Devanagari		= _Devanagari;			// Devanagari is the set of Unicode characters in script Devanagari.
-	Egyptian_Hieroglyphs	= _Egyptian_Hieroglyphs;	// Egyptian_Hieroglyphs is the set of Unicode characters in script Egyptian_Hieroglyphs.
-	Ethiopic		= _Ethiopic;			// Ethiopic is the set of Unicode characters in script Ethiopic.
-	Georgian		= _Georgian;			// Georgian is the set of Unicode characters in script Georgian.
-	Glagolitic		= _Glagolitic;			// Glagolitic is the set of Unicode characters in script Glagolitic.
-	Gothic			= _Gothic;			// Gothic is the set of Unicode characters in script Gothic.
-	Greek			= _Greek;			// Greek is the set of Unicode characters in script Greek.
-	Gujarati		= _Gujarati;			// Gujarati is the set of Unicode characters in script Gujarati.
-	Gurmukhi		= _Gurmukhi;			// Gurmukhi is the set of Unicode characters in script Gurmukhi.
-	Han			= _Han;				// Han is the set of Unicode characters in script Han.
-	Hangul			= _Hangul;			// Hangul is the set of Unicode characters in script Hangul.
-	Hanunoo			= _Hanunoo;			// Hanunoo is the set of Unicode characters in script Hanunoo.
-	Hebrew			= _Hebrew;			// Hebrew is the set of Unicode characters in script Hebrew.
-	Hiragana		= _Hiragana;			// Hiragana is the set of Unicode characters in script Hiragana.
-	Imperial_Aramaic	= _Imperial_Aramaic;		// Imperial_Aramaic is the set of Unicode characters in script Imperial_Aramaic.
-	Inherited		= _Inherited;			// Inherited is the set of Unicode characters in script Inherited.
-	Inscriptional_Pahlavi	= _Inscriptional_Pahlavi;	// Inscriptional_Pahlavi is the set of Unicode characters in script Inscriptional_Pahlavi.
-	Inscriptional_Parthian	= _Inscriptional_Parthian;	// Inscriptional_Parthian is the set of Unicode characters in script Inscriptional_Parthian.
-	Javanese		= _Javanese;			// Javanese is the set of Unicode characters in script Javanese.
-	Kaithi			= _Kaithi;			// Kaithi is the set of Unicode characters in script Kaithi.
-	Kannada			= _Kannada;			// Kannada is the set of Unicode characters in script Kannada.
-	Katakana		= _Katakana;			// Katakana is the set of Unicode characters in script Katakana.
-	Kayah_Li		= _Kayah_Li;			// Kayah_Li is the set of Unicode characters in script Kayah_Li.
-	Kharoshthi		= _Kharoshthi;			// Kharoshthi is the set of Unicode characters in script Kharoshthi.
-	Khmer			= _Khmer;			// Khmer is the set of Unicode characters in script Khmer.
-	Lao			= _Lao;				// Lao is the set of Unicode characters in script Lao.
-	Latin			= _Latin;			// Latin is the set of Unicode characters in script Latin.
-	Lepcha			= _Lepcha;			// Lepcha is the set of Unicode characters in script Lepcha.
-	Limbu			= _Limbu;			// Limbu is the set of Unicode characters in script Limbu.
-	Linear_B		= _Linear_B;			// Linear_B is the set of Unicode characters in script Linear_B.
-	Lisu			= _Lisu;			// Lisu is the set of Unicode characters in script Lisu.
-	Lycian			= _Lycian;			// Lycian is the set of Unicode characters in script Lycian.
-	Lydian			= _Lydian;			// Lydian is the set of Unicode characters in script Lydian.
-	Malayalam		= _Malayalam;			// Malayalam is the set of Unicode characters in script Malayalam.
-	Meetei_Mayek		= _Meetei_Mayek;		// Meetei_Mayek is the set of Unicode characters in script Meetei_Mayek.
-	Mongolian		= _Mongolian;			// Mongolian is the set of Unicode characters in script Mongolian.
-	Myanmar			= _Myanmar;			// Myanmar is the set of Unicode characters in script Myanmar.
-	New_Tai_Lue		= _New_Tai_Lue;			// New_Tai_Lue is the set of Unicode characters in script New_Tai_Lue.
-	Nko			= _Nko;				// Nko is the set of Unicode characters in script Nko.
-	Ogham			= _Ogham;			// Ogham is the set of Unicode characters in script Ogham.
-	Ol_Chiki		= _Ol_Chiki;			// Ol_Chiki is the set of Unicode characters in script Ol_Chiki.
-	Old_Italic		= _Old_Italic;			// Old_Italic is the set of Unicode characters in script Old_Italic.
-	Old_Persian		= _Old_Persian;			// Old_Persian is the set of Unicode characters in script Old_Persian.
-	Old_South_Arabian	= _Old_South_Arabian;		// Old_South_Arabian is the set of Unicode characters in script Old_South_Arabian.
-	Old_Turkic		= _Old_Turkic;			// Old_Turkic is the set of Unicode characters in script Old_Turkic.
-	Oriya			= _Oriya;			// Oriya is the set of Unicode characters in script Oriya.
-	Osmanya			= _Osmanya;			// Osmanya is the set of Unicode characters in script Osmanya.
-	Phags_Pa		= _Phags_Pa;			// Phags_Pa is the set of Unicode characters in script Phags_Pa.
-	Phoenician		= _Phoenician;			// Phoenician is the set of Unicode characters in script Phoenician.
-	Rejang			= _Rejang;			// Rejang is the set of Unicode characters in script Rejang.
-	Runic			= _Runic;			// Runic is the set of Unicode characters in script Runic.
-	Samaritan		= _Samaritan;			// Samaritan is the set of Unicode characters in script Samaritan.
-	Saurashtra		= _Saurashtra;			// Saurashtra is the set of Unicode characters in script Saurashtra.
-	Shavian			= _Shavian;			// Shavian is the set of Unicode characters in script Shavian.
-	Sinhala			= _Sinhala;			// Sinhala is the set of Unicode characters in script Sinhala.
-	Sundanese		= _Sundanese;			// Sundanese is the set of Unicode characters in script Sundanese.
-	Syloti_Nagri		= _Syloti_Nagri;		// Syloti_Nagri is the set of Unicode characters in script Syloti_Nagri.
-	Syriac			= _Syriac;			// Syriac is the set of Unicode characters in script Syriac.
-	Tagalog			= _Tagalog;			// Tagalog is the set of Unicode characters in script Tagalog.
-	Tagbanwa		= _Tagbanwa;			// Tagbanwa is the set of Unicode characters in script Tagbanwa.
-	Tai_Le			= _Tai_Le;			// Tai_Le is the set of Unicode characters in script Tai_Le.
-	Tai_Tham		= _Tai_Tham;			// Tai_Tham is the set of Unicode characters in script Tai_Tham.
-	Tai_Viet		= _Tai_Viet;			// Tai_Viet is the set of Unicode characters in script Tai_Viet.
-	Tamil			= _Tamil;			// Tamil is the set of Unicode characters in script Tamil.
-	Telugu			= _Telugu;			// Telugu is the set of Unicode characters in script Telugu.
-	Thaana			= _Thaana;			// Thaana is the set of Unicode characters in script Thaana.
-	Thai			= _Thai;			// Thai is the set of Unicode characters in script Thai.
-	Tibetan			= _Tibetan;			// Tibetan is the set of Unicode characters in script Tibetan.
-	Tifinagh		= _Tifinagh;			// Tifinagh is the set of Unicode characters in script Tifinagh.
-	Ugaritic		= _Ugaritic;			// Ugaritic is the set of Unicode characters in script Ugaritic.
-	Vai			= _Vai;				// Vai is the set of Unicode characters in script Vai.
-	Yi			= _Yi;				// Yi is the set of Unicode characters in script Yi.
+	Arabic                 = _Arabic                 // Arabic is the set of Unicode characters in script Arabic.
+	Armenian               = _Armenian               // Armenian is the set of Unicode characters in script Armenian.
+	Avestan                = _Avestan                // Avestan is the set of Unicode characters in script Avestan.
+	Balinese               = _Balinese               // Balinese is the set of Unicode characters in script Balinese.
+	Bamum                  = _Bamum                  // Bamum is the set of Unicode characters in script Bamum.
+	Bengali                = _Bengali                // Bengali is the set of Unicode characters in script Bengali.
+	Bopomofo               = _Bopomofo               // Bopomofo is the set of Unicode characters in script Bopomofo.
+	Braille                = _Braille                // Braille is the set of Unicode characters in script Braille.
+	Buginese               = _Buginese               // Buginese is the set of Unicode characters in script Buginese.
+	Buhid                  = _Buhid                  // Buhid is the set of Unicode characters in script Buhid.
+	Canadian_Aboriginal    = _Canadian_Aboriginal    // Canadian_Aboriginal is the set of Unicode characters in script Canadian_Aboriginal.
+	Carian                 = _Carian                 // Carian is the set of Unicode characters in script Carian.
+	Cham                   = _Cham                   // Cham is the set of Unicode characters in script Cham.
+	Cherokee               = _Cherokee               // Cherokee is the set of Unicode characters in script Cherokee.
+	Common                 = _Common                 // Common is the set of Unicode characters in script Common.
+	Coptic                 = _Coptic                 // Coptic is the set of Unicode characters in script Coptic.
+	Cuneiform              = _Cuneiform              // Cuneiform is the set of Unicode characters in script Cuneiform.
+	Cypriot                = _Cypriot                // Cypriot is the set of Unicode characters in script Cypriot.
+	Cyrillic               = _Cyrillic               // Cyrillic is the set of Unicode characters in script Cyrillic.
+	Deseret                = _Deseret                // Deseret is the set of Unicode characters in script Deseret.
+	Devanagari             = _Devanagari             // Devanagari is the set of Unicode characters in script Devanagari.
+	Egyptian_Hieroglyphs   = _Egyptian_Hieroglyphs   // Egyptian_Hieroglyphs is the set of Unicode characters in script Egyptian_Hieroglyphs.
+	Ethiopic               = _Ethiopic               // Ethiopic is the set of Unicode characters in script Ethiopic.
+	Georgian               = _Georgian               // Georgian is the set of Unicode characters in script Georgian.
+	Glagolitic             = _Glagolitic             // Glagolitic is the set of Unicode characters in script Glagolitic.
+	Gothic                 = _Gothic                 // Gothic is the set of Unicode characters in script Gothic.
+	Greek                  = _Greek                  // Greek is the set of Unicode characters in script Greek.
+	Gujarati               = _Gujarati               // Gujarati is the set of Unicode characters in script Gujarati.
+	Gurmukhi               = _Gurmukhi               // Gurmukhi is the set of Unicode characters in script Gurmukhi.
+	Han                    = _Han                    // Han is the set of Unicode characters in script Han.
+	Hangul                 = _Hangul                 // Hangul is the set of Unicode characters in script Hangul.
+	Hanunoo                = _Hanunoo                // Hanunoo is the set of Unicode characters in script Hanunoo.
+	Hebrew                 = _Hebrew                 // Hebrew is the set of Unicode characters in script Hebrew.
+	Hiragana               = _Hiragana               // Hiragana is the set of Unicode characters in script Hiragana.
+	Imperial_Aramaic       = _Imperial_Aramaic       // Imperial_Aramaic is the set of Unicode characters in script Imperial_Aramaic.
+	Inherited              = _Inherited              // Inherited is the set of Unicode characters in script Inherited.
+	Inscriptional_Pahlavi  = _Inscriptional_Pahlavi  // Inscriptional_Pahlavi is the set of Unicode characters in script Inscriptional_Pahlavi.
+	Inscriptional_Parthian = _Inscriptional_Parthian // Inscriptional_Parthian is the set of Unicode characters in script Inscriptional_Parthian.
+	Javanese               = _Javanese               // Javanese is the set of Unicode characters in script Javanese.
+	Kaithi                 = _Kaithi                 // Kaithi is the set of Unicode characters in script Kaithi.
+	Kannada                = _Kannada                // Kannada is the set of Unicode characters in script Kannada.
+	Katakana               = _Katakana               // Katakana is the set of Unicode characters in script Katakana.
+	Kayah_Li               = _Kayah_Li               // Kayah_Li is the set of Unicode characters in script Kayah_Li.
+	Kharoshthi             = _Kharoshthi             // Kharoshthi is the set of Unicode characters in script Kharoshthi.
+	Khmer                  = _Khmer                  // Khmer is the set of Unicode characters in script Khmer.
+	Lao                    = _Lao                    // Lao is the set of Unicode characters in script Lao.
+	Latin                  = _Latin                  // Latin is the set of Unicode characters in script Latin.
+	Lepcha                 = _Lepcha                 // Lepcha is the set of Unicode characters in script Lepcha.
+	Limbu                  = _Limbu                  // Limbu is the set of Unicode characters in script Limbu.
+	Linear_B               = _Linear_B               // Linear_B is the set of Unicode characters in script Linear_B.
+	Lisu                   = _Lisu                   // Lisu is the set of Unicode characters in script Lisu.
+	Lycian                 = _Lycian                 // Lycian is the set of Unicode characters in script Lycian.
+	Lydian                 = _Lydian                 // Lydian is the set of Unicode characters in script Lydian.
+	Malayalam              = _Malayalam              // Malayalam is the set of Unicode characters in script Malayalam.
+	Meetei_Mayek           = _Meetei_Mayek           // Meetei_Mayek is the set of Unicode characters in script Meetei_Mayek.
+	Mongolian              = _Mongolian              // Mongolian is the set of Unicode characters in script Mongolian.
+	Myanmar                = _Myanmar                // Myanmar is the set of Unicode characters in script Myanmar.
+	New_Tai_Lue            = _New_Tai_Lue            // New_Tai_Lue is the set of Unicode characters in script New_Tai_Lue.
+	Nko                    = _Nko                    // Nko is the set of Unicode characters in script Nko.
+	Ogham                  = _Ogham                  // Ogham is the set of Unicode characters in script Ogham.
+	Ol_Chiki               = _Ol_Chiki               // Ol_Chiki is the set of Unicode characters in script Ol_Chiki.
+	Old_Italic             = _Old_Italic             // Old_Italic is the set of Unicode characters in script Old_Italic.
+	Old_Persian            = _Old_Persian            // Old_Persian is the set of Unicode characters in script Old_Persian.
+	Old_South_Arabian      = _Old_South_Arabian      // Old_South_Arabian is the set of Unicode characters in script Old_South_Arabian.
+	Old_Turkic             = _Old_Turkic             // Old_Turkic is the set of Unicode characters in script Old_Turkic.
+	Oriya                  = _Oriya                  // Oriya is the set of Unicode characters in script Oriya.
+	Osmanya                = _Osmanya                // Osmanya is the set of Unicode characters in script Osmanya.
+	Phags_Pa               = _Phags_Pa               // Phags_Pa is the set of Unicode characters in script Phags_Pa.
+	Phoenician             = _Phoenician             // Phoenician is the set of Unicode characters in script Phoenician.
+	Rejang                 = _Rejang                 // Rejang is the set of Unicode characters in script Rejang.
+	Runic                  = _Runic                  // Runic is the set of Unicode characters in script Runic.
+	Samaritan              = _Samaritan              // Samaritan is the set of Unicode characters in script Samaritan.
+	Saurashtra             = _Saurashtra             // Saurashtra is the set of Unicode characters in script Saurashtra.
+	Shavian                = _Shavian                // Shavian is the set of Unicode characters in script Shavian.
+	Sinhala                = _Sinhala                // Sinhala is the set of Unicode characters in script Sinhala.
+	Sundanese              = _Sundanese              // Sundanese is the set of Unicode characters in script Sundanese.
+	Syloti_Nagri           = _Syloti_Nagri           // Syloti_Nagri is the set of Unicode characters in script Syloti_Nagri.
+	Syriac                 = _Syriac                 // Syriac is the set of Unicode characters in script Syriac.
+	Tagalog                = _Tagalog                // Tagalog is the set of Unicode characters in script Tagalog.
+	Tagbanwa               = _Tagbanwa               // Tagbanwa is the set of Unicode characters in script Tagbanwa.
+	Tai_Le                 = _Tai_Le                 // Tai_Le is the set of Unicode characters in script Tai_Le.
+	Tai_Tham               = _Tai_Tham               // Tai_Tham is the set of Unicode characters in script Tai_Tham.
+	Tai_Viet               = _Tai_Viet               // Tai_Viet is the set of Unicode characters in script Tai_Viet.
+	Tamil                  = _Tamil                  // Tamil is the set of Unicode characters in script Tamil.
+	Telugu                 = _Telugu                 // Telugu is the set of Unicode characters in script Telugu.
+	Thaana                 = _Thaana                 // Thaana is the set of Unicode characters in script Thaana.
+	Thai                   = _Thai                   // Thai is the set of Unicode characters in script Thai.
+	Tibetan                = _Tibetan                // Tibetan is the set of Unicode characters in script Tibetan.
+	Tifinagh               = _Tifinagh               // Tifinagh is the set of Unicode characters in script Tifinagh.
+	Ugaritic               = _Ugaritic               // Ugaritic is the set of Unicode characters in script Ugaritic.
+	Vai                    = _Vai                    // Vai is the set of Unicode characters in script Vai.
+	Yi                     = _Yi                     // Yi is the set of Unicode characters in script Yi.
 )
 
 // Generated by running
@@ -3943,38 +3943,38 @@ var _White_Space = []Range{
 }
 
 var (
-	ASCII_Hex_Digit				= _ASCII_Hex_Digit;			// ASCII_Hex_Digit is the set of Unicode characters with property ASCII_Hex_Digit.
-	Bidi_Control				= _Bidi_Control;			// Bidi_Control is the set of Unicode characters with property Bidi_Control.
-	Dash					= _Dash;				// Dash is the set of Unicode characters with property Dash.
-	Deprecated				= _Deprecated;				// Deprecated is the set of Unicode characters with property Deprecated.
-	Diacritic				= _Diacritic;				// Diacritic is the set of Unicode characters with property Diacritic.
-	Extender				= _Extender;				// Extender is the set of Unicode characters with property Extender.
-	Hex_Digit				= _Hex_Digit;				// Hex_Digit is the set of Unicode characters with property Hex_Digit.
-	Hyphen					= _Hyphen;				// Hyphen is the set of Unicode characters with property Hyphen.
-	IDS_Binary_Operator			= _IDS_Binary_Operator;			// IDS_Binary_Operator is the set of Unicode characters with property IDS_Binary_Operator.
-	IDS_Trinary_Operator			= _IDS_Trinary_Operator;		// IDS_Trinary_Operator is the set of Unicode characters with property IDS_Trinary_Operator.
-	Ideographic				= _Ideographic;				// Ideographic is the set of Unicode characters with property Ideographic.
-	Join_Control				= _Join_Control;			// Join_Control is the set of Unicode characters with property Join_Control.
-	Logical_Order_Exception			= _Logical_Order_Exception;		// Logical_Order_Exception is the set of Unicode characters with property Logical_Order_Exception.
-	Noncharacter_Code_Point			= _Noncharacter_Code_Point;		// Noncharacter_Code_Point is the set of Unicode characters with property Noncharacter_Code_Point.
-	Other_Alphabetic			= _Other_Alphabetic;			// Other_Alphabetic is the set of Unicode characters with property Other_Alphabetic.
-	Other_Default_Ignorable_Code_Point	= _Other_Default_Ignorable_Code_Point;	// Other_Default_Ignorable_Code_Point is the set of Unicode characters with property Other_Default_Ignorable_Code_Point.
-	Other_Grapheme_Extend			= _Other_Grapheme_Extend;		// Other_Grapheme_Extend is the set of Unicode characters with property Other_Grapheme_Extend.
-	Other_ID_Continue			= _Other_ID_Continue;			// Other_ID_Continue is the set of Unicode characters with property Other_ID_Continue.
-	Other_ID_Start				= _Other_ID_Start;			// Other_ID_Start is the set of Unicode characters with property Other_ID_Start.
-	Other_Lowercase				= _Other_Lowercase;			// Other_Lowercase is the set of Unicode characters with property Other_Lowercase.
-	Other_Math				= _Other_Math;				// Other_Math is the set of Unicode characters with property Other_Math.
-	Other_Uppercase				= _Other_Uppercase;			// Other_Uppercase is the set of Unicode characters with property Other_Uppercase.
-	Pattern_Syntax				= _Pattern_Syntax;			// Pattern_Syntax is the set of Unicode characters with property Pattern_Syntax.
-	Pattern_White_Space			= _Pattern_White_Space;			// Pattern_White_Space is the set of Unicode characters with property Pattern_White_Space.
-	Quotation_Mark				= _Quotation_Mark;			// Quotation_Mark is the set of Unicode characters with property Quotation_Mark.
-	Radical					= _Radical;				// Radical is the set of Unicode characters with property Radical.
-	STerm					= _STerm;				// STerm is the set of Unicode characters with property STerm.
-	Soft_Dotted				= _Soft_Dotted;				// Soft_Dotted is the set of Unicode characters with property Soft_Dotted.
-	Terminal_Punctuation			= _Terminal_Punctuation;		// Terminal_Punctuation is the set of Unicode characters with property Terminal_Punctuation.
-	Unified_Ideograph			= _Unified_Ideograph;			// Unified_Ideograph is the set of Unicode characters with property Unified_Ideograph.
-	Variation_Selector			= _Variation_Selector;			// Variation_Selector is the set of Unicode characters with property Variation_Selector.
-	White_Space				= _White_Space;				// White_Space is the set of Unicode characters with property White_Space.
+	ASCII_Hex_Digit                    = _ASCII_Hex_Digit                    // ASCII_Hex_Digit is the set of Unicode characters with property ASCII_Hex_Digit.
+	Bidi_Control                       = _Bidi_Control                       // Bidi_Control is the set of Unicode characters with property Bidi_Control.
+	Dash                               = _Dash                               // Dash is the set of Unicode characters with property Dash.
+	Deprecated                         = _Deprecated                         // Deprecated is the set of Unicode characters with property Deprecated.
+	Diacritic                          = _Diacritic                          // Diacritic is the set of Unicode characters with property Diacritic.
+	Extender                           = _Extender                           // Extender is the set of Unicode characters with property Extender.
+	Hex_Digit                          = _Hex_Digit                          // Hex_Digit is the set of Unicode characters with property Hex_Digit.
+	Hyphen                             = _Hyphen                             // Hyphen is the set of Unicode characters with property Hyphen.
+	IDS_Binary_Operator                = _IDS_Binary_Operator                // IDS_Binary_Operator is the set of Unicode characters with property IDS_Binary_Operator.
+	IDS_Trinary_Operator               = _IDS_Trinary_Operator               // IDS_Trinary_Operator is the set of Unicode characters with property IDS_Trinary_Operator.
+	Ideographic                        = _Ideographic                        // Ideographic is the set of Unicode characters with property Ideographic.
+	Join_Control                       = _Join_Control                       // Join_Control is the set of Unicode characters with property Join_Control.
+	Logical_Order_Exception            = _Logical_Order_Exception            // Logical_Order_Exception is the set of Unicode characters with property Logical_Order_Exception.
+	Noncharacter_Code_Point            = _Noncharacter_Code_Point            // Noncharacter_Code_Point is the set of Unicode characters with property Noncharacter_Code_Point.
+	Other_Alphabetic                   = _Other_Alphabetic                   // Other_Alphabetic is the set of Unicode characters with property Other_Alphabetic.
+	Other_Default_Ignorable_Code_Point = _Other_Default_Ignorable_Code_Point // Other_Default_Ignorable_Code_Point is the set of Unicode characters with property Other_Default_Ignorable_Code_Point.
+	Other_Grapheme_Extend              = _Other_Grapheme_Extend              // Other_Grapheme_Extend is the set of Unicode characters with property Other_Grapheme_Extend.
+	Other_ID_Continue                  = _Other_ID_Continue                  // Other_ID_Continue is the set of Unicode characters with property Other_ID_Continue.
+	Other_ID_Start                     = _Other_ID_Start                     // Other_ID_Start is the set of Unicode characters with property Other_ID_Start.
+	Other_Lowercase                    = _Other_Lowercase                    // Other_Lowercase is the set of Unicode characters with property Other_Lowercase.
+	Other_Math                         = _Other_Math                         // Other_Math is the set of Unicode characters with property Other_Math.
+	Other_Uppercase                    = _Other_Uppercase                    // Other_Uppercase is the set of Unicode characters with property Other_Uppercase.
+	Pattern_Syntax                     = _Pattern_Syntax                     // Pattern_Syntax is the set of Unicode characters with property Pattern_Syntax.
+	Pattern_White_Space                = _Pattern_White_Space                // Pattern_White_Space is the set of Unicode characters with property Pattern_White_Space.
+	Quotation_Mark                     = _Quotation_Mark                     // Quotation_Mark is the set of Unicode characters with property Quotation_Mark.
+	Radical                            = _Radical                            // Radical is the set of Unicode characters with property Radical.
+	STerm                              = _STerm                              // STerm is the set of Unicode characters with property STerm.
+	Soft_Dotted                        = _Soft_Dotted                        // Soft_Dotted is the set of Unicode characters with property Soft_Dotted.
+	Terminal_Punctuation               = _Terminal_Punctuation               // Terminal_Punctuation is the set of Unicode characters with property Terminal_Punctuation.
+	Unified_Ideograph                  = _Unified_Ideograph                  // Unified_Ideograph is the set of Unicode characters with property Unified_Ideograph.
+	Variation_Selector                 = _Variation_Selector                 // Variation_Selector is the set of Unicode characters with property Variation_Selector.
+	White_Space                        = _White_Space                        // White_Space is the set of Unicode characters with property White_Space.
 )
 
 // Generated by running
diff --git a/src/pkg/utf8/utf8.go b/src/pkg/utf8/utf8.go
index ad78f599ce..8e373e32d1 100644
--- a/src/pkg/utf8/utf8.go
+++ b/src/pkg/utf8/utf8.go
@@ -6,40 +6,40 @@
 // This package calls a Unicode character a rune for brevity.
 package utf8
 
-import "unicode"	// only needed for a couple of constants
+import "unicode" // only needed for a couple of constants
 
 // Numbers fundamental to the encoding.
 const (
-	RuneError	= unicode.ReplacementChar;	// the "error" Rune or "replacement character".
-	RuneSelf	= 0x80;				// characters below Runeself are represented as themselves in a single byte.
-	UTFMax		= 4;				// maximum number of bytes of a UTF-8 encoded Unicode character.
+	RuneError = unicode.ReplacementChar // the "error" Rune or "replacement character".
+	RuneSelf  = 0x80                    // characters below Runeself are represented as themselves in a single byte.
+	UTFMax    = 4                       // maximum number of bytes of a UTF-8 encoded Unicode character.
 )
 
 const (
-	_T1	= 0x00;	// 0000 0000
-	_Tx	= 0x80;	// 1000 0000
-	_T2	= 0xC0;	// 1100 0000
-	_T3	= 0xE0;	// 1110 0000
-	_T4	= 0xF0;	// 1111 0000
-	_T5	= 0xF8;	// 1111 1000
-
-	_Maskx	= 0x3F;	// 0011 1111
-	_Mask2	= 0x1F;	// 0001 1111
-	_Mask3	= 0x0F;	// 0000 1111
-	_Mask4	= 0x07;	// 0000 0111
-
-	_Rune1Max	= 1<<7 - 1;
-	_Rune2Max	= 1<<11 - 1;
-	_Rune3Max	= 1<<16 - 1;
-	_Rune4Max	= 1<<21 - 1;
+	_T1 = 0x00 // 0000 0000
+	_Tx = 0x80 // 1000 0000
+	_T2 = 0xC0 // 1100 0000
+	_T3 = 0xE0 // 1110 0000
+	_T4 = 0xF0 // 1111 0000
+	_T5 = 0xF8 // 1111 1000
+
+	_Maskx = 0x3F // 0011 1111
+	_Mask2 = 0x1F // 0001 1111
+	_Mask3 = 0x0F // 0000 1111
+	_Mask4 = 0x07 // 0000 0111
+
+	_Rune1Max = 1<<7 - 1
+	_Rune2Max = 1<<11 - 1
+	_Rune3Max = 1<<16 - 1
+	_Rune4Max = 1<<21 - 1
 )
 
 func decodeRuneInternal(p []byte) (rune, size int, short bool) {
-	n := len(p);
+	n := len(p)
 	if n < 1 {
 		return RuneError, 0, true
 	}
-	c0 := p[0];
+	c0 := p[0]
 
 	// 1-byte, 7-bit sequence?
 	if c0 < _Tx {
@@ -55,66 +55,66 @@ func decodeRuneInternal(p []byte) (rune, size int, short bool) {
 	if n < 2 {
 		return RuneError, 1, true
 	}
-	c1 := p[1];
+	c1 := p[1]
 	if c1 < _Tx || _T2 <= c1 {
 		return RuneError, 1, false
 	}
 
 	// 2-byte, 11-bit sequence?
 	if c0 < _T3 {
-		rune = int(c0&_Mask2)<<6 | int(c1&_Maskx);
+		rune = int(c0&_Mask2)<<6 | int(c1&_Maskx)
 		if rune <= _Rune1Max {
 			return RuneError, 1, false
 		}
-		return rune, 2, false;
+		return rune, 2, false
 	}
 
 	// need second continuation byte
 	if n < 3 {
 		return RuneError, 1, true
 	}
-	c2 := p[2];
+	c2 := p[2]
 	if c2 < _Tx || _T2 <= c2 {
 		return RuneError, 1, false
 	}
 
 	// 3-byte, 16-bit sequence?
 	if c0 < _T4 {
-		rune = int(c0&_Mask3)<<12 | int(c1&_Maskx)<<6 | int(c2&_Maskx);
+		rune = int(c0&_Mask3)<<12 | int(c1&_Maskx)<<6 | int(c2&_Maskx)
 		if rune <= _Rune2Max {
 			return RuneError, 1, false
 		}
-		return rune, 3, false;
+		return rune, 3, false
 	}
 
 	// need third continuation byte
 	if n < 4 {
 		return RuneError, 1, true
 	}
-	c3 := p[3];
+	c3 := p[3]
 	if c3 < _Tx || _T2 <= c3 {
 		return RuneError, 1, false
 	}
 
 	// 4-byte, 21-bit sequence?
 	if c0 < _T5 {
-		rune = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx);
+		rune = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx)
 		if rune <= _Rune3Max {
 			return RuneError, 1, false
 		}
-		return rune, 4, false;
+		return rune, 4, false
 	}
 
 	// error
-	return RuneError, 1, false;
+	return RuneError, 1, false
 }
 
 func decodeRuneInStringInternal(s string) (rune, size int, short bool) {
-	n := len(s);
+	n := len(s)
 	if n < 1 {
 		return RuneError, 0, true
 	}
-	c0 := s[0];
+	c0 := s[0]
 
 	// 1-byte, 7-bit sequence?
 	if c0 < _Tx {
@@ -130,83 +130,83 @@ func decodeRuneInStringInternal(s string) (rune, size int, short bool) {
 	if n < 2 {
 		return RuneError, 1, true
 	}
-	c1 := s[1];
+	c1 := s[1]
 	if c1 < _Tx || _T2 <= c1 {
 		return RuneError, 1, false
 	}
 
 	// 2-byte, 11-bit sequence?
 	if c0 < _T3 {
-		rune = int(c0&_Mask2)<<6 | int(c1&_Maskx);
+		rune = int(c0&_Mask2)<<6 | int(c1&_Maskx)
 		if rune <= _Rune1Max {
 			return RuneError, 1, false
 		}
-		return rune, 2, false;
+		return rune, 2, false
 	}
 
 	// need second continuation byte
 	if n < 3 {
 		return RuneError, 1, true
 	}
-	c2 := s[2];
+	c2 := s[2]
 	if c2 < _Tx || _T2 <= c2 {
 		return RuneError, 1, false
 	}
 
 	// 3-byte, 16-bit sequence?
 	if c0 < _T4 {
-		rune = int(c0&_Mask3)<<12 | int(c1&_Maskx)<<6 | int(c2&_Maskx);
+		rune = int(c0&_Mask3)<<12 | int(c1&_Maskx)<<6 | int(c2&_Maskx)
 		if rune <= _Rune2Max {
 			return RuneError, 1, false
 		}
-		return rune, 3, false;
+		return rune, 3, false
 	}
 
 	// need third continuation byte
 	if n < 4 {
 		return RuneError, 1, true
 	}
-	c3 := s[3];
+	c3 := s[3]
 	if c3 < _Tx || _T2 <= c3 {
 		return RuneError, 1, false
 	}
 
 	// 4-byte, 21-bit sequence?
 	if c0 < _T5 {
-		rune = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx);
+		rune = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx)
 		if rune <= _Rune3Max {
 			return RuneError, 1, false
 		}
-		return rune, 4, false;
+		return rune, 4, false
 	}
 
 	// error
-	return RuneError, 1, false;
+	return RuneError, 1, false
 }
 
 // FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.
 // An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.
 func FullRune(p []byte) bool {
-	_, _, short := decodeRuneInternal(p);
-	return !short;
+	_, _, short := decodeRuneInternal(p)
+	return !short
 }
 
 // FullRuneInString is like FullRune but its input is a string.
 func FullRuneInString(s string) bool {
-	_, _, short := decodeRuneInStringInternal(s);
-	return !short;
+	_, _, short := decodeRuneInStringInternal(s)
+	return !short
 }
 
 // DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and its width in bytes.
 func DecodeRune(p []byte) (rune, size int) {
-	rune, size, _ = decodeRuneInternal(p);
-	return;
+	rune, size, _ = decodeRuneInternal(p)
+	return
 }
 
 // DecodeRuneInString is like DecodeRune but its input is a string.
 func DecodeRuneInString(s string) (rune, size int) {
-	rune, size, _ = decodeRuneInStringInternal(s);
-	return;
+	rune, size, _ = decodeRuneInStringInternal(s)
+	return
 }
 
 // RuneLen returns the number of bytes required to encode the rune.
@@ -221,24 +221,24 @@ func RuneLen(rune int) int {
 	case rune <= _Rune4Max:
 		return 4
 	}
-	return -1;
+	return -1
 }
 
 // EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.
 // It returns the number of bytes written.
 func EncodeRune(rune int, p []byte) int {
 	// Negative values are erroneous.  Making it unsigned addresses the problem.
-	r := uint(rune);
+	r := uint(rune)
 
 	if r <= _Rune1Max {
-		p[0] = byte(r);
-		return 1;
+		p[0] = byte(r)
+		return 1
 	}
 
 	if r <= _Rune2Max {
-		p[0] = _T2 | byte(r>>6);
-		p[1] = _Tx | byte(r)&_Maskx;
-		return 2;
+		p[0] = _T2 | byte(r>>6)
+		p[1] = _Tx | byte(r)&_Maskx
+		return 2
 	}
 
 	if r > unicode.MaxRune {
@@ -246,33 +246,33 @@ func EncodeRune(rune int, p []byte) int {
 	}
 
 	if r <= _Rune3Max {
-		p[0] = _T3 | byte(r>>12);
-		p[1] = _Tx | byte(r>>6)&_Maskx;
-		p[2] = _Tx | byte(r)&_Maskx;
-		return 3;
+		p[0] = _T3 | byte(r>>12)
+		p[1] = _Tx | byte(r>>6)&_Maskx
+		p[2] = _Tx | byte(r)&_Maskx
+		return 3
 	}
 
-	p[0] = _T4 | byte(r>>18);
-	p[1] = _Tx | byte(r>>12)&_Maskx;
-	p[2] = _Tx | byte(r>>6)&_Maskx;
-	p[3] = _Tx | byte(r)&_Maskx;
-	return 4;
+	p[0] = _T4 | byte(r>>18)
+	p[1] = _Tx | byte(r>>12)&_Maskx
+	p[2] = _Tx | byte(r>>6)&_Maskx
+	p[3] = _Tx | byte(r)&_Maskx
+	return 4
 }
 
 // RuneCount returns the number of runes in p.  Erroneous and short
 // encodings are treated as single runes of width 1 byte.
 func RuneCount(p []byte) int {
-	i := 0;
-	var n int;
+	i := 0
+	var n int
 	for n = 0; i < len(p); n++ {
 		if p[i] < RuneSelf {
 			i++
 		} else {
-			_, size := DecodeRune(p[i:]);
-			i += size;
+			_, size := DecodeRune(p[i:])
+			i += size
 		}
 	}
-	return n;
+	return n
 }
 
 // RuneCountInString is like RuneCount but its input is a string.
@@ -280,10 +280,10 @@ func RuneCountInString(s string) (n int) {
 	for _ = range s {
 		n++
 	}
-	return;
+	return
 }
 
 // RuneStart reports whether the byte could be the first byte of
 // an encoded rune.  Second and subsequent bytes always have the top
 // two bits set to 10.
-func RuneStart(b byte) bool	{ return b&0xC0 != 0x80 }
+func RuneStart(b byte) bool { return b&0xC0 != 0x80 }
diff --git a/src/pkg/utf8/utf8_test.go b/src/pkg/utf8/utf8_test.go
index 595efc6343..68bfa6a772 100644
--- a/src/pkg/utf8/utf8_test.go
+++ b/src/pkg/utf8/utf8_test.go
@@ -5,15 +5,15 @@
 package utf8_test
 
 import (
-	"bytes";
-	"strings";
-	"testing";
-	. "utf8";
+	"bytes"
+	"strings"
+	"testing"
+	. "utf8"
 )
 
 type Utf8Map struct {
-	rune	int;
-	str	string;
+	rune int
+	str  string
 }
 
 var utf8map = []Utf8Map{
@@ -47,27 +47,27 @@ var utf8map = []Utf8Map{
 
 // strings.Bytes with one extra byte at end
 func makeBytes(s string) []byte {
-	s += "\x00";
-	b := strings.Bytes(s);
-	return b[0 : len(s)-1];
+	s += "\x00"
+	b := strings.Bytes(s)
+	return b[0 : len(s)-1]
 }
 
 func TestFullRune(t *testing.T) {
 	for i := 0; i < len(utf8map); i++ {
-		m := utf8map[i];
-		b := makeBytes(m.str);
+		m := utf8map[i]
+		b := makeBytes(m.str)
 		if !FullRune(b) {
 			t.Errorf("FullRune(%q) (rune %04x) = false, want true", b, m.rune)
 		}
-		s := m.str;
+		s := m.str
 		if !FullRuneInString(s) {
 			t.Errorf("FullRuneInString(%q) (rune %04x) = false, want true", s, m.rune)
 		}
-		b1 := b[0 : len(b)-1];
+		b1 := b[0 : len(b)-1]
 		if FullRune(b1) {
 			t.Errorf("FullRune(%q) = true, want false", b1)
 		}
-		s1 := string(b1);
+		s1 := string(b1)
 		if FullRuneInString(s1) {
 			t.Errorf("FullRune(%q) = true, want false", s1)
 		}
@@ -76,11 +76,11 @@ func TestFullRune(t *testing.T) {
 
 func TestEncodeRune(t *testing.T) {
 	for i := 0; i < len(utf8map); i++ {
-		m := utf8map[i];
-		b := makeBytes(m.str);
-		var buf [10]byte;
-		n := EncodeRune(m.rune, &buf);
-		b1 := buf[0:n];
+		m := utf8map[i]
+		b := makeBytes(m.str)
+		var buf [10]byte
+		n := EncodeRune(m.rune, &buf)
+		b1 := buf[0:n]
 		if !bytes.Equal(b, b1) {
 			t.Errorf("EncodeRune(%#04x) = %q want %q", m.rune, b1, b)
 		}
@@ -89,40 +89,40 @@ func TestEncodeRune(t *testing.T) {
 
 func TestDecodeRune(t *testing.T) {
 	for i := 0; i < len(utf8map); i++ {
-		m := utf8map[i];
-		b := makeBytes(m.str);
-		rune, size := DecodeRune(b);
+		m := utf8map[i]
+		b := makeBytes(m.str)
+		rune, size := DecodeRune(b)
 		if rune != m.rune || size != len(b) {
 			t.Errorf("DecodeRune(%q) = %#04x, %d want %#04x, %d", b, rune, size, m.rune, len(b))
 		}
-		s := m.str;
-		rune, size = DecodeRuneInString(s);
+		s := m.str
+		rune, size = DecodeRuneInString(s)
 		if rune != m.rune || size != len(b) {
 			t.Errorf("DecodeRune(%q) = %#04x, %d want %#04x, %d", s, rune, size, m.rune, len(b))
 		}
 
 		// there's an extra byte that bytes left behind - make sure trailing byte works
-		rune, size = DecodeRune(b[0:cap(b)]);
+		rune, size = DecodeRune(b[0:cap(b)])
 		if rune != m.rune || size != len(b) {
 			t.Errorf("DecodeRune(%q) = %#04x, %d want %#04x, %d", b, rune, size, m.rune, len(b))
 		}
-		s = m.str + "\x00";
-		rune, size = DecodeRuneInString(s);
+		s = m.str + "\x00"
+		rune, size = DecodeRuneInString(s)
 		if rune != m.rune || size != len(b) {
 			t.Errorf("DecodeRuneInString(%q) = %#04x, %d want %#04x, %d", s, rune, size, m.rune, len(b))
 		}
 
 		// make sure missing bytes fail
-		wantsize := 1;
+		wantsize := 1
 		if wantsize >= len(b) {
 			wantsize = 0
 		}
-		rune, size = DecodeRune(b[0 : len(b)-1]);
+		rune, size = DecodeRune(b[0 : len(b)-1])
 		if rune != RuneError || size != wantsize {
 			t.Errorf("DecodeRune(%q) = %#04x, %d want %#04x, %d", b[0:len(b)-1], rune, size, RuneError, wantsize)
 		}
-		s = m.str[0 : len(m.str)-1];
-		rune, size = DecodeRuneInString(s);
+		s = m.str[0 : len(m.str)-1]
+		rune, size = DecodeRuneInString(s)
 		if rune != RuneError || size != wantsize {
 			t.Errorf("DecodeRuneInString(%q) = %#04x, %d want %#04x, %d", s, rune, size, RuneError, wantsize)
 		}
@@ -133,12 +133,12 @@ func TestDecodeRune(t *testing.T) {
 		} else {
 			b[len(b)-1] = 0x7F
 		}
-		rune, size = DecodeRune(b);
+		rune, size = DecodeRune(b)
 		if rune != RuneError || size != 1 {
 			t.Errorf("DecodeRune(%q) = %#04x, %d want %#04x, %d", b, rune, size, RuneError, 1)
 		}
-		s = string(b);
-		rune, size = DecodeRune(b);
+		s = string(b)
+		rune, size = DecodeRune(b)
 		if rune != RuneError || size != 1 {
 			t.Errorf("DecodeRuneInString(%q) = %#04x, %d want %#04x, %d", s, rune, size, RuneError, 1)
 		}
@@ -147,18 +147,18 @@ func TestDecodeRune(t *testing.T) {
 
 // Check that negative runes encode as U+FFFD.
 func TestNegativeRune(t *testing.T) {
-	errorbuf := make([]byte, UTFMax);
-	errorbuf = errorbuf[0:EncodeRune(RuneError, errorbuf)];
-	buf := make([]byte, UTFMax);
-	buf = buf[0:EncodeRune(-1, buf)];
+	errorbuf := make([]byte, UTFMax)
+	errorbuf = errorbuf[0:EncodeRune(RuneError, errorbuf)]
+	buf := make([]byte, UTFMax)
+	buf = buf[0:EncodeRune(-1, buf)]
 	if !bytes.Equal(buf, errorbuf) {
 		t.Errorf("incorrect encoding [% x] for -1; expected [% x]", buf, errorbuf)
 	}
 }
 
 type RuneCountTest struct {
-	in	string;
-	out	int;
+	in  string
+	out int
 }
 
 var runecounttests = []RuneCountTest{
@@ -170,7 +170,7 @@ var runecounttests = []RuneCountTest{
 
 func TestRuneCount(t *testing.T) {
 	for i := 0; i < len(runecounttests); i++ {
-		tt := runecounttests[i];
+		tt := runecounttests[i]
 		if out := RuneCountInString(tt.in); out != tt.out {
 			t.Errorf("RuneCountInString(%q) = %d, want %d", tt.in, out, tt.out)
 		}
@@ -193,28 +193,28 @@ func BenchmarkRuneCountTenJapaneseChars(b *testing.B) {
 }
 
 func BenchmarkEncodeASCIIRune(b *testing.B) {
-	buf := make([]byte, UTFMax);
+	buf := make([]byte, UTFMax)
 	for i := 0; i < b.N; i++ {
 		EncodeRune('a', buf)
 	}
 }
 
 func BenchmarkEncodeJapaneseRune(b *testing.B) {
-	buf := make([]byte, UTFMax);
+	buf := make([]byte, UTFMax)
 	for i := 0; i < b.N; i++ {
 		EncodeRune('本', buf)
 	}
 }
 
 func BenchmarkDecodeASCIIRune(b *testing.B) {
-	a := []byte{'a'};
+	a := []byte{'a'}
 	for i := 0; i < b.N; i++ {
 		DecodeRune(a)
 	}
 }
 
 func BenchmarkDecodeJapaneseRune(b *testing.B) {
-	nihon := strings.Bytes("本");
+	nihon := strings.Bytes("本")
 	for i := 0; i < b.N; i++ {
 		DecodeRune(nihon)
 	}
diff --git a/src/pkg/websocket/client.go b/src/pkg/websocket/client.go
index bedaec02f2..c81f4f440f 100644
--- a/src/pkg/websocket/client.go
+++ b/src/pkg/websocket/client.go
@@ -5,40 +5,40 @@
 package websocket
 
 import (
-	"bufio";
-	"http";
-	"io";
-	"net";
-	"os";
+	"bufio"
+	"http"
+	"io"
+	"net"
+	"os"
 )
 
 type ProtocolError struct {
-	os.ErrorString;
+	os.ErrorString
 }
 
 var (
-	ErrBadStatus		= &ProtocolError{"bad status"};
-	ErrNoUpgrade		= &ProtocolError{"no upgrade"};
-	ErrBadUpgrade		= &ProtocolError{"bad upgrade"};
-	ErrNoWebSocketOrigin	= &ProtocolError{"no WebSocket-Origin"};
-	ErrBadWebSocketOrigin	= &ProtocolError{"bad WebSocket-Origin"};
-	ErrNoWebSocketLocation	= &ProtocolError{"no WebSocket-Location"};
-	ErrBadWebSocketLocation	= &ProtocolError{"bad WebSocket-Location"};
-	ErrNoWebSocketProtocol	= &ProtocolError{"no WebSocket-Protocol"};
-	ErrBadWebSocketProtocol	= &ProtocolError{"bad WebSocket-Protocol"};
+	ErrBadStatus            = &ProtocolError{"bad status"}
+	ErrNoUpgrade            = &ProtocolError{"no upgrade"}
+	ErrBadUpgrade           = &ProtocolError{"bad upgrade"}
+	ErrNoWebSocketOrigin    = &ProtocolError{"no WebSocket-Origin"}
+	ErrBadWebSocketOrigin   = &ProtocolError{"bad WebSocket-Origin"}
+	ErrNoWebSocketLocation  = &ProtocolError{"no WebSocket-Location"}
+	ErrBadWebSocketLocation = &ProtocolError{"bad WebSocket-Location"}
+	ErrNoWebSocketProtocol  = &ProtocolError{"no WebSocket-Protocol"}
+	ErrBadWebSocketProtocol = &ProtocolError{"bad WebSocket-Protocol"}
 )
 
 // newClient creates a new Web Socket client connection.
 func newClient(resourceName, host, origin, location, protocol string, rwc io.ReadWriteCloser) (ws *Conn, err os.Error) {
-	br := bufio.NewReader(rwc);
-	bw := bufio.NewWriter(rwc);
-	err = handshake(resourceName, host, origin, location, protocol, br, bw);
+	br := bufio.NewReader(rwc)
+	bw := bufio.NewWriter(rwc)
+	err = handshake(resourceName, host, origin, location, protocol, br, bw)
 	if err != nil {
 		return
 	}
-	buf := bufio.NewReadWriter(br, bw);
-	ws = newConn(origin, location, protocol, buf, rwc);
-	return;
+	buf := bufio.NewReadWriter(br, bw)
+	ws = newConn(origin, location, protocol, buf, rwc)
+	return
 }
 
 // Dial opens new Web Socket client connection.
@@ -68,55 +68,55 @@ func newClient(resourceName, host, origin, location, protocol string, rwc io.Rea
 // }
 
 func Dial(url, protocol, origin string) (ws *Conn, err os.Error) {
-	parsedUrl, err := http.ParseURL(url);
+	parsedUrl, err := http.ParseURL(url)
 	if err != nil {
 		return
 	}
-	client, err := net.Dial("tcp", "", parsedUrl.Host);
+	client, err := net.Dial("tcp", "", parsedUrl.Host)
 	if err != nil {
 		return
 	}
-	return newClient(parsedUrl.Path, parsedUrl.Host, origin, url, protocol, client);
+	return newClient(parsedUrl.Path, parsedUrl.Host, origin, url, protocol, client)
 }
 
 func handshake(resourceName, host, origin, location, protocol string, br *bufio.Reader, bw *bufio.Writer) (err os.Error) {
-	bw.WriteString("GET " + resourceName + " HTTP/1.1\r\n");
-	bw.WriteString("Upgrade: WebSocket\r\n");
-	bw.WriteString("Connection: Upgrade\r\n");
-	bw.WriteString("Host: " + host + "\r\n");
-	bw.WriteString("Origin: " + origin + "\r\n");
+	bw.WriteString("GET " + resourceName + " HTTP/1.1\r\n")
+	bw.WriteString("Upgrade: WebSocket\r\n")
+	bw.WriteString("Connection: Upgrade\r\n")
+	bw.WriteString("Host: " + host + "\r\n")
+	bw.WriteString("Origin: " + origin + "\r\n")
 	if protocol != "" {
 		bw.WriteString("WebSocket-Protocol: " + protocol + "\r\n")
 	}
-	bw.WriteString("\r\n");
-	bw.Flush();
-	resp, err := http.ReadResponse(br);
+	bw.WriteString("\r\n")
+	bw.Flush()
+	resp, err := http.ReadResponse(br)
 	if err != nil {
 		return
 	}
 	if resp.Status != "101 Web Socket Protocol Handshake" {
 		return ErrBadStatus
 	}
-	upgrade, found := resp.Header["Upgrade"];
+	upgrade, found := resp.Header["Upgrade"]
 	if !found {
 		return ErrNoUpgrade
 	}
 	if upgrade != "WebSocket" {
 		return ErrBadUpgrade
 	}
-	connection, found := resp.Header["Connection"];
+	connection, found := resp.Header["Connection"]
 	if !found || connection != "Upgrade" {
 		return ErrBadUpgrade
 	}
 
-	ws_origin, found := resp.Header["Websocket-Origin"];
+	ws_origin, found := resp.Header["Websocket-Origin"]
 	if !found {
 		return ErrNoWebSocketOrigin
 	}
 	if ws_origin != origin {
 		return ErrBadWebSocketOrigin
 	}
-	ws_location, found := resp.Header["Websocket-Location"];
+	ws_location, found := resp.Header["Websocket-Location"]
 	if !found {
 		return ErrNoWebSocketLocation
 	}
@@ -124,7 +124,7 @@ func handshake(resourceName, host, origin, location, protocol string, br *bufio.
 		return ErrBadWebSocketLocation
 	}
 	if protocol != "" {
-		ws_protocol, found := resp.Header["Websocket-Protocol"];
+		ws_protocol, found := resp.Header["Websocket-Protocol"]
 		if !found {
 			return ErrNoWebSocketProtocol
 		}
@@ -132,5 +132,5 @@ func handshake(resourceName, host, origin, location, protocol string, br *bufio.
 			return ErrBadWebSocketProtocol
 		}
 	}
-	return;
+	return
 }
diff --git a/src/pkg/websocket/server.go b/src/pkg/websocket/server.go
index e2d8cecbb0..bf80f6cc01 100644
--- a/src/pkg/websocket/server.go
+++ b/src/pkg/websocket/server.go
@@ -5,8 +5,8 @@
 package websocket
 
 import (
-	"http";
-	"io";
+	"http"
+	"io"
 )
 
 // Handler is a interface that use a WebSocket.
@@ -39,35 +39,35 @@ func (f Handler) ServeHTTP(c *http.Conn, req *http.Request) {
 	if req.Method != "GET" || req.Proto != "HTTP/1.1" ||
 		req.Header["Upgrade"] != "WebSocket" ||
 		req.Header["Connection"] != "Upgrade" {
-		c.WriteHeader(http.StatusNotFound);
-		io.WriteString(c, "must use websocket to connect here");
-		return;
+		c.WriteHeader(http.StatusNotFound)
+		io.WriteString(c, "must use websocket to connect here")
+		return
 	}
-	rwc, buf, err := c.Hijack();
+	rwc, buf, err := c.Hijack()
 	if err != nil {
-		panic("Hijack failed: ", err.String());
-		return;
+		panic("Hijack failed: ", err.String())
+		return
 	}
-	defer rwc.Close();
-	origin := req.Header["Origin"];
-	location := "ws://" + req.Host + req.URL.Path;
+	defer rwc.Close()
+	origin := req.Header["Origin"]
+	location := "ws://" + req.Host + req.URL.Path
 
 	// TODO(ukai): verify origin,location,protocol.
 
-	buf.WriteString("HTTP/1.1 101 Web Socket Protocol Handshake\r\n");
-	buf.WriteString("Upgrade: WebSocket\r\n");
-	buf.WriteString("Connection: Upgrade\r\n");
-	buf.WriteString("WebSocket-Origin: " + origin + "\r\n");
-	buf.WriteString("WebSocket-Location: " + location + "\r\n");
-	protocol := "";
+	buf.WriteString("HTTP/1.1 101 Web Socket Protocol Handshake\r\n")
+	buf.WriteString("Upgrade: WebSocket\r\n")
+	buf.WriteString("Connection: Upgrade\r\n")
+	buf.WriteString("WebSocket-Origin: " + origin + "\r\n")
+	buf.WriteString("WebSocket-Location: " + location + "\r\n")
+	protocol := ""
 	// canonical header key of WebSocket-Protocol.
 	if protocol, found := req.Header["Websocket-Protocol"]; found {
 		buf.WriteString("WebSocket-Protocol: " + protocol + "\r\n")
 	}
-	buf.WriteString("\r\n");
+	buf.WriteString("\r\n")
 	if err := buf.Flush(); err != nil {
 		return
 	}
-	ws := newConn(origin, location, protocol, buf, rwc);
-	f(ws);
+	ws := newConn(origin, location, protocol, buf, rwc)
+	f(ws)
 }
diff --git a/src/pkg/websocket/websocket.go b/src/pkg/websocket/websocket.go
index 373961d570..efcb228b38 100644
--- a/src/pkg/websocket/websocket.go
+++ b/src/pkg/websocket/websocket.go
@@ -12,52 +12,52 @@ package websocket
 //   better logging.
 
 import (
-	"bufio";
-	"io";
-	"net";
-	"os";
+	"bufio"
+	"io"
+	"net"
+	"os"
 )
 
 type WebSocketAddr string
 
-func (addr WebSocketAddr) Network() string	{ return "websocket" }
+func (addr WebSocketAddr) Network() string { return "websocket" }
 
-func (addr WebSocketAddr) String() string	{ return string(addr) }
+func (addr WebSocketAddr) String() string { return string(addr) }
 
 // Conn is an channels to communicate over Web Socket.
 type Conn struct {
 	// An origin URI of the Web Socket.
-	Origin	string;
+	Origin string
 	// A location URI of the Web Socket.
-	Location	string;
+	Location string
 	// A subprotocol of the Web Socket.
-	Protocol	string;
+	Protocol string
 
-	buf	*bufio.ReadWriter;
-	rwc	io.ReadWriteCloser;
+	buf *bufio.ReadWriter
+	rwc io.ReadWriteCloser
 }
 
 // newConn creates a new Web Socket.
 func newConn(origin, location, protocol string, buf *bufio.ReadWriter, rwc io.ReadWriteCloser) *Conn {
 	if buf == nil {
-		br := bufio.NewReader(rwc);
-		bw := bufio.NewWriter(rwc);
-		buf = bufio.NewReadWriter(br, bw);
+		br := bufio.NewReader(rwc)
+		bw := bufio.NewWriter(rwc)
+		buf = bufio.NewReadWriter(br, bw)
 	}
-	ws := &Conn{origin, location, protocol, buf, rwc};
-	return ws;
+	ws := &Conn{origin, location, protocol, buf, rwc}
+	return ws
 }
 
 func (ws *Conn) Read(msg []byte) (n int, err os.Error) {
 	for {
-		frameByte, err := ws.buf.ReadByte();
+		frameByte, err := ws.buf.ReadByte()
 		if err != nil {
 			return n, err
 		}
 		if (frameByte & 0x80) == 0x80 {
-			length := 0;
+			length := 0
 			for {
-				c, err := ws.buf.ReadByte();
+				c, err := ws.buf.ReadByte()
 				if err != nil {
 					return n, err
 				}
@@ -68,15 +68,15 @@ func (ws *Conn) Read(msg []byte) (n int, err os.Error) {
 				}
 			}
 			for length > 0 {
-				_, err := ws.buf.ReadByte();
+				_, err := ws.buf.ReadByte()
 				if err != nil {
 					return n, err
 				}
-				length--;
+				length--
 			}
 		} else {
 			for {
-				c, err := ws.buf.ReadByte();
+				c, err := ws.buf.ReadByte()
 				if err != nil {
 					return n, err
 				}
@@ -87,8 +87,8 @@ func (ws *Conn) Read(msg []byte) (n int, err os.Error) {
 					if n+1 <= cap(msg) {
 						msg = msg[0 : n+1]
 					}
-					msg[n] = c;
-					n++;
+					msg[n] = c
+					n++
 				}
 				if n >= cap(msg) {
 					return n, os.E2BIG
@@ -97,42 +97,42 @@ func (ws *Conn) Read(msg []byte) (n int, err os.Error) {
 		}
 	}
 
-	panic("unreachable");
+	panic("unreachable")
 }
 
 func (ws *Conn) Write(msg []byte) (n int, err os.Error) {
-	ws.buf.WriteByte(0);
-	ws.buf.Write(msg);
-	ws.buf.WriteByte(0xff);
-	err = ws.buf.Flush();
-	return len(msg), err;
+	ws.buf.WriteByte(0)
+	ws.buf.Write(msg)
+	ws.buf.WriteByte(0xff)
+	err = ws.buf.Flush()
+	return len(msg), err
 }
 
-func (ws *Conn) Close() os.Error	{ return ws.rwc.Close() }
+func (ws *Conn) Close() os.Error { return ws.rwc.Close() }
 
-func (ws *Conn) LocalAddr() net.Addr	{ return WebSocketAddr(ws.Origin) }
+func (ws *Conn) LocalAddr() net.Addr { return WebSocketAddr(ws.Origin) }
 
-func (ws *Conn) RemoteAddr() net.Addr	{ return WebSocketAddr(ws.Location) }
+func (ws *Conn) RemoteAddr() net.Addr { return WebSocketAddr(ws.Location) }
 
 func (ws *Conn) SetTimeout(nsec int64) os.Error {
 	if conn, ok := ws.rwc.(net.Conn); ok {
 		return conn.SetTimeout(nsec)
 	}
-	return os.EINVAL;
+	return os.EINVAL
 }
 
 func (ws *Conn) SetReadTimeout(nsec int64) os.Error {
 	if conn, ok := ws.rwc.(net.Conn); ok {
 		return conn.SetReadTimeout(nsec)
 	}
-	return os.EINVAL;
+	return os.EINVAL
 }
 
 func (ws *Conn) SetWriteTimeout(nsec int64) os.Error {
 	if conn, ok := ws.rwc.(net.Conn); ok {
 		return conn.SetWriteTimeout(nsec)
 	}
-	return os.EINVAL;
+	return os.EINVAL
 }
 
-var _ net.Conn = (*Conn)(nil)	// compile-time check that *Conn implements net.Conn.
+var _ net.Conn = (*Conn)(nil) // compile-time check that *Conn implements net.Conn.
diff --git a/src/pkg/websocket/websocket_test.go b/src/pkg/websocket/websocket_test.go
index ed25053137..c62604621e 100644
--- a/src/pkg/websocket/websocket_test.go
+++ b/src/pkg/websocket/websocket_test.go
@@ -5,57 +5,57 @@
 package websocket
 
 import (
-	"bytes";
-	"http";
-	"io";
-	"log";
-	"net";
-	"once";
-	"strings";
-	"testing";
+	"bytes"
+	"http"
+	"io"
+	"log"
+	"net"
+	"once"
+	"strings"
+	"testing"
 )
 
 var serverAddr string
 
-func echoServer(ws *Conn)	{ io.Copy(ws, ws) }
+func echoServer(ws *Conn) { io.Copy(ws, ws) }
 
 func startServer() {
-	l, e := net.Listen("tcp", ":0");	// any available address
+	l, e := net.Listen("tcp", ":0") // any available address
 	if e != nil {
 		log.Exitf("net.Listen tcp :0 %v", e)
 	}
-	serverAddr = l.Addr().String();
-	log.Stderr("Test WebSocket server listening on ", serverAddr);
-	http.Handle("/echo", Handler(echoServer));
-	go http.Serve(l, nil);
+	serverAddr = l.Addr().String()
+	log.Stderr("Test WebSocket server listening on ", serverAddr)
+	http.Handle("/echo", Handler(echoServer))
+	go http.Serve(l, nil)
 }
 
 func TestEcho(t *testing.T) {
-	once.Do(startServer);
+	once.Do(startServer)
 
-	client, err := net.Dial("tcp", "", serverAddr);
+	client, err := net.Dial("tcp", "", serverAddr)
 	if err != nil {
 		t.Fatal("dialing", err)
 	}
 
 	ws, err := newClient("/echo", "localhost", "http://localhost",
-		"ws://localhost/echo", "", client);
+		"ws://localhost/echo", "", client)
 	if err != nil {
-		t.Errorf("WebSocket handshake error", err);
-		return;
+		t.Errorf("WebSocket handshake error", err)
+		return
 	}
-	msg := strings.Bytes("hello, world\n");
+	msg := strings.Bytes("hello, world\n")
 	if _, err := ws.Write(msg); err != nil {
 		t.Errorf("Write: error %v", err)
 	}
-	var actual_msg = make([]byte, 512);
-	n, err := ws.Read(actual_msg);
+	var actual_msg = make([]byte, 512)
+	n, err := ws.Read(actual_msg)
 	if err != nil {
 		t.Errorf("Read: error %v", err)
 	}
-	actual_msg = actual_msg[0:n];
+	actual_msg = actual_msg[0:n]
 	if !bytes.Equal(msg, actual_msg) {
 		t.Errorf("Echo: expected %q got %q", msg, actual_msg)
 	}
-	ws.Close();
+	ws.Close()
 }
diff --git a/src/pkg/xgb/example.go b/src/pkg/xgb/example.go
index d7276da4f1..1c5ad75054 100644
--- a/src/pkg/xgb/example.go
+++ b/src/pkg/xgb/example.go
@@ -5,63 +5,63 @@
 package main
 
 import (
-	"fmt";
-	"os";
-	"xgb";
+	"fmt"
+	"os"
+	"xgb"
 )
 
 func main() {
-	c, err := xgb.Dial(os.Getenv("DISPLAY"));
+	c, err := xgb.Dial(os.Getenv("DISPLAY"))
 	if err != nil {
-		fmt.Printf("cannot connect: %v\n", err);
-		os.Exit(1);
+		fmt.Printf("cannot connect: %v\n", err)
+		os.Exit(1)
 	}
 
-	fmt.Printf("vendor = '%s'\n", string(c.Setup.Vendor));
+	fmt.Printf("vendor = '%s'\n", string(c.Setup.Vendor))
 
-	win := c.NewId();
-	gc := c.NewId();
+	win := c.NewId()
+	gc := c.NewId()
 
-	c.CreateWindow(0, win, c.DefaultScreen().Root, 150, 150, 200, 200, 0, 0, 0, 0, nil);
+	c.CreateWindow(0, win, c.DefaultScreen().Root, 150, 150, 200, 200, 0, 0, 0, 0, nil)
 	c.ChangeWindowAttributes(win, xgb.CWEventMask,
-		[]uint32{xgb.EventMaskExposure | xgb.EventMaskKeyRelease});
-	c.CreateGC(gc, win, 0, nil);
-	c.MapWindow(win);
+		[]uint32{xgb.EventMaskExposure | xgb.EventMaskKeyRelease})
+	c.CreateGC(gc, win, 0, nil)
+	c.MapWindow(win)
 
-	atom, _ := c.InternAtom(0, "HELLO");
-	fmt.Printf("atom = %d\n", atom.Atom);
+	atom, _ := c.InternAtom(0, "HELLO")
+	fmt.Printf("atom = %d\n", atom.Atom)
 
-	points := make([]xgb.Point, 2);
-	points[1] = xgb.Point{5, 5};
-	points[1] = xgb.Point{100, 120};
+	points := make([]xgb.Point, 2)
+	points[1] = xgb.Point{5, 5}
+	points[1] = xgb.Point{100, 120}
 
-	hosts, _ := c.ListHosts();
-	fmt.Printf("hosts = %+v\n", hosts);
+	hosts, _ := c.ListHosts()
+	fmt.Printf("hosts = %+v\n", hosts)
 
-	ecookie := c.ListExtensionsRequest();
-	exts, _ := c.ListExtensionsReply(ecookie);
+	ecookie := c.ListExtensionsRequest()
+	exts, _ := c.ListExtensionsReply(ecookie)
 	for _, name := range exts.Names {
 		fmt.Printf("exts = '%s'\n", name.Name)
 	}
 
 	for {
-		reply, err := c.WaitForEvent();
+		reply, err := c.WaitForEvent()
 		if err != nil {
-			fmt.Printf("error: %v\n", err);
-			os.Exit(1);
+			fmt.Printf("error: %v\n", err)
+			os.Exit(1)
 		}
-		fmt.Printf("event %T\n", reply);
+		fmt.Printf("event %T\n", reply)
 		switch event := reply.(type) {
 		case xgb.ExposeEvent:
 			c.PolyLine(xgb.CoordModeOrigin, win, gc, points)
 		case xgb.KeyReleaseEvent:
-			fmt.Printf("key release!\n");
-			points[0].X = event.EventX;
-			points[0].Y = event.EventY;
-			c.PolyLine(xgb.CoordModeOrigin, win, gc, points);
-			c.Bell(75);
+			fmt.Printf("key release!\n")
+			points[0].X = event.EventX
+			points[0].Y = event.EventY
+			c.PolyLine(xgb.CoordModeOrigin, win, gc, points)
+			c.Bell(75)
 		}
 	}
 
-	c.Close();
+	c.Close()
 }
diff --git a/src/pkg/xgb/xgb.go b/src/pkg/xgb/xgb.go
index cfb1d65831..1cde2b5c93 100644
--- a/src/pkg/xgb/xgb.go
+++ b/src/pkg/xgb/xgb.go
@@ -7,26 +7,26 @@
 package xgb
 
 import (
-	"fmt";
-	"io";
-	"net";
-	"os";
-	"strconv";
-	"strings";
+	"fmt"
+	"io"
+	"net"
+	"os"
+	"strconv"
+	"strings"
 )
 
 // A Conn represents a connection to an X server.
 // Only one goroutine should use a Conn's methods at a time.
 type Conn struct {
-	conn		net.Conn;
-	nextId		Id;
-	nextCookie	Cookie;
-	replies		map[Cookie][]byte;
-	events		queue;
-	err		os.Error;
-	defaultScreen	int;
-	scratch		[32]byte;
-	Setup		SetupInfo;
+	conn          net.Conn
+	nextId        Id
+	nextCookie    Cookie
+	replies       map[Cookie][]byte
+	events        queue
+	err           os.Error
+	defaultScreen int
+	scratch       [32]byte
+	Setup         SetupInfo
 }
 
 // Id is used for all X identifiers, such as windows, pixmaps, and GCs.
@@ -44,11 +44,11 @@ type Event interface{}
 
 // Error contains protocol errors returned to us by the X server.
 type Error struct {
-	Detail	uint8;
-	Major	uint8;
-	Minor	uint16;
-	Cookie	Cookie;
-	Id	Id;
+	Detail uint8
+	Major  uint8
+	Minor  uint16
+	Cookie Cookie
+	Id     Id
 }
 
 func (e *Error) String() string {
@@ -58,81 +58,81 @@ func (e *Error) String() string {
 
 // NewID generates a new unused ID for use with requests like CreateWindow.
 func (c *Conn) NewId() Id {
-	id := c.nextId;
+	id := c.nextId
 	// TODO: handle ID overflow
-	c.nextId++;
-	return id;
+	c.nextId++
+	return id
 }
 
 // Pad a length to align on 4 bytes.
-func pad(n int) int	{ return (n + 3) & ^3 }
+func pad(n int) int { return (n + 3) & ^3 }
 
 func put16(buf []byte, v uint16) {
-	buf[0] = byte(v);
-	buf[1] = byte(v >> 8);
+	buf[0] = byte(v)
+	buf[1] = byte(v >> 8)
 }
 
 func put32(buf []byte, v uint32) {
-	buf[0] = byte(v);
-	buf[1] = byte(v >> 8);
-	buf[2] = byte(v >> 16);
-	buf[3] = byte(v >> 24);
+	buf[0] = byte(v)
+	buf[1] = byte(v >> 8)
+	buf[2] = byte(v >> 16)
+	buf[3] = byte(v >> 24)
 }
 
 func get16(buf []byte) uint16 {
-	v := uint16(buf[0]);
-	v |= uint16(buf[1]) << 8;
-	return v;
+	v := uint16(buf[0])
+	v |= uint16(buf[1]) << 8
+	return v
 }
 
 func get32(buf []byte) uint32 {
-	v := uint32(buf[0]);
-	v |= uint32(buf[1]) << 8;
-	v |= uint32(buf[2]) << 16;
-	v |= uint32(buf[3]) << 32;
-	return v;
+	v := uint32(buf[0])
+	v |= uint32(buf[1]) << 8
+	v |= uint32(buf[2]) << 16
+	v |= uint32(buf[3]) << 32
+	return v
 }
 
 // Voodoo to count the number of bits set in a value list mask.
 func popCount(mask0 int) int {
-	mask := uint32(mask0);
-	n := 0;
+	mask := uint32(mask0)
+	n := 0
 	for i := uint32(0); i < 32; i++ {
 		if mask&(1<<i) != 0 {
 			n++
 		}
 	}
-	return n;
+	return n
 }
 
 // A simple queue used to stow away events.
 type queue struct {
-	data	[][]byte;
-	a, b	int;
+	data [][]byte
+	a, b int
 }
 
 func (q *queue) queue(item []byte) {
 	if q.b == len(q.data) {
 		if q.a > 0 {
-			copy(q.data, q.data[q.a:q.b]);
-			q.a, q.b = 0, q.b-q.a;
+			copy(q.data, q.data[q.a:q.b])
+			q.a, q.b = 0, q.b-q.a
 		} else {
-			newData := make([][]byte, (len(q.data)*3)/2);
-			copy(newData, q.data);
-			q.data = newData;
+			newData := make([][]byte, (len(q.data)*3)/2)
+			copy(newData, q.data)
+			q.data = newData
 		}
 	}
-	q.data[q.b] = item;
-	q.b++;
+	q.data[q.b] = item
+	q.b++
 }
 
 func (q *queue) dequeue() []byte {
 	if q.a < q.b {
-		item := q.data[q.a];
-		q.a++;
-		return item;
+		item := q.data[q.a]
+		q.a++
+		return item
 	}
-	return nil;
+	return nil
 }
 
 // sendRequest sends a request to the server and return its associated sequence number, or cookie.
@@ -140,23 +140,23 @@ func (q *queue) dequeue() []byte {
 // to send any additional variable length data.
 func (c *Conn) sendRequest(buf []byte) Cookie {
 	if _, err := c.conn.Write(buf); err != nil {
-		fmt.Fprintf(os.Stderr, "x protocol write error: %s\n", err);
-		c.err = err;
+		fmt.Fprintf(os.Stderr, "x protocol write error: %s\n", err)
+		c.err = err
 	}
-	cookie := c.nextCookie;
-	c.nextCookie++;
-	return cookie;
+	cookie := c.nextCookie
+	c.nextCookie++
+	return cookie
 }
 
 // sendPadding sends enough bytes to align to a 4-byte border.
 // It is used to pad the variable length data that is used with some requests.
 func (c *Conn) sendPadding(n int) {
-	x := pad(n) - n;
+	x := pad(n) - n
 	if x > 0 {
-		_, err := c.conn.Write(c.scratch[0:x]);
+		_, err := c.conn.Write(c.scratch[0:x])
 		if err != nil {
-			fmt.Fprintf(os.Stderr, "x protocol write error: %s\n", err);
-			c.err = err;
+			fmt.Fprintf(os.Stderr, "x protocol write error: %s\n", err)
+			c.err = err
 		}
 	}
 }
@@ -165,37 +165,37 @@ func (c *Conn) sendPadding(n int) {
 // along with any necessary padding.
 func (c *Conn) sendBytes(buf []byte) {
 	if _, err := c.conn.Write(buf); err != nil {
-		fmt.Fprintf(os.Stderr, "x protocol write error: %s\n", err);
-		c.err = err;
+		fmt.Fprintf(os.Stderr, "x protocol write error: %s\n", err)
+		c.err = err
 	}
-	c.sendPadding(len(buf));
+	c.sendPadding(len(buf))
 }
 
-func (c *Conn) sendString(str string)	{ c.sendBytes(strings.Bytes(str)) }
+func (c *Conn) sendString(str string) { c.sendBytes(strings.Bytes(str)) }
 
 // sendUInt32s sends a list of 32-bit integers as variable length data.
 func (c *Conn) sendUInt32List(list []uint32) {
-	buf := make([]byte, len(list)*4);
+	buf := make([]byte, len(list)*4)
 	for i := 0; i < len(list); i++ {
 		put32(buf[i*4:], list[i])
 	}
-	c.sendBytes(buf);
+	c.sendBytes(buf)
 }
 
 func (c *Conn) sendIdList(list []Id, length int) {
-	buf := make([]byte, length*4);
+	buf := make([]byte, length*4)
 	for i := 0; i < length; i++ {
 		put32(buf[i*4:], uint32(list[i]))
 	}
-	c.sendBytes(buf);
+	c.sendBytes(buf)
 }
 
 func (c *Conn) sendKeysymList(list []Keysym, length int) {
-	buf := make([]byte, length*4);
+	buf := make([]byte, length*4)
 	for i := 0; i < length; i++ {
 		put32(buf[i*4:], uint32(list[i]))
 	}
-	c.sendBytes(buf);
+	c.sendBytes(buf)
 }
 
 // readNextReply reads and processes the next server reply.
@@ -203,10 +203,10 @@ func (c *Conn) sendKeysymList(list []Keysym, length int) {
 // Events are pushed onto the event queue and replies to requests
 // are stashed away in a map indexed by the sequence number.
 func (c *Conn) readNextReply() os.Error {
-	buf := make([]byte, 32);
+	buf := make([]byte, 32)
 	if _, err := io.ReadFull(c.conn, buf); err != nil {
-		fmt.Fprintf(os.Stderr, "x protocol read error: %s\n", err);
-		return err;
+		fmt.Fprintf(os.Stderr, "x protocol read error: %s\n", err)
+		return err
 	}
 
 	switch buf[0] {
@@ -217,21 +217,21 @@ func (c *Conn) readNextReply() os.Error {
 			Id: Id(get32(buf[4:])),
 			Minor: get16(buf[8:]),
 			Major: buf[10],
-		};
-		fmt.Fprintf(os.Stderr, "x protocol error: %s\n", err);
-		return err;
+		}
+		fmt.Fprintf(os.Stderr, "x protocol error: %s\n", err)
+		return err
 
 	case 1:
-		seq := Cookie(get16(buf[2:]));
-		size := get32(buf[4:]);
+		seq := Cookie(get16(buf[2:]))
+		size := get32(buf[4:])
 		if size > 0 {
-			bigbuf := make([]byte, 32+size*4, 32+size*4);
-			copy(bigbuf[0:32], buf);
+			bigbuf := make([]byte, 32+size*4, 32+size*4)
+			copy(bigbuf[0:32], buf)
 			if _, err := io.ReadFull(c.conn, bigbuf[32:]); err != nil {
-				fmt.Fprintf(os.Stderr, "x protocol read error: %s\n", err);
-				return err;
+				fmt.Fprintf(os.Stderr, "x protocol read error: %s\n", err)
+				return err
 			}
-			c.replies[seq] = bigbuf;
+			c.replies[seq] = bigbuf
 		} else {
 			c.replies[seq] = buf
 		}
@@ -240,7 +240,7 @@ func (c *Conn) readNextReply() os.Error {
 		c.events.queue(buf)
 	}
 
-	return nil;
+	return nil
 }
 
 // waitForReply looks for a reply in the map indexed by sequence number.
@@ -249,14 +249,14 @@ func (c *Conn) readNextReply() os.Error {
 func (c *Conn) waitForReply(cookie Cookie) ([]byte, os.Error) {
 	for {
 		if reply, ok := c.replies[cookie]; ok {
-			c.replies[cookie] = reply, false;
-			return reply, nil;
+			c.replies[cookie] = reply, false
+			return reply, nil
 		}
 		if err := c.readNextReply(); err != nil {
 			return nil, err
 		}
 	}
-	panic("unreachable");
+	panic("unreachable")
 }
 
 // WaitForEvent returns the next event from the server.
@@ -270,7 +270,7 @@ func (c *Conn) WaitForEvent() (Event, os.Error) {
 			return nil, err
 		}
 	}
-	panic("unreachable");
+	panic("unreachable")
 }
 
 // PollForEvent returns the next event from the server if one is available in the internal queue.
@@ -280,119 +280,119 @@ func (c *Conn) PollForEvent() (Event, os.Error) {
 	if reply := c.events.dequeue(); reply != nil {
 		return parseEvent(reply)
 	}
-	return nil, nil;
+	return nil, nil
 }
 
 // Dial connects to the X server given in the 'display' string.
 // The display string is typically taken from os.Getenv("DISPLAY").
 func Dial(display string) (*Conn, os.Error) {
-	var err os.Error;
+	var err os.Error
 
-	c := new(Conn);
+	c := new(Conn)
 
 	if display[0] == '/' {
-		c.conn, err = net.Dial("unix", "", display);
+		c.conn, err = net.Dial("unix", "", display)
 		if err != nil {
-			fmt.Printf("cannot connect: %v\n", err);
-			return nil, err;
+			fmt.Printf("cannot connect: %v\n", err)
+			return nil, err
 		}
 	} else {
-		parts := strings.Split(display, ":", 2);
-		host := parts[0];
-		port := 0;
+		parts := strings.Split(display, ":", 2)
+		host := parts[0]
+		port := 0
 		if len(parts) > 1 {
-			parts = strings.Split(parts[1], ".", 2);
-			port, _ = strconv.Atoi(parts[0]);
+			parts = strings.Split(parts[1], ".", 2)
+			port, _ = strconv.Atoi(parts[0])
 			if len(parts) > 1 {
 				c.defaultScreen, _ = strconv.Atoi(parts[1])
 			}
 		}
-		display = fmt.Sprintf("%s:%d", host, port+6000);
-		c.conn, err = net.Dial("tcp", "", display);
+		display = fmt.Sprintf("%s:%d", host, port+6000)
+		c.conn, err = net.Dial("tcp", "", display)
 		if err != nil {
-			fmt.Printf("cannot connect: %v\n", err);
-			return nil, err;
+			fmt.Printf("cannot connect: %v\n", err)
+			return nil, err
 		}
 	}
 
 	// TODO: get these from .Xauthority
-	var authName, authData []byte;
-
-	buf := make([]byte, 12+pad(len(authName))+pad(len(authData)));
-	buf[0] = 'l';
-	buf[1] = 0;
-	put16(buf[2:], 11);
-	put16(buf[4:], 0);
-	put16(buf[6:], uint16(len(authName)));
-	put16(buf[8:], uint16(len(authData)));
-	put16(buf[10:], 0);
-	copy(buf[12:], authName);
-	copy(buf[12+pad(len(authName)):], authData);
+	var authName, authData []byte
+
+	buf := make([]byte, 12+pad(len(authName))+pad(len(authData)))
+	buf[0] = 'l'
+	buf[1] = 0
+	put16(buf[2:], 11)
+	put16(buf[4:], 0)
+	put16(buf[6:], uint16(len(authName)))
+	put16(buf[8:], uint16(len(authData)))
+	put16(buf[10:], 0)
+	copy(buf[12:], authName)
+	copy(buf[12+pad(len(authName)):], authData)
 	if _, err = c.conn.Write(buf); err != nil {
 		return nil, err
 	}
 
-	head := make([]byte, 8);
+	head := make([]byte, 8)
 	if _, err = io.ReadFull(c.conn, head[0:8]); err != nil {
 		return nil, err
 	}
-	code := head[0];
-	reasonLen := head[1];
-	major := get16(head[2:]);
-	minor := get16(head[4:]);
-	dataLen := get16(head[6:]);
+	code := head[0]
+	reasonLen := head[1]
+	major := get16(head[2:])
+	minor := get16(head[4:])
+	dataLen := get16(head[6:])
 
 	if major != 11 || minor != 0 {
 		return nil, os.NewError(fmt.Sprintf("x protocol version mismatch: %d.%d", major, minor))
 	}
 
-	buf = make([]byte, int(dataLen)*4+8, int(dataLen)*4+8);
-	copy(buf, head);
+	buf = make([]byte, int(dataLen)*4+8, int(dataLen)*4+8)
+	copy(buf, head)
 	if _, err = io.ReadFull(c.conn, buf[8:]); err != nil {
 		return nil, err
 	}
 
 	if code == 0 {
-		reason := buf[8 : 8+reasonLen];
-		return nil, os.NewError(fmt.Sprintf("x protocol authentication refused: %s", string(reason)));
+		reason := buf[8 : 8+reasonLen]
+		return nil, os.NewError(fmt.Sprintf("x protocol authentication refused: %s", string(reason)))
 	}
 
-	getSetupInfo(buf, &c.Setup);
+	getSetupInfo(buf, &c.Setup)
 
 	if c.defaultScreen >= len(c.Setup.Roots) {
 		c.defaultScreen = 0
 	}
 
-	c.nextId = Id(c.Setup.ResourceIdBase);
-	c.nextCookie = 1;
-	c.replies = make(map[Cookie][]byte);
-	c.events = queue{make([][]byte, 100), 0, 0};
-	return c, nil;
+	c.nextId = Id(c.Setup.ResourceIdBase)
+	c.nextCookie = 1
+	c.replies = make(map[Cookie][]byte)
+	c.events = queue{make([][]byte, 100), 0, 0}
+	return c, nil
 }
 
 // Close closes the connection to the X server.
-func (c *Conn) Close()	{ c.conn.Close() }
+func (c *Conn) Close() { c.conn.Close() }
 
 // DefaultScreen returns the Screen info for the default screen, which is
 // 0 or the one given in the display argument to Dial.
-func (c *Conn) DefaultScreen() *ScreenInfo	{ return &c.Setup.Roots[c.defaultScreen] }
+func (c *Conn) DefaultScreen() *ScreenInfo { return &c.Setup.Roots[c.defaultScreen] }
 
 
 // ClientMessageData holds the data from a client message,
 // duplicated in three forms because Go doesn't have unions.
 type ClientMessageData struct {
-	Data8	[20]byte;
-	Data16	[10]uint16;
-	Data32	[5]uint32;
+	Data8  [20]byte
+	Data16 [10]uint16
+	Data32 [5]uint32
 }
 
 func getClientMessageData(b []byte, v *ClientMessageData) int {
-	copy(&v.Data8, b);
+	copy(&v.Data8, b)
 	for i := 0; i < 10; i++ {
 		v.Data16[i] = get16(b[i*2:])
 	}
 	for i := 0; i < 5; i++ {
 		v.Data32[i] = get32(b[i*4:])
 	}
-	return 20;
+	return 20
 }
diff --git a/src/pkg/xgb/xproto.go b/src/pkg/xgb/xproto.go
index 487fc66d7c..154a6573c4 100644
--- a/src/pkg/xgb/xproto.go
+++ b/src/pkg/xgb/xproto.go
@@ -5,374 +5,374 @@ package xgb
 import "os"
 
 type Char2b struct {
-	Byte1	byte;
-	Byte2	byte;
+	Byte1 byte
+	Byte2 byte
 }
 
 func getChar2b(b []byte, v *Char2b) int {
-	v.Byte1 = b[0];
-	v.Byte2 = b[1];
-	return 2;
+	v.Byte1 = b[0]
+	v.Byte2 = b[1]
+	return 2
 }
 
 func (c *Conn) sendChar2bList(list []Char2b, count int) {
-	b0 := make([]byte, 2*count);
+	b0 := make([]byte, 2*count)
 	for k := 0; k < count; k++ {
-		b := b0[k*2:];
-		b[0] = list[k].Byte1;
-		b[1] = list[k].Byte2;
+		b := b0[k*2:]
+		b[0] = list[k].Byte1
+		b[1] = list[k].Byte2
 	}
-	c.sendBytes(b0);
+	c.sendBytes(b0)
 }
 
 type Point struct {
-	X	int16;
-	Y	int16;
+	X int16
+	Y int16
 }
 
 func getPoint(b []byte, v *Point) int {
-	v.X = int16(get16(b[0:]));
-	v.Y = int16(get16(b[2:]));
-	return 4;
+	v.X = int16(get16(b[0:]))
+	v.Y = int16(get16(b[2:]))
+	return 4
 }
 
 func (c *Conn) sendPointList(list []Point, count int) {
-	b0 := make([]byte, 4*count);
+	b0 := make([]byte, 4*count)
 	for k := 0; k < count; k++ {
-		b := b0[k*4:];
-		put16(b[0:], uint16(list[k].X));
-		put16(b[2:], uint16(list[k].Y));
+		b := b0[k*4:]
+		put16(b[0:], uint16(list[k].X))
+		put16(b[2:], uint16(list[k].Y))
 	}
-	c.sendBytes(b0);
+	c.sendBytes(b0)
 }
 
 type Rectangle struct {
-	X	int16;
-	Y	int16;
-	Width	uint16;
-	Height	uint16;
+	X      int16
+	Y      int16
+	Width  uint16
+	Height uint16
 }
 
 func getRectangle(b []byte, v *Rectangle) int {
-	v.X = int16(get16(b[0:]));
-	v.Y = int16(get16(b[2:]));
-	v.Width = get16(b[4:]);
-	v.Height = get16(b[6:]);
-	return 8;
+	v.X = int16(get16(b[0:]))
+	v.Y = int16(get16(b[2:]))
+	v.Width = get16(b[4:])
+	v.Height = get16(b[6:])
+	return 8
 }
 
 func (c *Conn) sendRectangleList(list []Rectangle, count int) {
-	b0 := make([]byte, 8*count);
+	b0 := make([]byte, 8*count)
 	for k := 0; k < count; k++ {
-		b := b0[k*8:];
-		put16(b[0:], uint16(list[k].X));
-		put16(b[2:], uint16(list[k].Y));
-		put16(b[4:], list[k].Width);
-		put16(b[6:], list[k].Height);
+		b := b0[k*8:]
+		put16(b[0:], uint16(list[k].X))
+		put16(b[2:], uint16(list[k].Y))
+		put16(b[4:], list[k].Width)
+		put16(b[6:], list[k].Height)
 	}
-	c.sendBytes(b0);
+	c.sendBytes(b0)
 }
 
 type Arc struct {
-	X	int16;
-	Y	int16;
-	Width	uint16;
-	Height	uint16;
-	Angle1	int16;
-	Angle2	int16;
+	X      int16
+	Y      int16
+	Width  uint16
+	Height uint16
+	Angle1 int16
+	Angle2 int16
 }
 
 func getArc(b []byte, v *Arc) int {
-	v.X = int16(get16(b[0:]));
-	v.Y = int16(get16(b[2:]));
-	v.Width = get16(b[4:]);
-	v.Height = get16(b[6:]);
-	v.Angle1 = int16(get16(b[8:]));
-	v.Angle2 = int16(get16(b[10:]));
-	return 12;
+	v.X = int16(get16(b[0:]))
+	v.Y = int16(get16(b[2:]))
+	v.Width = get16(b[4:])
+	v.Height = get16(b[6:])
+	v.Angle1 = int16(get16(b[8:]))
+	v.Angle2 = int16(get16(b[10:]))
+	return 12
 }
 
 func (c *Conn) sendArcList(list []Arc, count int) {
-	b0 := make([]byte, 12*count);
+	b0 := make([]byte, 12*count)
 	for k := 0; k < count; k++ {
-		b := b0[k*12:];
-		put16(b[0:], uint16(list[k].X));
-		put16(b[2:], uint16(list[k].Y));
-		put16(b[4:], list[k].Width);
-		put16(b[6:], list[k].Height);
-		put16(b[8:], uint16(list[k].Angle1));
-		put16(b[10:], uint16(list[k].Angle2));
+		b := b0[k*12:]
+		put16(b[0:], uint16(list[k].X))
+		put16(b[2:], uint16(list[k].Y))
+		put16(b[4:], list[k].Width)
+		put16(b[6:], list[k].Height)
+		put16(b[8:], uint16(list[k].Angle1))
+		put16(b[10:], uint16(list[k].Angle2))
 	}
-	c.sendBytes(b0);
+	c.sendBytes(b0)
 }
 
 type Format struct {
-	Depth		byte;
-	BitsPerPixel	byte;
-	ScanlinePad	byte;
+	Depth        byte
+	BitsPerPixel byte
+	ScanlinePad  byte
 }
 
 func getFormat(b []byte, v *Format) int {
-	v.Depth = b[0];
-	v.BitsPerPixel = b[1];
-	v.ScanlinePad = b[2];
-	return 8;
+	v.Depth = b[0]
+	v.BitsPerPixel = b[1]
+	v.ScanlinePad = b[2]
+	return 8
 }
 
 const (
-	VisualClassStaticGray	= 0;
-	VisualClassGrayScale	= 1;
-	VisualClassStaticColor	= 2;
-	VisualClassPseudoColor	= 3;
-	VisualClassTrueColor	= 4;
-	VisualClassDirectColor	= 5;
+	VisualClassStaticGray  = 0
+	VisualClassGrayScale   = 1
+	VisualClassStaticColor = 2
+	VisualClassPseudoColor = 3
+	VisualClassTrueColor   = 4
+	VisualClassDirectColor = 5
 )
 
 type VisualInfo struct {
-	VisualId	Id;
-	Class		byte;
-	BitsPerRgbValue	byte;
-	ColormapEntries	uint16;
-	RedMask		uint32;
-	GreenMask	uint32;
-	BlueMask	uint32;
+	VisualId        Id
+	Class           byte
+	BitsPerRgbValue byte
+	ColormapEntries uint16
+	RedMask         uint32
+	GreenMask       uint32
+	BlueMask        uint32
 }
 
 func getVisualInfo(b []byte, v *VisualInfo) int {
-	v.VisualId = Id(get32(b[0:]));
-	v.Class = b[4];
-	v.BitsPerRgbValue = b[5];
-	v.ColormapEntries = get16(b[6:]);
-	v.RedMask = get32(b[8:]);
-	v.GreenMask = get32(b[12:]);
-	v.BlueMask = get32(b[16:]);
-	return 24;
+	v.VisualId = Id(get32(b[0:]))
+	v.Class = b[4]
+	v.BitsPerRgbValue = b[5]
+	v.ColormapEntries = get16(b[6:])
+	v.RedMask = get32(b[8:])
+	v.GreenMask = get32(b[12:])
+	v.BlueMask = get32(b[16:])
+	return 24
 }
 
 type DepthInfo struct {
-	Depth		byte;
-	VisualsLen	uint16;
-	Visuals		[]VisualInfo;
+	Depth      byte
+	VisualsLen uint16
+	Visuals    []VisualInfo
 }
 
 func getDepthInfo(b []byte, v *DepthInfo) int {
-	v.Depth = b[0];
-	v.VisualsLen = get16(b[2:]);
-	offset := 8;
-	v.Visuals = make([]VisualInfo, int(v.VisualsLen));
+	v.Depth = b[0]
+	v.VisualsLen = get16(b[2:])
+	offset := 8
+	v.Visuals = make([]VisualInfo, int(v.VisualsLen))
 	for i := 0; i < int(v.VisualsLen); i++ {
 		offset += getVisualInfo(b[offset:], &v.Visuals[i])
 	}
-	return offset;
+	return offset
 }
 
 const (
-	EventMaskNoEvent		= 0;
-	EventMaskKeyPress		= 1;
-	EventMaskKeyRelease		= 2;
-	EventMaskButtonPress		= 4;
-	EventMaskButtonRelease		= 8;
-	EventMaskEnterWindow		= 16;
-	EventMaskLeaveWindow		= 32;
-	EventMaskPointerMotion		= 64;
-	EventMaskPointerMotionHint	= 128;
-	EventMaskButton1Motion		= 256;
-	EventMaskButton2Motion		= 512;
-	EventMaskButton3Motion		= 1024;
-	EventMaskButton4Motion		= 2048;
-	EventMaskButton5Motion		= 4096;
-	EventMaskButtonMotion		= 8192;
-	EventMaskKeymapState		= 16384;
-	EventMaskExposure		= 32768;
-	EventMaskVisibilityChange	= 65536;
-	EventMaskStructureNotify	= 131072;
-	EventMaskResizeRedirect		= 262144;
-	EventMaskSubstructureNotify	= 524288;
-	EventMaskSubstructureRedirect	= 1048576;
-	EventMaskFocusChange		= 2097152;
-	EventMaskPropertyChange		= 4194304;
-	EventMaskColorMapChange		= 8388608;
-	EventMaskOwnerGrabButton	= 16777216;
+	EventMaskNoEvent              = 0
+	EventMaskKeyPress             = 1
+	EventMaskKeyRelease           = 2
+	EventMaskButtonPress          = 4
+	EventMaskButtonRelease        = 8
+	EventMaskEnterWindow          = 16
+	EventMaskLeaveWindow          = 32
+	EventMaskPointerMotion        = 64
+	EventMaskPointerMotionHint    = 128
+	EventMaskButton1Motion        = 256
+	EventMaskButton2Motion        = 512
+	EventMaskButton3Motion        = 1024
+	EventMaskButton4Motion        = 2048
+	EventMaskButton5Motion        = 4096
+	EventMaskButtonMotion         = 8192
+	EventMaskKeymapState          = 16384
+	EventMaskExposure             = 32768
+	EventMaskVisibilityChange     = 65536
+	EventMaskStructureNotify      = 131072
+	EventMaskResizeRedirect       = 262144
+	EventMaskSubstructureNotify   = 524288
+	EventMaskSubstructureRedirect = 1048576
+	EventMaskFocusChange          = 2097152
+	EventMaskPropertyChange       = 4194304
+	EventMaskColorMapChange       = 8388608
+	EventMaskOwnerGrabButton      = 16777216
 )
 
 const (
-	BackingStoreNotUseful	= 0;
-	BackingStoreWhenMapped	= 1;
-	BackingStoreAlways	= 2;
+	BackingStoreNotUseful  = 0
+	BackingStoreWhenMapped = 1
+	BackingStoreAlways     = 2
 )
 
 type ScreenInfo struct {
-	Root			Id;
-	DefaultColormap		Id;
-	WhitePixel		uint32;
-	BlackPixel		uint32;
-	CurrentInputMasks	uint32;
-	WidthInPixels		uint16;
-	HeightInPixels		uint16;
-	WidthInMillimeters	uint16;
-	HeightInMillimeters	uint16;
-	MinInstalledMaps	uint16;
-	MaxInstalledMaps	uint16;
-	RootVisual		Id;
-	BackingStores		byte;
-	SaveUnders		byte;
-	RootDepth		byte;
-	AllowedDepthsLen	byte;
-	AllowedDepths		[]DepthInfo;
+	Root                Id
+	DefaultColormap     Id
+	WhitePixel          uint32
+	BlackPixel          uint32
+	CurrentInputMasks   uint32
+	WidthInPixels       uint16
+	HeightInPixels      uint16
+	WidthInMillimeters  uint16
+	HeightInMillimeters uint16
+	MinInstalledMaps    uint16
+	MaxInstalledMaps    uint16
+	RootVisual          Id
+	BackingStores       byte
+	SaveUnders          byte
+	RootDepth           byte
+	AllowedDepthsLen    byte
+	AllowedDepths       []DepthInfo
 }
 
 func getScreenInfo(b []byte, v *ScreenInfo) int {
-	v.Root = Id(get32(b[0:]));
-	v.DefaultColormap = Id(get32(b[4:]));
-	v.WhitePixel = get32(b[8:]);
-	v.BlackPixel = get32(b[12:]);
-	v.CurrentInputMasks = get32(b[16:]);
-	v.WidthInPixels = get16(b[20:]);
-	v.HeightInPixels = get16(b[22:]);
-	v.WidthInMillimeters = get16(b[24:]);
-	v.HeightInMillimeters = get16(b[26:]);
-	v.MinInstalledMaps = get16(b[28:]);
-	v.MaxInstalledMaps = get16(b[30:]);
-	v.RootVisual = Id(get32(b[32:]));
-	v.BackingStores = b[36];
-	v.SaveUnders = b[37];
-	v.RootDepth = b[38];
-	v.AllowedDepthsLen = b[39];
-	offset := 40;
-	v.AllowedDepths = make([]DepthInfo, int(v.AllowedDepthsLen));
+	v.Root = Id(get32(b[0:]))
+	v.DefaultColormap = Id(get32(b[4:]))
+	v.WhitePixel = get32(b[8:])
+	v.BlackPixel = get32(b[12:])
+	v.CurrentInputMasks = get32(b[16:])
+	v.WidthInPixels = get16(b[20:])
+	v.HeightInPixels = get16(b[22:])
+	v.WidthInMillimeters = get16(b[24:])
+	v.HeightInMillimeters = get16(b[26:])
+	v.MinInstalledMaps = get16(b[28:])
+	v.MaxInstalledMaps = get16(b[30:])
+	v.RootVisual = Id(get32(b[32:]))
+	v.BackingStores = b[36]
+	v.SaveUnders = b[37]
+	v.RootDepth = b[38]
+	v.AllowedDepthsLen = b[39]
+	offset := 40
+	v.AllowedDepths = make([]DepthInfo, int(v.AllowedDepthsLen))
 	for i := 0; i < int(v.AllowedDepthsLen); i++ {
 		offset += getDepthInfo(b[offset:], &v.AllowedDepths[i])
 	}
-	return offset;
+	return offset
 }
 
 const (
-	ImageOrderLSBFirst	= 0;
-	ImageOrderMSBFirst	= 1;
+	ImageOrderLSBFirst = 0
+	ImageOrderMSBFirst = 1
 )
 
 type SetupInfo struct {
-	Status				byte;
-	ProtocolMajorVersion		uint16;
-	ProtocolMinorVersion		uint16;
-	Length				uint16;
-	ReleaseNumber			uint32;
-	ResourceIdBase			uint32;
-	ResourceIdMask			uint32;
-	MotionBufferSize		uint32;
-	VendorLen			uint16;
-	MaximumRequestLength		uint16;
-	RootsLen			byte;
-	PixmapFormatsLen		byte;
-	ImageByteOrder			byte;
-	BitmapFormatBitOrder		byte;
-	BitmapFormatScanlineUnit	byte;
-	BitmapFormatScanlinePad		byte;
-	MinKeycode			byte;
-	MaxKeycode			byte;
-	Vendor				[]byte;
-	PixmapFormats			[]Format;
-	Roots				[]ScreenInfo;
+	Status                   byte
+	ProtocolMajorVersion     uint16
+	ProtocolMinorVersion     uint16
+	Length                   uint16
+	ReleaseNumber            uint32
+	ResourceIdBase           uint32
+	ResourceIdMask           uint32
+	MotionBufferSize         uint32
+	VendorLen                uint16
+	MaximumRequestLength     uint16
+	RootsLen                 byte
+	PixmapFormatsLen         byte
+	ImageByteOrder           byte
+	BitmapFormatBitOrder     byte
+	BitmapFormatScanlineUnit byte
+	BitmapFormatScanlinePad  byte
+	MinKeycode               byte
+	MaxKeycode               byte
+	Vendor                   []byte
+	PixmapFormats            []Format
+	Roots                    []ScreenInfo
 }
 
 func getSetupInfo(b []byte, v *SetupInfo) int {
-	v.Status = b[0];
-	v.ProtocolMajorVersion = get16(b[2:]);
-	v.ProtocolMinorVersion = get16(b[4:]);
-	v.Length = get16(b[6:]);
-	v.ReleaseNumber = get32(b[8:]);
-	v.ResourceIdBase = get32(b[12:]);
-	v.ResourceIdMask = get32(b[16:]);
-	v.MotionBufferSize = get32(b[20:]);
-	v.VendorLen = get16(b[24:]);
-	v.MaximumRequestLength = get16(b[26:]);
-	v.RootsLen = b[28];
-	v.PixmapFormatsLen = b[29];
-	v.ImageByteOrder = b[30];
-	v.BitmapFormatBitOrder = b[31];
-	v.BitmapFormatScanlineUnit = b[32];
-	v.BitmapFormatScanlinePad = b[33];
-	v.MinKeycode = b[34];
-	v.MaxKeycode = b[35];
-	offset := 40;
-	v.Vendor = make([]byte, int(v.VendorLen));
-	copy(v.Vendor[0:len(v.Vendor)], b[offset:]);
-	offset += len(v.Vendor) * 1;
-	offset = pad(offset);
-	v.PixmapFormats = make([]Format, int(v.PixmapFormatsLen));
+	v.Status = b[0]
+	v.ProtocolMajorVersion = get16(b[2:])
+	v.ProtocolMinorVersion = get16(b[4:])
+	v.Length = get16(b[6:])
+	v.ReleaseNumber = get32(b[8:])
+	v.ResourceIdBase = get32(b[12:])
+	v.ResourceIdMask = get32(b[16:])
+	v.MotionBufferSize = get32(b[20:])
+	v.VendorLen = get16(b[24:])
+	v.MaximumRequestLength = get16(b[26:])
+	v.RootsLen = b[28]
+	v.PixmapFormatsLen = b[29]
+	v.ImageByteOrder = b[30]
+	v.BitmapFormatBitOrder = b[31]
+	v.BitmapFormatScanlineUnit = b[32]
+	v.BitmapFormatScanlinePad = b[33]
+	v.MinKeycode = b[34]
+	v.MaxKeycode = b[35]
+	offset := 40
+	v.Vendor = make([]byte, int(v.VendorLen))
+	copy(v.Vendor[0:len(v.Vendor)], b[offset:])
+	offset += len(v.Vendor) * 1
+	offset = pad(offset)
+	v.PixmapFormats = make([]Format, int(v.PixmapFormatsLen))
 	for i := 0; i < int(v.PixmapFormatsLen); i++ {
 		offset += getFormat(b[offset:], &v.PixmapFormats[i])
 	}
-	offset = pad(offset);
-	v.Roots = make([]ScreenInfo, int(v.RootsLen));
+	offset = pad(offset)
+	v.Roots = make([]ScreenInfo, int(v.RootsLen))
 	for i := 0; i < int(v.RootsLen); i++ {
 		offset += getScreenInfo(b[offset:], &v.Roots[i])
 	}
-	return offset;
+	return offset
 }
 
 const (
-	ModMaskShift	= 1;
-	ModMaskLock	= 2;
-	ModMaskControl	= 4;
-	ModMask1	= 8;
-	ModMask2	= 16;
-	ModMask3	= 32;
-	ModMask4	= 64;
-	ModMask5	= 128;
-	ModMaskAny	= 32768;
+	ModMaskShift   = 1
+	ModMaskLock    = 2
+	ModMaskControl = 4
+	ModMask1       = 8
+	ModMask2       = 16
+	ModMask3       = 32
+	ModMask4       = 64
+	ModMask5       = 128
+	ModMaskAny     = 32768
 )
 
 const (
-	KeyButMaskShift		= 1;
-	KeyButMaskLock		= 2;
-	KeyButMaskControl	= 4;
-	KeyButMaskMod1		= 8;
-	KeyButMaskMod2		= 16;
-	KeyButMaskMod3		= 32;
-	KeyButMaskMod4		= 64;
-	KeyButMaskMod5		= 128;
-	KeyButMaskButton1	= 256;
-	KeyButMaskButton2	= 512;
-	KeyButMaskButton3	= 1024;
-	KeyButMaskButton4	= 2048;
-	KeyButMaskButton5	= 4096;
+	KeyButMaskShift   = 1
+	KeyButMaskLock    = 2
+	KeyButMaskControl = 4
+	KeyButMaskMod1    = 8
+	KeyButMaskMod2    = 16
+	KeyButMaskMod3    = 32
+	KeyButMaskMod4    = 64
+	KeyButMaskMod5    = 128
+	KeyButMaskButton1 = 256
+	KeyButMaskButton2 = 512
+	KeyButMaskButton3 = 1024
+	KeyButMaskButton4 = 2048
+	KeyButMaskButton5 = 4096
 )
 
 const (
-	WindowNone = 0;
+	WindowNone = 0
 )
 
 const KeyPress = 2
 
 type KeyPressEvent struct {
-	Detail		byte;
-	Time		Timestamp;
-	Root		Id;
-	Event		Id;
-	Child		Id;
-	RootX		int16;
-	RootY		int16;
-	EventX		int16;
-	EventY		int16;
-	State		uint16;
-	SameScreen	byte;
+	Detail     byte
+	Time       Timestamp
+	Root       Id
+	Event      Id
+	Child      Id
+	RootX      int16
+	RootY      int16
+	EventX     int16
+	EventY     int16
+	State      uint16
+	SameScreen byte
 }
 
 func getKeyPressEvent(b []byte) KeyPressEvent {
-	var v KeyPressEvent;
-	v.Detail = b[1];
-	v.Time = Timestamp(get32(b[4:]));
-	v.Root = Id(get32(b[8:]));
-	v.Event = Id(get32(b[12:]));
-	v.Child = Id(get32(b[16:]));
-	v.RootX = int16(get16(b[20:]));
-	v.RootY = int16(get16(b[22:]));
-	v.EventX = int16(get16(b[24:]));
-	v.EventY = int16(get16(b[26:]));
-	v.State = get16(b[28:]);
-	v.SameScreen = b[30];
-	return v;
+	var v KeyPressEvent
+	v.Detail = b[1]
+	v.Time = Timestamp(get32(b[4:]))
+	v.Root = Id(get32(b[8:]))
+	v.Event = Id(get32(b[12:]))
+	v.Child = Id(get32(b[16:]))
+	v.RootX = int16(get16(b[20:]))
+	v.RootY = int16(get16(b[22:]))
+	v.EventX = int16(get16(b[24:]))
+	v.EventY = int16(get16(b[26:]))
+	v.State = get16(b[28:])
+	v.SameScreen = b[30]
+	return v
 }
 
 const KeyRelease = 3
@@ -384,44 +384,44 @@ func getKeyReleaseEvent(b []byte) KeyReleaseEvent {
 }
 
 const (
-	ButtonMask1	= 256;
-	ButtonMask2	= 512;
-	ButtonMask3	= 1024;
-	ButtonMask4	= 2048;
-	ButtonMask5	= 4096;
-	ButtonMaskAny	= 32768;
+	ButtonMask1   = 256
+	ButtonMask2   = 512
+	ButtonMask3   = 1024
+	ButtonMask4   = 2048
+	ButtonMask5   = 4096
+	ButtonMaskAny = 32768
 )
 
 const ButtonPress = 4
 
 type ButtonPressEvent struct {
-	Detail		byte;
-	Time		Timestamp;
-	Root		Id;
-	Event		Id;
-	Child		Id;
-	RootX		int16;
-	RootY		int16;
-	EventX		int16;
-	EventY		int16;
-	State		uint16;
-	SameScreen	byte;
+	Detail     byte
+	Time       Timestamp
+	Root       Id
+	Event      Id
+	Child      Id
+	RootX      int16
+	RootY      int16
+	EventX     int16
+	EventY     int16
+	State      uint16
+	SameScreen byte
 }
 
 func getButtonPressEvent(b []byte) ButtonPressEvent {
-	var v ButtonPressEvent;
-	v.Detail = b[1];
-	v.Time = Timestamp(get32(b[4:]));
-	v.Root = Id(get32(b[8:]));
-	v.Event = Id(get32(b[12:]));
-	v.Child = Id(get32(b[16:]));
-	v.RootX = int16(get16(b[20:]));
-	v.RootY = int16(get16(b[22:]));
-	v.EventX = int16(get16(b[24:]));
-	v.EventY = int16(get16(b[26:]));
-	v.State = get16(b[28:]);
-	v.SameScreen = b[30];
-	return v;
+	var v ButtonPressEvent
+	v.Detail = b[1]
+	v.Time = Timestamp(get32(b[4:]))
+	v.Root = Id(get32(b[8:]))
+	v.Event = Id(get32(b[12:]))
+	v.Child = Id(get32(b[16:]))
+	v.RootX = int16(get16(b[20:]))
+	v.RootY = int16(get16(b[22:]))
+	v.EventX = int16(get16(b[24:]))
+	v.EventY = int16(get16(b[26:]))
+	v.State = get16(b[28:])
+	v.SameScreen = b[30]
+	return v
 }
 
 const ButtonRelease = 5
@@ -433,92 +433,92 @@ func getButtonReleaseEvent(b []byte) ButtonReleaseEvent {
 }
 
 const (
-	MotionNormal	= 0;
-	MotionHint	= 1;
+	MotionNormal = 0
+	MotionHint   = 1
 )
 
 const MotionNotify = 6
 
 type MotionNotifyEvent struct {
-	Detail		byte;
-	Time		Timestamp;
-	Root		Id;
-	Event		Id;
-	Child		Id;
-	RootX		int16;
-	RootY		int16;
-	EventX		int16;
-	EventY		int16;
-	State		uint16;
-	SameScreen	byte;
+	Detail     byte
+	Time       Timestamp
+	Root       Id
+	Event      Id
+	Child      Id
+	RootX      int16
+	RootY      int16
+	EventX     int16
+	EventY     int16
+	State      uint16
+	SameScreen byte
 }
 
 func getMotionNotifyEvent(b []byte) MotionNotifyEvent {
-	var v MotionNotifyEvent;
-	v.Detail = b[1];
-	v.Time = Timestamp(get32(b[4:]));
-	v.Root = Id(get32(b[8:]));
-	v.Event = Id(get32(b[12:]));
-	v.Child = Id(get32(b[16:]));
-	v.RootX = int16(get16(b[20:]));
-	v.RootY = int16(get16(b[22:]));
-	v.EventX = int16(get16(b[24:]));
-	v.EventY = int16(get16(b[26:]));
-	v.State = get16(b[28:]);
-	v.SameScreen = b[30];
-	return v;
+	var v MotionNotifyEvent
+	v.Detail = b[1]
+	v.Time = Timestamp(get32(b[4:]))
+	v.Root = Id(get32(b[8:]))
+	v.Event = Id(get32(b[12:]))
+	v.Child = Id(get32(b[16:]))
+	v.RootX = int16(get16(b[20:]))
+	v.RootY = int16(get16(b[22:]))
+	v.EventX = int16(get16(b[24:]))
+	v.EventY = int16(get16(b[26:]))
+	v.State = get16(b[28:])
+	v.SameScreen = b[30]
+	return v
 }
 
 const (
-	NotifyDetailAncestor		= 0;
-	NotifyDetailVirtual		= 1;
-	NotifyDetailInferior		= 2;
-	NotifyDetailNonlinear		= 3;
-	NotifyDetailNonlinearVirtual	= 4;
-	NotifyDetailPointer		= 5;
-	NotifyDetailPointerRoot		= 6;
-	NotifyDetailNone		= 7;
+	NotifyDetailAncestor         = 0
+	NotifyDetailVirtual          = 1
+	NotifyDetailInferior         = 2
+	NotifyDetailNonlinear        = 3
+	NotifyDetailNonlinearVirtual = 4
+	NotifyDetailPointer          = 5
+	NotifyDetailPointerRoot      = 6
+	NotifyDetailNone             = 7
 )
 
 const (
-	NotifyModeNormal	= 0;
-	NotifyModeGrab		= 1;
-	NotifyModeUngrab	= 2;
-	NotifyModeWhileGrabbed	= 3;
+	NotifyModeNormal       = 0
+	NotifyModeGrab         = 1
+	NotifyModeUngrab       = 2
+	NotifyModeWhileGrabbed = 3
 )
 
 const EnterNotify = 7
 
 type EnterNotifyEvent struct {
-	Detail		byte;
-	Time		Timestamp;
-	Root		Id;
-	Event		Id;
-	Child		Id;
-	RootX		int16;
-	RootY		int16;
-	EventX		int16;
-	EventY		int16;
-	State		uint16;
-	Mode		byte;
-	SameScreenFocus	byte;
+	Detail          byte
+	Time            Timestamp
+	Root            Id
+	Event           Id
+	Child           Id
+	RootX           int16
+	RootY           int16
+	EventX          int16
+	EventY          int16
+	State           uint16
+	Mode            byte
+	SameScreenFocus byte
 }
 
 func getEnterNotifyEvent(b []byte) EnterNotifyEvent {
-	var v EnterNotifyEvent;
-	v.Detail = b[1];
-	v.Time = Timestamp(get32(b[4:]));
-	v.Root = Id(get32(b[8:]));
-	v.Event = Id(get32(b[12:]));
-	v.Child = Id(get32(b[16:]));
-	v.RootX = int16(get16(b[20:]));
-	v.RootY = int16(get16(b[22:]));
-	v.EventX = int16(get16(b[24:]));
-	v.EventY = int16(get16(b[26:]));
-	v.State = get16(b[28:]);
-	v.Mode = b[30];
-	v.SameScreenFocus = b[31];
-	return v;
+	var v EnterNotifyEvent
+	v.Detail = b[1]
+	v.Time = Timestamp(get32(b[4:]))
+	v.Root = Id(get32(b[8:]))
+	v.Event = Id(get32(b[12:]))
+	v.Child = Id(get32(b[16:]))
+	v.RootX = int16(get16(b[20:]))
+	v.RootY = int16(get16(b[22:]))
+	v.EventX = int16(get16(b[24:]))
+	v.EventY = int16(get16(b[26:]))
+	v.State = get16(b[28:])
+	v.Mode = b[30]
+	v.SameScreenFocus = b[31]
+	return v
 }
 
 const LeaveNotify = 8
@@ -532,340 +532,340 @@ func getLeaveNotifyEvent(b []byte) LeaveNotifyEvent {
 const FocusIn = 9
 
 type FocusInEvent struct {
-	Detail	byte;
-	Event	Id;
-	Mode	byte;
+	Detail byte
+	Event  Id
+	Mode   byte
 }
 
 func getFocusInEvent(b []byte) FocusInEvent {
-	var v FocusInEvent;
-	v.Detail = b[1];
-	v.Event = Id(get32(b[4:]));
-	v.Mode = b[8];
-	return v;
+	var v FocusInEvent
+	v.Detail = b[1]
+	v.Event = Id(get32(b[4:]))
+	v.Mode = b[8]
+	return v
 }
 
 const FocusOut = 10
 
 type FocusOutEvent FocusInEvent
 
-func getFocusOutEvent(b []byte) FocusOutEvent	{ return (FocusOutEvent)(getFocusInEvent(b)) }
+func getFocusOutEvent(b []byte) FocusOutEvent { return (FocusOutEvent)(getFocusInEvent(b)) }
 
 const KeymapNotify = 11
 
 type KeymapNotifyEvent struct {
-	Keys [31]byte;
+	Keys [31]byte
 }
 
 func getKeymapNotifyEvent(b []byte) KeymapNotifyEvent {
-	var v KeymapNotifyEvent;
-	copy(v.Keys[0:31], b[1:]);
-	return v;
+	var v KeymapNotifyEvent
+	copy(v.Keys[0:31], b[1:])
+	return v
 }
 
 const Expose = 12
 
 type ExposeEvent struct {
-	Window	Id;
-	X	uint16;
-	Y	uint16;
-	Width	uint16;
-	Height	uint16;
-	Count	uint16;
+	Window Id
+	X      uint16
+	Y      uint16
+	Width  uint16
+	Height uint16
+	Count  uint16
 }
 
 func getExposeEvent(b []byte) ExposeEvent {
-	var v ExposeEvent;
-	v.Window = Id(get32(b[4:]));
-	v.X = get16(b[8:]);
-	v.Y = get16(b[10:]);
-	v.Width = get16(b[12:]);
-	v.Height = get16(b[14:]);
-	v.Count = get16(b[16:]);
-	return v;
+	var v ExposeEvent
+	v.Window = Id(get32(b[4:]))
+	v.X = get16(b[8:])
+	v.Y = get16(b[10:])
+	v.Width = get16(b[12:])
+	v.Height = get16(b[14:])
+	v.Count = get16(b[16:])
+	return v
 }
 
 const GraphicsExposure = 13
 
 type GraphicsExposureEvent struct {
-	Drawable	Id;
-	X		uint16;
-	Y		uint16;
-	Width		uint16;
-	Height		uint16;
-	MinorOpcode	uint16;
-	Count		uint16;
-	MajorOpcode	byte;
+	Drawable    Id
+	X           uint16
+	Y           uint16
+	Width       uint16
+	Height      uint16
+	MinorOpcode uint16
+	Count       uint16
+	MajorOpcode byte
 }
 
 func getGraphicsExposureEvent(b []byte) GraphicsExposureEvent {
-	var v GraphicsExposureEvent;
-	v.Drawable = Id(get32(b[4:]));
-	v.X = get16(b[8:]);
-	v.Y = get16(b[10:]);
-	v.Width = get16(b[12:]);
-	v.Height = get16(b[14:]);
-	v.MinorOpcode = get16(b[16:]);
-	v.Count = get16(b[18:]);
-	v.MajorOpcode = b[20];
-	return v;
+	var v GraphicsExposureEvent
+	v.Drawable = Id(get32(b[4:]))
+	v.X = get16(b[8:])
+	v.Y = get16(b[10:])
+	v.Width = get16(b[12:])
+	v.Height = get16(b[14:])
+	v.MinorOpcode = get16(b[16:])
+	v.Count = get16(b[18:])
+	v.MajorOpcode = b[20]
+	return v
 }
 
 const NoExposure = 14
 
 type NoExposureEvent struct {
-	Drawable	Id;
-	MinorOpcode	uint16;
-	MajorOpcode	byte;
+	Drawable    Id
+	MinorOpcode uint16
+	MajorOpcode byte
 }
 
 func getNoExposureEvent(b []byte) NoExposureEvent {
-	var v NoExposureEvent;
-	v.Drawable = Id(get32(b[4:]));
-	v.MinorOpcode = get16(b[8:]);
-	v.MajorOpcode = b[10];
-	return v;
+	var v NoExposureEvent
+	v.Drawable = Id(get32(b[4:]))
+	v.MinorOpcode = get16(b[8:])
+	v.MajorOpcode = b[10]
+	return v
 }
 
 const (
-	VisibilityUnobscured		= 0;
-	VisibilityPartiallyObscured	= 1;
-	VisibilityFullyObscured		= 2;
+	VisibilityUnobscured        = 0
+	VisibilityPartiallyObscured = 1
+	VisibilityFullyObscured     = 2
 )
 
 const VisibilityNotify = 15
 
 type VisibilityNotifyEvent struct {
-	Window	Id;
-	State	byte;
+	Window Id
+	State  byte
 }
 
 func getVisibilityNotifyEvent(b []byte) VisibilityNotifyEvent {
-	var v VisibilityNotifyEvent;
-	v.Window = Id(get32(b[4:]));
-	v.State = b[8];
-	return v;
+	var v VisibilityNotifyEvent
+	v.Window = Id(get32(b[4:]))
+	v.State = b[8]
+	return v
 }
 
 const CreateNotify = 16
 
 type CreateNotifyEvent struct {
-	Parent			Id;
-	Window			Id;
-	X			int16;
-	Y			int16;
-	Width			uint16;
-	Height			uint16;
-	BorderWidth		uint16;
-	OverrideRedirect	byte;
+	Parent           Id
+	Window           Id
+	X                int16
+	Y                int16
+	Width            uint16
+	Height           uint16
+	BorderWidth      uint16
+	OverrideRedirect byte
 }
 
 func getCreateNotifyEvent(b []byte) CreateNotifyEvent {
-	var v CreateNotifyEvent;
-	v.Parent = Id(get32(b[4:]));
-	v.Window = Id(get32(b[8:]));
-	v.X = int16(get16(b[12:]));
-	v.Y = int16(get16(b[14:]));
-	v.Width = get16(b[16:]);
-	v.Height = get16(b[18:]);
-	v.BorderWidth = get16(b[20:]);
-	v.OverrideRedirect = b[22];
-	return v;
+	var v CreateNotifyEvent
+	v.Parent = Id(get32(b[4:]))
+	v.Window = Id(get32(b[8:]))
+	v.X = int16(get16(b[12:]))
+	v.Y = int16(get16(b[14:]))
+	v.Width = get16(b[16:])
+	v.Height = get16(b[18:])
+	v.BorderWidth = get16(b[20:])
+	v.OverrideRedirect = b[22]
+	return v
 }
 
 const DestroyNotify = 17
 
 type DestroyNotifyEvent struct {
-	Event	Id;
-	Window	Id;
+	Event  Id
+	Window Id
 }
 
 func getDestroyNotifyEvent(b []byte) DestroyNotifyEvent {
-	var v DestroyNotifyEvent;
-	v.Event = Id(get32(b[4:]));
-	v.Window = Id(get32(b[8:]));
-	return v;
+	var v DestroyNotifyEvent
+	v.Event = Id(get32(b[4:]))
+	v.Window = Id(get32(b[8:]))
+	return v
 }
 
 const UnmapNotify = 18
 
 type UnmapNotifyEvent struct {
-	Event		Id;
-	Window		Id;
-	FromConfigure	byte;
+	Event         Id
+	Window        Id
+	FromConfigure byte
 }
 
 func getUnmapNotifyEvent(b []byte) UnmapNotifyEvent {
-	var v UnmapNotifyEvent;
-	v.Event = Id(get32(b[4:]));
-	v.Window = Id(get32(b[8:]));
-	v.FromConfigure = b[12];
-	return v;
+	var v UnmapNotifyEvent
+	v.Event = Id(get32(b[4:]))
+	v.Window = Id(get32(b[8:]))
+	v.FromConfigure = b[12]
+	return v
 }
 
 const MapNotify = 19
 
 type MapNotifyEvent struct {
-	Event			Id;
-	Window			Id;
-	OverrideRedirect	byte;
+	Event            Id
+	Window           Id
+	OverrideRedirect byte
 }
 
 func getMapNotifyEvent(b []byte) MapNotifyEvent {
-	var v MapNotifyEvent;
-	v.Event = Id(get32(b[4:]));
-	v.Window = Id(get32(b[8:]));
-	v.OverrideRedirect = b[12];
-	return v;
+	var v MapNotifyEvent
+	v.Event = Id(get32(b[4:]))
+	v.Window = Id(get32(b[8:]))
+	v.OverrideRedirect = b[12]
+	return v
 }
 
 const MapRequest = 20
 
 type MapRequestEvent struct {
-	Parent	Id;
-	Window	Id;
+	Parent Id
+	Window Id
 }
 
 func getMapRequestEvent(b []byte) MapRequestEvent {
-	var v MapRequestEvent;
-	v.Parent = Id(get32(b[4:]));
-	v.Window = Id(get32(b[8:]));
-	return v;
+	var v MapRequestEvent
+	v.Parent = Id(get32(b[4:]))
+	v.Window = Id(get32(b[8:]))
+	return v
 }
 
 const ReparentNotify = 21
 
 type ReparentNotifyEvent struct {
-	Event			Id;
-	Window			Id;
-	Parent			Id;
-	X			int16;
-	Y			int16;
-	OverrideRedirect	byte;
+	Event            Id
+	Window           Id
+	Parent           Id
+	X                int16
+	Y                int16
+	OverrideRedirect byte
 }
 
 func getReparentNotifyEvent(b []byte) ReparentNotifyEvent {
-	var v ReparentNotifyEvent;
-	v.Event = Id(get32(b[4:]));
-	v.Window = Id(get32(b[8:]));
-	v.Parent = Id(get32(b[12:]));
-	v.X = int16(get16(b[16:]));
-	v.Y = int16(get16(b[18:]));
-	v.OverrideRedirect = b[20];
-	return v;
+	var v ReparentNotifyEvent
+	v.Event = Id(get32(b[4:]))
+	v.Window = Id(get32(b[8:]))
+	v.Parent = Id(get32(b[12:]))
+	v.X = int16(get16(b[16:]))
+	v.Y = int16(get16(b[18:]))
+	v.OverrideRedirect = b[20]
+	return v
 }
 
 const ConfigureNotify = 22
 
 type ConfigureNotifyEvent struct {
-	Event			Id;
-	Window			Id;
-	AboveSibling		Id;
-	X			int16;
-	Y			int16;
-	Width			uint16;
-	Height			uint16;
-	BorderWidth		uint16;
-	OverrideRedirect	byte;
+	Event            Id
+	Window           Id
+	AboveSibling     Id
+	X                int16
+	Y                int16
+	Width            uint16
+	Height           uint16
+	BorderWidth      uint16
+	OverrideRedirect byte
 }
 
 func getConfigureNotifyEvent(b []byte) ConfigureNotifyEvent {
-	var v ConfigureNotifyEvent;
-	v.Event = Id(get32(b[4:]));
-	v.Window = Id(get32(b[8:]));
-	v.AboveSibling = Id(get32(b[12:]));
-	v.X = int16(get16(b[16:]));
-	v.Y = int16(get16(b[18:]));
-	v.Width = get16(b[20:]);
-	v.Height = get16(b[22:]);
-	v.BorderWidth = get16(b[24:]);
-	v.OverrideRedirect = b[26];
-	return v;
+	var v ConfigureNotifyEvent
+	v.Event = Id(get32(b[4:]))
+	v.Window = Id(get32(b[8:]))
+	v.AboveSibling = Id(get32(b[12:]))
+	v.X = int16(get16(b[16:]))
+	v.Y = int16(get16(b[18:]))
+	v.Width = get16(b[20:])
+	v.Height = get16(b[22:])
+	v.BorderWidth = get16(b[24:])
+	v.OverrideRedirect = b[26]
+	return v
 }
 
 const ConfigureRequest = 23
 
 type ConfigureRequestEvent struct {
-	StackMode	byte;
-	Parent		Id;
-	Window		Id;
-	Sibling		Id;
-	X		int16;
-	Y		int16;
-	Width		uint16;
-	Height		uint16;
-	BorderWidth	uint16;
-	ValueMask	uint16;
+	StackMode   byte
+	Parent      Id
+	Window      Id
+	Sibling     Id
+	X           int16
+	Y           int16
+	Width       uint16
+	Height      uint16
+	BorderWidth uint16
+	ValueMask   uint16
 }
 
 func getConfigureRequestEvent(b []byte) ConfigureRequestEvent {
-	var v ConfigureRequestEvent;
-	v.StackMode = b[1];
-	v.Parent = Id(get32(b[4:]));
-	v.Window = Id(get32(b[8:]));
-	v.Sibling = Id(get32(b[12:]));
-	v.X = int16(get16(b[16:]));
-	v.Y = int16(get16(b[18:]));
-	v.Width = get16(b[20:]);
-	v.Height = get16(b[22:]);
-	v.BorderWidth = get16(b[24:]);
-	v.ValueMask = get16(b[26:]);
-	return v;
+	var v ConfigureRequestEvent
+	v.StackMode = b[1]
+	v.Parent = Id(get32(b[4:]))
+	v.Window = Id(get32(b[8:]))
+	v.Sibling = Id(get32(b[12:]))
+	v.X = int16(get16(b[16:]))
+	v.Y = int16(get16(b[18:]))
+	v.Width = get16(b[20:])
+	v.Height = get16(b[22:])
+	v.BorderWidth = get16(b[24:])
+	v.ValueMask = get16(b[26:])
+	return v
 }
 
 const GravityNotify = 24
 
 type GravityNotifyEvent struct {
-	Event	Id;
-	Window	Id;
-	X	int16;
-	Y	int16;
+	Event  Id
+	Window Id
+	X      int16
+	Y      int16
 }
 
 func getGravityNotifyEvent(b []byte) GravityNotifyEvent {
-	var v GravityNotifyEvent;
-	v.Event = Id(get32(b[4:]));
-	v.Window = Id(get32(b[8:]));
-	v.X = int16(get16(b[12:]));
-	v.Y = int16(get16(b[14:]));
-	return v;
+	var v GravityNotifyEvent
+	v.Event = Id(get32(b[4:]))
+	v.Window = Id(get32(b[8:]))
+	v.X = int16(get16(b[12:]))
+	v.Y = int16(get16(b[14:]))
+	return v
 }
 
 const ResizeRequest = 25
 
 type ResizeRequestEvent struct {
-	Window	Id;
-	Width	uint16;
-	Height	uint16;
+	Window Id
+	Width  uint16
+	Height uint16
 }
 
 func getResizeRequestEvent(b []byte) ResizeRequestEvent {
-	var v ResizeRequestEvent;
-	v.Window = Id(get32(b[4:]));
-	v.Width = get16(b[8:]);
-	v.Height = get16(b[10:]);
-	return v;
+	var v ResizeRequestEvent
+	v.Window = Id(get32(b[4:]))
+	v.Width = get16(b[8:])
+	v.Height = get16(b[10:])
+	return v
 }
 
 const (
-	PlaceOnTop	= 0;
-	PlaceOnBottom	= 1;
+	PlaceOnTop    = 0
+	PlaceOnBottom = 1
 )
 
 const CirculateNotify = 26
 
 type CirculateNotifyEvent struct {
-	Event	Id;
-	Window	Id;
-	Place	byte;
+	Event  Id
+	Window Id
+	Place  byte
 }
 
 func getCirculateNotifyEvent(b []byte) CirculateNotifyEvent {
-	var v CirculateNotifyEvent;
-	v.Event = Id(get32(b[4:]));
-	v.Window = Id(get32(b[8:]));
-	v.Place = b[16];
-	return v;
+	var v CirculateNotifyEvent
+	v.Event = Id(get32(b[4:]))
+	v.Window = Id(get32(b[8:]))
+	v.Place = b[16]
+	return v
 }
 
 const CirculateRequest = 27
@@ -877,228 +877,228 @@ func getCirculateRequestEvent(b []byte) CirculateRequestEvent {
 }
 
 const (
-	PropertyNewValue	= 0;
-	PropertyDelete		= 1;
+	PropertyNewValue = 0
+	PropertyDelete   = 1
 )
 
 const PropertyNotify = 28
 
 type PropertyNotifyEvent struct {
-	Window	Id;
-	Atom	Id;
-	Time	Timestamp;
-	State	byte;
+	Window Id
+	Atom   Id
+	Time   Timestamp
+	State  byte
 }
 
 func getPropertyNotifyEvent(b []byte) PropertyNotifyEvent {
-	var v PropertyNotifyEvent;
-	v.Window = Id(get32(b[4:]));
-	v.Atom = Id(get32(b[8:]));
-	v.Time = Timestamp(get32(b[12:]));
-	v.State = b[16];
-	return v;
+	var v PropertyNotifyEvent
+	v.Window = Id(get32(b[4:]))
+	v.Atom = Id(get32(b[8:]))
+	v.Time = Timestamp(get32(b[12:]))
+	v.State = b[16]
+	return v
 }
 
 const SelectionClear = 29
 
 type SelectionClearEvent struct {
-	Time		Timestamp;
-	Owner		Id;
-	Selection	Id;
+	Time      Timestamp
+	Owner     Id
+	Selection Id
 }
 
 func getSelectionClearEvent(b []byte) SelectionClearEvent {
-	var v SelectionClearEvent;
-	v.Time = Timestamp(get32(b[4:]));
-	v.Owner = Id(get32(b[8:]));
-	v.Selection = Id(get32(b[12:]));
-	return v;
+	var v SelectionClearEvent
+	v.Time = Timestamp(get32(b[4:]))
+	v.Owner = Id(get32(b[8:]))
+	v.Selection = Id(get32(b[12:]))
+	return v
 }
 
 const (
-	TimeCurrentTime = 0;
+	TimeCurrentTime = 0
 )
 
 const (
-	AtomNone		= 0;
-	AtomAny			= 0;
-	AtomPrimary		= 1;
-	AtomSecondary		= 2;
-	AtomArc			= 3;
-	AtomAtom		= 4;
-	AtomBitmap		= 5;
-	AtomCardinal		= 6;
-	AtomColormap		= 7;
-	AtomCursor		= 8;
-	AtomCutBuffer0		= 9;
-	AtomCutBuffer1		= 10;
-	AtomCutBuffer2		= 11;
-	AtomCutBuffer3		= 12;
-	AtomCutBuffer4		= 13;
-	AtomCutBuffer5		= 14;
-	AtomCutBuffer6		= 15;
-	AtomCutBuffer7		= 16;
-	AtomDrawable		= 17;
-	AtomFont		= 18;
-	AtomInteger		= 19;
-	AtomPixmap		= 20;
-	AtomPoint		= 21;
-	AtomRectangle		= 22;
-	AtomResourceManager	= 23;
-	AtomRgbColorMap		= 24;
-	AtomRgbBestMap		= 25;
-	AtomRgbBlueMap		= 26;
-	AtomRgbDefaultMap	= 27;
-	AtomRgbGrayMap		= 28;
-	AtomRgbGreenMap		= 29;
-	AtomRgbRedMap		= 30;
-	AtomString		= 31;
-	AtomVisualid		= 32;
-	AtomWindow		= 33;
-	AtomWmCommand		= 34;
-	AtomWmHints		= 35;
-	AtomWmClientMachine	= 36;
-	AtomWmIconName		= 37;
-	AtomWmIconSize		= 38;
-	AtomWmName		= 39;
-	AtomWmNormalHints	= 40;
-	AtomWmSizeHints		= 41;
-	AtomWmZoomHints		= 42;
-	AtomMinSpace		= 43;
-	AtomNormSpace		= 44;
-	AtomMaxSpace		= 45;
-	AtomEndSpace		= 46;
-	AtomSuperscriptX	= 47;
-	AtomSuperscriptY	= 48;
-	AtomSubscriptX		= 49;
-	AtomSubscriptY		= 50;
-	AtomUnderlinePosition	= 51;
-	AtomUnderlineThickness	= 52;
-	AtomStrikeoutAscent	= 53;
-	AtomStrikeoutDescent	= 54;
-	AtomItalicAngle		= 55;
-	AtomXHeight		= 56;
-	AtomQuadWidth		= 57;
-	AtomWeight		= 58;
-	AtomPointSize		= 59;
-	AtomResolution		= 60;
-	AtomCopyright		= 61;
-	AtomNotice		= 62;
-	AtomFontName		= 63;
-	AtomFamilyName		= 64;
-	AtomFullName		= 65;
-	AtomCapHeight		= 66;
-	AtomWmClass		= 67;
-	AtomWmTransientFor	= 68;
+	AtomNone               = 0
+	AtomAny                = 0
+	AtomPrimary            = 1
+	AtomSecondary          = 2
+	AtomArc                = 3
+	AtomAtom               = 4
+	AtomBitmap             = 5
+	AtomCardinal           = 6
+	AtomColormap           = 7
+	AtomCursor             = 8
+	AtomCutBuffer0         = 9
+	AtomCutBuffer1         = 10
+	AtomCutBuffer2         = 11
+	AtomCutBuffer3         = 12
+	AtomCutBuffer4         = 13
+	AtomCutBuffer5         = 14
+	AtomCutBuffer6         = 15
+	AtomCutBuffer7         = 16
+	AtomDrawable           = 17
+	AtomFont               = 18
+	AtomInteger            = 19
+	AtomPixmap             = 20
+	AtomPoint              = 21
+	AtomRectangle          = 22
+	AtomResourceManager    = 23
+	AtomRgbColorMap        = 24
+	AtomRgbBestMap         = 25
+	AtomRgbBlueMap         = 26
+	AtomRgbDefaultMap      = 27
+	AtomRgbGrayMap         = 28
+	AtomRgbGreenMap        = 29
+	AtomRgbRedMap          = 30
+	AtomString             = 31
+	AtomVisualid           = 32
+	AtomWindow             = 33
+	AtomWmCommand          = 34
+	AtomWmHints            = 35
+	AtomWmClientMachine    = 36
+	AtomWmIconName         = 37
+	AtomWmIconSize         = 38
+	AtomWmName             = 39
+	AtomWmNormalHints      = 40
+	AtomWmSizeHints        = 41
+	AtomWmZoomHints        = 42
+	AtomMinSpace           = 43
+	AtomNormSpace          = 44
+	AtomMaxSpace           = 45
+	AtomEndSpace           = 46
+	AtomSuperscriptX       = 47
+	AtomSuperscriptY       = 48
+	AtomSubscriptX         = 49
+	AtomSubscriptY         = 50
+	AtomUnderlinePosition  = 51
+	AtomUnderlineThickness = 52
+	AtomStrikeoutAscent    = 53
+	AtomStrikeoutDescent   = 54
+	AtomItalicAngle        = 55
+	AtomXHeight            = 56
+	AtomQuadWidth          = 57
+	AtomWeight             = 58
+	AtomPointSize          = 59
+	AtomResolution         = 60
+	AtomCopyright          = 61
+	AtomNotice             = 62
+	AtomFontName           = 63
+	AtomFamilyName         = 64
+	AtomFullName           = 65
+	AtomCapHeight          = 66
+	AtomWmClass            = 67
+	AtomWmTransientFor     = 68
 )
 
 const SelectionRequest = 30
 
 type SelectionRequestEvent struct {
-	Time		Timestamp;
-	Owner		Id;
-	Requestor	Id;
-	Selection	Id;
-	Target		Id;
-	Property	Id;
+	Time      Timestamp
+	Owner     Id
+	Requestor Id
+	Selection Id
+	Target    Id
+	Property  Id
 }
 
 func getSelectionRequestEvent(b []byte) SelectionRequestEvent {
-	var v SelectionRequestEvent;
-	v.Time = Timestamp(get32(b[4:]));
-	v.Owner = Id(get32(b[8:]));
-	v.Requestor = Id(get32(b[12:]));
-	v.Selection = Id(get32(b[16:]));
-	v.Target = Id(get32(b[20:]));
-	v.Property = Id(get32(b[24:]));
-	return v;
+	var v SelectionRequestEvent
+	v.Time = Timestamp(get32(b[4:]))
+	v.Owner = Id(get32(b[8:]))
+	v.Requestor = Id(get32(b[12:]))
+	v.Selection = Id(get32(b[16:]))
+	v.Target = Id(get32(b[20:]))
+	v.Property = Id(get32(b[24:]))
+	return v
 }
 
 const SelectionNotify = 31
 
 type SelectionNotifyEvent struct {
-	Time		Timestamp;
-	Requestor	Id;
-	Selection	Id;
-	Target		Id;
-	Property	Id;
+	Time      Timestamp
+	Requestor Id
+	Selection Id
+	Target    Id
+	Property  Id
 }
 
 func getSelectionNotifyEvent(b []byte) SelectionNotifyEvent {
-	var v SelectionNotifyEvent;
-	v.Time = Timestamp(get32(b[4:]));
-	v.Requestor = Id(get32(b[8:]));
-	v.Selection = Id(get32(b[12:]));
-	v.Target = Id(get32(b[16:]));
-	v.Property = Id(get32(b[20:]));
-	return v;
+	var v SelectionNotifyEvent
+	v.Time = Timestamp(get32(b[4:]))
+	v.Requestor = Id(get32(b[8:]))
+	v.Selection = Id(get32(b[12:]))
+	v.Target = Id(get32(b[16:]))
+	v.Property = Id(get32(b[20:]))
+	return v
 }
 
 const (
-	ColormapStateUninstalled	= 0;
-	ColormapStateInstalled		= 1;
+	ColormapStateUninstalled = 0
+	ColormapStateInstalled   = 1
 )
 
 const (
-	ColormapNone = 0;
+	ColormapNone = 0
 )
 
 const ColormapNotify = 32
 
 type ColormapNotifyEvent struct {
-	Window		Id;
-	Colormap	Id;
-	New		byte;
-	State		byte;
+	Window   Id
+	Colormap Id
+	New      byte
+	State    byte
 }
 
 func getColormapNotifyEvent(b []byte) ColormapNotifyEvent {
-	var v ColormapNotifyEvent;
-	v.Window = Id(get32(b[4:]));
-	v.Colormap = Id(get32(b[8:]));
-	v.New = b[12];
-	v.State = b[13];
-	return v;
+	var v ColormapNotifyEvent
+	v.Window = Id(get32(b[4:]))
+	v.Colormap = Id(get32(b[8:]))
+	v.New = b[12]
+	v.State = b[13]
+	return v
 }
 
 const ClientMessage = 33
 
 type ClientMessageEvent struct {
-	Format	byte;
-	Window	Id;
-	Type	Id;
-	Data	ClientMessageData;
+	Format byte
+	Window Id
+	Type   Id
+	Data   ClientMessageData
 }
 
 func getClientMessageEvent(b []byte) ClientMessageEvent {
-	var v ClientMessageEvent;
-	v.Format = b[1];
-	v.Window = Id(get32(b[4:]));
-	v.Type = Id(get32(b[8:]));
-	getClientMessageData(b[12:], &v.Data);
-	return v;
+	var v ClientMessageEvent
+	v.Format = b[1]
+	v.Window = Id(get32(b[4:]))
+	v.Type = Id(get32(b[8:]))
+	getClientMessageData(b[12:], &v.Data)
+	return v
 }
 
 const (
-	MappingModifier	= 0;
-	MappingKeyboard	= 1;
-	MappingPointer	= 2;
+	MappingModifier = 0
+	MappingKeyboard = 1
+	MappingPointer  = 2
 )
 
 const MappingNotify = 34
 
 type MappingNotifyEvent struct {
-	Request		byte;
-	FirstKeycode	byte;
-	Count		byte;
+	Request      byte
+	FirstKeycode byte
+	Count        byte
 }
 
 func getMappingNotifyEvent(b []byte) MappingNotifyEvent {
-	var v MappingNotifyEvent;
-	v.Request = b[4];
-	v.FirstKeycode = b[5];
-	v.Count = b[6];
-	return v;
+	var v MappingNotifyEvent
+	v.Request = b[4]
+	v.FirstKeycode = b[5]
+	v.Count = b[6]
+	return v
 }
 
 const BadRequest = 1
@@ -1136,94 +1136,94 @@ const BadLength = 16
 const BadImplementation = 17
 
 const (
-	WindowClassCopyFromParent	= 0;
-	WindowClassInputOutput		= 1;
-	WindowClassInputOnly		= 2;
+	WindowClassCopyFromParent = 0
+	WindowClassInputOutput    = 1
+	WindowClassInputOnly      = 2
 )
 
 const (
-	CWBackPixmap		= 1;
-	CWBackPixel		= 2;
-	CWBorderPixmap		= 4;
-	CWBorderPixel		= 8;
-	CWBitGravity		= 16;
-	CWWinGravity		= 32;
-	CWBackingStore		= 64;
-	CWBackingPlanes		= 128;
-	CWBackingPixel		= 256;
-	CWOverrideRedirect	= 512;
-	CWSaveUnder		= 1024;
-	CWEventMask		= 2048;
-	CWDontPropagate		= 4096;
-	CWColormap		= 8192;
-	CWCursor		= 16384;
+	CWBackPixmap       = 1
+	CWBackPixel        = 2
+	CWBorderPixmap     = 4
+	CWBorderPixel      = 8
+	CWBitGravity       = 16
+	CWWinGravity       = 32
+	CWBackingStore     = 64
+	CWBackingPlanes    = 128
+	CWBackingPixel     = 256
+	CWOverrideRedirect = 512
+	CWSaveUnder        = 1024
+	CWEventMask        = 2048
+	CWDontPropagate    = 4096
+	CWColormap         = 8192
+	CWCursor           = 16384
 )
 
 const (
-	BackPixmapNone			= 0;
-	BackPixmapParentRelative	= 1;
+	BackPixmapNone           = 0
+	BackPixmapParentRelative = 1
 )
 
 const (
-	GravityBitForget	= 0;
-	GravityWinUnmap		= 0;
-	GravityNorthWest	= 1;
-	GravityNorth		= 2;
-	GravityNorthEast	= 3;
-	GravityWest		= 4;
-	GravityCenter		= 5;
-	GravityEast		= 6;
-	GravitySouthWest	= 7;
-	GravitySouth		= 8;
-	GravitySouthEast	= 9;
-	GravityStatic		= 10;
+	GravityBitForget = 0
+	GravityWinUnmap  = 0
+	GravityNorthWest = 1
+	GravityNorth     = 2
+	GravityNorthEast = 3
+	GravityWest      = 4
+	GravityCenter    = 5
+	GravityEast      = 6
+	GravitySouthWest = 7
+	GravitySouth     = 8
+	GravitySouthEast = 9
+	GravityStatic    = 10
 )
 
 func (c *Conn) CreateWindow(Depth byte, Wid Id, Parent Id, X int16, Y int16, Width uint16, Height uint16, BorderWidth uint16, Class uint16, Visual Id, ValueMask uint32, ValueList []uint32) {
-	b := c.scratch[0:32];
-	n := 32;
-	n += pad(popCount(int(ValueMask)) * 4);
-	put16(b[2:], uint16(n/4));
-	b[0] = 1;
-	b[1] = Depth;
-	put32(b[4:], uint32(Wid));
-	put32(b[8:], uint32(Parent));
-	put16(b[12:], uint16(X));
-	put16(b[14:], uint16(Y));
-	put16(b[16:], Width);
-	put16(b[18:], Height);
-	put16(b[20:], BorderWidth);
-	put16(b[22:], Class);
-	put32(b[24:], uint32(Visual));
-	put32(b[28:], ValueMask);
-	c.sendRequest(b);
-	c.sendUInt32List(ValueList[0:popCount(int(ValueMask))]);
+	b := c.scratch[0:32]
+	n := 32
+	n += pad(popCount(int(ValueMask)) * 4)
+	put16(b[2:], uint16(n/4))
+	b[0] = 1
+	b[1] = Depth
+	put32(b[4:], uint32(Wid))
+	put32(b[8:], uint32(Parent))
+	put16(b[12:], uint16(X))
+	put16(b[14:], uint16(Y))
+	put16(b[16:], Width)
+	put16(b[18:], Height)
+	put16(b[20:], BorderWidth)
+	put16(b[22:], Class)
+	put32(b[24:], uint32(Visual))
+	put32(b[28:], ValueMask)
+	c.sendRequest(b)
+	c.sendUInt32List(ValueList[0:popCount(int(ValueMask))])
 }
 
 func (c *Conn) ChangeWindowAttributes(Window Id, ValueMask uint32, ValueList []uint32) {
-	b := c.scratch[0:12];
-	n := 12;
-	n += pad(popCount(int(ValueMask)) * 4);
-	put16(b[2:], uint16(n/4));
-	b[0] = 2;
-	put32(b[4:], uint32(Window));
-	put32(b[8:], ValueMask);
-	c.sendRequest(b);
-	c.sendUInt32List(ValueList[0:popCount(int(ValueMask))]);
+	b := c.scratch[0:12]
+	n := 12
+	n += pad(popCount(int(ValueMask)) * 4)
+	put16(b[2:], uint16(n/4))
+	b[0] = 2
+	put32(b[4:], uint32(Window))
+	put32(b[8:], ValueMask)
+	c.sendRequest(b)
+	c.sendUInt32List(ValueList[0:popCount(int(ValueMask))])
 }
 
 const (
-	MapStateUnmapped	= 0;
-	MapStateUnviewable	= 1;
-	MapStateViewable	= 2;
+	MapStateUnmapped   = 0
+	MapStateUnviewable = 1
+	MapStateViewable   = 2
 )
 
 func (c *Conn) GetWindowAttributesRequest(Window Id) Cookie {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 3;
-	put32(b[4:], uint32(Window));
-	return c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 3
+	put32(b[4:], uint32(Window))
+	return c.sendRequest(b)
 }
 
 func (c *Conn) GetWindowAttributes(Window Id) (*GetWindowAttributesReply, os.Error) {
@@ -1231,170 +1231,170 @@ func (c *Conn) GetWindowAttributes(Window Id) (*GetWindowAttributesReply, os.Err
 }
 
 type GetWindowAttributesReply struct {
-	BackingStore		byte;
-	Visual			Id;
-	Class			uint16;
-	BitGravity		byte;
-	WinGravity		byte;
-	BackingPlanes		uint32;
-	BackingPixel		uint32;
-	SaveUnder		byte;
-	MapIsInstalled		byte;
-	MapState		byte;
-	OverrideRedirect	byte;
-	Colormap		Id;
-	AllEventMasks		uint32;
-	YourEventMask		uint32;
-	DoNotPropagateMask	uint16;
+	BackingStore       byte
+	Visual             Id
+	Class              uint16
+	BitGravity         byte
+	WinGravity         byte
+	BackingPlanes      uint32
+	BackingPixel       uint32
+	SaveUnder          byte
+	MapIsInstalled     byte
+	MapState           byte
+	OverrideRedirect   byte
+	Colormap           Id
+	AllEventMasks      uint32
+	YourEventMask      uint32
+	DoNotPropagateMask uint16
 }
 
 func (c *Conn) GetWindowAttributesReply(cookie Cookie) (*GetWindowAttributesReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(GetWindowAttributesReply);
-	v.BackingStore = b[1];
-	v.Visual = Id(get32(b[8:]));
-	v.Class = get16(b[12:]);
-	v.BitGravity = b[14];
-	v.WinGravity = b[15];
-	v.BackingPlanes = get32(b[16:]);
-	v.BackingPixel = get32(b[20:]);
-	v.SaveUnder = b[24];
-	v.MapIsInstalled = b[25];
-	v.MapState = b[26];
-	v.OverrideRedirect = b[27];
-	v.Colormap = Id(get32(b[28:]));
-	v.AllEventMasks = get32(b[32:]);
-	v.YourEventMask = get32(b[36:]);
-	v.DoNotPropagateMask = get16(b[40:]);
-	return v, nil;
+	v := new(GetWindowAttributesReply)
+	v.BackingStore = b[1]
+	v.Visual = Id(get32(b[8:]))
+	v.Class = get16(b[12:])
+	v.BitGravity = b[14]
+	v.WinGravity = b[15]
+	v.BackingPlanes = get32(b[16:])
+	v.BackingPixel = get32(b[20:])
+	v.SaveUnder = b[24]
+	v.MapIsInstalled = b[25]
+	v.MapState = b[26]
+	v.OverrideRedirect = b[27]
+	v.Colormap = Id(get32(b[28:]))
+	v.AllEventMasks = get32(b[32:])
+	v.YourEventMask = get32(b[36:])
+	v.DoNotPropagateMask = get16(b[40:])
+	return v, nil
 }
 
 func (c *Conn) DestroyWindow(Window Id) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 4;
-	put32(b[4:], uint32(Window));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 4
+	put32(b[4:], uint32(Window))
+	c.sendRequest(b)
 }
 
 func (c *Conn) DestroySubwindows(Window Id) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 5;
-	put32(b[4:], uint32(Window));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 5
+	put32(b[4:], uint32(Window))
+	c.sendRequest(b)
 }
 
 const (
-	SetModeInsert	= 0;
-	SetModeDelete	= 1;
+	SetModeInsert = 0
+	SetModeDelete = 1
 )
 
 func (c *Conn) ChangeSaveSet(Mode byte, Window Id) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 6;
-	b[1] = Mode;
-	put32(b[4:], uint32(Window));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 6
+	b[1] = Mode
+	put32(b[4:], uint32(Window))
+	c.sendRequest(b)
 }
 
 func (c *Conn) ReparentWindow(Window Id, Parent Id, X int16, Y int16) {
-	b := c.scratch[0:16];
-	put16(b[2:], 4);
-	b[0] = 7;
-	put32(b[4:], uint32(Window));
-	put32(b[8:], uint32(Parent));
-	put16(b[12:], uint16(X));
-	put16(b[14:], uint16(Y));
-	c.sendRequest(b);
+	b := c.scratch[0:16]
+	put16(b[2:], 4)
+	b[0] = 7
+	put32(b[4:], uint32(Window))
+	put32(b[8:], uint32(Parent))
+	put16(b[12:], uint16(X))
+	put16(b[14:], uint16(Y))
+	c.sendRequest(b)
 }
 
 func (c *Conn) MapWindow(Window Id) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 8;
-	put32(b[4:], uint32(Window));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 8
+	put32(b[4:], uint32(Window))
+	c.sendRequest(b)
 }
 
 func (c *Conn) MapSubwindows(Window Id) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 9;
-	put32(b[4:], uint32(Window));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 9
+	put32(b[4:], uint32(Window))
+	c.sendRequest(b)
 }
 
 func (c *Conn) UnmapWindow(Window Id) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 10;
-	put32(b[4:], uint32(Window));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 10
+	put32(b[4:], uint32(Window))
+	c.sendRequest(b)
 }
 
 func (c *Conn) UnmapSubwindows(Window Id) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 11;
-	put32(b[4:], uint32(Window));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 11
+	put32(b[4:], uint32(Window))
+	c.sendRequest(b)
 }
 
 const (
-	ConfigWindowX		= 1;
-	ConfigWindowY		= 2;
-	ConfigWindowWidth	= 4;
-	ConfigWindowHeight	= 8;
-	ConfigWindowBorderWidth	= 16;
-	ConfigWindowSibling	= 32;
-	ConfigWindowStackMode	= 64;
+	ConfigWindowX           = 1
+	ConfigWindowY           = 2
+	ConfigWindowWidth       = 4
+	ConfigWindowHeight      = 8
+	ConfigWindowBorderWidth = 16
+	ConfigWindowSibling     = 32
+	ConfigWindowStackMode   = 64
 )
 
 const (
-	StackModeAbove		= 0;
-	StackModeBelow		= 1;
-	StackModeTopIf		= 2;
-	StackModeBottomIf	= 3;
-	StackModeOpposite	= 4;
+	StackModeAbove    = 0
+	StackModeBelow    = 1
+	StackModeTopIf    = 2
+	StackModeBottomIf = 3
+	StackModeOpposite = 4
 )
 
 func (c *Conn) ConfigureWindow(Window Id, ValueMask uint16, ValueList []uint32) {
-	b := c.scratch[0:12];
-	n := 12;
-	n += pad(popCount(int(ValueMask)) * 4);
-	put16(b[2:], uint16(n/4));
-	b[0] = 12;
-	put32(b[4:], uint32(Window));
-	put16(b[8:], ValueMask);
-	c.sendRequest(b);
-	c.sendUInt32List(ValueList[0:popCount(int(ValueMask))]);
+	b := c.scratch[0:12]
+	n := 12
+	n += pad(popCount(int(ValueMask)) * 4)
+	put16(b[2:], uint16(n/4))
+	b[0] = 12
+	put32(b[4:], uint32(Window))
+	put16(b[8:], ValueMask)
+	c.sendRequest(b)
+	c.sendUInt32List(ValueList[0:popCount(int(ValueMask))])
 }
 
 const (
-	CirculateRaiseLowest	= 0;
-	CirculateLowerHighest	= 1;
+	CirculateRaiseLowest  = 0
+	CirculateLowerHighest = 1
 )
 
 func (c *Conn) CirculateWindow(Direction byte, Window Id) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 13;
-	b[1] = Direction;
-	put32(b[4:], uint32(Window));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 13
+	b[1] = Direction
+	put32(b[4:], uint32(Window))
+	c.sendRequest(b)
 }
 
 func (c *Conn) GetGeometryRequest(Drawable Id) Cookie {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 14;
-	put32(b[4:], uint32(Drawable));
-	return c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 14
+	put32(b[4:], uint32(Drawable))
+	return c.sendRequest(b)
 }
 
 func (c *Conn) GetGeometry(Drawable Id) (*GetGeometryReply, os.Error) {
@@ -1402,37 +1402,37 @@ func (c *Conn) GetGeometry(Drawable Id) (*GetGeometryReply, os.Error) {
 }
 
 type GetGeometryReply struct {
-	Depth		byte;
-	Root		Id;
-	X		int16;
-	Y		int16;
-	Width		uint16;
-	Height		uint16;
-	BorderWidth	uint16;
+	Depth       byte
+	Root        Id
+	X           int16
+	Y           int16
+	Width       uint16
+	Height      uint16
+	BorderWidth uint16
 }
 
 func (c *Conn) GetGeometryReply(cookie Cookie) (*GetGeometryReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(GetGeometryReply);
-	v.Depth = b[1];
-	v.Root = Id(get32(b[8:]));
-	v.X = int16(get16(b[12:]));
-	v.Y = int16(get16(b[14:]));
-	v.Width = get16(b[16:]);
-	v.Height = get16(b[18:]);
-	v.BorderWidth = get16(b[20:]);
-	return v, nil;
+	v := new(GetGeometryReply)
+	v.Depth = b[1]
+	v.Root = Id(get32(b[8:]))
+	v.X = int16(get16(b[12:]))
+	v.Y = int16(get16(b[14:]))
+	v.Width = get16(b[16:])
+	v.Height = get16(b[18:])
+	v.BorderWidth = get16(b[20:])
+	return v, nil
 }
 
 func (c *Conn) QueryTreeRequest(Window Id) Cookie {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 15;
-	put32(b[4:], uint32(Window));
-	return c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 15
+	put32(b[4:], uint32(Window))
+	return c.sendRequest(b)
 }
 
 func (c *Conn) QueryTree(Window Id) (*QueryTreeReply, os.Error) {
@@ -1440,41 +1440,41 @@ func (c *Conn) QueryTree(Window Id) (*QueryTreeReply, os.Error) {
 }
 
 type QueryTreeReply struct {
-	Root		Id;
-	Parent		Id;
-	ChildrenLen	uint16;
-	Children	[]Id;
+	Root        Id
+	Parent      Id
+	ChildrenLen uint16
+	Children    []Id
 }
 
 func (c *Conn) QueryTreeReply(cookie Cookie) (*QueryTreeReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(QueryTreeReply);
-	v.Root = Id(get32(b[8:]));
-	v.Parent = Id(get32(b[12:]));
-	v.ChildrenLen = get16(b[16:]);
-	offset := 32;
-	v.Children = make([]Id, int(v.ChildrenLen));
+	v := new(QueryTreeReply)
+	v.Root = Id(get32(b[8:]))
+	v.Parent = Id(get32(b[12:]))
+	v.ChildrenLen = get16(b[16:])
+	offset := 32
+	v.Children = make([]Id, int(v.ChildrenLen))
 	for i := 0; i < len(v.Children); i++ {
 		v.Children[i] = Id(get32(b[offset+i*4:]))
 	}
-	offset += len(v.Children) * 4;
-	return v, nil;
+	offset += len(v.Children) * 4
+	return v, nil
 }
 
 func (c *Conn) InternAtomRequest(OnlyIfExists byte, Name string) Cookie {
-	b := c.scratch[0:8];
-	n := 8;
-	n += pad(len(Name) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 16;
-	b[1] = OnlyIfExists;
-	put16(b[4:], uint16(len(Name)));
-	cookie := c.sendRequest(b);
-	c.sendString(Name);
-	return cookie;
+	b := c.scratch[0:8]
+	n := 8
+	n += pad(len(Name) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 16
+	b[1] = OnlyIfExists
+	put16(b[4:], uint16(len(Name)))
+	cookie := c.sendRequest(b)
+	c.sendString(Name)
+	return cookie
 }
 
 func (c *Conn) InternAtom(OnlyIfExists byte, Name string) (*InternAtomReply, os.Error) {
@@ -1482,25 +1482,25 @@ func (c *Conn) InternAtom(OnlyIfExists byte, Name string) (*InternAtomReply, os.
 }
 
 type InternAtomReply struct {
-	Atom Id;
+	Atom Id
 }
 
 func (c *Conn) InternAtomReply(cookie Cookie) (*InternAtomReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(InternAtomReply);
-	v.Atom = Id(get32(b[8:]));
-	return v, nil;
+	v := new(InternAtomReply)
+	v.Atom = Id(get32(b[8:]))
+	return v, nil
 }
 
 func (c *Conn) GetAtomNameRequest(Atom Id) Cookie {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 17;
-	put32(b[4:], uint32(Atom));
-	return c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 17
+	put32(b[4:], uint32(Atom))
+	return c.sendRequest(b)
 }
 
 func (c *Conn) GetAtomName(Atom Id) (*GetAtomNameReply, os.Error) {
@@ -1508,70 +1508,70 @@ func (c *Conn) GetAtomName(Atom Id) (*GetAtomNameReply, os.Error) {
 }
 
 type GetAtomNameReply struct {
-	NameLen	uint16;
-	Name	[]byte;
+	NameLen uint16
+	Name    []byte
 }
 
 func (c *Conn) GetAtomNameReply(cookie Cookie) (*GetAtomNameReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(GetAtomNameReply);
-	v.NameLen = get16(b[8:]);
-	offset := 32;
-	v.Name = make([]byte, int(v.NameLen));
-	copy(v.Name[0:len(v.Name)], b[offset:]);
-	offset += len(v.Name) * 1;
-	return v, nil;
+	v := new(GetAtomNameReply)
+	v.NameLen = get16(b[8:])
+	offset := 32
+	v.Name = make([]byte, int(v.NameLen))
+	copy(v.Name[0:len(v.Name)], b[offset:])
+	offset += len(v.Name) * 1
+	return v, nil
 }
 
 const (
-	PropModeReplace	= 0;
-	PropModePrepend	= 1;
-	PropModeAppend	= 2;
+	PropModeReplace = 0
+	PropModePrepend = 1
+	PropModeAppend  = 2
 )
 
 func (c *Conn) ChangeProperty(Mode byte, Window Id, Property Id, Type Id, Format byte, Data []byte) {
-	b := c.scratch[0:24];
-	n := 24;
-	n += pad(((len(Data) * int(Format)) / 8) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 18;
-	b[1] = Mode;
-	put32(b[4:], uint32(Window));
-	put32(b[8:], uint32(Property));
-	put32(b[12:], uint32(Type));
-	b[16] = Format;
-	put32(b[20:], uint32(len(Data)));
-	c.sendRequest(b);
-	c.sendBytes(Data[0:((len(Data) * int(Format)) / 8)]);
+	b := c.scratch[0:24]
+	n := 24
+	n += pad(((len(Data) * int(Format)) / 8) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 18
+	b[1] = Mode
+	put32(b[4:], uint32(Window))
+	put32(b[8:], uint32(Property))
+	put32(b[12:], uint32(Type))
+	b[16] = Format
+	put32(b[20:], uint32(len(Data)))
+	c.sendRequest(b)
+	c.sendBytes(Data[0:((len(Data) * int(Format)) / 8)])
 }
 
 func (c *Conn) DeleteProperty(Window Id, Property Id) {
-	b := c.scratch[0:12];
-	put16(b[2:], 3);
-	b[0] = 19;
-	put32(b[4:], uint32(Window));
-	put32(b[8:], uint32(Property));
-	c.sendRequest(b);
+	b := c.scratch[0:12]
+	put16(b[2:], 3)
+	b[0] = 19
+	put32(b[4:], uint32(Window))
+	put32(b[8:], uint32(Property))
+	c.sendRequest(b)
 }
 
 const (
-	GetPropertyTypeAny = 0;
+	GetPropertyTypeAny = 0
 )
 
 func (c *Conn) GetPropertyRequest(Delete byte, Window Id, Property Id, Type Id, LongOffset uint32, LongLength uint32) Cookie {
-	b := c.scratch[0:24];
-	put16(b[2:], 6);
-	b[0] = 20;
-	b[1] = Delete;
-	put32(b[4:], uint32(Window));
-	put32(b[8:], uint32(Property));
-	put32(b[12:], uint32(Type));
-	put32(b[16:], LongOffset);
-	put32(b[20:], LongLength);
-	return c.sendRequest(b);
+	b := c.scratch[0:24]
+	put16(b[2:], 6)
+	b[0] = 20
+	b[1] = Delete
+	put32(b[4:], uint32(Window))
+	put32(b[8:], uint32(Property))
+	put32(b[12:], uint32(Type))
+	put32(b[16:], LongOffset)
+	put32(b[20:], LongLength)
+	return c.sendRequest(b)
 }
 
 func (c *Conn) GetProperty(Delete byte, Window Id, Property Id, Type Id, LongOffset uint32, LongLength uint32) (*GetPropertyReply, os.Error) {
@@ -1579,36 +1579,36 @@ func (c *Conn) GetProperty(Delete byte, Window Id, Property Id, Type Id, LongOff
 }
 
 type GetPropertyReply struct {
-	Format		byte;
-	Type		Id;
-	BytesAfter	uint32;
-	ValueLen	uint32;
-	Value		[]byte;
+	Format     byte
+	Type       Id
+	BytesAfter uint32
+	ValueLen   uint32
+	Value      []byte
 }
 
 func (c *Conn) GetPropertyReply(cookie Cookie) (*GetPropertyReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(GetPropertyReply);
-	v.Format = b[1];
-	v.Type = Id(get32(b[8:]));
-	v.BytesAfter = get32(b[12:]);
-	v.ValueLen = get32(b[16:]);
-	offset := 32;
-	v.Value = make([]byte, (int(v.ValueLen) * (int(v.Format) / 8)));
-	copy(v.Value[0:len(v.Value)], b[offset:]);
-	offset += len(v.Value) * 1;
-	return v, nil;
+	v := new(GetPropertyReply)
+	v.Format = b[1]
+	v.Type = Id(get32(b[8:]))
+	v.BytesAfter = get32(b[12:])
+	v.ValueLen = get32(b[16:])
+	offset := 32
+	v.Value = make([]byte, (int(v.ValueLen) * (int(v.Format) / 8)))
+	copy(v.Value[0:len(v.Value)], b[offset:])
+	offset += len(v.Value) * 1
+	return v, nil
 }
 
 func (c *Conn) ListPropertiesRequest(Window Id) Cookie {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 21;
-	put32(b[4:], uint32(Window));
-	return c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 21
+	put32(b[4:], uint32(Window))
+	return c.sendRequest(b)
 }
 
 func (c *Conn) ListProperties(Window Id) (*ListPropertiesReply, os.Error) {
@@ -1616,42 +1616,42 @@ func (c *Conn) ListProperties(Window Id) (*ListPropertiesReply, os.Error) {
 }
 
 type ListPropertiesReply struct {
-	AtomsLen	uint16;
-	Atoms		[]Id;
+	AtomsLen uint16
+	Atoms    []Id
 }
 
 func (c *Conn) ListPropertiesReply(cookie Cookie) (*ListPropertiesReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(ListPropertiesReply);
-	v.AtomsLen = get16(b[8:]);
-	offset := 32;
-	v.Atoms = make([]Id, int(v.AtomsLen));
+	v := new(ListPropertiesReply)
+	v.AtomsLen = get16(b[8:])
+	offset := 32
+	v.Atoms = make([]Id, int(v.AtomsLen))
 	for i := 0; i < len(v.Atoms); i++ {
 		v.Atoms[i] = Id(get32(b[offset+i*4:]))
 	}
-	offset += len(v.Atoms) * 4;
-	return v, nil;
+	offset += len(v.Atoms) * 4
+	return v, nil
 }
 
 func (c *Conn) SetSelectionOwner(Owner Id, Selection Id, Time Timestamp) {
-	b := c.scratch[0:16];
-	put16(b[2:], 4);
-	b[0] = 22;
-	put32(b[4:], uint32(Owner));
-	put32(b[8:], uint32(Selection));
-	put32(b[12:], uint32(Time));
-	c.sendRequest(b);
+	b := c.scratch[0:16]
+	put16(b[2:], 4)
+	b[0] = 22
+	put32(b[4:], uint32(Owner))
+	put32(b[8:], uint32(Selection))
+	put32(b[12:], uint32(Time))
+	c.sendRequest(b)
 }
 
 func (c *Conn) GetSelectionOwnerRequest(Selection Id) Cookie {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 23;
-	put32(b[4:], uint32(Selection));
-	return c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 23
+	put32(b[4:], uint32(Selection))
+	return c.sendRequest(b)
 }
 
 func (c *Conn) GetSelectionOwner(Selection Id) (*GetSelectionOwnerReply, os.Error) {
@@ -1659,77 +1659,77 @@ func (c *Conn) GetSelectionOwner(Selection Id) (*GetSelectionOwnerReply, os.Erro
 }
 
 type GetSelectionOwnerReply struct {
-	Owner Id;
+	Owner Id
 }
 
 func (c *Conn) GetSelectionOwnerReply(cookie Cookie) (*GetSelectionOwnerReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(GetSelectionOwnerReply);
-	v.Owner = Id(get32(b[8:]));
-	return v, nil;
+	v := new(GetSelectionOwnerReply)
+	v.Owner = Id(get32(b[8:]))
+	return v, nil
 }
 
 func (c *Conn) ConvertSelection(Requestor Id, Selection Id, Target Id, Property Id, Time Timestamp) {
-	b := c.scratch[0:24];
-	put16(b[2:], 6);
-	b[0] = 24;
-	put32(b[4:], uint32(Requestor));
-	put32(b[8:], uint32(Selection));
-	put32(b[12:], uint32(Target));
-	put32(b[16:], uint32(Property));
-	put32(b[20:], uint32(Time));
-	c.sendRequest(b);
+	b := c.scratch[0:24]
+	put16(b[2:], 6)
+	b[0] = 24
+	put32(b[4:], uint32(Requestor))
+	put32(b[8:], uint32(Selection))
+	put32(b[12:], uint32(Target))
+	put32(b[16:], uint32(Property))
+	put32(b[20:], uint32(Time))
+	c.sendRequest(b)
 }
 
 const (
-	SendEventDestPointerWindow	= 0;
-	SendEventDestItemFocus		= 1;
+	SendEventDestPointerWindow = 0
+	SendEventDestItemFocus     = 1
 )
 
 func (c *Conn) SendEvent(Propagate byte, Destination Id, EventMask uint32, Event []byte) {
-	b := make([]byte, 44);
-	put16(b[2:], 11);
-	b[0] = 25;
-	b[1] = Propagate;
-	put32(b[4:], uint32(Destination));
-	put32(b[8:], EventMask);
-	copy(b[12:44], Event);
-	c.sendRequest(b);
+	b := make([]byte, 44)
+	put16(b[2:], 11)
+	b[0] = 25
+	b[1] = Propagate
+	put32(b[4:], uint32(Destination))
+	put32(b[8:], EventMask)
+	copy(b[12:44], Event)
+	c.sendRequest(b)
 }
 
 const (
-	GrabModeSync	= 0;
-	GrabModeAsync	= 1;
+	GrabModeSync  = 0
+	GrabModeAsync = 1
 )
 
 const (
-	GrabStatusSuccess		= 0;
-	GrabStatusAlreadyGrabbed	= 1;
-	GrabStatusInvalidTime		= 2;
-	GrabStatusNotViewable		= 3;
-	GrabStatusFrozen		= 4;
+	GrabStatusSuccess        = 0
+	GrabStatusAlreadyGrabbed = 1
+	GrabStatusInvalidTime    = 2
+	GrabStatusNotViewable    = 3
+	GrabStatusFrozen         = 4
 )
 
 const (
-	CursorNone = 0;
+	CursorNone = 0
 )
 
 func (c *Conn) GrabPointerRequest(OwnerEvents byte, GrabWindow Id, EventMask uint16, PointerMode byte, KeyboardMode byte, ConfineTo Id, Cursor Id, Time Timestamp) Cookie {
-	b := c.scratch[0:24];
-	put16(b[2:], 6);
-	b[0] = 26;
-	b[1] = OwnerEvents;
-	put32(b[4:], uint32(GrabWindow));
-	put16(b[8:], EventMask);
-	b[10] = PointerMode;
-	b[11] = KeyboardMode;
-	put32(b[12:], uint32(ConfineTo));
-	put32(b[16:], uint32(Cursor));
-	put32(b[20:], uint32(Time));
-	return c.sendRequest(b);
+	b := c.scratch[0:24]
+	put16(b[2:], 6)
+	b[0] = 26
+	b[1] = OwnerEvents
+	put32(b[4:], uint32(GrabWindow))
+	put16(b[8:], EventMask)
+	b[10] = PointerMode
+	b[11] = KeyboardMode
+	put32(b[12:], uint32(ConfineTo))
+	put32(b[16:], uint32(Cursor))
+	put32(b[20:], uint32(Time))
+	return c.sendRequest(b)
 }
 
 func (c *Conn) GrabPointer(OwnerEvents byte, GrabWindow Id, EventMask uint16, PointerMode byte, KeyboardMode byte, ConfineTo Id, Cursor Id, Time Timestamp) (*GrabPointerReply, os.Error) {
@@ -1737,82 +1737,82 @@ func (c *Conn) GrabPointer(OwnerEvents byte, GrabWindow Id, EventMask uint16, Po
 }
 
 type GrabPointerReply struct {
-	Status byte;
+	Status byte
 }
 
 func (c *Conn) GrabPointerReply(cookie Cookie) (*GrabPointerReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(GrabPointerReply);
-	v.Status = b[1];
-	return v, nil;
+	v := new(GrabPointerReply)
+	v.Status = b[1]
+	return v, nil
 }
 
 func (c *Conn) UngrabPointer(Time Timestamp) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 27;
-	put32(b[4:], uint32(Time));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 27
+	put32(b[4:], uint32(Time))
+	c.sendRequest(b)
 }
 
 const (
-	ButtonIndexAny	= 0;
-	ButtonIndex1	= 1;
-	ButtonIndex2	= 2;
-	ButtonIndex3	= 3;
-	ButtonIndex4	= 4;
-	ButtonIndex5	= 5;
+	ButtonIndexAny = 0
+	ButtonIndex1   = 1
+	ButtonIndex2   = 2
+	ButtonIndex3   = 3
+	ButtonIndex4   = 4
+	ButtonIndex5   = 5
 )
 
 func (c *Conn) GrabButton(OwnerEvents byte, GrabWindow Id, EventMask uint16, PointerMode byte, KeyboardMode byte, ConfineTo Id, Cursor Id, Button byte, Modifiers uint16) {
-	b := c.scratch[0:24];
-	put16(b[2:], 6);
-	b[0] = 28;
-	b[1] = OwnerEvents;
-	put32(b[4:], uint32(GrabWindow));
-	put16(b[8:], EventMask);
-	b[10] = PointerMode;
-	b[11] = KeyboardMode;
-	put32(b[12:], uint32(ConfineTo));
-	put32(b[16:], uint32(Cursor));
-	b[20] = Button;
-	put16(b[22:], Modifiers);
-	c.sendRequest(b);
+	b := c.scratch[0:24]
+	put16(b[2:], 6)
+	b[0] = 28
+	b[1] = OwnerEvents
+	put32(b[4:], uint32(GrabWindow))
+	put16(b[8:], EventMask)
+	b[10] = PointerMode
+	b[11] = KeyboardMode
+	put32(b[12:], uint32(ConfineTo))
+	put32(b[16:], uint32(Cursor))
+	b[20] = Button
+	put16(b[22:], Modifiers)
+	c.sendRequest(b)
 }
 
 func (c *Conn) UngrabButton(Button byte, GrabWindow Id, Modifiers uint16) {
-	b := c.scratch[0:12];
-	put16(b[2:], 3);
-	b[0] = 29;
-	b[1] = Button;
-	put32(b[4:], uint32(GrabWindow));
-	put16(b[8:], Modifiers);
-	c.sendRequest(b);
+	b := c.scratch[0:12]
+	put16(b[2:], 3)
+	b[0] = 29
+	b[1] = Button
+	put32(b[4:], uint32(GrabWindow))
+	put16(b[8:], Modifiers)
+	c.sendRequest(b)
 }
 
 func (c *Conn) ChangeActivePointerGrab(Cursor Id, Time Timestamp, EventMask uint16) {
-	b := c.scratch[0:16];
-	put16(b[2:], 4);
-	b[0] = 30;
-	put32(b[4:], uint32(Cursor));
-	put32(b[8:], uint32(Time));
-	put16(b[12:], EventMask);
-	c.sendRequest(b);
+	b := c.scratch[0:16]
+	put16(b[2:], 4)
+	b[0] = 30
+	put32(b[4:], uint32(Cursor))
+	put32(b[8:], uint32(Time))
+	put16(b[12:], EventMask)
+	c.sendRequest(b)
 }
 
 func (c *Conn) GrabKeyboardRequest(OwnerEvents byte, GrabWindow Id, Time Timestamp, PointerMode byte, KeyboardMode byte) Cookie {
-	b := c.scratch[0:16];
-	put16(b[2:], 4);
-	b[0] = 31;
-	b[1] = OwnerEvents;
-	put32(b[4:], uint32(GrabWindow));
-	put32(b[8:], uint32(Time));
-	b[12] = PointerMode;
-	b[13] = KeyboardMode;
-	return c.sendRequest(b);
+	b := c.scratch[0:16]
+	put16(b[2:], 4)
+	b[0] = 31
+	b[1] = OwnerEvents
+	put32(b[4:], uint32(GrabWindow))
+	put32(b[8:], uint32(Time))
+	b[12] = PointerMode
+	b[13] = KeyboardMode
+	return c.sendRequest(b)
 }
 
 func (c *Conn) GrabKeyboard(OwnerEvents byte, GrabWindow Id, Time Timestamp, PointerMode byte, KeyboardMode byte) (*GrabKeyboardReply, os.Error) {
@@ -1820,94 +1820,94 @@ func (c *Conn) GrabKeyboard(OwnerEvents byte, GrabWindow Id, Time Timestamp, Poi
 }
 
 type GrabKeyboardReply struct {
-	Status byte;
+	Status byte
 }
 
 func (c *Conn) GrabKeyboardReply(cookie Cookie) (*GrabKeyboardReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(GrabKeyboardReply);
-	v.Status = b[1];
-	return v, nil;
+	v := new(GrabKeyboardReply)
+	v.Status = b[1]
+	return v, nil
 }
 
 func (c *Conn) UngrabKeyboard(Time Timestamp) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 32;
-	put32(b[4:], uint32(Time));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 32
+	put32(b[4:], uint32(Time))
+	c.sendRequest(b)
 }
 
 const (
-	GrabAny = 0;
+	GrabAny = 0
 )
 
 func (c *Conn) GrabKey(OwnerEvents byte, GrabWindow Id, Modifiers uint16, Key byte, PointerMode byte, KeyboardMode byte) {
-	b := c.scratch[0:16];
-	put16(b[2:], 4);
-	b[0] = 33;
-	b[1] = OwnerEvents;
-	put32(b[4:], uint32(GrabWindow));
-	put16(b[8:], Modifiers);
-	b[10] = Key;
-	b[11] = PointerMode;
-	b[12] = KeyboardMode;
-	c.sendRequest(b);
+	b := c.scratch[0:16]
+	put16(b[2:], 4)
+	b[0] = 33
+	b[1] = OwnerEvents
+	put32(b[4:], uint32(GrabWindow))
+	put16(b[8:], Modifiers)
+	b[10] = Key
+	b[11] = PointerMode
+	b[12] = KeyboardMode
+	c.sendRequest(b)
 }
 
 func (c *Conn) UngrabKey(Key byte, GrabWindow Id, Modifiers uint16) {
-	b := c.scratch[0:12];
-	put16(b[2:], 3);
-	b[0] = 34;
-	b[1] = Key;
-	put32(b[4:], uint32(GrabWindow));
-	put16(b[8:], Modifiers);
-	c.sendRequest(b);
+	b := c.scratch[0:12]
+	put16(b[2:], 3)
+	b[0] = 34
+	b[1] = Key
+	put32(b[4:], uint32(GrabWindow))
+	put16(b[8:], Modifiers)
+	c.sendRequest(b)
 }
 
 const (
-	AllowAsyncPointer	= 0;
-	AllowSyncPointer	= 1;
-	AllowReplayPointer	= 2;
-	AllowAsyncKeyboard	= 3;
-	AllowSyncKeyboard	= 4;
-	AllowReplayKeyboard	= 5;
-	AllowAsyncBoth		= 6;
-	AllowSyncBoth		= 7;
+	AllowAsyncPointer   = 0
+	AllowSyncPointer    = 1
+	AllowReplayPointer  = 2
+	AllowAsyncKeyboard  = 3
+	AllowSyncKeyboard   = 4
+	AllowReplayKeyboard = 5
+	AllowAsyncBoth      = 6
+	AllowSyncBoth       = 7
 )
 
 func (c *Conn) AllowEvents(Mode byte, Time Timestamp) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 35;
-	b[1] = Mode;
-	put32(b[4:], uint32(Time));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 35
+	b[1] = Mode
+	put32(b[4:], uint32(Time))
+	c.sendRequest(b)
 }
 
 func (c *Conn) GrabServer() {
-	b := c.scratch[0:4];
-	put16(b[2:], 1);
-	b[0] = 36;
-	c.sendRequest(b);
+	b := c.scratch[0:4]
+	put16(b[2:], 1)
+	b[0] = 36
+	c.sendRequest(b)
 }
 
 func (c *Conn) UngrabServer() {
-	b := c.scratch[0:4];
-	put16(b[2:], 1);
-	b[0] = 37;
-	c.sendRequest(b);
+	b := c.scratch[0:4]
+	put16(b[2:], 1)
+	b[0] = 37
+	c.sendRequest(b)
 }
 
 func (c *Conn) QueryPointerRequest(Window Id) Cookie {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 38;
-	put32(b[4:], uint32(Window));
-	return c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 38
+	put32(b[4:], uint32(Window))
+	return c.sendRequest(b)
 }
 
 func (c *Conn) QueryPointer(Window Id) (*QueryPointerReply, os.Error) {
@@ -1915,65 +1915,65 @@ func (c *Conn) QueryPointer(Window Id) (*QueryPointerReply, os.Error) {
 }
 
 type QueryPointerReply struct {
-	SameScreen	byte;
-	Root		Id;
-	Child		Id;
-	RootX		int16;
-	RootY		int16;
-	WinX		int16;
-	WinY		int16;
-	Mask		uint16;
+	SameScreen byte
+	Root       Id
+	Child      Id
+	RootX      int16
+	RootY      int16
+	WinX       int16
+	WinY       int16
+	Mask       uint16
 }
 
 func (c *Conn) QueryPointerReply(cookie Cookie) (*QueryPointerReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(QueryPointerReply);
-	v.SameScreen = b[1];
-	v.Root = Id(get32(b[8:]));
-	v.Child = Id(get32(b[12:]));
-	v.RootX = int16(get16(b[16:]));
-	v.RootY = int16(get16(b[18:]));
-	v.WinX = int16(get16(b[20:]));
-	v.WinY = int16(get16(b[22:]));
-	v.Mask = get16(b[24:]);
-	return v, nil;
+	v := new(QueryPointerReply)
+	v.SameScreen = b[1]
+	v.Root = Id(get32(b[8:]))
+	v.Child = Id(get32(b[12:]))
+	v.RootX = int16(get16(b[16:]))
+	v.RootY = int16(get16(b[18:]))
+	v.WinX = int16(get16(b[20:]))
+	v.WinY = int16(get16(b[22:]))
+	v.Mask = get16(b[24:])
+	return v, nil
 }
 
 type Timecoord struct {
-	Time	Timestamp;
-	X	int16;
-	Y	int16;
+	Time Timestamp
+	X    int16
+	Y    int16
 }
 
 func getTimecoord(b []byte, v *Timecoord) int {
-	v.Time = Timestamp(get32(b[0:]));
-	v.X = int16(get16(b[4:]));
-	v.Y = int16(get16(b[6:]));
-	return 8;
+	v.Time = Timestamp(get32(b[0:]))
+	v.X = int16(get16(b[4:]))
+	v.Y = int16(get16(b[6:]))
+	return 8
 }
 
 func (c *Conn) sendTimecoordList(list []Timecoord, count int) {
-	b0 := make([]byte, 8*count);
+	b0 := make([]byte, 8*count)
 	for k := 0; k < count; k++ {
-		b := b0[k*8:];
-		put32(b[0:], uint32(list[k].Time));
-		put16(b[4:], uint16(list[k].X));
-		put16(b[6:], uint16(list[k].Y));
+		b := b0[k*8:]
+		put32(b[0:], uint32(list[k].Time))
+		put16(b[4:], uint16(list[k].X))
+		put16(b[6:], uint16(list[k].Y))
 	}
-	c.sendBytes(b0);
+	c.sendBytes(b0)
 }
 
 func (c *Conn) GetMotionEventsRequest(Window Id, Start Timestamp, Stop Timestamp) Cookie {
-	b := c.scratch[0:16];
-	put16(b[2:], 4);
-	b[0] = 39;
-	put32(b[4:], uint32(Window));
-	put32(b[8:], uint32(Start));
-	put32(b[12:], uint32(Stop));
-	return c.sendRequest(b);
+	b := c.scratch[0:16]
+	put16(b[2:], 4)
+	b[0] = 39
+	put32(b[4:], uint32(Window))
+	put32(b[8:], uint32(Start))
+	put32(b[12:], uint32(Stop))
+	return c.sendRequest(b)
 }
 
 func (c *Conn) GetMotionEvents(Window Id, Start Timestamp, Stop Timestamp) (*GetMotionEventsReply, os.Error) {
@@ -1981,34 +1981,34 @@ func (c *Conn) GetMotionEvents(Window Id, Start Timestamp, Stop Timestamp) (*Get
 }
 
 type GetMotionEventsReply struct {
-	EventsLen	uint32;
-	Events		[]Timecoord;
+	EventsLen uint32
+	Events    []Timecoord
 }
 
 func (c *Conn) GetMotionEventsReply(cookie Cookie) (*GetMotionEventsReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(GetMotionEventsReply);
-	v.EventsLen = get32(b[8:]);
-	offset := 32;
-	v.Events = make([]Timecoord, int(v.EventsLen));
+	v := new(GetMotionEventsReply)
+	v.EventsLen = get32(b[8:])
+	offset := 32
+	v.Events = make([]Timecoord, int(v.EventsLen))
 	for i := 0; i < int(v.EventsLen); i++ {
 		offset += getTimecoord(b[offset:], &v.Events[i])
 	}
-	return v, nil;
+	return v, nil
 }
 
 func (c *Conn) TranslateCoordinatesRequest(SrcWindow Id, DstWindow Id, SrcX int16, SrcY int16) Cookie {
-	b := c.scratch[0:16];
-	put16(b[2:], 4);
-	b[0] = 40;
-	put32(b[4:], uint32(SrcWindow));
-	put32(b[8:], uint32(DstWindow));
-	put16(b[12:], uint16(SrcX));
-	put16(b[14:], uint16(SrcY));
-	return c.sendRequest(b);
+	b := c.scratch[0:16]
+	put16(b[2:], 4)
+	b[0] = 40
+	put32(b[4:], uint32(SrcWindow))
+	put32(b[8:], uint32(DstWindow))
+	put16(b[12:], uint16(SrcX))
+	put16(b[14:], uint16(SrcY))
+	return c.sendRequest(b)
 }
 
 func (c *Conn) TranslateCoordinates(SrcWindow Id, DstWindow Id, SrcX int16, SrcY int16) (*TranslateCoordinatesReply, os.Error) {
@@ -2016,62 +2016,62 @@ func (c *Conn) TranslateCoordinates(SrcWindow Id, DstWindow Id, SrcX int16, SrcY
 }
 
 type TranslateCoordinatesReply struct {
-	SameScreen	byte;
-	Child		Id;
-	DstX		uint16;
-	DstY		uint16;
+	SameScreen byte
+	Child      Id
+	DstX       uint16
+	DstY       uint16
 }
 
 func (c *Conn) TranslateCoordinatesReply(cookie Cookie) (*TranslateCoordinatesReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(TranslateCoordinatesReply);
-	v.SameScreen = b[1];
-	v.Child = Id(get32(b[8:]));
-	v.DstX = get16(b[12:]);
-	v.DstY = get16(b[14:]);
-	return v, nil;
+	v := new(TranslateCoordinatesReply)
+	v.SameScreen = b[1]
+	v.Child = Id(get32(b[8:]))
+	v.DstX = get16(b[12:])
+	v.DstY = get16(b[14:])
+	return v, nil
 }
 
 func (c *Conn) WarpPointer(SrcWindow Id, DstWindow Id, SrcX int16, SrcY int16, SrcWidth uint16, SrcHeight uint16, DstX int16, DstY int16) {
-	b := c.scratch[0:24];
-	put16(b[2:], 6);
-	b[0] = 41;
-	put32(b[4:], uint32(SrcWindow));
-	put32(b[8:], uint32(DstWindow));
-	put16(b[12:], uint16(SrcX));
-	put16(b[14:], uint16(SrcY));
-	put16(b[16:], SrcWidth);
-	put16(b[18:], SrcHeight);
-	put16(b[20:], uint16(DstX));
-	put16(b[22:], uint16(DstY));
-	c.sendRequest(b);
+	b := c.scratch[0:24]
+	put16(b[2:], 6)
+	b[0] = 41
+	put32(b[4:], uint32(SrcWindow))
+	put32(b[8:], uint32(DstWindow))
+	put16(b[12:], uint16(SrcX))
+	put16(b[14:], uint16(SrcY))
+	put16(b[16:], SrcWidth)
+	put16(b[18:], SrcHeight)
+	put16(b[20:], uint16(DstX))
+	put16(b[22:], uint16(DstY))
+	c.sendRequest(b)
 }
 
 const (
-	InputFocusNone			= 0;
-	InputFocusPointerRoot		= 1;
-	InputFocusParent		= 2;
-	InputFocusFollowKeyboard	= 3;
+	InputFocusNone           = 0
+	InputFocusPointerRoot    = 1
+	InputFocusParent         = 2
+	InputFocusFollowKeyboard = 3
 )
 
 func (c *Conn) SetInputFocus(RevertTo byte, Focus Id, Time Timestamp) {
-	b := c.scratch[0:12];
-	put16(b[2:], 3);
-	b[0] = 42;
-	b[1] = RevertTo;
-	put32(b[4:], uint32(Focus));
-	put32(b[8:], uint32(Time));
-	c.sendRequest(b);
+	b := c.scratch[0:12]
+	put16(b[2:], 3)
+	b[0] = 42
+	b[1] = RevertTo
+	put32(b[4:], uint32(Focus))
+	put32(b[8:], uint32(Time))
+	c.sendRequest(b)
 }
 
 func (c *Conn) GetInputFocusRequest() Cookie {
-	b := c.scratch[0:4];
-	put16(b[2:], 1);
-	b[0] = 43;
-	return c.sendRequest(b);
+	b := c.scratch[0:4]
+	put16(b[2:], 1)
+	b[0] = 43
+	return c.sendRequest(b)
 }
 
 func (c *Conn) GetInputFocus() (*GetInputFocusReply, os.Error) {
@@ -2079,26 +2079,26 @@ func (c *Conn) GetInputFocus() (*GetInputFocusReply, os.Error) {
 }
 
 type GetInputFocusReply struct {
-	RevertTo	byte;
-	Focus		Id;
+	RevertTo byte
+	Focus    Id
 }
 
 func (c *Conn) GetInputFocusReply(cookie Cookie) (*GetInputFocusReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(GetInputFocusReply);
-	v.RevertTo = b[1];
-	v.Focus = Id(get32(b[8:]));
-	return v, nil;
+	v := new(GetInputFocusReply)
+	v.RevertTo = b[1]
+	v.Focus = Id(get32(b[8:]))
+	return v, nil
 }
 
 func (c *Conn) QueryKeymapRequest() Cookie {
-	b := c.scratch[0:4];
-	put16(b[2:], 1);
-	b[0] = 44;
-	return c.sendRequest(b);
+	b := c.scratch[0:4]
+	put16(b[2:], 1)
+	b[0] = 44
+	return c.sendRequest(b)
 }
 
 func (c *Conn) QueryKeymap() (*QueryKeymapReply, os.Error) {
@@ -2106,104 +2106,104 @@ func (c *Conn) QueryKeymap() (*QueryKeymapReply, os.Error) {
 }
 
 type QueryKeymapReply struct {
-	Keys [32]byte;
+	Keys [32]byte
 }
 
 func (c *Conn) QueryKeymapReply(cookie Cookie) (*QueryKeymapReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(QueryKeymapReply);
-	copy(v.Keys[0:32], b[8:]);
-	return v, nil;
+	v := new(QueryKeymapReply)
+	copy(v.Keys[0:32], b[8:])
+	return v, nil
 }
 
 func (c *Conn) OpenFont(Fid Id, Name string) {
-	b := c.scratch[0:12];
-	n := 12;
-	n += pad(len(Name) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 45;
-	put32(b[4:], uint32(Fid));
-	put16(b[8:], uint16(len(Name)));
-	c.sendRequest(b);
-	c.sendString(Name);
+	b := c.scratch[0:12]
+	n := 12
+	n += pad(len(Name) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 45
+	put32(b[4:], uint32(Fid))
+	put16(b[8:], uint16(len(Name)))
+	c.sendRequest(b)
+	c.sendString(Name)
 }
 
 func (c *Conn) CloseFont(Font Id) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 46;
-	put32(b[4:], uint32(Font));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 46
+	put32(b[4:], uint32(Font))
+	c.sendRequest(b)
 }
 
 const (
-	FontDrawLeftToRight	= 0;
-	FontDrawRightToLeft	= 1;
+	FontDrawLeftToRight = 0
+	FontDrawRightToLeft = 1
 )
 
 type Fontprop struct {
-	Name	Id;
-	Value	uint32;
+	Name  Id
+	Value uint32
 }
 
 func getFontprop(b []byte, v *Fontprop) int {
-	v.Name = Id(get32(b[0:]));
-	v.Value = get32(b[4:]);
-	return 8;
+	v.Name = Id(get32(b[0:]))
+	v.Value = get32(b[4:])
+	return 8
 }
 
 func (c *Conn) sendFontpropList(list []Fontprop, count int) {
-	b0 := make([]byte, 8*count);
+	b0 := make([]byte, 8*count)
 	for k := 0; k < count; k++ {
-		b := b0[k*8:];
-		put32(b[0:], uint32(list[k].Name));
-		put32(b[4:], list[k].Value);
+		b := b0[k*8:]
+		put32(b[0:], uint32(list[k].Name))
+		put32(b[4:], list[k].Value)
 	}
-	c.sendBytes(b0);
+	c.sendBytes(b0)
 }
 
 type Charinfo struct {
-	LeftSideBearing		int16;
-	RightSideBearing	int16;
-	CharacterWidth		int16;
-	Ascent			int16;
-	Descent			int16;
-	Attributes		uint16;
+	LeftSideBearing  int16
+	RightSideBearing int16
+	CharacterWidth   int16
+	Ascent           int16
+	Descent          int16
+	Attributes       uint16
 }
 
 func getCharinfo(b []byte, v *Charinfo) int {
-	v.LeftSideBearing = int16(get16(b[0:]));
-	v.RightSideBearing = int16(get16(b[2:]));
-	v.CharacterWidth = int16(get16(b[4:]));
-	v.Ascent = int16(get16(b[6:]));
-	v.Descent = int16(get16(b[8:]));
-	v.Attributes = get16(b[10:]);
-	return 12;
+	v.LeftSideBearing = int16(get16(b[0:]))
+	v.RightSideBearing = int16(get16(b[2:]))
+	v.CharacterWidth = int16(get16(b[4:]))
+	v.Ascent = int16(get16(b[6:]))
+	v.Descent = int16(get16(b[8:]))
+	v.Attributes = get16(b[10:])
+	return 12
 }
 
 func (c *Conn) sendCharinfoList(list []Charinfo, count int) {
-	b0 := make([]byte, 12*count);
+	b0 := make([]byte, 12*count)
 	for k := 0; k < count; k++ {
-		b := b0[k*12:];
-		put16(b[0:], uint16(list[k].LeftSideBearing));
-		put16(b[2:], uint16(list[k].RightSideBearing));
-		put16(b[4:], uint16(list[k].CharacterWidth));
-		put16(b[6:], uint16(list[k].Ascent));
-		put16(b[8:], uint16(list[k].Descent));
-		put16(b[10:], list[k].Attributes);
+		b := b0[k*12:]
+		put16(b[0:], uint16(list[k].LeftSideBearing))
+		put16(b[2:], uint16(list[k].RightSideBearing))
+		put16(b[4:], uint16(list[k].CharacterWidth))
+		put16(b[6:], uint16(list[k].Ascent))
+		put16(b[8:], uint16(list[k].Descent))
+		put16(b[10:], list[k].Attributes)
 	}
-	c.sendBytes(b0);
+	c.sendBytes(b0)
 }
 
 func (c *Conn) QueryFontRequest(Font Id) Cookie {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 47;
-	put32(b[4:], uint32(Font));
-	return c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 47
+	put32(b[4:], uint32(Font))
+	return c.sendRequest(b)
 }
 
 func (c *Conn) QueryFont(Font Id) (*QueryFontReply, os.Error) {
@@ -2211,66 +2211,66 @@ func (c *Conn) QueryFont(Font Id) (*QueryFontReply, os.Error) {
 }
 
 type QueryFontReply struct {
-	MinBounds	Charinfo;
-	MaxBounds	Charinfo;
-	MinCharOrByte2	uint16;
-	MaxCharOrByte2	uint16;
-	DefaultChar	uint16;
-	PropertiesLen	uint16;
-	DrawDirection	byte;
-	MinByte1	byte;
-	MaxByte1	byte;
-	AllCharsExist	byte;
-	FontAscent	int16;
-	FontDescent	int16;
-	CharInfosLen	uint32;
-	Properties	[]Fontprop;
-	CharInfos	[]Charinfo;
+	MinBounds      Charinfo
+	MaxBounds      Charinfo
+	MinCharOrByte2 uint16
+	MaxCharOrByte2 uint16
+	DefaultChar    uint16
+	PropertiesLen  uint16
+	DrawDirection  byte
+	MinByte1       byte
+	MaxByte1       byte
+	AllCharsExist  byte
+	FontAscent     int16
+	FontDescent    int16
+	CharInfosLen   uint32
+	Properties     []Fontprop
+	CharInfos      []Charinfo
 }
 
 func (c *Conn) QueryFontReply(cookie Cookie) (*QueryFontReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(QueryFontReply);
-	getCharinfo(b[8:], &v.MinBounds);
-	getCharinfo(b[24:], &v.MaxBounds);
-	v.MinCharOrByte2 = get16(b[40:]);
-	v.MaxCharOrByte2 = get16(b[42:]);
-	v.DefaultChar = get16(b[44:]);
-	v.PropertiesLen = get16(b[46:]);
-	v.DrawDirection = b[48];
-	v.MinByte1 = b[49];
-	v.MaxByte1 = b[50];
-	v.AllCharsExist = b[51];
-	v.FontAscent = int16(get16(b[52:]));
-	v.FontDescent = int16(get16(b[54:]));
-	v.CharInfosLen = get32(b[56:]);
-	offset := 60;
-	v.Properties = make([]Fontprop, int(v.PropertiesLen));
+	v := new(QueryFontReply)
+	getCharinfo(b[8:], &v.MinBounds)
+	getCharinfo(b[24:], &v.MaxBounds)
+	v.MinCharOrByte2 = get16(b[40:])
+	v.MaxCharOrByte2 = get16(b[42:])
+	v.DefaultChar = get16(b[44:])
+	v.PropertiesLen = get16(b[46:])
+	v.DrawDirection = b[48]
+	v.MinByte1 = b[49]
+	v.MaxByte1 = b[50]
+	v.AllCharsExist = b[51]
+	v.FontAscent = int16(get16(b[52:]))
+	v.FontDescent = int16(get16(b[54:]))
+	v.CharInfosLen = get32(b[56:])
+	offset := 60
+	v.Properties = make([]Fontprop, int(v.PropertiesLen))
 	for i := 0; i < int(v.PropertiesLen); i++ {
 		offset += getFontprop(b[offset:], &v.Properties[i])
 	}
-	offset = pad(offset);
-	v.CharInfos = make([]Charinfo, int(v.CharInfosLen));
+	offset = pad(offset)
+	v.CharInfos = make([]Charinfo, int(v.CharInfosLen))
 	for i := 0; i < int(v.CharInfosLen); i++ {
 		offset += getCharinfo(b[offset:], &v.CharInfos[i])
 	}
-	return v, nil;
+	return v, nil
 }
 
 func (c *Conn) QueryTextExtentsRequest(Font Id, String []Char2b) Cookie {
-	b := c.scratch[0:8];
-	n := 8;
-	n += pad(len(String) * 2);
-	put16(b[2:], uint16(n/4));
-	b[0] = 48;
-	b[1] = byte((len(String) & 1));
-	put32(b[4:], uint32(Font));
-	cookie := c.sendRequest(b);
-	c.sendChar2bList(String, len(String));
-	return cookie;
+	b := c.scratch[0:8]
+	n := 8
+	n += pad(len(String) * 2)
+	put16(b[2:], uint16(n/4))
+	b[0] = 48
+	b[1] = byte((len(String) & 1))
+	put32(b[4:], uint32(Font))
+	cookie := c.sendRequest(b)
+	c.sendChar2bList(String, len(String))
+	return cookie
 }
 
 func (c *Conn) QueryTextExtents(Font Id, String []Char2b) (*QueryTextExtentsReply, os.Error) {
@@ -2278,60 +2278,60 @@ func (c *Conn) QueryTextExtents(Font Id, String []Char2b) (*QueryTextExtentsRepl
 }
 
 type QueryTextExtentsReply struct {
-	DrawDirection	byte;
-	FontAscent	int16;
-	FontDescent	int16;
-	OverallAscent	int16;
-	OverallDescent	int16;
-	OverallWidth	int32;
-	OverallLeft	int32;
-	OverallRight	int32;
+	DrawDirection  byte
+	FontAscent     int16
+	FontDescent    int16
+	OverallAscent  int16
+	OverallDescent int16
+	OverallWidth   int32
+	OverallLeft    int32
+	OverallRight   int32
 }
 
 func (c *Conn) QueryTextExtentsReply(cookie Cookie) (*QueryTextExtentsReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(QueryTextExtentsReply);
-	v.DrawDirection = b[1];
-	v.FontAscent = int16(get16(b[8:]));
-	v.FontDescent = int16(get16(b[10:]));
-	v.OverallAscent = int16(get16(b[12:]));
-	v.OverallDescent = int16(get16(b[14:]));
-	v.OverallWidth = int32(get32(b[16:]));
-	v.OverallLeft = int32(get32(b[20:]));
-	v.OverallRight = int32(get32(b[24:]));
-	return v, nil;
+	v := new(QueryTextExtentsReply)
+	v.DrawDirection = b[1]
+	v.FontAscent = int16(get16(b[8:]))
+	v.FontDescent = int16(get16(b[10:]))
+	v.OverallAscent = int16(get16(b[12:]))
+	v.OverallDescent = int16(get16(b[14:]))
+	v.OverallWidth = int32(get32(b[16:]))
+	v.OverallLeft = int32(get32(b[20:]))
+	v.OverallRight = int32(get32(b[24:]))
+	return v, nil
 }
 
 type Str struct {
-	NameLen	byte;
-	Name	[]byte;
+	NameLen byte
+	Name    []byte
 }
 
 func getStr(b []byte, v *Str) int {
-	v.NameLen = b[0];
-	offset := 1;
-	v.Name = make([]byte, int(v.NameLen));
-	copy(v.Name[0:len(v.Name)], b[offset:]);
-	offset += len(v.Name) * 1;
-	return offset;
+	v.NameLen = b[0]
+	offset := 1
+	v.Name = make([]byte, int(v.NameLen))
+	copy(v.Name[0:len(v.Name)], b[offset:])
+	offset += len(v.Name) * 1
+	return offset
 }
 
 // omitting variable length sendStr
 
 func (c *Conn) ListFontsRequest(MaxNames uint16, Pattern []byte) Cookie {
-	b := c.scratch[0:8];
-	n := 8;
-	n += pad(len(Pattern) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 49;
-	put16(b[4:], MaxNames);
-	put16(b[6:], uint16(len(Pattern)));
-	cookie := c.sendRequest(b);
-	c.sendBytes(Pattern[0:len(Pattern)]);
-	return cookie;
+	b := c.scratch[0:8]
+	n := 8
+	n += pad(len(Pattern) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 49
+	put16(b[4:], MaxNames)
+	put16(b[6:], uint16(len(Pattern)))
+	cookie := c.sendRequest(b)
+	c.sendBytes(Pattern[0:len(Pattern)])
+	return cookie
 }
 
 func (c *Conn) ListFonts(MaxNames uint16, Pattern []byte) (*ListFontsReply, os.Error) {
@@ -2339,36 +2339,36 @@ func (c *Conn) ListFonts(MaxNames uint16, Pattern []byte) (*ListFontsReply, os.E
 }
 
 type ListFontsReply struct {
-	NamesLen	uint16;
-	Names		[]Str;
+	NamesLen uint16
+	Names    []Str
 }
 
 func (c *Conn) ListFontsReply(cookie Cookie) (*ListFontsReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(ListFontsReply);
-	v.NamesLen = get16(b[8:]);
-	offset := 32;
-	v.Names = make([]Str, int(v.NamesLen));
+	v := new(ListFontsReply)
+	v.NamesLen = get16(b[8:])
+	offset := 32
+	v.Names = make([]Str, int(v.NamesLen))
 	for i := 0; i < int(v.NamesLen); i++ {
 		offset += getStr(b[offset:], &v.Names[i])
 	}
-	return v, nil;
+	return v, nil
 }
 
 func (c *Conn) ListFontsWithInfoRequest(MaxNames uint16, Pattern []byte) Cookie {
-	b := c.scratch[0:8];
-	n := 8;
-	n += pad(len(Pattern) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 50;
-	put16(b[4:], MaxNames);
-	put16(b[6:], uint16(len(Pattern)));
-	cookie := c.sendRequest(b);
-	c.sendBytes(Pattern[0:len(Pattern)]);
-	return cookie;
+	b := c.scratch[0:8]
+	n := 8
+	n += pad(len(Pattern) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 50
+	put16(b[4:], MaxNames)
+	put16(b[6:], uint16(len(Pattern)))
+	cookie := c.sendRequest(b)
+	c.sendBytes(Pattern[0:len(Pattern)])
+	return cookie
 }
 
 func (c *Conn) ListFontsWithInfo(MaxNames uint16, Pattern []byte) (*ListFontsWithInfoReply, os.Error) {
@@ -2376,72 +2376,72 @@ func (c *Conn) ListFontsWithInfo(MaxNames uint16, Pattern []byte) (*ListFontsWit
 }
 
 type ListFontsWithInfoReply struct {
-	NameLen		byte;
-	MinBounds	Charinfo;
-	MaxBounds	Charinfo;
-	MinCharOrByte2	uint16;
-	MaxCharOrByte2	uint16;
-	DefaultChar	uint16;
-	PropertiesLen	uint16;
-	DrawDirection	byte;
-	MinByte1	byte;
-	MaxByte1	byte;
-	AllCharsExist	byte;
-	FontAscent	int16;
-	FontDescent	int16;
-	RepliesHint	uint32;
-	Properties	[]Fontprop;
-	Name		[]byte;
+	NameLen        byte
+	MinBounds      Charinfo
+	MaxBounds      Charinfo
+	MinCharOrByte2 uint16
+	MaxCharOrByte2 uint16
+	DefaultChar    uint16
+	PropertiesLen  uint16
+	DrawDirection  byte
+	MinByte1       byte
+	MaxByte1       byte
+	AllCharsExist  byte
+	FontAscent     int16
+	FontDescent    int16
+	RepliesHint    uint32
+	Properties     []Fontprop
+	Name           []byte
 }
 
 func (c *Conn) ListFontsWithInfoReply(cookie Cookie) (*ListFontsWithInfoReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(ListFontsWithInfoReply);
-	v.NameLen = b[1];
-	getCharinfo(b[8:], &v.MinBounds);
-	getCharinfo(b[24:], &v.MaxBounds);
-	v.MinCharOrByte2 = get16(b[40:]);
-	v.MaxCharOrByte2 = get16(b[42:]);
-	v.DefaultChar = get16(b[44:]);
-	v.PropertiesLen = get16(b[46:]);
-	v.DrawDirection = b[48];
-	v.MinByte1 = b[49];
-	v.MaxByte1 = b[50];
-	v.AllCharsExist = b[51];
-	v.FontAscent = int16(get16(b[52:]));
-	v.FontDescent = int16(get16(b[54:]));
-	v.RepliesHint = get32(b[56:]);
-	offset := 60;
-	v.Properties = make([]Fontprop, int(v.PropertiesLen));
+	v := new(ListFontsWithInfoReply)
+	v.NameLen = b[1]
+	getCharinfo(b[8:], &v.MinBounds)
+	getCharinfo(b[24:], &v.MaxBounds)
+	v.MinCharOrByte2 = get16(b[40:])
+	v.MaxCharOrByte2 = get16(b[42:])
+	v.DefaultChar = get16(b[44:])
+	v.PropertiesLen = get16(b[46:])
+	v.DrawDirection = b[48]
+	v.MinByte1 = b[49]
+	v.MaxByte1 = b[50]
+	v.AllCharsExist = b[51]
+	v.FontAscent = int16(get16(b[52:]))
+	v.FontDescent = int16(get16(b[54:]))
+	v.RepliesHint = get32(b[56:])
+	offset := 60
+	v.Properties = make([]Fontprop, int(v.PropertiesLen))
 	for i := 0; i < int(v.PropertiesLen); i++ {
 		offset += getFontprop(b[offset:], &v.Properties[i])
 	}
-	offset = pad(offset);
-	v.Name = make([]byte, int(v.NameLen));
-	copy(v.Name[0:len(v.Name)], b[offset:]);
-	offset += len(v.Name) * 1;
-	return v, nil;
+	offset = pad(offset)
+	v.Name = make([]byte, int(v.NameLen))
+	copy(v.Name[0:len(v.Name)], b[offset:])
+	offset += len(v.Name) * 1
+	return v, nil
 }
 
 func (c *Conn) SetFontPath(FontQty uint16, Path []byte) {
-	b := c.scratch[0:6];
-	n := 6;
-	n += pad(len(Path) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 51;
-	put16(b[4:], FontQty);
-	c.sendRequest(b);
-	c.sendBytes(Path[0:len(Path)]);
+	b := c.scratch[0:6]
+	n := 6
+	n += pad(len(Path) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 51
+	put16(b[4:], FontQty)
+	c.sendRequest(b)
+	c.sendBytes(Path[0:len(Path)])
 }
 
 func (c *Conn) GetFontPathRequest() Cookie {
-	b := c.scratch[0:4];
-	put16(b[2:], 1);
-	b[0] = 52;
-	return c.sendRequest(b);
+	b := c.scratch[0:4]
+	put16(b[2:], 1)
+	b[0] = 52
+	return c.sendRequest(b)
 }
 
 func (c *Conn) GetFontPath() (*GetFontPathReply, os.Error) {
@@ -2449,429 +2449,429 @@ func (c *Conn) GetFontPath() (*GetFontPathReply, os.Error) {
 }
 
 type GetFontPathReply struct {
-	PathLen	uint16;
-	Path	[]Str;
+	PathLen uint16
+	Path    []Str
 }
 
 func (c *Conn) GetFontPathReply(cookie Cookie) (*GetFontPathReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(GetFontPathReply);
-	v.PathLen = get16(b[8:]);
-	offset := 32;
-	v.Path = make([]Str, int(v.PathLen));
+	v := new(GetFontPathReply)
+	v.PathLen = get16(b[8:])
+	offset := 32
+	v.Path = make([]Str, int(v.PathLen))
 	for i := 0; i < int(v.PathLen); i++ {
 		offset += getStr(b[offset:], &v.Path[i])
 	}
-	return v, nil;
+	return v, nil
 }
 
 func (c *Conn) CreatePixmap(Depth byte, Pid Id, Drawable Id, Width uint16, Height uint16) {
-	b := c.scratch[0:16];
-	put16(b[2:], 4);
-	b[0] = 53;
-	b[1] = Depth;
-	put32(b[4:], uint32(Pid));
-	put32(b[8:], uint32(Drawable));
-	put16(b[12:], Width);
-	put16(b[14:], Height);
-	c.sendRequest(b);
+	b := c.scratch[0:16]
+	put16(b[2:], 4)
+	b[0] = 53
+	b[1] = Depth
+	put32(b[4:], uint32(Pid))
+	put32(b[8:], uint32(Drawable))
+	put16(b[12:], Width)
+	put16(b[14:], Height)
+	c.sendRequest(b)
 }
 
 func (c *Conn) FreePixmap(Pixmap Id) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 54;
-	put32(b[4:], uint32(Pixmap));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 54
+	put32(b[4:], uint32(Pixmap))
+	c.sendRequest(b)
 }
 
 const (
-	GCFunction		= 1;
-	GCPlaneMask		= 2;
-	GCForeground		= 4;
-	GCBackground		= 8;
-	GCLineWidth		= 16;
-	GCLineStyle		= 32;
-	GCCapStyle		= 64;
-	GCJoinStyle		= 128;
-	GCFillStyle		= 256;
-	GCFillRule		= 512;
-	GCTile			= 1024;
-	GCStipple		= 2048;
-	GCTileStippleOriginX	= 4096;
-	GCTileStippleOriginY	= 8192;
-	GCFont			= 16384;
-	GCSubwindowMode		= 32768;
-	GCGraphicsExposures	= 65536;
-	GCClipOriginX		= 131072;
-	GCClipOriginY		= 262144;
-	GCClipMask		= 524288;
-	GCDashOffset		= 1048576;
-	GCDashList		= 2097152;
-	GCArcMode		= 4194304;
+	GCFunction           = 1
+	GCPlaneMask          = 2
+	GCForeground         = 4
+	GCBackground         = 8
+	GCLineWidth          = 16
+	GCLineStyle          = 32
+	GCCapStyle           = 64
+	GCJoinStyle          = 128
+	GCFillStyle          = 256
+	GCFillRule           = 512
+	GCTile               = 1024
+	GCStipple            = 2048
+	GCTileStippleOriginX = 4096
+	GCTileStippleOriginY = 8192
+	GCFont               = 16384
+	GCSubwindowMode      = 32768
+	GCGraphicsExposures  = 65536
+	GCClipOriginX        = 131072
+	GCClipOriginY        = 262144
+	GCClipMask           = 524288
+	GCDashOffset         = 1048576
+	GCDashList           = 2097152
+	GCArcMode            = 4194304
 )
 
 const (
-	GXClear		= 0;
-	GXAnd		= 1;
-	GXAndReverse	= 2;
-	GXCopy		= 3;
-	GXAndInverted	= 4;
-	GXNoop		= 5;
-	GXXor		= 6;
-	GXOr		= 7;
-	GXNor		= 8;
-	GXEquiv		= 9;
-	GXInvert	= 10;
-	GXOrReverse	= 11;
-	GXCopyInverted	= 12;
-	GXOrInverted	= 13;
-	GXNand		= 14;
-	GXSet		= 15;
+	GXClear        = 0
+	GXAnd          = 1
+	GXAndReverse   = 2
+	GXCopy         = 3
+	GXAndInverted  = 4
+	GXNoop         = 5
+	GXXor          = 6
+	GXOr           = 7
+	GXNor          = 8
+	GXEquiv        = 9
+	GXInvert       = 10
+	GXOrReverse    = 11
+	GXCopyInverted = 12
+	GXOrInverted   = 13
+	GXNand         = 14
+	GXSet          = 15
 )
 
 const (
-	LineStyleSolid		= 0;
-	LineStyleOnOffDash	= 1;
-	LineStyleDoubleDash	= 2;
+	LineStyleSolid      = 0
+	LineStyleOnOffDash  = 1
+	LineStyleDoubleDash = 2
 )
 
 const (
-	CapStyleNotLast		= 0;
-	CapStyleButt		= 1;
-	CapStyleRound		= 2;
-	CapStyleProjecting	= 3;
+	CapStyleNotLast    = 0
+	CapStyleButt       = 1
+	CapStyleRound      = 2
+	CapStyleProjecting = 3
 )
 
 const (
-	JoinStyleMiter	= 0;
-	JoinStyleRound	= 1;
-	JoinStyleBevel	= 2;
+	JoinStyleMiter = 0
+	JoinStyleRound = 1
+	JoinStyleBevel = 2
 )
 
 const (
-	FillStyleSolid		= 0;
-	FillStyleTiled		= 1;
-	FillStyleStippled	= 2;
-	FillStyleOpaqueStippled	= 3;
+	FillStyleSolid          = 0
+	FillStyleTiled          = 1
+	FillStyleStippled       = 2
+	FillStyleOpaqueStippled = 3
 )
 
 const (
-	FillRuleEvenOdd	= 0;
-	FillRuleWinding	= 1;
+	FillRuleEvenOdd = 0
+	FillRuleWinding = 1
 )
 
 const (
-	SubwindowModeClipByChildren	= 0;
-	SubwindowModeIncludeInferiors	= 1;
+	SubwindowModeClipByChildren   = 0
+	SubwindowModeIncludeInferiors = 1
 )
 
 const (
-	ArcModeChord	= 0;
-	ArcModePieSlice	= 1;
+	ArcModeChord    = 0
+	ArcModePieSlice = 1
 )
 
 func (c *Conn) CreateGC(Cid Id, Drawable Id, ValueMask uint32, ValueList []uint32) {
-	b := c.scratch[0:16];
-	n := 16;
-	n += pad(popCount(int(ValueMask)) * 4);
-	put16(b[2:], uint16(n/4));
-	b[0] = 55;
-	put32(b[4:], uint32(Cid));
-	put32(b[8:], uint32(Drawable));
-	put32(b[12:], ValueMask);
-	c.sendRequest(b);
-	c.sendUInt32List(ValueList[0:popCount(int(ValueMask))]);
+	b := c.scratch[0:16]
+	n := 16
+	n += pad(popCount(int(ValueMask)) * 4)
+	put16(b[2:], uint16(n/4))
+	b[0] = 55
+	put32(b[4:], uint32(Cid))
+	put32(b[8:], uint32(Drawable))
+	put32(b[12:], ValueMask)
+	c.sendRequest(b)
+	c.sendUInt32List(ValueList[0:popCount(int(ValueMask))])
 }
 
 func (c *Conn) ChangeGC(Gc Id, ValueMask uint32, ValueList []uint32) {
-	b := c.scratch[0:12];
-	n := 12;
-	n += pad(popCount(int(ValueMask)) * 4);
-	put16(b[2:], uint16(n/4));
-	b[0] = 56;
-	put32(b[4:], uint32(Gc));
-	put32(b[8:], ValueMask);
-	c.sendRequest(b);
-	c.sendUInt32List(ValueList[0:popCount(int(ValueMask))]);
+	b := c.scratch[0:12]
+	n := 12
+	n += pad(popCount(int(ValueMask)) * 4)
+	put16(b[2:], uint16(n/4))
+	b[0] = 56
+	put32(b[4:], uint32(Gc))
+	put32(b[8:], ValueMask)
+	c.sendRequest(b)
+	c.sendUInt32List(ValueList[0:popCount(int(ValueMask))])
 }
 
 func (c *Conn) CopyGC(SrcGc Id, DstGc Id, ValueMask uint32) {
-	b := c.scratch[0:16];
-	put16(b[2:], 4);
-	b[0] = 57;
-	put32(b[4:], uint32(SrcGc));
-	put32(b[8:], uint32(DstGc));
-	put32(b[12:], ValueMask);
-	c.sendRequest(b);
+	b := c.scratch[0:16]
+	put16(b[2:], 4)
+	b[0] = 57
+	put32(b[4:], uint32(SrcGc))
+	put32(b[8:], uint32(DstGc))
+	put32(b[12:], ValueMask)
+	c.sendRequest(b)
 }
 
 func (c *Conn) SetDashes(Gc Id, DashOffset uint16, Dashes []byte) {
-	b := c.scratch[0:12];
-	n := 12;
-	n += pad(len(Dashes) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 58;
-	put32(b[4:], uint32(Gc));
-	put16(b[8:], DashOffset);
-	put16(b[10:], uint16(len(Dashes)));
-	c.sendRequest(b);
-	c.sendBytes(Dashes[0:len(Dashes)]);
+	b := c.scratch[0:12]
+	n := 12
+	n += pad(len(Dashes) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 58
+	put32(b[4:], uint32(Gc))
+	put16(b[8:], DashOffset)
+	put16(b[10:], uint16(len(Dashes)))
+	c.sendRequest(b)
+	c.sendBytes(Dashes[0:len(Dashes)])
 }
 
 const (
-	ClipOrderingUnsorted	= 0;
-	ClipOrderingYSorted	= 1;
-	ClipOrderingYXSorted	= 2;
-	ClipOrderingYXBanded	= 3;
+	ClipOrderingUnsorted = 0
+	ClipOrderingYSorted  = 1
+	ClipOrderingYXSorted = 2
+	ClipOrderingYXBanded = 3
 )
 
 func (c *Conn) SetClipRectangles(Ordering byte, Gc Id, ClipXOrigin int16, ClipYOrigin int16, Rectangles []Rectangle) {
-	b := c.scratch[0:12];
-	n := 12;
-	n += pad(len(Rectangles) * 8);
-	put16(b[2:], uint16(n/4));
-	b[0] = 59;
-	b[1] = Ordering;
-	put32(b[4:], uint32(Gc));
-	put16(b[8:], uint16(ClipXOrigin));
-	put16(b[10:], uint16(ClipYOrigin));
-	c.sendRequest(b);
-	c.sendRectangleList(Rectangles, len(Rectangles));
+	b := c.scratch[0:12]
+	n := 12
+	n += pad(len(Rectangles) * 8)
+	put16(b[2:], uint16(n/4))
+	b[0] = 59
+	b[1] = Ordering
+	put32(b[4:], uint32(Gc))
+	put16(b[8:], uint16(ClipXOrigin))
+	put16(b[10:], uint16(ClipYOrigin))
+	c.sendRequest(b)
+	c.sendRectangleList(Rectangles, len(Rectangles))
 }
 
 func (c *Conn) FreeGC(Gc Id) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 60;
-	put32(b[4:], uint32(Gc));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 60
+	put32(b[4:], uint32(Gc))
+	c.sendRequest(b)
 }
 
 func (c *Conn) ClearArea(Exposures byte, Window Id, X int16, Y int16, Width uint16, Height uint16) {
-	b := c.scratch[0:16];
-	put16(b[2:], 4);
-	b[0] = 61;
-	b[1] = Exposures;
-	put32(b[4:], uint32(Window));
-	put16(b[8:], uint16(X));
-	put16(b[10:], uint16(Y));
-	put16(b[12:], Width);
-	put16(b[14:], Height);
-	c.sendRequest(b);
+	b := c.scratch[0:16]
+	put16(b[2:], 4)
+	b[0] = 61
+	b[1] = Exposures
+	put32(b[4:], uint32(Window))
+	put16(b[8:], uint16(X))
+	put16(b[10:], uint16(Y))
+	put16(b[12:], Width)
+	put16(b[14:], Height)
+	c.sendRequest(b)
 }
 
 func (c *Conn) CopyArea(SrcDrawable Id, DstDrawable Id, Gc Id, SrcX int16, SrcY int16, DstX int16, DstY int16, Width uint16, Height uint16) {
-	b := c.scratch[0:28];
-	put16(b[2:], 7);
-	b[0] = 62;
-	put32(b[4:], uint32(SrcDrawable));
-	put32(b[8:], uint32(DstDrawable));
-	put32(b[12:], uint32(Gc));
-	put16(b[16:], uint16(SrcX));
-	put16(b[18:], uint16(SrcY));
-	put16(b[20:], uint16(DstX));
-	put16(b[22:], uint16(DstY));
-	put16(b[24:], Width);
-	put16(b[26:], Height);
-	c.sendRequest(b);
+	b := c.scratch[0:28]
+	put16(b[2:], 7)
+	b[0] = 62
+	put32(b[4:], uint32(SrcDrawable))
+	put32(b[8:], uint32(DstDrawable))
+	put32(b[12:], uint32(Gc))
+	put16(b[16:], uint16(SrcX))
+	put16(b[18:], uint16(SrcY))
+	put16(b[20:], uint16(DstX))
+	put16(b[22:], uint16(DstY))
+	put16(b[24:], Width)
+	put16(b[26:], Height)
+	c.sendRequest(b)
 }
 
 func (c *Conn) CopyPlane(SrcDrawable Id, DstDrawable Id, Gc Id, SrcX int16, SrcY int16, DstX int16, DstY int16, Width uint16, Height uint16, BitPlane uint32) {
-	b := c.scratch[0:32];
-	put16(b[2:], 8);
-	b[0] = 63;
-	put32(b[4:], uint32(SrcDrawable));
-	put32(b[8:], uint32(DstDrawable));
-	put32(b[12:], uint32(Gc));
-	put16(b[16:], uint16(SrcX));
-	put16(b[18:], uint16(SrcY));
-	put16(b[20:], uint16(DstX));
-	put16(b[22:], uint16(DstY));
-	put16(b[24:], Width);
-	put16(b[26:], Height);
-	put32(b[28:], BitPlane);
-	c.sendRequest(b);
+	b := c.scratch[0:32]
+	put16(b[2:], 8)
+	b[0] = 63
+	put32(b[4:], uint32(SrcDrawable))
+	put32(b[8:], uint32(DstDrawable))
+	put32(b[12:], uint32(Gc))
+	put16(b[16:], uint16(SrcX))
+	put16(b[18:], uint16(SrcY))
+	put16(b[20:], uint16(DstX))
+	put16(b[22:], uint16(DstY))
+	put16(b[24:], Width)
+	put16(b[26:], Height)
+	put32(b[28:], BitPlane)
+	c.sendRequest(b)
 }
 
 const (
-	CoordModeOrigin		= 0;
-	CoordModePrevious	= 1;
+	CoordModeOrigin   = 0
+	CoordModePrevious = 1
 )
 
 func (c *Conn) PolyPoint(CoordinateMode byte, Drawable Id, Gc Id, Points []Point) {
-	b := c.scratch[0:12];
-	n := 12;
-	n += pad(len(Points) * 4);
-	put16(b[2:], uint16(n/4));
-	b[0] = 64;
-	b[1] = CoordinateMode;
-	put32(b[4:], uint32(Drawable));
-	put32(b[8:], uint32(Gc));
-	c.sendRequest(b);
-	c.sendPointList(Points, len(Points));
+	b := c.scratch[0:12]
+	n := 12
+	n += pad(len(Points) * 4)
+	put16(b[2:], uint16(n/4))
+	b[0] = 64
+	b[1] = CoordinateMode
+	put32(b[4:], uint32(Drawable))
+	put32(b[8:], uint32(Gc))
+	c.sendRequest(b)
+	c.sendPointList(Points, len(Points))
 }
 
 func (c *Conn) PolyLine(CoordinateMode byte, Drawable Id, Gc Id, Points []Point) {
-	b := c.scratch[0:12];
-	n := 12;
-	n += pad(len(Points) * 4);
-	put16(b[2:], uint16(n/4));
-	b[0] = 65;
-	b[1] = CoordinateMode;
-	put32(b[4:], uint32(Drawable));
-	put32(b[8:], uint32(Gc));
-	c.sendRequest(b);
-	c.sendPointList(Points, len(Points));
+	b := c.scratch[0:12]
+	n := 12
+	n += pad(len(Points) * 4)
+	put16(b[2:], uint16(n/4))
+	b[0] = 65
+	b[1] = CoordinateMode
+	put32(b[4:], uint32(Drawable))
+	put32(b[8:], uint32(Gc))
+	c.sendRequest(b)
+	c.sendPointList(Points, len(Points))
 }
 
 type Segment struct {
-	X1	int16;
-	Y1	int16;
-	X2	int16;
-	Y2	int16;
+	X1 int16
+	Y1 int16
+	X2 int16
+	Y2 int16
 }
 
 func getSegment(b []byte, v *Segment) int {
-	v.X1 = int16(get16(b[0:]));
-	v.Y1 = int16(get16(b[2:]));
-	v.X2 = int16(get16(b[4:]));
-	v.Y2 = int16(get16(b[6:]));
-	return 8;
+	v.X1 = int16(get16(b[0:]))
+	v.Y1 = int16(get16(b[2:]))
+	v.X2 = int16(get16(b[4:]))
+	v.Y2 = int16(get16(b[6:]))
+	return 8
 }
 
 func (c *Conn) sendSegmentList(list []Segment, count int) {
-	b0 := make([]byte, 8*count);
+	b0 := make([]byte, 8*count)
 	for k := 0; k < count; k++ {
-		b := b0[k*8:];
-		put16(b[0:], uint16(list[k].X1));
-		put16(b[2:], uint16(list[k].Y1));
-		put16(b[4:], uint16(list[k].X2));
-		put16(b[6:], uint16(list[k].Y2));
+		b := b0[k*8:]
+		put16(b[0:], uint16(list[k].X1))
+		put16(b[2:], uint16(list[k].Y1))
+		put16(b[4:], uint16(list[k].X2))
+		put16(b[6:], uint16(list[k].Y2))
 	}
-	c.sendBytes(b0);
+	c.sendBytes(b0)
 }
 
 func (c *Conn) PolySegment(Drawable Id, Gc Id, Segments []Segment) {
-	b := c.scratch[0:12];
-	n := 12;
-	n += pad(len(Segments) * 8);
-	put16(b[2:], uint16(n/4));
-	b[0] = 66;
-	put32(b[4:], uint32(Drawable));
-	put32(b[8:], uint32(Gc));
-	c.sendRequest(b);
-	c.sendSegmentList(Segments, len(Segments));
+	b := c.scratch[0:12]
+	n := 12
+	n += pad(len(Segments) * 8)
+	put16(b[2:], uint16(n/4))
+	b[0] = 66
+	put32(b[4:], uint32(Drawable))
+	put32(b[8:], uint32(Gc))
+	c.sendRequest(b)
+	c.sendSegmentList(Segments, len(Segments))
 }
 
 func (c *Conn) PolyRectangle(Drawable Id, Gc Id, Rectangles []Rectangle) {
-	b := c.scratch[0:12];
-	n := 12;
-	n += pad(len(Rectangles) * 8);
-	put16(b[2:], uint16(n/4));
-	b[0] = 67;
-	put32(b[4:], uint32(Drawable));
-	put32(b[8:], uint32(Gc));
-	c.sendRequest(b);
-	c.sendRectangleList(Rectangles, len(Rectangles));
+	b := c.scratch[0:12]
+	n := 12
+	n += pad(len(Rectangles) * 8)
+	put16(b[2:], uint16(n/4))
+	b[0] = 67
+	put32(b[4:], uint32(Drawable))
+	put32(b[8:], uint32(Gc))
+	c.sendRequest(b)
+	c.sendRectangleList(Rectangles, len(Rectangles))
 }
 
 func (c *Conn) PolyArc(Drawable Id, Gc Id, Arcs []Arc) {
-	b := c.scratch[0:12];
-	n := 12;
-	n += pad(len(Arcs) * 12);
-	put16(b[2:], uint16(n/4));
-	b[0] = 68;
-	put32(b[4:], uint32(Drawable));
-	put32(b[8:], uint32(Gc));
-	c.sendRequest(b);
-	c.sendArcList(Arcs, len(Arcs));
+	b := c.scratch[0:12]
+	n := 12
+	n += pad(len(Arcs) * 12)
+	put16(b[2:], uint16(n/4))
+	b[0] = 68
+	put32(b[4:], uint32(Drawable))
+	put32(b[8:], uint32(Gc))
+	c.sendRequest(b)
+	c.sendArcList(Arcs, len(Arcs))
 }
 
 const (
-	PolyShapeComplex	= 0;
-	PolyShapeNonconvex	= 1;
-	PolyShapeConvex		= 2;
+	PolyShapeComplex   = 0
+	PolyShapeNonconvex = 1
+	PolyShapeConvex    = 2
 )
 
 func (c *Conn) FillPoly(Drawable Id, Gc Id, Shape byte, CoordinateMode byte, Points []Point) {
-	b := c.scratch[0:16];
-	n := 16;
-	n += pad(len(Points) * 4);
-	put16(b[2:], uint16(n/4));
-	b[0] = 69;
-	put32(b[4:], uint32(Drawable));
-	put32(b[8:], uint32(Gc));
-	b[12] = Shape;
-	b[13] = CoordinateMode;
-	c.sendRequest(b);
-	c.sendPointList(Points, len(Points));
+	b := c.scratch[0:16]
+	n := 16
+	n += pad(len(Points) * 4)
+	put16(b[2:], uint16(n/4))
+	b[0] = 69
+	put32(b[4:], uint32(Drawable))
+	put32(b[8:], uint32(Gc))
+	b[12] = Shape
+	b[13] = CoordinateMode
+	c.sendRequest(b)
+	c.sendPointList(Points, len(Points))
 }
 
 func (c *Conn) PolyFillRectangle(Drawable Id, Gc Id, Rectangles []Rectangle) {
-	b := c.scratch[0:12];
-	n := 12;
-	n += pad(len(Rectangles) * 8);
-	put16(b[2:], uint16(n/4));
-	b[0] = 70;
-	put32(b[4:], uint32(Drawable));
-	put32(b[8:], uint32(Gc));
-	c.sendRequest(b);
-	c.sendRectangleList(Rectangles, len(Rectangles));
+	b := c.scratch[0:12]
+	n := 12
+	n += pad(len(Rectangles) * 8)
+	put16(b[2:], uint16(n/4))
+	b[0] = 70
+	put32(b[4:], uint32(Drawable))
+	put32(b[8:], uint32(Gc))
+	c.sendRequest(b)
+	c.sendRectangleList(Rectangles, len(Rectangles))
 }
 
 func (c *Conn) PolyFillArc(Drawable Id, Gc Id, Arcs []Arc) {
-	b := c.scratch[0:12];
-	n := 12;
-	n += pad(len(Arcs) * 12);
-	put16(b[2:], uint16(n/4));
-	b[0] = 71;
-	put32(b[4:], uint32(Drawable));
-	put32(b[8:], uint32(Gc));
-	c.sendRequest(b);
-	c.sendArcList(Arcs, len(Arcs));
+	b := c.scratch[0:12]
+	n := 12
+	n += pad(len(Arcs) * 12)
+	put16(b[2:], uint16(n/4))
+	b[0] = 71
+	put32(b[4:], uint32(Drawable))
+	put32(b[8:], uint32(Gc))
+	c.sendRequest(b)
+	c.sendArcList(Arcs, len(Arcs))
 }
 
 const (
-	ImageFormatXYBitmap	= 0;
-	ImageFormatXYPixmap	= 1;
-	ImageFormatZPixmap	= 2;
+	ImageFormatXYBitmap = 0
+	ImageFormatXYPixmap = 1
+	ImageFormatZPixmap  = 2
 )
 
 func (c *Conn) PutImage(Format byte, Drawable Id, Gc Id, Width uint16, Height uint16, DstX int16, DstY int16, LeftPad byte, Depth byte, Data []byte) {
-	b := c.scratch[0:24];
-	n := 24;
-	n += pad(len(Data) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 72;
-	b[1] = Format;
-	put32(b[4:], uint32(Drawable));
-	put32(b[8:], uint32(Gc));
-	put16(b[12:], Width);
-	put16(b[14:], Height);
-	put16(b[16:], uint16(DstX));
-	put16(b[18:], uint16(DstY));
-	b[20] = LeftPad;
-	b[21] = Depth;
-	c.sendRequest(b);
-	c.sendBytes(Data[0:len(Data)]);
+	b := c.scratch[0:24]
+	n := 24
+	n += pad(len(Data) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 72
+	b[1] = Format
+	put32(b[4:], uint32(Drawable))
+	put32(b[8:], uint32(Gc))
+	put16(b[12:], Width)
+	put16(b[14:], Height)
+	put16(b[16:], uint16(DstX))
+	put16(b[18:], uint16(DstY))
+	b[20] = LeftPad
+	b[21] = Depth
+	c.sendRequest(b)
+	c.sendBytes(Data[0:len(Data)])
 }
 
 func (c *Conn) GetImageRequest(Format byte, Drawable Id, X int16, Y int16, Width uint16, Height uint16, PlaneMask uint32) Cookie {
-	b := c.scratch[0:20];
-	put16(b[2:], 5);
-	b[0] = 73;
-	b[1] = Format;
-	put32(b[4:], uint32(Drawable));
-	put16(b[8:], uint16(X));
-	put16(b[10:], uint16(Y));
-	put16(b[12:], Width);
-	put16(b[14:], Height);
-	put32(b[16:], PlaneMask);
-	return c.sendRequest(b);
+	b := c.scratch[0:20]
+	put16(b[2:], 5)
+	b[0] = 73
+	b[1] = Format
+	put32(b[4:], uint32(Drawable))
+	put16(b[8:], uint16(X))
+	put16(b[10:], uint16(Y))
+	put16(b[12:], Width)
+	put16(b[14:], Height)
+	put32(b[16:], PlaneMask)
+	return c.sendRequest(b)
 }
 
 func (c *Conn) GetImage(Format byte, Drawable Id, X int16, Y int16, Width uint16, Height uint16, PlaneMask uint32) (*GetImageReply, os.Error) {
@@ -2879,141 +2879,141 @@ func (c *Conn) GetImage(Format byte, Drawable Id, X int16, Y int16, Width uint16
 }
 
 type GetImageReply struct {
-	Depth	byte;
-	Length	uint32;
-	Visual	Id;
-	Data	[]byte;
+	Depth  byte
+	Length uint32
+	Visual Id
+	Data   []byte
 }
 
 func (c *Conn) GetImageReply(cookie Cookie) (*GetImageReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(GetImageReply);
-	v.Depth = b[1];
-	v.Length = get32(b[4:]);
-	v.Visual = Id(get32(b[8:]));
-	offset := 32;
-	v.Data = make([]byte, (int(v.Length) * 4));
-	copy(v.Data[0:len(v.Data)], b[offset:]);
-	offset += len(v.Data) * 1;
-	return v, nil;
+	v := new(GetImageReply)
+	v.Depth = b[1]
+	v.Length = get32(b[4:])
+	v.Visual = Id(get32(b[8:]))
+	offset := 32
+	v.Data = make([]byte, (int(v.Length) * 4))
+	copy(v.Data[0:len(v.Data)], b[offset:])
+	offset += len(v.Data) * 1
+	return v, nil
 }
 
 func (c *Conn) PolyText8(Drawable Id, Gc Id, X int16, Y int16, Items []byte) {
-	b := c.scratch[0:16];
-	n := 16;
-	n += pad(len(Items) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 74;
-	put32(b[4:], uint32(Drawable));
-	put32(b[8:], uint32(Gc));
-	put16(b[12:], uint16(X));
-	put16(b[14:], uint16(Y));
-	c.sendRequest(b);
-	c.sendBytes(Items[0:len(Items)]);
+	b := c.scratch[0:16]
+	n := 16
+	n += pad(len(Items) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 74
+	put32(b[4:], uint32(Drawable))
+	put32(b[8:], uint32(Gc))
+	put16(b[12:], uint16(X))
+	put16(b[14:], uint16(Y))
+	c.sendRequest(b)
+	c.sendBytes(Items[0:len(Items)])
 }
 
 func (c *Conn) PolyText16(Drawable Id, Gc Id, X int16, Y int16, Items []byte) {
-	b := c.scratch[0:16];
-	n := 16;
-	n += pad(len(Items) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 75;
-	put32(b[4:], uint32(Drawable));
-	put32(b[8:], uint32(Gc));
-	put16(b[12:], uint16(X));
-	put16(b[14:], uint16(Y));
-	c.sendRequest(b);
-	c.sendBytes(Items[0:len(Items)]);
+	b := c.scratch[0:16]
+	n := 16
+	n += pad(len(Items) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 75
+	put32(b[4:], uint32(Drawable))
+	put32(b[8:], uint32(Gc))
+	put16(b[12:], uint16(X))
+	put16(b[14:], uint16(Y))
+	c.sendRequest(b)
+	c.sendBytes(Items[0:len(Items)])
 }
 
 func (c *Conn) ImageText8(Drawable Id, Gc Id, X int16, Y int16, String []byte) {
-	b := c.scratch[0:16];
-	n := 16;
-	n += pad(len(String) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 76;
-	b[1] = byte(len(String));
-	put32(b[4:], uint32(Drawable));
-	put32(b[8:], uint32(Gc));
-	put16(b[12:], uint16(X));
-	put16(b[14:], uint16(Y));
-	c.sendRequest(b);
-	c.sendBytes(String[0:len(String)]);
+	b := c.scratch[0:16]
+	n := 16
+	n += pad(len(String) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 76
+	b[1] = byte(len(String))
+	put32(b[4:], uint32(Drawable))
+	put32(b[8:], uint32(Gc))
+	put16(b[12:], uint16(X))
+	put16(b[14:], uint16(Y))
+	c.sendRequest(b)
+	c.sendBytes(String[0:len(String)])
 }
 
 func (c *Conn) ImageText16(Drawable Id, Gc Id, X int16, Y int16, String []Char2b) {
-	b := c.scratch[0:16];
-	n := 16;
-	n += pad(len(String) * 2);
-	put16(b[2:], uint16(n/4));
-	b[0] = 77;
-	b[1] = byte(len(String));
-	put32(b[4:], uint32(Drawable));
-	put32(b[8:], uint32(Gc));
-	put16(b[12:], uint16(X));
-	put16(b[14:], uint16(Y));
-	c.sendRequest(b);
-	c.sendChar2bList(String, len(String));
+	b := c.scratch[0:16]
+	n := 16
+	n += pad(len(String) * 2)
+	put16(b[2:], uint16(n/4))
+	b[0] = 77
+	b[1] = byte(len(String))
+	put32(b[4:], uint32(Drawable))
+	put32(b[8:], uint32(Gc))
+	put16(b[12:], uint16(X))
+	put16(b[14:], uint16(Y))
+	c.sendRequest(b)
+	c.sendChar2bList(String, len(String))
 }
 
 const (
-	ColormapAllocNone	= 0;
-	ColormapAllocAll	= 1;
+	ColormapAllocNone = 0
+	ColormapAllocAll  = 1
 )
 
 func (c *Conn) CreateColormap(Alloc byte, Mid Id, Window Id, Visual Id) {
-	b := c.scratch[0:16];
-	put16(b[2:], 4);
-	b[0] = 78;
-	b[1] = Alloc;
-	put32(b[4:], uint32(Mid));
-	put32(b[8:], uint32(Window));
-	put32(b[12:], uint32(Visual));
-	c.sendRequest(b);
+	b := c.scratch[0:16]
+	put16(b[2:], 4)
+	b[0] = 78
+	b[1] = Alloc
+	put32(b[4:], uint32(Mid))
+	put32(b[8:], uint32(Window))
+	put32(b[12:], uint32(Visual))
+	c.sendRequest(b)
 }
 
 func (c *Conn) FreeColormap(Cmap Id) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 79;
-	put32(b[4:], uint32(Cmap));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 79
+	put32(b[4:], uint32(Cmap))
+	c.sendRequest(b)
 }
 
 func (c *Conn) CopyColormapAndFree(Mid Id, SrcCmap Id) {
-	b := c.scratch[0:12];
-	put16(b[2:], 3);
-	b[0] = 80;
-	put32(b[4:], uint32(Mid));
-	put32(b[8:], uint32(SrcCmap));
-	c.sendRequest(b);
+	b := c.scratch[0:12]
+	put16(b[2:], 3)
+	b[0] = 80
+	put32(b[4:], uint32(Mid))
+	put32(b[8:], uint32(SrcCmap))
+	c.sendRequest(b)
 }
 
 func (c *Conn) InstallColormap(Cmap Id) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 81;
-	put32(b[4:], uint32(Cmap));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 81
+	put32(b[4:], uint32(Cmap))
+	c.sendRequest(b)
 }
 
 func (c *Conn) UninstallColormap(Cmap Id) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 82;
-	put32(b[4:], uint32(Cmap));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 82
+	put32(b[4:], uint32(Cmap))
+	c.sendRequest(b)
 }
 
 func (c *Conn) ListInstalledColormapsRequest(Window Id) Cookie {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 83;
-	put32(b[4:], uint32(Window));
-	return c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 83
+	put32(b[4:], uint32(Window))
+	return c.sendRequest(b)
 }
 
 func (c *Conn) ListInstalledColormaps(Window Id) (*ListInstalledColormapsReply, os.Error) {
@@ -3021,35 +3021,35 @@ func (c *Conn) ListInstalledColormaps(Window Id) (*ListInstalledColormapsReply,
 }
 
 type ListInstalledColormapsReply struct {
-	CmapsLen	uint16;
-	Cmaps		[]Id;
+	CmapsLen uint16
+	Cmaps    []Id
 }
 
 func (c *Conn) ListInstalledColormapsReply(cookie Cookie) (*ListInstalledColormapsReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(ListInstalledColormapsReply);
-	v.CmapsLen = get16(b[8:]);
-	offset := 32;
-	v.Cmaps = make([]Id, int(v.CmapsLen));
+	v := new(ListInstalledColormapsReply)
+	v.CmapsLen = get16(b[8:])
+	offset := 32
+	v.Cmaps = make([]Id, int(v.CmapsLen))
 	for i := 0; i < len(v.Cmaps); i++ {
 		v.Cmaps[i] = Id(get32(b[offset+i*4:]))
 	}
-	offset += len(v.Cmaps) * 4;
-	return v, nil;
+	offset += len(v.Cmaps) * 4
+	return v, nil
 }
 
 func (c *Conn) AllocColorRequest(Cmap Id, Red uint16, Green uint16, Blue uint16) Cookie {
-	b := c.scratch[0:16];
-	put16(b[2:], 4);
-	b[0] = 84;
-	put32(b[4:], uint32(Cmap));
-	put16(b[8:], Red);
-	put16(b[10:], Green);
-	put16(b[12:], Blue);
-	return c.sendRequest(b);
+	b := c.scratch[0:16]
+	put16(b[2:], 4)
+	b[0] = 84
+	put32(b[4:], uint32(Cmap))
+	put16(b[8:], Red)
+	put16(b[10:], Green)
+	put16(b[12:], Blue)
+	return c.sendRequest(b)
 }
 
 func (c *Conn) AllocColor(Cmap Id, Red uint16, Green uint16, Blue uint16) (*AllocColorReply, os.Error) {
@@ -3057,36 +3057,36 @@ func (c *Conn) AllocColor(Cmap Id, Red uint16, Green uint16, Blue uint16) (*Allo
 }
 
 type AllocColorReply struct {
-	Red	uint16;
-	Green	uint16;
-	Blue	uint16;
-	Pixel	uint32;
+	Red   uint16
+	Green uint16
+	Blue  uint16
+	Pixel uint32
 }
 
 func (c *Conn) AllocColorReply(cookie Cookie) (*AllocColorReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(AllocColorReply);
-	v.Red = get16(b[8:]);
-	v.Green = get16(b[10:]);
-	v.Blue = get16(b[12:]);
-	v.Pixel = get32(b[16:]);
-	return v, nil;
+	v := new(AllocColorReply)
+	v.Red = get16(b[8:])
+	v.Green = get16(b[10:])
+	v.Blue = get16(b[12:])
+	v.Pixel = get32(b[16:])
+	return v, nil
 }
 
 func (c *Conn) AllocNamedColorRequest(Cmap Id, Name string) Cookie {
-	b := c.scratch[0:12];
-	n := 12;
-	n += pad(len(Name) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 85;
-	put32(b[4:], uint32(Cmap));
-	put16(b[8:], uint16(len(Name)));
-	cookie := c.sendRequest(b);
-	c.sendString(Name);
-	return cookie;
+	b := c.scratch[0:12]
+	n := 12
+	n += pad(len(Name) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 85
+	put32(b[4:], uint32(Cmap))
+	put16(b[8:], uint16(len(Name)))
+	cookie := c.sendRequest(b)
+	c.sendString(Name)
+	return cookie
 }
 
 func (c *Conn) AllocNamedColor(Cmap Id, Name string) (*AllocNamedColorReply, os.Error) {
@@ -3094,40 +3094,40 @@ func (c *Conn) AllocNamedColor(Cmap Id, Name string) (*AllocNamedColorReply, os.
 }
 
 type AllocNamedColorReply struct {
-	Pixel		uint32;
-	ExactRed	uint16;
-	ExactGreen	uint16;
-	ExactBlue	uint16;
-	VisualRed	uint16;
-	VisualGreen	uint16;
-	VisualBlue	uint16;
+	Pixel       uint32
+	ExactRed    uint16
+	ExactGreen  uint16
+	ExactBlue   uint16
+	VisualRed   uint16
+	VisualGreen uint16
+	VisualBlue  uint16
 }
 
 func (c *Conn) AllocNamedColorReply(cookie Cookie) (*AllocNamedColorReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(AllocNamedColorReply);
-	v.Pixel = get32(b[8:]);
-	v.ExactRed = get16(b[12:]);
-	v.ExactGreen = get16(b[14:]);
-	v.ExactBlue = get16(b[16:]);
-	v.VisualRed = get16(b[18:]);
-	v.VisualGreen = get16(b[20:]);
-	v.VisualBlue = get16(b[22:]);
-	return v, nil;
+	v := new(AllocNamedColorReply)
+	v.Pixel = get32(b[8:])
+	v.ExactRed = get16(b[12:])
+	v.ExactGreen = get16(b[14:])
+	v.ExactBlue = get16(b[16:])
+	v.VisualRed = get16(b[18:])
+	v.VisualGreen = get16(b[20:])
+	v.VisualBlue = get16(b[22:])
+	return v, nil
 }
 
 func (c *Conn) AllocColorCellsRequest(Contiguous byte, Cmap Id, Colors uint16, Planes uint16) Cookie {
-	b := c.scratch[0:12];
-	put16(b[2:], 3);
-	b[0] = 86;
-	b[1] = Contiguous;
-	put32(b[4:], uint32(Cmap));
-	put16(b[8:], Colors);
-	put16(b[10:], Planes);
-	return c.sendRequest(b);
+	b := c.scratch[0:12]
+	put16(b[2:], 3)
+	b[0] = 86
+	b[1] = Contiguous
+	put32(b[4:], uint32(Cmap))
+	put16(b[8:], Colors)
+	put16(b[10:], Planes)
+	return c.sendRequest(b)
 }
 
 func (c *Conn) AllocColorCells(Contiguous byte, Cmap Id, Colors uint16, Planes uint16) (*AllocColorCellsReply, os.Error) {
@@ -3135,46 +3135,46 @@ func (c *Conn) AllocColorCells(Contiguous byte, Cmap Id, Colors uint16, Planes u
 }
 
 type AllocColorCellsReply struct {
-	PixelsLen	uint16;
-	MasksLen	uint16;
-	Pixels		[]uint32;
-	Masks		[]uint32;
+	PixelsLen uint16
+	MasksLen  uint16
+	Pixels    []uint32
+	Masks     []uint32
 }
 
 func (c *Conn) AllocColorCellsReply(cookie Cookie) (*AllocColorCellsReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(AllocColorCellsReply);
-	v.PixelsLen = get16(b[8:]);
-	v.MasksLen = get16(b[10:]);
-	offset := 32;
-	v.Pixels = make([]uint32, int(v.PixelsLen));
+	v := new(AllocColorCellsReply)
+	v.PixelsLen = get16(b[8:])
+	v.MasksLen = get16(b[10:])
+	offset := 32
+	v.Pixels = make([]uint32, int(v.PixelsLen))
 	for i := 0; i < len(v.Pixels); i++ {
 		v.Pixels[i] = get32(b[offset+i*4:])
 	}
-	offset += len(v.Pixels) * 4;
-	offset = pad(offset);
-	v.Masks = make([]uint32, int(v.MasksLen));
+	offset += len(v.Pixels) * 4
+	offset = pad(offset)
+	v.Masks = make([]uint32, int(v.MasksLen))
 	for i := 0; i < len(v.Masks); i++ {
 		v.Masks[i] = get32(b[offset+i*4:])
 	}
-	offset += len(v.Masks) * 4;
-	return v, nil;
+	offset += len(v.Masks) * 4
+	return v, nil
 }
 
 func (c *Conn) AllocColorPlanesRequest(Contiguous byte, Cmap Id, Colors uint16, Reds uint16, Greens uint16, Blues uint16) Cookie {
-	b := c.scratch[0:16];
-	put16(b[2:], 4);
-	b[0] = 87;
-	b[1] = Contiguous;
-	put32(b[4:], uint32(Cmap));
-	put16(b[8:], Colors);
-	put16(b[10:], Reds);
-	put16(b[12:], Greens);
-	put16(b[14:], Blues);
-	return c.sendRequest(b);
+	b := c.scratch[0:16]
+	put16(b[2:], 4)
+	b[0] = 87
+	b[1] = Contiguous
+	put32(b[4:], uint32(Cmap))
+	put16(b[8:], Colors)
+	put16(b[10:], Reds)
+	put16(b[12:], Greens)
+	put16(b[14:], Blues)
+	return c.sendRequest(b)
 }
 
 func (c *Conn) AllocColorPlanes(Contiguous byte, Cmap Id, Colors uint16, Reds uint16, Greens uint16, Blues uint16) (*AllocColorPlanesReply, os.Error) {
@@ -3182,139 +3182,139 @@ func (c *Conn) AllocColorPlanes(Contiguous byte, Cmap Id, Colors uint16, Reds ui
 }
 
 type AllocColorPlanesReply struct {
-	PixelsLen	uint16;
-	RedMask		uint32;
-	GreenMask	uint32;
-	BlueMask	uint32;
-	Pixels		[]uint32;
+	PixelsLen uint16
+	RedMask   uint32
+	GreenMask uint32
+	BlueMask  uint32
+	Pixels    []uint32
 }
 
 func (c *Conn) AllocColorPlanesReply(cookie Cookie) (*AllocColorPlanesReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(AllocColorPlanesReply);
-	v.PixelsLen = get16(b[8:]);
-	v.RedMask = get32(b[12:]);
-	v.GreenMask = get32(b[16:]);
-	v.BlueMask = get32(b[20:]);
-	offset := 32;
-	v.Pixels = make([]uint32, int(v.PixelsLen));
+	v := new(AllocColorPlanesReply)
+	v.PixelsLen = get16(b[8:])
+	v.RedMask = get32(b[12:])
+	v.GreenMask = get32(b[16:])
+	v.BlueMask = get32(b[20:])
+	offset := 32
+	v.Pixels = make([]uint32, int(v.PixelsLen))
 	for i := 0; i < len(v.Pixels); i++ {
 		v.Pixels[i] = get32(b[offset+i*4:])
 	}
-	offset += len(v.Pixels) * 4;
-	return v, nil;
+	offset += len(v.Pixels) * 4
+	return v, nil
 }
 
 func (c *Conn) FreeColors(Cmap Id, PlaneMask uint32, Pixels []uint32) {
-	b := c.scratch[0:12];
-	n := 12;
-	n += pad(len(Pixels) * 4);
-	put16(b[2:], uint16(n/4));
-	b[0] = 88;
-	put32(b[4:], uint32(Cmap));
-	put32(b[8:], PlaneMask);
-	c.sendRequest(b);
-	c.sendUInt32List(Pixels[0:len(Pixels)]);
+	b := c.scratch[0:12]
+	n := 12
+	n += pad(len(Pixels) * 4)
+	put16(b[2:], uint16(n/4))
+	b[0] = 88
+	put32(b[4:], uint32(Cmap))
+	put32(b[8:], PlaneMask)
+	c.sendRequest(b)
+	c.sendUInt32List(Pixels[0:len(Pixels)])
 }
 
 const (
-	ColorFlagRed	= 1;
-	ColorFlagGreen	= 2;
-	ColorFlagBlue	= 4;
+	ColorFlagRed   = 1
+	ColorFlagGreen = 2
+	ColorFlagBlue  = 4
 )
 
 type Coloritem struct {
-	Pixel	uint32;
-	Red	uint16;
-	Green	uint16;
-	Blue	uint16;
-	Flags	byte;
+	Pixel uint32
+	Red   uint16
+	Green uint16
+	Blue  uint16
+	Flags byte
 }
 
 func getColoritem(b []byte, v *Coloritem) int {
-	v.Pixel = get32(b[0:]);
-	v.Red = get16(b[4:]);
-	v.Green = get16(b[6:]);
-	v.Blue = get16(b[8:]);
-	v.Flags = b[10];
-	return 12;
+	v.Pixel = get32(b[0:])
+	v.Red = get16(b[4:])
+	v.Green = get16(b[6:])
+	v.Blue = get16(b[8:])
+	v.Flags = b[10]
+	return 12
 }
 
 func (c *Conn) sendColoritemList(list []Coloritem, count int) {
-	b0 := make([]byte, 12*count);
+	b0 := make([]byte, 12*count)
 	for k := 0; k < count; k++ {
-		b := b0[k*12:];
-		put32(b[0:], list[k].Pixel);
-		put16(b[4:], list[k].Red);
-		put16(b[6:], list[k].Green);
-		put16(b[8:], list[k].Blue);
-		b[10] = list[k].Flags;
+		b := b0[k*12:]
+		put32(b[0:], list[k].Pixel)
+		put16(b[4:], list[k].Red)
+		put16(b[6:], list[k].Green)
+		put16(b[8:], list[k].Blue)
+		b[10] = list[k].Flags
 	}
-	c.sendBytes(b0);
+	c.sendBytes(b0)
 }
 
 func (c *Conn) StoreColors(Cmap Id, Items []Coloritem) {
-	b := c.scratch[0:8];
-	n := 8;
-	n += pad(len(Items) * 12);
-	put16(b[2:], uint16(n/4));
-	b[0] = 89;
-	put32(b[4:], uint32(Cmap));
-	c.sendRequest(b);
-	c.sendColoritemList(Items, len(Items));
+	b := c.scratch[0:8]
+	n := 8
+	n += pad(len(Items) * 12)
+	put16(b[2:], uint16(n/4))
+	b[0] = 89
+	put32(b[4:], uint32(Cmap))
+	c.sendRequest(b)
+	c.sendColoritemList(Items, len(Items))
 }
 
 func (c *Conn) StoreNamedColor(Flags byte, Cmap Id, Pixel uint32, Name string) {
-	b := c.scratch[0:16];
-	n := 16;
-	n += pad(len(Name) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 90;
-	b[1] = Flags;
-	put32(b[4:], uint32(Cmap));
-	put32(b[8:], Pixel);
-	put16(b[12:], uint16(len(Name)));
-	c.sendRequest(b);
-	c.sendString(Name);
+	b := c.scratch[0:16]
+	n := 16
+	n += pad(len(Name) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 90
+	b[1] = Flags
+	put32(b[4:], uint32(Cmap))
+	put32(b[8:], Pixel)
+	put16(b[12:], uint16(len(Name)))
+	c.sendRequest(b)
+	c.sendString(Name)
 }
 
 type Rgb struct {
-	Red	uint16;
-	Green	uint16;
-	Blue	uint16;
+	Red   uint16
+	Green uint16
+	Blue  uint16
 }
 
 func getRgb(b []byte, v *Rgb) int {
-	v.Red = get16(b[0:]);
-	v.Green = get16(b[2:]);
-	v.Blue = get16(b[4:]);
-	return 8;
+	v.Red = get16(b[0:])
+	v.Green = get16(b[2:])
+	v.Blue = get16(b[4:])
+	return 8
 }
 
 func (c *Conn) sendRgbList(list []Rgb, count int) {
-	b0 := make([]byte, 8*count);
+	b0 := make([]byte, 8*count)
 	for k := 0; k < count; k++ {
-		b := b0[k*8:];
-		put16(b[0:], list[k].Red);
-		put16(b[2:], list[k].Green);
-		put16(b[4:], list[k].Blue);
+		b := b0[k*8:]
+		put16(b[0:], list[k].Red)
+		put16(b[2:], list[k].Green)
+		put16(b[4:], list[k].Blue)
 	}
-	c.sendBytes(b0);
+	c.sendBytes(b0)
 }
 
 func (c *Conn) QueryColorsRequest(Cmap Id, Pixels []uint32) Cookie {
-	b := c.scratch[0:8];
-	n := 8;
-	n += pad(len(Pixels) * 4);
-	put16(b[2:], uint16(n/4));
-	b[0] = 91;
-	put32(b[4:], uint32(Cmap));
-	cookie := c.sendRequest(b);
-	c.sendUInt32List(Pixels[0:len(Pixels)]);
-	return cookie;
+	b := c.scratch[0:8]
+	n := 8
+	n += pad(len(Pixels) * 4)
+	put16(b[2:], uint16(n/4))
+	b[0] = 91
+	put32(b[4:], uint32(Cmap))
+	cookie := c.sendRequest(b)
+	c.sendUInt32List(Pixels[0:len(Pixels)])
+	return cookie
 }
 
 func (c *Conn) QueryColors(Cmap Id, Pixels []uint32) (*QueryColorsReply, os.Error) {
@@ -3322,36 +3322,36 @@ func (c *Conn) QueryColors(Cmap Id, Pixels []uint32) (*QueryColorsReply, os.Erro
 }
 
 type QueryColorsReply struct {
-	ColorsLen	uint16;
-	Colors		[]Rgb;
+	ColorsLen uint16
+	Colors    []Rgb
 }
 
 func (c *Conn) QueryColorsReply(cookie Cookie) (*QueryColorsReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(QueryColorsReply);
-	v.ColorsLen = get16(b[8:]);
-	offset := 32;
-	v.Colors = make([]Rgb, int(v.ColorsLen));
+	v := new(QueryColorsReply)
+	v.ColorsLen = get16(b[8:])
+	offset := 32
+	v.Colors = make([]Rgb, int(v.ColorsLen))
 	for i := 0; i < int(v.ColorsLen); i++ {
 		offset += getRgb(b[offset:], &v.Colors[i])
 	}
-	return v, nil;
+	return v, nil
 }
 
 func (c *Conn) LookupColorRequest(Cmap Id, Name string) Cookie {
-	b := c.scratch[0:12];
-	n := 12;
-	n += pad(len(Name) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 92;
-	put32(b[4:], uint32(Cmap));
-	put16(b[8:], uint16(len(Name)));
-	cookie := c.sendRequest(b);
-	c.sendString(Name);
-	return cookie;
+	b := c.scratch[0:12]
+	n := 12
+	n += pad(len(Name) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 92
+	put32(b[4:], uint32(Cmap))
+	put16(b[8:], uint16(len(Name)))
+	cookie := c.sendRequest(b)
+	c.sendString(Name)
+	return cookie
 }
 
 func (c *Conn) LookupColor(Cmap Id, Name string) (*LookupColorReply, os.Error) {
@@ -3359,110 +3359,110 @@ func (c *Conn) LookupColor(Cmap Id, Name string) (*LookupColorReply, os.Error) {
 }
 
 type LookupColorReply struct {
-	ExactRed	uint16;
-	ExactGreen	uint16;
-	ExactBlue	uint16;
-	VisualRed	uint16;
-	VisualGreen	uint16;
-	VisualBlue	uint16;
+	ExactRed    uint16
+	ExactGreen  uint16
+	ExactBlue   uint16
+	VisualRed   uint16
+	VisualGreen uint16
+	VisualBlue  uint16
 }
 
 func (c *Conn) LookupColorReply(cookie Cookie) (*LookupColorReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(LookupColorReply);
-	v.ExactRed = get16(b[8:]);
-	v.ExactGreen = get16(b[10:]);
-	v.ExactBlue = get16(b[12:]);
-	v.VisualRed = get16(b[14:]);
-	v.VisualGreen = get16(b[16:]);
-	v.VisualBlue = get16(b[18:]);
-	return v, nil;
+	v := new(LookupColorReply)
+	v.ExactRed = get16(b[8:])
+	v.ExactGreen = get16(b[10:])
+	v.ExactBlue = get16(b[12:])
+	v.VisualRed = get16(b[14:])
+	v.VisualGreen = get16(b[16:])
+	v.VisualBlue = get16(b[18:])
+	return v, nil
 }
 
 const (
-	PixmapNone = 0;
+	PixmapNone = 0
 )
 
 func (c *Conn) CreateCursor(Cid Id, Source Id, Mask Id, ForeRed uint16, ForeGreen uint16, ForeBlue uint16, BackRed uint16, BackGreen uint16, BackBlue uint16, X uint16, Y uint16) {
-	b := c.scratch[0:32];
-	put16(b[2:], 8);
-	b[0] = 93;
-	put32(b[4:], uint32(Cid));
-	put32(b[8:], uint32(Source));
-	put32(b[12:], uint32(Mask));
-	put16(b[16:], ForeRed);
-	put16(b[18:], ForeGreen);
-	put16(b[20:], ForeBlue);
-	put16(b[22:], BackRed);
-	put16(b[24:], BackGreen);
-	put16(b[26:], BackBlue);
-	put16(b[28:], X);
-	put16(b[30:], Y);
-	c.sendRequest(b);
+	b := c.scratch[0:32]
+	put16(b[2:], 8)
+	b[0] = 93
+	put32(b[4:], uint32(Cid))
+	put32(b[8:], uint32(Source))
+	put32(b[12:], uint32(Mask))
+	put16(b[16:], ForeRed)
+	put16(b[18:], ForeGreen)
+	put16(b[20:], ForeBlue)
+	put16(b[22:], BackRed)
+	put16(b[24:], BackGreen)
+	put16(b[26:], BackBlue)
+	put16(b[28:], X)
+	put16(b[30:], Y)
+	c.sendRequest(b)
 }
 
 const (
-	FontNone = 0;
+	FontNone = 0
 )
 
 func (c *Conn) CreateGlyphCursor(Cid Id, SourceFont Id, MaskFont Id, SourceChar uint16, MaskChar uint16, ForeRed uint16, ForeGreen uint16, ForeBlue uint16, BackRed uint16, BackGreen uint16, BackBlue uint16) {
-	b := c.scratch[0:32];
-	put16(b[2:], 8);
-	b[0] = 94;
-	put32(b[4:], uint32(Cid));
-	put32(b[8:], uint32(SourceFont));
-	put32(b[12:], uint32(MaskFont));
-	put16(b[16:], SourceChar);
-	put16(b[18:], MaskChar);
-	put16(b[20:], ForeRed);
-	put16(b[22:], ForeGreen);
-	put16(b[24:], ForeBlue);
-	put16(b[26:], BackRed);
-	put16(b[28:], BackGreen);
-	put16(b[30:], BackBlue);
-	c.sendRequest(b);
+	b := c.scratch[0:32]
+	put16(b[2:], 8)
+	b[0] = 94
+	put32(b[4:], uint32(Cid))
+	put32(b[8:], uint32(SourceFont))
+	put32(b[12:], uint32(MaskFont))
+	put16(b[16:], SourceChar)
+	put16(b[18:], MaskChar)
+	put16(b[20:], ForeRed)
+	put16(b[22:], ForeGreen)
+	put16(b[24:], ForeBlue)
+	put16(b[26:], BackRed)
+	put16(b[28:], BackGreen)
+	put16(b[30:], BackBlue)
+	c.sendRequest(b)
 }
 
 func (c *Conn) FreeCursor(Cursor Id) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 95;
-	put32(b[4:], uint32(Cursor));
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 95
+	put32(b[4:], uint32(Cursor))
+	c.sendRequest(b)
 }
 
 func (c *Conn) RecolorCursor(Cursor Id, ForeRed uint16, ForeGreen uint16, ForeBlue uint16, BackRed uint16, BackGreen uint16, BackBlue uint16) {
-	b := c.scratch[0:20];
-	put16(b[2:], 5);
-	b[0] = 96;
-	put32(b[4:], uint32(Cursor));
-	put16(b[8:], ForeRed);
-	put16(b[10:], ForeGreen);
-	put16(b[12:], ForeBlue);
-	put16(b[14:], BackRed);
-	put16(b[16:], BackGreen);
-	put16(b[18:], BackBlue);
-	c.sendRequest(b);
+	b := c.scratch[0:20]
+	put16(b[2:], 5)
+	b[0] = 96
+	put32(b[4:], uint32(Cursor))
+	put16(b[8:], ForeRed)
+	put16(b[10:], ForeGreen)
+	put16(b[12:], ForeBlue)
+	put16(b[14:], BackRed)
+	put16(b[16:], BackGreen)
+	put16(b[18:], BackBlue)
+	c.sendRequest(b)
 }
 
 const (
-	QueryShapeOfLargestCursor	= 0;
-	QueryShapeOfFastestTile		= 1;
-	QueryShapeOfFastestStipple	= 2;
+	QueryShapeOfLargestCursor  = 0
+	QueryShapeOfFastestTile    = 1
+	QueryShapeOfFastestStipple = 2
 )
 
 func (c *Conn) QueryBestSizeRequest(Class byte, Drawable Id, Width uint16, Height uint16) Cookie {
-	b := c.scratch[0:12];
-	put16(b[2:], 3);
-	b[0] = 97;
-	b[1] = Class;
-	put32(b[4:], uint32(Drawable));
-	put16(b[8:], Width);
-	put16(b[10:], Height);
-	return c.sendRequest(b);
+	b := c.scratch[0:12]
+	put16(b[2:], 3)
+	b[0] = 97
+	b[1] = Class
+	put32(b[4:], uint32(Drawable))
+	put16(b[8:], Width)
+	put16(b[10:], Height)
+	return c.sendRequest(b)
 }
 
 func (c *Conn) QueryBestSize(Class byte, Drawable Id, Width uint16, Height uint16) (*QueryBestSizeReply, os.Error) {
@@ -3470,31 +3470,31 @@ func (c *Conn) QueryBestSize(Class byte, Drawable Id, Width uint16, Height uint1
 }
 
 type QueryBestSizeReply struct {
-	Width	uint16;
-	Height	uint16;
+	Width  uint16
+	Height uint16
 }
 
 func (c *Conn) QueryBestSizeReply(cookie Cookie) (*QueryBestSizeReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(QueryBestSizeReply);
-	v.Width = get16(b[8:]);
-	v.Height = get16(b[10:]);
-	return v, nil;
+	v := new(QueryBestSizeReply)
+	v.Width = get16(b[8:])
+	v.Height = get16(b[10:])
+	return v, nil
 }
 
 func (c *Conn) QueryExtensionRequest(Name string) Cookie {
-	b := c.scratch[0:8];
-	n := 8;
-	n += pad(len(Name) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 98;
-	put16(b[4:], uint16(len(Name)));
-	cookie := c.sendRequest(b);
-	c.sendString(Name);
-	return cookie;
+	b := c.scratch[0:8]
+	n := 8
+	n += pad(len(Name) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 98
+	put16(b[4:], uint16(len(Name)))
+	cookie := c.sendRequest(b)
+	c.sendString(Name)
+	return cookie
 }
 
 func (c *Conn) QueryExtension(Name string) (*QueryExtensionReply, os.Error) {
@@ -3502,30 +3502,30 @@ func (c *Conn) QueryExtension(Name string) (*QueryExtensionReply, os.Error) {
 }
 
 type QueryExtensionReply struct {
-	Present		byte;
-	MajorOpcode	byte;
-	FirstEvent	byte;
-	FirstError	byte;
+	Present     byte
+	MajorOpcode byte
+	FirstEvent  byte
+	FirstError  byte
 }
 
 func (c *Conn) QueryExtensionReply(cookie Cookie) (*QueryExtensionReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(QueryExtensionReply);
-	v.Present = b[8];
-	v.MajorOpcode = b[9];
-	v.FirstEvent = b[10];
-	v.FirstError = b[11];
-	return v, nil;
+	v := new(QueryExtensionReply)
+	v.Present = b[8]
+	v.MajorOpcode = b[9]
+	v.FirstEvent = b[10]
+	v.FirstError = b[11]
+	return v, nil
 }
 
 func (c *Conn) ListExtensionsRequest() Cookie {
-	b := c.scratch[0:4];
-	put16(b[2:], 1);
-	b[0] = 99;
-	return c.sendRequest(b);
+	b := c.scratch[0:4]
+	put16(b[2:], 1)
+	b[0] = 99
+	return c.sendRequest(b)
 }
 
 func (c *Conn) ListExtensions() (*ListExtensionsReply, os.Error) {
@@ -3533,45 +3533,45 @@ func (c *Conn) ListExtensions() (*ListExtensionsReply, os.Error) {
 }
 
 type ListExtensionsReply struct {
-	NamesLen	byte;
-	Names		[]Str;
+	NamesLen byte
+	Names    []Str
 }
 
 func (c *Conn) ListExtensionsReply(cookie Cookie) (*ListExtensionsReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(ListExtensionsReply);
-	v.NamesLen = b[1];
-	offset := 32;
-	v.Names = make([]Str, int(v.NamesLen));
+	v := new(ListExtensionsReply)
+	v.NamesLen = b[1]
+	offset := 32
+	v.Names = make([]Str, int(v.NamesLen))
 	for i := 0; i < int(v.NamesLen); i++ {
 		offset += getStr(b[offset:], &v.Names[i])
 	}
-	return v, nil;
+	return v, nil
 }
 
 func (c *Conn) ChangeKeyboardMapping(KeycodeCount byte, FirstKeycode byte, KeysymsPerKeycode byte, Keysyms []Keysym) {
-	b := c.scratch[0:6];
-	n := 6;
-	n += pad((int(KeycodeCount) * int(KeysymsPerKeycode)) * 4);
-	put16(b[2:], uint16(n/4));
-	b[0] = 100;
-	b[1] = KeycodeCount;
-	b[4] = FirstKeycode;
-	b[5] = KeysymsPerKeycode;
-	c.sendRequest(b);
-	c.sendKeysymList(Keysyms, (int(KeycodeCount) * int(KeysymsPerKeycode)));
+	b := c.scratch[0:6]
+	n := 6
+	n += pad((int(KeycodeCount) * int(KeysymsPerKeycode)) * 4)
+	put16(b[2:], uint16(n/4))
+	b[0] = 100
+	b[1] = KeycodeCount
+	b[4] = FirstKeycode
+	b[5] = KeysymsPerKeycode
+	c.sendRequest(b)
+	c.sendKeysymList(Keysyms, (int(KeycodeCount) * int(KeysymsPerKeycode)))
 }
 
 func (c *Conn) GetKeyboardMappingRequest(FirstKeycode byte, Count byte) Cookie {
-	b := c.scratch[0:6];
-	put16(b[2:], 1);
-	b[0] = 101;
-	b[4] = FirstKeycode;
-	b[5] = Count;
-	return c.sendRequest(b);
+	b := c.scratch[0:6]
+	put16(b[2:], 1)
+	b[0] = 101
+	b[4] = FirstKeycode
+	b[5] = Count
+	return c.sendRequest(b)
 }
 
 func (c *Conn) GetKeyboardMapping(FirstKeycode byte, Count byte) (*GetKeyboardMappingReply, os.Error) {
@@ -3579,66 +3579,66 @@ func (c *Conn) GetKeyboardMapping(FirstKeycode byte, Count byte) (*GetKeyboardMa
 }
 
 type GetKeyboardMappingReply struct {
-	KeysymsPerKeycode	byte;
-	Length			uint32;
-	Keysyms			[]Keysym;
+	KeysymsPerKeycode byte
+	Length            uint32
+	Keysyms           []Keysym
 }
 
 func (c *Conn) GetKeyboardMappingReply(cookie Cookie) (*GetKeyboardMappingReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(GetKeyboardMappingReply);
-	v.KeysymsPerKeycode = b[1];
-	v.Length = get32(b[4:]);
-	offset := 32;
-	v.Keysyms = make([]Keysym, int(v.Length));
+	v := new(GetKeyboardMappingReply)
+	v.KeysymsPerKeycode = b[1]
+	v.Length = get32(b[4:])
+	offset := 32
+	v.Keysyms = make([]Keysym, int(v.Length))
 	for i := 0; i < len(v.Keysyms); i++ {
 		v.Keysyms[i] = Keysym(get32(b[offset+i*4:]))
 	}
-	offset += len(v.Keysyms) * 4;
-	return v, nil;
+	offset += len(v.Keysyms) * 4
+	return v, nil
 }
 
 const (
-	KBKeyClickPercent	= 1;
-	KBBellPercent		= 2;
-	KBBellPitch		= 4;
-	KBBellDuration		= 8;
-	KBLed			= 16;
-	KBLedMode		= 32;
-	KBKey			= 64;
-	KBAutoRepeatMode	= 128;
+	KBKeyClickPercent = 1
+	KBBellPercent     = 2
+	KBBellPitch       = 4
+	KBBellDuration    = 8
+	KBLed             = 16
+	KBLedMode         = 32
+	KBKey             = 64
+	KBAutoRepeatMode  = 128
 )
 
 const (
-	LedModeOff	= 0;
-	LedModeOn	= 1;
+	LedModeOff = 0
+	LedModeOn  = 1
 )
 
 const (
-	AutoRepeatModeOff	= 0;
-	AutoRepeatModeOn	= 1;
-	AutoRepeatModeDefault	= 2;
+	AutoRepeatModeOff     = 0
+	AutoRepeatModeOn      = 1
+	AutoRepeatModeDefault = 2
 )
 
 func (c *Conn) ChangeKeyboardControl(ValueMask uint32, ValueList []uint32) {
-	b := c.scratch[0:8];
-	n := 8;
-	n += pad(popCount(int(ValueMask)) * 4);
-	put16(b[2:], uint16(n/4));
-	b[0] = 102;
-	put32(b[4:], ValueMask);
-	c.sendRequest(b);
-	c.sendUInt32List(ValueList[0:popCount(int(ValueMask))]);
+	b := c.scratch[0:8]
+	n := 8
+	n += pad(popCount(int(ValueMask)) * 4)
+	put16(b[2:], uint16(n/4))
+	b[0] = 102
+	put32(b[4:], ValueMask)
+	c.sendRequest(b)
+	c.sendUInt32List(ValueList[0:popCount(int(ValueMask))])
 }
 
 func (c *Conn) GetKeyboardControlRequest() Cookie {
-	b := c.scratch[0:4];
-	put16(b[2:], 1);
-	b[0] = 103;
-	return c.sendRequest(b);
+	b := c.scratch[0:4]
+	put16(b[2:], 1)
+	b[0] = 103
+	return c.sendRequest(b)
 }
 
 func (c *Conn) GetKeyboardControl() (*GetKeyboardControlReply, os.Error) {
@@ -3646,56 +3646,56 @@ func (c *Conn) GetKeyboardControl() (*GetKeyboardControlReply, os.Error) {
 }
 
 type GetKeyboardControlReply struct {
-	GlobalAutoRepeat	byte;
-	LedMask			uint32;
-	KeyClickPercent		byte;
-	BellPercent		byte;
-	BellPitch		uint16;
-	BellDuration		uint16;
-	AutoRepeats		[32]byte;
+	GlobalAutoRepeat byte
+	LedMask          uint32
+	KeyClickPercent  byte
+	BellPercent      byte
+	BellPitch        uint16
+	BellDuration     uint16
+	AutoRepeats      [32]byte
 }
 
 func (c *Conn) GetKeyboardControlReply(cookie Cookie) (*GetKeyboardControlReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(GetKeyboardControlReply);
-	v.GlobalAutoRepeat = b[1];
-	v.LedMask = get32(b[8:]);
-	v.KeyClickPercent = b[12];
-	v.BellPercent = b[13];
-	v.BellPitch = get16(b[14:]);
-	v.BellDuration = get16(b[16:]);
-	copy(v.AutoRepeats[0:32], b[20:]);
-	return v, nil;
+	v := new(GetKeyboardControlReply)
+	v.GlobalAutoRepeat = b[1]
+	v.LedMask = get32(b[8:])
+	v.KeyClickPercent = b[12]
+	v.BellPercent = b[13]
+	v.BellPitch = get16(b[14:])
+	v.BellDuration = get16(b[16:])
+	copy(v.AutoRepeats[0:32], b[20:])
+	return v, nil
 }
 
 func (c *Conn) Bell(Percent int8) {
-	b := c.scratch[0:4];
-	put16(b[2:], 1);
-	b[0] = 104;
-	b[1] = byte(Percent);
-	c.sendRequest(b);
+	b := c.scratch[0:4]
+	put16(b[2:], 1)
+	b[0] = 104
+	b[1] = byte(Percent)
+	c.sendRequest(b)
 }
 
 func (c *Conn) ChangePointerControl(AccelerationNumerator int16, AccelerationDenominator int16, Threshold int16, DoAcceleration byte, DoThreshold byte) {
-	b := c.scratch[0:12];
-	put16(b[2:], 3);
-	b[0] = 105;
-	put16(b[4:], uint16(AccelerationNumerator));
-	put16(b[6:], uint16(AccelerationDenominator));
-	put16(b[8:], uint16(Threshold));
-	b[10] = DoAcceleration;
-	b[11] = DoThreshold;
-	c.sendRequest(b);
+	b := c.scratch[0:12]
+	put16(b[2:], 3)
+	b[0] = 105
+	put16(b[4:], uint16(AccelerationNumerator))
+	put16(b[6:], uint16(AccelerationDenominator))
+	put16(b[8:], uint16(Threshold))
+	b[10] = DoAcceleration
+	b[11] = DoThreshold
+	c.sendRequest(b)
 }
 
 func (c *Conn) GetPointerControlRequest() Cookie {
-	b := c.scratch[0:4];
-	put16(b[2:], 1);
-	b[0] = 106;
-	return c.sendRequest(b);
+	b := c.scratch[0:4]
+	put16(b[2:], 1)
+	b[0] = 106
+	return c.sendRequest(b)
 }
 
 func (c *Conn) GetPointerControl() (*GetPointerControlReply, os.Error) {
@@ -3703,51 +3703,51 @@ func (c *Conn) GetPointerControl() (*GetPointerControlReply, os.Error) {
 }
 
 type GetPointerControlReply struct {
-	AccelerationNumerator	uint16;
-	AccelerationDenominator	uint16;
-	Threshold		uint16;
+	AccelerationNumerator   uint16
+	AccelerationDenominator uint16
+	Threshold               uint16
 }
 
 func (c *Conn) GetPointerControlReply(cookie Cookie) (*GetPointerControlReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(GetPointerControlReply);
-	v.AccelerationNumerator = get16(b[8:]);
-	v.AccelerationDenominator = get16(b[10:]);
-	v.Threshold = get16(b[12:]);
-	return v, nil;
+	v := new(GetPointerControlReply)
+	v.AccelerationNumerator = get16(b[8:])
+	v.AccelerationDenominator = get16(b[10:])
+	v.Threshold = get16(b[12:])
+	return v, nil
 }
 
 const (
-	BlankingNotPreferred	= 0;
-	BlankingPreferred	= 1;
-	BlankingDefault		= 2;
+	BlankingNotPreferred = 0
+	BlankingPreferred    = 1
+	BlankingDefault      = 2
 )
 
 const (
-	ExposuresNotAllowed	= 0;
-	ExposuresAllowed	= 1;
-	ExposuresDefault	= 2;
+	ExposuresNotAllowed = 0
+	ExposuresAllowed    = 1
+	ExposuresDefault    = 2
 )
 
 func (c *Conn) SetScreenSaver(Timeout int16, Interval int16, PreferBlanking byte, AllowExposures byte) {
-	b := c.scratch[0:10];
-	put16(b[2:], 2);
-	b[0] = 107;
-	put16(b[4:], uint16(Timeout));
-	put16(b[6:], uint16(Interval));
-	b[8] = PreferBlanking;
-	b[9] = AllowExposures;
-	c.sendRequest(b);
+	b := c.scratch[0:10]
+	put16(b[2:], 2)
+	b[0] = 107
+	put16(b[4:], uint16(Timeout))
+	put16(b[6:], uint16(Interval))
+	b[8] = PreferBlanking
+	b[9] = AllowExposures
+	c.sendRequest(b)
 }
 
 func (c *Conn) GetScreenSaverRequest() Cookie {
-	b := c.scratch[0:4];
-	put16(b[2:], 1);
-	b[0] = 108;
-	return c.sendRequest(b);
+	b := c.scratch[0:4]
+	put16(b[2:], 1)
+	b[0] = 108
+	return c.sendRequest(b)
 }
 
 func (c *Conn) GetScreenSaver() (*GetScreenSaverReply, os.Error) {
@@ -3755,74 +3755,74 @@ func (c *Conn) GetScreenSaver() (*GetScreenSaverReply, os.Error) {
 }
 
 type GetScreenSaverReply struct {
-	Timeout		uint16;
-	Interval	uint16;
-	PreferBlanking	byte;
-	AllowExposures	byte;
+	Timeout        uint16
+	Interval       uint16
+	PreferBlanking byte
+	AllowExposures byte
 }
 
 func (c *Conn) GetScreenSaverReply(cookie Cookie) (*GetScreenSaverReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(GetScreenSaverReply);
-	v.Timeout = get16(b[8:]);
-	v.Interval = get16(b[10:]);
-	v.PreferBlanking = b[12];
-	v.AllowExposures = b[13];
-	return v, nil;
+	v := new(GetScreenSaverReply)
+	v.Timeout = get16(b[8:])
+	v.Interval = get16(b[10:])
+	v.PreferBlanking = b[12]
+	v.AllowExposures = b[13]
+	return v, nil
 }
 
 const (
-	HostModeInsert	= 0;
-	HostModeDelete	= 1;
+	HostModeInsert = 0
+	HostModeDelete = 1
 )
 
 const (
-	FamilyInternet		= 0;
-	FamilyDECnet		= 1;
-	FamilyChaos		= 2;
-	FamilyServerInterpreted	= 5;
-	FamilyInternet6		= 6;
+	FamilyInternet          = 0
+	FamilyDECnet            = 1
+	FamilyChaos             = 2
+	FamilyServerInterpreted = 5
+	FamilyInternet6         = 6
 )
 
 func (c *Conn) ChangeHosts(Mode byte, Family byte, Address []byte) {
-	b := c.scratch[0:8];
-	n := 8;
-	n += pad(len(Address) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 109;
-	b[1] = Mode;
-	b[4] = Family;
-	put16(b[6:], uint16(len(Address)));
-	c.sendRequest(b);
-	c.sendBytes(Address[0:len(Address)]);
+	b := c.scratch[0:8]
+	n := 8
+	n += pad(len(Address) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 109
+	b[1] = Mode
+	b[4] = Family
+	put16(b[6:], uint16(len(Address)))
+	c.sendRequest(b)
+	c.sendBytes(Address[0:len(Address)])
 }
 
 type Host struct {
-	Family		byte;
-	AddressLen	uint16;
-	Address		[]byte;
+	Family     byte
+	AddressLen uint16
+	Address    []byte
 }
 
 func getHost(b []byte, v *Host) int {
-	v.Family = b[0];
-	v.AddressLen = get16(b[2:]);
-	offset := 4;
-	v.Address = make([]byte, int(v.AddressLen));
-	copy(v.Address[0:len(v.Address)], b[offset:]);
-	offset += len(v.Address) * 1;
-	return offset;
+	v.Family = b[0]
+	v.AddressLen = get16(b[2:])
+	offset := 4
+	v.Address = make([]byte, int(v.AddressLen))
+	copy(v.Address[0:len(v.Address)], b[offset:])
+	offset += len(v.Address) * 1
+	return offset
 }
 
 // omitting variable length sendHost
 
 func (c *Conn) ListHostsRequest() Cookie {
-	b := c.scratch[0:4];
-	put16(b[2:], 1);
-	b[0] = 110;
-	return c.sendRequest(b);
+	b := c.scratch[0:4]
+	put16(b[2:], 1)
+	b[0] = 110
+	return c.sendRequest(b)
 }
 
 func (c *Conn) ListHosts() (*ListHostsReply, os.Error) {
@@ -3830,108 +3830,108 @@ func (c *Conn) ListHosts() (*ListHostsReply, os.Error) {
 }
 
 type ListHostsReply struct {
-	Mode		byte;
-	HostsLen	uint16;
-	Hosts		[]Host;
+	Mode     byte
+	HostsLen uint16
+	Hosts    []Host
 }
 
 func (c *Conn) ListHostsReply(cookie Cookie) (*ListHostsReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(ListHostsReply);
-	v.Mode = b[1];
-	v.HostsLen = get16(b[8:]);
-	offset := 32;
-	v.Hosts = make([]Host, int(v.HostsLen));
+	v := new(ListHostsReply)
+	v.Mode = b[1]
+	v.HostsLen = get16(b[8:])
+	offset := 32
+	v.Hosts = make([]Host, int(v.HostsLen))
 	for i := 0; i < int(v.HostsLen); i++ {
 		offset += getHost(b[offset:], &v.Hosts[i])
 	}
-	return v, nil;
+	return v, nil
 }
 
 const (
-	AccessControlDisable	= 0;
-	AccessControlEnable	= 1;
+	AccessControlDisable = 0
+	AccessControlEnable  = 1
 )
 
 func (c *Conn) SetAccessControl(Mode byte) {
-	b := c.scratch[0:4];
-	put16(b[2:], 1);
-	b[0] = 111;
-	b[1] = Mode;
-	c.sendRequest(b);
+	b := c.scratch[0:4]
+	put16(b[2:], 1)
+	b[0] = 111
+	b[1] = Mode
+	c.sendRequest(b)
 }
 
 const (
-	CloseDownDestroyAll		= 0;
-	CloseDownRetainPermanent	= 1;
-	CloseDownRetainTemporary	= 2;
+	CloseDownDestroyAll      = 0
+	CloseDownRetainPermanent = 1
+	CloseDownRetainTemporary = 2
 )
 
 func (c *Conn) SetCloseDownMode(Mode byte) {
-	b := c.scratch[0:4];
-	put16(b[2:], 1);
-	b[0] = 112;
-	b[1] = Mode;
-	c.sendRequest(b);
+	b := c.scratch[0:4]
+	put16(b[2:], 1)
+	b[0] = 112
+	b[1] = Mode
+	c.sendRequest(b)
 }
 
 const (
-	KillAllTemporary = 0;
+	KillAllTemporary = 0
 )
 
 func (c *Conn) KillClient(Resource uint32) {
-	b := c.scratch[0:8];
-	put16(b[2:], 2);
-	b[0] = 113;
-	put32(b[4:], Resource);
-	c.sendRequest(b);
+	b := c.scratch[0:8]
+	put16(b[2:], 2)
+	b[0] = 113
+	put32(b[4:], Resource)
+	c.sendRequest(b)
 }
 
 func (c *Conn) RotateProperties(Window Id, Delta int16, Atoms []Id) {
-	b := c.scratch[0:12];
-	n := 12;
-	n += pad(len(Atoms) * 4);
-	put16(b[2:], uint16(n/4));
-	b[0] = 114;
-	put32(b[4:], uint32(Window));
-	put16(b[8:], uint16(len(Atoms)));
-	put16(b[10:], uint16(Delta));
-	c.sendRequest(b);
-	c.sendIdList(Atoms, len(Atoms));
+	b := c.scratch[0:12]
+	n := 12
+	n += pad(len(Atoms) * 4)
+	put16(b[2:], uint16(n/4))
+	b[0] = 114
+	put32(b[4:], uint32(Window))
+	put16(b[8:], uint16(len(Atoms)))
+	put16(b[10:], uint16(Delta))
+	c.sendRequest(b)
+	c.sendIdList(Atoms, len(Atoms))
 }
 
 const (
-	ScreenSaverReset	= 0;
-	ScreenSaverActive	= 1;
+	ScreenSaverReset  = 0
+	ScreenSaverActive = 1
 )
 
 func (c *Conn) ForceScreenSaver(Mode byte) {
-	b := c.scratch[0:4];
-	put16(b[2:], 1);
-	b[0] = 115;
-	b[1] = Mode;
-	c.sendRequest(b);
+	b := c.scratch[0:4]
+	put16(b[2:], 1)
+	b[0] = 115
+	b[1] = Mode
+	c.sendRequest(b)
 }
 
 const (
-	MappingStatusSuccess	= 0;
-	MappingStatusBusy	= 1;
-	MappingStatusFailure	= 2;
+	MappingStatusSuccess = 0
+	MappingStatusBusy    = 1
+	MappingStatusFailure = 2
 )
 
 func (c *Conn) SetPointerMappingRequest(Map []byte) Cookie {
-	b := c.scratch[0:4];
-	n := 4;
-	n += pad(len(Map) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 116;
-	b[1] = byte(len(Map));
-	cookie := c.sendRequest(b);
-	c.sendBytes(Map[0:len(Map)]);
-	return cookie;
+	b := c.scratch[0:4]
+	n := 4
+	n += pad(len(Map) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 116
+	b[1] = byte(len(Map))
+	cookie := c.sendRequest(b)
+	c.sendBytes(Map[0:len(Map)])
+	return cookie
 }
 
 func (c *Conn) SetPointerMapping(Map []byte) (*SetPointerMappingReply, os.Error) {
@@ -3939,24 +3939,24 @@ func (c *Conn) SetPointerMapping(Map []byte) (*SetPointerMappingReply, os.Error)
 }
 
 type SetPointerMappingReply struct {
-	Status byte;
+	Status byte
 }
 
 func (c *Conn) SetPointerMappingReply(cookie Cookie) (*SetPointerMappingReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(SetPointerMappingReply);
-	v.Status = b[1];
-	return v, nil;
+	v := new(SetPointerMappingReply)
+	v.Status = b[1]
+	return v, nil
 }
 
 func (c *Conn) GetPointerMappingRequest() Cookie {
-	b := c.scratch[0:4];
-	put16(b[2:], 1);
-	b[0] = 117;
-	return c.sendRequest(b);
+	b := c.scratch[0:4]
+	put16(b[2:], 1)
+	b[0] = 117
+	return c.sendRequest(b)
 }
 
 func (c *Conn) GetPointerMapping() (*GetPointerMappingReply, os.Error) {
@@ -3964,45 +3964,45 @@ func (c *Conn) GetPointerMapping() (*GetPointerMappingReply, os.Error) {
 }
 
 type GetPointerMappingReply struct {
-	MapLen	byte;
-	Map	[]byte;
+	MapLen byte
+	Map    []byte
 }
 
 func (c *Conn) GetPointerMappingReply(cookie Cookie) (*GetPointerMappingReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(GetPointerMappingReply);
-	v.MapLen = b[1];
-	offset := 32;
-	v.Map = make([]byte, int(v.MapLen));
-	copy(v.Map[0:len(v.Map)], b[offset:]);
-	offset += len(v.Map) * 1;
-	return v, nil;
+	v := new(GetPointerMappingReply)
+	v.MapLen = b[1]
+	offset := 32
+	v.Map = make([]byte, int(v.MapLen))
+	copy(v.Map[0:len(v.Map)], b[offset:])
+	offset += len(v.Map) * 1
+	return v, nil
 }
 
 const (
-	MapIndexShift	= 0;
-	MapIndexLock	= 1;
-	MapIndexControl	= 2;
-	MapIndex1	= 3;
-	MapIndex2	= 4;
-	MapIndex3	= 5;
-	MapIndex4	= 6;
-	MapIndex5	= 7;
+	MapIndexShift   = 0
+	MapIndexLock    = 1
+	MapIndexControl = 2
+	MapIndex1       = 3
+	MapIndex2       = 4
+	MapIndex3       = 5
+	MapIndex4       = 6
+	MapIndex5       = 7
 )
 
 func (c *Conn) SetModifierMappingRequest(KeycodesPerModifier byte, Keycodes []byte) Cookie {
-	b := c.scratch[0:4];
-	n := 4;
-	n += pad((int(KeycodesPerModifier) * 8) * 1);
-	put16(b[2:], uint16(n/4));
-	b[0] = 118;
-	b[1] = KeycodesPerModifier;
-	cookie := c.sendRequest(b);
-	c.sendBytes(Keycodes[0:(int(KeycodesPerModifier) * 8)]);
-	return cookie;
+	b := c.scratch[0:4]
+	n := 4
+	n += pad((int(KeycodesPerModifier) * 8) * 1)
+	put16(b[2:], uint16(n/4))
+	b[0] = 118
+	b[1] = KeycodesPerModifier
+	cookie := c.sendRequest(b)
+	c.sendBytes(Keycodes[0:(int(KeycodesPerModifier) * 8)])
+	return cookie
 }
 
 func (c *Conn) SetModifierMapping(KeycodesPerModifier byte, Keycodes []byte) (*SetModifierMappingReply, os.Error) {
@@ -4010,24 +4010,24 @@ func (c *Conn) SetModifierMapping(KeycodesPerModifier byte, Keycodes []byte) (*S
 }
 
 type SetModifierMappingReply struct {
-	Status byte;
+	Status byte
 }
 
 func (c *Conn) SetModifierMappingReply(cookie Cookie) (*SetModifierMappingReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(SetModifierMappingReply);
-	v.Status = b[1];
-	return v, nil;
+	v := new(SetModifierMappingReply)
+	v.Status = b[1]
+	return v, nil
 }
 
 func (c *Conn) GetModifierMappingRequest() Cookie {
-	b := c.scratch[0:4];
-	put16(b[2:], 1);
-	b[0] = 119;
-	return c.sendRequest(b);
+	b := c.scratch[0:4]
+	put16(b[2:], 1)
+	b[0] = 119
+	return c.sendRequest(b)
 }
 
 func (c *Conn) GetModifierMapping() (*GetModifierMappingReply, os.Error) {
@@ -4035,29 +4035,29 @@ func (c *Conn) GetModifierMapping() (*GetModifierMappingReply, os.Error) {
 }
 
 type GetModifierMappingReply struct {
-	KeycodesPerModifier	byte;
-	Keycodes		[]byte;
+	KeycodesPerModifier byte
+	Keycodes            []byte
 }
 
 func (c *Conn) GetModifierMappingReply(cookie Cookie) (*GetModifierMappingReply, os.Error) {
-	b, error := c.waitForReply(cookie);
+	b, error := c.waitForReply(cookie)
 	if error != nil {
 		return nil, error
 	}
-	v := new(GetModifierMappingReply);
-	v.KeycodesPerModifier = b[1];
-	offset := 32;
-	v.Keycodes = make([]byte, (int(v.KeycodesPerModifier) * 8));
-	copy(v.Keycodes[0:len(v.Keycodes)], b[offset:]);
-	offset += len(v.Keycodes) * 1;
-	return v, nil;
+	v := new(GetModifierMappingReply)
+	v.KeycodesPerModifier = b[1]
+	offset := 32
+	v.Keycodes = make([]byte, (int(v.KeycodesPerModifier) * 8))
+	copy(v.Keycodes[0:len(v.Keycodes)], b[offset:])
+	offset += len(v.Keycodes) * 1
+	return v, nil
 }
 
 func (c *Conn) NoOperation() {
-	b := c.scratch[0:4];
-	put16(b[2:], 1);
-	b[0] = 127;
-	c.sendRequest(b);
+	b := c.scratch[0:4]
+	put16(b[2:], 1)
+	b[0] = 127
+	c.sendRequest(b)
 }
 
 func parseEvent(buf []byte) (Event, os.Error) {
@@ -4129,7 +4129,7 @@ func parseEvent(buf []byte) (Event, os.Error) {
 	case MappingNotify:
 		return getMappingNotifyEvent(buf), nil
 	}
-	return nil, os.NewError("unknown event type");
+	return nil, os.NewError("unknown event type")
 }
 
 var errorNames = map[byte]string{
diff --git a/src/pkg/xml/read.go b/src/pkg/xml/read.go
index d8ee78a123..c1defe5e72 100644
--- a/src/pkg/xml/read.go
+++ b/src/pkg/xml/read.go
@@ -5,12 +5,12 @@
 package xml
 
 import (
-	"bytes";
-	"io";
-	"os";
-	"reflect";
-	"strings";
-	"unicode";
+	"bytes"
+	"io"
+	"os"
+	"reflect"
+	"strings"
+	"unicode"
 )
 
 // BUG(rsc): Mapping between XML elements and data structures is inherently flawed:
@@ -113,23 +113,23 @@ import (
 // to a freshly allocated value and then mapping the element to that value.
 //
 func Unmarshal(r io.Reader, val interface{}) os.Error {
-	v, ok := reflect.NewValue(val).(*reflect.PtrValue);
+	v, ok := reflect.NewValue(val).(*reflect.PtrValue)
 	if !ok {
 		return os.NewError("non-pointer passed to Unmarshal")
 	}
-	p := NewParser(r);
-	elem := v.Elem();
-	err := p.unmarshal(elem, nil);
+	p := NewParser(r)
+	elem := v.Elem()
+	err := p.unmarshal(elem, nil)
 	if err != nil {
 		return err
 	}
-	return nil;
+	return nil
 }
 
 // An UnmarshalError represents an error in the unmarshalling process.
 type UnmarshalError string
 
-func (e UnmarshalError) String() string	{ return string(e) }
+func (e UnmarshalError) String() string { return string(e) }
 
 // The Parser's Unmarshal method is like xml.Unmarshal
 // except that it can be passed a pointer to the initial start element,
@@ -138,11 +138,11 @@ func (e UnmarshalError) String() string	{ return string(e) }
 // Passing a nil start element indicates that Unmarshal should
 // read the token stream to find the start element.
 func (p *Parser) Unmarshal(val interface{}, start *StartElement) os.Error {
-	v, ok := reflect.NewValue(val).(*reflect.PtrValue);
+	v, ok := reflect.NewValue(val).(*reflect.PtrValue)
 	if !ok {
 		return os.NewError("non-pointer passed to Unmarshal")
 	}
-	return p.unmarshal(v.Elem(), start);
+	return p.unmarshal(v.Elem(), start)
 }
 
 // fieldName strips invalid characters from an XML name
@@ -154,7 +154,7 @@ func fieldName(original string) string {
 			if unicode.IsDigit(x) || unicode.IsLetter(x) {
 				return unicode.ToLower(x)
 			}
-			return -1;
+			return -1
 		},
 		original)
 }
@@ -164,87 +164,87 @@ func (p *Parser) unmarshal(val reflect.Value, start *StartElement) os.Error {
 	// Find start element if we need it.
 	if start == nil {
 		for {
-			tok, err := p.Token();
+			tok, err := p.Token()
 			if err != nil {
 				return err
 			}
 			if t, ok := tok.(StartElement); ok {
-				start = &t;
-				break;
+				start = &t
+				break
 			}
 		}
 	}
 
 	if pv, ok := val.(*reflect.PtrValue); ok {
 		if pv.Get() == 0 {
-			zv := reflect.MakeZero(pv.Type().(*reflect.PtrType).Elem());
-			pv.PointTo(zv);
-			val = zv;
+			zv := reflect.MakeZero(pv.Type().(*reflect.PtrType).Elem())
+			pv.PointTo(zv)
+			val = zv
 		} else {
 			val = pv.Elem()
 		}
 	}
 
 	var (
-		data		[]byte;
-		saveData	reflect.Value;
-		comment		[]byte;
-		saveComment	reflect.Value;
-		sv		*reflect.StructValue;
-		styp		*reflect.StructType;
+		data        []byte
+		saveData    reflect.Value
+		comment     []byte
+		saveComment reflect.Value
+		sv          *reflect.StructValue
+		styp        *reflect.StructType
 	)
 	switch v := val.(type) {
 	case *reflect.BoolValue:
 		v.Set(true)
 
 	case *reflect.SliceValue:
-		typ := v.Type().(*reflect.SliceType);
+		typ := v.Type().(*reflect.SliceType)
 		if _, ok := typ.Elem().(*reflect.Uint8Type); ok {
 			// []byte
-			saveData = v;
-			break;
+			saveData = v
+			break
 		}
 
 		// Slice of element values.
 		// Grow slice.
-		n := v.Len();
+		n := v.Len()
 		if n >= v.Cap() {
-			ncap := 2 * n;
+			ncap := 2 * n
 			if ncap < 4 {
 				ncap = 4
 			}
-			new := reflect.MakeSlice(typ, n, ncap);
-			reflect.ArrayCopy(new, v);
-			v.Set(new);
+			new := reflect.MakeSlice(typ, n, ncap)
+			reflect.ArrayCopy(new, v)
+			v.Set(new)
 		}
-		v.SetLen(n + 1);
+		v.SetLen(n + 1)
 
 		// Recur to read element into slice.
 		if err := p.unmarshal(v.Elem(n), start); err != nil {
-			v.SetLen(n);
-			return err;
+			v.SetLen(n)
+			return err
 		}
-		return nil;
+		return nil
 
 	case *reflect.StringValue:
 		saveData = v
 
 	case *reflect.StructValue:
 		if _, ok := v.Interface().(Name); ok {
-			v.Set(reflect.NewValue(start.Name).(*reflect.StructValue));
-			break;
+			v.Set(reflect.NewValue(start.Name).(*reflect.StructValue))
+			break
 		}
 
-		sv = v;
-		typ := sv.Type().(*reflect.StructType);
-		styp = typ;
+		sv = v
+		typ := sv.Type().(*reflect.StructType)
+		styp = typ
 		// Assign name.
 		if f, ok := typ.FieldByName("XMLName"); ok {
 			// Validate element name.
 			if f.Tag != "" {
-				tag := f.Tag;
-				ns := "";
-				i := strings.LastIndex(tag, " ");
+				tag := f.Tag
+				ns := ""
+				i := strings.LastIndex(tag, " ")
 				if i >= 0 {
 					ns, tag = tag[0:i], tag[i+1:]
 				}
@@ -252,44 +252,44 @@ func (p *Parser) unmarshal(val reflect.Value, start *StartElement) os.Error {
 					return UnmarshalError("expected element type <" + tag + "> but have <" + start.Name.Local + ">")
 				}
 				if ns != "" && ns != start.Name.Space {
-					e := "expected element <" + tag + "> in name space " + ns + " but have ";
+					e := "expected element <" + tag + "> in name space " + ns + " but have "
 					if start.Name.Space == "" {
 						e += "no name space"
 					} else {
 						e += start.Name.Space
 					}
-					return UnmarshalError(e);
+					return UnmarshalError(e)
 				}
 			}
 
 			// Save
-			v := sv.FieldByIndex(f.Index);
+			v := sv.FieldByIndex(f.Index)
 			if _, ok := v.Interface().(Name); !ok {
 				return UnmarshalError(sv.Type().String() + " field XMLName does not have type xml.Name")
 			}
-			v.(*reflect.StructValue).Set(reflect.NewValue(start.Name).(*reflect.StructValue));
+			v.(*reflect.StructValue).Set(reflect.NewValue(start.Name).(*reflect.StructValue))
 		}
 
 		// Assign attributes.
 		// Also, determine whether we need to save character data or comments.
 		for i, n := 0, typ.NumField(); i < n; i++ {
-			f := typ.Field(i);
+			f := typ.Field(i)
 			switch f.Tag {
 			case "attr":
-				strv, ok := sv.FieldByIndex(f.Index).(*reflect.StringValue);
+				strv, ok := sv.FieldByIndex(f.Index).(*reflect.StringValue)
 				if !ok {
 					return UnmarshalError(sv.Type().String() + " field " + f.Name + " has attr tag but is not type string")
 				}
 				// Look for attribute.
-				val := "";
-				k := strings.ToLower(f.Name);
+				val := ""
+				k := strings.ToLower(f.Name)
 				for _, a := range start.Attr {
 					if fieldName(a.Name.Local) == k {
-						val = a.Value;
-						break;
+						val = a.Value
+						break
 					}
 				}
-				strv.Set(val);
+				strv.Set(val)
 
 			case "comment":
 				if saveComment == nil {
@@ -308,7 +308,7 @@ func (p *Parser) unmarshal(val reflect.Value, start *StartElement) os.Error {
 	// Process sub-elements along the way.
 Loop:
 	for {
-		tok, err := p.Token();
+		tok, err := p.Token()
 		if err != nil {
 			return err
 		}
@@ -318,15 +318,15 @@ Loop:
 			// Look up by tag name.
 			// If that fails, fall back to mop-up field named "Any".
 			if sv != nil {
-				k := fieldName(t.Name.Local);
-				any := -1;
+				k := fieldName(t.Name.Local)
+				any := -1
 				for i, n := 0, styp.NumField(); i < n; i++ {
-					f := styp.Field(i);
+					f := styp.Field(i)
 					if strings.ToLower(f.Name) == k {
 						if err := p.unmarshal(sv.FieldByIndex(f.Index), &t); err != nil {
 							return err
 						}
-						continue Loop;
+						continue Loop
 					}
 					if any < 0 && f.Name == "Any" {
 						any = i
@@ -336,7 +336,7 @@ Loop:
 					if err := p.unmarshal(sv.FieldByIndex(styp.Field(any).Index), &t); err != nil {
 						return err
 					}
-					continue Loop;
+					continue Loop
 				}
 			}
 			// Not saving sub-element but still have to skip over it.
@@ -374,7 +374,7 @@ Loop:
 		t.Set(reflect.NewValue(comment).(*reflect.SliceValue))
 	}
 
-	return nil;
+	return nil
 }
 
 // Have already read a start element.
@@ -383,7 +383,7 @@ Loop:
 // end element matches the start element we saw.
 func (p *Parser) Skip() os.Error {
 	for {
-		tok, err := p.Token();
+		tok, err := p.Token()
 		if err != nil {
 			return err
 		}
@@ -396,5 +396,5 @@ func (p *Parser) Skip() os.Error {
 			return nil
 		}
 	}
-	panic("unreachable");
+	panic("unreachable")
 }
diff --git a/src/pkg/xml/read_test.go b/src/pkg/xml/read_test.go
index ca9b30d9b7..5722387a4f 100644
--- a/src/pkg/xml/read_test.go
+++ b/src/pkg/xml/read_test.go
@@ -5,14 +5,14 @@
 package xml
 
 import (
-	"reflect";
-	"testing";
+	"reflect"
+	"testing"
 )
 
 // Stripped down Atom feed data structures.
 
 func TestUnmarshalFeed(t *testing.T) {
-	var f Feed;
+	var f Feed
 	if err := Unmarshal(StringReader(rssFeedString), &f); err != nil {
 		t.Fatalf("Unmarshal: %s", err)
 	}
@@ -78,38 +78,38 @@ not being used from outside intra_region_diff.py.
 </summary></entry></feed>`
 
 type Feed struct {
-	XMLName	Name	"http://www.w3.org/2005/Atom feed";
-	Title	string;
-	Id	string;
-	Link	[]Link;
-	Updated	Time;
-	Author	Person;
-	Entry	[]Entry;
+	XMLName Name "http://www.w3.org/2005/Atom feed"
+	Title   string
+	Id      string
+	Link    []Link
+	Updated Time
+	Author  Person
+	Entry   []Entry
 }
 
 type Entry struct {
-	Title	string;
-	Id	string;
-	Link	[]Link;
-	Updated	Time;
-	Author	Person;
-	Summary	Text;
+	Title   string
+	Id      string
+	Link    []Link
+	Updated Time
+	Author  Person
+	Summary Text
 }
 
 type Link struct {
-	Rel	string	"attr";
-	Href	string	"attr";
+	Rel  string "attr"
+	Href string "attr"
 }
 
 type Person struct {
-	Name	string;
-	URI	string;
-	Email	string;
+	Name  string
+	URI   string
+	Email string
 }
 
 type Text struct {
-	Type	string	"attr";
-	Body	string	"chardata";
+	Type string "attr"
+	Body string "chardata"
 }
 
 type Time string
@@ -210,7 +210,7 @@ not being used from outside intra_region_diff.py.
 }
 
 type FieldNameTest struct {
-	in, out string;
+	in, out string
 }
 
 var FieldNameTests = []FieldNameTest{
@@ -220,7 +220,7 @@ var FieldNameTests = []FieldNameTest{
 
 func TestFieldName(t *testing.T) {
 	for _, tt := range FieldNameTests {
-		a := fieldName(tt.in);
+		a := fieldName(tt.in)
 		if a != tt.out {
 			t.Fatalf("have %#v\nwant %#v\n\n", a, tt.out)
 		}
diff --git a/src/pkg/xml/xml.go b/src/pkg/xml/xml.go
index 360a39863c..346b346492 100644
--- a/src/pkg/xml/xml.go
+++ b/src/pkg/xml/xml.go
@@ -15,20 +15,20 @@ package xml
 //	Expose parser line number in errors.
 
 import (
-	"bufio";
-	"bytes";
-	"io";
-	"os";
-	"strconv";
-	"strings";
-	"unicode";
-	"utf8";
+	"bufio"
+	"bytes"
+	"io"
+	"os"
+	"strconv"
+	"strings"
+	"unicode"
+	"utf8"
 )
 
 // A SyntaxError represents a syntax error in the XML input stream.
 type SyntaxError string
 
-func (e SyntaxError) String() string	{ return "XML syntax error: " + string(e) }
+func (e SyntaxError) String() string { return "XML syntax error: " + string(e) }
 
 // A Name represents an XML name (Local) annotated
 // with a name space identifier (Space).
@@ -36,13 +36,13 @@ func (e SyntaxError) String() string	{ return "XML syntax error: " + string(e) }
 // is given as a canonical URL, not the short prefix used
 // in the document being parsed.
 type Name struct {
-	Space, Local string;
+	Space, Local string
 }
 
 // An Attr represents an attribute in an XML element (Name=Value).
 type Attr struct {
-	Name	Name;
-	Value	string;
+	Name  Name
+	Value string
 }
 
 // A Token is an interface holding one of the token types:
@@ -51,13 +51,13 @@ type Token interface{}
 
 // A StartElement represents an XML start element.
 type StartElement struct {
-	Name	Name;
-	Attr	[]Attr;
+	Name Name
+	Attr []Attr
 }
 
 // An EndElement represents an XML end element.
 type EndElement struct {
-	Name Name;
+	Name Name
 }
 
 // A CharData represents XML character data (raw text),
@@ -66,38 +66,38 @@ type EndElement struct {
 type CharData []byte
 
 func makeCopy(b []byte) []byte {
-	b1 := make([]byte, len(b));
-	copy(b1, b);
-	return b1;
+	b1 := make([]byte, len(b))
+	copy(b1, b)
+	return b1
 }
 
-func (c CharData) Copy() CharData	{ return CharData(makeCopy(c)) }
+func (c CharData) Copy() CharData { return CharData(makeCopy(c)) }
 
 // A Comment represents an XML comment of the form <!--comment-->.
 // The bytes do not include the <!-- and --> comment markers.
 type Comment []byte
 
-func (c Comment) Copy() Comment	{ return Comment(makeCopy(c)) }
+func (c Comment) Copy() Comment { return Comment(makeCopy(c)) }
 
 // A ProcInst represents an XML processing instruction of the form <?target inst?>
 type ProcInst struct {
-	Target	string;
-	Inst	[]byte;
+	Target string
+	Inst   []byte
 }
 
 func (p ProcInst) Copy() ProcInst {
-	p.Inst = makeCopy(p.Inst);
-	return p;
+	p.Inst = makeCopy(p.Inst)
+	return p
 }
 
 // A Directive represents an XML directive of the form <!text>.
 // The bytes do not include the <! and > markers.
 type Directive []byte
 
-func (d Directive) Copy() Directive	{ return Directive(makeCopy(d)) }
+func (d Directive) Copy() Directive { return Directive(makeCopy(d)) }
 
 type readByter interface {
-	ReadByte() (b byte, err os.Error);
+	ReadByte() (b byte, err os.Error)
 }
 
 // A Parser represents an XML parser reading a particular input stream.
@@ -120,12 +120,12 @@ type Parser struct {
 	//	p.Entity = HTMLEntity
 	//
 	// creates a parser that can handle typical HTML.
-	Strict	bool;
+	Strict bool
 
 	// When Strict == false, AutoClose indicates a set of elements to
 	// consider closed immediately after they are opened, regardless
 	// of whether an end element is present.
-	AutoClose	[]string;
+	AutoClose []string
 
 	// Entity can be used to map non-standard entity names to string replacements.
 	// The parser behaves as if these standard mappings are present in the map,
@@ -137,20 +137,20 @@ type Parser struct {
 	//	"pos": "'",
 	//	"quot": `"`,
 	//
-	Entity	map[string]string;
-
-	r		readByter;
-	buf		bytes.Buffer;
-	stk		*stack;
-	free		*stack;
-	needClose	bool;
-	toClose		Name;
-	nextToken	Token;
-	nextByte	int;
-	ns		map[string]string;
-	err		os.Error;
-	line		int;
-	tmp		[32]byte;
+	Entity map[string]string
+
+	r         readByter
+	buf       bytes.Buffer
+	stk       *stack
+	free      *stack
+	needClose bool
+	toClose   Name
+	nextToken Token
+	nextByte  int
+	ns        map[string]string
+	err       os.Error
+	line      int
+	tmp       [32]byte
 }
 
 // NewParser creates a new XML parser reading from r.
@@ -160,7 +160,7 @@ func NewParser(r io.Reader) *Parser {
 		nextByte: -1,
 		line: 1,
 		Strict: true,
-	};
+	}
 
 	// Get efficient byte at a time reader.
 	// Assume that if reader has its own
@@ -172,7 +172,7 @@ func NewParser(r io.Reader) *Parser {
 		p.r = bufio.NewReader(r)
 	}
 
-	return p;
+	return p
 }
 
 // Token returns the next XML token in the input stream.
@@ -200,16 +200,16 @@ func NewParser(r io.Reader) *Parser {
 //
 func (p *Parser) Token() (t Token, err os.Error) {
 	if p.nextToken != nil {
-		t = p.nextToken;
-		p.nextToken = nil;
+		t = p.nextToken
+		p.nextToken = nil
 	} else if t, err = p.RawToken(); err != nil {
 		return
 	}
 
 	if !p.Strict {
 		if t1, ok := p.autoClose(t); ok {
-			p.nextToken = t;
-			t = t1;
+			p.nextToken = t
+			t = t1
 		}
 	}
 	switch t1 := t.(type) {
@@ -220,33 +220,33 @@ func (p *Parser) Token() (t Token, err os.Error) {
 		// the translations first.
 		for _, a := range t1.Attr {
 			if a.Name.Space == "xmlns" {
-				v, ok := p.ns[a.Name.Local];
-				p.pushNs(a.Name.Local, v, ok);
-				p.ns[a.Name.Local] = a.Value;
+				v, ok := p.ns[a.Name.Local]
+				p.pushNs(a.Name.Local, v, ok)
+				p.ns[a.Name.Local] = a.Value
 			}
 			if a.Name.Space == "" && a.Name.Local == "xmlns" {
 				// Default space for untagged names
-				v, ok := p.ns[""];
-				p.pushNs("", v, ok);
-				p.ns[""] = a.Value;
+				v, ok := p.ns[""]
+				p.pushNs("", v, ok)
+				p.ns[""] = a.Value
 			}
 		}
 
-		p.translate(&t1.Name, true);
+		p.translate(&t1.Name, true)
 		for i := range t1.Attr {
 			p.translate(&t1.Attr[i].Name, false)
 		}
-		p.pushElement(t1.Name);
-		t = t1;
+		p.pushElement(t1.Name)
+		t = t1
 
 	case EndElement:
-		p.translate(&t1.Name, true);
+		p.translate(&t1.Name, true)
 		if !p.popElement(&t1) {
 			return nil, p.err
 		}
-		t = t1;
+		t = t1
 	}
-	return;
+	return
 }
 
 // Apply name space translation to name n.
@@ -271,53 +271,53 @@ func (p *Parser) translate(n *Name, isElementName bool) {
 // ending a given tag are *below* it on the stack, which is
 // more work but forced on us by XML.
 type stack struct {
-	next	*stack;
-	kind	int;
-	name	Name;
-	ok	bool;
+	next *stack
+	kind int
+	name Name
+	ok   bool
 }
 
 const (
-	stkStart	= iota;
-	stkNs;
+	stkStart = iota
+	stkNs
 )
 
 func (p *Parser) push(kind int) *stack {
-	s := p.free;
+	s := p.free
 	if s != nil {
 		p.free = s.next
 	} else {
 		s = new(stack)
 	}
-	s.next = p.stk;
-	s.kind = kind;
-	p.stk = s;
-	return s;
+	s.next = p.stk
+	s.kind = kind
+	p.stk = s
+	return s
 }
 
 func (p *Parser) pop() *stack {
-	s := p.stk;
+	s := p.stk
 	if s != nil {
-		p.stk = s.next;
-		s.next = p.free;
-		p.free = s;
+		p.stk = s.next
+		s.next = p.free
+		p.free = s
 	}
-	return s;
+	return s
 }
 
 // Record that we are starting an element with the given name.
 func (p *Parser) pushElement(name Name) {
-	s := p.push(stkStart);
-	s.name = name;
+	s := p.push(stkStart)
+	s.name = name
 }
 
 // Record that we are changing the value of ns[local].
 // The old value is url, ok.
 func (p *Parser) pushNs(local string, url string, ok bool) {
-	s := p.push(stkNs);
-	s.name.Local = local;
-	s.name.Space = url;
-	s.ok = ok;
+	s := p.push(stkNs)
+	s.name.Local = local
+	s.name.Space = url
+	s.ok = ok
 }
 
 // Record that we are ending an element with the given name.
@@ -327,35 +327,35 @@ func (p *Parser) pushNs(local string, url string, ok bool) {
 // the stack to restore the name translations that existed
 // before we saw this element.
 func (p *Parser) popElement(t *EndElement) bool {
-	s := p.pop();
-	name := t.Name;
+	s := p.pop()
+	name := t.Name
 	switch {
 	case s == nil || s.kind != stkStart:
-		p.err = SyntaxError("unexpected end element </" + name.Local + ">");
-		return false;
+		p.err = SyntaxError("unexpected end element </" + name.Local + ">")
+		return false
 	case s.name.Local != name.Local:
 		if !p.Strict {
-			p.needClose = true;
-			p.toClose = t.Name;
-			t.Name = s.name;
-			return true;
+			p.needClose = true
+			p.toClose = t.Name
+			t.Name = s.name
+			return true
 		}
-		p.err = SyntaxError("element <" + s.name.Local + "> closed by </" + name.Local + ">");
-		return false;
+		p.err = SyntaxError("element <" + s.name.Local + "> closed by </" + name.Local + ">")
+		return false
 	case s.name.Space != name.Space:
 		p.err = SyntaxError("element <" + s.name.Local + "> in space " + s.name.Space +
-			"closed by </" + name.Local + "> in space " + name.Space);
-		return false;
+			"closed by </" + name.Local + "> in space " + name.Space)
+		return false
 	}
 
 	// Pop stack until a Start is on the top, undoing the
 	// translations that were associated with the element we just closed.
 	for p.stk != nil && p.stk.kind != stkStart {
-		s := p.pop();
-		p.ns[s.name.Local] = s.name.Space, s.ok;
+		s := p.pop()
+		p.ns[s.name.Local] = s.name.Space, s.ok
 	}
 
-	return true;
+	return true
 }
 
 // If the top element on the stack is autoclosing and
@@ -364,18 +364,18 @@ func (p *Parser) autoClose(t Token) (Token, bool) {
 	if p.stk == nil || p.stk.kind != stkStart {
 		return nil, false
 	}
-	name := strings.ToLower(p.stk.name.Local);
+	name := strings.ToLower(p.stk.name.Local)
 	for _, s := range p.AutoClose {
 		if strings.ToLower(s) == name {
 			// This one should be auto closed if t doesn't close it.
-			et, ok := t.(EndElement);
+			et, ok := t.(EndElement)
 			if !ok || et.Name.Local != name {
 				return EndElement{p.stk.name}, true
 			}
-			break;
+			break
 		}
 	}
-	return nil, false;
+	return nil, false
 }
 
 
@@ -390,23 +390,23 @@ func (p *Parser) RawToken() (Token, os.Error) {
 		// The last element we read was self-closing and
 		// we returned just the StartElement half.
 		// Return the EndElement half now.
-		p.needClose = false;
-		return EndElement{p.toClose}, nil;
+		p.needClose = false
+		return EndElement{p.toClose}, nil
 	}
 
-	b, ok := p.getc();
+	b, ok := p.getc()
 	if !ok {
 		return nil, p.err
 	}
 
 	if b != '<' {
 		// Text section.
-		p.ungetc(b);
-		data := p.text(-1, false);
+		p.ungetc(b)
+		data := p.text(-1, false)
 		if data == nil {
 			return nil, p.err
 		}
-		return CharData(data), nil;
+		return CharData(data), nil
 	}
 
 	if b, ok = p.mustgetc(); !ok {
@@ -415,50 +415,50 @@ func (p *Parser) RawToken() (Token, os.Error) {
 	switch b {
 	case '/':
 		// </: End element
-		var name Name;
+		var name Name
 		if name, ok = p.nsname(); !ok {
 			if p.err == nil {
 				p.err = SyntaxError("expected element name after </")
 			}
-			return nil, p.err;
+			return nil, p.err
 		}
-		p.space();
+		p.space()
 		if b, ok = p.mustgetc(); !ok {
 			return nil, p.err
 		}
 		if b != '>' {
-			p.err = SyntaxError("invalid characters between </" + name.Local + " and >");
-			return nil, p.err;
+			p.err = SyntaxError("invalid characters between </" + name.Local + " and >")
+			return nil, p.err
 		}
-		return EndElement{name}, nil;
+		return EndElement{name}, nil
 
 	case '?':
 		// <?: Processing instruction.
 		// TODO(rsc): Should parse the <?xml declaration to make sure
 		// the version is 1.0 and the encoding is UTF-8.
-		var target string;
+		var target string
 		if target, ok = p.name(); !ok {
 			if p.err == nil {
 				p.err = SyntaxError("expected target name after <?")
 			}
-			return nil, p.err;
+			return nil, p.err
 		}
-		p.space();
-		p.buf.Reset();
-		var b0 byte;
+		p.space()
+		p.buf.Reset()
+		var b0 byte
 		for {
 			if b, ok = p.mustgetc(); !ok {
 				return nil, p.err
 			}
-			p.buf.WriteByte(b);
+			p.buf.WriteByte(b)
 			if b0 == '?' && b == '>' {
 				break
 			}
-			b0 = b;
+			b0 = b
 		}
-		data := p.buf.Bytes();
-		data = data[0 : len(data)-2];	// chop ?>
-		return ProcInst{target, data}, nil;
+		data := p.buf.Bytes()
+		data = data[0 : len(data)-2] // chop ?>
+		return ProcInst{target, data}, nil
 
 	case '!':
 		// <!: Maybe comment, maybe CDATA.
@@ -466,55 +466,55 @@ func (p *Parser) RawToken() (Token, os.Error) {
 			return nil, p.err
 		}
 		switch b {
-		case '-':	// <!-
+		case '-': // <!-
 			// Probably <!-- for a comment.
 			if b, ok = p.mustgetc(); !ok {
 				return nil, p.err
 			}
 			if b != '-' {
-				p.err = SyntaxError("invalid sequence <!- not part of <!--");
-				return nil, p.err;
+				p.err = SyntaxError("invalid sequence <!- not part of <!--")
+				return nil, p.err
 			}
 			// Look for terminator.
-			p.buf.Reset();
-			var b0, b1 byte;
+			p.buf.Reset()
+			var b0, b1 byte
 			for {
 				if b, ok = p.mustgetc(); !ok {
 					return nil, p.err
 				}
-				p.buf.WriteByte(b);
+				p.buf.WriteByte(b)
 				if b0 == '-' && b1 == '-' && b == '>' {
 					break
 				}
-				b0, b1 = b1, b;
+				b0, b1 = b1, b
 			}
-			data := p.buf.Bytes();
-			data = data[0 : len(data)-3];	// chop -->
-			return Comment(data), nil;
+			data := p.buf.Bytes()
+			data = data[0 : len(data)-3] // chop -->
+			return Comment(data), nil
 
-		case '[':	// <![
+		case '[': // <![
 			// Probably <![CDATA[.
 			for i := 0; i < 6; i++ {
 				if b, ok = p.mustgetc(); !ok {
 					return nil, p.err
 				}
 				if b != "CDATA["[i] {
-					p.err = SyntaxError("invalid <![ sequence");
-					return nil, p.err;
+					p.err = SyntaxError("invalid <![ sequence")
+					return nil, p.err
 				}
 			}
 			// Have <![CDATA[.  Read text until ]]>.
-			data := p.text(-1, true);
+			data := p.text(-1, true)
 			if data == nil {
 				return nil, p.err
 			}
-			return CharData(data), nil;
+			return CharData(data), nil
 		}
 
 		// Probably a directive: <!DOCTYPE ...>, <!ENTITY ...>, etc.
 		// We don't care, but accumulate for caller.
-		p.buf.Reset();
-		p.buf.WriteByte(b);
+		p.buf.Reset()
+		p.buf.WriteByte(b)
 		for {
 			if b, ok = p.mustgetc(); !ok {
 				return nil, p.err
@@ -522,106 +522,106 @@ func (p *Parser) RawToken() (Token, os.Error) {
 			if b == '>' {
 				break
 			}
-			p.buf.WriteByte(b);
+			p.buf.WriteByte(b)
 		}
-		return Directive(p.buf.Bytes()), nil;
+		return Directive(p.buf.Bytes()), nil
 	}
 
 	// Must be an open element like <a href="foo">
-	p.ungetc(b);
+	p.ungetc(b)
 
 	var (
-		name	Name;
-		empty	bool;
-		attr	[]Attr;
+		name  Name
+		empty bool
+		attr  []Attr
 	)
 	if name, ok = p.nsname(); !ok {
 		if p.err == nil {
 			p.err = SyntaxError("expected element name after <")
 		}
-		return nil, p.err;
+		return nil, p.err
 	}
 
-	attr = make([]Attr, 0, 4);
+	attr = make([]Attr, 0, 4)
 	for {
-		p.space();
+		p.space()
 		if b, ok = p.mustgetc(); !ok {
 			return nil, p.err
 		}
 		if b == '/' {
-			empty = true;
+			empty = true
 			if b, ok = p.mustgetc(); !ok {
 				return nil, p.err
 			}
 			if b != '>' {
-				p.err = SyntaxError("expected /> in element");
-				return nil, p.err;
+				p.err = SyntaxError("expected /> in element")
+				return nil, p.err
 			}
-			break;
+			break
 		}
 		if b == '>' {
 			break
 		}
-		p.ungetc(b);
+		p.ungetc(b)
 
-		n := len(attr);
+		n := len(attr)
 		if n >= cap(attr) {
-			nattr := make([]Attr, n, 2*cap(attr));
+			nattr := make([]Attr, n, 2*cap(attr))
 			for i, a := range attr {
 				nattr[i] = a
 			}
-			attr = nattr;
+			attr = nattr
 		}
-		attr = attr[0 : n+1];
-		a := &attr[n];
+		attr = attr[0 : n+1]
+		a := &attr[n]
 		if a.Name, ok = p.nsname(); !ok {
 			if p.err == nil {
 				p.err = SyntaxError("expected attribute name in element")
 			}
-			return nil, p.err;
+			return nil, p.err
 		}
-		p.space();
+		p.space()
 		if b, ok = p.mustgetc(); !ok {
 			return nil, p.err
 		}
 		if b != '=' {
-			p.err = SyntaxError("attribute name without = in element");
-			return nil, p.err;
+			p.err = SyntaxError("attribute name without = in element")
+			return nil, p.err
 		}
-		p.space();
+		p.space()
 		if b, ok = p.mustgetc(); !ok {
 			return nil, p.err
 		}
 		if b != '"' && b != '\'' {
-			p.err = SyntaxError("unquoted or missing attribute value in element");
-			return nil, p.err;
+			p.err = SyntaxError("unquoted or missing attribute value in element")
+			return nil, p.err
 		}
-		data := p.text(int(b), false);
+		data := p.text(int(b), false)
 		if data == nil {
 			return nil, p.err
 		}
-		a.Value = string(data);
+		a.Value = string(data)
 	}
 
 	if empty {
-		p.needClose = true;
-		p.toClose = name;
+		p.needClose = true
+		p.toClose = name
 	}
-	return StartElement{name, attr}, nil;
+	return StartElement{name, attr}, nil
 }
 
 // Skip spaces if any
 func (p *Parser) space() {
 	for {
-		b, ok := p.getc();
+		b, ok := p.getc()
 		if !ok {
 			return
 		}
 		switch b {
 		case ' ', '\r', '\n', '\t':
 		default:
-			p.ungetc(b);
-			return;
+			p.ungetc(b)
+			return
 		}
 	}
 }
@@ -635,10 +635,10 @@ func (p *Parser) getc() (b byte, ok bool) {
 		return 0, false
 	}
 	if p.nextByte >= 0 {
-		b = byte(p.nextByte);
-		p.nextByte = -1;
+		b = byte(p.nextByte)
+		p.nextByte = -1
 	} else {
-		b, p.err = p.r.ReadByte();
+		b, p.err = p.r.ReadByte()
 		if p.err != nil {
 			return 0, false
 		}
@@ -646,7 +646,7 @@ func (p *Parser) getc() (b byte, ok bool) {
 	if b == '\n' {
 		p.line++
 	}
-	return b, true;
+	return b, true
 }
 
 // Must read a single byte.
@@ -659,7 +659,7 @@ func (p *Parser) mustgetc() (b byte, ok bool) {
 			p.err = SyntaxError("unexpected EOF")
 		}
 	}
-	return;
+	return
 }
 
 // Unread a single byte.
@@ -667,7 +667,7 @@ func (p *Parser) ungetc(b byte) {
 	if b == '\n' {
 		p.line--
 	}
-	p.nextByte = int(b);
+	p.nextByte = int(b)
 }
 
 var entity = map[string]int{
@@ -683,12 +683,12 @@ var entity = map[string]int{
 // If cdata == true, we are in a <![CDATA[ section and need to find ]]>.
 // On failure return nil and leave the error in p.err.
 func (p *Parser) text(quote int, cdata bool) []byte {
-	var b0, b1 byte;
-	var trunc int;
-	p.buf.Reset();
+	var b0, b1 byte
+	var trunc int
+	p.buf.Reset()
 Input:
 	for {
-		b, ok := p.mustgetc();
+		b, ok := p.mustgetc()
 		if !ok {
 			return nil
 		}
@@ -697,21 +697,21 @@ Input:
 		// It is an error for ]]> to appear in ordinary text.
 		if b0 == ']' && b1 == ']' && b == '>' {
 			if cdata {
-				trunc = 2;
-				break Input;
+				trunc = 2
+				break Input
 			}
-			p.err = SyntaxError("unescaped ]]> not in CDATA section");
-			return nil;
+			p.err = SyntaxError("unescaped ]]> not in CDATA section")
+			return nil
 		}
 
 		// Stop reading text if we see a <.
 		if b == '<' && !cdata {
 			if quote >= 0 {
-				p.err = SyntaxError("unescaped < inside quoted string");
-				return nil;
+				p.err = SyntaxError("unescaped < inside quoted string")
+				return nil
 			}
-			p.ungetc('<');
-			break Input;
+			p.ungetc('<')
+			break Input
 		}
 		if quote >= 0 && b == byte(quote) {
 			break Input
@@ -722,17 +722,17 @@ Input:
 			// its own character names with <!ENTITY ...> directives.
 			// Parsers are required to recognize lt, gt, amp, apos, and quot
 			// even if they have not been declared.  That's all we allow.
-			var i int;
+			var i int
 		CharLoop:
 			for i = 0; i < len(p.tmp); i++ {
-				p.tmp[i], p.err = p.r.ReadByte();
+				p.tmp[i], p.err = p.r.ReadByte()
 				if p.err != nil {
 					if p.err == os.EOF {
 						p.err = SyntaxError("unexpected EOF")
 					}
-					return nil;
+					return nil
 				}
-				c := p.tmp[i];
+				c := p.tmp[i]
 				if c == ';' {
 					break
 				}
@@ -742,131 +742,131 @@ Input:
 					c == '_' || c == '#' {
 					continue
 				}
-				p.ungetc(c);
-				break;
+				p.ungetc(c)
+				break
 			}
-			s := string(p.tmp[0:i]);
+			s := string(p.tmp[0:i])
 			if i >= len(p.tmp) {
 				if !p.Strict {
-					b0, b1 = 0, 0;
-					p.buf.WriteByte('&');
-					p.buf.Write(p.tmp[0:i]);
-					continue Input;
+					b0, b1 = 0, 0
+					p.buf.WriteByte('&')
+					p.buf.Write(p.tmp[0:i])
+					continue Input
 				}
-				p.err = SyntaxError("character entity expression &" + s + "... too long");
-				return nil;
+				p.err = SyntaxError("character entity expression &" + s + "... too long")
+				return nil
 			}
-			var haveText bool;
-			var text string;
+			var haveText bool
+			var text string
 			if i >= 2 && s[0] == '#' {
-				var n uint64;
-				var err os.Error;
+				var n uint64
+				var err os.Error
 				if i >= 3 && s[1] == 'x' {
 					n, err = strconv.Btoui64(s[2:], 16)
 				} else {
 					n, err = strconv.Btoui64(s[1:], 10)
 				}
 				if err == nil && n <= unicode.MaxRune {
-					text = string(n);
-					haveText = true;
+					text = string(n)
+					haveText = true
 				}
 			} else {
 				if r, ok := entity[s]; ok {
-					text = string(r);
-					haveText = true;
+					text = string(r)
+					haveText = true
 				} else if p.Entity != nil {
 					text, haveText = p.Entity[s]
 				}
 			}
 			if !haveText {
 				if !p.Strict {
-					b0, b1 = 0, 0;
-					p.buf.WriteByte('&');
-					p.buf.Write(p.tmp[0:i]);
-					continue Input;
+					b0, b1 = 0, 0
+					p.buf.WriteByte('&')
+					p.buf.Write(p.tmp[0:i])
+					continue Input
 				}
-				p.err = SyntaxError("invalid character entity &" + s + ";");
-				return nil;
+				p.err = SyntaxError("invalid character entity &" + s + ";")
+				return nil
 			}
-			p.buf.Write(strings.Bytes(text));
-			b0, b1 = 0, 0;
-			continue Input;
+			p.buf.Write(strings.Bytes(text))
+			b0, b1 = 0, 0
+			continue Input
 		}
-		p.buf.WriteByte(b);
-		b0, b1 = b1, b;
+		p.buf.WriteByte(b)
+		b0, b1 = b1, b
 	}
-	data := p.buf.Bytes();
-	data = data[0 : len(data)-trunc];
+	data := p.buf.Bytes()
+	data = data[0 : len(data)-trunc]
 
 	// Must rewrite \r and \r\n into \n.
-	w := 0;
+	w := 0
 	for r := 0; r < len(data); r++ {
-		b := data[r];
+		b := data[r]
 		if b == '\r' {
 			if r+1 < len(data) && data[r+1] == '\n' {
 				continue
 			}
-			b = '\n';
+			b = '\n'
 		}
-		data[w] = b;
-		w++;
+		data[w] = b
+		w++
 	}
-	return data[0:w];
+	return data[0:w]
 }
 
 // Get name space name: name with a : stuck in the middle.
 // The part before the : is the name space identifier.
 func (p *Parser) nsname() (name Name, ok bool) {
-	s, ok := p.name();
+	s, ok := p.name()
 	if !ok {
 		return
 	}
-	i := strings.Index(s, ":");
+	i := strings.Index(s, ":")
 	if i < 0 {
 		name.Local = s
 	} else {
-		name.Space = s[0:i];
-		name.Local = s[i+1:];
+		name.Space = s[0:i]
+		name.Local = s[i+1:]
 	}
-	return name, true;
+	return name, true
 }
 
 // Get name: /first(first|second)*/
 // Do not set p.err if the name is missing (unless unexpected EOF is received):
 // let the caller provide better context.
 func (p *Parser) name() (s string, ok bool) {
-	var b byte;
+	var b byte
 	if b, ok = p.mustgetc(); !ok {
 		return
 	}
 
 	// As a first approximation, we gather the bytes [A-Za-z_:.-\x80-\xFF]*
 	if b < utf8.RuneSelf && !isNameByte(b) {
-		p.ungetc(b);
-		return "", false;
+		p.ungetc(b)
+		return "", false
 	}
-	p.buf.Reset();
-	p.buf.WriteByte(b);
+	p.buf.Reset()
+	p.buf.WriteByte(b)
 	for {
 		if b, ok = p.mustgetc(); !ok {
 			return
 		}
 		if b < utf8.RuneSelf && !isNameByte(b) {
-			p.ungetc(b);
-			break;
+			p.ungetc(b)
+			break
 		}
-		p.buf.WriteByte(b);
+		p.buf.WriteByte(b)
 	}
 
 	// Then we check the characters.
-	s = p.buf.String();
+	s = p.buf.String()
 	for i, c := range s {
 		if !unicode.Is(first, c) && (i == 0 || !unicode.Is(second, c)) {
-			p.err = SyntaxError("invalid XML name: " + s);
-			return "", false;
+			p.err = SyntaxError("invalid XML name: " + s)
+			return "", false
 		}
 	}
-	return s, true;
+	return s, true
 }
 
 func isNameByte(c byte) bool {
diff --git a/src/pkg/xml/xml_test.go b/src/pkg/xml/xml_test.go
index e689949afe..43d418c1ea 100644
--- a/src/pkg/xml/xml_test.go
+++ b/src/pkg/xml/xml_test.go
@@ -5,11 +5,11 @@
 package xml
 
 import (
-	"io";
-	"os";
-	"reflect";
-	"strings";
-	"testing";
+	"io"
+	"os"
+	"reflect"
+	"strings"
+	"testing"
 )
 
 const testInput = `
@@ -146,8 +146,8 @@ var xmlInput = []string{
 }
 
 type stringReader struct {
-	s	string;
-	off	int;
+	s   string
+	off int
 }
 
 func (r *stringReader) Read(b []byte) (n int, err os.Error) {
@@ -155,29 +155,29 @@ func (r *stringReader) Read(b []byte) (n int, err os.Error) {
 		return 0, os.EOF
 	}
 	for r.off < len(r.s) && n < len(b) {
-		b[n] = r.s[r.off];
-		n++;
-		r.off++;
+		b[n] = r.s[r.off]
+		n++
+		r.off++
 	}
-	return;
+	return
 }
 
 func (r *stringReader) ReadByte() (b byte, err os.Error) {
 	if r.off >= len(r.s) {
 		return 0, os.EOF
 	}
-	b = r.s[r.off];
-	r.off++;
-	return;
+	b = r.s[r.off]
+	r.off++
+	return
 }
 
-func StringReader(s string) io.Reader	{ return &stringReader{s, 0} }
+func StringReader(s string) io.Reader { return &stringReader{s, 0} }
 
 func TestRawToken(t *testing.T) {
-	p := NewParser(StringReader(testInput));
+	p := NewParser(StringReader(testInput))
 
 	for i, want := range rawTokens {
-		have, err := p.RawToken();
+		have, err := p.RawToken()
 		if err != nil {
 			t.Fatalf("token %d: unexpected error: %s", i, err)
 		}
@@ -188,10 +188,10 @@ func TestRawToken(t *testing.T) {
 }
 
 func TestToken(t *testing.T) {
-	p := NewParser(StringReader(testInput));
+	p := NewParser(StringReader(testInput))
 
 	for i, want := range cookedTokens {
-		have, err := p.Token();
+		have, err := p.Token()
 		if err != nil {
 			t.Fatalf("token %d: unexpected error: %s", i, err)
 		}
@@ -203,8 +203,8 @@ func TestToken(t *testing.T) {
 
 func TestSyntax(t *testing.T) {
 	for i := range xmlInput {
-		p := NewParser(StringReader(xmlInput[i]));
-		var err os.Error;
+		p := NewParser(StringReader(xmlInput[i]))
+		var err os.Error
 		for _, err = p.Token(); err == nil; _, err = p.Token() {
 		}
 		if _, ok := err.(SyntaxError); !ok {
diff --git a/test/bench/binary-tree-freelist.go b/test/bench/binary-tree-freelist.go
index 21fe5c5d9f..071a4e06e7 100644
--- a/test/bench/binary-tree-freelist.go
+++ b/test/bench/binary-tree-freelist.go
@@ -37,19 +37,19 @@ POSSIBILITY OF SUCH DAMAGE.
 package main
 
 import (
-	"flag";
-	"fmt";
+	"flag"
+	"fmt"
 )
 
 var n = flag.Int("n", 15, "depth")
 
 type Node struct {
-	item		int;
-	left, right	*Node;
+	item        int
+	left, right *Node
 }
 
 type Arena struct {
-	head *Node;
+	head *Node
 }
 
 var arena Arena
@@ -61,69 +61,69 @@ func (n *Node) free() {
 	if n.right != nil {
 		n.right.free()
 	}
-	n.left = arena.head;
-	arena.head = n;
+	n.left = arena.head
+	arena.head = n
 }
 
 func (a *Arena) New(item int, left, right *Node) *Node {
 	if a.head == nil {
-		nodes := make([]Node, 3<<uint(*n));
+		nodes := make([]Node, 3<<uint(*n))
 		for i := 0; i < len(nodes)-1; i++ {
 			nodes[i].left = &nodes[i+1]
 		}
-		a.head = &nodes[0];
+		a.head = &nodes[0]
 	}
-	n := a.head;
-	a.head = a.head.left;
-	n.item = item;
-	n.left = left;
-	n.right = right;
-	return n;
+	n := a.head
+	a.head = a.head.left
+	n.item = item
+	n.left = left
+	n.right = right
+	return n
 }
 
 func bottomUpTree(item, depth int) *Node {
 	if depth <= 0 {
 		return arena.New(item, nil, nil)
 	}
-	return arena.New(item, bottomUpTree(2*item-1, depth-1), bottomUpTree(2*item, depth-1));
+	return arena.New(item, bottomUpTree(2*item-1, depth-1), bottomUpTree(2*item, depth-1))
 }
 
 func (n *Node) itemCheck() int {
 	if n.left == nil {
 		return n.item
 	}
-	return n.item + n.left.itemCheck() - n.right.itemCheck();
+	return n.item + n.left.itemCheck() - n.right.itemCheck()
 }
 
 const minDepth = 4
 
 func main() {
-	flag.Parse();
+	flag.Parse()
 
-	maxDepth := *n;
+	maxDepth := *n
 	if minDepth+2 > *n {
 		maxDepth = minDepth + 2
 	}
-	stretchDepth := maxDepth + 1;
+	stretchDepth := maxDepth + 1
 
-	check := bottomUpTree(0, stretchDepth).itemCheck();
-	fmt.Printf("stretch tree of depth %d\t check: %d\n", stretchDepth, check);
+	check := bottomUpTree(0, stretchDepth).itemCheck()
+	fmt.Printf("stretch tree of depth %d\t check: %d\n", stretchDepth, check)
 
-	longLivedTree := bottomUpTree(0, maxDepth);
+	longLivedTree := bottomUpTree(0, maxDepth)
 
 	for depth := minDepth; depth <= maxDepth; depth += 2 {
-		iterations := 1 << uint(maxDepth-depth+minDepth);
-		check = 0;
+		iterations := 1 << uint(maxDepth-depth+minDepth)
+		check = 0
 
 		for i := 1; i <= iterations; i++ {
-			t := bottomUpTree(i, depth);
-			check += t.itemCheck();
-			t.free();
-			t = bottomUpTree(-i, depth);
-			check += t.itemCheck();
-			t.free();
+			t := bottomUpTree(i, depth)
+			check += t.itemCheck()
+			t.free()
+			t = bottomUpTree(-i, depth)
+			check += t.itemCheck()
+			t.free()
 		}
-		fmt.Printf("%d\t trees of depth %d\t check: %d\n", iterations*2, depth, check);
+		fmt.Printf("%d\t trees of depth %d\t check: %d\n", iterations*2, depth, check)
 	}
-	fmt.Printf("long lived tree of depth %d\t check: %d\n", maxDepth, longLivedTree.itemCheck());
+	fmt.Printf("long lived tree of depth %d\t check: %d\n", maxDepth, longLivedTree.itemCheck())
 }
diff --git a/test/bench/binary-tree.go b/test/bench/binary-tree.go
index 88497d490f..9f867d11a7 100644
--- a/test/bench/binary-tree.go
+++ b/test/bench/binary-tree.go
@@ -37,56 +37,56 @@ POSSIBILITY OF SUCH DAMAGE.
 package main
 
 import (
-	"flag";
-	"fmt";
+	"flag"
+	"fmt"
 )
 
 var n = flag.Int("n", 15, "depth")
 
 type Node struct {
-	item		int;
-	left, right	*Node;
+	item        int
+	left, right *Node
 }
 
 func bottomUpTree(item, depth int) *Node {
 	if depth <= 0 {
 		return &Node{item: item}
 	}
-	return &Node{item, bottomUpTree(2*item-1, depth-1), bottomUpTree(2*item, depth-1)};
+	return &Node{item, bottomUpTree(2*item-1, depth-1), bottomUpTree(2*item, depth-1)}
 }
 
 func (n *Node) itemCheck() int {
 	if n.left == nil {
 		return n.item
 	}
-	return n.item + n.left.itemCheck() - n.right.itemCheck();
+	return n.item + n.left.itemCheck() - n.right.itemCheck()
 }
 
 const minDepth = 4
 
 func main() {
-	flag.Parse();
+	flag.Parse()
 
-	maxDepth := *n;
+	maxDepth := *n
 	if minDepth+2 > *n {
 		maxDepth = minDepth + 2
 	}
-	stretchDepth := maxDepth + 1;
+	stretchDepth := maxDepth + 1
 
-	check := bottomUpTree(0, stretchDepth).itemCheck();
-	fmt.Printf("stretch tree of depth %d\t check: %d\n", stretchDepth, check);
+	check := bottomUpTree(0, stretchDepth).itemCheck()
+	fmt.Printf("stretch tree of depth %d\t check: %d\n", stretchDepth, check)
 
-	longLivedTree := bottomUpTree(0, maxDepth);
+	longLivedTree := bottomUpTree(0, maxDepth)
 
 	for depth := minDepth; depth <= maxDepth; depth += 2 {
-		iterations := 1 << uint(maxDepth-depth+minDepth);
-		check = 0;
+		iterations := 1 << uint(maxDepth-depth+minDepth)
+		check = 0
 
 		for i := 1; i <= iterations; i++ {
-			check += bottomUpTree(i, depth).itemCheck();
-			check += bottomUpTree(-i, depth).itemCheck();
+			check += bottomUpTree(i, depth).itemCheck()
+			check += bottomUpTree(-i, depth).itemCheck()
 		}
-		fmt.Printf("%d\t trees of depth %d\t check: %d\n", iterations*2, depth, check);
+		fmt.Printf("%d\t trees of depth %d\t check: %d\n", iterations*2, depth, check)
 	}
-	fmt.Printf("long lived tree of depth %d\t check: %d\n", maxDepth, longLivedTree.itemCheck());
+	fmt.Printf("long lived tree of depth %d\t check: %d\n", maxDepth, longLivedTree.itemCheck())
 }
diff --git a/test/bench/chameneosredux.go b/test/bench/chameneosredux.go
index ce464dc2bc..5445c42106 100644
--- a/test/bench/chameneosredux.go
+++ b/test/bench/chameneosredux.go
@@ -36,16 +36,16 @@ POSSIBILITY OF SUCH DAMAGE.
 package main
 
 import (
-	"flag";
-	"fmt";
-	"strconv";
+	"flag"
+	"fmt"
+	"strconv"
 )
 
 const (
-	blue	= iota;
-	red;
-	yellow;
-	ncol;
+	blue = iota
+	red
+	yellow
+	ncol
 )
 
 var complement = [...]int{
@@ -68,8 +68,8 @@ var colname = [...]string{
 
 // information about the current state of a creature.
 type info struct {
-	colour	int;	// creature's current colour.
-	name	int;	// creature's name.
+	colour int // creature's current colour.
+	name   int // creature's name.
 }
 
 // exclusive access data-structure kept inside meetingplace.
@@ -77,21 +77,21 @@ type info struct {
 // otherwise the creature's info is stored in info, and
 // it is waiting to receive its mate's information on the mate channel.
 type rendez struct {
-	n	int;		// current number of encounters.
-	mate	chan<- info;	// creature waiting when non-nil.
-	info	info;		// info about creature waiting.
+	n    int         // current number of encounters.
+	mate chan<- info // creature waiting when non-nil.
+	info info        // info about creature waiting.
 }
 
 // result sent by each creature at the end of processing.
 type result struct {
-	met	int;
-	same	int;
+	met  int
+	same int
 }
 
 var n = 600
 
 func main() {
-	flag.Parse();
+	flag.Parse()
 	if flag.NArg() > 0 {
 		n, _ = strconv.Atoi(flag.Arg(0))
 	}
@@ -101,72 +101,72 @@ func main() {
 			fmt.Printf("%s + %s -> %s\n", colname[c0], colname[c1], colname[complement[c0|c1<<2]])
 		}
 	}
-	fmt.Print("\n");
+	fmt.Print("\n")
 
-	pallmall([]int{blue, red, yellow});
-	pallmall([]int{blue, red, yellow, red, yellow, blue, red, yellow, red, blue});
+	pallmall([]int{blue, red, yellow})
+	pallmall([]int{blue, red, yellow, red, yellow, blue, red, yellow, red, blue})
 }
 
 func pallmall(cols []int) {
 
 	// invariant: meetingplace always contains a value unless a creature
 	// is currently dealing with it (whereupon it must put it back).
-	meetingplace := make(chan rendez, 1);
-	meetingplace <- rendez{n: 0};
+	meetingplace := make(chan rendez, 1)
+	meetingplace <- rendez{n: 0}
 
-	ended := make(chan result);
-	msg := "";
+	ended := make(chan result)
+	msg := ""
 	for i, col := range cols {
-		go creature(info{col, i}, meetingplace, ended);
-		msg += " " + colname[col];
+		go creature(info{col, i}, meetingplace, ended)
+		msg += " " + colname[col]
 	}
-	fmt.Println(msg);
-	tot := 0;
+	fmt.Println(msg)
+	tot := 0
 	// wait for all results
 	for _ = range (cols) {
-		result := <-ended;
-		tot += result.met;
-		fmt.Printf("%v%v\n", result.met, spell(result.same, true));
+		result := <-ended
+		tot += result.met
+		fmt.Printf("%v%v\n", result.met, spell(result.same, true))
 	}
-	fmt.Printf("%v\n\n", spell(tot, true));
+	fmt.Printf("%v\n\n", spell(tot, true))
 }
 
 // in this function, variables ending in 0 refer to the local creature,
 // variables ending in 1 to the creature we've met.
 func creature(info0 info, meetingplace chan rendez, ended chan result) {
-	c0 := make(chan info);
-	met := 0;
-	same := 0;
+	c0 := make(chan info)
+	met := 0
+	same := 0
 	for {
-		var othername int;
+		var othername int
 		// get access to rendez data and decide what to do.
 		switch r := <-meetingplace; {
 		case r.n >= n:
 			// if no more meetings left, then send our result data and exit.
-			meetingplace <- rendez{n: r.n};
-			ended <- result{met, same};
-			return;
+			meetingplace <- rendez{n: r.n}
+			ended <- result{met, same}
+			return
 		case r.mate == nil:
 			// no creature waiting; wait for someone to meet us,
 			// get their info and send our info in reply.
-			meetingplace <- rendez{n: r.n, info: info0, mate: c0};
-			info1 := <-c0;
-			othername = info1.name;
-			info0.colour = complement[info0.colour|info1.colour<<2];
+			meetingplace <- rendez{n: r.n, info: info0, mate: c0}
+			info1 := <-c0
+			othername = info1.name
+			info0.colour = complement[info0.colour|info1.colour<<2]
 		default:
 			// another creature is waiting for us with its info;
 			// increment meeting count,
 			// send them our info in reply.
-			r.n++;
-			meetingplace <- rendez{n: r.n, mate: nil};
-			r.mate <- info0;
-			othername = r.info.name;
-			info0.colour = complement[info0.colour|r.info.colour<<2];
+			r.n++
+			meetingplace <- rendez{n: r.n, mate: nil}
+			r.mate <- info0
+			othername = r.info.name
+			info0.colour = complement[info0.colour|r.info.colour<<2]
 		}
 		if othername == info0.name {
 			same++
 		}
-		met++;
+		met++
 	}
 }
 
@@ -176,5 +176,5 @@ func spell(n int, required bool) string {
 	if n == 0 && !required {
 		return ""
 	}
-	return spell(n/10, false) + " " + digits[n%10];
+	return spell(n/10, false) + " " + digits[n%10]
 }
diff --git a/test/bench/fannkuch.go b/test/bench/fannkuch.go
index 90e6fb899d..b554c77b10 100644
--- a/test/bench/fannkuch.go
+++ b/test/bench/fannkuch.go
@@ -38,8 +38,8 @@ POSSIBILITY OF SUCH DAMAGE.
 package main
 
 import (
-	"flag";
-	"fmt";
+	"flag"
+	"fmt"
 )
 
 var n = flag.Int("n", 7, "count")
@@ -49,45 +49,45 @@ func fannkuch(n int) int {
 		return 0
 	}
 
-	n1 := n - 1;
-	perm := make([]int, n);
-	perm1 := make([]int, n);
-	count := make([]int, n);
+	n1 := n - 1
+	perm := make([]int, n)
+	perm1 := make([]int, n)
+	count := make([]int, n)
 
 	for i := 0; i < n; i++ {
-		perm1[i] = i	// initial (trivial) permutation
+		perm1[i] = i // initial (trivial) permutation
 	}
 
-	r := n;
-	didpr := 0;
-	flipsMax := 0;
+	r := n
+	didpr := 0
+	flipsMax := 0
 	for {
 		if didpr < 30 {
 			for i := 0; i < n; i++ {
 				fmt.Printf("%d", 1+perm1[i])
 			}
-			fmt.Printf("\n");
-			didpr++;
+			fmt.Printf("\n")
+			didpr++
 		}
 		for ; r != 1; r-- {
 			count[r-1] = r
 		}
 
 		if perm1[0] != 0 && perm1[n1] != n1 {
-			flips := 0;
-			for i := 1; i < n; i++ {	// perm = perm1
+			flips := 0
+			for i := 1; i < n; i++ { // perm = perm1
 				perm[i] = perm1[i]
 			}
-			k := perm1[0];	// cache perm[0] in k
-			for {		// k!=0 ==> k>0
+			k := perm1[0] // cache perm[0] in k
+			for {         // k!=0 ==> k>0
 				for i, j := 1, k-1; i < j; i, j = i+1, j-1 {
 					perm[i], perm[j] = perm[j], perm[i]
 				}
-				flips++;
+				flips++
 				// Now exchange k (caching perm[0]) and perm[k]... with care!
-				j := perm[k];
-				perm[k] = k;
-				k = j;
+				j := perm[k]
+				perm[k] = k
+				k = j
 				if k == 0 {
 					break
 				}
@@ -99,12 +99,12 @@ func fannkuch(n int) int {
 
 		for ; r < n; r++ {
 			// rotate down perm[0..r] by one
-			perm0 := perm1[0];
+			perm0 := perm1[0]
 			for i := 0; i < r; i++ {
 				perm1[i] = perm1[i+1]
 			}
-			perm1[r] = perm0;
-			count[r]--;
+			perm1[r] = perm0
+			count[r]--
 			if count[r] > 0 {
 				break
 			}
@@ -113,10 +113,10 @@ func fannkuch(n int) int {
 			return flipsMax
 		}
 	}
-	return 0;
+	return 0
 }
 
 func main() {
-	flag.Parse();
-	fmt.Printf("Pfannkuchen(%d) = %d\n", *n, fannkuch(*n));
+	flag.Parse()
+	fmt.Printf("Pfannkuchen(%d) = %d\n", *n, fannkuch(*n))
 }
diff --git a/test/bench/fasta.go b/test/bench/fasta.go
index 07d7af2600..1afb1ffb80 100644
--- a/test/bench/fasta.go
+++ b/test/bench/fasta.go
@@ -38,28 +38,28 @@ POSSIBILITY OF SUCH DAMAGE.
 package main
 
 import (
-	"bufio";
-	"flag";
-	"os";
-	"strings";
+	"bufio"
+	"flag"
+	"os"
+	"strings"
 )
 
 var out *bufio.Writer
 
 var n = flag.Int("n", 1000, "length of result")
 
-const WIDTH = 60	// Fold lines after WIDTH bytes
+const WIDTH = 60 // Fold lines after WIDTH bytes
 
 func min(a, b int) int {
 	if a < b {
 		return a
 	}
-	return b;
+	return b
 }
 
 type AminoAcid struct {
-	p	float;
-	c	byte;
+	p float
+	c byte
 }
 
 func AccumulateProbabilities(genelist []AminoAcid) {
@@ -74,28 +74,28 @@ func AccumulateProbabilities(genelist []AminoAcid) {
 // After each WIDTH characters it prints a newline.
 // It assumes that WIDTH <= len(s) + 1.
 func RepeatFasta(s []byte, count int) {
-	pos := 0;
-	s2 := make([]byte, len(s)+WIDTH);
-	copy(s2, s);
-	copy(s2[len(s):], s);
+	pos := 0
+	s2 := make([]byte, len(s)+WIDTH)
+	copy(s2, s)
+	copy(s2[len(s):], s)
 	for count > 0 {
-		line := min(WIDTH, count);
-		out.Write(s2[pos : pos+line]);
-		out.WriteByte('\n');
-		pos += line;
+		line := min(WIDTH, count)
+		out.Write(s2[pos : pos+line])
+		out.WriteByte('\n')
+		pos += line
 		if pos >= len(s) {
 			pos -= len(s)
 		}
-		count -= line;
+		count -= line
 	}
 }
 
 var lastrandom uint32 = 42
 
 const (
-	IM	= 139968;
-	IA	= 3877;
-	IC	= 29573;
+	IM = 139968
+	IA = 3877
+	IC = 29573
 )
 
 // Each element of genelist is a struct with a character and
@@ -107,31 +107,31 @@ const (
 // This sequence is repeated count times.
 // Between each WIDTH consecutive characters, the function prints a newline.
 func RandomFasta(genelist []AminoAcid, count int) {
-	buf := make([]byte, WIDTH+1);
+	buf := make([]byte, WIDTH+1)
 	for count > 0 {
-		line := min(WIDTH, count);
+		line := min(WIDTH, count)
 		for pos := 0; pos < line; pos++ {
-			lastrandom = (lastrandom*IA + IC) % IM;
+			lastrandom = (lastrandom*IA + IC) % IM
 			// Integer to float conversions are faster if the integer is signed.
-			r := float(int32(lastrandom)) / IM;
+			r := float(int32(lastrandom)) / IM
 			for _, v := range genelist {
 				if v.p >= r {
-					buf[pos] = v.c;
-					break;
+					buf[pos] = v.c
+					break
 				}
 			}
 		}
-		buf[line] = '\n';
-		out.Write(buf[0 : line+1]);
-		count -= line;
+		buf[line] = '\n'
+		out.Write(buf[0 : line+1])
+		count -= line
 	}
 }
 
 func main() {
-	out = bufio.NewWriter(os.Stdout);
-	defer out.Flush();
+	out = bufio.NewWriter(os.Stdout)
+	defer out.Flush()
 
-	flag.Parse();
+	flag.Parse()
 
 	iub := []AminoAcid{
 		AminoAcid{0.27, 'a'},
@@ -149,17 +149,17 @@ func main() {
 		AminoAcid{0.02, 'V'},
 		AminoAcid{0.02, 'W'},
 		AminoAcid{0.02, 'Y'},
-	};
+	}
 
 	homosapiens := []AminoAcid{
 		AminoAcid{0.3029549426680, 'a'},
 		AminoAcid{0.1979883004921, 'c'},
 		AminoAcid{0.1975473066391, 'g'},
 		AminoAcid{0.3015094502008, 't'},
-	};
+	}
 
-	AccumulateProbabilities(iub);
-	AccumulateProbabilities(homosapiens);
+	AccumulateProbabilities(iub)
+	AccumulateProbabilities(homosapiens)
 
 	alu := strings.Bytes(
 		"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG" +
@@ -168,12 +168,12 @@ func main() {
 			"ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA" +
 			"GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG" +
 			"AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC" +
-			"AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA");
-
-	out.WriteString(">ONE Homo sapiens alu\n");
-	RepeatFasta(alu, 2**n);
-	out.WriteString(">TWO IUB ambiguity codes\n");
-	RandomFasta(iub, 3**n);
-	out.WriteString(">THREE Homo sapiens frequency\n");
-	RandomFasta(homosapiens, 5**n);
+			"AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA")
+
+	out.WriteString(">ONE Homo sapiens alu\n")
+	RepeatFasta(alu, 2**n)
+	out.WriteString(">TWO IUB ambiguity codes\n")
+	RandomFasta(iub, 3**n)
+	out.WriteString(">THREE Homo sapiens frequency\n")
+	RandomFasta(homosapiens, 5**n)
 }
diff --git a/test/bench/k-nucleotide.go b/test/bench/k-nucleotide.go
index 47debecb3d..a5c7f79bb3 100644
--- a/test/bench/k-nucleotide.go
+++ b/test/bench/k-nucleotide.go
@@ -36,71 +36,71 @@ POSSIBILITY OF SUCH DAMAGE.
 package main
 
 import (
-	"bufio";
-	"bytes";
-	"fmt";
-	"io/ioutil";
-	"os";
-	"sort";
-	"strings";
+	"bufio"
+	"bytes"
+	"fmt"
+	"io/ioutil"
+	"os"
+	"sort"
+	"strings"
 )
 
 var in *bufio.Reader
 
 func count(data string, n int) map[string]int {
-	counts := make(map[string]int);
-	top := len(data) - n;
+	counts := make(map[string]int)
+	top := len(data) - n
 	for i := 0; i <= top; i++ {
-		s := data[i : i+n];
+		s := data[i : i+n]
 		if k, ok := counts[s]; ok {
 			counts[s] = k + 1
 		} else {
 			counts[s] = 1
 		}
 	}
-	return counts;
+	return counts
 }
 
 func countOne(data string, s string) int {
-	counts := count(data, len(s));
+	counts := count(data, len(s))
 	if i, ok := counts[s]; ok {
 		return i
 	}
-	return 0;
+	return 0
 }
 
 
 type kNuc struct {
-	name	string;
-	count	int;
+	name  string
+	count int
 }
 
 type kNucArray []kNuc
 
-func (kn kNucArray) Len() int		{ return len(kn) }
-func (kn kNucArray) Swap(i, j int)	{ kn[i], kn[j] = kn[j], kn[i] }
+func (kn kNucArray) Len() int      { return len(kn) }
+func (kn kNucArray) Swap(i, j int) { kn[i], kn[j] = kn[j], kn[i] }
 func (kn kNucArray) Less(i, j int) bool {
 	if kn[i].count == kn[j].count {
-		return kn[i].name > kn[j].name	// sort down
+		return kn[i].name > kn[j].name // sort down
 	}
-	return kn[i].count > kn[j].count;
+	return kn[i].count > kn[j].count
 }
 
 func sortedArray(m map[string]int) kNucArray {
-	kn := make(kNucArray, len(m));
-	i := 0;
+	kn := make(kNucArray, len(m))
+	i := 0
 	for k, v := range m {
-		kn[i].name = k;
-		kn[i].count = v;
-		i++;
+		kn[i].name = k
+		kn[i].count = v
+		i++
 	}
-	sort.Sort(kn);
-	return kn;
+	sort.Sort(kn)
+	return kn
 }
 
 func print(m map[string]int) {
-	a := sortedArray(m);
-	sum := 0;
+	a := sortedArray(m)
+	sum := 0
 	for _, kn := range a {
 		sum += kn.count
 	}
@@ -110,40 +110,40 @@ func print(m map[string]int) {
 }
 
 func main() {
-	in = bufio.NewReader(os.Stdin);
-	three := strings.Bytes(">THREE ");
+	in = bufio.NewReader(os.Stdin)
+	three := strings.Bytes(">THREE ")
 	for {
-		line, err := in.ReadSlice('\n');
+		line, err := in.ReadSlice('\n')
 		if err != nil {
-			fmt.Fprintln(os.Stderr, "ReadLine err:", err);
-			os.Exit(2);
+			fmt.Fprintln(os.Stderr, "ReadLine err:", err)
+			os.Exit(2)
 		}
 		if line[0] == '>' && bytes.Equal(line[0:len(three)], three) {
 			break
 		}
 	}
-	data, err := ioutil.ReadAll(in);
+	data, err := ioutil.ReadAll(in)
 	if err != nil {
-		fmt.Fprintln(os.Stderr, "ReadAll err:", err);
-		os.Exit(2);
+		fmt.Fprintln(os.Stderr, "ReadAll err:", err)
+		os.Exit(2)
 	}
 	// delete the newlines and convert to upper case
-	j := 0;
+	j := 0
 	for i := 0; i < len(data); i++ {
 		if data[i] != '\n' {
-			data[j] = data[i] &^ ' ';	// upper case
-			j++;
+			data[j] = data[i] &^ ' ' // upper case
+			j++
 		}
 	}
-	str := string(data[0:j]);
+	str := string(data[0:j])
 
-	print(count(str, 1));
-	fmt.Print("\n");
+	print(count(str, 1))
+	fmt.Print("\n")
 
-	print(count(str, 2));
-	fmt.Print("\n");
+	print(count(str, 2))
+	fmt.Print("\n")
 
-	interests := []string{"GGT", "GGTA", "GGTATT", "GGTATTTTAATT", "GGTATTTTAATTTATAGT"};
+	interests := []string{"GGT", "GGTA", "GGTATT", "GGTATTTTAATT", "GGTATTTTAATTTATAGT"}
 	for _, s := range interests {
 		fmt.Printf("%d %s\n", countOne(str, s), s)
 	}
diff --git a/test/bench/mandelbrot.go b/test/bench/mandelbrot.go
index 6c1b7d4e59..1f9fbfd3d4 100644
--- a/test/bench/mandelbrot.go
+++ b/test/bench/mandelbrot.go
@@ -37,58 +37,58 @@ POSSIBILITY OF SUCH DAMAGE.
 package main
 
 import (
-	"bufio";
-	"flag";
-	"fmt";
-	"os";
+	"bufio"
+	"flag"
+	"fmt"
+	"os"
 )
 
 var n = flag.Int("n", 200, "size")
 
 func main() {
-	flag.Parse();
-	out := bufio.NewWriter(os.Stdout);
-	defer out.Flush();
+	flag.Parse()
+	out := bufio.NewWriter(os.Stdout)
+	defer out.Flush()
 
-	w := *n;
-	h := *n;
-	bit_num := 0;
-	byte_acc := byte(0);
-	const Iter = 50;
-	const Zero float64 = 0;
-	const Limit = 2.0;
+	w := *n
+	h := *n
+	bit_num := 0
+	byte_acc := byte(0)
+	const Iter = 50
+	const Zero float64 = 0
+	const Limit = 2.0
 
-	fmt.Fprintf(out, "P4\n%d %d\n", w, h);
+	fmt.Fprintf(out, "P4\n%d %d\n", w, h)
 
 	for y := 0; y < h; y++ {
 		for x := 0; x < w; x++ {
-			Zr, Zi, Tr, Ti := Zero, Zero, Zero, Zero;
-			Cr := (2*float64(x)/float64(w) - 1.5);
-			Ci := (2*float64(y)/float64(h) - 1.0);
+			Zr, Zi, Tr, Ti := Zero, Zero, Zero, Zero
+			Cr := (2*float64(x)/float64(w) - 1.5)
+			Ci := (2*float64(y)/float64(h) - 1.0)
 
 			for i := 0; i < Iter && (Tr+Ti <= Limit*Limit); i++ {
-				Zi = 2*Zr*Zi + Ci;
-				Zr = Tr - Ti + Cr;
-				Tr = Zr * Zr;
-				Ti = Zi * Zi;
+				Zi = 2*Zr*Zi + Ci
+				Zr = Tr - Ti + Cr
+				Tr = Zr * Zr
+				Ti = Zi * Zi
 			}
 
-			byte_acc <<= 1;
+			byte_acc <<= 1
 			if Tr+Ti <= Limit*Limit {
 				byte_acc |= 0x01
 			}
 
-			bit_num++;
+			bit_num++
 
 			if bit_num == 8 {
-				out.WriteByte(byte_acc);
-				byte_acc = 0;
-				bit_num = 0;
+				out.WriteByte(byte_acc)
+				byte_acc = 0
+				bit_num = 0
 			} else if x == w-1 {
-				byte_acc <<= uint(8 - w%8);
-				out.WriteByte(byte_acc);
-				byte_acc = 0;
-				bit_num = 0;
+				byte_acc <<= uint(8 - w%8)
+				out.WriteByte(byte_acc)
+				byte_acc = 0
+				bit_num = 0
 			}
 		}
 	}
diff --git a/test/bench/meteor-contest.go b/test/bench/meteor-contest.go
index a939389994..163aaa7c45 100644
--- a/test/bench/meteor-contest.go
+++ b/test/bench/meteor-contest.go
@@ -37,8 +37,8 @@ POSSIBILITY OF SUCH DAMAGE.
 package main
 
 import (
-	"flag";
-	"fmt";
+	"flag"
+	"fmt"
 )
 
 var max_solutions = flag.Int("n", 2100, "maximum number of solutions")
@@ -48,7 +48,7 @@ func boolInt(b bool) int8 {
 	if b {
 		return 1
 	}
-	return 0;
+	return 0
 }
 
 /* The board is a 50 cell hexagonal pattern.  For    . . . . .
@@ -87,19 +87,19 @@ var board uint64 = 0xFFFC000000000000
  */
 
 const (
-	E	= iota;
-	ESE;
-	SE;
-	S;
-	SW;
-	WSW;
-	W;
-	WNW;
-	NW;
-	N;
-	NE;
-	ENE;
-	PIVOT;
+	E = iota
+	ESE
+	SE
+	S
+	SW
+	WSW
+	W
+	WNW
+	NW
+	N
+	NE
+	ENE
+	PIVOT
 )
 
 var piece_def = [10][4]int8{
@@ -127,16 +127,16 @@ var piece_def = [10][4]int8{
  * location to reduce the burden on the solve function.
  */
 var (
-	pieces		[10][50][12]uint64;
-	piece_counts	[10][50]int;
-	next_cell	[10][50][12]int8;
+	pieces       [10][50][12]uint64
+	piece_counts [10][50]int
+	next_cell    [10][50][12]int8
 )
 
 /* Returns the direction rotated 60 degrees clockwise */
-func rotate(dir int8) int8	{ return (dir + 2) % PIVOT }
+func rotate(dir int8) int8 { return (dir + 2) % PIVOT }
 
 /* Returns the direction flipped on the horizontal axis */
-func flip(dir int8) int8	{ return (PIVOT - dir) % PIVOT }
+func flip(dir int8) int8 { return (PIVOT - dir) % PIVOT }
 
 
 /* Returns the new cell index from the specified cell in the
@@ -203,7 +203,7 @@ func shift(cell, dir int8) int8 {
 			return cell - 4
 		}
 	}
-	return cell;
+	return cell
 }
 
 /* Returns wether the specified cell and direction will land outside
@@ -215,8 +215,8 @@ func out_of_bounds(cell, dir int8) bool {
 	case E:
 		return cell%5 == 4
 	case ESE:
-		i := cell % 10;
-		return i == 4 || i == 8 || i == 9 || cell >= 45;
+		i := cell % 10
+		return i == 4 || i == 8 || i == 9 || cell >= 45
 	case SE:
 		return cell%10 == 9 || cell >= 45
 	case S:
@@ -224,13 +224,13 @@ func out_of_bounds(cell, dir int8) bool {
 	case SW:
 		return cell%10 == 0 || cell >= 45
 	case WSW:
-		i := cell % 10;
-		return i == 0 || i == 1 || i == 5 || cell >= 45;
+		i := cell % 10
+		return i == 0 || i == 1 || i == 5 || cell >= 45
 	case W:
 		return cell%5 == 0
 	case WNW:
-		i := cell % 10;
-		return i == 0 || i == 1 || i == 5 || cell < 5;
+		i := cell % 10
+		return i == 0 || i == 1 || i == 5 || cell < 5
 	case NW:
 		return cell%10 == 0 || cell < 5
 	case N:
@@ -238,10 +238,10 @@ func out_of_bounds(cell, dir int8) bool {
 	case NE:
 		return cell%10 == 9 || cell < 5
 	case ENE:
-		i := cell % 10;
-		return i == 4 || i == 8 || i == 9 || cell < 5;
+		i := cell % 10
+		return i == 4 || i == 8 || i == 9 || cell < 5
 	}
-	return false;
+	return false
 }
 
 /* Rotate a piece 60 degrees clockwise */
@@ -260,7 +260,7 @@ func flip_piece(piece int) {
 
 /* Convenience function to quickly calculate all of the indices for a piece */
 func calc_cell_indices(cell []int8, piece int, index int8) {
-	cell[0] = index;
+	cell[0] = index
 	for i := 1; i < 5; i++ {
 		cell[i] = shift(cell[i-1], piece_def[piece][i-1])
 	}
@@ -279,13 +279,13 @@ func cells_fit_on_board(cell []int8, piece int) bool {
  * the piece in the solve function.
  */
 func minimum_of_cells(cell []int8) int8 {
-	minimum := cell[0];
+	minimum := cell[0]
 	for i := 1; i < 5; i++ {
 		if cell[i] < minimum {
 			minimum = cell[i]
 		}
 	}
-	return minimum;
+	return minimum
 }
 
 /* Calculate the lowest possible open cell if the piece is placed on the board.
@@ -293,33 +293,33 @@ func minimum_of_cells(cell []int8) int8 {
  * solve function.
  */
 func first_empty_cell(cell []int8, minimum int8) int8 {
-	first_empty := minimum;
+	first_empty := minimum
 	for first_empty == cell[0] || first_empty == cell[1] ||
 		first_empty == cell[2] || first_empty == cell[3] ||
 		first_empty == cell[4] {
 		first_empty++
 	}
-	return first_empty;
+	return first_empty
 }
 
 /* Generate the unsigned long long int that will later be anded with the
  * board to determine if it fits.
  */
 func bitmask_from_cells(cell []int8) uint64 {
-	var piece_mask uint64;
+	var piece_mask uint64
 	for i := 0; i < 5; i++ {
 		piece_mask |= 1 << uint(cell[i])
 	}
-	return piece_mask;
+	return piece_mask
 }
 
 /* Record the piece and other important information in arrays that will
  * later be used by the solve function.
  */
 func record_piece(piece int, minimum int8, first_empty int8, piece_mask uint64) {
-	pieces[piece][minimum][piece_counts[piece][minimum]] = piece_mask;
-	next_cell[piece][minimum][piece_counts[piece][minimum]] = first_empty;
-	piece_counts[piece][minimum]++;
+	pieces[piece][minimum][piece_counts[piece][minimum]] = piece_mask
+	next_cell[piece][minimum][piece_counts[piece][minimum]] = first_empty
+	piece_counts[piece][minimum]++
 }
 
 
@@ -330,7 +330,7 @@ func fill_contiguous_space(board []int8, index int8) {
 	if board[index] == 1 {
 		return
 	}
-	board[index] = 1;
+	board[index] = 1
 	if !out_of_bounds(index, E) {
 		fill_contiguous_space(board, shift(index, E))
 	}
@@ -359,17 +359,17 @@ func fill_contiguous_space(board []int8, index int8) {
  * can split the board in half where both halves are viable.
  */
 func has_island(cell []int8, piece int) bool {
-	temp_board := make([]int8, 50);
-	var i int;
+	temp_board := make([]int8, 50)
+	var i int
 	for i = 0; i < 5; i++ {
 		temp_board[cell[i]] = 1
 	}
-	i = 49;
+	i = 49
 	for temp_board[i] == 1 {
 		i--
 	}
-	fill_contiguous_space(temp_board, int8(i));
-	c := 0;
+	fill_contiguous_space(temp_board, int8(i))
+	c := 0
 	for i = 0; i < 50; i++ {
 		if temp_board[i] == 0 {
 			c++
@@ -379,7 +379,7 @@ func has_island(cell []int8, piece int) bool {
 		(c%5 == 0 && piece == 0) {
 		return false
 	}
-	return true;
+	return true
 }
 
 
@@ -391,18 +391,18 @@ func has_island(cell []int8, piece int) bool {
  * me the best time ;)
  */
 func calc_six_rotations(piece, index int) {
-	cell := make([]int8, 5);
+	cell := make([]int8, 5)
 	for rotation := 0; rotation < 6; rotation++ {
 		if piece != 3 || rotation < 3 {
-			calc_cell_indices(cell, piece, int8(index));
+			calc_cell_indices(cell, piece, int8(index))
 			if cells_fit_on_board(cell, piece) && !has_island(cell, piece) {
-				minimum := minimum_of_cells(cell);
-				first_empty := first_empty_cell(cell, minimum);
-				piece_mask := bitmask_from_cells(cell);
-				record_piece(piece, minimum, first_empty, piece_mask);
+				minimum := minimum_of_cells(cell)
+				first_empty := first_empty_cell(cell, minimum)
+				piece_mask := bitmask_from_cells(cell)
+				record_piece(piece, minimum, first_empty, piece_mask)
 			}
 		}
-		rotate_piece(piece);
+		rotate_piece(piece)
 	}
 }
 
@@ -410,9 +410,9 @@ func calc_six_rotations(piece, index int) {
 func calc_pieces() {
 	for piece := 0; piece < 10; piece++ {
 		for index := 0; index < 50; index++ {
-			calc_six_rotations(piece, index);
-			flip_piece(piece);
-			calc_six_rotations(piece, index);
+			calc_six_rotations(piece, index)
+			flip_piece(piece)
+			calc_six_rotations(piece, index)
 		}
 	}
 }
@@ -424,41 +424,41 @@ func calc_pieces() {
  * board in the solve function.
  */
 const (
-	ROW_MASK	= 0x1F;
-	TRIPLE_MASK	= 0x7FFF;
+	ROW_MASK    = 0x1F
+	TRIPLE_MASK = 0x7FFF
 )
 
 var (
-	all_rows	= [32]int8{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
+	all_rows = [32]int8{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
 		17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
-	};
-	bad_even_rows	[32][32]int8;
-	bad_odd_rows	[32][32]int8;
-	bad_even_triple	[32768]int8;
-	bad_odd_triple	[32768]int8;
+	}
+	bad_even_rows   [32][32]int8
+	bad_odd_rows    [32][32]int8
+	bad_even_triple [32768]int8
+	bad_odd_triple  [32768]int8
 )
 
 func rows_bad(row1, row2 int8, even bool) int8 {
 	/* even is referring to row1 */
-	var row2_shift int8;
+	var row2_shift int8
 	/* Test for blockages at same index and shifted index */
 	if even {
 		row2_shift = ((row2 << 1) & ROW_MASK) | 0x01
 	} else {
 		row2_shift = (row2 >> 1) | 0x10
 	}
-	block := ((row1 ^ row2) & row2) & ((row1 ^ row2_shift) & row2_shift);
+	block := ((row1 ^ row2) & row2) & ((row1 ^ row2_shift) & row2_shift)
 	/* Test for groups of 0's */
-	in_zeroes := false;
-	group_okay := false;
+	in_zeroes := false
+	group_okay := false
 	for i := uint8(0); i < 5; i++ {
 		if row1&(1<<i) != 0 {
 			if in_zeroes {
 				if !group_okay {
 					return 1
 				}
-				in_zeroes = false;
-				group_okay = false;
+				in_zeroes = false
+				group_okay = false
 			}
 		} else {
 			if !in_zeroes {
@@ -472,7 +472,7 @@ func rows_bad(row1, row2 int8, even bool) int8 {
 	if in_zeroes {
 		return boolInt(!group_okay)
 	}
-	return 0;
+	return 0
 }
 
 /* Check for cases where three rows checked sequentially cause a false
@@ -497,29 +497,29 @@ func triple_is_okay(row1, row2, row3 int, even bool) bool {
 	 * row3: ?????  ?????
 	 */
 	return ((row1 == 0x13) && (row2 == 0x11)) ||
-		((row1 == 0x15) && (row2 == 0x11));
+		((row1 == 0x15) && (row2 == 0x11))
 }
 
 func calc_rows() {
 	for row1 := int8(0); row1 < 32; row1++ {
 		for row2 := int8(0); row2 < 32; row2++ {
-			bad_even_rows[row1][row2] = rows_bad(row1, row2, true);
-			bad_odd_rows[row1][row2] = rows_bad(row1, row2, false);
+			bad_even_rows[row1][row2] = rows_bad(row1, row2, true)
+			bad_odd_rows[row1][row2] = rows_bad(row1, row2, false)
 		}
 	}
 	for row1 := 0; row1 < 32; row1++ {
 		for row2 := 0; row2 < 32; row2++ {
 			for row3 := 0; row3 < 32; row3++ {
-				result1 := bad_even_rows[row1][row2];
-				result2 := bad_odd_rows[row2][row3];
+				result1 := bad_even_rows[row1][row2]
+				result2 := bad_odd_rows[row2][row3]
 				if result1 == 0 && result2 != 0 && triple_is_okay(row1, row2, row3, true) {
 					bad_even_triple[row1+(row2*32)+(row3*1024)] = 0
 				} else {
 					bad_even_triple[row1+(row2*32)+(row3*1024)] = boolInt(result1 != 0 || result2 != 0)
 				}
 
-				result1 = bad_odd_rows[row1][row2];
-				result2 = bad_even_rows[row2][row3];
+				result1 = bad_odd_rows[row1][row2]
+				result2 = bad_even_rows[row2][row3]
 				if result1 == 0 && result2 != 0 && triple_is_okay(row1, row2, row3, false) {
 					bad_odd_triple[row1+(row2*32)+(row3*1024)] = 0
 				} else {
@@ -538,11 +538,11 @@ func boardHasIslands(cell int8) int8 {
 	if cell >= 40 {
 		return 0
 	}
-	current_triple := (board >> uint((cell/5)*5)) & TRIPLE_MASK;
+	current_triple := (board >> uint((cell/5)*5)) & TRIPLE_MASK
 	if (cell/5)%2 != 0 {
 		return bad_odd_triple[current_triple]
 	}
-	return bad_even_triple[current_triple];
+	return bad_even_triple[current_triple]
 }
 
 
@@ -553,26 +553,26 @@ func boardHasIslands(cell int8) int8 {
  * array if a solution is found.
  */
 var (
-	avail		uint16	= 0x03FF;
-	sol_nums	[10]int8;
-	sol_masks	[10]uint64;
-	solutions	[2100][50]int8;
-	solution_count	= 0;
+	avail          uint16 = 0x03FF
+	sol_nums       [10]int8
+	sol_masks      [10]uint64
+	solutions      [2100][50]int8
+	solution_count = 0
 )
 
 func record_solution() {
 	for sol_no := 0; sol_no < 10; sol_no++ {
-		sol_mask := sol_masks[sol_no];
+		sol_mask := sol_masks[sol_no]
 		for index := 0; index < 50; index++ {
 			if sol_mask&1 == 1 {
-				solutions[solution_count][index] = sol_nums[sol_no];
+				solutions[solution_count][index] = sol_nums[sol_no]
 				/* Board rotated 180 degrees is a solution too! */
-				solutions[solution_count+1][49-index] = sol_nums[sol_no];
+				solutions[solution_count+1][49-index] = sol_nums[sol_no]
 			}
-			sol_mask = sol_mask >> 1;
+			sol_mask = sol_mask >> 1
 		}
 	}
-	solution_count += 2;
+	solution_count += 2
 }
 
 func solve(depth, cell int8) {
@@ -585,31 +585,31 @@ func solve(depth, cell int8) {
 	}
 
 	for piece := int8(0); piece < 10; piece++ {
-		var piece_no_mask uint16 = 1 << uint(piece);
+		var piece_no_mask uint16 = 1 << uint(piece)
 		if avail&piece_no_mask == 0 {
 			continue
 		}
-		avail ^= piece_no_mask;
-		max_rots := piece_counts[piece][cell];
-		piece_mask := pieces[piece][cell];
+		avail ^= piece_no_mask
+		max_rots := piece_counts[piece][cell]
+		piece_mask := pieces[piece][cell]
 		for rotation := 0; rotation < max_rots; rotation++ {
 			if board&piece_mask[rotation] == 0 {
-				sol_nums[depth] = piece;
-				sol_masks[depth] = piece_mask[rotation];
+				sol_nums[depth] = piece
+				sol_masks[depth] = piece_mask[rotation]
 				if depth == 9 {
 					/* Solution found!!!!!11!!ONE! */
-					record_solution();
-					avail ^= piece_no_mask;
-					return;
+					record_solution()
+					avail ^= piece_no_mask
+					return
 				}
-				board |= piece_mask[rotation];
+				board |= piece_mask[rotation]
 				if boardHasIslands(next_cell[piece][cell][rotation]) == 0 {
 					solve(depth+1, next_cell[piece][cell][rotation])
 				}
-				board ^= piece_mask[rotation];
+				board ^= piece_mask[rotation]
 			}
 		}
-		avail ^= piece_no_mask;
+		avail ^= piece_no_mask
 	}
 }
 
@@ -620,46 +620,46 @@ func pretty(b *[50]int8) {
 			b[i+2]+'0', b[i+3]+'0', b[i+4]+'0', b[i+5]+'0', b[i+6]+'0',
 			b[i+7]+'0', b[i+8]+'0', b[i+9]+'0')
 	}
-	fmt.Printf("\n");
+	fmt.Printf("\n")
 }
 
 /* Find smallest and largest solutions */
 func smallest_largest() (smallest, largest *[50]int8) {
-	smallest = &solutions[0];
-	largest = &solutions[0];
+	smallest = &solutions[0]
+	largest = &solutions[0]
 	for i := 1; i < solution_count; i++ {
-		candidate := &solutions[i];
+		candidate := &solutions[i]
 		for j, s := range *smallest {
-			c := candidate[j];
+			c := candidate[j]
 			if c == s {
 				continue
 			}
 			if c < s {
 				smallest = candidate
 			}
-			break;
+			break
 		}
 		for j, s := range *largest {
-			c := candidate[j];
+			c := candidate[j]
 			if c == s {
 				continue
 			}
 			if c > s {
 				largest = candidate
 			}
-			break;
+			break
 		}
 	}
-	return;
+	return
 }
 
 func main() {
-	flag.Parse();
-	calc_pieces();
-	calc_rows();
-	solve(0, 0);
-	fmt.Printf("%d solutions found\n\n", solution_count);
-	smallest, largest := smallest_largest();
-	pretty(smallest);
-	pretty(largest);
+	flag.Parse()
+	calc_pieces()
+	calc_rows()
+	solve(0, 0)
+	fmt.Printf("%d solutions found\n\n", solution_count)
+	smallest, largest := smallest_largest()
+	pretty(smallest)
+	pretty(largest)
 }
diff --git a/test/bench/nbody.go b/test/bench/nbody.go
index 05831bba24..e9f4517e8e 100644
--- a/test/bench/nbody.go
+++ b/test/bench/nbody.go
@@ -37,94 +37,94 @@ POSSIBILITY OF SUCH DAMAGE.
 package main
 
 import (
-	"flag";
-	"fmt";
-	"math";
+	"flag"
+	"fmt"
+	"math"
 )
 
 var n = flag.Int("n", 1000, "number of iterations")
 
 type Body struct {
-	x, y, z, vx, vy, vz, mass float64;
+	x, y, z, vx, vy, vz, mass float64
 }
 
 const (
-	solarMass	= 4 * math.Pi * math.Pi;
-	daysPerYear	= 365.24;
+	solarMass   = 4 * math.Pi * math.Pi
+	daysPerYear = 365.24
 )
 
 func (b *Body) offsetMomentum(px, py, pz float64) {
-	b.vx = -px / solarMass;
-	b.vy = -py / solarMass;
-	b.vz = -pz / solarMass;
+	b.vx = -px / solarMass
+	b.vy = -py / solarMass
+	b.vz = -pz / solarMass
 }
 
 type System []*Body
 
 func NewSystem(body []Body) System {
-	n := make(System, len(body));
+	n := make(System, len(body))
 	for i := 0; i < len(body); i++ {
-		n[i] = new(Body);	// copy to avoid overwriting the inputs
-		*n[i] = body[i];
+		n[i] = new(Body) // copy to avoid overwriting the inputs
+		*n[i] = body[i]
 	}
-	var px, py, pz float64;
+	var px, py, pz float64
 	for _, body := range n {
-		px += body.vx * body.mass;
-		py += body.vy * body.mass;
-		pz += body.vz * body.mass;
+		px += body.vx * body.mass
+		py += body.vy * body.mass
+		pz += body.vz * body.mass
 	}
-	n[0].offsetMomentum(px, py, pz);
-	return n;
+	n[0].offsetMomentum(px, py, pz)
+	return n
 }
 
 func (sys System) energy() float64 {
-	var e float64;
+	var e float64
 	for i, body := range sys {
 		e += 0.5 * body.mass *
-			(body.vx*body.vx + body.vy*body.vy + body.vz*body.vz);
+			(body.vx*body.vx + body.vy*body.vy + body.vz*body.vz)
 		for j := i + 1; j < len(sys); j++ {
-			body2 := sys[j];
-			dx := body.x - body2.x;
-			dy := body.y - body2.y;
-			dz := body.z - body2.z;
-			distance := math.Sqrt(dx*dx + dy*dy + dz*dz);
-			e -= (body.mass * body2.mass) / distance;
+			body2 := sys[j]
+			dx := body.x - body2.x
+			dy := body.y - body2.y
+			dz := body.z - body2.z
+			distance := math.Sqrt(dx*dx + dy*dy + dz*dz)
+			e -= (body.mass * body2.mass) / distance
 		}
 	}
-	return e;
+	return e
 }
 
 func (sys System) advance(dt float64) {
 	for i, body := range sys {
 		for j := i + 1; j < len(sys); j++ {
-			body2 := sys[j];
-			dx := body.x - body2.x;
-			dy := body.y - body2.y;
-			dz := body.z - body2.z;
-
-			dSquared := dx*dx + dy*dy + dz*dz;
-			distance := math.Sqrt(dSquared);
-			mag := dt / (dSquared * distance);
-
-			body.vx -= dx * body2.mass * mag;
-			body.vy -= dy * body2.mass * mag;
-			body.vz -= dz * body2.mass * mag;
-
-			body2.vx += dx * body.mass * mag;
-			body2.vy += dy * body.mass * mag;
-			body2.vz += dz * body.mass * mag;
+			body2 := sys[j]
+			dx := body.x - body2.x
+			dy := body.y - body2.y
+			dz := body.z - body2.z
+
+			dSquared := dx*dx + dy*dy + dz*dz
+			distance := math.Sqrt(dSquared)
+			mag := dt / (dSquared * distance)
+
+			body.vx -= dx * body2.mass * mag
+			body.vy -= dy * body2.mass * mag
+			body.vz -= dz * body2.mass * mag
+
+			body2.vx += dx * body.mass * mag
+			body2.vy += dy * body.mass * mag
+			body2.vz += dz * body.mass * mag
 		}
 	}
 
 	for _, body := range sys {
-		body.x += dt * body.vx;
-		body.y += dt * body.vy;
-		body.z += dt * body.vz;
+		body.x += dt * body.vx
+		body.y += dt * body.vy
+		body.z += dt * body.vz
 	}
 }
 
 var (
-	jupiter	= Body{
+	jupiter = Body{
 		x: 4.84143144246472090e+00,
 		y: -1.16032004402742839e+00,
 		z: -1.03622044471123109e-01,
@@ -132,8 +132,8 @@ var (
 		vy: 7.69901118419740425e-03 * daysPerYear,
 		vz: -6.90460016972063023e-05 * daysPerYear,
 		mass: 9.54791938424326609e-04 * solarMass,
-	};
-	saturn	= Body{
+	}
+	saturn = Body{
 		x: 8.34336671824457987e+00,
 		y: 4.12479856412430479e+00,
 		z: -4.03523417114321381e-01,
@@ -141,8 +141,8 @@ var (
 		vy: 4.99852801234917238e-03 * daysPerYear,
 		vz: 2.30417297573763929e-05 * daysPerYear,
 		mass: 2.85885980666130812e-04 * solarMass,
-	};
-	uranus	= Body{
+	}
+	uranus = Body{
 		x: 1.28943695621391310e+01,
 		y: -1.51111514016986312e+01,
 		z: -2.23307578892655734e-01,
@@ -150,8 +150,8 @@ var (
 		vy: 2.37847173959480950e-03 * daysPerYear,
 		vz: -2.96589568540237556e-05 * daysPerYear,
 		mass: 4.36624404335156298e-05 * solarMass,
-	};
-	neptune	= Body{
+	}
+	neptune = Body{
 		x: 1.53796971148509165e+01,
 		y: -2.59193146099879641e+01,
 		z: 1.79258772950371181e-01,
@@ -159,19 +159,19 @@ var (
 		vy: 1.62824170038242295e-03 * daysPerYear,
 		vz: -9.51592254519715870e-05 * daysPerYear,
 		mass: 5.15138902046611451e-05 * solarMass,
-	};
-	sun	= Body{
+	}
+	sun = Body{
 		mass: solarMass,
-	};
+	}
 )
 
 func main() {
-	flag.Parse();
+	flag.Parse()
 
-	system := NewSystem([]Body{sun, jupiter, saturn, uranus, neptune});
-	fmt.Printf("%.9f\n", system.energy());
+	system := NewSystem([]Body{sun, jupiter, saturn, uranus, neptune})
+	fmt.Printf("%.9f\n", system.energy())
 	for i := 0; i < *n; i++ {
 		system.advance(0.01)
 	}
-	fmt.Printf("%.9f\n", system.energy());
+	fmt.Printf("%.9f\n", system.energy())
 }
diff --git a/test/bench/pidigits.go b/test/bench/pidigits.go
index d0dfc966b5..430c118287 100644
--- a/test/bench/pidigits.go
+++ b/test/bench/pidigits.go
@@ -38,20 +38,20 @@ POSSIBILITY OF SUCH DAMAGE.
 package main
 
 import (
-	"bignum";
-	"flag";
-	"fmt";
+	"bignum"
+	"flag"
+	"fmt"
 )
 
 var n = flag.Int("n", 27, "number of digits")
 var silent = flag.Bool("s", false, "don't print result")
 
 var (
-	tmp1	*bignum.Integer;
-	tmp2	*bignum.Integer;
-	numer	= bignum.Int(1);
-	accum	= bignum.Int(0);
-	denom	= bignum.Int(1);
+	tmp1  *bignum.Integer
+	tmp2  *bignum.Integer
+	numer = bignum.Int(1)
+	accum = bignum.Int(0)
+	denom = bignum.Int(1)
 )
 
 func extract_digit() int64 {
@@ -60,36 +60,36 @@ func extract_digit() int64 {
 	}
 
 	// Compute (numer * 3 + accum) / denom
-	tmp1 = numer.Shl(1);
-	bignum.Iadd(tmp1, tmp1, numer);
-	bignum.Iadd(tmp1, tmp1, accum);
-	tmp1, tmp2 := tmp1.QuoRem(denom);
+	tmp1 = numer.Shl(1)
+	bignum.Iadd(tmp1, tmp1, numer)
+	bignum.Iadd(tmp1, tmp1, accum)
+	tmp1, tmp2 := tmp1.QuoRem(denom)
 
 	// Now, if (numer * 4 + accum) % denom...
-	bignum.Iadd(tmp2, tmp2, numer);
+	bignum.Iadd(tmp2, tmp2, numer)
 
 	// ... is normalized, then the two divisions have the same result.
 	if tmp2.Cmp(denom) >= 0 {
 		return -1
 	}
 
-	return tmp1.Value();
+	return tmp1.Value()
 }
 
 func next_term(k int64) {
-	y2 := k*2 + 1;
+	y2 := k*2 + 1
 
-	tmp1 = numer.Shl(1);
-	bignum.Iadd(accum, accum, tmp1);
-	bignum.Iscale(accum, y2);
-	bignum.Iscale(numer, k);
-	bignum.Iscale(denom, y2);
+	tmp1 = numer.Shl(1)
+	bignum.Iadd(accum, accum, tmp1)
+	bignum.Iscale(accum, y2)
+	bignum.Iscale(numer, k)
+	bignum.Iscale(denom, y2)
 }
 
 func eliminate_digit(d int64) {
-	bignum.Isub(accum, accum, denom.Mul1(d));
-	bignum.Iscale(accum, 10);
-	bignum.Iscale(numer, 10);
+	bignum.Isub(accum, accum, denom.Mul1(d))
+	bignum.Iscale(accum, 10)
+	bignum.Iscale(numer, 10)
 }
 
 func printf(s string, arg ...) {
@@ -99,28 +99,28 @@ func printf(s string, arg ...) {
 }
 
 func main() {
-	flag.Parse();
+	flag.Parse()
 
-	var m int;	// 0 <= m < 10
+	var m int // 0 <= m < 10
 	for i, k := 0, int64(0); ; {
-		d := int64(-1);
+		d := int64(-1)
 		for d < 0 {
-			k++;
-			next_term(k);
-			d = extract_digit();
+			k++
+			next_term(k)
+			d = extract_digit()
 		}
 
-		printf("%c", d+'0');
+		printf("%c", d+'0')
 
-		i++;
-		m = i % 10;
+		i++
+		m = i % 10
 		if m == 0 {
 			printf("\t:%d\n", i)
 		}
 		if i >= *n {
 			break
 		}
-		eliminate_digit(d);
+		eliminate_digit(d)
 	}
 
 	if m > 0 {
diff --git a/test/bench/regex-dna.go b/test/bench/regex-dna.go
index 2e1ab8edb2..9d56830b36 100644
--- a/test/bench/regex-dna.go
+++ b/test/bench/regex-dna.go
@@ -36,11 +36,11 @@ POSSIBILITY OF SUCH DAMAGE.
 package main
 
 import (
-	"fmt";
-	"io/ioutil";
-	"os";
-	"regexp";
-	"strings";
+	"fmt"
+	"io/ioutil"
+	"os"
+	"regexp"
+	"strings"
 )
 
 var variants = []string{
@@ -56,7 +56,7 @@ var variants = []string{
 }
 
 type Subst struct {
-	pat, repl string;
+	pat, repl string
 }
 
 var substs = []Subst{
@@ -74,34 +74,34 @@ var substs = []Subst{
 }
 
 func countMatches(pat string, bytes []byte) int {
-	re := regexp.MustCompile(pat);
-	n := 0;
+	re := regexp.MustCompile(pat)
+	n := 0
 	for {
-		e := re.Execute(bytes);
+		e := re.Execute(bytes)
 		if len(e) == 0 {
 			break
 		}
-		n++;
-		bytes = bytes[e[1]:];
+		n++
+		bytes = bytes[e[1]:]
 	}
-	return n;
+	return n
 }
 
 func main() {
-	bytes, err := ioutil.ReadFile("/dev/stdin");
+	bytes, err := ioutil.ReadFile("/dev/stdin")
 	if err != nil {
-		fmt.Fprintf(os.Stderr, "can't read input: %s\n", err);
-		os.Exit(2);
+		fmt.Fprintf(os.Stderr, "can't read input: %s\n", err)
+		os.Exit(2)
 	}
-	ilen := len(bytes);
+	ilen := len(bytes)
 	// Delete the comment lines and newlines
-	bytes = regexp.MustCompile("(>[^\n]+)?\n").ReplaceAll(bytes, []byte{});
-	clen := len(bytes);
+	bytes = regexp.MustCompile("(>[^\n]+)?\n").ReplaceAll(bytes, []byte{})
+	clen := len(bytes)
 	for _, s := range variants {
 		fmt.Printf("%s %d\n", s, countMatches(s, bytes))
 	}
 	for _, sub := range substs {
 		bytes = regexp.MustCompile(sub.pat).ReplaceAll(bytes, strings.Bytes(sub.repl))
 	}
-	fmt.Printf("\n%d\n%d\n%d\n", ilen, clen, len(bytes));
+	fmt.Printf("\n%d\n%d\n%d\n", ilen, clen, len(bytes))
 }
diff --git a/test/bench/reverse-complement.go b/test/bench/reverse-complement.go
index a685e43b5b..baa30ffccc 100644
--- a/test/bench/reverse-complement.go
+++ b/test/bench/reverse-complement.go
@@ -36,8 +36,8 @@ POSSIBILITY OF SUCH DAMAGE.
 package main
 
 import (
-	"bufio";
-	"os";
+	"bufio"
+	"os"
 )
 
 const lineSize = 60
@@ -62,44 +62,44 @@ var complement = [256]uint8{
 }
 
 func main() {
-	in := bufio.NewReader(os.Stdin);
-	buf := make([]byte, 1024*1024);
-	line, err := in.ReadSlice('\n');
+	in := bufio.NewReader(os.Stdin)
+	buf := make([]byte, 1024*1024)
+	line, err := in.ReadSlice('\n')
 	for err == nil {
-		os.Stdout.Write(line);
+		os.Stdout.Write(line)
 
 		// Accumulate reversed complement in buf[w:]
-		nchar := 0;
-		w := len(buf);
+		nchar := 0
+		w := len(buf)
 		for {
-			line, err = in.ReadSlice('\n');
+			line, err = in.ReadSlice('\n')
 			if err != nil || line[0] == '>' {
 				break
 			}
-			line = line[0 : len(line)-1];
-			nchar += len(line);
+			line = line[0 : len(line)-1]
+			nchar += len(line)
 			if len(line)+nchar/60+128 >= w {
-				nbuf := make([]byte, len(buf)*5);
-				copy(nbuf[len(nbuf)-len(buf):], buf);
-				w += len(nbuf) - len(buf);
-				buf = nbuf;
+				nbuf := make([]byte, len(buf)*5)
+				copy(nbuf[len(nbuf)-len(buf):], buf)
+				w += len(nbuf) - len(buf)
+				buf = nbuf
 			}
 
 			// This loop is the bottleneck.
 			for _, c := range line {
-				w--;
-				buf[w] = complement[c];
+				w--
+				buf[w] = complement[c]
 			}
 		}
 
 		// Copy down to beginning of buffer, inserting newlines.
 		// The loop left room for the newlines and 128 bytes of padding.
-		i := 0;
+		i := 0
 		for j := w; j < len(buf); j += 60 {
-			n := copy(buf[i:i+60], buf[j:]);
-			buf[i+n] = '\n';
-			i += n + 1;
+			n := copy(buf[i:i+60], buf[j:])
+			buf[i+n] = '\n'
+			i += n + 1
 		}
-		os.Stdout.Write(buf[0:i]);
+		os.Stdout.Write(buf[0:i])
 	}
 }
diff --git a/test/bench/spectral-norm-parallel.go b/test/bench/spectral-norm-parallel.go
index 47882c69db..2706f39ec3 100644
--- a/test/bench/spectral-norm-parallel.go
+++ b/test/bench/spectral-norm-parallel.go
@@ -37,37 +37,37 @@ POSSIBILITY OF SUCH DAMAGE.
 package main
 
 import (
-	"flag";
-	"fmt";
-	"math";
-	"runtime";
+	"flag"
+	"fmt"
+	"math"
+	"runtime"
 )
 
 var n = flag.Int("n", 2000, "count")
 var nCPU = flag.Int("ncpu", 4, "number of cpus")
 
-func evalA(i, j int) float64	{ return 1 / float64(((i+j)*(i+j+1)/2 + i + 1)) }
+func evalA(i, j int) float64 { return 1 / float64(((i+j)*(i+j+1)/2 + i + 1)) }
 
 type Vec []float64
 
 func (v Vec) Times(i, n int, u Vec, c chan int) {
 	for ; i < n; i++ {
-		v[i] = 0;
+		v[i] = 0
 		for j := 0; j < len(u); j++ {
 			v[i] += evalA(i, j) * u[j]
 		}
 	}
-	c <- 1;
+	c <- 1
 }
 
 func (v Vec) TimesTransp(i, n int, u Vec, c chan int) {
 	for ; i < n; i++ {
-		v[i] = 0;
+		v[i] = 0
 		for j := 0; j < len(u); j++ {
 			v[i] += evalA(j, i) * u[j]
 		}
 	}
-	c <- 1;
+	c <- 1
 }
 
 func wait(c chan int) {
@@ -77,35 +77,35 @@ func wait(c chan int) {
 }
 
 func (v Vec) ATimesTransp(u Vec) {
-	x := make(Vec, len(u));
-	c := make(chan int, *nCPU);
+	x := make(Vec, len(u))
+	c := make(chan int, *nCPU)
 	for i := 0; i < *nCPU; i++ {
 		go x.Times(i*len(v) / *nCPU, (i+1)*len(v) / *nCPU, u, c)
 	}
-	wait(c);
+	wait(c)
 	for i := 0; i < *nCPU; i++ {
 		go v.TimesTransp(i*len(v) / *nCPU, (i+1)*len(v) / *nCPU, x, c)
 	}
-	wait(c);
+	wait(c)
 }
 
 func main() {
-	flag.Parse();
-	runtime.GOMAXPROCS(*nCPU);
-	N := *n;
-	u := make(Vec, N);
+	flag.Parse()
+	runtime.GOMAXPROCS(*nCPU)
+	N := *n
+	u := make(Vec, N)
 	for i := 0; i < N; i++ {
 		u[i] = 1
 	}
-	v := make(Vec, N);
+	v := make(Vec, N)
 	for i := 0; i < 10; i++ {
-		v.ATimesTransp(u);
-		u.ATimesTransp(v);
+		v.ATimesTransp(u)
+		u.ATimesTransp(v)
 	}
-	var vBv, vv float64;
+	var vBv, vv float64
 	for i := 0; i < N; i++ {
-		vBv += u[i] * v[i];
-		vv += v[i] * v[i];
+		vBv += u[i] * v[i]
+		vv += v[i] * v[i]
 	}
-	fmt.Printf("%0.9f\n", math.Sqrt(vBv/vv));
+	fmt.Printf("%0.9f\n", math.Sqrt(vBv/vv))
 }
diff --git a/test/bench/spectral-norm.go b/test/bench/spectral-norm.go
index e79bc282e5..6667f3e04a 100644
--- a/test/bench/spectral-norm.go
+++ b/test/bench/spectral-norm.go
@@ -37,20 +37,20 @@ POSSIBILITY OF SUCH DAMAGE.
 package main
 
 import (
-	"flag";
-	"fmt";
-	"math";
+	"flag"
+	"fmt"
+	"math"
 )
 
 var n = flag.Int("n", 2000, "count")
 
-func evalA(i, j int) float64	{ return 1 / float64(((i+j)*(i+j+1)/2 + i + 1)) }
+func evalA(i, j int) float64 { return 1 / float64(((i+j)*(i+j+1)/2 + i + 1)) }
 
 type Vec []float64
 
 func (v Vec) Times(u Vec) {
 	for i := 0; i < len(v); i++ {
-		v[i] = 0;
+		v[i] = 0
 		for j := 0; j < len(u); j++ {
 			v[i] += evalA(i, j) * u[j]
 		}
@@ -59,7 +59,7 @@ func (v Vec) Times(u Vec) {
 
 func (v Vec) TimesTransp(u Vec) {
 	for i := 0; i < len(v); i++ {
-		v[i] = 0;
+		v[i] = 0
 		for j := 0; j < len(u); j++ {
 			v[i] += evalA(j, i) * u[j]
 		}
@@ -67,27 +67,27 @@ func (v Vec) TimesTransp(u Vec) {
 }
 
 func (v Vec) ATimesTransp(u Vec) {
-	x := make(Vec, len(u));
-	x.Times(u);
-	v.TimesTransp(x);
+	x := make(Vec, len(u))
+	x.Times(u)
+	v.TimesTransp(x)
 }
 
 func main() {
-	flag.Parse();
-	N := *n;
-	u := make(Vec, N);
+	flag.Parse()
+	N := *n
+	u := make(Vec, N)
 	for i := 0; i < N; i++ {
 		u[i] = 1
 	}
-	v := make(Vec, N);
+	v := make(Vec, N)
 	for i := 0; i < 10; i++ {
-		v.ATimesTransp(u);
-		u.ATimesTransp(v);
+		v.ATimesTransp(u)
+		u.ATimesTransp(v)
 	}
-	var vBv, vv float64;
+	var vBv, vv float64
 	for i := 0; i < N; i++ {
-		vBv += u[i] * v[i];
-		vv += v[i] * v[i];
+		vBv += u[i] * v[i]
+		vv += v[i] * v[i]
 	}
-	fmt.Printf("%0.9f\n", math.Sqrt(vBv/vv));
+	fmt.Printf("%0.9f\n", math.Sqrt(vBv/vv))
 }
diff --git a/test/bench/threadring.go b/test/bench/threadring.go
index c069a2655e..031908a20f 100644
--- a/test/bench/threadring.go
+++ b/test/bench/threadring.go
@@ -36,9 +36,9 @@ POSSIBILITY OF SUCH DAMAGE.
 package main
 
 import (
-	"flag";
-	"fmt";
-	"os";
+	"flag"
+	"fmt"
+	"os"
 )
 
 var n = flag.Int("n", 1000, "how many passes")
@@ -47,25 +47,25 @@ const Nthread = 503
 
 func f(i int, in <-chan int, out chan<- int) {
 	for {
-		n := <-in;
+		n := <-in
 		if n == 0 {
-			fmt.Printf("%d\n", i);
-			os.Exit(0);
+			fmt.Printf("%d\n", i)
+			os.Exit(0)
 		}
-		out <- n-1;
+		out <- n-1
 	}
 }
 
 func main() {
-	flag.Parse();
+	flag.Parse()
 
-	one := make(chan int);	// will be input to thread 1
-	var in, out chan int = nil, one;
+	one := make(chan int) // will be input to thread 1
+	var in, out chan int = nil, one
 	for i := 1; i <= Nthread-1; i++ {
-		in, out = out, make(chan int);
-		go f(i, in, out);
+		in, out = out, make(chan int)
+		go f(i, in, out)
 	}
-	go f(Nthread, out, one);
-	one <- *n;
-	<-make(chan int);	// hang until ring completes
+	go f(Nthread, out, one)
+	one <- *n
+	<-make(chan int) // hang until ring completes
 }
