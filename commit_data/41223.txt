commit 606019cb4b1c8fb57e5a83747ee0aff1054291d8
Author: Matthew Dempsky <mdempsky@google.com>
Date:   Thu Sep 12 10:18:03 2019 -0700

    cmd/compile: trim function name prefix from escape diagnostics
    
    This information is redundant with the position information already
    provided. Also, no other -m diagnostics print out function name.
    
    While here, report parameter leak diagnostics against the parameter
    declaration position rather than the function, and use Warnl for
    "moved to heap" messages.
    
    Test cases updated programmatically by removing the first word from
    every "no match for" error emitted by run.go:
    
    go run run.go |& \
      sed -E -n 's/^(.*):(.*): no match for `([^ ]* (.*))` in:$/\1!\2!\3!\4/p' | \
      while IFS='!' read -r fn line before after; do
        before=$(echo "$before" | sed 's/[.[\*^$()+?{|]/\\&/g')
        after=$(echo "$after" | sed -E 's/(\&|\\)/\\&/g')
        fn=$(find . -name "${fn}" | head -1)
        sed -i -E -e "${line}s/\"${before}\"/\"${after}\"/" "${fn}"
      done
    
    Passes toolstash-check.
    
    Change-Id: I6e02486b1409e4a8dbb2b9b816d22095835426b5
    Reviewed-on: https://go-review.googlesource.com/c/go/+/195040
    Run-TryBot: Matthew Dempsky <mdempsky@google.com>
    TryBot-Result: Gobot Gobot <gobot@golang.org>
    Reviewed-by: Cherry Zhang <cherryyz@google.com>
---
 src/cmd/compile/internal/gc/esc.go    |  22 ++--
 src/cmd/compile/internal/gc/escape.go |   2 +-
 test/escape2.go                       | 238 +++++++++++++++++-----------------
 test/escape2n.go                      | 238 +++++++++++++++++-----------------
 test/escape_array.go                  |   4 +-
 test/escape_calls.go                  |   2 +-
 test/escape_closure.go                |  14 +-
 test/escape_field.go                  |  10 +-
 test/escape_iface.go                  |   2 +-
 test/escape_indir.go                  |   2 +-
 test/escape_param.go                  |  20 +--
 test/escape_struct_param1.go          |  52 ++++----
 test/escape_struct_param2.go          |  52 ++++----
 test/fixedbugs/issue12006.go          |  16 +--
 test/fixedbugs/issue12588.go          |   2 +-
 test/fixedbugs/issue13799.go          |  22 ++--
 test/fixedbugs/issue17318.go          |  10 +-
 test/fixedbugs/issue21709.go          |  10 +-
 test/fixedbugs/issue7921.go           |  14 +-
 test/inline.go                        |  12 +-
 test/inline_big.go                    |   6 +-
 test/linkname.dir/linkname1.go        |   2 +-
 test/live_syscall.go                  |   2 +-
 23 files changed, 377 insertions(+), 377 deletions(-)

diff --git a/src/cmd/compile/internal/gc/esc.go b/src/cmd/compile/internal/gc/esc.go
index c350d7c1bc..301fa7a8fc 100644
--- a/src/cmd/compile/internal/gc/esc.go
+++ b/src/cmd/compile/internal/gc/esc.go
@@ -392,7 +392,7 @@ func moveToHeap(n *Node) {
 	n.Name.Param.Heapaddr = heapaddr
 	n.Esc = EscHeap
 	if Debug['m'] != 0 {
-		fmt.Printf("%v: moved to heap: %v\n", n.Line(), n)
+		Warnl(n.Pos, "moved to heap: %v", n)
 	}
 }
 
@@ -422,7 +422,7 @@ func (e *Escape) paramTag(fn *Node, narg int, f *types.Field) string {
 		// argument and pass those annotations along to importing code.
 		if f.Type.Etype == TUINTPTR {
 			if Debug['m'] != 0 {
-				Warnl(fn.Pos, "%v assuming %v is unsafe uintptr", funcSym(fn), name())
+				Warnl(f.Pos, "assuming %v is unsafe uintptr", name())
 			}
 			return unsafeUintptrTag
 		}
@@ -435,13 +435,13 @@ func (e *Escape) paramTag(fn *Node, narg int, f *types.Field) string {
 		// //go:noescape is given before the declaration.
 		if fn.Noescape() {
 			if Debug['m'] != 0 && f.Sym != nil {
-				Warnl(fn.Pos, "%S %v does not escape", funcSym(fn), name())
+				Warnl(f.Pos, "%v does not escape", name())
 			}
 			return mktag(EscNone)
 		}
 
 		if Debug['m'] != 0 && f.Sym != nil {
-			Warnl(fn.Pos, "leaking param: %v", name())
+			Warnl(f.Pos, "leaking param: %v", name())
 		}
 		return mktag(EscHeap)
 	}
@@ -449,14 +449,14 @@ func (e *Escape) paramTag(fn *Node, narg int, f *types.Field) string {
 	if fn.Func.Pragma&UintptrEscapes != 0 {
 		if f.Type.Etype == TUINTPTR {
 			if Debug['m'] != 0 {
-				Warnl(fn.Pos, "%v marking %v as escaping uintptr", funcSym(fn), name())
+				Warnl(f.Pos, "marking %v as escaping uintptr", name())
 			}
 			return uintptrEscapesTag
 		}
 		if f.IsDDD() && f.Type.Elem().Etype == TUINTPTR {
 			// final argument is ...uintptr.
 			if Debug['m'] != 0 {
-				Warnl(fn.Pos, "%v marking %v as escaping ...uintptr", funcSym(fn), name())
+				Warnl(f.Pos, "marking %v as escaping ...uintptr", name())
 			}
 			return uintptrEscapesTag
 		}
@@ -477,17 +477,17 @@ func (e *Escape) paramTag(fn *Node, narg int, f *types.Field) string {
 
 	if Debug['m'] != 0 && !loc.escapes {
 		if esc == EscNone {
-			Warnl(n.Pos, "%S %S does not escape", funcSym(fn), n)
+			Warnl(f.Pos, "%v does not escape", name())
 		} else if esc == EscHeap {
-			Warnl(n.Pos, "leaking param: %S", n)
+			Warnl(f.Pos, "leaking param: %v", name())
 		} else {
 			if esc&EscContentEscapes != 0 {
-				Warnl(n.Pos, "leaking param content: %S", n)
+				Warnl(f.Pos, "leaking param content: %v", name())
 			}
 			for i := 0; i < numEscReturns; i++ {
 				if x := getEscReturn(esc, i); x >= 0 {
-					res := n.Name.Curfn.Type.Results().Field(i).Sym
-					Warnl(n.Pos, "leaking param: %S to result %v level=%d", n, res, x)
+					res := fn.Type.Results().Field(i).Sym
+					Warnl(f.Pos, "leaking param: %v to result %v level=%d", name(), res, x)
 				}
 			}
 		}
diff --git a/src/cmd/compile/internal/gc/escape.go b/src/cmd/compile/internal/gc/escape.go
index ff958beef3..ce0462414f 100644
--- a/src/cmd/compile/internal/gc/escape.go
+++ b/src/cmd/compile/internal/gc/escape.go
@@ -1289,7 +1289,7 @@ func (e *Escape) finish(fns []*Node) {
 			addrescapes(n)
 		} else {
 			if Debug['m'] != 0 && n.Op != ONAME && n.Op != OTYPESW && n.Op != ORANGE && n.Op != ODEFER {
-				Warnl(n.Pos, "%S %S does not escape", funcSym(loc.curfn), n)
+				Warnl(n.Pos, "%S does not escape", n)
 			}
 			n.Esc = EscNone
 			if loc.transient {
diff --git a/test/escape2.go b/test/escape2.go
index 49eb835915..b7cd914c22 100644
--- a/test/escape2.go
+++ b/test/escape2.go
@@ -37,24 +37,24 @@ func foo3b(t T) { // ERROR "leaking param: t$"
 }
 
 // xx isn't going anywhere, so use of yy is ok
-func foo4(xx, yy *int) { // ERROR "foo4 xx does not escape$" "foo4 yy does not escape$"
+func foo4(xx, yy *int) { // ERROR "xx does not escape$" "yy does not escape$"
 	xx = yy
 }
 
 // xx isn't going anywhere, so taking address of yy is ok
-func foo5(xx **int, yy *int) { // ERROR "foo5 xx does not escape$" "foo5 yy does not escape$"
+func foo5(xx **int, yy *int) { // ERROR "xx does not escape$" "yy does not escape$"
 	xx = &yy
 }
 
-func foo6(xx **int, yy *int) { // ERROR "foo6 xx does not escape$" "leaking param: yy$"
+func foo6(xx **int, yy *int) { // ERROR "xx does not escape$" "leaking param: yy$"
 	*xx = yy
 }
 
-func foo7(xx **int, yy *int) { // ERROR "foo7 xx does not escape$" "foo7 yy does not escape$"
+func foo7(xx **int, yy *int) { // ERROR "xx does not escape$" "yy does not escape$"
 	**xx = *yy
 }
 
-func foo8(xx, yy *int) int { // ERROR "foo8 xx does not escape$" "foo8 yy does not escape$"
+func foo8(xx, yy *int) int { // ERROR "xx does not escape$" "yy does not escape$"
 	xx = yy
 	return *xx
 }
@@ -64,7 +64,7 @@ func foo9(xx, yy *int) *int { // ERROR "leaking param: xx to result ~r2 level=0$
 	return xx
 }
 
-func foo10(xx, yy *int) { // ERROR "foo10 xx does not escape$" "foo10 yy does not escape$"
+func foo10(xx, yy *int) { // ERROR "xx does not escape$" "yy does not escape$"
 	*xx = *yy
 }
 
@@ -88,7 +88,7 @@ func foo13(yyy **int) { // ERROR "leaking param content: yyy$"
 	*xxx = *yyy
 }
 
-func foo14(yyy **int) { // ERROR "foo14 yyy does not escape$"
+func foo14(yyy **int) { // ERROR "yyy does not escape$"
 	**xxx = **yyy
 }
 
@@ -100,7 +100,7 @@ func foo16(yy *int) { // ERROR "leaking param: yy$"
 	*xxx = yy
 }
 
-func foo17(yy *int) { // ERROR "foo17 yy does not escape$"
+func foo17(yy *int) { // ERROR "yy does not escape$"
 	**xxx = *yy
 }
 
@@ -125,11 +125,11 @@ func NewBarp(x *int) *Bar { // ERROR "leaking param: x$"
 	return &Bar{42, x} // ERROR "&Bar literal escapes to heap$"
 }
 
-func NewBarp2(x *int) *Bar { // ERROR "NewBarp2 x does not escape$"
+func NewBarp2(x *int) *Bar { // ERROR "x does not escape$"
 	return &Bar{*x, nil} // ERROR "&Bar literal escapes to heap$"
 }
 
-func (b *Bar) NoLeak() int { // ERROR "\(\*Bar\).NoLeak b does not escape$"
+func (b *Bar) NoLeak() int { // ERROR "b does not escape$"
 	return *(b.ii)
 }
 
@@ -157,7 +157,7 @@ func (b *Bar) LeaksABit() *int { // ERROR "leaking param: b to result ~r0 level=
 	return b.ii
 }
 
-func (b Bar) StillNoLeak() int { // ERROR "Bar.StillNoLeak b does not escape$"
+func (b Bar) StillNoLeak() int { // ERROR "b does not escape$"
 	v := 0
 	b.ii = &v
 	return b.i
@@ -176,7 +176,7 @@ func NewBar2() *Bar2 {
 	return &Bar2{[12]int{42}, nil} // ERROR "&Bar2 literal escapes to heap$"
 }
 
-func (b *Bar2) NoLeak() int { // ERROR "\(\*Bar2\).NoLeak b does not escape$"
+func (b *Bar2) NoLeak() int { // ERROR "b does not escape$"
 	return b.i[0]
 }
 
@@ -188,7 +188,7 @@ func (b *Bar2) AlsoNoLeak() []int { // ERROR "leaking param: b to result ~r0 lev
 	return b.ii[0:1]
 }
 
-func (b Bar2) AgainNoLeak() [12]int { // ERROR "Bar2.AgainNoLeak b does not escape$"
+func (b Bar2) AgainNoLeak() [12]int { // ERROR "b does not escape$"
 	return b.i
 }
 
@@ -219,7 +219,7 @@ func foo21a() func() int {
 
 func foo22() int {
 	x := 42
-	return func() int { // ERROR "foo22 func literal does not escape$"
+	return func() int { // ERROR "func literal does not escape$"
 		return x
 	}()
 }
@@ -250,7 +250,7 @@ func foo23c(x int) func() int { // ERROR "moved to heap: x$"
 }
 
 func foo24(x int) int {
-	return func() int { // ERROR "foo24 func literal does not escape$"
+	return func() int { // ERROR "func literal does not escape$"
 		return x
 	}()
 }
@@ -262,7 +262,7 @@ func fooleak(xx *int) int { // ERROR "leaking param: xx$"
 	return *x
 }
 
-func foonoleak(xx *int) int { // ERROR "foonoleak xx does not escape$"
+func foonoleak(xx *int) int { // ERROR "xx does not escape$"
 	return *x + *xx
 }
 
@@ -286,7 +286,7 @@ func (f *Foo) fooleak() { // ERROR "leaking param: f$"
 	pf = f
 }
 
-func (f *Foo) foonoleak() { // ERROR "\(\*Foo\).foonoleak f does not escape$"
+func (f *Foo) foonoleak() { // ERROR "f does not escape$"
 	F.x = f.x
 }
 
@@ -294,7 +294,7 @@ func (f *Foo) Leak() { // ERROR "leaking param: f$"
 	f.fooleak()
 }
 
-func (f *Foo) NoLeak() { // ERROR "\(\*Foo\).NoLeak f does not escape$"
+func (f *Foo) NoLeak() { // ERROR "f does not escape$"
 	f.foonoleak()
 }
 
@@ -302,11 +302,11 @@ func foo41(x int) { // ERROR "moved to heap: x$"
 	F.xx = &x
 }
 
-func (f *Foo) foo42(x int) { // ERROR "\(\*Foo\).foo42 f does not escape$" "moved to heap: x$"
+func (f *Foo) foo42(x int) { // ERROR "f does not escape$" "moved to heap: x$"
 	f.xx = &x
 }
 
-func foo43(f *Foo, x int) { // ERROR "foo43 f does not escape$" "moved to heap: x$"
+func foo43(f *Foo, x int) { // ERROR "f does not escape$" "moved to heap: x$"
 	f.xx = &x
 }
 
@@ -314,7 +314,7 @@ func foo44(yy *int) { // ERROR "leaking param: yy$"
 	F.xx = yy
 }
 
-func (f *Foo) foo45() { // ERROR "\(\*Foo\).foo45 f does not escape$"
+func (f *Foo) foo45() { // ERROR "f does not escape$"
 	F.x = f.x
 }
 
@@ -407,7 +407,7 @@ func foo60(i *int) *int { // ERROR "leaking param: i to result ~r1 level=0$"
 	return a[1]
 }
 
-func foo60a(i *int) *int { // ERROR "foo60a i does not escape$"
+func foo60a(i *int) *int { // ERROR "i does not escape$"
 	var a [12]*int
 	a[0] = i
 	return nil
@@ -423,7 +423,7 @@ func foo61(i *int) *int { // ERROR "leaking param: i to result ~r1 level=0$"
 	return s.b
 }
 
-func foo61a(i *int) *int { // ERROR "foo61a i does not escape$"
+func foo61a(i *int) *int { // ERROR "i does not escape$"
 	type S struct {
 		a, b *int
 	}
@@ -439,7 +439,7 @@ func foo62(i *int) *int { // ERROR "leaking param: i$"
 	type S struct {
 		a, b *int
 	}
-	s := new(S) // ERROR "foo62 new\(S\) does not escape$"
+	s := new(S) // ERROR "new\(S\) does not escape$"
 	s.a = i
 	return nil // s.b
 }
@@ -448,7 +448,7 @@ type M interface {
 	M()
 }
 
-func foo63(m M) { // ERROR "foo63 m does not escape$"
+func foo63(m M) { // ERROR "m does not escape$"
 }
 
 func foo64(m M) { // ERROR "leaking param: m$"
@@ -475,7 +475,7 @@ func foo66() {
 
 func foo67() {
 	var mv MV
-	foo63(mv) // ERROR "foo67 mv does not escape$"
+	foo63(mv) // ERROR "mv does not escape$"
 }
 
 func foo68() {
@@ -539,7 +539,7 @@ func foo72b() [10]*int {
 
 // issue 2145
 func foo73() {
-	s := []int{3, 2, 1} // ERROR "foo73 \[\]int literal does not escape$"
+	s := []int{3, 2, 1} // ERROR "\[\]int literal does not escape$"
 	for _, v := range s {
 		vv := v
 		// actually just escapes its scope
@@ -550,7 +550,7 @@ func foo73() {
 }
 
 func foo731() {
-	s := []int{3, 2, 1} // ERROR "foo731 \[\]int literal does not escape$"
+	s := []int{3, 2, 1} // ERROR "\[\]int literal does not escape$"
 	for _, v := range s {
 		vv := v // ERROR "moved to heap: vv$"
 		// actually just escapes its scope
@@ -562,7 +562,7 @@ func foo731() {
 }
 
 func foo74() {
-	s := []int{3, 2, 1} // ERROR "foo74 \[\]int literal does not escape$"
+	s := []int{3, 2, 1} // ERROR "\[\]int literal does not escape$"
 	for _, v := range s {
 		vv := v
 		// actually just escapes its scope
@@ -574,7 +574,7 @@ func foo74() {
 }
 
 func foo74a() {
-	s := []int{3, 2, 1} // ERROR "foo74a \[\]int literal does not escape$"
+	s := []int{3, 2, 1} // ERROR "\[\]int literal does not escape$"
 	for _, v := range s {
 		vv := v // ERROR "moved to heap: vv$"
 		// actually just escapes its scope
@@ -589,7 +589,7 @@ func foo74a() {
 // issue 3975
 func foo74b() {
 	var array [3]func()
-	s := []int{3, 2, 1} // ERROR "foo74b \[\]int literal does not escape$"
+	s := []int{3, 2, 1} // ERROR "\[\]int literal does not escape$"
 	for i, v := range s {
 		vv := v
 		// actually just escapes its scope
@@ -601,7 +601,7 @@ func foo74b() {
 
 func foo74c() {
 	var array [3]func()
-	s := []int{3, 2, 1} // ERROR "foo74c \[\]int literal does not escape$"
+	s := []int{3, 2, 1} // ERROR "\[\]int literal does not escape$"
 	for i, v := range s {
 		vv := v // ERROR "moved to heap: vv$"
 		// actually just escapes its scope
@@ -611,57 +611,57 @@ func foo74c() {
 	}
 }
 
-func myprint(y *int, x ...interface{}) *int { // ERROR "leaking param: y to result ~r2 level=0$" "myprint x does not escape$"
+func myprint(y *int, x ...interface{}) *int { // ERROR "leaking param: y to result ~r2 level=0$" "x does not escape$"
 	return y
 }
 
-func myprint1(y *int, x ...interface{}) *interface{} { // ERROR "leaking param: x to result ~r2 level=0$" "myprint1 y does not escape$"
+func myprint1(y *int, x ...interface{}) *interface{} { // ERROR "leaking param: x to result ~r2 level=0$" "y does not escape$"
 	return &x[0]
 }
 
-func foo75(z *int) { // ERROR "foo75 z does not escape$"
-	myprint(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo75 ... argument does not escape$"
+func foo75(z *int) { // ERROR "z does not escape$"
+	myprint(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "... argument does not escape$"
 }
 
-func foo75a(z *int) { // ERROR "foo75a z does not escape$"
-	myprint1(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo75a ... argument does not escape$"
+func foo75a(z *int) { // ERROR "z does not escape$"
+	myprint1(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "... argument does not escape$"
 }
 
 func foo75esc(z *int) { // ERROR "leaking param: z$"
-	gxx = myprint(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo75esc ... argument does not escape$"
+	gxx = myprint(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "... argument does not escape$"
 }
 
-func foo75aesc(z *int) { // ERROR "foo75aesc z does not escape$"
+func foo75aesc(z *int) { // ERROR "z does not escape$"
 	var ppi **interface{}       // assignments to pointer dereferences lose track
 	*ppi = myprint1(z, 1, 2, 3) // ERROR "... argument escapes to heap$" "1 escapes to heap$" "2 escapes to heap$" "3 escapes to heap$"
 }
 
-func foo75aesc1(z *int) { // ERROR "foo75aesc1 z does not escape$"
+func foo75aesc1(z *int) { // ERROR "z does not escape$"
 	sink = myprint1(z, 1, 2, 3) // ERROR "... argument escapes to heap$" "1 escapes to heap$" "2 escapes to heap$" "3 escapes to heap$"
 }
 
 func foo76(z *int) { // ERROR "z does not escape"
-	myprint(nil, z) // ERROR "foo76 ... argument does not escape$"
+	myprint(nil, z) // ERROR "... argument does not escape$"
 }
 
 func foo76a(z *int) { // ERROR "z does not escape"
-	myprint1(nil, z) // ERROR "foo76a ... argument does not escape$"
+	myprint1(nil, z) // ERROR "... argument does not escape$"
 }
 
 func foo76b() {
-	myprint(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo76b ... argument does not escape$"
+	myprint(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "... argument does not escape$"
 }
 
 func foo76c() {
-	myprint1(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo76c ... argument does not escape$"
+	myprint1(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "... argument does not escape$"
 }
 
 func foo76d() {
-	defer myprint(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo76d ... argument does not escape$"
+	defer myprint(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "... argument does not escape$"
 }
 
 func foo76e() {
-	defer myprint1(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo76e ... argument does not escape$"
+	defer myprint1(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "... argument does not escape$"
 }
 
 func foo76f() {
@@ -677,11 +677,11 @@ func foo76g() {
 	}
 }
 
-func foo77(z []interface{}) { // ERROR "foo77 z does not escape$"
+func foo77(z []interface{}) { // ERROR "z does not escape$"
 	myprint(nil, z...) // z does not escape
 }
 
-func foo77a(z []interface{}) { // ERROR "foo77a z does not escape$"
+func foo77a(z []interface{}) { // ERROR "z does not escape$"
 	myprint1(nil, z...)
 }
 
@@ -696,10 +696,10 @@ func foo77c(z []interface{}) { // ERROR "leaking param: z$"
 
 func dotdotdot() {
 	i := 0
-	myprint(nil, &i) // ERROR "dotdotdot ... argument does not escape$"
+	myprint(nil, &i) // ERROR "... argument does not escape$"
 
 	j := 0
-	myprint1(nil, &j) // ERROR "dotdotdot ... argument does not escape$"
+	myprint1(nil, &j) // ERROR "... argument does not escape$"
 }
 
 func foo78(z int) *int { // ERROR "moved to heap: z$"
@@ -728,7 +728,7 @@ func foo80() *int {
 
 func foo81() *int {
 	for {
-		z := new(int) // ERROR "foo81 new\(int\) does not escape$"
+		z := new(int) // ERROR "new\(int\) does not escape$"
 		_ = z
 	}
 	return nil
@@ -736,7 +736,7 @@ func foo81() *int {
 
 func tee(p *int) (x, y *int) { return p, p } // ERROR "leaking param: p to result x level=0$" "leaking param: p to result y level=0$"
 
-func noop(x, y *int) {} // ERROR "noop x does not escape$" "noop y does not escape$"
+func noop(x, y *int) {} // ERROR "x does not escape$" "y does not escape$"
 
 func foo82() {
 	var x, y, z int // ERROR "moved to heap: x$" "moved to heap: y$" "moved to heap: z$"
@@ -775,7 +775,7 @@ func foo92(x *int) [2]*int { // ERROR "leaking param: x to result ~r1 level=0$"
 }
 
 // does not leak c
-func foo93(c chan *int) *int { // ERROR "foo93 c does not escape$"
+func foo93(c chan *int) *int { // ERROR "c does not escape$"
 	for v := range c {
 		return v
 	}
@@ -794,7 +794,7 @@ func foo94(m map[*int]*int, b bool) *int { // ERROR "leaking param: m to result
 }
 
 // does leak x
-func foo95(m map[*int]*int, x *int) { // ERROR "foo95 m does not escape$" "leaking param: x$"
+func foo95(m map[*int]*int, x *int) { // ERROR "m does not escape$" "leaking param: x$"
 	m[x] = x
 }
 
@@ -809,7 +809,7 @@ func foo97(m [1]*int) *int { // ERROR "leaking param: m to result ~r1 level=0$"
 }
 
 // does not leak m
-func foo98(m map[int]*int) *int { // ERROR "foo98 m does not escape$"
+func foo98(m map[int]*int) *int { // ERROR "m does not escape$"
 	return m[0]
 }
 
@@ -835,7 +835,7 @@ func foo101(m [1]*int) *int { // ERROR "leaking param: m to result ~r1 level=0$"
 }
 
 // does not leak m
-func foo101a(m [1]*int) *int { // ERROR "foo101a m does not escape$"
+func foo101a(m [1]*int) *int { // ERROR "m does not escape$"
 	for i := range m { // ERROR "moved to heap: i$"
 		return &i
 	}
@@ -843,12 +843,12 @@ func foo101a(m [1]*int) *int { // ERROR "foo101a m does not escape$"
 }
 
 // does leak x
-func foo102(m []*int, x *int) { // ERROR "foo102 m does not escape$" "leaking param: x$"
+func foo102(m []*int, x *int) { // ERROR "m does not escape$" "leaking param: x$"
 	m[0] = x
 }
 
 // does not leak x
-func foo103(m [1]*int, x *int) { // ERROR "foo103 m does not escape$" "foo103 x does not escape$"
+func foo103(m [1]*int, x *int) { // ERROR "m does not escape$" "x does not escape$"
 	m[0] = x
 }
 
@@ -878,7 +878,7 @@ func foo108(x *int) map[*int]*int { // ERROR "leaking param: x$"
 }
 
 func foo109(x *int) *int { // ERROR "leaking param: x$"
-	m := map[*int]*int{x: nil} // ERROR "foo109 map\[\*int\]\*int literal does not escape$"
+	m := map[*int]*int{x: nil} // ERROR "map\[\*int\]\*int literal does not escape$"
 	for k, _ := range m {
 		return k
 	}
@@ -886,12 +886,12 @@ func foo109(x *int) *int { // ERROR "leaking param: x$"
 }
 
 func foo110(x *int) *int { // ERROR "leaking param: x$"
-	m := map[*int]*int{nil: x} // ERROR "foo110 map\[\*int\]\*int literal does not escape$"
+	m := map[*int]*int{nil: x} // ERROR "map\[\*int\]\*int literal does not escape$"
 	return m[nil]
 }
 
 func foo111(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0"
-	m := []*int{x} // ERROR "foo111 \[\]\*int literal does not escape$"
+	m := []*int{x} // ERROR "\[\]\*int literal does not escape$"
 	return m[0]
 }
 
@@ -906,7 +906,7 @@ func foo113(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0$"
 }
 
 func foo114(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0$"
-	m := &Bar{ii: x} // ERROR "foo114 &Bar literal does not escape$"
+	m := &Bar{ii: x} // ERROR "&Bar literal does not escape$"
 	return m.ii
 }
 
@@ -925,12 +925,12 @@ func foo116(b bool) *int {
 	return nil
 }
 
-func foo117(unknown func(interface{})) { // ERROR "foo117 unknown does not escape$"
+func foo117(unknown func(interface{})) { // ERROR "unknown does not escape$"
 	x := 1 // ERROR "moved to heap: x$"
 	unknown(&x)
 }
 
-func foo118(unknown func(*int)) { // ERROR "foo118 unknown does not escape$"
+func foo118(unknown func(*int)) { // ERROR "unknown does not escape$"
 	x := 1 // ERROR "moved to heap: x$"
 	unknown(&x)
 }
@@ -1167,7 +1167,7 @@ func foo122() {
 
 	goto L1
 L1:
-	i = new(int) // ERROR "foo122 new\(int\) does not escape$"
+	i = new(int) // ERROR "new\(int\) does not escape$"
 	_ = i
 }
 
@@ -1182,18 +1182,18 @@ L1:
 	_ = i
 }
 
-func foo124(x **int) { // ERROR "foo124 x does not escape$"
+func foo124(x **int) { // ERROR "x does not escape$"
 	var i int // ERROR "moved to heap: i$"
 	p := &i
-	func() { // ERROR "foo124 func literal does not escape$"
+	func() { // ERROR "func literal does not escape$"
 		*x = p
 	}()
 }
 
-func foo125(ch chan *int) { // ERROR "foo125 ch does not escape$"
+func foo125(ch chan *int) { // ERROR "ch does not escape$"
 	var i int // ERROR "moved to heap: i$"
 	p := &i
-	func() { // ERROR "foo125 func literal does not escape$"
+	func() { // ERROR "func literal does not escape$"
 		ch <- p
 	}()
 }
@@ -1203,7 +1203,7 @@ func foo126() {
 	for {
 		// loopdepth 1
 		var i int // ERROR "moved to heap: i$"
-		func() {  // ERROR "foo126 func literal does not escape$"
+		func() {  // ERROR "func literal does not escape$"
 			px = &i
 		}()
 	}
@@ -1229,9 +1229,9 @@ func foo128() {
 func foo129() {
 	var i int // ERROR "moved to heap: i$"
 	p := &i
-	func() { // ERROR "foo129 func literal does not escape$"
+	func() { // ERROR "func literal does not escape$"
 		q := p
-		func() { // ERROR "foo129.func1 func literal does not escape$"
+		func() { // ERROR "func literal does not escape$"
 			r := q
 			px = r
 		}()
@@ -1241,7 +1241,7 @@ func foo129() {
 func foo130() {
 	for {
 		var i int // ERROR "moved to heap: i$"
-		func() {  // ERROR "foo130 func literal does not escape$"
+		func() {  // ERROR "func literal does not escape$"
 			px = &i
 		}()
 	}
@@ -1249,7 +1249,7 @@ func foo130() {
 
 func foo131() {
 	var i int // ERROR "moved to heap: i$"
-	func() {  // ERROR "foo131 func literal does not escape$"
+	func() {  // ERROR "func literal does not escape$"
 		px = &i
 	}()
 }
@@ -1263,7 +1263,7 @@ func foo132() {
 
 func foo133() {
 	var i int      // ERROR "moved to heap: i$"
-	defer func() { // ERROR "foo133 func literal does not escape$"
+	defer func() { // ERROR "func literal does not escape$"
 		px = &i
 	}()
 }
@@ -1271,9 +1271,9 @@ func foo133() {
 func foo134() {
 	var i int
 	p := &i
-	func() { // ERROR "foo134 func literal does not escape$"
+	func() { // ERROR "func literal does not escape$"
 		q := p
-		func() { // ERROR "foo134.func1 func literal does not escape$"
+		func() { // ERROR "func literal does not escape$"
 			r := q
 			_ = r
 		}()
@@ -1285,7 +1285,7 @@ func foo135() {
 	p := &i
 	go func() { // ERROR "func literal escapes to heap$"
 		q := p
-		func() { // ERROR "foo135.func1 func literal does not escape$"
+		func() { // ERROR "func literal does not escape$"
 			r := q
 			_ = r
 		}()
@@ -1297,7 +1297,7 @@ func foo136() {
 	p := &i
 	go func() { // ERROR "func literal escapes to heap$"
 		q := p
-		func() { // ERROR "foo136.func1 func literal does not escape$"
+		func() { // ERROR "func literal does not escape$"
 			r := q
 			px = r
 		}()
@@ -1307,7 +1307,7 @@ func foo136() {
 func foo137() {
 	var i int // ERROR "moved to heap: i$"
 	p := &i
-	func() { // ERROR "foo137 func literal does not escape$"
+	func() { // ERROR "func literal does not escape$"
 		q := p
 		go func() { // ERROR "func literal escapes to heap$"
 			r := q
@@ -1358,7 +1358,7 @@ func F2([]byte)
 
 //go:noescape
 
-func F3(x []byte) // ERROR "F3 x does not escape$"
+func F3(x []byte) // ERROR "x does not escape$"
 
 func F4(x []byte) // ERROR "leaking param: x$"
 
@@ -1380,14 +1380,14 @@ type Tm struct {
 	x int
 }
 
-func (t *Tm) M() { // ERROR "\(\*Tm\).M t does not escape$"
+func (t *Tm) M() { // ERROR "t does not escape$"
 }
 
 func foo141() {
 	var f func()
 
 	t := new(Tm) // ERROR "new\(Tm\) escapes to heap$"
-	f = t.M      // ERROR "foo141 t.M does not escape$"
+	f = t.M      // ERROR "t.M does not escape$"
 	_ = f
 }
 
@@ -1401,7 +1401,7 @@ func foo142() {
 // issue 3888.
 func foo143() {
 	for i := 0; i < 1000; i++ {
-		func() { // ERROR "foo143 func literal does not escape$"
+		func() { // ERROR "func literal does not escape$"
 			for i := 0; i < 1; i++ {
 				var t Tm
 				t.M()
@@ -1435,20 +1435,20 @@ type List struct {
 	Next *List
 }
 
-func foo145(l List) { // ERROR "foo145 l does not escape$"
+func foo145(l List) { // ERROR "l does not escape$"
 	var p *List
 	for p = &l; p.Next != nil; p = p.Next {
 	}
 }
 
-func foo146(l List) { // ERROR "foo146 l does not escape$"
+func foo146(l List) { // ERROR "l does not escape$"
 	var p *List
 	p = &l
 	for ; p.Next != nil; p = p.Next {
 	}
 }
 
-func foo147(l List) { // ERROR "foo147 l does not escape$"
+func foo147(l List) { // ERROR "l does not escape$"
 	var p *List
 	p = &l
 	for p.Next != nil {
@@ -1456,14 +1456,14 @@ func foo147(l List) { // ERROR "foo147 l does not escape$"
 	}
 }
 
-func foo148(l List) { // ERROR "foo148 l does not escape$"
+func foo148(l List) { // ERROR "l does not escape$"
 	for p := &l; p.Next != nil; p = p.Next {
 	}
 }
 
 // related: address of variable should have depth of variable, not of loop
 
-func foo149(l List) { // ERROR "foo149 l does not escape$"
+func foo149(l List) { // ERROR "l does not escape$"
 	var p *List
 	for {
 		for p = &l; p.Next != nil; p = p.Next {
@@ -1542,7 +1542,7 @@ func foo152() {
 
 // issue 8176 - &x in type switch body not marked as escaping
 
-func foo153(v interface{}) *int { // ERROR "foo153 v does not escape"
+func foo153(v interface{}) *int { // ERROR "v does not escape"
 	switch x := v.(type) {
 	case int: // ERROR "moved to heap: x$"
 		return &x
@@ -1571,14 +1571,14 @@ type Lit struct {
 func ptrlitNoescape() {
 	// Both literal and element do not escape.
 	i := 0
-	x := &Lit{&i} // ERROR "ptrlitNoescape &Lit literal does not escape$"
+	x := &Lit{&i} // ERROR "&Lit literal does not escape$"
 	_ = x
 }
 
 func ptrlitNoEscape2() {
 	// Literal does not escape, but element does.
 	i := 0        // ERROR "moved to heap: i$"
-	x := &Lit{&i} // ERROR "ptrlitNoEscape2 &Lit literal does not escape$"
+	x := &Lit{&i} // ERROR "&Lit literal does not escape$"
 	sink = *x
 }
 
@@ -1600,7 +1600,7 @@ type Buffer struct {
 	str2   string
 }
 
-func (b *Buffer) foo() { // ERROR "\(\*Buffer\).foo b does not escape$"
+func (b *Buffer) foo() { // ERROR "b does not escape$"
 	b.buf1 = b.buf1[1:2]   // ERROR "\(\*Buffer\).foo ignoring self-assignment in b.buf1 = b.buf1\[1:2\]$"
 	b.buf1 = b.buf1[1:2:3] // ERROR "\(\*Buffer\).foo ignoring self-assignment in b.buf1 = b.buf1\[1:2:3\]$"
 	b.buf1 = b.buf2[1:2]   // ERROR "\(\*Buffer\).foo ignoring self-assignment in b.buf1 = b.buf2\[1:2\]$"
@@ -1611,12 +1611,12 @@ func (b *Buffer) bar() { // ERROR "leaking param: b$"
 	b.buf1 = b.arr[1:2]
 }
 
-func (b *Buffer) arrayPtr() { // ERROR "\(\*Buffer\).arrayPtr b does not escape"
+func (b *Buffer) arrayPtr() { // ERROR "b does not escape"
 	b.buf1 = b.arrPtr[1:2]   // ERROR "\(\*Buffer\).arrayPtr ignoring self-assignment in b.buf1 = b.arrPtr\[1:2\]$"
 	b.buf1 = b.arrPtr[1:2:3] // ERROR "\(\*Buffer\).arrayPtr ignoring self-assignment in b.buf1 = b.arrPtr\[1:2:3\]$"
 }
 
-func (b *Buffer) baz() { // ERROR "\(\*Buffer\).baz b does not escape$"
+func (b *Buffer) baz() { // ERROR "b does not escape$"
 	b.str1 = b.str1[1:2] // ERROR "\(\*Buffer\).baz ignoring self-assignment in b.str1 = b.str1\[1:2\]$"
 	b.str1 = b.str2[1:2] // ERROR "\(\*Buffer\).baz ignoring self-assignment in b.str1 = b.str2\[1:2\]$"
 }
@@ -1627,7 +1627,7 @@ func (b *Buffer) bat() { // ERROR "leaking param content: b$"
 	sink = o
 }
 
-func quux(sp *string, bp *[]byte) { // ERROR "quux bp does not escape$" "quux sp does not escape$"
+func quux(sp *string, bp *[]byte) { // ERROR "bp does not escape$" "sp does not escape$"
 	*sp = (*sp)[1:2] // ERROR "quux ignoring self-assignment in \*sp = \(\*sp\)\[1:2\]$"
 	*bp = (*bp)[1:2] // ERROR "quux ignoring self-assignment in \*bp = \(\*bp\)\[1:2\]$"
 }
@@ -1650,27 +1650,27 @@ func fieldFlowTracking() {
 // String operations.
 
 func slicebytetostring0() {
-	b := make([]byte, 20) // ERROR "slicebytetostring0 make\(\[\]byte, 20\) does not escape$"
-	s := string(b)        // ERROR "slicebytetostring0 string\(b\) does not escape$"
+	b := make([]byte, 20) // ERROR "make\(\[\]byte, 20\) does not escape$"
+	s := string(b)        // ERROR "string\(b\) does not escape$"
 	_ = s
 }
 
 func slicebytetostring1() {
-	b := make([]byte, 20) // ERROR "slicebytetostring1 make\(\[\]byte, 20\) does not escape$"
-	s := string(b)        // ERROR "slicebytetostring1 string\(b\) does not escape$"
+	b := make([]byte, 20) // ERROR "make\(\[\]byte, 20\) does not escape$"
+	s := string(b)        // ERROR "string\(b\) does not escape$"
 	s1 := s[0:1]
 	_ = s1
 }
 
 func slicebytetostring2() {
-	b := make([]byte, 20) // ERROR "slicebytetostring2 make\(\[\]byte, 20\) does not escape$"
+	b := make([]byte, 20) // ERROR "make\(\[\]byte, 20\) does not escape$"
 	s := string(b)        // ERROR "string\(b\) escapes to heap$"
 	s1 := s[0:1]          // ERROR "moved to heap: s1$"
 	sink = &s1
 }
 
 func slicebytetostring3() {
-	b := make([]byte, 20) // ERROR "slicebytetostring3 make\(\[\]byte, 20\) does not escape$"
+	b := make([]byte, 20) // ERROR "make\(\[\]byte, 20\) does not escape$"
 	s := string(b)        // ERROR "string\(b\) escapes to heap$"
 	s1 := s[0:1]
 	sink = s1 // ERROR "s1 escapes to heap$"
@@ -1679,7 +1679,7 @@ func slicebytetostring3() {
 func addstr0() {
 	s0 := "a"
 	s1 := "b"
-	s := s0 + s1 // ERROR "addstr0 s0 \+ s1 does not escape$"
+	s := s0 + s1 // ERROR "s0 \+ s1 does not escape$"
 	_ = s
 }
 
@@ -1687,14 +1687,14 @@ func addstr1() {
 	s0 := "a"
 	s1 := "b"
 	s := "c"
-	s += s0 + s1 // ERROR "addstr1 s0 \+ s1 does not escape$"
+	s += s0 + s1 // ERROR "s0 \+ s1 does not escape$"
 	_ = s
 }
 
 func addstr2() {
-	b := make([]byte, 20) // ERROR "addstr2 make\(\[\]byte, 20\) does not escape$"
+	b := make([]byte, 20) // ERROR "make\(\[\]byte, 20\) does not escape$"
 	s0 := "a"
-	s := string(b) + s0 // ERROR "addstr2 string\(b\) \+ s0 does not escape$" "addstr2 string\(b\) does not escape$"
+	s := string(b) + s0 // ERROR "string\(b\) \+ s0 does not escape$" "string\(b\) does not escape$"
 	_ = s
 }
 
@@ -1709,7 +1709,7 @@ func addstr3() {
 func intstring0() bool {
 	// string does not escape
 	x := '0'
-	s := string(x) // ERROR "intstring0 string\(x\) does not escape$"
+	s := string(x) // ERROR "string\(x\) does not escape$"
 	return s == "0"
 }
 
@@ -1729,7 +1729,7 @@ func intstring2() {
 
 func stringtoslicebyte0() {
 	s := "foo"
-	x := []byte(s) // ERROR "stringtoslicebyte0 \(\[\]byte\)\(s\) does not escape$"
+	x := []byte(s) // ERROR "\(\[\]byte\)\(s\) does not escape$"
 	_ = x
 }
 
@@ -1745,7 +1745,7 @@ func stringtoslicebyte2() {
 
 func stringtoslicerune0() {
 	s := "foo"
-	x := []rune(s) // ERROR "stringtoslicerune0 \(\[\]rune\)\(s\) does not escape$"
+	x := []rune(s) // ERROR "\(\[\]rune\)\(s\) does not escape$"
 	_ = x
 }
 
@@ -1760,23 +1760,23 @@ func stringtoslicerune2() {
 }
 
 func slicerunetostring0() {
-	r := []rune{1, 2, 3} // ERROR "slicerunetostring0 \[\]rune literal does not escape$"
-	s := string(r)       // ERROR "slicerunetostring0 string\(r\) does not escape$"
+	r := []rune{1, 2, 3} // ERROR "\[\]rune literal does not escape$"
+	s := string(r)       // ERROR "string\(r\) does not escape$"
 	_ = s
 }
 
 func slicerunetostring1() string {
-	r := []rune{1, 2, 3} // ERROR "slicerunetostring1 \[\]rune literal does not escape$"
+	r := []rune{1, 2, 3} // ERROR "\[\]rune literal does not escape$"
 	return string(r)     // ERROR "string\(r\) escapes to heap$"
 }
 
 func slicerunetostring2() {
-	r := []rune{1, 2, 3} // ERROR "slicerunetostring2 \[\]rune literal does not escape$"
+	r := []rune{1, 2, 3} // ERROR "\[\]rune literal does not escape$"
 	sink = string(r)     // ERROR "string\(r\) escapes to heap$"
 }
 
 func makemap0() {
-	m := make(map[int]int) // ERROR "makemap0 make\(map\[int\]int\) does not escape$"
+	m := make(map[int]int) // ERROR "make\(map\[int\]int\) does not escape$"
 	m[0] = 0
 	m[1]++
 	delete(m, 1)
@@ -1792,12 +1792,12 @@ func makemap2() {
 	sink = m
 }
 
-func nonescapingEface(m map[interface{}]bool) bool { // ERROR "nonescapingEface m does not escape$"
-	return m["foo"] // ERROR "nonescapingEface .foo. does not escape$"
+func nonescapingEface(m map[interface{}]bool) bool { // ERROR "m does not escape$"
+	return m["foo"] // ERROR ".foo. does not escape$"
 }
 
-func nonescapingIface(m map[M]bool) bool { // ERROR "nonescapingIface m does not escape$"
-	return m[MV(0)] // ERROR "nonescapingIface MV\(0\) does not escape$"
+func nonescapingIface(m map[M]bool) bool { // ERROR "m does not escape$"
+	return m[MV(0)] // ERROR "MV\(0\) does not escape$"
 }
 
 func issue10353() {
diff --git a/test/escape2n.go b/test/escape2n.go
index 936f0d8af6..42312fe41d 100644
--- a/test/escape2n.go
+++ b/test/escape2n.go
@@ -37,24 +37,24 @@ func foo3b(t T) { // ERROR "leaking param: t$"
 }
 
 // xx isn't going anywhere, so use of yy is ok
-func foo4(xx, yy *int) { // ERROR "foo4 xx does not escape$" "foo4 yy does not escape$"
+func foo4(xx, yy *int) { // ERROR "xx does not escape$" "yy does not escape$"
 	xx = yy
 }
 
 // xx isn't going anywhere, so taking address of yy is ok
-func foo5(xx **int, yy *int) { // ERROR "foo5 xx does not escape$" "foo5 yy does not escape$"
+func foo5(xx **int, yy *int) { // ERROR "xx does not escape$" "yy does not escape$"
 	xx = &yy
 }
 
-func foo6(xx **int, yy *int) { // ERROR "foo6 xx does not escape$" "leaking param: yy$"
+func foo6(xx **int, yy *int) { // ERROR "xx does not escape$" "leaking param: yy$"
 	*xx = yy
 }
 
-func foo7(xx **int, yy *int) { // ERROR "foo7 xx does not escape$" "foo7 yy does not escape$"
+func foo7(xx **int, yy *int) { // ERROR "xx does not escape$" "yy does not escape$"
 	**xx = *yy
 }
 
-func foo8(xx, yy *int) int { // ERROR "foo8 xx does not escape$" "foo8 yy does not escape$"
+func foo8(xx, yy *int) int { // ERROR "xx does not escape$" "yy does not escape$"
 	xx = yy
 	return *xx
 }
@@ -64,7 +64,7 @@ func foo9(xx, yy *int) *int { // ERROR "leaking param: xx to result ~r2 level=0$
 	return xx
 }
 
-func foo10(xx, yy *int) { // ERROR "foo10 xx does not escape$" "foo10 yy does not escape$"
+func foo10(xx, yy *int) { // ERROR "xx does not escape$" "yy does not escape$"
 	*xx = *yy
 }
 
@@ -88,7 +88,7 @@ func foo13(yyy **int) { // ERROR "leaking param content: yyy$"
 	*xxx = *yyy
 }
 
-func foo14(yyy **int) { // ERROR "foo14 yyy does not escape$"
+func foo14(yyy **int) { // ERROR "yyy does not escape$"
 	**xxx = **yyy
 }
 
@@ -100,7 +100,7 @@ func foo16(yy *int) { // ERROR "leaking param: yy$"
 	*xxx = yy
 }
 
-func foo17(yy *int) { // ERROR "foo17 yy does not escape$"
+func foo17(yy *int) { // ERROR "yy does not escape$"
 	**xxx = *yy
 }
 
@@ -125,11 +125,11 @@ func NewBarp(x *int) *Bar { // ERROR "leaking param: x$"
 	return &Bar{42, x} // ERROR "&Bar literal escapes to heap$"
 }
 
-func NewBarp2(x *int) *Bar { // ERROR "NewBarp2 x does not escape$"
+func NewBarp2(x *int) *Bar { // ERROR "x does not escape$"
 	return &Bar{*x, nil} // ERROR "&Bar literal escapes to heap$"
 }
 
-func (b *Bar) NoLeak() int { // ERROR "\(\*Bar\).NoLeak b does not escape$"
+func (b *Bar) NoLeak() int { // ERROR "b does not escape$"
 	return *(b.ii)
 }
 
@@ -157,7 +157,7 @@ func (b *Bar) LeaksABit() *int { // ERROR "leaking param: b to result ~r0 level=
 	return b.ii
 }
 
-func (b Bar) StillNoLeak() int { // ERROR "Bar.StillNoLeak b does not escape$"
+func (b Bar) StillNoLeak() int { // ERROR "b does not escape$"
 	v := 0
 	b.ii = &v
 	return b.i
@@ -176,7 +176,7 @@ func NewBar2() *Bar2 {
 	return &Bar2{[12]int{42}, nil} // ERROR "&Bar2 literal escapes to heap$"
 }
 
-func (b *Bar2) NoLeak() int { // ERROR "\(\*Bar2\).NoLeak b does not escape$"
+func (b *Bar2) NoLeak() int { // ERROR "b does not escape$"
 	return b.i[0]
 }
 
@@ -188,7 +188,7 @@ func (b *Bar2) AlsoNoLeak() []int { // ERROR "leaking param: b to result ~r0 lev
 	return b.ii[0:1]
 }
 
-func (b Bar2) AgainNoLeak() [12]int { // ERROR "Bar2.AgainNoLeak b does not escape$"
+func (b Bar2) AgainNoLeak() [12]int { // ERROR "b does not escape$"
 	return b.i
 }
 
@@ -219,7 +219,7 @@ func foo21a() func() int {
 
 func foo22() int {
 	x := 42
-	return func() int { // ERROR "foo22 func literal does not escape$"
+	return func() int { // ERROR "func literal does not escape$"
 		return x
 	}()
 }
@@ -250,7 +250,7 @@ func foo23c(x int) func() int { // ERROR "moved to heap: x$"
 }
 
 func foo24(x int) int {
-	return func() int { // ERROR "foo24 func literal does not escape$"
+	return func() int { // ERROR "func literal does not escape$"
 		return x
 	}()
 }
@@ -262,7 +262,7 @@ func fooleak(xx *int) int { // ERROR "leaking param: xx$"
 	return *x
 }
 
-func foonoleak(xx *int) int { // ERROR "foonoleak xx does not escape$"
+func foonoleak(xx *int) int { // ERROR "xx does not escape$"
 	return *x + *xx
 }
 
@@ -286,7 +286,7 @@ func (f *Foo) fooleak() { // ERROR "leaking param: f$"
 	pf = f
 }
 
-func (f *Foo) foonoleak() { // ERROR "\(\*Foo\).foonoleak f does not escape$"
+func (f *Foo) foonoleak() { // ERROR "f does not escape$"
 	F.x = f.x
 }
 
@@ -294,7 +294,7 @@ func (f *Foo) Leak() { // ERROR "leaking param: f$"
 	f.fooleak()
 }
 
-func (f *Foo) NoLeak() { // ERROR "\(\*Foo\).NoLeak f does not escape$"
+func (f *Foo) NoLeak() { // ERROR "f does not escape$"
 	f.foonoleak()
 }
 
@@ -302,11 +302,11 @@ func foo41(x int) { // ERROR "moved to heap: x$"
 	F.xx = &x
 }
 
-func (f *Foo) foo42(x int) { // ERROR "\(\*Foo\).foo42 f does not escape$" "moved to heap: x$"
+func (f *Foo) foo42(x int) { // ERROR "f does not escape$" "moved to heap: x$"
 	f.xx = &x
 }
 
-func foo43(f *Foo, x int) { // ERROR "foo43 f does not escape$" "moved to heap: x$"
+func foo43(f *Foo, x int) { // ERROR "f does not escape$" "moved to heap: x$"
 	f.xx = &x
 }
 
@@ -314,7 +314,7 @@ func foo44(yy *int) { // ERROR "leaking param: yy$"
 	F.xx = yy
 }
 
-func (f *Foo) foo45() { // ERROR "\(\*Foo\).foo45 f does not escape$"
+func (f *Foo) foo45() { // ERROR "f does not escape$"
 	F.x = f.x
 }
 
@@ -407,7 +407,7 @@ func foo60(i *int) *int { // ERROR "leaking param: i to result ~r1 level=0$"
 	return a[1]
 }
 
-func foo60a(i *int) *int { // ERROR "foo60a i does not escape$"
+func foo60a(i *int) *int { // ERROR "i does not escape$"
 	var a [12]*int
 	a[0] = i
 	return nil
@@ -423,7 +423,7 @@ func foo61(i *int) *int { // ERROR "leaking param: i to result ~r1 level=0$"
 	return s.b
 }
 
-func foo61a(i *int) *int { // ERROR "foo61a i does not escape$"
+func foo61a(i *int) *int { // ERROR "i does not escape$"
 	type S struct {
 		a, b *int
 	}
@@ -439,7 +439,7 @@ func foo62(i *int) *int { // ERROR "leaking param: i$"
 	type S struct {
 		a, b *int
 	}
-	s := new(S) // ERROR "foo62 new\(S\) does not escape$"
+	s := new(S) // ERROR "new\(S\) does not escape$"
 	s.a = i
 	return nil // s.b
 }
@@ -448,7 +448,7 @@ type M interface {
 	M()
 }
 
-func foo63(m M) { // ERROR "foo63 m does not escape$"
+func foo63(m M) { // ERROR "m does not escape$"
 }
 
 func foo64(m M) { // ERROR "leaking param: m$"
@@ -475,7 +475,7 @@ func foo66() {
 
 func foo67() {
 	var mv MV
-	foo63(mv) // ERROR "foo67 mv does not escape$"
+	foo63(mv) // ERROR "mv does not escape$"
 }
 
 func foo68() {
@@ -539,7 +539,7 @@ func foo72b() [10]*int {
 
 // issue 2145
 func foo73() {
-	s := []int{3, 2, 1} // ERROR "foo73 \[\]int literal does not escape$"
+	s := []int{3, 2, 1} // ERROR "\[\]int literal does not escape$"
 	for _, v := range s {
 		vv := v
 		// actually just escapes its scope
@@ -550,7 +550,7 @@ func foo73() {
 }
 
 func foo731() {
-	s := []int{3, 2, 1} // ERROR "foo731 \[\]int literal does not escape$"
+	s := []int{3, 2, 1} // ERROR "\[\]int literal does not escape$"
 	for _, v := range s {
 		vv := v // ERROR "moved to heap: vv$"
 		// actually just escapes its scope
@@ -562,7 +562,7 @@ func foo731() {
 }
 
 func foo74() {
-	s := []int{3, 2, 1} // ERROR "foo74 \[\]int literal does not escape$"
+	s := []int{3, 2, 1} // ERROR "\[\]int literal does not escape$"
 	for _, v := range s {
 		vv := v
 		// actually just escapes its scope
@@ -574,7 +574,7 @@ func foo74() {
 }
 
 func foo74a() {
-	s := []int{3, 2, 1} // ERROR "foo74a \[\]int literal does not escape$"
+	s := []int{3, 2, 1} // ERROR "\[\]int literal does not escape$"
 	for _, v := range s {
 		vv := v // ERROR "moved to heap: vv$"
 		// actually just escapes its scope
@@ -589,7 +589,7 @@ func foo74a() {
 // issue 3975
 func foo74b() {
 	var array [3]func()
-	s := []int{3, 2, 1} // ERROR "foo74b \[\]int literal does not escape$"
+	s := []int{3, 2, 1} // ERROR "\[\]int literal does not escape$"
 	for i, v := range s {
 		vv := v
 		// actually just escapes its scope
@@ -601,7 +601,7 @@ func foo74b() {
 
 func foo74c() {
 	var array [3]func()
-	s := []int{3, 2, 1} // ERROR "foo74c \[\]int literal does not escape$"
+	s := []int{3, 2, 1} // ERROR "\[\]int literal does not escape$"
 	for i, v := range s {
 		vv := v // ERROR "moved to heap: vv$"
 		// actually just escapes its scope
@@ -611,57 +611,57 @@ func foo74c() {
 	}
 }
 
-func myprint(y *int, x ...interface{}) *int { // ERROR "leaking param: y to result ~r2 level=0$" "myprint x does not escape$"
+func myprint(y *int, x ...interface{}) *int { // ERROR "leaking param: y to result ~r2 level=0$" "x does not escape$"
 	return y
 }
 
-func myprint1(y *int, x ...interface{}) *interface{} { // ERROR "leaking param: x to result ~r2 level=0$" "myprint1 y does not escape$"
+func myprint1(y *int, x ...interface{}) *interface{} { // ERROR "leaking param: x to result ~r2 level=0$" "y does not escape$"
 	return &x[0]
 }
 
-func foo75(z *int) { // ERROR "foo75 z does not escape$"
-	myprint(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo75 ... argument does not escape$"
+func foo75(z *int) { // ERROR "z does not escape$"
+	myprint(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "... argument does not escape$"
 }
 
-func foo75a(z *int) { // ERROR "foo75a z does not escape$"
-	myprint1(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo75a ... argument does not escape$"
+func foo75a(z *int) { // ERROR "z does not escape$"
+	myprint1(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "... argument does not escape$"
 }
 
 func foo75esc(z *int) { // ERROR "leaking param: z$"
-	gxx = myprint(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo75esc ... argument does not escape$"
+	gxx = myprint(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "... argument does not escape$"
 }
 
-func foo75aesc(z *int) { // ERROR "foo75aesc z does not escape$"
+func foo75aesc(z *int) { // ERROR "z does not escape$"
 	var ppi **interface{}       // assignments to pointer dereferences lose track
 	*ppi = myprint1(z, 1, 2, 3) // ERROR "... argument escapes to heap$" "1 escapes to heap$" "2 escapes to heap$" "3 escapes to heap$"
 }
 
-func foo75aesc1(z *int) { // ERROR "foo75aesc1 z does not escape$"
+func foo75aesc1(z *int) { // ERROR "z does not escape$"
 	sink = myprint1(z, 1, 2, 3) // ERROR "... argument escapes to heap$" "1 escapes to heap$" "2 escapes to heap$" "3 escapes to heap$"
 }
 
 func foo76(z *int) { // ERROR "z does not escape"
-	myprint(nil, z) // ERROR "foo76 ... argument does not escape$"
+	myprint(nil, z) // ERROR "... argument does not escape$"
 }
 
 func foo76a(z *int) { // ERROR "z does not escape"
-	myprint1(nil, z) // ERROR "foo76a ... argument does not escape$"
+	myprint1(nil, z) // ERROR "... argument does not escape$"
 }
 
 func foo76b() {
-	myprint(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo76b ... argument does not escape$"
+	myprint(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "... argument does not escape$"
 }
 
 func foo76c() {
-	myprint1(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo76c ... argument does not escape$"
+	myprint1(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "... argument does not escape$"
 }
 
 func foo76d() {
-	defer myprint(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo76d ... argument does not escape$"
+	defer myprint(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "... argument does not escape$"
 }
 
 func foo76e() {
-	defer myprint1(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo76e ... argument does not escape$"
+	defer myprint1(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "... argument does not escape$"
 }
 
 func foo76f() {
@@ -677,11 +677,11 @@ func foo76g() {
 	}
 }
 
-func foo77(z []interface{}) { // ERROR "foo77 z does not escape$"
+func foo77(z []interface{}) { // ERROR "z does not escape$"
 	myprint(nil, z...) // z does not escape
 }
 
-func foo77a(z []interface{}) { // ERROR "foo77a z does not escape$"
+func foo77a(z []interface{}) { // ERROR "z does not escape$"
 	myprint1(nil, z...)
 }
 
@@ -696,10 +696,10 @@ func foo77c(z []interface{}) { // ERROR "leaking param: z$"
 
 func dotdotdot() {
 	i := 0
-	myprint(nil, &i) // ERROR "dotdotdot ... argument does not escape$"
+	myprint(nil, &i) // ERROR "... argument does not escape$"
 
 	j := 0
-	myprint1(nil, &j) // ERROR "dotdotdot ... argument does not escape$"
+	myprint1(nil, &j) // ERROR "... argument does not escape$"
 }
 
 func foo78(z int) *int { // ERROR "moved to heap: z$"
@@ -728,7 +728,7 @@ func foo80() *int {
 
 func foo81() *int {
 	for {
-		z := new(int) // ERROR "foo81 new\(int\) does not escape$"
+		z := new(int) // ERROR "new\(int\) does not escape$"
 		_ = z
 	}
 	return nil
@@ -736,7 +736,7 @@ func foo81() *int {
 
 func tee(p *int) (x, y *int) { return p, p } // ERROR "leaking param: p to result x level=0$" "leaking param: p to result y level=0$"
 
-func noop(x, y *int) {} // ERROR "noop x does not escape$" "noop y does not escape$"
+func noop(x, y *int) {} // ERROR "x does not escape$" "y does not escape$"
 
 func foo82() {
 	var x, y, z int // ERROR "moved to heap: x$" "moved to heap: y$" "moved to heap: z$"
@@ -775,7 +775,7 @@ func foo92(x *int) [2]*int { // ERROR "leaking param: x to result ~r1 level=0$"
 }
 
 // does not leak c
-func foo93(c chan *int) *int { // ERROR "foo93 c does not escape$"
+func foo93(c chan *int) *int { // ERROR "c does not escape$"
 	for v := range c {
 		return v
 	}
@@ -794,7 +794,7 @@ func foo94(m map[*int]*int, b bool) *int { // ERROR "leaking param: m to result
 }
 
 // does leak x
-func foo95(m map[*int]*int, x *int) { // ERROR "foo95 m does not escape$" "leaking param: x$"
+func foo95(m map[*int]*int, x *int) { // ERROR "m does not escape$" "leaking param: x$"
 	m[x] = x
 }
 
@@ -809,7 +809,7 @@ func foo97(m [1]*int) *int { // ERROR "leaking param: m to result ~r1 level=0$"
 }
 
 // does not leak m
-func foo98(m map[int]*int) *int { // ERROR "foo98 m does not escape$"
+func foo98(m map[int]*int) *int { // ERROR "m does not escape$"
 	return m[0]
 }
 
@@ -835,7 +835,7 @@ func foo101(m [1]*int) *int { // ERROR "leaking param: m to result ~r1 level=0$"
 }
 
 // does not leak m
-func foo101a(m [1]*int) *int { // ERROR "foo101a m does not escape$"
+func foo101a(m [1]*int) *int { // ERROR "m does not escape$"
 	for i := range m { // ERROR "moved to heap: i$"
 		return &i
 	}
@@ -843,12 +843,12 @@ func foo101a(m [1]*int) *int { // ERROR "foo101a m does not escape$"
 }
 
 // does leak x
-func foo102(m []*int, x *int) { // ERROR "foo102 m does not escape$" "leaking param: x$"
+func foo102(m []*int, x *int) { // ERROR "m does not escape$" "leaking param: x$"
 	m[0] = x
 }
 
 // does not leak x
-func foo103(m [1]*int, x *int) { // ERROR "foo103 m does not escape$" "foo103 x does not escape$"
+func foo103(m [1]*int, x *int) { // ERROR "m does not escape$" "x does not escape$"
 	m[0] = x
 }
 
@@ -878,7 +878,7 @@ func foo108(x *int) map[*int]*int { // ERROR "leaking param: x$"
 }
 
 func foo109(x *int) *int { // ERROR "leaking param: x$"
-	m := map[*int]*int{x: nil} // ERROR "foo109 map\[\*int\]\*int literal does not escape$"
+	m := map[*int]*int{x: nil} // ERROR "map\[\*int\]\*int literal does not escape$"
 	for k, _ := range m {
 		return k
 	}
@@ -886,12 +886,12 @@ func foo109(x *int) *int { // ERROR "leaking param: x$"
 }
 
 func foo110(x *int) *int { // ERROR "leaking param: x$"
-	m := map[*int]*int{nil: x} // ERROR "foo110 map\[\*int\]\*int literal does not escape$"
+	m := map[*int]*int{nil: x} // ERROR "map\[\*int\]\*int literal does not escape$"
 	return m[nil]
 }
 
 func foo111(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0"
-	m := []*int{x} // ERROR "foo111 \[\]\*int literal does not escape$"
+	m := []*int{x} // ERROR "\[\]\*int literal does not escape$"
 	return m[0]
 }
 
@@ -906,7 +906,7 @@ func foo113(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0$"
 }
 
 func foo114(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0$"
-	m := &Bar{ii: x} // ERROR "foo114 &Bar literal does not escape$"
+	m := &Bar{ii: x} // ERROR "&Bar literal does not escape$"
 	return m.ii
 }
 
@@ -925,12 +925,12 @@ func foo116(b bool) *int {
 	return nil
 }
 
-func foo117(unknown func(interface{})) { // ERROR "foo117 unknown does not escape$"
+func foo117(unknown func(interface{})) { // ERROR "unknown does not escape$"
 	x := 1 // ERROR "moved to heap: x$"
 	unknown(&x)
 }
 
-func foo118(unknown func(*int)) { // ERROR "foo118 unknown does not escape$"
+func foo118(unknown func(*int)) { // ERROR "unknown does not escape$"
 	x := 1 // ERROR "moved to heap: x$"
 	unknown(&x)
 }
@@ -1167,7 +1167,7 @@ func foo122() {
 
 	goto L1
 L1:
-	i = new(int) // ERROR "foo122 new\(int\) does not escape$"
+	i = new(int) // ERROR "new\(int\) does not escape$"
 	_ = i
 }
 
@@ -1182,18 +1182,18 @@ L1:
 	_ = i
 }
 
-func foo124(x **int) { // ERROR "foo124 x does not escape$"
+func foo124(x **int) { // ERROR "x does not escape$"
 	var i int // ERROR "moved to heap: i$"
 	p := &i
-	func() { // ERROR "foo124 func literal does not escape$"
+	func() { // ERROR "func literal does not escape$"
 		*x = p
 	}()
 }
 
-func foo125(ch chan *int) { // ERROR "foo125 ch does not escape$"
+func foo125(ch chan *int) { // ERROR "ch does not escape$"
 	var i int // ERROR "moved to heap: i$"
 	p := &i
-	func() { // ERROR "foo125 func literal does not escape$"
+	func() { // ERROR "func literal does not escape$"
 		ch <- p
 	}()
 }
@@ -1203,7 +1203,7 @@ func foo126() {
 	for {
 		// loopdepth 1
 		var i int // ERROR "moved to heap: i$"
-		func() {  // ERROR "foo126 func literal does not escape$"
+		func() {  // ERROR "func literal does not escape$"
 			px = &i
 		}()
 	}
@@ -1229,9 +1229,9 @@ func foo128() {
 func foo129() {
 	var i int // ERROR "moved to heap: i$"
 	p := &i
-	func() { // ERROR "foo129 func literal does not escape$"
+	func() { // ERROR "func literal does not escape$"
 		q := p
-		func() { // ERROR "foo129.func1 func literal does not escape$"
+		func() { // ERROR "func literal does not escape$"
 			r := q
 			px = r
 		}()
@@ -1241,7 +1241,7 @@ func foo129() {
 func foo130() {
 	for {
 		var i int // ERROR "moved to heap: i$"
-		func() {  // ERROR "foo130 func literal does not escape$"
+		func() {  // ERROR "func literal does not escape$"
 			px = &i
 		}()
 	}
@@ -1249,7 +1249,7 @@ func foo130() {
 
 func foo131() {
 	var i int // ERROR "moved to heap: i$"
-	func() {  // ERROR "foo131 func literal does not escape$"
+	func() {  // ERROR "func literal does not escape$"
 		px = &i
 	}()
 }
@@ -1263,7 +1263,7 @@ func foo132() {
 
 func foo133() {
 	var i int      // ERROR "moved to heap: i$"
-	defer func() { // ERROR "foo133 func literal does not escape$"
+	defer func() { // ERROR "func literal does not escape$"
 		px = &i
 	}()
 }
@@ -1271,9 +1271,9 @@ func foo133() {
 func foo134() {
 	var i int
 	p := &i
-	func() { // ERROR "foo134 func literal does not escape$"
+	func() { // ERROR "func literal does not escape$"
 		q := p
-		func() { // ERROR "foo134.func1 func literal does not escape$"
+		func() { // ERROR "func literal does not escape$"
 			r := q
 			_ = r
 		}()
@@ -1285,7 +1285,7 @@ func foo135() {
 	p := &i
 	go func() { // ERROR "func literal escapes to heap$"
 		q := p
-		func() { // ERROR "foo135.func1 func literal does not escape$"
+		func() { // ERROR "func literal does not escape$"
 			r := q
 			_ = r
 		}()
@@ -1297,7 +1297,7 @@ func foo136() {
 	p := &i
 	go func() { // ERROR "func literal escapes to heap$"
 		q := p
-		func() { // ERROR "foo136.func1 func literal does not escape$"
+		func() { // ERROR "func literal does not escape$"
 			r := q
 			px = r
 		}()
@@ -1307,7 +1307,7 @@ func foo136() {
 func foo137() {
 	var i int // ERROR "moved to heap: i$"
 	p := &i
-	func() { // ERROR "foo137 func literal does not escape$"
+	func() { // ERROR "func literal does not escape$"
 		q := p
 		go func() { // ERROR "func literal escapes to heap$"
 			r := q
@@ -1358,7 +1358,7 @@ func F2([]byte)
 
 //go:noescape
 
-func F3(x []byte) // ERROR "F3 x does not escape$"
+func F3(x []byte) // ERROR "x does not escape$"
 
 func F4(x []byte) // ERROR "leaking param: x$"
 
@@ -1380,14 +1380,14 @@ type Tm struct {
 	x int
 }
 
-func (t *Tm) M() { // ERROR "\(\*Tm\).M t does not escape$"
+func (t *Tm) M() { // ERROR "t does not escape$"
 }
 
 func foo141() {
 	var f func()
 
 	t := new(Tm) // ERROR "new\(Tm\) escapes to heap$"
-	f = t.M      // ERROR "foo141 t.M does not escape$"
+	f = t.M      // ERROR "t.M does not escape$"
 	_ = f
 }
 
@@ -1401,7 +1401,7 @@ func foo142() {
 // issue 3888.
 func foo143() {
 	for i := 0; i < 1000; i++ {
-		func() { // ERROR "foo143 func literal does not escape$"
+		func() { // ERROR "func literal does not escape$"
 			for i := 0; i < 1; i++ {
 				var t Tm
 				t.M()
@@ -1435,20 +1435,20 @@ type List struct {
 	Next *List
 }
 
-func foo145(l List) { // ERROR "foo145 l does not escape$"
+func foo145(l List) { // ERROR "l does not escape$"
 	var p *List
 	for p = &l; p.Next != nil; p = p.Next {
 	}
 }
 
-func foo146(l List) { // ERROR "foo146 l does not escape$"
+func foo146(l List) { // ERROR "l does not escape$"
 	var p *List
 	p = &l
 	for ; p.Next != nil; p = p.Next {
 	}
 }
 
-func foo147(l List) { // ERROR "foo147 l does not escape$"
+func foo147(l List) { // ERROR "l does not escape$"
 	var p *List
 	p = &l
 	for p.Next != nil {
@@ -1456,14 +1456,14 @@ func foo147(l List) { // ERROR "foo147 l does not escape$"
 	}
 }
 
-func foo148(l List) { // ERROR "foo148 l does not escape$"
+func foo148(l List) { // ERROR "l does not escape$"
 	for p := &l; p.Next != nil; p = p.Next {
 	}
 }
 
 // related: address of variable should have depth of variable, not of loop
 
-func foo149(l List) { // ERROR "foo149 l does not escape$"
+func foo149(l List) { // ERROR "l does not escape$"
 	var p *List
 	for {
 		for p = &l; p.Next != nil; p = p.Next {
@@ -1542,7 +1542,7 @@ func foo152() {
 
 // issue 8176 - &x in type switch body not marked as escaping
 
-func foo153(v interface{}) *int { // ERROR "foo153 v does not escape"
+func foo153(v interface{}) *int { // ERROR "v does not escape"
 	switch x := v.(type) {
 	case int: // ERROR "moved to heap: x$"
 		return &x
@@ -1571,14 +1571,14 @@ type Lit struct {
 func ptrlitNoescape() {
 	// Both literal and element do not escape.
 	i := 0
-	x := &Lit{&i} // ERROR "ptrlitNoescape &Lit literal does not escape$"
+	x := &Lit{&i} // ERROR "&Lit literal does not escape$"
 	_ = x
 }
 
 func ptrlitNoEscape2() {
 	// Literal does not escape, but element does.
 	i := 0        // ERROR "moved to heap: i$"
-	x := &Lit{&i} // ERROR "ptrlitNoEscape2 &Lit literal does not escape$"
+	x := &Lit{&i} // ERROR "&Lit literal does not escape$"
 	sink = *x
 }
 
@@ -1600,7 +1600,7 @@ type Buffer struct {
 	str2   string
 }
 
-func (b *Buffer) foo() { // ERROR "\(\*Buffer\).foo b does not escape$"
+func (b *Buffer) foo() { // ERROR "b does not escape$"
 	b.buf1 = b.buf1[1:2]   // ERROR "\(\*Buffer\).foo ignoring self-assignment in b.buf1 = b.buf1\[1:2\]$"
 	b.buf1 = b.buf1[1:2:3] // ERROR "\(\*Buffer\).foo ignoring self-assignment in b.buf1 = b.buf1\[1:2:3\]$"
 	b.buf1 = b.buf2[1:2]   // ERROR "\(\*Buffer\).foo ignoring self-assignment in b.buf1 = b.buf2\[1:2\]$"
@@ -1611,12 +1611,12 @@ func (b *Buffer) bar() { // ERROR "leaking param: b$"
 	b.buf1 = b.arr[1:2]
 }
 
-func (b *Buffer) arrayPtr() { // ERROR "\(\*Buffer\).arrayPtr b does not escape"
+func (b *Buffer) arrayPtr() { // ERROR "b does not escape"
 	b.buf1 = b.arrPtr[1:2]   // ERROR "\(\*Buffer\).arrayPtr ignoring self-assignment in b.buf1 = b.arrPtr\[1:2\]$"
 	b.buf1 = b.arrPtr[1:2:3] // ERROR "\(\*Buffer\).arrayPtr ignoring self-assignment in b.buf1 = b.arrPtr\[1:2:3\]$"
 }
 
-func (b *Buffer) baz() { // ERROR "\(\*Buffer\).baz b does not escape$"
+func (b *Buffer) baz() { // ERROR "b does not escape$"
 	b.str1 = b.str1[1:2] // ERROR "\(\*Buffer\).baz ignoring self-assignment in b.str1 = b.str1\[1:2\]$"
 	b.str1 = b.str2[1:2] // ERROR "\(\*Buffer\).baz ignoring self-assignment in b.str1 = b.str2\[1:2\]$"
 }
@@ -1627,7 +1627,7 @@ func (b *Buffer) bat() { // ERROR "leaking param content: b$"
 	sink = o
 }
 
-func quux(sp *string, bp *[]byte) { // ERROR "quux bp does not escape$" "quux sp does not escape$"
+func quux(sp *string, bp *[]byte) { // ERROR "bp does not escape$" "sp does not escape$"
 	*sp = (*sp)[1:2] // ERROR "quux ignoring self-assignment in \*sp = \(\*sp\)\[1:2\]$"
 	*bp = (*bp)[1:2] // ERROR "quux ignoring self-assignment in \*bp = \(\*bp\)\[1:2\]$"
 }
@@ -1650,27 +1650,27 @@ func fieldFlowTracking() {
 // String operations.
 
 func slicebytetostring0() {
-	b := make([]byte, 20) // ERROR "slicebytetostring0 make\(\[\]byte, 20\) does not escape$"
-	s := string(b)        // ERROR "slicebytetostring0 string\(b\) does not escape$"
+	b := make([]byte, 20) // ERROR "make\(\[\]byte, 20\) does not escape$"
+	s := string(b)        // ERROR "string\(b\) does not escape$"
 	_ = s
 }
 
 func slicebytetostring1() {
-	b := make([]byte, 20) // ERROR "slicebytetostring1 make\(\[\]byte, 20\) does not escape$"
-	s := string(b)        // ERROR "slicebytetostring1 string\(b\) does not escape$"
+	b := make([]byte, 20) // ERROR "make\(\[\]byte, 20\) does not escape$"
+	s := string(b)        // ERROR "string\(b\) does not escape$"
 	s1 := s[0:1]
 	_ = s1
 }
 
 func slicebytetostring2() {
-	b := make([]byte, 20) // ERROR "slicebytetostring2 make\(\[\]byte, 20\) does not escape$"
+	b := make([]byte, 20) // ERROR "make\(\[\]byte, 20\) does not escape$"
 	s := string(b)        // ERROR "string\(b\) escapes to heap$"
 	s1 := s[0:1]          // ERROR "moved to heap: s1$"
 	sink = &s1
 }
 
 func slicebytetostring3() {
-	b := make([]byte, 20) // ERROR "slicebytetostring3 make\(\[\]byte, 20\) does not escape$"
+	b := make([]byte, 20) // ERROR "make\(\[\]byte, 20\) does not escape$"
 	s := string(b)        // ERROR "string\(b\) escapes to heap$"
 	s1 := s[0:1]
 	sink = s1 // ERROR "s1 escapes to heap$"
@@ -1679,7 +1679,7 @@ func slicebytetostring3() {
 func addstr0() {
 	s0 := "a"
 	s1 := "b"
-	s := s0 + s1 // ERROR "addstr0 s0 \+ s1 does not escape$"
+	s := s0 + s1 // ERROR "s0 \+ s1 does not escape$"
 	_ = s
 }
 
@@ -1687,14 +1687,14 @@ func addstr1() {
 	s0 := "a"
 	s1 := "b"
 	s := "c"
-	s += s0 + s1 // ERROR "addstr1 s0 \+ s1 does not escape$"
+	s += s0 + s1 // ERROR "s0 \+ s1 does not escape$"
 	_ = s
 }
 
 func addstr2() {
-	b := make([]byte, 20) // ERROR "addstr2 make\(\[\]byte, 20\) does not escape$"
+	b := make([]byte, 20) // ERROR "make\(\[\]byte, 20\) does not escape$"
 	s0 := "a"
-	s := string(b) + s0 // ERROR "addstr2 string\(b\) \+ s0 does not escape$" "addstr2 string\(b\) does not escape$"
+	s := string(b) + s0 // ERROR "string\(b\) \+ s0 does not escape$" "string\(b\) does not escape$"
 	_ = s
 }
 
@@ -1709,7 +1709,7 @@ func addstr3() {
 func intstring0() bool {
 	// string does not escape
 	x := '0'
-	s := string(x) // ERROR "intstring0 string\(x\) does not escape$"
+	s := string(x) // ERROR "string\(x\) does not escape$"
 	return s == "0"
 }
 
@@ -1729,7 +1729,7 @@ func intstring2() {
 
 func stringtoslicebyte0() {
 	s := "foo"
-	x := []byte(s) // ERROR "stringtoslicebyte0 \(\[\]byte\)\(s\) does not escape$"
+	x := []byte(s) // ERROR "\(\[\]byte\)\(s\) does not escape$"
 	_ = x
 }
 
@@ -1745,7 +1745,7 @@ func stringtoslicebyte2() {
 
 func stringtoslicerune0() {
 	s := "foo"
-	x := []rune(s) // ERROR "stringtoslicerune0 \(\[\]rune\)\(s\) does not escape$"
+	x := []rune(s) // ERROR "\(\[\]rune\)\(s\) does not escape$"
 	_ = x
 }
 
@@ -1760,23 +1760,23 @@ func stringtoslicerune2() {
 }
 
 func slicerunetostring0() {
-	r := []rune{1, 2, 3} // ERROR "slicerunetostring0 \[\]rune literal does not escape$"
-	s := string(r)       // ERROR "slicerunetostring0 string\(r\) does not escape$"
+	r := []rune{1, 2, 3} // ERROR "\[\]rune literal does not escape$"
+	s := string(r)       // ERROR "string\(r\) does not escape$"
 	_ = s
 }
 
 func slicerunetostring1() string {
-	r := []rune{1, 2, 3} // ERROR "slicerunetostring1 \[\]rune literal does not escape$"
+	r := []rune{1, 2, 3} // ERROR "\[\]rune literal does not escape$"
 	return string(r)     // ERROR "string\(r\) escapes to heap$"
 }
 
 func slicerunetostring2() {
-	r := []rune{1, 2, 3} // ERROR "slicerunetostring2 \[\]rune literal does not escape$"
+	r := []rune{1, 2, 3} // ERROR "\[\]rune literal does not escape$"
 	sink = string(r)     // ERROR "string\(r\) escapes to heap$"
 }
 
 func makemap0() {
-	m := make(map[int]int) // ERROR "makemap0 make\(map\[int\]int\) does not escape$"
+	m := make(map[int]int) // ERROR "make\(map\[int\]int\) does not escape$"
 	m[0] = 0
 	m[1]++
 	delete(m, 1)
@@ -1792,12 +1792,12 @@ func makemap2() {
 	sink = m
 }
 
-func nonescapingEface(m map[interface{}]bool) bool { // ERROR "nonescapingEface m does not escape$"
-	return m["foo"] // ERROR "nonescapingEface .foo. does not escape$"
+func nonescapingEface(m map[interface{}]bool) bool { // ERROR "m does not escape$"
+	return m["foo"] // ERROR ".foo. does not escape$"
 }
 
-func nonescapingIface(m map[M]bool) bool { // ERROR "nonescapingIface m does not escape$"
-	return m[MV(0)] // ERROR "nonescapingIface MV\(0\) does not escape$"
+func nonescapingIface(m map[M]bool) bool { // ERROR "m does not escape$"
+	return m[MV(0)] // ERROR "MV\(0\) does not escape$"
 }
 
 func issue10353() {
diff --git a/test/escape_array.go b/test/escape_array.go
index d363b98eac..0d07fd861f 100644
--- a/test/escape_array.go
+++ b/test/escape_array.go
@@ -71,7 +71,7 @@ func fuo(x *U, y *U) *string { // ERROR "leaking param: x to result ~r2 level=1$
 // pointers stored in small array literals do not escape;
 // large array literals are heap allocated;
 // pointers stored in large array literals escape.
-func hugeLeaks1(x **string, y **string) { // ERROR "leaking param content: x" "hugeLeaks1 y does not escape"
+func hugeLeaks1(x **string, y **string) { // ERROR "leaking param content: x" "y does not escape"
 	a := [10]*string{*y}
 	_ = a
 	// 4 x 4,000,000 exceeds MaxStackVarSize, therefore it must be heap allocated if pointers are 4 bytes or larger.
@@ -79,7 +79,7 @@ func hugeLeaks1(x **string, y **string) { // ERROR "leaking param content: x" "h
 	_ = b
 }
 
-func hugeLeaks2(x *string, y *string) { // ERROR "leaking param: x" "hugeLeaks2 y does not escape"
+func hugeLeaks2(x *string, y *string) { // ERROR "leaking param: x" "y does not escape"
 	a := [10]*string{y}
 	_ = a
 	// 4 x 4,000,000 exceeds MaxStackVarSize, therefore it must be heap allocated if pointers are 4 bytes or larger.
diff --git a/test/escape_calls.go b/test/escape_calls.go
index 7b1862e014..2dbfee1558 100644
--- a/test/escape_calls.go
+++ b/test/escape_calls.go
@@ -44,7 +44,7 @@ func walk(np **Node) int { // ERROR "leaking param content: np"
 }
 
 // Test for bug where func var f used prototype's escape analysis results.
-func prototype(xyz []string) {} // ERROR "prototype xyz does not escape"
+func prototype(xyz []string) {} // ERROR "xyz does not escape"
 func bar() {
 	var got [][]string
 	f := prototype
diff --git a/test/escape_closure.go b/test/escape_closure.go
index f9f3c0fbd4..3b14027fa4 100644
--- a/test/escape_closure.go
+++ b/test/escape_closure.go
@@ -139,28 +139,28 @@ func ClosureCallArgs15() {
 	}(&p)
 }
 
-func ClosureLeak1(s string) string { // ERROR "ClosureLeak1 s does not escape"
+func ClosureLeak1(s string) string { // ERROR "s does not escape"
 	t := s + "YYYY"         // ERROR "escapes to heap"
-	return ClosureLeak1a(t) // ERROR "ClosureLeak1 ... argument does not escape"
+	return ClosureLeak1a(t) // ERROR "... argument does not escape"
 }
 
 // See #14409 -- returning part of captured var leaks it.
 func ClosureLeak1a(a ...string) string { // ERROR "leaking param: a to result ~r1 level=1$"
-	return func() string { // ERROR "ClosureLeak1a func literal does not escape"
+	return func() string { // ERROR "func literal does not escape"
 		return a[0]
 	}()
 }
 
-func ClosureLeak2(s string) string { // ERROR "ClosureLeak2 s does not escape"
+func ClosureLeak2(s string) string { // ERROR "s does not escape"
 	t := s + "YYYY"       // ERROR "escapes to heap"
-	c := ClosureLeak2a(t) // ERROR "ClosureLeak2 ... argument does not escape"
+	c := ClosureLeak2a(t) // ERROR "... argument does not escape"
 	return c
 }
 func ClosureLeak2a(a ...string) string { // ERROR "leaking param content: a"
-	return ClosureLeak2b(func() string { // ERROR "ClosureLeak2a func literal does not escape"
+	return ClosureLeak2b(func() string { // ERROR "func literal does not escape"
 		return a[0]
 	})
 }
-func ClosureLeak2b(f func() string) string { // ERROR "ClosureLeak2b f does not escape"
+func ClosureLeak2b(f func() string) string { // ERROR "f does not escape"
 	return f()
 }
diff --git a/test/escape_field.go b/test/escape_field.go
index 8bb1a99553..bf1dfb18ff 100644
--- a/test/escape_field.go
+++ b/test/escape_field.go
@@ -127,14 +127,14 @@ func field12() {
 
 func field13() {
 	i := 0          // ERROR "moved to heap: i$"
-	x := &X{p1: &i} // ERROR "field13 &X literal does not escape$"
+	x := &X{p1: &i} // ERROR "&X literal does not escape$"
 	sink = x.p1
 }
 
 func field14() {
 	i := 0 // ERROR "moved to heap: i$"
 	// BAD: &i should not escape
-	x := &X{p1: &i} // ERROR "field14 &X literal does not escape$"
+	x := &X{p1: &i} // ERROR "&X literal does not escape$"
 	sink = x.p2
 }
 
@@ -149,7 +149,7 @@ func field16() {
 	var x X
 	// BAD: &i should not escape
 	x.p1 = &i
-	var iface interface{} = x // ERROR "field16 x does not escape"
+	var iface interface{} = x // ERROR "x does not escape"
 	x1 := iface.(X)
 	sink = x1.p2
 }
@@ -158,7 +158,7 @@ func field17() {
 	i := 0 // ERROR "moved to heap: i$"
 	var x X
 	x.p1 = &i
-	var iface interface{} = x // ERROR "field17 x does not escape"
+	var iface interface{} = x // ERROR "x does not escape"
 	x1 := iface.(X)
 	sink = x1.p1
 }
@@ -168,7 +168,7 @@ func field18() {
 	var x X
 	// BAD: &i should not escape
 	x.p1 = &i
-	var iface interface{} = x // ERROR "field18 x does not escape"
+	var iface interface{} = x // ERROR "x does not escape"
 	y, _ := iface.(Y)         // Put X, but extracted Y. The cast will fail, so y is zero initialized.
 	sink = y                  // ERROR "y escapes to heap"
 }
diff --git a/test/escape_iface.go b/test/escape_iface.go
index be7b6024cd..898f504b31 100644
--- a/test/escape_iface.go
+++ b/test/escape_iface.go
@@ -110,7 +110,7 @@ func efaceEscape1() {
 	{
 		i := 0         // ERROR "moved to heap: i"
 		v := M1{&i, 0}
-		var x M = v // ERROR "efaceEscape1 v does not escape"
+		var x M = v // ERROR "v does not escape"
 		v1 := x.(M1)
 		sink = v1 // ERROR "v1 escapes to heap"
 	}
diff --git a/test/escape_indir.go b/test/escape_indir.go
index ccc8418d55..19889f259f 100644
--- a/test/escape_indir.go
+++ b/test/escape_indir.go
@@ -127,7 +127,7 @@ func constptr11() *ConstPtr {
 	return p
 }
 
-func foo(p **int) { // ERROR "foo p does not escape"
+func foo(p **int) { // ERROR "p does not escape"
 	i := 0 // ERROR "moved to heap: i"
 	y := p
 	*y = &i
diff --git a/test/escape_param.go b/test/escape_param.go
index 329d6d1c7f..5e81de9f46 100644
--- a/test/escape_param.go
+++ b/test/escape_param.go
@@ -42,7 +42,7 @@ func caller1() {
 }
 
 // in -> other in
-func param2(p1 *int, p2 **int) { // ERROR "leaking param: p1$" "param2 p2 does not escape$"
+func param2(p1 *int, p2 **int) { // ERROR "leaking param: p1$" "p2 does not escape$"
 	*p2 = p1
 }
 
@@ -137,7 +137,7 @@ type Pair struct {
 	p2 *int
 }
 
-func param3(p *Pair) { // ERROR "param3 p does not escape"
+func param3(p *Pair) { // ERROR "p does not escape"
 	p.p1 = p.p2 // ERROR "param3 ignoring self-assignment in p.p1 = p.p2"
 }
 
@@ -158,7 +158,7 @@ func caller3b() {
 }
 
 // in -> rcvr
-func (p *Pair) param4(i *int) { // ERROR "\(\*Pair\).param4 p does not escape$" "leaking param: i$"
+func (p *Pair) param4(i *int) { // ERROR "p does not escape$" "leaking param: i$"
 	p.p1 = i
 }
 
@@ -211,7 +211,7 @@ func caller7() {
 }
 
 // **in -> heap
-func param8(i **int) { // ERROR "param8 i does not escape$"
+func param8(i **int) { // ERROR "i does not escape$"
 	sink = **i // ERROR "\* \(\*i\) escapes to heap"
 }
 
@@ -294,7 +294,7 @@ type Indir struct {
 	p ***int
 }
 
-func (r *Indir) param12(i **int) { // ERROR "\(\*Indir\).param12 r does not escape$" "moved to heap: i$"
+func (r *Indir) param12(i **int) { // ERROR "r does not escape$" "moved to heap: i$"
 	r.p = &i
 }
 
@@ -309,7 +309,7 @@ func caller12a() {
 func caller12b() {
 	i := 0        // ERROR "moved to heap: i$"
 	p := &i       // ERROR "moved to heap: p$"
-	r := &Indir{} // ERROR "caller12b &Indir literal does not escape$"
+	r := &Indir{} // ERROR "&Indir literal does not escape$"
 	r.param12(&p)
 	_ = r
 }
@@ -335,7 +335,7 @@ type Val struct {
 	p **int
 }
 
-func (v Val) param13(i *int) { // ERROR "Val.param13 v does not escape$" "leaking param: i$"
+func (v Val) param13(i *int) { // ERROR "v does not escape$" "leaking param: i$"
 	*v.p = i
 }
 
@@ -359,7 +359,7 @@ func caller13b() {
 func caller13c() {
 	i := 0 // ERROR "moved to heap: i$"
 	var p *int
-	v := &Val{&p} // ERROR "caller13c &Val literal does not escape$"
+	v := &Val{&p} // ERROR "&Val literal does not escape$"
 	v.param13(&i)
 	_ = v
 }
@@ -400,7 +400,7 @@ func caller13g() {
 func caller13h() {
 	i := 0 // ERROR "moved to heap: i$"
 	var p *int
-	v := &Val{&p} // ERROR "caller13h &Val literal does not escape$"
+	v := &Val{&p} // ERROR "&Val literal does not escape$"
 	v.param13(&i)
 	sink = **v.p  // ERROR "\* \(\*v\.p\) escapes to heap"
 }
@@ -420,7 +420,7 @@ func g(x *Node) *Node { // ERROR "leaking param content: x"
 }
 
 func h(x *Node) { // ERROR "leaking param: x"
-	y := &Node{x} // ERROR "h &Node literal does not escape"
+	y := &Node{x} // ERROR "&Node literal does not escape"
 	Sink = g(y)
 	f(y)
 }
diff --git a/test/escape_struct_param1.go b/test/escape_struct_param1.go
index 7004946e2f..70b36191ab 100644
--- a/test/escape_struct_param1.go
+++ b/test/escape_struct_param1.go
@@ -38,7 +38,7 @@ func tSPPi() {
 	s := "cat"        // ERROR "moved to heap: s$"
 	ps := &s
 	pps := &ps
-	pu := &U{ps, pps} // ERROR "tSPPi &U literal does not escape$"
+	pu := &U{ps, pps} // ERROR "&U literal does not escape$"
 	Ssink = pu.SPPi()
 }
 
@@ -46,7 +46,7 @@ func tiSPP() {
 	s := "cat"        // ERROR "moved to heap: s$"
 	ps := &s
 	pps := &ps
-	pu := &U{ps, pps} // ERROR "tiSPP &U literal does not escape$"
+	pu := &U{ps, pps} // ERROR "&U literal does not escape$"
 	Ssink = *pu.SPP()
 }
 
@@ -55,7 +55,7 @@ func tSP() {
 	s := "cat"        // ERROR "moved to heap: s$"
 	ps := &s          // ERROR "moved to heap: ps$"
 	pps := &ps
-	pu := &U{ps, pps} // ERROR "tSP &U literal does not escape$"
+	pu := &U{ps, pps} // ERROR "&U literal does not escape$"
 	Ssink = pu.SP()
 }
 
@@ -123,9 +123,9 @@ func tUPiSPa() {
 	ps4 := &s4           // ERROR "moved to heap: ps4$"
 	ps6 := &s6           // ERROR "moved to heap: ps6$"
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPa &U literal does not escape$"
+	u2 := &U{&s3, &ps4}  // ERROR "&U literal does not escape$"
 	u3 := &U{&s5, &ps6}  // ERROR "&U literal escapes to heap$"
-	v := &V{u1, u2, &u3} // ERROR "tUPiSPa &V literal does not escape$"
+	v := &V{u1, u2, &u3} // ERROR "&V literal does not escape$"
 	Ssink = v.UPiSPa()   // Ssink = &s3 (only &s3 really escapes)
 }
 
@@ -141,9 +141,9 @@ func tUPiSPb() {
 	ps4 := &s4           // ERROR "moved to heap: ps4$"
 	ps6 := &s6           // ERROR "moved to heap: ps6$"
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPb &U literal does not escape$"
+	u2 := &U{&s3, &ps4}  // ERROR "&U literal does not escape$"
 	u3 := &U{&s5, &ps6}  // ERROR "&U literal escapes to heap$"
-	v := &V{u1, u2, &u3} // ERROR "tUPiSPb &V literal does not escape$"
+	v := &V{u1, u2, &u3} // ERROR "&V literal does not escape$"
 	Ssink = v.UPiSPb()   // Ssink = &s3 (only &s3 really escapes)
 }
 
@@ -159,9 +159,9 @@ func tUPiSPc() {
 	ps4 := &s4           // ERROR "moved to heap: ps4$"
 	ps6 := &s6           // ERROR "moved to heap: ps6$"
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPc &U literal does not escape$"
+	u2 := &U{&s3, &ps4}  // ERROR "&U literal does not escape$"
 	u3 := &U{&s5, &ps6}  // ERROR "&U literal escapes to heap$"
-	v := &V{u1, u2, &u3} // ERROR "tUPiSPc &V literal does not escape$"
+	v := &V{u1, u2, &u3} // ERROR "&V literal does not escape$"
 	Ssink = v.UPiSPc()   // Ssink = &s3 (only &s3 really escapes)
 }
 
@@ -177,9 +177,9 @@ func tUPiSPd() {
 	ps4 := &s4           // ERROR "moved to heap: ps4$"
 	ps6 := &s6           // ERROR "moved to heap: ps6$"
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPd &U literal does not escape$"
+	u2 := &U{&s3, &ps4}  // ERROR "&U literal does not escape$"
 	u3 := &U{&s5, &ps6}  // ERROR "&U literal escapes to heap$"
-	v := &V{u1, u2, &u3} // ERROR "tUPiSPd &V literal does not escape$"
+	v := &V{u1, u2, &u3} // ERROR "&V literal does not escape$"
 	Ssink = v.UPiSPd()   // Ssink = &s3 (only &s3 really escapes)
 }
 
@@ -211,9 +211,9 @@ func tUPiSPPia() {
 	ps4 := &s4
 	ps6 := &s6           // ERROR "moved to heap: ps6$"
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPPia &U literal does not escape$"
-	u3 := &U{&s5, &ps6}  // ERROR "tUPiSPPia &U literal does not escape$"
-	v := &V{u1, u2, &u3} // ERROR "tUPiSPPia &V literal does not escape$"
+	u2 := &U{&s3, &ps4}  // ERROR "&U literal does not escape$"
+	u3 := &U{&s5, &ps6}  // ERROR "&U literal does not escape$"
+	v := &V{u1, u2, &u3} // ERROR "&V literal does not escape$"
 	Ssink = v.UPiSPPia() // Ssink = *&ps4 = &s4 (only &s4 really escapes)
 }
 
@@ -229,9 +229,9 @@ func tUPiSPPib() {
 	ps4 := &s4
 	ps6 := &s6           // ERROR "moved to heap: ps6$"
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPPib &U literal does not escape$"
-	u3 := &U{&s5, &ps6}  // ERROR "tUPiSPPib &U literal does not escape$"
-	v := &V{u1, u2, &u3} // ERROR "tUPiSPPib &V literal does not escape$"
+	u2 := &U{&s3, &ps4}  // ERROR "&U literal does not escape$"
+	u3 := &U{&s5, &ps6}  // ERROR "&U literal does not escape$"
+	v := &V{u1, u2, &u3} // ERROR "&V literal does not escape$"
 	Ssink = v.UPiSPPib() // Ssink = *&ps4 = &s4 (only &s4 really escapes)
 }
 
@@ -247,9 +247,9 @@ func tUPiSPPic() {
 	ps4 := &s4
 	ps6 := &s6           // ERROR "moved to heap: ps6$"
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPPic &U literal does not escape$"
-	u3 := &U{&s5, &ps6}  // ERROR "tUPiSPPic &U literal does not escape$"
-	v := &V{u1, u2, &u3} // ERROR "tUPiSPPic &V literal does not escape$"
+	u2 := &U{&s3, &ps4}  // ERROR "&U literal does not escape$"
+	u3 := &U{&s5, &ps6}  // ERROR "&U literal does not escape$"
+	v := &V{u1, u2, &u3} // ERROR "&V literal does not escape$"
 	Ssink = v.UPiSPPic() // Ssink = *&ps4 = &s4 (only &s4 really escapes)
 }
 
@@ -265,9 +265,9 @@ func tUPiSPPid() {
 	ps4 := &s4
 	ps6 := &s6           // ERROR "moved to heap: ps6$"
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPPid &U literal does not escape$"
-	u3 := &U{&s5, &ps6}  // ERROR "tUPiSPPid &U literal does not escape$"
-	v := &V{u1, u2, &u3} // ERROR "tUPiSPPid &V literal does not escape$"
+	u2 := &U{&s3, &ps4}  // ERROR "&U literal does not escape$"
+	u3 := &U{&s5, &ps6}  // ERROR "&U literal does not escape$"
+	v := &V{u1, u2, &u3} // ERROR "&V literal does not escape$"
 	Ssink = v.UPiSPPid() // Ssink = *&ps4 = &s4 (only &s4 really escapes)
 }
 
@@ -291,8 +291,8 @@ func tUPPiSPPia() {
 	ps4 := &s4
 	ps6 := &s6
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}   // ERROR "tUPPiSPPia &U literal does not escape$"
-	u3 := &U{&s5, &ps6}   // ERROR "tUPPiSPPia &U literal does not escape$"
-	v := &V{u1, u2, &u3}  // ERROR "tUPPiSPPia &V literal does not escape$"
+	u2 := &U{&s3, &ps4}   // ERROR "&U literal does not escape$"
+	u3 := &U{&s5, &ps6}   // ERROR "&U literal does not escape$"
+	v := &V{u1, u2, &u3}  // ERROR "&V literal does not escape$"
 	Ssink = v.UPPiSPPia() // Ssink = *&ps6 = &s6 (only &s6 really escapes)
 }
diff --git a/test/escape_struct_param2.go b/test/escape_struct_param2.go
index 5a9b271958..e42be79793 100644
--- a/test/escape_struct_param2.go
+++ b/test/escape_struct_param2.go
@@ -38,7 +38,7 @@ func tSPPi() {
 	s := "cat"        // ERROR "moved to heap: s$"
 	ps := &s
 	pps := &ps
-	pu := &U{ps, pps} // ERROR "tSPPi &U literal does not escape$"
+	pu := &U{ps, pps} // ERROR "&U literal does not escape$"
 	Ssink = pu.SPPi()
 }
 
@@ -46,7 +46,7 @@ func tiSPP() {
 	s := "cat"        // ERROR "moved to heap: s$"
 	ps := &s
 	pps := &ps
-	pu := &U{ps, pps} // ERROR "tiSPP &U literal does not escape$"
+	pu := &U{ps, pps} // ERROR "&U literal does not escape$"
 	Ssink = *pu.SPP()
 }
 
@@ -55,7 +55,7 @@ func tSP() {
 	s := "cat"        // ERROR "moved to heap: s$"
 	ps := &s          // ERROR "moved to heap: ps$"
 	pps := &ps
-	pu := &U{ps, pps} // ERROR "tSP &U literal does not escape$"
+	pu := &U{ps, pps} // ERROR "&U literal does not escape$"
 	Ssink = pu.SP()
 }
 
@@ -123,9 +123,9 @@ func tUPiSPa() {
 	ps4 := &s4           // ERROR "moved to heap: ps4$"
 	ps6 := &s6           // ERROR "moved to heap: ps6$"
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPa &U literal does not escape$"
+	u2 := &U{&s3, &ps4}  // ERROR "&U literal does not escape$"
 	u3 := &U{&s5, &ps6}  // ERROR "&U literal escapes to heap$"
-	v := &V{u1, u2, &u3} // ERROR "tUPiSPa &V literal does not escape$"
+	v := &V{u1, u2, &u3} // ERROR "&V literal does not escape$"
 	Ssink = v.UPiSPa()   // Ssink = &s3 (only &s3 really escapes)
 }
 
@@ -141,9 +141,9 @@ func tUPiSPb() {
 	ps4 := &s4           // ERROR "moved to heap: ps4$"
 	ps6 := &s6           // ERROR "moved to heap: ps6$"
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPb &U literal does not escape$"
+	u2 := &U{&s3, &ps4}  // ERROR "&U literal does not escape$"
 	u3 := &U{&s5, &ps6}  // ERROR "&U literal escapes to heap$"
-	v := &V{u1, u2, &u3} // ERROR "tUPiSPb &V literal does not escape$"
+	v := &V{u1, u2, &u3} // ERROR "&V literal does not escape$"
 	Ssink = v.UPiSPb()   // Ssink = &s3 (only &s3 really escapes)
 }
 
@@ -159,9 +159,9 @@ func tUPiSPc() {
 	ps4 := &s4           // ERROR "moved to heap: ps4$"
 	ps6 := &s6           // ERROR "moved to heap: ps6$"
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPc &U literal does not escape$"
+	u2 := &U{&s3, &ps4}  // ERROR "&U literal does not escape$"
 	u3 := &U{&s5, &ps6}  // ERROR "&U literal escapes to heap$"
-	v := &V{u1, u2, &u3} // ERROR "tUPiSPc &V literal does not escape$"
+	v := &V{u1, u2, &u3} // ERROR "&V literal does not escape$"
 	Ssink = v.UPiSPc()   // Ssink = &s3 (only &s3 really escapes)
 }
 
@@ -177,9 +177,9 @@ func tUPiSPd() {
 	ps4 := &s4           // ERROR "moved to heap: ps4$"
 	ps6 := &s6           // ERROR "moved to heap: ps6$"
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPd &U literal does not escape$"
+	u2 := &U{&s3, &ps4}  // ERROR "&U literal does not escape$"
 	u3 := &U{&s5, &ps6}  // ERROR "&U literal escapes to heap$"
-	v := &V{u1, u2, &u3} // ERROR "tUPiSPd &V literal does not escape$"
+	v := &V{u1, u2, &u3} // ERROR "&V literal does not escape$"
 	Ssink = v.UPiSPd()   // Ssink = &s3 (only &s3 really escapes)
 }
 
@@ -211,9 +211,9 @@ func tUPiSPPia() {
 	ps4 := &s4
 	ps6 := &s6           // ERROR "moved to heap: ps6$"
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPPia &U literal does not escape$"
-	u3 := &U{&s5, &ps6}  // ERROR "tUPiSPPia &U literal does not escape$"
-	v := &V{u1, u2, &u3} // ERROR "tUPiSPPia &V literal does not escape$"
+	u2 := &U{&s3, &ps4}  // ERROR "&U literal does not escape$"
+	u3 := &U{&s5, &ps6}  // ERROR "&U literal does not escape$"
+	v := &V{u1, u2, &u3} // ERROR "&V literal does not escape$"
 	Ssink = v.UPiSPPia() // Ssink = *&ps4 = &s4 (only &s4 really escapes)
 }
 
@@ -229,9 +229,9 @@ func tUPiSPPib() {
 	ps4 := &s4
 	ps6 := &s6           // ERROR "moved to heap: ps6$"
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPPib &U literal does not escape$"
-	u3 := &U{&s5, &ps6}  // ERROR "tUPiSPPib &U literal does not escape$"
-	v := &V{u1, u2, &u3} // ERROR "tUPiSPPib &V literal does not escape$"
+	u2 := &U{&s3, &ps4}  // ERROR "&U literal does not escape$"
+	u3 := &U{&s5, &ps6}  // ERROR "&U literal does not escape$"
+	v := &V{u1, u2, &u3} // ERROR "&V literal does not escape$"
 	Ssink = v.UPiSPPib() // Ssink = *&ps4 = &s4 (only &s4 really escapes)
 }
 
@@ -247,9 +247,9 @@ func tUPiSPPic() {
 	ps4 := &s4
 	ps6 := &s6           // ERROR "moved to heap: ps6$"
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPPic &U literal does not escape$"
-	u3 := &U{&s5, &ps6}  // ERROR "tUPiSPPic &U literal does not escape$"
-	v := &V{u1, u2, &u3} // ERROR "tUPiSPPic &V literal does not escape$"
+	u2 := &U{&s3, &ps4}  // ERROR "&U literal does not escape$"
+	u3 := &U{&s5, &ps6}  // ERROR "&U literal does not escape$"
+	v := &V{u1, u2, &u3} // ERROR "&V literal does not escape$"
 	Ssink = v.UPiSPPic() // Ssink = *&ps4 = &s4 (only &s4 really escapes)
 }
 
@@ -265,9 +265,9 @@ func tUPiSPPid() {
 	ps4 := &s4
 	ps6 := &s6           // ERROR "moved to heap: ps6$"
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPPid &U literal does not escape$"
-	u3 := &U{&s5, &ps6}  // ERROR "tUPiSPPid &U literal does not escape$"
-	v := &V{u1, u2, &u3} // ERROR "tUPiSPPid &V literal does not escape$"
+	u2 := &U{&s3, &ps4}  // ERROR "&U literal does not escape$"
+	u3 := &U{&s5, &ps6}  // ERROR "&U literal does not escape$"
+	v := &V{u1, u2, &u3} // ERROR "&V literal does not escape$"
 	Ssink = v.UPiSPPid() // Ssink = *&ps4 = &s4 (only &s4 really escapes)
 }
 
@@ -291,8 +291,8 @@ func tUPPiSPPia() { // This test is sensitive to the level cap in function summa
 	ps4 := &s4
 	ps6 := &s6
 	u1 := U{&s1, &ps2}
-	u2 := &U{&s3, &ps4}   // ERROR "tUPPiSPPia &U literal does not escape$"
-	u3 := &U{&s5, &ps6}   // ERROR "tUPPiSPPia &U literal does not escape$"
-	v := &V{u1, u2, &u3}  // ERROR "tUPPiSPPia &V literal does not escape$"
+	u2 := &U{&s3, &ps4}   // ERROR "&U literal does not escape$"
+	u3 := &U{&s5, &ps6}   // ERROR "&U literal does not escape$"
+	v := &V{u1, u2, &u3}  // ERROR "&V literal does not escape$"
 	Ssink = v.UPPiSPPia() // Ssink = *&ps6 = &s6 (only &s6 really escapes)
 }
diff --git a/test/fixedbugs/issue12006.go b/test/fixedbugs/issue12006.go
index 60396c93ce..c44f2e5547 100644
--- a/test/fixedbugs/issue12006.go
+++ b/test/fixedbugs/issue12006.go
@@ -8,7 +8,7 @@
 
 package foo
 
-func FooN(vals ...*int) (s int) { // ERROR "FooN vals does not escape"
+func FooN(vals ...*int) (s int) { // ERROR "vals does not escape"
 	for _, v := range vals {
 		s += *v
 	}
@@ -37,14 +37,14 @@ func FooNz(vals ...*int) (s int) { // ERROR "leaking param: vals"
 func TFooN() {
 	for i := 0; i < 1000; i++ {
 		var i, j int
-		FooN(&i, &j) // ERROR "TFooN ... argument does not escape"
+		FooN(&i, &j) // ERROR "... argument does not escape"
 	}
 }
 
 func TFooNx() {
 	for i := 0; i < 1000; i++ {
 		var i, j, k int   // ERROR "moved to heap: i" "moved to heap: j" "moved to heap: k"
-		FooNx(&k, &i, &j) // ERROR "TFooNx ... argument does not escape"
+		FooNx(&k, &i, &j) // ERROR "... argument does not escape"
 	}
 }
 
@@ -84,7 +84,7 @@ func TFooI() {
 	a := int32(1) // ERROR "moved to heap: a"
 	b := "cat"
 	c := &a
-	FooI(a, b, c) // ERROR "a escapes to heap" "b escapes to heap" "TFooI ... argument does not escape"
+	FooI(a, b, c) // ERROR "a escapes to heap" "b escapes to heap" "... argument does not escape"
 }
 
 func FooJ(args ...interface{}) *int32 { // ERROR "leaking param: args to result ~r1 level=1"
@@ -108,14 +108,14 @@ func TFooJ1() {
 	a := int32(1)
 	b := "cat"
 	c := &a
-	FooJ(a, b, c) // ERROR "TFooJ1 a does not escape" "TFooJ1 b does not escape" "TFooJ1 ... argument does not escape"
+	FooJ(a, b, c) // ERROR "a does not escape" "b does not escape" "... argument does not escape"
 }
 
 func TFooJ2() {
 	a := int32(1) // ERROR "moved to heap: a"
 	b := "cat"
 	c := &a
-	isink = FooJ(a, b, c) // ERROR "a escapes to heap" "b escapes to heap" "TFooJ2 ... argument does not escape"
+	isink = FooJ(a, b, c) // ERROR "a escapes to heap" "b escapes to heap" "... argument does not escape"
 }
 
 type fakeSlice struct {
@@ -144,7 +144,7 @@ func TFooK2() {
 	a := int32(1) // ERROR "moved to heap: a"
 	b := "cat"
 	c := &a
-	fs := fakeSlice{3, &[4]interface{}{a, b, c, nil}} // ERROR "a escapes to heap" "b escapes to heap" "TFooK2 &\[4\]interface {} literal does not escape"
+	fs := fakeSlice{3, &[4]interface{}{a, b, c, nil}} // ERROR "a escapes to heap" "b escapes to heap" "&\[4\]interface {} literal does not escape"
 	isink = FooK(fs)
 }
 
@@ -169,6 +169,6 @@ func TFooL2() {
 	a := int32(1) // ERROR "moved to heap: a"
 	b := "cat"
 	c := &a
-	s := []interface{}{a, b, c} // ERROR "a escapes to heap" "b escapes to heap" "TFooL2 \[\]interface {} literal does not escape"
+	s := []interface{}{a, b, c} // ERROR "a escapes to heap" "b escapes to heap" "\[\]interface {} literal does not escape"
 	isink = FooL(s)
 }
diff --git a/test/fixedbugs/issue12588.go b/test/fixedbugs/issue12588.go
index f99807b98b..950ef36e20 100644
--- a/test/fixedbugs/issue12588.go
+++ b/test/fixedbugs/issue12588.go
@@ -26,7 +26,7 @@ func f(a A) int {
 	return 0
 }
 
-func g(a *A) int { // ERROR "g a does not escape"
+func g(a *A) int { // ERROR "a does not escape"
 	for i, x := range &a.b {
 		if x != 0 {
 			return 64*i + int(x)
diff --git a/test/fixedbugs/issue13799.go b/test/fixedbugs/issue13799.go
index b9bf49ca42..5c57494777 100644
--- a/test/fixedbugs/issue13799.go
+++ b/test/fixedbugs/issue13799.go
@@ -20,7 +20,7 @@ func main() {
 	// (sometimes it takes 1 time, sometimes it takes ~4,000+).
 	for iter := 0; ; iter++ {
 		if iter%50 == 0 {
-			fmt.Println(iter) // ERROR "iter escapes to heap$" "main ... argument does not escape$"
+			fmt.Println(iter) // ERROR "iter escapes to heap$" "... argument does not escape$"
 		}
 		test1(iter)
 		test2(iter)
@@ -60,20 +60,20 @@ func test1(iter int) {
 	}
 
 	if len(m) != maxI {
-		panic(fmt.Sprintf("iter %d: maxI = %d, len(m) = %d", iter, maxI, len(m))) // ERROR "iter escapes to heap$" "len\(m\) escapes to heap$" "maxI escapes to heap$" "test1 ... argument does not escape$"
+		panic(fmt.Sprintf("iter %d: maxI = %d, len(m) = %d", iter, maxI, len(m))) // ERROR "iter escapes to heap$" "len\(m\) escapes to heap$" "maxI escapes to heap$" "... argument does not escape$"
 	}
 }
 
 func test2(iter int) {
 
 	const maxI = 500
-	m := make(map[int][]int) // ERROR "test2 make\(map\[int\]\[\]int\) does not escape$"
+	m := make(map[int][]int) // ERROR "make\(map\[int\]\[\]int\) does not escape$"
 
 	// var fn func()
 	for i := 0; i < maxI; i++ {
 		var fn func() // this makes it work, because fn stays off heap
 		j := 0
-		fn = func() { // ERROR "test2 func literal does not escape$"
+		fn = func() { // ERROR "func literal does not escape$"
 			m[i] = append(m[i], 0)
 			if j < 25 {
 				j++
@@ -84,7 +84,7 @@ func test2(iter int) {
 	}
 
 	if len(m) != maxI {
-		panic(fmt.Sprintf("iter %d: maxI = %d, len(m) = %d", iter, maxI, len(m))) // ERROR "iter escapes to heap$" "len\(m\) escapes to heap$" "maxI escapes to heap$" "test2 ... argument does not escape$"
+		panic(fmt.Sprintf("iter %d: maxI = %d, len(m) = %d", iter, maxI, len(m))) // ERROR "iter escapes to heap$" "len\(m\) escapes to heap$" "maxI escapes to heap$" "... argument does not escape$"
 	}
 }
 
@@ -110,7 +110,7 @@ func test3(iter int) {
 	}
 
 	if *m != maxI {
-		panic(fmt.Sprintf("iter %d: maxI = %d, *m = %d", iter, maxI, *m)) // ERROR "\*m escapes to heap$" "iter escapes to heap$" "maxI escapes to heap$" "test3 ... argument does not escape$"
+		panic(fmt.Sprintf("iter %d: maxI = %d, *m = %d", iter, maxI, *m)) // ERROR "\*m escapes to heap$" "iter escapes to heap$" "maxI escapes to heap$" "... argument does not escape$"
 	}
 }
 
@@ -124,7 +124,7 @@ func test4(iter int) {
 	for i := 0; i < maxI; i++ {
 		var fn func() // this makes it work, because fn stays off heap
 		j := 0
-		fn = func() { // ERROR "test4 func literal does not escape$"
+		fn = func() { // ERROR "func literal does not escape$"
 			if j < 100 {
 				j++
 				fn()
@@ -136,7 +136,7 @@ func test4(iter int) {
 	}
 
 	if *m != maxI {
-		panic(fmt.Sprintf("iter %d: maxI = %d, *m = %d", iter, maxI, *m)) // ERROR "\*m escapes to heap$" "iter escapes to heap$" "maxI escapes to heap$" "test4 ... argument does not escape$"
+		panic(fmt.Sprintf("iter %d: maxI = %d, *m = %d", iter, maxI, *m)) // ERROR "\*m escapes to heap$" "iter escapes to heap$" "maxI escapes to heap$" "... argument does not escape$"
 	}
 }
 
@@ -144,7 +144,7 @@ type str struct {
 	m *int
 }
 
-func recur1(j int, s *str) { // ERROR "recur1 s does not escape"
+func recur1(j int, s *str) { // ERROR "s does not escape"
 	if j < 100 {
 		j++
 		recur1(j, s)
@@ -167,7 +167,7 @@ func test5(iter int) {
 	}
 
 	if *m != maxI {
-		panic(fmt.Sprintf("iter %d: maxI = %d, *m = %d", iter, maxI, *m)) // ERROR "\*m escapes to heap$" "iter escapes to heap$" "maxI escapes to heap$" "test5 ... argument does not escape$"
+		panic(fmt.Sprintf("iter %d: maxI = %d, *m = %d", iter, maxI, *m)) // ERROR "\*m escapes to heap$" "iter escapes to heap$" "maxI escapes to heap$" "... argument does not escape$"
 	}
 }
 
@@ -185,6 +185,6 @@ func test6(iter int) {
 	}
 
 	if *m != maxI {
-		panic(fmt.Sprintf("iter %d: maxI = %d, *m = %d", iter, maxI, *m)) // ERROR "\*m escapes to heap$" "iter escapes to heap$" "maxI escapes to heap$" "test6 ... argument does not escape$"
+		panic(fmt.Sprintf("iter %d: maxI = %d, *m = %d", iter, maxI, *m)) // ERROR "\*m escapes to heap$" "iter escapes to heap$" "maxI escapes to heap$" "... argument does not escape$"
 	}
 }
diff --git a/test/fixedbugs/issue17318.go b/test/fixedbugs/issue17318.go
index 6932d04d25..21df729f09 100644
--- a/test/fixedbugs/issue17318.go
+++ b/test/fixedbugs/issue17318.go
@@ -22,12 +22,12 @@ type closure func(i, j int) ent
 type ent int
 
 func (e ent) String() string {
-	return fmt.Sprintf("%d", int(e)) // ERROR "ent.String ... argument does not escape$" "int\(e\) escapes to heap$"
+	return fmt.Sprintf("%d", int(e)) // ERROR "... argument does not escape$" "int\(e\) escapes to heap$"
 }
 
 //go:noinline
-func foo(ops closure, j int) (err fmt.Stringer) { // ERROR "foo ops does not escape"
-	enqueue := func(i int) fmt.Stringer { // ERROR "foo func literal does not escape"
+func foo(ops closure, j int) (err fmt.Stringer) { // ERROR "ops does not escape"
+	enqueue := func(i int) fmt.Stringer { // ERROR "func literal does not escape"
 		return ops(i, j) // ERROR "ops\(i, j\) escapes to heap$"
 	}
 	err = enqueue(4)
@@ -39,9 +39,9 @@ func foo(ops closure, j int) (err fmt.Stringer) { // ERROR "foo ops does not esc
 
 func main() {
 	// 3 identical functions, to get different escape behavior.
-	f := func(i, j int) ent { // ERROR "main func literal does not escape"
+	f := func(i, j int) ent { // ERROR "func literal does not escape"
 		return ent(i + j)
 	}
 	i := foo(f, 3).(ent)
-	fmt.Printf("foo(f,3)=%d\n", int(i)) // ERROR "int\(i\) escapes to heap$" "main ... argument does not escape$"
+	fmt.Printf("foo(f,3)=%d\n", int(i)) // ERROR "int\(i\) escapes to heap$" "... argument does not escape$"
 }
diff --git a/test/fixedbugs/issue21709.go b/test/fixedbugs/issue21709.go
index 6e7f1d5ba6..10f5660e1b 100644
--- a/test/fixedbugs/issue21709.go
+++ b/test/fixedbugs/issue21709.go
@@ -10,14 +10,14 @@ package p
 
 type S struct{}
 
-func (s *S) Inc() {} // ERROR "\(\*S\).Inc s does not escape"
+func (s *S) Inc() {} // ERROR "s does not escape"
 var N int
 
 func F1() {
 	var s S // ERROR "moved to heap: s"
 	for i := 0; i < N; i++ {
-		fs := []func(){ // ERROR "F1 \[\]func\(\) literal does not escape"
-			s.Inc, // ERROR "F1 s.Inc does not escape"
+		fs := []func(){ // ERROR "\[\]func\(\) literal does not escape"
+			s.Inc, // ERROR "s.Inc does not escape"
 		}
 		for _, f := range fs {
 			f()
@@ -28,8 +28,8 @@ func F1() {
 func F2() {
 	var s S // ERROR "moved to heap: s"
 	for i := 0; i < N; i++ {
-		for _, f := range []func(){ // ERROR "F2 \[\]func\(\) literal does not escape"
-			s.Inc, // ERROR "F2 s.Inc does not escape"
+		for _, f := range []func(){ // ERROR "\[\]func\(\) literal does not escape"
+			s.Inc, // ERROR "s.Inc does not escape"
 		} {
 			f()
 		}
diff --git a/test/fixedbugs/issue7921.go b/test/fixedbugs/issue7921.go
index e19b113062..a8efc8dd9e 100644
--- a/test/fixedbugs/issue7921.go
+++ b/test/fixedbugs/issue7921.go
@@ -18,20 +18,20 @@ func bufferNotEscape() string {
 	// can be stack-allocated.
 	var b bytes.Buffer
 	b.WriteString("123")
-	b.Write([]byte{'4'}) // ERROR "bufferNotEscape \[\]byte literal does not escape$"
+	b.Write([]byte{'4'}) // ERROR "\[\]byte literal does not escape$"
 	return b.String()    // ERROR "inlining call to bytes.\(\*Buffer\).String$" "string\(bytes.b.buf\[bytes.b.off:\]\) escapes to heap$"
 }
 
-func bufferNoEscape2(xs []string) int { // ERROR "bufferNoEscape2 xs does not escape$"
-	b := bytes.NewBuffer(make([]byte, 0, 64)) // ERROR "bufferNoEscape2 &bytes.Buffer literal does not escape$" "bufferNoEscape2 make\(\[\]byte, 0, 64\) does not escape$" "inlining call to bytes.NewBuffer$"
+func bufferNoEscape2(xs []string) int { // ERROR "xs does not escape$"
+	b := bytes.NewBuffer(make([]byte, 0, 64)) // ERROR "&bytes.Buffer literal does not escape$" "make\(\[\]byte, 0, 64\) does not escape$" "inlining call to bytes.NewBuffer$"
 	for _, x := range xs {
 		b.WriteString(x)
 	}
 	return b.Len() // ERROR "inlining call to bytes.\(\*Buffer\).Len$"
 }
 
-func bufferNoEscape3(xs []string) string { // ERROR "bufferNoEscape3 xs does not escape$"
-	b := bytes.NewBuffer(make([]byte, 0, 64)) // ERROR "bufferNoEscape3 &bytes.Buffer literal does not escape$" "bufferNoEscape3 make\(\[\]byte, 0, 64\) does not escape$" "inlining call to bytes.NewBuffer$"
+func bufferNoEscape3(xs []string) string { // ERROR "xs does not escape$"
+	b := bytes.NewBuffer(make([]byte, 0, 64)) // ERROR "&bytes.Buffer literal does not escape$" "make\(\[\]byte, 0, 64\) does not escape$" "inlining call to bytes.NewBuffer$"
 	for _, x := range xs {
 		b.WriteString(x)
 		b.WriteByte(',')
@@ -47,11 +47,11 @@ func bufferNoEscape4() []byte {
 }
 
 func bufferNoEscape5() { // ERROR "can inline bufferNoEscape5$"
-	b := bytes.NewBuffer(make([]byte, 0, 128)) // ERROR "bufferNoEscape5 &bytes.Buffer literal does not escape$" "bufferNoEscape5 make\(\[\]byte, 0, 128\) does not escape$" "inlining call to bytes.NewBuffer$"
+	b := bytes.NewBuffer(make([]byte, 0, 128)) // ERROR "&bytes.Buffer literal does not escape$" "make\(\[\]byte, 0, 128\) does not escape$" "inlining call to bytes.NewBuffer$"
 	useBuffer(b)
 }
 
 //go:noinline
-func useBuffer(b *bytes.Buffer) { // ERROR "useBuffer b does not escape$"
+func useBuffer(b *bytes.Buffer) { // ERROR "b does not escape$"
 	b.WriteString("1234")
 }
diff --git a/test/inline.go b/test/inline.go
index 7e0551708e..8ebffedfb7 100644
--- a/test/inline.go
+++ b/test/inline.go
@@ -95,15 +95,15 @@ func p() int {
 }
 
 func q(x int) int {
-	foo := func() int { return x * 2 } // ERROR "can inline q.func1" "q func literal does not escape"
+	foo := func() int { return x * 2 } // ERROR "can inline q.func1" "func literal does not escape"
 	return foo()                       // ERROR "inlining call to q.func1"
 }
 
 func r(z int) int {
-	foo := func(x int) int { // ERROR "can inline r.func1" "r func literal does not escape"
+	foo := func(x int) int { // ERROR "can inline r.func1" "func literal does not escape"
 		return x + z
 	}
-	bar := func(x int) int { // ERROR "r func literal does not escape"
+	bar := func(x int) int { // ERROR "func literal does not escape"
 		return x + func(y int) int { // ERROR "can inline r.func2.1"
 			return 2*y + x*z
 		}(x) // ERROR "inlining call to r.func2.1"
@@ -112,7 +112,7 @@ func r(z int) int {
 }
 
 func s0(x int) int {
-	foo := func() { // ERROR "can inline s0.func1" "s0 func literal does not escape"
+	foo := func() { // ERROR "can inline s0.func1" "func literal does not escape"
 		x = x + 1
 	}
 	foo() // ERROR "inlining call to s0.func1"
@@ -120,7 +120,7 @@ func s0(x int) int {
 }
 
 func s1(x int) int {
-	foo := func() int { // ERROR "can inline s1.func1" "s1 func literal does not escape"
+	foo := func() int { // ERROR "can inline s1.func1" "func literal does not escape"
 		return x
 	}
 	x = x + 1
@@ -145,7 +145,7 @@ func switchBreak(x, y int) int {
 }
 
 // can't currently inline functions with a type switch
-func switchType(x interface{}) int { // ERROR "switchType x does not escape"
+func switchType(x interface{}) int { // ERROR "x does not escape"
 	switch x.(type) {
 	case int:
 		return x.(int)
diff --git a/test/inline_big.go b/test/inline_big.go
index c4af15b4e1..b72ceb7f42 100644
--- a/test/inline_big.go
+++ b/test/inline_big.go
@@ -9,18 +9,18 @@
 
 package foo
 
-func small(a []int) int { // ERROR "can inline small as:.*" "small a does not escape"
+func small(a []int) int { // ERROR "can inline small as:.*" "a does not escape"
 	// Cost 16 body (need cost < 20).
 	// See cmd/compile/internal/gc/inl.go:inlineBigFunction*
 	return a[0] + a[1] + a[2] + a[3]
 }
-func medium(a []int) int { // ERROR "can inline medium as:.*" "medium a does not escape"
+func medium(a []int) int { // ERROR "can inline medium as:.*" "a does not escape"
 	// Cost 32 body (need cost > 20 and cost < 80).
 	// See cmd/compile/internal/gc/inl.go:inlineBigFunction*
 	return a[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7]
 }
 
-func f(a []int) int { // ERROR "cannot inline f:.*" "f a does not escape"
+func f(a []int) int { // ERROR "cannot inline f:.*" "a does not escape"
 	// Add lots of nodes to f's body. We need >5000.
 	// See cmd/compile/internal/gc/inl.go:inlineBigFunction*
 	a[0] = 0
diff --git a/test/linkname.dir/linkname1.go b/test/linkname.dir/linkname1.go
index 9c61522fcc..c61a0d7d95 100644
--- a/test/linkname.dir/linkname1.go
+++ b/test/linkname.dir/linkname1.go
@@ -1,6 +1,6 @@
 package x
 
-func indexByte(xs []byte, b byte) int { // ERROR "indexByte xs does not escape"
+func indexByte(xs []byte, b byte) int { // ERROR "xs does not escape"
 	for i, x := range xs {
 		if x == b {
 			return i
diff --git a/test/live_syscall.go b/test/live_syscall.go
index 2d1ef14de7..b920ff68aa 100644
--- a/test/live_syscall.go
+++ b/test/live_syscall.go
@@ -15,7 +15,7 @@ import (
 	"unsafe"
 )
 
-func f(uintptr) // ERROR "f assuming arg#1 is unsafe uintptr"
+func f(uintptr) // ERROR "assuming arg#1 is unsafe uintptr"
 
 func g() { // ERROR "can inline g"
 	var t int
