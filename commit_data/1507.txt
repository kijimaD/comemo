commit ed2ac9b8b0a6721598ffbd8f8e53aed5b129f48c
Author: Rob Pike <r@golang.org>
Date:   Fri Jan 16 12:48:07 2009 -0800

    casify reflect.
    
    R=rsc
    DELTA=513  (0 added, 2 deleted, 511 changed)
    OCL=22954
    CL=22956
---
 src/lib/reflect/all_test.go |  10 +-
 src/lib/reflect/tostring.go |  20 +--
 src/lib/reflect/type.go     | 338 +++++++++++++++++++++---------------------
 src/lib/reflect/value.go    | 348 ++++++++++++++++++++++----------------------
 4 files changed, 357 insertions(+), 359 deletions(-)

diff --git a/src/lib/reflect/all_test.go b/src/lib/reflect/all_test.go
index 38e2589fe8..4ad8abd74e 100644
--- a/src/lib/reflect/all_test.go
+++ b/src/lib/reflect/all_test.go
@@ -87,8 +87,6 @@ func valuedump(s, t string) {
 	assert(reflect.ValueToString(v), t);
 }
 
-export type empty interface {}
-
 export type T struct { a int; b float64; c string; d *int }
 
 export func TestAll(tt *testing.T) {	// TODO(r): wrap up better
@@ -342,14 +340,14 @@ export func TestBigUnnamedStruct(t *testing.T) {
 	}
 }
 
-type Big struct {
+type big struct {
 	a, b, c, d, e int64
 }
 export func TestBigStruct(t *testing.T) {
-	b := Big{1, 2, 3, 4, 5};
+	b := big{1, 2, 3, 4, 5};
 	v := NewValue(b);
-	b1 := v.Interface().(Big);
+	b1 := v.Interface().(big);
 	if b1.a != b.a || b1.b != b.b || b1.c != b.c || b1.d != b.d || b1.e != b.e {
-		t.Errorf("NewValue(%v).Interface().(Big) = %v", b, b1);
+		t.Errorf("NewValue(%v).Interface().(big) = %v", b, b1);
 	}
 }
diff --git a/src/lib/reflect/tostring.go b/src/lib/reflect/tostring.go
index 51d8863103..d451e552fe 100644
--- a/src/lib/reflect/tostring.go
+++ b/src/lib/reflect/tostring.go
@@ -15,7 +15,7 @@ import (
 export func TypeToString(typ Type, expand bool) string
 export func ValueToString(val Value) string
 
-func DoubleQuote(s string) string {
+func doubleQuote(s string) string {
 	out := "\"";
 	for i := 0; i < len(s); i++ {
 		c := s[i];
@@ -38,12 +38,12 @@ func DoubleQuote(s string) string {
 	return out;
 }
 
-type HasFields interface {
+type hasFields interface {
 	Field(i int)	(name string, typ Type, tag string, offset int);
 	Len()	int;
 }
 
-func TypeFieldsToString(t HasFields, sep string) string {
+func typeFieldsToString(t hasFields, sep string) string {
 	var str string;
 	for i := 0; i < t.Len(); i++ {
 		str1, typ, tag, offset := t.Field(i);
@@ -52,7 +52,7 @@ func TypeFieldsToString(t HasFields, sep string) string {
 		}
 		str1 += TypeToString(typ, false);
 		if tag != "" {
-			str1 += " " + DoubleQuote(tag);
+			str1 += " " + doubleQuote(tag);
 		}
 		if i < t.Len() - 1 {
 			str1 += sep + " ";
@@ -62,7 +62,7 @@ func TypeFieldsToString(t HasFields, sep string) string {
 	return str;
 }
 
-func TypeToString(typ Type, expand bool) string {
+export func TypeToString(typ Type, expand bool) string {
 	var str string;
 	if name := typ.Name(); !expand && name != "" {
 		return name
@@ -105,14 +105,14 @@ func TypeToString(typ Type, expand bool) string {
 		}
 		return str + TypeToString(c.Elem(), false);
 	case StructKind:
-		return "struct{" + TypeFieldsToString(typ, ";") + "}";
+		return "struct{" + typeFieldsToString(typ, ";") + "}";
 	case InterfaceKind:
-		return "interface{" + TypeFieldsToString(typ, ";") + "}";
+		return "interface{" + typeFieldsToString(typ, ";") + "}";
 	case FuncKind:
 		f := typ.(FuncType);
-		str = "(" + TypeFieldsToString(f.In(), ",") + ")";
+		str = "(" + typeFieldsToString(f.In(), ",") + ")";
 		if f.Out() != nil {
-			str += "(" + TypeFieldsToString(f.Out(), ",") + ")";
+			str += "(" + typeFieldsToString(f.Out(), ",") + ")";
 		}
 		return str;
 	default:
@@ -126,7 +126,7 @@ func integer(v int64) string {
 	return strconv.Itoa64(v);
 }
 
-func ValueToString(val Value) string {
+export func ValueToString(val Value) string {
 	var str string;
 	typ := val.Type();
 	switch(val.Kind()) {
diff --git a/src/lib/reflect/type.go b/src/lib/reflect/type.go
index ac8b0fc4d4..87751547e4 100644
--- a/src/lib/reflect/type.go
+++ b/src/lib/reflect/type.go
@@ -48,8 +48,8 @@ export const (
 var ptrsize int
 var interfacesize int
 
-var MissingString = "$missing$"	// syntactic name for undefined type names
-var DotDotDotString = "..."
+var missingString = "$missing$"	// syntactic name for undefined type names
+var dotDotDotString = "..."
 
 export type Type interface {
 	Kind()	int;
@@ -90,50 +90,50 @@ func (c *commonType) Size() int {
 
 // -- Basic
 
-type BasicType struct {
+type basicType struct {
 	commonType
 }
 
-func NewBasicType(name string, kind int, size int) Type {
-	return &BasicType{ commonType{kind, name, name, size} }
+func newBasicType(name string, kind int, size int) Type {
+	return &basicType{ commonType{kind, name, name, size} }
 }
 
 // Prebuilt basic types
 export var (
-	Missing = NewBasicType(MissingString, MissingKind, 1);
-	DotDotDot = NewBasicType(DotDotDotString, DotDotDotKind, 16);	// TODO(r): size of interface?
-	Bool = NewBasicType("bool", BoolKind, 1); // TODO: need to know how big a bool is
-	Int = NewBasicType("int", IntKind, 4);	// TODO: need to know how big an int is
-	Int8 = NewBasicType("int8", Int8Kind, 1);
-	Int16 = NewBasicType("int16", Int16Kind, 2);
-	Int32 = NewBasicType("int32", Int32Kind, 4);
-	Int64 = NewBasicType("int64", Int64Kind, 8);
-	Uint = NewBasicType("uint", UintKind, 4);	// TODO: need to know how big a uint is
-	Uint8 = NewBasicType("uint8", Uint8Kind, 1);
-	Uint16 = NewBasicType("uint16", Uint16Kind, 2);
-	Uint32 = NewBasicType("uint32", Uint32Kind, 4);
-	Uint64 = NewBasicType("uint64", Uint64Kind, 8);
-	Uintptr = NewBasicType("uintptr", UintptrKind, 8);	// TODO: need to know how big a uintptr is
-	Float = NewBasicType("float", FloatKind, 4);	// TODO: need to know how big a float is
-	Float32 = NewBasicType("float32", Float32Kind, 4);
-	Float64 = NewBasicType("float64", Float64Kind, 8);
-	Float80 = NewBasicType("float80", Float80Kind, 10);	// TODO: strange size?
-	String = NewBasicType("string", StringKind, 8);	// implemented as a pointer
+	Missing = newBasicType(missingString, MissingKind, 1);
+	DotDotDot = newBasicType(dotDotDotString, DotDotDotKind, 16);	// TODO(r): size of interface?
+	Bool = newBasicType("bool", BoolKind, 1); // TODO: need to know how big a bool is
+	Int = newBasicType("int", IntKind, 4);	// TODO: need to know how big an int is
+	Int8 = newBasicType("int8", Int8Kind, 1);
+	Int16 = newBasicType("int16", Int16Kind, 2);
+	Int32 = newBasicType("int32", Int32Kind, 4);
+	Int64 = newBasicType("int64", Int64Kind, 8);
+	Uint = newBasicType("uint", UintKind, 4);	// TODO: need to know how big a uint is
+	Uint8 = newBasicType("uint8", Uint8Kind, 1);
+	Uint16 = newBasicType("uint16", Uint16Kind, 2);
+	Uint32 = newBasicType("uint32", Uint32Kind, 4);
+	Uint64 = newBasicType("uint64", Uint64Kind, 8);
+	Uintptr = newBasicType("uintptr", UintptrKind, 8);	// TODO: need to know how big a uintptr is
+	Float = newBasicType("float", FloatKind, 4);	// TODO: need to know how big a float is
+	Float32 = newBasicType("float32", Float32Kind, 4);
+	Float64 = newBasicType("float64", Float64Kind, 8);
+	Float80 = newBasicType("float80", Float80Kind, 10);	// TODO: strange size?
+	String = newBasicType("string", StringKind, 8);	// implemented as a pointer
 )
 
 // Stub types allow us to defer evaluating type names until needed.
 // If the name is empty, the type must be non-nil.
 
-type StubType struct {
+type stubType struct {
 	name	string;
 	typ		Type;
 }
 
-func NewStubType(name string, typ Type) *StubType {
-	return &StubType{name, typ}
+func newStubType(name string, typ Type) *stubType {
+	return &stubType{name, typ}
 }
 
-func (t *StubType) Get() Type {
+func (t *stubType) Get() Type {
 	if t.typ == nil {
 		t.typ = ExpandType(t.name)
 	}
@@ -146,16 +146,16 @@ export type PtrType interface {
 	Sub()	Type
 }
 
-type PtrTypeStruct struct {
+type ptrTypeStruct struct {
 	commonType;
-	sub	*StubType;
+	sub	*stubType;
 }
 
-func NewPtrTypeStruct(name, typestring string, sub *StubType) *PtrTypeStruct {
-	return &PtrTypeStruct{ commonType{PtrKind, typestring, name, ptrsize}, sub}
+func newPtrTypeStruct(name, typestring string, sub *stubType) *ptrTypeStruct {
+	return &ptrTypeStruct{ commonType{PtrKind, typestring, name, ptrsize}, sub}
 }
 
-func (t *PtrTypeStruct) Sub() Type {
+func (t *ptrTypeStruct) Sub() Type {
 	return t.sub.Get()
 }
 
@@ -167,34 +167,34 @@ export type ArrayType interface {
 	Elem()	Type;
 }
 
-type ArrayTypeStruct struct {
+type arrayTypeStruct struct {
 	commonType;
-	elem	*StubType;
+	elem	*stubType;
 	open	bool;	// otherwise fixed size
 	len	int;
 }
 
-func NewArrayTypeStruct(name, typestring string, open bool, len int, elem *StubType) *ArrayTypeStruct {
-	return &ArrayTypeStruct{ commonType{ArrayKind, typestring, name, 0}, elem, open, len}
+func newArrayTypeStruct(name, typestring string, open bool, len int, elem *stubType) *arrayTypeStruct {
+	return &arrayTypeStruct{ commonType{ArrayKind, typestring, name, 0}, elem, open, len}
 }
 
-func (t *ArrayTypeStruct) Size() int {
+func (t *arrayTypeStruct) Size() int {
 	if t.open {
 		return ptrsize*2	// open arrays are 2-word headers
 	}
 	return t.len * t.elem.Get().Size();
 }
 
-func (t *ArrayTypeStruct) Open() bool {
+func (t *arrayTypeStruct) Open() bool {
 	return t.open
 }
 
-func (t *ArrayTypeStruct) Len() int {
+func (t *arrayTypeStruct) Len() int {
 	// what about open array?  TODO
 	return t.len
 }
 
-func (t *ArrayTypeStruct) Elem() Type {
+func (t *arrayTypeStruct) Elem() Type {
 	return t.elem.Get()
 }
 
@@ -205,21 +205,21 @@ export type MapType interface {
 	Elem()	Type;
 }
 
-type MapTypeStruct struct {
+type mapTypeStruct struct {
 	commonType;
-	key	*StubType;
-	elem	*StubType;
+	key	*stubType;
+	elem	*stubType;
 }
 
-func NewMapTypeStruct(name, typestring string, key, elem *StubType) *MapTypeStruct {
-	return &MapTypeStruct{ commonType{MapKind, typestring, name, ptrsize}, key, elem}
+func newMapTypeStruct(name, typestring string, key, elem *stubType) *mapTypeStruct {
+	return &mapTypeStruct{ commonType{MapKind, typestring, name, ptrsize}, key, elem}
 }
 
-func (t *MapTypeStruct) Key() Type {
+func (t *mapTypeStruct) Key() Type {
 	return t.key.Get()
 }
 
-func (t *MapTypeStruct) Elem() Type {
+func (t *mapTypeStruct) Elem() Type {
 	return t.elem.Get()
 }
 
@@ -236,21 +236,21 @@ export const (	// channel direction
 	BothDir = SendDir | RecvDir;
 )
 
-type ChanTypeStruct struct {
+type chanTypeStruct struct {
 	commonType;
-	elem	*StubType;
+	elem	*stubType;
 	dir	int;
 }
 
-func NewChanTypeStruct(name, typestring string, dir int, elem *StubType) *ChanTypeStruct {
-	return &ChanTypeStruct{ commonType{ChanKind, typestring, name, ptrsize}, elem, dir}
+func newChanTypeStruct(name, typestring string, dir int, elem *stubType) *chanTypeStruct {
+	return &chanTypeStruct{ commonType{ChanKind, typestring, name, ptrsize}, elem, dir}
 }
 
-func (t *ChanTypeStruct) Dir() int {
+func (t *chanTypeStruct) Dir() int {
 	return t.dir
 }
 
-func (t *ChanTypeStruct) Elem() Type {
+func (t *chanTypeStruct) Elem() Type {
 	return t.elem.Get()
 }
 
@@ -261,25 +261,25 @@ export type StructType interface {
 	Len()	int;
 }
 
-type Field struct {
+type structField struct {
 	name	string;
-	typ	*StubType;
+	typ	*stubType;
 	tag	string;
 	size	int;
 	offset	int;
 }
 
-type StructTypeStruct struct {
+type structTypeStruct struct {
 	commonType;
-	field	[]Field;
+	field	[]structField;
 }
 
-func NewStructTypeStruct(name, typestring string, field []Field) *StructTypeStruct {
-	return &StructTypeStruct{ commonType{StructKind, typestring, name, 0}, field}
+func newStructTypeStruct(name, typestring string, field []structField) *structTypeStruct {
+	return &structTypeStruct{ commonType{StructKind, typestring, name, 0}, field}
 }
 
 // TODO: not portable; depends on 6g
-func (t *StructTypeStruct) Size() int {
+func (t *structTypeStruct) Size() int {
 	if t.size > 0 {
 		return t.size
 	}
@@ -303,14 +303,14 @@ func (t *StructTypeStruct) Size() int {
 	return size;
 }
 
-func (t *StructTypeStruct) Field(i int) (name string, typ Type, tag string, offset int) {
+func (t *structTypeStruct) Field(i int) (name string, typ Type, tag string, offset int) {
 	if t.field[i].offset == 0 {
 		t.Size();	// will compute offsets
 	}
 	return t.field[i].name, t.field[i].typ.Get(), t.field[i].tag, t.field[i].offset
 }
 
-func (t *StructTypeStruct) Len() int {
+func (t *structTypeStruct) Len() int {
 	return len(t.field)
 }
 
@@ -321,24 +321,24 @@ export type InterfaceType interface {
 	Len()	int;
 }
 
-type InterfaceTypeStruct struct {
+type interfaceTypeStruct struct {
 	commonType;
-	field	[]Field;
+	field	[]structField;
 }
 
-func NewInterfaceTypeStruct(name, typestring string, field []Field) *InterfaceTypeStruct {
-	return &InterfaceTypeStruct{ commonType{InterfaceKind, typestring, name, interfacesize}, field }
+func newInterfaceTypeStruct(name, typestring string, field []structField) *interfaceTypeStruct {
+	return &interfaceTypeStruct{ commonType{InterfaceKind, typestring, name, interfacesize}, field }
 }
 
-func (t *InterfaceTypeStruct) Field(i int) (name string, typ Type, tag string, offset int) {
+func (t *interfaceTypeStruct) Field(i int) (name string, typ Type, tag string, offset int) {
 	return t.field[i].name, t.field[i].typ.Get(), "", 0
 }
 
-func (t *InterfaceTypeStruct) Len() int {
+func (t *interfaceTypeStruct) Len() int {
 	return len(t.field)
 }
 
-var NilInterface = NewInterfaceTypeStruct("nil", "", make([]Field, 0));
+var nilInterface = newInterfaceTypeStruct("nil", "", make([]structField, 0));
 
 // -- Func
 
@@ -347,26 +347,26 @@ export type FuncType interface {
 	Out()	StructType;
 }
 
-type FuncTypeStruct struct {
+type funcTypeStruct struct {
 	commonType;
-	in	*StructTypeStruct;
-	out	*StructTypeStruct;
+	in	*structTypeStruct;
+	out	*structTypeStruct;
 }
 
-func NewFuncTypeStruct(name, typestring string, in, out *StructTypeStruct) *FuncTypeStruct {
-	return &FuncTypeStruct{ commonType{FuncKind, typestring, name, 0}, in, out }
+func newFuncTypeStruct(name, typestring string, in, out *structTypeStruct) *funcTypeStruct {
+	return &funcTypeStruct{ commonType{FuncKind, typestring, name, 0}, in, out }
 }
 
-func (t *FuncTypeStruct) Size() int {
+func (t *funcTypeStruct) Size() int {
 	panic("reflect.type: func.Size(): cannot happen");
 	return 0
 }
 
-func (t *FuncTypeStruct) In() StructType {
+func (t *funcTypeStruct) In() StructType {
 	return t.in
 }
 
-func (t *FuncTypeStruct) Out() StructType {
+func (t *funcTypeStruct) Out() StructType {
 	if t.out == nil {	// nil.(StructType) != nil so make sure caller sees real nil
 		return nil
 	}
@@ -380,20 +380,20 @@ var types map[string] Type
 var typestring map[string] string
 var initialized bool = false
 
-// Map of basic types to prebuilt StubTypes
-var basicstub map[string] *StubType
+// Map of basic types to prebuilt stubTypes
+var basicstub map[string] *stubType
 
-var MissingStub *StubType;
-var DotDotDotStub *StubType;
+var missingStub *stubType;
+var dotDotDotStub *stubType;
 
 // The database stored in the maps is global; use locking to guarantee safety.
 var typestringlock sync.Mutex
 
-func Lock() {
+func lock() {
 	typestringlock.Lock()
 }
 
-func Unlock() {
+func unlock() {
 	typestringlock.Unlock()
 }
 
@@ -401,15 +401,15 @@ func init() {
 	ptrsize = 8;	// TODO: compute this
 	interfacesize = 2*ptrsize;	// TODO: compute this
 
-	Lock();	// not necessary because of init ordering but be safe.
+	lock();	// not necessary because of init ordering but be safe.
 
 	types = make(map[string] Type);
 	typestring = make(map[string] string);
-	basicstub = make(map[string] *StubType);
+	basicstub = make(map[string] *stubType);
 
 	// Basics go into types table
-	types[MissingString] = Missing;
-	types[DotDotDotString] = DotDotDot;
+	types[missingString] = Missing;
+	types[dotDotDotString] = DotDotDot;
 	types["int"] = Int;
 	types["int8"] = Int8;
 	types["int16"] = Int16;
@@ -429,29 +429,29 @@ func init() {
 	types["bool"] = Bool;
 
 	// Basics get prebuilt stubs
-	MissingStub = NewStubType(MissingString, Missing);
-	DotDotDotStub = NewStubType(DotDotDotString, DotDotDot);
-	basicstub[MissingString] = MissingStub;
-	basicstub[DotDotDotString] = DotDotDotStub;
-	basicstub["int"] = NewStubType("int", Int);
-	basicstub["int8"] = NewStubType("int8", Int8);
-	basicstub["int16"] = NewStubType("int16", Int16);
-	basicstub["int32"] = NewStubType("int32", Int32);
-	basicstub["int64"] = NewStubType("int64", Int64);
-	basicstub["uint"] = NewStubType("uint", Uint);
-	basicstub["uint8"] = NewStubType("uint8", Uint8);
-	basicstub["uint16"] = NewStubType("uint16", Uint16);
-	basicstub["uint32"] = NewStubType("uint32", Uint32);
-	basicstub["uint64"] = NewStubType("uint64", Uint64);
-	basicstub["uintptr"] = NewStubType("uintptr", Uintptr);
-	basicstub["float"] = NewStubType("float", Float);
-	basicstub["float32"] = NewStubType("float32", Float32);
-	basicstub["float64"] = NewStubType("float64", Float64);
-	basicstub["float80"] = NewStubType("float80", Float80);
-	basicstub["string"] = NewStubType("string", String);
-	basicstub["bool"] = NewStubType("bool", Bool);
-
-	Unlock();
+	missingStub = newStubType(missingString, Missing);
+	dotDotDotStub = newStubType(dotDotDotString, DotDotDot);
+	basicstub[missingString] = missingStub;
+	basicstub[dotDotDotString] = dotDotDotStub;
+	basicstub["int"] = newStubType("int", Int);
+	basicstub["int8"] = newStubType("int8", Int8);
+	basicstub["int16"] = newStubType("int16", Int16);
+	basicstub["int32"] = newStubType("int32", Int32);
+	basicstub["int64"] = newStubType("int64", Int64);
+	basicstub["uint"] = newStubType("uint", Uint);
+	basicstub["uint8"] = newStubType("uint8", Uint8);
+	basicstub["uint16"] = newStubType("uint16", Uint16);
+	basicstub["uint32"] = newStubType("uint32", Uint32);
+	basicstub["uint64"] = newStubType("uint64", Uint64);
+	basicstub["uintptr"] = newStubType("uintptr", Uintptr);
+	basicstub["float"] = newStubType("float", Float);
+	basicstub["float32"] = newStubType("float32", Float32);
+	basicstub["float64"] = newStubType("float64", Float64);
+	basicstub["float80"] = newStubType("float80", Float80);
+	basicstub["string"] = newStubType("string", String);
+	basicstub["bool"] = newStubType("bool", Bool);
+
+	unlock();
 }
 
 /*
@@ -551,7 +551,7 @@ func unescape(s string, backslash bool) string {
 }
 
 // Simple parser for type strings
-type Parser struct {
+type typeParser struct {
 	str	string;	// string being parsed
 	token	string;	// the token being parsed now
 	tokstart	int;	// starting position of token
@@ -561,12 +561,12 @@ type Parser struct {
 
 // Return typestring starting at position i.  It will finish at the
 // end of the previous token (before trailing white space).
-func (p *Parser) TypeString(i int) string {
+func (p *typeParser) TypeString(i int) string {
 	return p.str[i:p.prevend];
 }
 
 // Load next token into p.token
-func (p *Parser) Next() {
+func (p *typeParser) Next() {
 	p.prevend = p.index;
 	token := "";
 	for ; p.index < len(p.str) && p.str[p.index] == ' '; p.index++ {
@@ -588,9 +588,9 @@ func (p *Parser) Next() {
 		}
 		fallthrough;	// shouldn't happen but let the parser figure it out
 	case c == '.':
-		if p.index < len(p.str)+2 && p.str[p.index-1:p.index+2] == DotDotDotString {
+		if p.index < len(p.str)+2 && p.str[p.index-1:p.index+2] == dotDotDotString {
 			p.index += 2;
-			p.token = DotDotDotString;
+			p.token = dotDotDotString;
 			return;
 		}
 		fallthrough;	// shouldn't happen but let the parser figure it out
@@ -627,14 +627,14 @@ func (p *Parser) Next() {
 	p.token = p.str[start : p.index];
 }
 
-func (p *Parser) Type(name string) *StubType
+func (p *typeParser) Type(name string) *stubType
 
-func (p *Parser) Array(name string, tokstart int) *StubType {
+func (p *typeParser) Array(name string, tokstart int) *stubType {
 	size := 0;
 	open := true;
 	if p.token != "]" {
 		if len(p.token) == 0 || !isdigit(p.token[0]) {
-			return MissingStub
+			return missingStub
 		}
 		// write our own (trivial and simpleminded) atoi to avoid dependency
 		size = 0;
@@ -645,46 +645,46 @@ func (p *Parser) Array(name string, tokstart int) *StubType {
 		open = false;
 	}
 	if p.token != "]" {
-		return MissingStub
+		return missingStub
 	}
 	p.Next();
 	elemtype := p.Type("");
-	return NewStubType(name, NewArrayTypeStruct(name, p.TypeString(tokstart), open, size, elemtype));
+	return newStubType(name, newArrayTypeStruct(name, p.TypeString(tokstart), open, size, elemtype));
 }
 
-func (p *Parser) Map(name string, tokstart int) *StubType {
+func (p *typeParser) Map(name string, tokstart int) *stubType {
 	if p.token != "[" {
-		return MissingStub
+		return missingStub
 	}
 	p.Next();
 	keytype := p.Type("");
 	if p.token != "]" {
-		return MissingStub
+		return missingStub
 	}
 	p.Next();
 	elemtype := p.Type("");
-	return NewStubType(name, NewMapTypeStruct(name, p.TypeString(tokstart), keytype, elemtype));
+	return newStubType(name, newMapTypeStruct(name, p.TypeString(tokstart), keytype, elemtype));
 }
 
-func (p *Parser) Chan(name string, tokstart, dir int) *StubType {
+func (p *typeParser) Chan(name string, tokstart, dir int) *stubType {
 	if p.token == "<-" {
 		if dir != BothDir {
-			return MissingStub
+			return missingStub
 		}
 		p.Next();
 		dir = SendDir;
 	}
 	elemtype := p.Type("");
-	return NewStubType(name, NewChanTypeStruct(name, p.TypeString(tokstart), dir, elemtype));
+	return newStubType(name, newChanTypeStruct(name, p.TypeString(tokstart), dir, elemtype));
 }
 
 // Parse array of fields for struct, interface, and func arguments
-func (p *Parser) Fields(sep, term string) []Field {
-	a := make([]Field, 10);
+func (p *typeParser) Fields(sep, term string) []structField {
+	a := make([]structField, 10);
 	nf := 0;
 	for p.token != "" && p.token != term {
 		if nf == len(a) {
-			a1 := make([]Field, 2*nf);
+			a1 := make([]structField, 2*nf);
 			for i := 0; i < nf; i++ {
 				a1[i] = a[i];
 			}
@@ -711,59 +711,59 @@ func (p *Parser) Fields(sep, term string) []Field {
 }
 
 // A single type packaged as a field for a function return
-func (p *Parser) OneField() []Field {
-	a := make([]Field, 1);
+func (p *typeParser) OneField() []structField {
+	a := make([]structField, 1);
 	a[0].name = "";
 	a[0].typ = p.Type("");
 	return a;
 }
 
-func (p *Parser) Struct(name string, tokstart int) *StubType {
+func (p *typeParser) Struct(name string, tokstart int) *stubType {
 	f := p.Fields(";", "}");
 	if p.token != "}" {
-		return MissingStub;
+		return missingStub;
 	}
 	p.Next();
-	return NewStubType(name, NewStructTypeStruct(name, p.TypeString(tokstart), f));
+	return newStubType(name, newStructTypeStruct(name, p.TypeString(tokstart), f));
 }
 
-func (p *Parser) Interface(name string, tokstart int) *StubType {
+func (p *typeParser) Interface(name string, tokstart int) *stubType {
 	f := p.Fields(";", "}");
 	if p.token != "}" {
-		return MissingStub;
+		return missingStub;
 	}
 	p.Next();
-	return NewStubType(name, NewInterfaceTypeStruct(name, p.TypeString(tokstart), f));
+	return newStubType(name, newInterfaceTypeStruct(name, p.TypeString(tokstart), f));
 }
 
-func (p *Parser) Func(name string, tokstart int) *StubType {
+func (p *typeParser) Func(name string, tokstart int) *stubType {
 	// may be 1 or 2 parenthesized lists
-	f1 := NewStructTypeStruct("", "", p.Fields(",", ")"));
+	f1 := newStructTypeStruct("", "", p.Fields(",", ")"));
 	if p.token != ")" {
-		return MissingStub;
+		return missingStub;
 	}
 	p.Next();
 	if p.token != "(" {
 		// 1 list: the in parameters are a list.  Is there a single out parameter?
 		if p.token == "" || p.token == "}" || p.token == "," || p.token == ";" {
-			return NewStubType(name, NewFuncTypeStruct(name, p.TypeString(tokstart), f1, nil));
+			return newStubType(name, newFuncTypeStruct(name, p.TypeString(tokstart), f1, nil));
 		}
 		// A single out parameter.
-		f2 := NewStructTypeStruct("", "", p.OneField());
-		return NewStubType(name, NewFuncTypeStruct(name, p.TypeString(tokstart), f1, f2));
+		f2 := newStructTypeStruct("", "", p.OneField());
+		return newStubType(name, newFuncTypeStruct(name, p.TypeString(tokstart), f1, f2));
 	} else {
 		p.Next();
 	}
-	f2 := NewStructTypeStruct("", "", p.Fields(",", ")"));
+	f2 := newStructTypeStruct("", "", p.Fields(",", ")"));
 	if p.token != ")" {
-		return MissingStub;
+		return missingStub;
 	}
 	p.Next();
 	// 2 lists: the in and out parameters are present
-	return NewStubType(name, NewFuncTypeStruct(name, p.TypeString(tokstart), f1, f2));
+	return newStubType(name, newFuncTypeStruct(name, p.TypeString(tokstart), f1, f2));
 }
 
-func (p *Parser) Type(name string) *StubType {
+func (p *typeParser) Type(name string) *stubType {
 	dir := BothDir;
 	tokstart := p.tokstart;
 	switch {
@@ -772,7 +772,7 @@ func (p *Parser) Type(name string) *StubType {
 	case p.token == "*":
 		p.Next();
 		sub := p.Type("");
-		return NewStubType(name, NewPtrTypeStruct(name, p.TypeString(tokstart), sub));
+		return newStubType(name, newPtrTypeStruct(name, p.TypeString(tokstart), sub));
 	case p.token == "[":
 		p.Next();
 		return p.Array(name, tokstart);
@@ -783,7 +783,7 @@ func (p *Parser) Type(name string) *StubType {
 		p.Next();
 		dir = RecvDir;
 		if p.token != "chan" {
-			return MissingStub;
+			return missingStub;
 		}
 		fallthrough;
 	case p.token == "chan":
@@ -792,14 +792,14 @@ func (p *Parser) Type(name string) *StubType {
 	case p.token == "struct":
 		p.Next();
 		if p.token != "{" {
-			return MissingStub
+			return missingStub
 		}
 		p.Next();
 		return p.Struct(name, tokstart);
 	case p.token == "interface":
 		p.Next();
 		if p.token != "{" {
-			return MissingStub
+			return missingStub
 		}
 		p.Next();
 		return p.Interface(name, tokstart);
@@ -808,10 +808,10 @@ func (p *Parser) Type(name string) *StubType {
 		return p.Func(name, tokstart);
 	case isdigit(p.token[0]):
 		p.Next();
-		return MissingStub;
+		return missingStub;
 	case special(p.token[0]):
 		p.Next();
-		return MissingStub;
+		return missingStub;
 	}
 	// must be an identifier. is it basic? if so, we have a stub
 	if s, ok := basicstub[p.token]; ok {
@@ -819,7 +819,7 @@ func (p *Parser) Type(name string) *StubType {
 		if name != "" {
 			// Need to make a copy because we are renaming a basic type
 			b := s.Get();
-			s = NewStubType(name, NewBasicType(name, b.Kind(), b.Size()));
+			s = newStubType(name, newBasicType(name, b.Kind(), b.Size()));
 		}
 		return s
 	}
@@ -832,9 +832,9 @@ func (p *Parser) Type(name string) *StubType {
 	}
 	if ndot != 1 {
 		p.Next();
-		return MissingStub;
+		return missingStub;
 	}
-	s := NewStubType(p.token, nil);
+	s := newStubType(p.token, nil);
 	p.Next();
 	return s;
 }
@@ -842,16 +842,16 @@ func (p *Parser) Type(name string) *StubType {
 export func ParseTypeString(name, typestring string) Type {
 	if typestring == "" {
 		// If the typestring is empty, it represents (the type of) a nil interface value
-		return NilInterface
+		return nilInterface
 	}
-	p := new(Parser);
+	p := new(typeParser);
 	p.str = typestring;
 	p.Next();
 	return p.Type(name).Get();
 }
 
 // Create typestring map from reflect.typestrings() data.  Lock is held.
-func InitializeTypeStrings() {
+func initializeTypeStrings() {
 	if initialized {
 		return
 	}
@@ -885,13 +885,13 @@ func InitializeTypeStrings() {
 }
 
 // Look up type string associated with name.  Lock is held.
-func TypeNameToTypeString(name string) string {
+func typeNameToTypeString(name string) string {
 	s, ok := typestring[name];
 	if !ok {
-		InitializeTypeStrings();
+		initializeTypeStrings();
 		s, ok = typestring[name];
 		if !ok {
-			s = MissingString;
+			s = missingString;
 			typestring[name] = s;
 		}
 	}
@@ -899,16 +899,16 @@ func TypeNameToTypeString(name string) string {
 }
 
 // Type is known by name.  Find (and create if necessary) its real type.
-func ExpandType(name string) Type {
-	Lock();
+export func ExpandType(name string) Type {
+	lock();
 	t, ok := types[name];
 	if ok {
-		Unlock();
+		unlock();
 		return t
 	}
 	types[name] = Missing;	// prevent recursion; will overwrite
-	t1 := ParseTypeString(name, TypeNameToTypeString(name));
+	t1 := ParseTypeString(name, typeNameToTypeString(name));
 	types[name] = t1;
-	Unlock();
+	unlock();
 	return t1;
 }
diff --git a/src/lib/reflect/value.go b/src/lib/reflect/value.go
index 2adf430dad..63752d84de 100644
--- a/src/lib/reflect/value.go
+++ b/src/lib/reflect/value.go
@@ -12,9 +12,9 @@ import (
 	"unsafe";
 )
 
-type Addr unsafe.pointer
+export type Addr unsafe.pointer
 
-func EqualType(a, b Type) bool {
+func equalType(a, b Type) bool {
 	return a.String() == b.String()
 }
 
@@ -58,9 +58,9 @@ func (c *commonValue) Interface() interface {} {
 	return i;
 }
 
-func NewValueAddr(typ Type, addr Addr) Value
+func newValueAddr(typ Type, addr Addr) Value
 
-type Creator *(typ Type, addr Addr) Value
+type creatorFn *(typ Type, addr Addr) Value
 
 
 // -- Missing
@@ -71,12 +71,12 @@ export type MissingValue interface {
 	Addr()	Addr;
 }
 
-type MissingValueStruct struct {
+type missingValueStruct struct {
 	commonValue
 }
 
-func MissingCreator(typ Type, addr Addr) Value {
-	return &MissingValueStruct{ commonValue{MissingKind, typ, addr} }
+func missingCreator(typ Type, addr Addr) Value {
+	return &missingValueStruct{ commonValue{MissingKind, typ, addr} }
 }
 
 // -- Int
@@ -88,19 +88,19 @@ export type IntValue interface {
 	Type()	Type;
 }
 
-type IntValueStruct struct {
+type intValueStruct struct {
 	commonValue
 }
 
-func IntCreator(typ Type, addr Addr) Value {
-	return &IntValueStruct{ commonValue{IntKind, typ, addr} }
+func intCreator(typ Type, addr Addr) Value {
+	return &intValueStruct{ commonValue{IntKind, typ, addr} }
 }
 
-func (v *IntValueStruct) Get() int {
+func (v *intValueStruct) Get() int {
 	return *v.addr.(*int)
 }
 
-func (v *IntValueStruct) Set(i int) {
+func (v *intValueStruct) Set(i int) {
 	*v.addr.(*int) = i
 }
 
@@ -113,19 +113,19 @@ export type Int8Value interface {
 	Type()	Type;
 }
 
-type Int8ValueStruct struct {
+type int8ValueStruct struct {
 	commonValue
 }
 
-func Int8Creator(typ Type, addr Addr) Value {
-	return &Int8ValueStruct{ commonValue{Int8Kind, typ, addr} }
+func int8Creator(typ Type, addr Addr) Value {
+	return &int8ValueStruct{ commonValue{Int8Kind, typ, addr} }
 }
 
-func (v *Int8ValueStruct) Get() int8 {
+func (v *int8ValueStruct) Get() int8 {
 	return *v.addr.(*int8)
 }
 
-func (v *Int8ValueStruct) Set(i int8) {
+func (v *int8ValueStruct) Set(i int8) {
 	*v.addr.(*int8) = i
 }
 
@@ -138,19 +138,19 @@ export type Int16Value interface {
 	Type()	Type;
 }
 
-type Int16ValueStruct struct {
+type int16ValueStruct struct {
 	commonValue
 }
 
-func Int16Creator(typ Type, addr Addr) Value {
-	return &Int16ValueStruct{ commonValue{Int16Kind, typ, addr} }
+func int16Creator(typ Type, addr Addr) Value {
+	return &int16ValueStruct{ commonValue{Int16Kind, typ, addr} }
 }
 
-func (v *Int16ValueStruct) Get() int16 {
+func (v *int16ValueStruct) Get() int16 {
 	return *v.addr.(*int16)
 }
 
-func (v *Int16ValueStruct) Set(i int16) {
+func (v *int16ValueStruct) Set(i int16) {
 	*v.addr.(*int16) = i
 }
 
@@ -163,19 +163,19 @@ export type Int32Value interface {
 	Type()	Type;
 }
 
-type Int32ValueStruct struct {
+type int32ValueStruct struct {
 	commonValue
 }
 
-func Int32Creator(typ Type, addr Addr) Value {
-	return &Int32ValueStruct{ commonValue{Int32Kind, typ, addr} }
+func int32Creator(typ Type, addr Addr) Value {
+	return &int32ValueStruct{ commonValue{Int32Kind, typ, addr} }
 }
 
-func (v *Int32ValueStruct) Get() int32 {
+func (v *int32ValueStruct) Get() int32 {
 	return *v.addr.(*int32)
 }
 
-func (v *Int32ValueStruct) Set(i int32) {
+func (v *int32ValueStruct) Set(i int32) {
 	*v.addr.(*int32) = i
 }
 
@@ -188,19 +188,19 @@ export type Int64Value interface {
 	Type()	Type;
 }
 
-type Int64ValueStruct struct {
+type int64ValueStruct struct {
 	commonValue
 }
 
-func Int64Creator(typ Type, addr Addr) Value {
-	return &Int64ValueStruct{ commonValue{Int64Kind, typ, addr} }
+func int64Creator(typ Type, addr Addr) Value {
+	return &int64ValueStruct{ commonValue{Int64Kind, typ, addr} }
 }
 
-func (v *Int64ValueStruct) Get() int64 {
+func (v *int64ValueStruct) Get() int64 {
 	return *v.addr.(*int64)
 }
 
-func (v *Int64ValueStruct) Set(i int64) {
+func (v *int64ValueStruct) Set(i int64) {
 	*v.addr.(*int64) = i
 }
 
@@ -213,19 +213,19 @@ export type UintValue interface {
 	Type()	Type;
 }
 
-type UintValueStruct struct {
+type uintValueStruct struct {
 	commonValue
 }
 
-func UintCreator(typ Type, addr Addr) Value {
-	return &UintValueStruct{ commonValue{UintKind, typ, addr} }
+func uintCreator(typ Type, addr Addr) Value {
+	return &uintValueStruct{ commonValue{UintKind, typ, addr} }
 }
 
-func (v *UintValueStruct) Get() uint {
+func (v *uintValueStruct) Get() uint {
 	return *v.addr.(*uint)
 }
 
-func (v *UintValueStruct) Set(i uint) {
+func (v *uintValueStruct) Set(i uint) {
 	*v.addr.(*uint) = i
 }
 
@@ -238,19 +238,19 @@ export type Uint8Value interface {
 	Type()	Type;
 }
 
-type Uint8ValueStruct struct {
+type uint8ValueStruct struct {
 	commonValue
 }
 
-func Uint8Creator(typ Type, addr Addr) Value {
-	return &Uint8ValueStruct{ commonValue{Uint8Kind, typ, addr} }
+func uint8Creator(typ Type, addr Addr) Value {
+	return &uint8ValueStruct{ commonValue{Uint8Kind, typ, addr} }
 }
 
-func (v *Uint8ValueStruct) Get() uint8 {
+func (v *uint8ValueStruct) Get() uint8 {
 	return *v.addr.(*uint8)
 }
 
-func (v *Uint8ValueStruct) Set(i uint8) {
+func (v *uint8ValueStruct) Set(i uint8) {
 	*v.addr.(*uint8) = i
 }
 
@@ -263,19 +263,19 @@ export type Uint16Value interface {
 	Type()	Type;
 }
 
-type Uint16ValueStruct struct {
+type uint16ValueStruct struct {
 	commonValue
 }
 
-func Uint16Creator(typ Type, addr Addr) Value {
-	return &Uint16ValueStruct{ commonValue{Uint16Kind, typ, addr} }
+func uint16Creator(typ Type, addr Addr) Value {
+	return &uint16ValueStruct{ commonValue{Uint16Kind, typ, addr} }
 }
 
-func (v *Uint16ValueStruct) Get() uint16 {
+func (v *uint16ValueStruct) Get() uint16 {
 	return *v.addr.(*uint16)
 }
 
-func (v *Uint16ValueStruct) Set(i uint16) {
+func (v *uint16ValueStruct) Set(i uint16) {
 	*v.addr.(*uint16) = i
 }
 
@@ -288,19 +288,19 @@ export type Uint32Value interface {
 	Type()	Type;
 }
 
-type Uint32ValueStruct struct {
+type uint32ValueStruct struct {
 	commonValue
 }
 
-func Uint32Creator(typ Type, addr Addr) Value {
-	return &Uint32ValueStruct{ commonValue{Uint32Kind, typ, addr} }
+func uint32Creator(typ Type, addr Addr) Value {
+	return &uint32ValueStruct{ commonValue{Uint32Kind, typ, addr} }
 }
 
-func (v *Uint32ValueStruct) Get() uint32 {
+func (v *uint32ValueStruct) Get() uint32 {
 	return *v.addr.(*uint32)
 }
 
-func (v *Uint32ValueStruct) Set(i uint32) {
+func (v *uint32ValueStruct) Set(i uint32) {
 	*v.addr.(*uint32) = i
 }
 
@@ -313,19 +313,19 @@ export type Uint64Value interface {
 	Type()	Type;
 }
 
-type Uint64ValueStruct struct {
+type uint64ValueStruct struct {
 	commonValue
 }
 
-func Uint64Creator(typ Type, addr Addr) Value {
-	return &Uint64ValueStruct{ commonValue{Uint64Kind, typ, addr} }
+func uint64Creator(typ Type, addr Addr) Value {
+	return &uint64ValueStruct{ commonValue{Uint64Kind, typ, addr} }
 }
 
-func (v *Uint64ValueStruct) Get() uint64 {
+func (v *uint64ValueStruct) Get() uint64 {
 	return *v.addr.(*uint64)
 }
 
-func (v *Uint64ValueStruct) Set(i uint64) {
+func (v *uint64ValueStruct) Set(i uint64) {
 	*v.addr.(*uint64) = i
 }
 
@@ -338,19 +338,19 @@ export type UintptrValue interface {
 	Type()	Type;
 }
 
-type UintptrValueStruct struct {
+type uintptrValueStruct struct {
 	commonValue
 }
 
-func UintptrCreator(typ Type, addr Addr) Value {
-	return &UintptrValueStruct{ commonValue{UintptrKind, typ, addr} }
+func uintptrCreator(typ Type, addr Addr) Value {
+	return &uintptrValueStruct{ commonValue{UintptrKind, typ, addr} }
 }
 
-func (v *UintptrValueStruct) Get() uintptr {
+func (v *uintptrValueStruct) Get() uintptr {
 	return *v.addr.(*uintptr)
 }
 
-func (v *UintptrValueStruct) Set(i uintptr) {
+func (v *uintptrValueStruct) Set(i uintptr) {
 	*v.addr.(*uintptr) = i
 }
 
@@ -363,19 +363,19 @@ export type FloatValue interface {
 	Type()	Type;
 }
 
-type FloatValueStruct struct {
+type floatValueStruct struct {
 	commonValue
 }
 
-func FloatCreator(typ Type, addr Addr) Value {
-	return &FloatValueStruct{ commonValue{FloatKind, typ, addr} }
+func floatCreator(typ Type, addr Addr) Value {
+	return &floatValueStruct{ commonValue{FloatKind, typ, addr} }
 }
 
-func (v *FloatValueStruct) Get() float {
+func (v *floatValueStruct) Get() float {
 	return *v.addr.(*float)
 }
 
-func (v *FloatValueStruct) Set(f float) {
+func (v *floatValueStruct) Set(f float) {
 	*v.addr.(*float) = f
 }
 
@@ -388,19 +388,19 @@ export type Float32Value interface {
 	Type()	Type;
 }
 
-type Float32ValueStruct struct {
+type float32ValueStruct struct {
 	commonValue
 }
 
-func Float32Creator(typ Type, addr Addr) Value {
-	return &Float32ValueStruct{ commonValue{Float32Kind, typ, addr} }
+func float32Creator(typ Type, addr Addr) Value {
+	return &float32ValueStruct{ commonValue{Float32Kind, typ, addr} }
 }
 
-func (v *Float32ValueStruct) Get() float32 {
+func (v *float32ValueStruct) Get() float32 {
 	return *v.addr.(*float32)
 }
 
-func (v *Float32ValueStruct) Set(f float32) {
+func (v *float32ValueStruct) Set(f float32) {
 	*v.addr.(*float32) = f
 }
 
@@ -413,19 +413,19 @@ export type Float64Value interface {
 	Type()	Type;
 }
 
-type Float64ValueStruct struct {
+type float64ValueStruct struct {
 	commonValue
 }
 
-func Float64Creator(typ Type, addr Addr) Value {
-	return &Float64ValueStruct{ commonValue{Float64Kind, typ, addr} }
+func float64Creator(typ Type, addr Addr) Value {
+	return &float64ValueStruct{ commonValue{Float64Kind, typ, addr} }
 }
 
-func (v *Float64ValueStruct) Get() float64 {
+func (v *float64ValueStruct) Get() float64 {
 	return *v.addr.(*float64)
 }
 
-func (v *Float64ValueStruct) Set(f float64) {
+func (v *float64ValueStruct) Set(f float64) {
 	*v.addr.(*float64) = f
 }
 
@@ -438,12 +438,12 @@ export type Float80Value interface {
 	Type()	Type;
 }
 
-type Float80ValueStruct struct {
+type float80ValueStruct struct {
 	commonValue
 }
 
-func Float80Creator(typ Type, addr Addr) Value {
-	return &Float80ValueStruct{ commonValue{Float80Kind, typ, addr} }
+func float80Creator(typ Type, addr Addr) Value {
+	return &float80ValueStruct{ commonValue{Float80Kind, typ, addr} }
 }
 
 /*
@@ -466,19 +466,19 @@ export type StringValue interface {
 	Type()	Type;
 }
 
-type StringValueStruct struct {
+type stringValueStruct struct {
 	commonValue
 }
 
-func StringCreator(typ Type, addr Addr) Value {
-	return &StringValueStruct{ commonValue{StringKind, typ, addr} }
+func stringCreator(typ Type, addr Addr) Value {
+	return &stringValueStruct{ commonValue{StringKind, typ, addr} }
 }
 
-func (v *StringValueStruct) Get() string {
+func (v *stringValueStruct) Get() string {
 	return *v.addr.(*string)
 }
 
-func (v *StringValueStruct) Set(s string) {
+func (v *stringValueStruct) Set(s string) {
 	*v.addr.(*string) = s
 }
 
@@ -491,19 +491,19 @@ export type BoolValue interface {
 	Type()	Type;
 }
 
-type BoolValueStruct struct {
+type boolValueStruct struct {
 	commonValue
 }
 
-func BoolCreator(typ Type, addr Addr) Value {
-	return &BoolValueStruct{ commonValue{BoolKind, typ, addr} }
+func boolCreator(typ Type, addr Addr) Value {
+	return &boolValueStruct{ commonValue{BoolKind, typ, addr} }
 }
 
-func (v *BoolValueStruct) Get() bool {
+func (v *boolValueStruct) Get() bool {
 	return *v.addr.(*bool)
 }
 
-func (v *BoolValueStruct) Set(b bool) {
+func (v *boolValueStruct) Set(b bool) {
 	*v.addr.(*bool) = b
 }
 
@@ -517,30 +517,30 @@ export type PtrValue interface {
 	SetSub(Value);
 }
 
-type PtrValueStruct struct {
+type ptrValueStruct struct {
 	commonValue
 }
 
-func (v *PtrValueStruct) Get() Addr {
+func (v *ptrValueStruct) Get() Addr {
 	return *v.addr.(*Addr)
 }
 
-func (v *PtrValueStruct) Sub() Value {
-	return NewValueAddr(v.typ.(PtrType).Sub(), v.Get());
+func (v *ptrValueStruct) Sub() Value {
+	return newValueAddr(v.typ.(PtrType).Sub(), v.Get());
 }
 
-func (v *PtrValueStruct) SetSub(subv Value) {
+func (v *ptrValueStruct) SetSub(subv Value) {
 	a := v.typ.(PtrType).Sub();
 	b := subv.Type();
-	if !EqualType(a, b) {
+	if !equalType(a, b) {
 		panicln("reflect: incompatible types in PtrValue.SetSub:",
 			a.String(), b.String());
 	}
 	*v.addr.(*Addr) = subv.Addr();
 }
 
-func PtrCreator(typ Type, addr Addr) Value {
-	return &PtrValueStruct{ commonValue{PtrKind, typ, addr} };
+func ptrCreator(typ Type, addr Addr) Value {
+	return &ptrValueStruct{ commonValue{PtrKind, typ, addr} };
 }
 
 // -- Array
@@ -563,84 +563,84 @@ export type ArrayValue interface {
 			uint32	cap;
 		};
 */
-type RuntimeArray struct {
+type runtimeArray struct {
 	data	Addr;
 	len	uint32;
 	cap	uint32;
 }
 
-type OpenArrayValueStruct struct {
+type openArrayValueStruct struct {
 	commonValue;
 	elemtype	Type;
 	elemsize	int;
-	array *RuntimeArray;
+	array *runtimeArray;
 }
 
-func (v *OpenArrayValueStruct) Open() bool {
+func (v *openArrayValueStruct) Open() bool {
 	return true
 }
 
-func (v *OpenArrayValueStruct) Len() int {
+func (v *openArrayValueStruct) Len() int {
 	return int(v.array.len);
 }
 
-func (v *OpenArrayValueStruct) Cap() int {
+func (v *openArrayValueStruct) Cap() int {
 	return int(v.array.cap);
 }
 
-func (v *OpenArrayValueStruct) SetLen(len int) {
+func (v *openArrayValueStruct) SetLen(len int) {
 	if len > v.Cap() {
 		panicln("reflect: OpenArrayValueStruct.SetLen", len, v.Cap());
 	}
 	v.array.len = uint32(len);
 }
 
-func (v *OpenArrayValueStruct) Elem(i int) Value {
+func (v *openArrayValueStruct) Elem(i int) Value {
 	data_uint := uintptr(v.array.data) + uintptr(i * v.elemsize);
-	return NewValueAddr(v.elemtype, Addr(data_uint));
+	return newValueAddr(v.elemtype, Addr(data_uint));
 }
 
-type FixedArrayValueStruct struct {
+type fixedArrayValueStruct struct {
 	commonValue;
 	elemtype	Type;
 	elemsize	int;
 	len	int;
 }
 
-func (v *FixedArrayValueStruct) Open() bool {
+func (v *fixedArrayValueStruct) Open() bool {
 	return false
 }
 
-func (v *FixedArrayValueStruct) Len() int {
+func (v *fixedArrayValueStruct) Len() int {
 	return v.len
 }
 
-func (v *FixedArrayValueStruct) Cap() int {
+func (v *fixedArrayValueStruct) Cap() int {
 	return v.len
 }
 
-func (v *FixedArrayValueStruct) SetLen(len int) {
+func (v *fixedArrayValueStruct) SetLen(len int) {
 }
 
-func (v *FixedArrayValueStruct) Elem(i int) Value {
+func (v *fixedArrayValueStruct) Elem(i int) Value {
 	data_uint := uintptr(v.addr) + uintptr(i * v.elemsize);
-	return NewValueAddr(v.elemtype, Addr(data_uint));
+	return newValueAddr(v.elemtype, Addr(data_uint));
 	return nil
 }
 
-func ArrayCreator(typ Type, addr Addr) Value {
+func arrayCreator(typ Type, addr Addr) Value {
 	arraytype := typ.(ArrayType);
 	if arraytype.Open() {
-		v := new(OpenArrayValueStruct);
+		v := new(openArrayValueStruct);
 		v.kind = ArrayKind;
 		v.addr = addr;
 		v.typ = typ;
 		v.elemtype = arraytype.Elem();
 		v.elemsize = v.elemtype.Size();
-		v.array = addr.(*RuntimeArray);
+		v.array = addr.(*runtimeArray);
 		return v;
 	}
-	v := new(FixedArrayValueStruct);
+	v := new(fixedArrayValueStruct);
 	v.kind = ArrayKind;
 	v.addr = addr;
 	v.typ = typ;
@@ -659,19 +659,19 @@ export type MapValue interface {
 	Elem(key Value)	Value;
 }
 
-type MapValueStruct struct {
+type mapValueStruct struct {
 	commonValue
 }
 
-func MapCreator(typ Type, addr Addr) Value {
-	return &MapValueStruct{ commonValue{MapKind, typ, addr} }
+func mapCreator(typ Type, addr Addr) Value {
+	return &mapValueStruct{ commonValue{MapKind, typ, addr} }
 }
 
-func (v *MapValueStruct) Len() int {
+func (v *mapValueStruct) Len() int {
 	return 0	// TODO: probably want this to be dynamic
 }
 
-func (v *MapValueStruct) Elem(key Value) Value {
+func (v *mapValueStruct) Elem(key Value) Value {
 	panic("map value element");
 	return nil
 }
@@ -683,12 +683,12 @@ export type ChanValue interface {
 	Type()	Type;
 }
 
-type ChanValueStruct struct {
+type chanValueStruct struct {
 	commonValue
 }
 
-func ChanCreator(typ Type, addr Addr) Value {
-	return &ChanValueStruct{ commonValue{ChanKind, typ, addr} }
+func chanCreator(typ Type, addr Addr) Value {
+	return &chanValueStruct{ commonValue{ChanKind, typ, addr} }
 }
 
 // -- Struct
@@ -700,27 +700,27 @@ export type StructValue interface {
 	Field(i int)	Value;
 }
 
-type StructValueStruct struct {
+type structValueStruct struct {
 	commonValue;
 	field	[]Value;
 }
 
-func (v *StructValueStruct) Len() int {
+func (v *structValueStruct) Len() int {
 	return len(v.field)
 }
 
-func (v *StructValueStruct) Field(i int) Value {
+func (v *structValueStruct) Field(i int) Value {
 	return v.field[i]
 }
 
-func StructCreator(typ Type, addr Addr) Value {
+func structCreator(typ Type, addr Addr) Value {
 	t := typ.(StructType);
 	nfield := t.Len();
-	v := &StructValueStruct{ commonValue{StructKind, typ, addr}, make([]Value, nfield) };
+	v := &structValueStruct{ commonValue{StructKind, typ, addr}, make([]Value, nfield) };
 	for i := 0; i < nfield; i++ {
 		name, ftype, str, offset := t.Field(i);
 		addr_uint := uintptr(addr) + uintptr(offset);
-		v.field[i] = NewValueAddr(ftype, Addr(addr_uint));
+		v.field[i] = newValueAddr(ftype, Addr(addr_uint));
 	}
 	v.typ = typ;
 	return v;
@@ -734,16 +734,16 @@ export type InterfaceValue interface {
 	Get()	interface {};
 }
 
-type InterfaceValueStruct struct {
+type interfaceValueStruct struct {
 	commonValue
 }
 
-func (v *InterfaceValueStruct) Get() interface{} {
+func (v *interfaceValueStruct) Get() interface{} {
 	return *v.addr.(*interface{})
 }
 
-func InterfaceCreator(typ Type, addr Addr) Value {
-	return &InterfaceValueStruct{ commonValue{InterfaceKind, typ, addr} }
+func interfaceCreator(typ Type, addr Addr) Value {
+	return &interfaceValueStruct{ commonValue{InterfaceKind, typ, addr} }
 }
 
 // -- Func
@@ -753,45 +753,45 @@ export type FuncValue interface {
 	Type()	Type;
 }
 
-type FuncValueStruct struct {
+type funcValueStruct struct {
 	commonValue
 }
 
-func FuncCreator(typ Type, addr Addr) Value {
-	return &FuncValueStruct{ commonValue{FuncKind, typ, addr} }
-}
-
-var creator = map[int] Creator {
-	MissingKind : &MissingCreator,
-	IntKind : &IntCreator,
-	Int8Kind : &Int8Creator,
-	Int16Kind : &Int16Creator,
-	Int32Kind : &Int32Creator,
-	Int64Kind : &Int64Creator,
-	UintKind : &UintCreator,
-	Uint8Kind : &Uint8Creator,
-	Uint16Kind : &Uint16Creator,
-	Uint32Kind : &Uint32Creator,
-	Uint64Kind : &Uint64Creator,
-	UintptrKind : &UintptrCreator,
-	FloatKind : &FloatCreator,
-	Float32Kind : &Float32Creator,
-	Float64Kind : &Float64Creator,
-	Float80Kind : &Float80Creator,
-	StringKind : &StringCreator,
-	BoolKind : &BoolCreator,
-	PtrKind : &PtrCreator,
-	ArrayKind : &ArrayCreator,
-	MapKind : &MapCreator,
-	ChanKind : &ChanCreator,
-	StructKind : &StructCreator,
-	InterfaceKind : &InterfaceCreator,
-	FuncKind : &FuncCreator,
+func funcCreator(typ Type, addr Addr) Value {
+	return &funcValueStruct{ commonValue{FuncKind, typ, addr} }
+}
+
+var creator = map[int] creatorFn {
+	MissingKind : &missingCreator,
+	IntKind : &intCreator,
+	Int8Kind : &int8Creator,
+	Int16Kind : &int16Creator,
+	Int32Kind : &int32Creator,
+	Int64Kind : &int64Creator,
+	UintKind : &uintCreator,
+	Uint8Kind : &uint8Creator,
+	Uint16Kind : &uint16Creator,
+	Uint32Kind : &uint32Creator,
+	Uint64Kind : &uint64Creator,
+	UintptrKind : &uintptrCreator,
+	FloatKind : &floatCreator,
+	Float32Kind : &float32Creator,
+	Float64Kind : &float64Creator,
+	Float80Kind : &float80Creator,
+	StringKind : &stringCreator,
+	BoolKind : &boolCreator,
+	PtrKind : &ptrCreator,
+	ArrayKind : &arrayCreator,
+	MapKind : &mapCreator,
+	ChanKind : &chanCreator,
+	StructKind : &structCreator,
+	InterfaceKind : &interfaceCreator,
+	FuncKind : &funcCreator,
 }
 
 var typecache = make(map[string] Type);
 
-func NewValueAddr(typ Type, addr Addr) Value {
+func newValueAddr(typ Type, addr Addr) Value {
 	c, ok := creator[typ.Kind()];
 	if !ok {
 		panicln("no creator for type" , typ.Kind());
@@ -814,7 +814,7 @@ export func NewInitValue(typ Type) Value {
 		size = 1;
 	}
 	data := make([]uint8, size);
-	return NewValueAddr(typ, Addr(&data[0]));
+	return newValueAddr(typ, Addr(&data[0]));
 }
 
 /*
@@ -830,7 +830,7 @@ export func NewOpenArrayValue(typ ArrayType, len, cap int) ArrayValue {
 		return nil
 	}
 
-	array := new(RuntimeArray);
+	array := new(runtimeArray);
 	size := typ.Elem().Size() * cap;
 	if size == 0 {
 		size = 1;
@@ -840,7 +840,7 @@ export func NewOpenArrayValue(typ ArrayType, len, cap int) ArrayValue {
 	array.len = uint32(len);
 	array.cap = uint32(cap);
 
-	return NewValueAddr(typ, Addr(array));
+	return newValueAddr(typ, Addr(array));
 }
 
 export func CopyArray(dst ArrayValue, src ArrayValue, n int) {
@@ -849,7 +849,7 @@ export func CopyArray(dst ArrayValue, src ArrayValue, n int) {
 	}
 	dt := dst.Type().(ArrayType).Elem();
 	st := src.Type().(ArrayType).Elem();
-	if !EqualType(dt, st) {
+	if !equalType(dt, st) {
 		panicln("reflect: incompatible types in CopyArray:",
 			dt.String(), st.String());
 	}
@@ -885,12 +885,12 @@ export func NewValue(e interface {}) Value {
 
 	if indir {
 		// Content of interface is a pointer.
-		return NewValueAddr(typ, value.(uintptr).(Addr));
+		return newValueAddr(typ, value.(uintptr).(Addr));
 	}
 
 	// Content of interface is a value;
 	// need a permanent copy to take its address.
 	ap := new(uint64);
 	*ap = value;
-	return NewValueAddr(typ, ap.(Addr));
+	return newValueAddr(typ, ap.(Addr));
 }
