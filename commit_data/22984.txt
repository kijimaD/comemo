commit c1c667542cb831303d332f3699a9cf32dfa490e1
Author: Austin Clements <austin@google.com>
Date:   Mon Apr 13 16:50:20 2015 -0400

    runtime: fix dangling pointer in readyExecute
    
    readyExecute passes a closure to mcall that captures an argument to
    readyExecute. Since mcall is marked noescape, this closure lives on
    the stack of the calling goroutine. However, the closure puts the
    calling goroutine on the run queue (and switches to a new
    goroutine). If the calling goroutine gets scheduled before the mcall
    returns, this stack-allocated closure will become invalid while it's
    still executing. One consequence of this we've observed is that the
    captured gp variable can get overwritten before the call to
    execute(gp), causing execute(gp) to segfault.
    
    Fix this by passing the currently captured gp variable through a field
    in the calling goroutine's g struct so that the func is no longer a
    closure.
    
    To prevent problems like this in the future, this change also removes
    the go:noescape annotation from mcall. Due to a compiler bug, this
    will currently cause a func closure passed to mcall to be implicitly
    allocated rather than refusing the implicit allocation. However, this
    is okay because there are no other closures passed to mcall right now
    and the compiler bug will be fixed shortly.
    
    Fixes #10428.
    
    Change-Id: I49b48b85de5643323b89e9eaa4df63854e968c32
    Reviewed-on: https://go-review.googlesource.com/8866
    TryBot-Result: Gobot Gobot <gobot@golang.org>
    Reviewed-by: David Chase <drchase@google.com>
    Reviewed-by: Russ Cox <rsc@golang.org>

 src/runtime/proc1.go    | 8 ++++++++
 src/runtime/runtime2.go | 1 +
 src/runtime/stubs.go    | 5 ++++-
 3 files changed, 13 insertions(+), 1 deletion(-)
