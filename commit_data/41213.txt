commit 8cc57c0ccc882a06352e6ad73cb7c281d34be3ef
Author: Tim Cooper <tim.cooper@layeh.com>
Date:   Mon Jul 15 17:54:23 2019 -0500

    log: add Lmsgprefix flag
    
    The Lmsgprefix flag moves the logger's prefix from the
    beginning of the line to after the log header. For example,
    a logger with the prefix "LOG " and LstdFlags would output:
    
        LOG 2009/11/10 23:00:00 entry text
    
    Adding the Lmsgprefix flag would output:
    
        2009/11/10 23:00:00 LOG entry text
    
    Fixes #32062
    
    Change-Id: I9f7c9739abeb53c424112aaeed33444eeefdfbbc
    Reviewed-on: https://go-review.googlesource.com/c/go/+/186182
    Run-TryBot: Rob Pike <r@golang.org>
    TryBot-Result: Gobot Gobot <gobot@golang.org>
    Reviewed-by: Rob Pike <r@golang.org>
---
 src/log/log.go      | 23 ++++++++++++++++-------
 src/log/log_test.go |  5 ++++-
 2 files changed, 20 insertions(+), 8 deletions(-)

diff --git a/src/log/log.go b/src/log/log.go
index 12a9e7b8ce..1bf39ae9a3 100644
--- a/src/log/log.go
+++ b/src/log/log.go
@@ -25,8 +25,9 @@ import (
 
 // These flags define which text to prefix to each log entry generated by the Logger.
 // Bits are or'ed together to control what's printed.
-// There is no control over the order they appear (the order listed
-// here) or the format they present (as described in the comments).
+// With the exception of the Lmsgprefix flag, there is no
+// control over the order they appear (the order listed here)
+// or the format they present (as described in the comments).
 // The prefix is followed by a colon only when Llongfile or Lshortfile
 // is specified.
 // For example, flags Ldate | Ltime (or LstdFlags) produce,
@@ -40,6 +41,7 @@ const (
 	Llongfile                     // full file name and line number: /a/b/c/d.go:23
 	Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile
 	LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone
+	Lmsgprefix                    // move the "prefix" from the beginning of the line to before the message
 	LstdFlags     = Ldate | Ltime // initial values for the standard logger
 )
 
@@ -49,7 +51,7 @@ const (
 // multiple goroutines; it guarantees to serialize access to the Writer.
 type Logger struct {
 	mu     sync.Mutex // ensures atomic writes; protects the following fields
-	prefix string     // prefix to write at beginning of each line
+	prefix string     // prefix on each line to identify the logger (but see Lmsgprefix)
 	flag   int        // properties
 	out    io.Writer  // destination for output
 	buf    []byte     // for accumulating text to write
@@ -57,7 +59,8 @@ type Logger struct {
 
 // New creates a new Logger. The out variable sets the
 // destination to which log data will be written.
-// The prefix appears at the beginning of each generated log line.
+// The prefix appears at the beginning of each generated log line, or
+// after the log header if the Lmsgprefix flag is provided.
 // The flag argument defines the logging properties.
 func New(out io.Writer, prefix string, flag int) *Logger {
 	return &Logger{out: out, prefix: prefix, flag: flag}
@@ -90,11 +93,14 @@ func itoa(buf *[]byte, i int, wid int) {
 }
 
 // formatHeader writes log header to buf in following order:
-//   * l.prefix (if it's not blank),
+//   * l.prefix (if it's not blank and Lmsgprefix is unset),
 //   * date and/or time (if corresponding flags are provided),
-//   * file and line number (if corresponding flags are provided).
+//   * file and line number (if corresponding flags are provided),
+//   * l.prefix (if it's not blank and Lmsgprefix is set).
 func (l *Logger) formatHeader(buf *[]byte, t time.Time, file string, line int) {
-	*buf = append(*buf, l.prefix...)
+	if l.flag&Lmsgprefix == 0 {
+		*buf = append(*buf, l.prefix...)
+	}
 	if l.flag&(Ldate|Ltime|Lmicroseconds) != 0 {
 		if l.flag&LUTC != 0 {
 			t = t.UTC()
@@ -138,6 +144,9 @@ func (l *Logger) formatHeader(buf *[]byte, t time.Time, file string, line int) {
 		itoa(buf, line, -1)
 		*buf = append(*buf, ": "...)
 	}
+	if l.flag&Lmsgprefix != 0 {
+		*buf = append(*buf, l.prefix...)
+	}
 }
 
 // Output writes the output for a logging event. The string s contains
diff --git a/src/log/log_test.go b/src/log/log_test.go
index b79251877e..cdccbc554d 100644
--- a/src/log/log_test.go
+++ b/src/log/log_test.go
@@ -20,7 +20,7 @@ const (
 	Rdate         = `[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9]`
 	Rtime         = `[0-9][0-9]:[0-9][0-9]:[0-9][0-9]`
 	Rmicroseconds = `\.[0-9][0-9][0-9][0-9][0-9][0-9]`
-	Rline         = `(57|59):` // must update if the calls to l.Printf / l.Print below move
+	Rline         = `(60|62):` // must update if the calls to l.Printf / l.Print below move
 	Rlongfile     = `.*/[A-Za-z0-9_\-]+\.go:` + Rline
 	Rshortfile    = `[A-Za-z0-9_\-]+\.go:` + Rline
 )
@@ -37,6 +37,7 @@ var tests = []tester{
 	{0, "XXX", "XXX"},
 	{Ldate, "", Rdate + " "},
 	{Ltime, "", Rtime + " "},
+	{Ltime | Lmsgprefix, "XXX", Rtime + " XXX"},
 	{Ltime | Lmicroseconds, "", Rtime + Rmicroseconds + " "},
 	{Lmicroseconds, "", Rtime + Rmicroseconds + " "}, // microsec implies time
 	{Llongfile, "", Rlongfile + " "},
@@ -45,6 +46,8 @@ var tests = []tester{
 	// everything at once:
 	{Ldate | Ltime | Lmicroseconds | Llongfile, "XXX", "XXX" + Rdate + " " + Rtime + Rmicroseconds + " " + Rlongfile + " "},
 	{Ldate | Ltime | Lmicroseconds | Lshortfile, "XXX", "XXX" + Rdate + " " + Rtime + Rmicroseconds + " " + Rshortfile + " "},
+	{Ldate | Ltime | Lmicroseconds | Llongfile | Lmsgprefix, "XXX", Rdate + " " + Rtime + Rmicroseconds + " " + Rlongfile + " XXX"},
+	{Ldate | Ltime | Lmicroseconds | Lshortfile | Lmsgprefix, "XXX", Rdate + " " + Rtime + Rmicroseconds + " " + Rshortfile + " XXX"},
 }
 
 // Test using Println("hello", 23, "world") or using Printf("hello %d world", 23)
