commit 2db1769d7b3119278ade0741502f20c6df73a4b6
Author: Adam Langley <agl@golang.org>
Date:   Tue Apr 5 15:23:40 2011 -0400

    crypto/block: remove deprecated package.
    
    R=rsc
    CC=golang-dev
    https://golang.org/cl/4315051
---
 src/pkg/Makefile                      |   1 -
 src/pkg/crypto/block/Makefile         |  19 ---
 src/pkg/crypto/block/cbc.go           |  71 --------
 src/pkg/crypto/block/cfb.go           |  96 -----------
 src/pkg/crypto/block/cfb_aes_test.go  | 311 ----------------------------------
 src/pkg/crypto/block/cipher.go        |  57 -------
 src/pkg/crypto/block/cmac.go          | 105 ------------
 src/pkg/crypto/block/cmac_aes_test.go | 130 --------------
 src/pkg/crypto/block/ctr.go           |  67 --------
 src/pkg/crypto/block/eax.go           | 253 ---------------------------
 src/pkg/crypto/block/eax_aes_test.go  | 140 ---------------
 src/pkg/crypto/block/ecb.go           | 270 -----------------------------
 src/pkg/crypto/block/ecb_aes_test.go  | 127 --------------
 src/pkg/crypto/block/ecb_test.go      | 181 --------------------
 src/pkg/crypto/block/ofb.go           |  60 -------
 src/pkg/crypto/block/ofb_aes_test.go  | 108 ------------
 src/pkg/crypto/block/xor.go           | 124 --------------
 src/pkg/crypto/block/xor_test.go      | 168 ------------------
 18 files changed, 2288 deletions(-)

diff --git a/src/pkg/Makefile b/src/pkg/Makefile
index 7fc45e5b67..0b45772500 100644
--- a/src/pkg/Makefile
+++ b/src/pkg/Makefile
@@ -32,7 +32,6 @@ DIRS=\
 	container/vector\
 	crypto\
 	crypto/aes\
-	crypto/block\
 	crypto/blowfish\
 	crypto/cast5\
 	crypto/cipher\
diff --git a/src/pkg/crypto/block/Makefile b/src/pkg/crypto/block/Makefile
deleted file mode 100644
index 71c7aff640..0000000000
--- a/src/pkg/crypto/block/Makefile
+++ /dev/null
@@ -1,19 +0,0 @@
-# Copyright 2009 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-include ../../../Make.inc
-
-TARG=crypto/block
-GOFILES=\
-	cbc.go\
-	cfb.go\
-	cipher.go\
-	cmac.go\
-	ctr.go\
-	eax.go\
-	ecb.go\
-	ofb.go\
-	xor.go\
-
-include ../../../Make.pkg
diff --git a/src/pkg/crypto/block/cbc.go b/src/pkg/crypto/block/cbc.go
deleted file mode 100644
index 23229c09f7..0000000000
--- a/src/pkg/crypto/block/cbc.go
+++ /dev/null
@@ -1,71 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Cipher block chaining (CBC) mode.
-
-// CBC provides confidentiality by xoring (chaining) each plaintext block
-// with the previous ciphertext block before applying the block cipher.
-
-// See NIST SP 800-38A, pp 10-11
-
-package block
-
-import (
-	"io"
-)
-
-type cbcCipher struct {
-	c         Cipher
-	blockSize int
-	iv        []byte
-	tmp       []byte
-}
-
-func newCBC(c Cipher, iv []byte) *cbcCipher {
-	n := c.BlockSize()
-	x := new(cbcCipher)
-	x.c = c
-	x.blockSize = n
-	x.iv = dup(iv)
-	x.tmp = make([]byte, n)
-	return x
-}
-
-func (x *cbcCipher) BlockSize() int { return x.blockSize }
-
-func (x *cbcCipher) Encrypt(dst, src []byte) {
-	for i := 0; i < x.blockSize; i++ {
-		x.iv[i] ^= src[i]
-	}
-	x.c.Encrypt(x.iv, x.iv)
-	for i := 0; i < x.blockSize; i++ {
-		dst[i] = x.iv[i]
-	}
-}
-
-func (x *cbcCipher) Decrypt(dst, src []byte) {
-	x.c.Decrypt(x.tmp, src)
-	for i := 0; i < x.blockSize; i++ {
-		x.tmp[i] ^= x.iv[i]
-		x.iv[i] = src[i]
-		dst[i] = x.tmp[i]
-	}
-}
-
-// NewCBCDecrypter returns a reader that reads data from r and decrypts it using c
-// in cipher block chaining (CBC) mode with the initialization vector iv.
-// The returned Reader does not buffer or read ahead except
-// as required by the cipher's block size.
-func NewCBCDecrypter(c Cipher, iv []byte, r io.Reader) io.Reader {
-	return NewECBDecrypter(newCBC(c, iv), r)
-}
-
-// NewCBCEncrypter returns a writer that encrypts data using c
-// in cipher block chaining (CBC) mode with the initialization vector iv
-// and writes the encrypted data to w.
-// The returned Writer does no buffering except as required
-// by the cipher's block size, so there is no need for a Flush method.
-func NewCBCEncrypter(c Cipher, iv []byte, w io.Writer) io.Writer {
-	return NewECBEncrypter(newCBC(c, iv), w)
-}
diff --git a/src/pkg/crypto/block/cfb.go b/src/pkg/crypto/block/cfb.go
deleted file mode 100644
index f20c0a04f6..0000000000
--- a/src/pkg/crypto/block/cfb.go
+++ /dev/null
@@ -1,96 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Cipher feedback (CFB) mode.
-
-// CFB provides confidentiality by feeding a fraction of
-// the previous ciphertext in as the plaintext for the next
-// block operation.
-
-// See NIST SP 800-38A, pp 11-13
-
-package block
-
-import (
-	"io"
-)
-
-type cfbCipher struct {
-	c          Cipher
-	blockSize  int // our block size (s/8)
-	cipherSize int // underlying cipher block size
-	iv         []byte
-	tmp        []byte
-}
-
-func newCFB(c Cipher, s int, iv []byte) *cfbCipher {
-	if s == 0 || s%8 != 0 {
-		panic("crypto/block: invalid CFB mode")
-	}
-	b := c.BlockSize()
-	x := new(cfbCipher)
-	x.c = c
-	x.blockSize = s / 8
-	x.cipherSize = b
-	x.iv = dup(iv)
-	x.tmp = make([]byte, b)
-	return x
-}
-
-func (x *cfbCipher) BlockSize() int { return x.blockSize }
-
-func (x *cfbCipher) Encrypt(dst, src []byte) {
-	// Encrypt old IV and xor prefix with src to make dst.
-	x.c.Encrypt(x.tmp, x.iv)
-	for i := 0; i < x.blockSize; i++ {
-		dst[i] = src[i] ^ x.tmp[i]
-	}
-
-	// Slide unused IV pieces down and insert dst at end.
-	for i := 0; i < x.cipherSize-x.blockSize; i++ {
-		x.iv[i] = x.iv[i+x.blockSize]
-	}
-	off := x.cipherSize - x.blockSize
-	for i := off; i < x.cipherSize; i++ {
-		x.iv[i] = dst[i-off]
-	}
-}
-
-func (x *cfbCipher) Decrypt(dst, src []byte) {
-	// Encrypt [sic] old IV and xor prefix with src to make dst.
-	x.c.Encrypt(x.tmp, x.iv)
-	for i := 0; i < x.blockSize; i++ {
-		dst[i] = src[i] ^ x.tmp[i]
-	}
-
-	// Slide unused IV pieces down and insert src at top.
-	for i := 0; i < x.cipherSize-x.blockSize; i++ {
-		x.iv[i] = x.iv[i+x.blockSize]
-	}
-	off := x.cipherSize - x.blockSize
-	for i := off; i < x.cipherSize; i++ {
-		// Reconstruct src = dst ^ x.tmp
-		// in case we overwrote src (src == dst).
-		x.iv[i] = dst[i-off] ^ x.tmp[i-off]
-	}
-}
-
-// NewCFBDecrypter returns a reader that reads data from r and decrypts it using c
-// in s-bit cipher feedback (CFB) mode with the initialization vector iv.
-// The returned Reader does not buffer or read ahead except
-// as required by the cipher's block size.
-// Modes for s not a multiple of 8 are unimplemented.
-func NewCFBDecrypter(c Cipher, s int, iv []byte, r io.Reader) io.Reader {
-	return NewECBDecrypter(newCFB(c, s, iv), r)
-}
-
-// NewCFBEncrypter returns a writer that encrypts data using c
-// in s-bit cipher feedback (CFB) mode with the initialization vector iv
-// and writes the encrypted data to w.
-// The returned Writer does no buffering except as required
-// by the cipher's block size, so there is no need for a Flush method.
-// Modes for s not a multiple of 8 are unimplemented.
-func NewCFBEncrypter(c Cipher, s int, iv []byte, w io.Writer) io.Writer {
-	return NewECBEncrypter(newCFB(c, s, iv), w)
-}
diff --git a/src/pkg/crypto/block/cfb_aes_test.go b/src/pkg/crypto/block/cfb_aes_test.go
deleted file mode 100644
index e400c182a2..0000000000
--- a/src/pkg/crypto/block/cfb_aes_test.go
+++ /dev/null
@@ -1,311 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// CFB AES test vectors.
-
-// See U.S. National Institute of Standards and Technology (NIST)
-// Special Publication 800-38A, ``Recommendation for Block Cipher
-// Modes of Operation,'' 2001 Edition, pp. 29-52.
-
-package block
-
-import (
-	"bytes"
-	"crypto/aes"
-	"io"
-	"testing"
-)
-
-type cfbTest struct {
-	name string
-	s    int
-	key  []byte
-	iv   []byte
-	in   []byte
-	out  []byte
-}
-
-var cfbAESTests = []cfbTest{
-	{
-		"CFB1-AES128",
-		1,
-		commonKey128,
-		commonIV,
-		[]byte{
-			0<<7 | 1<<6 | 1<<5 | 0<<4 | 1<<3 | 0<<2 | 1<<1,
-			1<<7 | 1<<6 | 0<<5 | 0<<4 | 0<<3 | 0<<2 | 0<<1,
-		},
-		[]byte{
-			0<<7 | 1<<6 | 1<<5 | 0<<4 | 1<<3 | 0<<2 | 0<<1,
-			1<<7 | 0<<6 | 1<<5 | 1<<4 | 0<<3 | 0<<2 | 1<<1,
-		},
-	},
-	{
-		"CFB1-AES192",
-		1,
-		commonKey192,
-		commonIV,
-		[]byte{
-			0<<7 | 1<<6 | 1<<5 | 0<<4 | 1<<3 | 0<<2 | 1<<1,
-			1<<7 | 1<<6 | 0<<5 | 0<<4 | 0<<3 | 0<<2 | 0<<1,
-		},
-		[]byte{
-			1<<7 | 0<<6 | 0<<5 | 1<<4 | 0<<3 | 0<<2 | 1<<1,
-			0<<7 | 1<<6 | 0<<5 | 1<<4 | 1<<3 | 0<<2 | 0<<1,
-		},
-	},
-	{
-		"CFB1-AES256",
-		1,
-		commonKey256,
-		commonIV,
-		[]byte{
-			0<<7 | 1<<6 | 1<<5 | 0<<4 | 1<<3 | 0<<2 | 1<<1,
-			1<<7 | 1<<6 | 0<<5 | 0<<4 | 0<<3 | 0<<2 | 0<<1,
-		},
-		[]byte{
-			1<<7 | 0<<6 | 0<<5 | 1<<4 | 0<<3 | 0<<2 | 0<<1,
-			0<<7 | 0<<6 | 1<<5 | 0<<4 | 1<<3 | 0<<2 | 0<<1,
-		},
-	},
-
-	{
-		"CFB8-AES128",
-		8,
-		commonKey128,
-		commonIV,
-		[]byte{
-			0x6b,
-			0xc1,
-			0xbe,
-			0xe2,
-			0x2e,
-			0x40,
-			0x9f,
-			0x96,
-			0xe9,
-			0x3d,
-			0x7e,
-			0x11,
-			0x73,
-			0x93,
-			0x17,
-			0x2a,
-			0xae,
-			0x2d,
-		},
-		[]byte{
-			0x3b,
-			0x79,
-			0x42,
-			0x4c,
-			0x9c,
-			0x0d,
-			0xd4,
-			0x36,
-			0xba,
-			0xce,
-			0x9e,
-			0x0e,
-			0xd4,
-			0x58,
-			0x6a,
-			0x4f,
-			0x32,
-			0xb9,
-		},
-	},
-
-	{
-		"CFB8-AES192",
-		8,
-		commonKey192,
-		commonIV,
-		[]byte{
-			0x6b,
-			0xc1,
-			0xbe,
-			0xe2,
-			0x2e,
-			0x40,
-			0x9f,
-			0x96,
-			0xe9,
-			0x3d,
-			0x7e,
-			0x11,
-			0x73,
-			0x93,
-			0x17,
-			0x2a,
-			0xae,
-			0x2d,
-		},
-		[]byte{
-			0xcd,
-			0xa2,
-			0x52,
-			0x1e,
-			0xf0,
-			0xa9,
-			0x05,
-			0xca,
-			0x44,
-			0xcd,
-			0x05,
-			0x7c,
-			0xbf,
-			0x0d,
-			0x47,
-			0xa0,
-			0x67,
-			0x8a,
-		},
-	},
-
-	{
-		"CFB8-AES256",
-		8,
-		commonKey256,
-		commonIV,
-		[]byte{
-			0x6b,
-			0xc1,
-			0xbe,
-			0xe2,
-			0x2e,
-			0x40,
-			0x9f,
-			0x96,
-			0xe9,
-			0x3d,
-			0x7e,
-			0x11,
-			0x73,
-			0x93,
-			0x17,
-			0x2a,
-			0xae,
-			0x2d,
-		},
-		[]byte{
-			0xdc,
-			0x1f,
-			0x1a,
-			0x85,
-			0x20,
-			0xa6,
-			0x4d,
-			0xb5,
-			0x5f,
-			0xcc,
-			0x8a,
-			0xc5,
-			0x54,
-			0x84,
-			0x4e,
-			0x88,
-			0x97,
-			0x00,
-		},
-	},
-
-	{
-		"CFB128-AES128",
-		128,
-		commonKey128,
-		commonIV,
-		[]byte{
-			0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
-			0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
-			0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
-			0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10,
-		},
-		[]byte{
-			0x3b, 0x3f, 0xd9, 0x2e, 0xb7, 0x2d, 0xad, 0x20, 0x33, 0x34, 0x49, 0xf8, 0xe8, 0x3c, 0xfb, 0x4a,
-			0xc8, 0xa6, 0x45, 0x37, 0xa0, 0xb3, 0xa9, 0x3f, 0xcd, 0xe3, 0xcd, 0xad, 0x9f, 0x1c, 0xe5, 0x8b,
-			0x26, 0x75, 0x1f, 0x67, 0xa3, 0xcb, 0xb1, 0x40, 0xb1, 0x80, 0x8c, 0xf1, 0x87, 0xa4, 0xf4, 0xdf,
-			0xc0, 0x4b, 0x05, 0x35, 0x7c, 0x5d, 0x1c, 0x0e, 0xea, 0xc4, 0xc6, 0x6f, 0x9f, 0xf7, 0xf2, 0xe6,
-		},
-	},
-
-	{
-		"CFB128-AES192",
-		128,
-		commonKey192,
-		commonIV,
-		[]byte{
-			0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
-			0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
-			0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
-			0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10,
-		},
-		[]byte{
-			0xcd, 0xc8, 0x0d, 0x6f, 0xdd, 0xf1, 0x8c, 0xab, 0x34, 0xc2, 0x59, 0x09, 0xc9, 0x9a, 0x41, 0x74,
-			0x67, 0xce, 0x7f, 0x7f, 0x81, 0x17, 0x36, 0x21, 0x96, 0x1a, 0x2b, 0x70, 0x17, 0x1d, 0x3d, 0x7a,
-			0x2e, 0x1e, 0x8a, 0x1d, 0xd5, 0x9b, 0x88, 0xb1, 0xc8, 0xe6, 0x0f, 0xed, 0x1e, 0xfa, 0xc4, 0xc9,
-			0xc0, 0x5f, 0x9f, 0x9c, 0xa9, 0x83, 0x4f, 0xa0, 0x42, 0xae, 0x8f, 0xba, 0x58, 0x4b, 0x09, 0xff,
-		},
-	},
-
-	{
-		"CFB128-AES256",
-		128,
-		commonKey256,
-		commonIV,
-		[]byte{
-			0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
-			0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
-			0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
-			0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10,
-		},
-		[]byte{
-			0xdc, 0x7e, 0x84, 0xbf, 0xda, 0x79, 0x16, 0x4b, 0x7e, 0xcd, 0x84, 0x86, 0x98, 0x5d, 0x38, 0x60,
-			0x39, 0xff, 0xed, 0x14, 0x3b, 0x28, 0xb1, 0xc8, 0x32, 0x11, 0x3c, 0x63, 0x31, 0xe5, 0x40, 0x7b,
-			0xdf, 0x10, 0x13, 0x24, 0x15, 0xe5, 0x4b, 0x92, 0xa1, 0x3e, 0xd0, 0xa8, 0x26, 0x7a, 0xe2, 0xf9,
-			0x75, 0xa3, 0x85, 0x74, 0x1a, 0xb9, 0xce, 0xf8, 0x20, 0x31, 0x62, 0x3d, 0x55, 0xb1, 0xe4, 0x71,
-		},
-	},
-}
-
-func TestCFB_AES(t *testing.T) {
-	for _, tt := range cfbAESTests {
-		test := tt.name
-
-		if tt.s == 1 {
-			// 1-bit CFB not implemented
-			continue
-		}
-
-		c, err := aes.NewCipher(tt.key)
-		if err != nil {
-			t.Errorf("%s: NewCipher(%d bytes) = %s", test, len(tt.key), err)
-			continue
-		}
-
-		var crypt bytes.Buffer
-		w := NewCFBEncrypter(c, tt.s, tt.iv, &crypt)
-		var r io.Reader = bytes.NewBuffer(tt.in)
-		n, err := io.Copy(w, r)
-		if n != int64(len(tt.in)) || err != nil {
-			t.Errorf("%s: CFBEncrypter io.Copy = %d, %v want %d, nil", test, n, err, len(tt.in))
-		} else if d := crypt.Bytes(); !same(tt.out, d) {
-			t.Errorf("%s: CFBEncrypter\nhave %x\nwant %x", test, d, tt.out)
-		}
-
-		var plain bytes.Buffer
-		r = NewCFBDecrypter(c, tt.s, tt.iv, bytes.NewBuffer(tt.out))
-		w = &plain
-		n, err = io.Copy(w, r)
-		if n != int64(len(tt.out)) || err != nil {
-			t.Errorf("%s: CFBDecrypter io.Copy = %d, %v want %d, nil", test, n, err, len(tt.out))
-		} else if d := plain.Bytes(); !same(tt.in, d) {
-			t.Errorf("%s: CFBDecrypter\nhave %x\nwant %x", test, d, tt.in)
-		}
-
-		if t.Failed() {
-			break
-		}
-	}
-}
diff --git a/src/pkg/crypto/block/cipher.go b/src/pkg/crypto/block/cipher.go
deleted file mode 100644
index e1099e9a10..0000000000
--- a/src/pkg/crypto/block/cipher.go
+++ /dev/null
@@ -1,57 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// The block package is deprecated, use cipher instead.
-// The block package implements standard block cipher modes
-// that can be wrapped around low-level block cipher implementations.
-// See http://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html
-// and NIST Special Publication 800-38A.
-package block
-
-// A Cipher represents an implementation of block cipher
-// using a given key.  It provides the capability to encrypt
-// or decrypt individual blocks.  The mode implementations
-// extend that capability to streams of blocks.
-type Cipher interface {
-	// BlockSize returns the cipher's block size.
-	BlockSize() int
-
-	// Encrypt encrypts the first block in src into dst.
-	// Src and dst may point at the same memory.
-	Encrypt(dst, src []byte)
-
-	// Decrypt decrypts the first block in src into dst.
-	// Src and dst may point at the same memory.
-	Decrypt(dst, src []byte)
-}
-
-// Utility routines
-
-func shift1(dst, src []byte) byte {
-	var b byte
-	for i := len(src) - 1; i >= 0; i-- {
-		bb := src[i] >> 7
-		dst[i] = src[i]<<1 | b
-		b = bb
-	}
-	return b
-}
-
-func same(p, q []byte) bool {
-	if len(p) != len(q) {
-		return false
-	}
-	for i := 0; i < len(p); i++ {
-		if p[i] != q[i] {
-			return false
-		}
-	}
-	return true
-}
-
-func dup(p []byte) []byte {
-	q := make([]byte, len(p))
-	copy(q, p)
-	return q
-}
diff --git a/src/pkg/crypto/block/cmac.go b/src/pkg/crypto/block/cmac.go
deleted file mode 100644
index b85cde72e1..0000000000
--- a/src/pkg/crypto/block/cmac.go
+++ /dev/null
@@ -1,105 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// CMAC message authentication code, defined in
-// NIST Special Publication SP 800-38B.
-
-package block
-
-import (
-	"hash"
-	"os"
-)
-
-const (
-	// minimal irreducible polynomial of degree b
-	r64  = 0x1b
-	r128 = 0x87
-)
-
-type cmac struct {
-	k1, k2, ci, digest []byte
-	p                  int // position in ci
-	c                  Cipher
-}
-
-// TODO(rsc): Should this return an error instead of panic?
-
-// NewCMAC returns a new instance of a CMAC message authentication code
-// digest using the given Cipher.
-func NewCMAC(c Cipher) hash.Hash {
-	var r byte
-	n := c.BlockSize()
-	switch n {
-	case 64 / 8:
-		r = r64
-	case 128 / 8:
-		r = r128
-	default:
-		panic("crypto/block: NewCMAC: invalid cipher block size")
-	}
-
-	d := new(cmac)
-	d.c = c
-	d.k1 = make([]byte, n)
-	d.k2 = make([]byte, n)
-	d.ci = make([]byte, n)
-	d.digest = make([]byte, n)
-
-	// Subkey generation, p. 7
-	c.Encrypt(d.k1, d.k1)
-	if shift1(d.k1, d.k1) != 0 {
-		d.k1[n-1] ^= r
-	}
-	if shift1(d.k2, d.k1) != 0 {
-		d.k2[n-1] ^= r
-	}
-
-	return d
-}
-
-// Reset clears the digest state, starting a new digest.
-func (d *cmac) Reset() {
-	for i := range d.ci {
-		d.ci[i] = 0
-	}
-	d.p = 0
-}
-
-// Write adds the given data to the digest state.
-func (d *cmac) Write(p []byte) (n int, err os.Error) {
-	// Xor input into ci.
-	for _, c := range p {
-		// If ci is full, encrypt and start over.
-		if d.p >= len(d.ci) {
-			d.c.Encrypt(d.ci, d.ci)
-			d.p = 0
-		}
-		d.ci[d.p] ^= c
-		d.p++
-	}
-	return len(p), nil
-}
-
-// Sum returns the CMAC digest, one cipher block in length,
-// of the data written with Write.
-func (d *cmac) Sum() []byte {
-	// Finish last block, mix in key, encrypt.
-	// Don't edit ci, in case caller wants
-	// to keep digesting after call to Sum.
-	k := d.k1
-	if d.p < len(d.digest) {
-		k = d.k2
-	}
-	for i := 0; i < len(d.ci); i++ {
-		d.digest[i] = d.ci[i] ^ k[i]
-	}
-	if d.p < len(d.digest) {
-		d.digest[d.p] ^= 0x80
-	}
-	d.c.Encrypt(d.digest, d.digest)
-	return d.digest
-}
-
-func (d *cmac) Size() int { return len(d.digest) }
diff --git a/src/pkg/crypto/block/cmac_aes_test.go b/src/pkg/crypto/block/cmac_aes_test.go
deleted file mode 100644
index 0a4a1a418e..0000000000
--- a/src/pkg/crypto/block/cmac_aes_test.go
+++ /dev/null
@@ -1,130 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// CMAC test vectors.  See NIST SP 800-38B, Appendix D.
-
-package block
-
-import (
-	"crypto/aes"
-	"testing"
-)
-
-type cmacAESTest struct {
-	key    []byte
-	in     []byte
-	digest []byte
-}
-
-var cmacAESTests = []cmacAESTest{
-	{
-		commonKey128,
-		nil,
-		[]byte{0xbb, 0x1d, 0x69, 0x29, 0xe9, 0x59, 0x37, 0x28, 0x7f, 0xa3, 0x7d, 0x12, 0x9b, 0x75, 0x67, 0x46},
-	},
-	{
-		commonKey128,
-		[]byte{0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a},
-		[]byte{0x07, 0x0a, 0x16, 0xb4, 0x6b, 0x4d, 0x41, 0x44, 0xf7, 0x9b, 0xdd, 0x9d, 0xd0, 0x4a, 0x28, 0x7c},
-	},
-	{
-		commonKey128,
-		[]byte{
-			0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
-			0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
-			0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
-		},
-		[]byte{0xdf, 0xa6, 0x67, 0x47, 0xde, 0x9a, 0xe6, 0x30, 0x30, 0xca, 0x32, 0x61, 0x14, 0x97, 0xc8, 0x27},
-	},
-	{
-		commonKey128,
-		[]byte{
-			0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
-			0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
-			0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
-			0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10,
-		},
-		[]byte{0x51, 0xf0, 0xbe, 0xbf, 0x7e, 0x3b, 0x9d, 0x92, 0xfc, 0x49, 0x74, 0x17, 0x79, 0x36, 0x3c, 0xfe},
-	},
-	{
-		commonKey192,
-		nil,
-		[]byte{0xd1, 0x7d, 0xdf, 0x46, 0xad, 0xaa, 0xcd, 0xe5, 0x31, 0xca, 0xc4, 0x83, 0xde, 0x7a, 0x93, 0x67},
-	},
-	{
-		commonKey192,
-		[]byte{0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a},
-		[]byte{0x9e, 0x99, 0xa7, 0xbf, 0x31, 0xe7, 0x10, 0x90, 0x06, 0x62, 0xf6, 0x5e, 0x61, 0x7c, 0x51, 0x84},
-	},
-	{
-		commonKey192,
-		[]byte{
-			0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
-			0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
-			0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
-		},
-		[]byte{0x8a, 0x1d, 0xe5, 0xbe, 0x2e, 0xb3, 0x1a, 0xad, 0x08, 0x9a, 0x82, 0xe6, 0xee, 0x90, 0x8b, 0x0e},
-	},
-	{
-		commonKey192,
-		[]byte{
-			0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
-			0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
-			0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
-			0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10,
-		},
-		[]byte{0xa1, 0xd5, 0xdf, 0x0e, 0xed, 0x79, 0x0f, 0x79, 0x4d, 0x77, 0x58, 0x96, 0x59, 0xf3, 0x9a, 0x11},
-	},
-	{
-		commonKey256,
-		nil,
-		[]byte{0x02, 0x89, 0x62, 0xf6, 0x1b, 0x7b, 0xf8, 0x9e, 0xfc, 0x6b, 0x55, 0x1f, 0x46, 0x67, 0xd9, 0x83},
-	},
-	{
-		commonKey256,
-		[]byte{0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a},
-		[]byte{0x28, 0xa7, 0x02, 0x3f, 0x45, 0x2e, 0x8f, 0x82, 0xbd, 0x4b, 0xf2, 0x8d, 0x8c, 0x37, 0xc3, 0x5c},
-	},
-	{
-		commonKey256,
-		[]byte{
-			0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
-			0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
-			0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
-		},
-		[]byte{0xaa, 0xf3, 0xd8, 0xf1, 0xde, 0x56, 0x40, 0xc2, 0x32, 0xf5, 0xb1, 0x69, 0xb9, 0xc9, 0x11, 0xe6},
-	},
-	{
-		commonKey256,
-		[]byte{
-			0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
-			0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
-			0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
-			0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10,
-		},
-		[]byte{0xe1, 0x99, 0x21, 0x90, 0x54, 0x9f, 0x6e, 0xd5, 0x69, 0x6a, 0x2c, 0x05, 0x6c, 0x31, 0x54, 0x10},
-	},
-}
-
-func TestCMAC_AES(t *testing.T) {
-	for i, tt := range cmacAESTests {
-		c, err := aes.NewCipher(tt.key)
-		if err != nil {
-			t.Errorf("test %d: NewCipher: %s", i, err)
-			continue
-		}
-		d := NewCMAC(c)
-		n, err := d.Write(tt.in)
-		if err != nil || n != len(tt.in) {
-			t.Errorf("test %d: Write %d: %d, %s", i, len(tt.in), n, err)
-			continue
-		}
-		sum := d.Sum()
-		if !same(sum, tt.digest) {
-			x := d.(*cmac)
-			t.Errorf("test %d: digest mismatch\n\twant %x\n\thave %x\n\tk1 %x\n\tk2 %x", i, tt.digest, sum, x.k1, x.k2)
-			continue
-		}
-	}
-}
diff --git a/src/pkg/crypto/block/ctr.go b/src/pkg/crypto/block/ctr.go
deleted file mode 100644
index 5d65c0c9a9..0000000000
--- a/src/pkg/crypto/block/ctr.go
+++ /dev/null
@@ -1,67 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Counter (CTR) mode.
-
-// CTR converts a block cipher into a stream cipher by
-// repeatedly encrypting an incrementing counter and
-// xoring the resulting stream of data with the input.
-
-// See NIST SP 800-38A, pp 13-15
-
-package block
-
-import (
-	"io"
-)
-
-type ctrStream struct {
-	c   Cipher
-	ctr []byte
-	out []byte
-}
-
-func newCTRStream(c Cipher, ctr []byte) *ctrStream {
-	x := new(ctrStream)
-	x.c = c
-	x.ctr = dup(ctr)
-	x.out = make([]byte, len(ctr))
-	return x
-}
-
-func (x *ctrStream) Next() []byte {
-	// Next block is encryption of counter.
-	x.c.Encrypt(x.out, x.ctr)
-
-	// Increment counter
-	for i := len(x.ctr) - 1; i >= 0; i-- {
-		x.ctr[i]++
-		if x.ctr[i] != 0 {
-			break
-		}
-	}
-
-	return x.out
-}
-
-// NewCTRReader returns a reader that reads data from r, decrypts (or encrypts)
-// it using c in counter (CTR) mode with the initialization vector iv.
-// The returned Reader does not buffer and has no block size.
-// In CTR mode, encryption and decryption are the same operation:
-// a CTR reader applied to an encrypted stream produces a decrypted
-// stream and vice versa.
-func NewCTRReader(c Cipher, iv []byte, r io.Reader) io.Reader {
-	return newXorReader(newCTRStream(c, iv), r)
-}
-
-// NewCTRWriter returns a writer that encrypts (or decrypts) data using c
-// in counter (CTR) mode with the initialization vector iv
-// and writes the encrypted data to w.
-// The returned Writer does not buffer and has no block size.
-// In CTR mode, encryption and decryption are the same operation:
-// a CTR writer applied to an decrypted stream produces an encrypted
-// stream and vice versa.
-func NewCTRWriter(c Cipher, iv []byte, w io.Writer) io.Writer {
-	return newXorWriter(newCTRStream(c, iv), w)
-}
diff --git a/src/pkg/crypto/block/eax.go b/src/pkg/crypto/block/eax.go
deleted file mode 100644
index 3f3b96431e..0000000000
--- a/src/pkg/crypto/block/eax.go
+++ /dev/null
@@ -1,253 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// EAX mode, not a NIST standard (yet).
-// EAX provides encryption and authentication.
-// EAX targets the same uses as NIST's CCM mode,
-// but EAX adds the ability to run in streaming mode.
-
-// See
-// http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/eax/eax-spec.pdf
-// http://www.cs.ucdavis.edu/~rogaway/papers/eax.pdf
-// What those papers call OMAC is now called CMAC.
-
-package block
-
-import (
-	"fmt"
-	"hash"
-	"io"
-	"os"
-)
-
-// An EAXTagError is returned when the message has failed to authenticate,
-// because the tag at the end of the message stream (Read) does not match
-// the tag computed from the message itself (Computed).
-type EAXTagError struct {
-	Read     []byte
-	Computed []byte
-}
-
-func (e *EAXTagError) String() string {
-	return fmt.Sprintf("crypto/block: EAX tag mismatch: read %x but computed %x", e.Read, e.Computed)
-}
-
-func setupEAX(c Cipher, iv, hdr []byte, tagBytes int) (ctrIV, tag []byte, cmac hash.Hash) {
-	n := len(iv)
-	if n != c.BlockSize() {
-		panic(fmt.Sprintln("crypto/block: EAX: iv length", n, "!=", c.BlockSize()))
-	}
-	buf := make([]byte, n) // zeroed
-
-	// tag = CMAC(0 + iv) ^ CMAC(1 + hdr) ^ CMAC(2 + data)
-	cmac = NewCMAC(c)
-	cmac.Write(buf) // 0
-	cmac.Write(iv)
-	sum := cmac.Sum()
-	ctrIV = dup(sum)
-	tag = dup(sum[0:tagBytes])
-
-	cmac.Reset()
-	buf[n-1] = 1
-	cmac.Write(buf) // 1
-	cmac.Write(hdr)
-	sum = cmac.Sum()
-	for i := 0; i < tagBytes; i++ {
-		tag[i] ^= sum[i]
-	}
-
-	cmac.Reset()
-	buf[n-1] = 2 // 2
-	cmac.Write(buf)
-
-	return
-}
-
-func finishEAX(tag []byte, cmac hash.Hash) {
-	// Finish CMAC #2 and xor into tag.
-	sum := cmac.Sum()
-	for i := range tag {
-		tag[i] ^= sum[i]
-	}
-}
-
-// Writer adapter.  Tees writes into both w and cmac.
-// Knows that cmac never returns write errors.
-type cmacWriter struct {
-	w    io.Writer
-	cmac hash.Hash
-}
-
-func (cw *cmacWriter) Write(p []byte) (n int, err os.Error) {
-	n, err = cw.w.Write(p)
-	cw.cmac.Write(p[0:n])
-	return
-}
-
-// An eaxEncrypter implements the EAX encryption mode.
-type eaxEncrypter struct {
-	ctr io.Writer  // CTR encrypter
-	cw  cmacWriter // CTR's output stream
-	tag []byte
-}
-
-// NewEAXEncrypter creates and returns a new EAX encrypter
-// using the given cipher c, initialization vector iv, associated data hdr,
-// and tag length tagBytes.  The encrypter's Write method encrypts
-// the data it receives and writes that data to w.
-// The encrypter's Close method writes a final authenticating tag to w.
-func NewEAXEncrypter(c Cipher, iv []byte, hdr []byte, tagBytes int, w io.Writer) io.WriteCloser {
-	x := new(eaxEncrypter)
-
-	// Create new CTR instance writing to both
-	// w for encrypted output and cmac for digesting.
-	x.cw.w = w
-	var ctrIV []byte
-	ctrIV, x.tag, x.cw.cmac = setupEAX(c, iv, hdr, tagBytes)
-	x.ctr = NewCTRWriter(c, ctrIV, &x.cw)
-	return x
-}
-
-func (x *eaxEncrypter) Write(p []byte) (n int, err os.Error) {
-	return x.ctr.Write(p)
-}
-
-func (x *eaxEncrypter) Close() os.Error {
-	x.ctr = nil // crash if Write is called again
-
-	// Write tag.
-	finishEAX(x.tag, x.cw.cmac)
-	n, err := x.cw.w.Write(x.tag)
-	if n != len(x.tag) && err == nil {
-		err = io.ErrShortWrite
-	}
-
-	return err
-}
-
-// Reader adapter.  Returns data read from r but hangs
-// on to the last len(tag) bytes for itself (returns EOF len(tag)
-// bytes early).  Also tees all data returned from Read into
-// the cmac digest.  The "don't return the last t bytes"
-// and the "tee into digest" functionality could be separated,
-// but the latter half is trivial.
-type cmacReader struct {
-	r    io.Reader
-	cmac hash.Hash
-	tag  []byte
-	tmp  []byte
-}
-
-func (cr *cmacReader) Read(p []byte) (n int, err os.Error) {
-	// TODO(rsc): Maybe fall back to simpler code if
-	// we recognize the underlying r as a ByteBuffer
-	// or ByteReader.  Then we can just take the last piece
-	// off at the start.
-
-	// First, read a tag-sized chunk.
-	// It's probably not the tag (unless there's no data).
-	tag := cr.tag
-	if len(tag) < cap(tag) {
-		nt := len(tag)
-		nn, err1 := io.ReadFull(cr.r, tag[nt:cap(tag)])
-		tag = tag[0 : nt+nn]
-		cr.tag = tag
-		if err1 != nil {
-			return 0, err1
-		}
-	}
-
-	tagBytes := len(tag)
-	if len(p) > 4*tagBytes {
-		// If p is big, try to read directly into p to avoid a copy.
-		n, err = cr.r.Read(p[tagBytes:])
-		if n == 0 {
-			goto out
-		}
-		// copy old tag into p
-		for i := 0; i < tagBytes; i++ {
-			p[i] = tag[i]
-		}
-		// copy new tag out of p
-		for i := 0; i < tagBytes; i++ {
-			tag[i] = p[n+i]
-		}
-		goto out
-	}
-
-	// Otherwise, read into p and then slide data
-	n, err = cr.r.Read(p)
-	if n == 0 {
-		goto out
-	}
-
-	// copy tag+p into p+tmp and then swap tmp, tag
-	tmp := cr.tmp
-	for i := n + tagBytes - 1; i >= 0; i-- {
-		var c byte
-		if i < tagBytes {
-			c = tag[i]
-		} else {
-			c = p[i-tagBytes]
-		}
-		if i < n {
-			p[i] = c
-		} else {
-			tmp[i] = c
-		}
-	}
-	cr.tmp, cr.tag = tag, tmp
-
-out:
-	cr.cmac.Write(p[0:n])
-	return
-}
-
-type eaxDecrypter struct {
-	ctr io.Reader
-	cr  cmacReader
-	tag []byte
-}
-
-// NewEAXDecrypter creates and returns a new EAX decrypter
-// using the given cipher c, initialization vector iv, associated data hdr,
-// and tag length tagBytes.  The encrypter's Read method decrypts and
-// returns data read from r.  At r's EOF, the encrypter checks the final
-// authenticating tag and returns an EAXTagError if the tag is invalid.
-// In that case, the message should be discarded.
-// Note that the data stream returned from Read cannot be
-// assumed to be valid, authenticated data until Read returns
-// 0, nil to signal the end of the data.
-func NewEAXDecrypter(c Cipher, iv []byte, hdr []byte, tagBytes int, r io.Reader) io.Reader {
-	x := new(eaxDecrypter)
-
-	x.cr.r = r
-	x.cr.tag = make([]byte, 0, tagBytes)
-	x.cr.tmp = make([]byte, 0, tagBytes)
-	var ctrIV []byte
-	ctrIV, x.tag, x.cr.cmac = setupEAX(c, iv, hdr, tagBytes)
-	x.ctr = NewCTRReader(c, ctrIV, &x.cr)
-	return x
-}
-
-func (x *eaxDecrypter) checkTag() os.Error {
-	x.ctr = nil // crash if Read is called again
-
-	finishEAX(x.tag, x.cr.cmac)
-	if !same(x.tag, x.cr.tag) {
-		e := new(EAXTagError)
-		e.Computed = dup(x.tag)
-		e.Read = dup(x.cr.tag)
-		return e
-	}
-	return nil
-}
-
-func (x *eaxDecrypter) Read(p []byte) (n int, err os.Error) {
-	n, err = x.ctr.Read(p)
-	if n == 0 && err == nil {
-		err = x.checkTag()
-	}
-	return n, err
-}
diff --git a/src/pkg/crypto/block/eax_aes_test.go b/src/pkg/crypto/block/eax_aes_test.go
deleted file mode 100644
index 93aa771be8..0000000000
--- a/src/pkg/crypto/block/eax_aes_test.go
+++ /dev/null
@@ -1,140 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package block
-
-import (
-	"bytes"
-	"crypto/aes"
-	"fmt"
-	"io"
-	"testing"
-)
-
-// Test vectors from http://www.cs.ucdavis.edu/~rogaway/papers/eax.pdf
-
-type eaxAESTest struct {
-	msg    []byte
-	key    []byte
-	nonce  []byte
-	header []byte
-	cipher []byte
-}
-
-var eaxAESTests = []eaxAESTest{
-	{
-		[]byte{},
-		[]byte{0x23, 0x39, 0x52, 0xDE, 0xE4, 0xD5, 0xED, 0x5F, 0x9B, 0x9C, 0x6D, 0x6F, 0xF8, 0x0F, 0xF4, 0x78},
-		[]byte{0x62, 0xEC, 0x67, 0xF9, 0xC3, 0xA4, 0xA4, 0x07, 0xFC, 0xB2, 0xA8, 0xC4, 0x90, 0x31, 0xA8, 0xB3},
-		[]byte{0x6B, 0xFB, 0x91, 0x4F, 0xD0, 0x7E, 0xAE, 0x6B},
-		[]byte{0xE0, 0x37, 0x83, 0x0E, 0x83, 0x89, 0xF2, 0x7B, 0x02, 0x5A, 0x2D, 0x65, 0x27, 0xE7, 0x9D, 0x01},
-	},
-	{
-		[]byte{0xF7, 0xFB},
-		[]byte{0x91, 0x94, 0x5D, 0x3F, 0x4D, 0xCB, 0xEE, 0x0B, 0xF4, 0x5E, 0xF5, 0x22, 0x55, 0xF0, 0x95, 0xA4},
-		[]byte{0xBE, 0xCA, 0xF0, 0x43, 0xB0, 0xA2, 0x3D, 0x84, 0x31, 0x94, 0xBA, 0x97, 0x2C, 0x66, 0xDE, 0xBD},
-		[]byte{0xFA, 0x3B, 0xFD, 0x48, 0x06, 0xEB, 0x53, 0xFA},
-		[]byte{0x19, 0xDD, 0x5C, 0x4C, 0x93, 0x31, 0x04, 0x9D, 0x0B, 0xDA, 0xB0, 0x27, 0x74, 0x08, 0xF6, 0x79, 0x67, 0xE5},
-	},
-	{
-		[]byte{0x1A, 0x47, 0xCB, 0x49, 0x33},
-		[]byte{0x01, 0xF7, 0x4A, 0xD6, 0x40, 0x77, 0xF2, 0xE7, 0x04, 0xC0, 0xF6, 0x0A, 0xDA, 0x3D, 0xD5, 0x23},
-		[]byte{0x70, 0xC3, 0xDB, 0x4F, 0x0D, 0x26, 0x36, 0x84, 0x00, 0xA1, 0x0E, 0xD0, 0x5D, 0x2B, 0xFF, 0x5E},
-		[]byte{0x23, 0x4A, 0x34, 0x63, 0xC1, 0x26, 0x4A, 0xC6},
-		[]byte{0xD8, 0x51, 0xD5, 0xBA, 0xE0, 0x3A, 0x59, 0xF2, 0x38, 0xA2, 0x3E, 0x39, 0x19, 0x9D, 0xC9, 0x26, 0x66, 0x26, 0xC4, 0x0F, 0x80},
-	},
-	{
-		[]byte{0x48, 0x1C, 0x9E, 0x39, 0xB1},
-		[]byte{0xD0, 0x7C, 0xF6, 0xCB, 0xB7, 0xF3, 0x13, 0xBD, 0xDE, 0x66, 0xB7, 0x27, 0xAF, 0xD3, 0xC5, 0xE8},
-		[]byte{0x84, 0x08, 0xDF, 0xFF, 0x3C, 0x1A, 0x2B, 0x12, 0x92, 0xDC, 0x19, 0x9E, 0x46, 0xB7, 0xD6, 0x17},
-		[]byte{0x33, 0xCC, 0xE2, 0xEA, 0xBF, 0xF5, 0xA7, 0x9D},
-		[]byte{0x63, 0x2A, 0x9D, 0x13, 0x1A, 0xD4, 0xC1, 0x68, 0xA4, 0x22, 0x5D, 0x8E, 0x1F, 0xF7, 0x55, 0x93, 0x99, 0x74, 0xA7, 0xBE, 0xDE},
-	},
-	{
-		[]byte{0x40, 0xD0, 0xC0, 0x7D, 0xA5, 0xE4},
-		[]byte{0x35, 0xB6, 0xD0, 0x58, 0x00, 0x05, 0xBB, 0xC1, 0x2B, 0x05, 0x87, 0x12, 0x45, 0x57, 0xD2, 0xC2},
-		[]byte{0xFD, 0xB6, 0xB0, 0x66, 0x76, 0xEE, 0xDC, 0x5C, 0x61, 0xD7, 0x42, 0x76, 0xE1, 0xF8, 0xE8, 0x16},
-		[]byte{0xAE, 0xB9, 0x6E, 0xAE, 0xBE, 0x29, 0x70, 0xE9},
-		[]byte{0x07, 0x1D, 0xFE, 0x16, 0xC6, 0x75, 0xCB, 0x06, 0x77, 0xE5, 0x36, 0xF7, 0x3A, 0xFE, 0x6A, 0x14, 0xB7, 0x4E, 0xE4, 0x98, 0x44, 0xDD},
-	},
-	{
-		[]byte{0x4D, 0xE3, 0xB3, 0x5C, 0x3F, 0xC0, 0x39, 0x24, 0x5B, 0xD1, 0xFB, 0x7D},
-		[]byte{0xBD, 0x8E, 0x6E, 0x11, 0x47, 0x5E, 0x60, 0xB2, 0x68, 0x78, 0x4C, 0x38, 0xC6, 0x2F, 0xEB, 0x22},
-		[]byte{0x6E, 0xAC, 0x5C, 0x93, 0x07, 0x2D, 0x8E, 0x85, 0x13, 0xF7, 0x50, 0x93, 0x5E, 0x46, 0xDA, 0x1B},
-		[]byte{0xD4, 0x48, 0x2D, 0x1C, 0xA7, 0x8D, 0xCE, 0x0F},
-		[]byte{0x83, 0x5B, 0xB4, 0xF1, 0x5D, 0x74, 0x3E, 0x35, 0x0E, 0x72, 0x84, 0x14, 0xAB, 0xB8, 0x64, 0x4F, 0xD6, 0xCC, 0xB8, 0x69, 0x47, 0xC5, 0xE1, 0x05, 0x90, 0x21, 0x0A, 0x4F},
-	},
-	{
-		[]byte{0x8B, 0x0A, 0x79, 0x30, 0x6C, 0x9C, 0xE7, 0xED, 0x99, 0xDA, 0xE4, 0xF8, 0x7F, 0x8D, 0xD6, 0x16, 0x36},
-		[]byte{0x7C, 0x77, 0xD6, 0xE8, 0x13, 0xBE, 0xD5, 0xAC, 0x98, 0xBA, 0xA4, 0x17, 0x47, 0x7A, 0x2E, 0x7D},
-		[]byte{0x1A, 0x8C, 0x98, 0xDC, 0xD7, 0x3D, 0x38, 0x39, 0x3B, 0x2B, 0xF1, 0x56, 0x9D, 0xEE, 0xFC, 0x19},
-		[]byte{0x65, 0xD2, 0x01, 0x79, 0x90, 0xD6, 0x25, 0x28},
-		[]byte{0x02, 0x08, 0x3E, 0x39, 0x79, 0xDA, 0x01, 0x48, 0x12, 0xF5, 0x9F, 0x11, 0xD5, 0x26, 0x30, 0xDA, 0x30, 0x13, 0x73, 0x27, 0xD1, 0x06, 0x49, 0xB0, 0xAA, 0x6E, 0x1C, 0x18, 0x1D, 0xB6, 0x17, 0xD7, 0xF2},
-	},
-	{
-		[]byte{0x1B, 0xDA, 0x12, 0x2B, 0xCE, 0x8A, 0x8D, 0xBA, 0xF1, 0x87, 0x7D, 0x96, 0x2B, 0x85, 0x92, 0xDD, 0x2D, 0x56},
-		[]byte{0x5F, 0xFF, 0x20, 0xCA, 0xFA, 0xB1, 0x19, 0xCA, 0x2F, 0xC7, 0x35, 0x49, 0xE2, 0x0F, 0x5B, 0x0D},
-		[]byte{0xDD, 0xE5, 0x9B, 0x97, 0xD7, 0x22, 0x15, 0x6D, 0x4D, 0x9A, 0xFF, 0x2B, 0xC7, 0x55, 0x98, 0x26},
-		[]byte{0x54, 0xB9, 0xF0, 0x4E, 0x6A, 0x09, 0x18, 0x9A},
-		[]byte{0x2E, 0xC4, 0x7B, 0x2C, 0x49, 0x54, 0xA4, 0x89, 0xAF, 0xC7, 0xBA, 0x48, 0x97, 0xED, 0xCD, 0xAE, 0x8C, 0xC3, 0x3B, 0x60, 0x45, 0x05, 0x99, 0xBD, 0x02, 0xC9, 0x63, 0x82, 0x90, 0x2A, 0xEF, 0x7F, 0x83, 0x2A},
-	},
-	{
-		[]byte{0x6C, 0xF3, 0x67, 0x20, 0x87, 0x2B, 0x85, 0x13, 0xF6, 0xEA, 0xB1, 0xA8, 0xA4, 0x44, 0x38, 0xD5, 0xEF, 0x11},
-		[]byte{0xA4, 0xA4, 0x78, 0x2B, 0xCF, 0xFD, 0x3E, 0xC5, 0xE7, 0xEF, 0x6D, 0x8C, 0x34, 0xA5, 0x61, 0x23},
-		[]byte{0xB7, 0x81, 0xFC, 0xF2, 0xF7, 0x5F, 0xA5, 0xA8, 0xDE, 0x97, 0xA9, 0xCA, 0x48, 0xE5, 0x22, 0xEC},
-		[]byte{0x89, 0x9A, 0x17, 0x58, 0x97, 0x56, 0x1D, 0x7E},
-		[]byte{0x0D, 0xE1, 0x8F, 0xD0, 0xFD, 0xD9, 0x1E, 0x7A, 0xF1, 0x9F, 0x1D, 0x8E, 0xE8, 0x73, 0x39, 0x38, 0xB1, 0xE8, 0xE7, 0xF6, 0xD2, 0x23, 0x16, 0x18, 0x10, 0x2F, 0xDB, 0x7F, 0xE5, 0x5F, 0xF1, 0x99, 0x17, 0x00},
-	},
-	{
-		[]byte{0xCA, 0x40, 0xD7, 0x44, 0x6E, 0x54, 0x5F, 0xFA, 0xED, 0x3B, 0xD1, 0x2A, 0x74, 0x0A, 0x65, 0x9F, 0xFB, 0xBB, 0x3C, 0xEA, 0xB7},
-		[]byte{0x83, 0x95, 0xFC, 0xF1, 0xE9, 0x5B, 0xEB, 0xD6, 0x97, 0xBD, 0x01, 0x0B, 0xC7, 0x66, 0xAA, 0xC3},
-		[]byte{0x22, 0xE7, 0xAD, 0xD9, 0x3C, 0xFC, 0x63, 0x93, 0xC5, 0x7E, 0xC0, 0xB3, 0xC1, 0x7D, 0x6B, 0x44},
-		[]byte{0x12, 0x67, 0x35, 0xFC, 0xC3, 0x20, 0xD2, 0x5A},
-		[]byte{0xCB, 0x89, 0x20, 0xF8, 0x7A, 0x6C, 0x75, 0xCF, 0xF3, 0x96, 0x27, 0xB5, 0x6E, 0x3E, 0xD1, 0x97, 0xC5, 0x52, 0xD2, 0x95, 0xA7, 0xCF, 0xC4, 0x6A, 0xFC, 0x25, 0x3B, 0x46, 0x52, 0xB1, 0xAF, 0x37, 0x95, 0xB1, 0x24, 0xAB, 0x6E},
-	},
-}
-
-func TestEAXEncrypt_AES(t *testing.T) {
-	b := new(bytes.Buffer)
-	for i, tt := range eaxAESTests {
-		test := fmt.Sprintf("test %d", i)
-		c, err := aes.NewCipher(tt.key)
-		if err != nil {
-			t.Fatalf("%s: NewCipher(%d bytes) = %s", test, len(tt.key), err)
-		}
-		b.Reset()
-		enc := NewEAXEncrypter(c, tt.nonce, tt.header, 16, b)
-		n, err := io.Copy(enc, bytes.NewBuffer(tt.msg))
-		if n != int64(len(tt.msg)) || err != nil {
-			t.Fatalf("%s: io.Copy into encrypter: %d, %s", test, n, err)
-		}
-		err = enc.Close()
-		if err != nil {
-			t.Fatalf("%s: enc.Close: %s", test, err)
-		}
-		if d := b.Bytes(); !same(d, tt.cipher) {
-			t.Fatalf("%s: got %x want %x", test, d, tt.cipher)
-		}
-	}
-}
-
-func TestEAXDecrypt_AES(t *testing.T) {
-	b := new(bytes.Buffer)
-	for i, tt := range eaxAESTests {
-		test := fmt.Sprintf("test %d", i)
-		c, err := aes.NewCipher(tt.key)
-		if err != nil {
-			t.Fatalf("%s: NewCipher(%d bytes) = %s", test, len(tt.key), err)
-		}
-		b.Reset()
-		dec := NewEAXDecrypter(c, tt.nonce, tt.header, 16, bytes.NewBuffer(tt.cipher))
-		n, err := io.Copy(b, dec)
-		if n != int64(len(tt.msg)) || err != nil {
-			t.Fatalf("%s: io.Copy into decrypter: %d, %s", test, n, err)
-		}
-		if d := b.Bytes(); !same(d, tt.msg) {
-			t.Fatalf("%s: got %x want %x", test, d, tt.msg)
-		}
-	}
-}
diff --git a/src/pkg/crypto/block/ecb.go b/src/pkg/crypto/block/ecb.go
deleted file mode 100644
index cf09f7cb3f..0000000000
--- a/src/pkg/crypto/block/ecb.go
+++ /dev/null
@@ -1,270 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Electronic codebook (ECB) mode.
-// ECB is a fancy name for ``encrypt and decrypt each block separately.''
-// It's a pretty bad thing to do for any large amount of data (more than one block),
-// because the individual blocks can still be identified, duplicated, and reordered.
-// The ECB implementation exists mainly to provide buffering for
-// the other modes, which wrap it by providing modified Ciphers.
-
-// See NIST SP 800-38A, pp 9-10
-
-package block
-
-import (
-	"io"
-	"os"
-	"strconv"
-)
-
-type ecbDecrypter struct {
-	c         Cipher
-	r         io.Reader
-	blockSize int // block size
-
-	// Buffered data.
-	// The buffer buf is used as storage for both
-	// plain or crypt; at least one of those is nil at any given time.
-	buf   []byte
-	plain []byte // plain text waiting to be read
-	crypt []byte // ciphertext waiting to be decrypted
-}
-
-// Read into x.crypt until it has a full block or EOF or an error happens.
-func (x *ecbDecrypter) fillCrypt() os.Error {
-	var err os.Error
-	for len(x.crypt) < x.blockSize {
-		off := len(x.crypt)
-		var m int
-		m, err = x.r.Read(x.crypt[off:x.blockSize])
-		x.crypt = x.crypt[0 : off+m]
-		if m == 0 {
-			break
-		}
-
-		// If an error happened but we got enough
-		// data to do some decryption, we can decrypt
-		// first and report the error (with some data) later.
-		// But if we don't have enough to decrypt,
-		// have to stop now.
-		if err != nil && len(x.crypt) < x.blockSize {
-			break
-		}
-	}
-	return err
-}
-
-// Read from plain text buffer into p.
-func (x *ecbDecrypter) readPlain(p []byte) int {
-	n := len(x.plain)
-	if n > len(p) {
-		n = len(p)
-	}
-	for i := 0; i < n; i++ {
-		p[i] = x.plain[i]
-	}
-	if n < len(x.plain) {
-		x.plain = x.plain[n:]
-	} else {
-		x.plain = nil
-	}
-	return n
-}
-
-type ecbFragmentError int
-
-func (n ecbFragmentError) String() string {
-	return "crypto/block: " + strconv.Itoa(int(n)) + "-byte fragment at EOF"
-}
-
-func (x *ecbDecrypter) Read(p []byte) (n int, err os.Error) {
-	if len(p) == 0 {
-		return
-	}
-
-	// If there's no plaintext waiting and p is not big enough
-	// to hold a whole cipher block, we'll have to work in the
-	// cipher text buffer.  Set it to non-nil so that the
-	// code below will fill it.
-	if x.plain == nil && len(p) < x.blockSize && x.crypt == nil {
-		x.crypt = x.buf[0:0]
-	}
-
-	// If there is a leftover cipher text buffer,
-	// try to accumulate a full block.
-	if x.crypt != nil {
-		err = x.fillCrypt()
-		if err != nil || len(x.crypt) == 0 {
-			return
-		}
-		x.c.Decrypt(x.crypt, x.crypt)
-		x.plain = x.crypt
-		x.crypt = nil
-	}
-
-	// If there is a leftover plain text buffer, read from it.
-	if x.plain != nil {
-		n = x.readPlain(p)
-		return
-	}
-
-	// Read and decrypt directly in caller's buffer.
-	n, err = io.ReadAtLeast(x.r, p, x.blockSize)
-	if err == os.EOF && n > 0 {
-		// EOF is only okay on block boundary
-		err = os.ErrorString("block fragment at EOF during decryption")
-		return
-	}
-	var i int
-	for i = 0; i+x.blockSize <= n; i += x.blockSize {
-		a := p[i : i+x.blockSize]
-		x.c.Decrypt(a, a)
-	}
-
-	// There might be an encrypted fringe remaining.
-	// Save it for next time.
-	if i < n {
-		p = p[i:n]
-		copy(x.buf, p)
-		x.crypt = x.buf[0:len(p)]
-		n = i
-	}
-
-	return
-}
-
-// NewECBDecrypter returns a reader that reads data from r and decrypts it using c.
-// It decrypts by calling c.Decrypt on each block in sequence;
-// this mode is known as electronic codebook mode, or ECB.
-// The returned Reader does not buffer or read ahead except
-// as required by the cipher's block size.
-func NewECBDecrypter(c Cipher, r io.Reader) io.Reader {
-	x := new(ecbDecrypter)
-	x.c = c
-	x.r = r
-	x.blockSize = c.BlockSize()
-	x.buf = make([]byte, x.blockSize)
-	return x
-}
-
-type ecbEncrypter struct {
-	c         Cipher
-	w         io.Writer
-	blockSize int
-
-	// Buffered data.
-	// The buffer buf is used as storage for both
-	// plain or crypt.  If both are non-nil, plain
-	// follows crypt in buf.
-	buf   []byte
-	plain []byte // plain text waiting to be encrypted
-	crypt []byte // encrypted text waiting to be written
-}
-
-// Flush the x.crypt buffer to x.w.
-func (x *ecbEncrypter) flushCrypt() os.Error {
-	if len(x.crypt) == 0 {
-		return nil
-	}
-	n, err := x.w.Write(x.crypt)
-	if n < len(x.crypt) {
-		x.crypt = x.crypt[n:]
-		if err == nil {
-			err = io.ErrShortWrite
-		}
-	}
-	if err != nil {
-		return err
-	}
-	x.crypt = nil
-	return nil
-}
-
-// Slide x.plain down to the beginning of x.buf.
-// Plain is known to have less than one block of data,
-// so this is cheap enough.
-func (x *ecbEncrypter) slidePlain() {
-	if len(x.plain) == 0 {
-		x.plain = x.buf[0:0]
-	} else if cap(x.plain) < cap(x.buf) {
-		copy(x.buf, x.plain)
-		x.plain = x.buf[0:len(x.plain)]
-	}
-}
-
-// Fill x.plain from the data in p.
-// Return the number of bytes copied.
-func (x *ecbEncrypter) fillPlain(p []byte) int {
-	off := len(x.plain)
-	n := len(p)
-	if max := cap(x.plain) - off; n > max {
-		n = max
-	}
-	x.plain = x.plain[0 : off+n]
-	for i := 0; i < n; i++ {
-		x.plain[off+i] = p[i]
-	}
-	return n
-}
-
-// Encrypt x.plain; record encrypted range as x.crypt.
-func (x *ecbEncrypter) encrypt() {
-	var i int
-	n := len(x.plain)
-	for i = 0; i+x.blockSize <= n; i += x.blockSize {
-		a := x.plain[i : i+x.blockSize]
-		x.c.Encrypt(a, a)
-	}
-	x.crypt = x.plain[0:i]
-	x.plain = x.plain[i:n]
-}
-
-func (x *ecbEncrypter) Write(p []byte) (n int, err os.Error) {
-	for {
-		// If there is data waiting to be written, write it.
-		// This can happen on the first iteration
-		// if a write failed in an earlier call.
-		if err = x.flushCrypt(); err != nil {
-			return
-		}
-
-		// Now that encrypted data is gone (flush ran),
-		// perhaps we need to slide the plaintext down.
-		x.slidePlain()
-
-		// Fill plaintext buffer from p.
-		m := x.fillPlain(p)
-		if m == 0 {
-			break
-		}
-		n += m
-		p = p[m:]
-
-		// Encrypt, adjusting crypt and plain.
-		x.encrypt()
-
-		// Write x.crypt.
-		if err = x.flushCrypt(); err != nil {
-			break
-		}
-	}
-	return
-}
-
-// NewECBEncrypter returns a writer that encrypts data using c and writes it to w.
-// It encrypts by calling c.Encrypt on each block in sequence;
-// this mode is known as electronic codebook mode, or ECB.
-// The returned Writer does no buffering except as required
-// by the cipher's block size, so there is no need for a Flush method.
-func NewECBEncrypter(c Cipher, w io.Writer) io.Writer {
-	x := new(ecbEncrypter)
-	x.c = c
-	x.w = w
-	x.blockSize = c.BlockSize()
-
-	// Create a buffer that is an integral number of blocks.
-	x.buf = make([]byte, 8192/x.blockSize*x.blockSize)
-	return x
-}
diff --git a/src/pkg/crypto/block/ecb_aes_test.go b/src/pkg/crypto/block/ecb_aes_test.go
deleted file mode 100644
index 14481d0969..0000000000
--- a/src/pkg/crypto/block/ecb_aes_test.go
+++ /dev/null
@@ -1,127 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// ECB AES test vectors.
-
-// See U.S. National Institute of Standards and Technology (NIST)
-// Special Publication 800-38A, ``Recommendation for Block Cipher
-// Modes of Operation,'' 2001 Edition, pp. 24-27.
-
-package block
-
-import (
-	"bytes"
-	"crypto/aes"
-	"io"
-	"testing"
-)
-
-type ecbTest struct {
-	name string
-	key  []byte
-	in   []byte
-	out  []byte
-}
-
-var commonInput = []byte{
-	0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
-	0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
-	0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
-	0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10,
-}
-
-var commonKey128 = []byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}
-
-var commonKey192 = []byte{
-	0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52, 0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5,
-	0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b,
-}
-
-var commonKey256 = []byte{
-	0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
-	0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4,
-}
-
-var commonIV = []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}
-
-var ecbAESTests = []ecbTest{
-	// FIPS 197, Appendix B, C
-	{
-		"FIPS-197 Appendix B",
-		commonKey128,
-		[]byte{0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34},
-		[]byte{0x39, 0x25, 0x84, 0x1d, 0x02, 0xdc, 0x09, 0xfb, 0xdc, 0x11, 0x85, 0x97, 0x19, 0x6a, 0x0b, 0x32},
-	},
-
-	// NIST SP 800-38A pp 24-27
-	{
-		"ECB-AES128",
-		commonKey128,
-		commonInput,
-		[]byte{
-			0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97,
-			0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d, 0xe7, 0x85, 0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf,
-			0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce, 0x23, 0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88,
-			0x7b, 0x0c, 0x78, 0x5e, 0x27, 0xe8, 0xad, 0x3f, 0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4,
-		},
-	},
-	{
-		"ECB-AES192",
-		commonKey192,
-		commonInput,
-		[]byte{
-			0xbd, 0x33, 0x4f, 0x1d, 0x6e, 0x45, 0xf2, 0x5f, 0xf7, 0x12, 0xa2, 0x14, 0x57, 0x1f, 0xa5, 0xcc,
-			0x97, 0x41, 0x04, 0x84, 0x6d, 0x0a, 0xd3, 0xad, 0x77, 0x34, 0xec, 0xb3, 0xec, 0xee, 0x4e, 0xef,
-			0xef, 0x7a, 0xfd, 0x22, 0x70, 0xe2, 0xe6, 0x0a, 0xdc, 0xe0, 0xba, 0x2f, 0xac, 0xe6, 0x44, 0x4e,
-			0x9a, 0x4b, 0x41, 0xba, 0x73, 0x8d, 0x6c, 0x72, 0xfb, 0x16, 0x69, 0x16, 0x03, 0xc1, 0x8e, 0x0e,
-		},
-	},
-	{
-		"ECB-AES256",
-		commonKey256,
-		commonInput,
-		[]byte{
-			0xf3, 0xee, 0xd1, 0xbd, 0xb5, 0xd2, 0xa0, 0x3c, 0x06, 0x4b, 0x5a, 0x7e, 0x3d, 0xb1, 0x81, 0xf8,
-			0x59, 0x1c, 0xcb, 0x10, 0xd4, 0x10, 0xed, 0x26, 0xdc, 0x5b, 0xa7, 0x4a, 0x31, 0x36, 0x28, 0x70,
-			0xb6, 0xed, 0x21, 0xb9, 0x9c, 0xa6, 0xf4, 0xf9, 0xf1, 0x53, 0xe7, 0xb1, 0xbe, 0xaf, 0xed, 0x1d,
-			0x23, 0x30, 0x4b, 0x7a, 0x39, 0xf9, 0xf3, 0xff, 0x06, 0x7d, 0x8d, 0x8f, 0x9e, 0x24, 0xec, 0xc7,
-		},
-	},
-}
-
-func TestECB_AES(t *testing.T) {
-	for _, tt := range ecbAESTests {
-		test := tt.name
-
-		c, err := aes.NewCipher(tt.key)
-		if err != nil {
-			t.Errorf("%s: NewCipher(%d bytes) = %s", test, len(tt.key), err)
-			continue
-		}
-
-		var crypt bytes.Buffer
-		w := NewECBEncrypter(c, &crypt)
-		var r io.Reader = bytes.NewBuffer(tt.in)
-		n, err := io.Copy(w, r)
-		if n != int64(len(tt.in)) || err != nil {
-			t.Errorf("%s: ECBReader io.Copy = %d, %v want %d, nil", test, n, err, len(tt.in))
-		} else if d := crypt.Bytes(); !same(tt.out, d) {
-			t.Errorf("%s: ECBReader\nhave %x\nwant %x", test, d, tt.out)
-		}
-
-		var plain bytes.Buffer
-		r = NewECBDecrypter(c, bytes.NewBuffer(tt.out))
-		w = &plain
-		n, err = io.Copy(w, r)
-		if n != int64(len(tt.out)) || err != nil {
-			t.Errorf("%s: ECBWriter io.Copy = %d, %v want %d, nil", test, n, err, len(tt.out))
-		} else if d := plain.Bytes(); !same(tt.in, d) {
-			t.Errorf("%s: ECBWriter\nhave %x\nwant %x", test, d, tt.in)
-		}
-
-		if t.Failed() {
-			break
-		}
-	}
-}
diff --git a/src/pkg/crypto/block/ecb_test.go b/src/pkg/crypto/block/ecb_test.go
deleted file mode 100644
index 6f79d929a6..0000000000
--- a/src/pkg/crypto/block/ecb_test.go
+++ /dev/null
@@ -1,181 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package block
-
-import (
-	"bytes"
-	"fmt"
-	"io"
-	"testing"
-	"testing/iotest"
-)
-
-// Simple Cipher for testing: adds an incrementing amount
-// to each byte in each
-type IncCipher struct {
-	blockSize  int
-	delta      byte
-	encrypting bool
-}
-
-func (c *IncCipher) BlockSize() int { return c.blockSize }
-
-func (c *IncCipher) Encrypt(dst, src []byte) {
-	if !c.encrypting {
-		panic("encrypt: not encrypting")
-	}
-	if len(src) != c.blockSize || len(dst) != c.blockSize {
-		panic(fmt.Sprintln("encrypt: wrong block size", c.blockSize, len(src), len(dst)))
-	}
-	c.delta++
-	for i, b := range src {
-		dst[i] = b + c.delta
-	}
-}
-
-func (c *IncCipher) Decrypt(dst, src []byte) {
-	if c.encrypting {
-		panic("decrypt: not decrypting")
-	}
-	if len(src) != c.blockSize || len(dst) != c.blockSize {
-		panic(fmt.Sprintln("decrypt: wrong block size ", c.blockSize, " ", len(src), " ", len(dst)))
-	}
-	c.delta--
-	for i, b := range src {
-		dst[i] = b + c.delta
-	}
-}
-
-func TestECBEncrypter(t *testing.T) {
-	var plain, crypt [256]byte
-	for i := 0; i < len(plain); i++ {
-		plain[i] = byte(i)
-	}
-	b := new(bytes.Buffer)
-	for block := 1; block <= 64; block *= 2 {
-		// compute encrypted version
-		delta := byte(0)
-		for i := 0; i < len(crypt); i++ {
-			if i%block == 0 {
-				delta++
-			}
-			crypt[i] = plain[i] + delta
-		}
-
-		for frag := 0; frag < 2; frag++ {
-			c := &IncCipher{block, 0, true}
-			b.Reset()
-			r := bytes.NewBuffer(plain[0:])
-			w := NewECBEncrypter(c, b)
-
-			// copy plain into w in increasingly large chunks: 1, 1, 2, 4, 8, ...
-			// if frag != 0, move the 1 to the end to cause fragmentation.
-			if frag == 0 {
-				_, err := io.Copyn(w, r, 1)
-				if err != nil {
-					t.Errorf("block=%d frag=0: first Copyn: %s", block, err)
-					continue
-				}
-			}
-			for n := 1; n <= len(plain)/2; n *= 2 {
-				_, err := io.Copyn(w, r, int64(n))
-				if err != nil {
-					t.Errorf("block=%d frag=%d: Copyn %d: %s", block, frag, n, err)
-				}
-			}
-			if frag != 0 {
-				_, err := io.Copyn(w, r, 1)
-				if err != nil {
-					t.Errorf("block=%d frag=1: last Copyn: %s", block, err)
-					continue
-				}
-			}
-
-			// check output
-			data := b.Bytes()
-			if len(data) != len(crypt) {
-				t.Errorf("block=%d frag=%d: want %d bytes, got %d", block, frag, len(crypt), len(data))
-				continue
-			}
-
-			if string(data) != string(crypt[0:]) {
-				t.Errorf("block=%d frag=%d: want %x got %x", block, frag, data, crypt)
-			}
-		}
-	}
-}
-
-func testECBDecrypter(t *testing.T, maxio int) {
-	var readers = []func(io.Reader) io.Reader{
-		func(r io.Reader) io.Reader { return r },
-		iotest.OneByteReader,
-		iotest.HalfReader,
-	}
-	var plain, crypt [256]byte
-	for i := 0; i < len(plain); i++ {
-		plain[i] = byte(255 - i)
-	}
-	b := new(bytes.Buffer)
-	for block := 1; block <= 64 && block <= maxio; block *= 2 {
-		// compute encrypted version
-		delta := byte(0)
-		for i := 0; i < len(crypt); i++ {
-			if i%block == 0 {
-				delta++
-			}
-			crypt[i] = plain[i] + delta
-		}
-
-		for mode := 0; mode < len(readers); mode++ {
-			for frag := 0; frag < 2; frag++ {
-				test := fmt.Sprintf("block=%d mode=%d frag=%d maxio=%d", block, mode, frag, maxio)
-				c := &IncCipher{block, 0, false}
-				b.Reset()
-				r := NewECBDecrypter(c, readers[mode](bytes.NewBuffer(crypt[0:maxio])))
-
-				// read from crypt in increasingly large chunks: 1, 1, 2, 4, 8, ...
-				// if frag == 1, move the 1 to the end to cause fragmentation.
-				if frag == 0 {
-					_, err := io.Copyn(b, r, 1)
-					if err != nil {
-						t.Errorf("%s: first Copyn: %s", test, err)
-						continue
-					}
-				}
-				for n := 1; n <= maxio/2; n *= 2 {
-					_, err := io.Copyn(b, r, int64(n))
-					if err != nil {
-						t.Errorf("%s: Copyn %d: %s", test, n, err)
-					}
-				}
-				if frag != 0 {
-					_, err := io.Copyn(b, r, 1)
-					if err != nil {
-						t.Errorf("%s: last Copyn: %s", test, err)
-						continue
-					}
-				}
-
-				// check output
-				data := b.Bytes()
-				if len(data) != maxio {
-					t.Errorf("%s: want %d bytes, got %d", test, maxio, len(data))
-					continue
-				}
-
-				if string(data) != string(plain[0:maxio]) {
-					t.Errorf("%s: input=%x want %x got %x", test, crypt[0:maxio], plain[0:maxio], data)
-				}
-			}
-		}
-	}
-}
-
-func TestECBDecrypter(t *testing.T) {
-	// Do shorter I/O sizes first; they're easier to debug.
-	for n := 1; n <= 256 && !t.Failed(); n *= 2 {
-		testECBDecrypter(t, n)
-	}
-}
diff --git a/src/pkg/crypto/block/ofb.go b/src/pkg/crypto/block/ofb.go
deleted file mode 100644
index 11aaaa4d71..0000000000
--- a/src/pkg/crypto/block/ofb.go
+++ /dev/null
@@ -1,60 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Output feedback (OFB) mode.
-
-// OFB converts a block cipher into a stream cipher by
-// repeatedly encrypting an initialization vector and
-// xoring the resulting stream of data with the input.
-
-// See NIST SP 800-38A, pp 13-15
-
-package block
-
-import (
-	"fmt"
-	"io"
-)
-
-type ofbStream struct {
-	c  Cipher
-	iv []byte
-}
-
-func newOFBStream(c Cipher, iv []byte) *ofbStream {
-	x := new(ofbStream)
-	x.c = c
-	n := len(iv)
-	if n != c.BlockSize() {
-		panic(fmt.Sprintln("crypto/block: newOFBStream: invalid iv size", n, "!=", c.BlockSize()))
-	}
-	x.iv = dup(iv)
-	return x
-}
-
-func (x *ofbStream) Next() []byte {
-	x.c.Encrypt(x.iv, x.iv)
-	return x.iv
-}
-
-// NewOFBReader returns a reader that reads data from r, decrypts (or encrypts)
-// it using c in output feedback (OFB) mode with the initialization vector iv.
-// The returned Reader does not buffer and has no block size.
-// In OFB mode, encryption and decryption are the same operation:
-// an OFB reader applied to an encrypted stream produces a decrypted
-// stream and vice versa.
-func NewOFBReader(c Cipher, iv []byte, r io.Reader) io.Reader {
-	return newXorReader(newOFBStream(c, iv), r)
-}
-
-// NewOFBWriter returns a writer that encrypts (or decrypts) data using c
-// in cipher feedback (OFB) mode with the initialization vector iv
-// and writes the encrypted data to w.
-// The returned Writer does not buffer and has no block size.
-// In OFB mode, encryption and decryption are the same operation:
-// an OFB writer applied to an decrypted stream produces an encrypted
-// stream and vice versa.
-func NewOFBWriter(c Cipher, iv []byte, w io.Writer) io.Writer {
-	return newXorWriter(newOFBStream(c, iv), w)
-}
diff --git a/src/pkg/crypto/block/ofb_aes_test.go b/src/pkg/crypto/block/ofb_aes_test.go
deleted file mode 100644
index 9c527a6b37..0000000000
--- a/src/pkg/crypto/block/ofb_aes_test.go
+++ /dev/null
@@ -1,108 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// OFB AES test vectors.
-
-// See U.S. National Institute of Standards and Technology (NIST)
-// Special Publication 800-38A, ``Recommendation for Block Cipher
-// Modes of Operation,'' 2001 Edition, pp. 52-55.
-
-package block
-
-import (
-	"bytes"
-	"crypto/aes"
-	"io"
-	"testing"
-)
-
-type ofbTest struct {
-	name string
-	key  []byte
-	iv   []byte
-	in   []byte
-	out  []byte
-}
-
-var ofbAESTests = []ofbTest{
-	// NIST SP 800-38A pp 52-55
-	{
-		"OFB-AES128",
-		commonKey128,
-		commonIV,
-		commonInput,
-		[]byte{
-			0x3b, 0x3f, 0xd9, 0x2e, 0xb7, 0x2d, 0xad, 0x20, 0x33, 0x34, 0x49, 0xf8, 0xe8, 0x3c, 0xfb, 0x4a,
-			0x77, 0x89, 0x50, 0x8d, 0x16, 0x91, 0x8f, 0x03, 0xf5, 0x3c, 0x52, 0xda, 0xc5, 0x4e, 0xd8, 0x25,
-			0x97, 0x40, 0x05, 0x1e, 0x9c, 0x5f, 0xec, 0xf6, 0x43, 0x44, 0xf7, 0xa8, 0x22, 0x60, 0xed, 0xcc,
-			0x30, 0x4c, 0x65, 0x28, 0xf6, 0x59, 0xc7, 0x78, 0x66, 0xa5, 0x10, 0xd9, 0xc1, 0xd6, 0xae, 0x5e,
-		},
-	},
-	{
-		"OFB-AES192",
-		commonKey192,
-		commonIV,
-		commonInput,
-		[]byte{
-			0xcd, 0xc8, 0x0d, 0x6f, 0xdd, 0xf1, 0x8c, 0xab, 0x34, 0xc2, 0x59, 0x09, 0xc9, 0x9a, 0x41, 0x74,
-			0xfc, 0xc2, 0x8b, 0x8d, 0x4c, 0x63, 0x83, 0x7c, 0x09, 0xe8, 0x17, 0x00, 0xc1, 0x10, 0x04, 0x01,
-			0x8d, 0x9a, 0x9a, 0xea, 0xc0, 0xf6, 0x59, 0x6f, 0x55, 0x9c, 0x6d, 0x4d, 0xaf, 0x59, 0xa5, 0xf2,
-			0x6d, 0x9f, 0x20, 0x08, 0x57, 0xca, 0x6c, 0x3e, 0x9c, 0xac, 0x52, 0x4b, 0xd9, 0xac, 0xc9, 0x2a,
-		},
-	},
-	{
-		"OFB-AES256",
-		commonKey256,
-		commonIV,
-		commonInput,
-		[]byte{
-			0xdc, 0x7e, 0x84, 0xbf, 0xda, 0x79, 0x16, 0x4b, 0x7e, 0xcd, 0x84, 0x86, 0x98, 0x5d, 0x38, 0x60,
-			0x4f, 0xeb, 0xdc, 0x67, 0x40, 0xd2, 0x0b, 0x3a, 0xc8, 0x8f, 0x6a, 0xd8, 0x2a, 0x4f, 0xb0, 0x8d,
-			0x71, 0xab, 0x47, 0xa0, 0x86, 0xe8, 0x6e, 0xed, 0xf3, 0x9d, 0x1c, 0x5b, 0xba, 0x97, 0xc4, 0x08,
-			0x01, 0x26, 0x14, 0x1d, 0x67, 0xf3, 0x7b, 0xe8, 0x53, 0x8f, 0x5a, 0x8b, 0xe7, 0x40, 0xe4, 0x84,
-		},
-	},
-}
-
-func TestOFB_AES(t *testing.T) {
-	for _, tt := range ofbAESTests {
-		test := tt.name
-
-		c, err := aes.NewCipher(tt.key)
-		if err != nil {
-			t.Errorf("%s: NewCipher(%d bytes) = %s", test, len(tt.key), err)
-			continue
-		}
-
-		for j := 0; j <= 5; j += 5 {
-			var crypt bytes.Buffer
-			in := tt.in[0 : len(tt.in)-j]
-			w := NewOFBWriter(c, tt.iv, &crypt)
-			var r io.Reader = bytes.NewBuffer(in)
-			n, err := io.Copy(w, r)
-			if n != int64(len(in)) || err != nil {
-				t.Errorf("%s/%d: OFBWriter io.Copy = %d, %v want %d, nil", test, len(in), n, err, len(in))
-			} else if d, out := crypt.Bytes(), tt.out[0:len(in)]; !same(out, d) {
-				t.Errorf("%s/%d: OFBWriter\ninpt %x\nhave %x\nwant %x", test, len(in), in, d, out)
-			}
-		}
-
-		for j := 0; j <= 7; j += 7 {
-			var plain bytes.Buffer
-			out := tt.out[0 : len(tt.out)-j]
-			r := NewOFBReader(c, tt.iv, bytes.NewBuffer(out))
-			w := &plain
-			n, err := io.Copy(w, r)
-			if n != int64(len(out)) || err != nil {
-				t.Errorf("%s/%d: OFBReader io.Copy = %d, %v want %d, nil", test, len(out), n, err, len(out))
-			} else if d, in := plain.Bytes(), tt.in[0:len(out)]; !same(in, d) {
-				t.Errorf("%s/%d: OFBReader\nhave %x\nwant %x", test, len(out), d, in)
-			}
-		}
-
-		if t.Failed() {
-			break
-		}
-	}
-}
diff --git a/src/pkg/crypto/block/xor.go b/src/pkg/crypto/block/xor.go
deleted file mode 100644
index 9d8b172240..0000000000
--- a/src/pkg/crypto/block/xor.go
+++ /dev/null
@@ -1,124 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Encrypt/decrypt data by xor with a pseudo-random data stream.
-
-package block
-
-import (
-	"io"
-	"os"
-)
-
-// A dataStream is an interface to an unending stream of data,
-// used by XorReader and XorWriter to model a pseudo-random generator.
-// Calls to Next() return sequential blocks of data from the stream.
-// Each call must return at least one byte: there is no EOF.
-type dataStream interface {
-	Next() []byte
-}
-
-type xorReader struct {
-	r    io.Reader
-	rand dataStream // pseudo-random
-	buf  []byte     // data available from last call to rand
-}
-
-func newXorReader(rand dataStream, r io.Reader) io.Reader {
-	x := new(xorReader)
-	x.r = r
-	x.rand = rand
-	return x
-}
-
-func (x *xorReader) Read(p []byte) (n int, err os.Error) {
-	n, err = x.r.Read(p)
-
-	// xor input with stream.
-	bp := 0
-	buf := x.buf
-	for i := 0; i < n; i++ {
-		if bp >= len(buf) {
-			buf = x.rand.Next()
-			bp = 0
-		}
-		p[i] ^= buf[bp]
-		bp++
-	}
-	x.buf = buf[bp:]
-	return n, err
-}
-
-type xorWriter struct {
-	w     io.Writer
-	rand  dataStream // pseudo-random
-	buf   []byte     // last buffer returned by rand
-	extra []byte     // extra random data (use before buf)
-	work  []byte     // work space
-}
-
-func newXorWriter(rand dataStream, w io.Writer) io.Writer {
-	x := new(xorWriter)
-	x.w = w
-	x.rand = rand
-	x.work = make([]byte, 4096)
-	return x
-}
-
-func (x *xorWriter) Write(p []byte) (n int, err os.Error) {
-	for len(p) > 0 {
-		// Determine next chunk of random data
-		// and xor with p into x.work.
-		var chunk []byte
-		m := len(p)
-		if nn := len(x.extra); nn > 0 {
-			// extra points into work, so edit directly
-			if m > nn {
-				m = nn
-			}
-			for i := 0; i < m; i++ {
-				x.extra[i] ^= p[i]
-			}
-			chunk = x.extra[0:m]
-		} else {
-			// xor p ^ buf into work, refreshing buf as needed
-			if nn := len(x.work); m > nn {
-				m = nn
-			}
-			bp := 0
-			buf := x.buf
-			for i := 0; i < m; i++ {
-				if bp >= len(buf) {
-					buf = x.rand.Next()
-					bp = 0
-				}
-				x.work[i] = buf[bp] ^ p[i]
-				bp++
-			}
-			x.buf = buf[bp:]
-			chunk = x.work[0:m]
-		}
-
-		// Write chunk.
-		var nn int
-		nn, err = x.w.Write(chunk)
-		if nn != len(chunk) && err == nil {
-			err = io.ErrShortWrite
-		}
-		if nn < len(chunk) {
-			// Reconstruct the random bits from the unwritten
-			// data and save them for next time.
-			for i := nn; i < m; i++ {
-				chunk[i] ^= p[i]
-			}
-			x.extra = chunk[nn:]
-		}
-		n += nn
-		if err != nil {
-			return
-		}
-		p = p[m:]
-	}
-	return
-}
diff --git a/src/pkg/crypto/block/xor_test.go b/src/pkg/crypto/block/xor_test.go
deleted file mode 100644
index 50f6bb08df..0000000000
--- a/src/pkg/crypto/block/xor_test.go
+++ /dev/null
@@ -1,168 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package block
-
-import (
-	"bytes"
-	"fmt"
-	"io"
-	"testing"
-	"testing/iotest"
-)
-
-// Simple "pseudo-random" stream for testing.
-type incStream struct {
-	buf []byte
-	n   byte
-}
-
-func newIncStream(blockSize int) *incStream {
-	x := new(incStream)
-	x.buf = make([]byte, blockSize)
-	return x
-}
-
-func (x *incStream) Next() []byte {
-	x.n++
-	for i := range x.buf {
-		x.buf[i] = x.n
-		x.n++
-	}
-	return x.buf
-}
-
-func testXorWriter(t *testing.T, maxio int) {
-	var plain, crypt [256]byte
-	for i := 0; i < len(plain); i++ {
-		plain[i] = byte(i)
-	}
-	b := new(bytes.Buffer)
-	for block := 1; block <= 64 && block <= maxio; block *= 2 {
-		// compute encrypted version
-		n := byte(0)
-		for i := 0; i < len(crypt); i++ {
-			if i%block == 0 {
-				n++
-			}
-			crypt[i] = plain[i] ^ n
-			n++
-		}
-
-		for frag := 0; frag < 2; frag++ {
-			test := fmt.Sprintf("block=%d frag=%d maxio=%d", block, frag, maxio)
-			b.Reset()
-			r := bytes.NewBuffer(plain[0:])
-			s := newIncStream(block)
-			w := newXorWriter(s, b)
-
-			// copy plain into w in increasingly large chunks: 1, 1, 2, 4, 8, ...
-			// if frag != 0, move the 1 to the end to cause fragmentation.
-			if frag == 0 {
-				_, err := io.Copyn(w, r, 1)
-				if err != nil {
-					t.Errorf("%s: first Copyn: %s", test, err)
-					continue
-				}
-			}
-			for n := 1; n <= len(plain)/2; n *= 2 {
-				_, err := io.Copyn(w, r, int64(n))
-				if err != nil {
-					t.Errorf("%s: Copyn %d: %s", test, n, err)
-				}
-			}
-
-			// check output
-			crypt := crypt[0 : len(crypt)-frag]
-			data := b.Bytes()
-			if len(data) != len(crypt) {
-				t.Errorf("%s: want %d bytes, got %d", test, len(crypt), len(data))
-				continue
-			}
-
-			if string(data) != string(crypt) {
-				t.Errorf("%s: want %x got %x", test, data, crypt)
-			}
-		}
-	}
-}
-
-
-func TestXorWriter(t *testing.T) {
-	// Do shorter I/O sizes first; they're easier to debug.
-	for n := 1; n <= 256 && !t.Failed(); n *= 2 {
-		testXorWriter(t, n)
-	}
-}
-
-func testXorReader(t *testing.T, maxio int) {
-	var readers = []func(io.Reader) io.Reader{
-		func(r io.Reader) io.Reader { return r },
-		iotest.OneByteReader,
-		iotest.HalfReader,
-	}
-	var plain, crypt [256]byte
-	for i := 0; i < len(plain); i++ {
-		plain[i] = byte(255 - i)
-	}
-	b := new(bytes.Buffer)
-	for block := 1; block <= 64 && block <= maxio; block *= 2 {
-		// compute encrypted version
-		n := byte(0)
-		for i := 0; i < len(crypt); i++ {
-			if i%block == 0 {
-				n++
-			}
-			crypt[i] = plain[i] ^ n
-			n++
-		}
-
-		for mode := 0; mode < len(readers); mode++ {
-			for frag := 0; frag < 2; frag++ {
-				test := fmt.Sprintf("block=%d mode=%d frag=%d maxio=%d", block, mode, frag, maxio)
-				s := newIncStream(block)
-				b.Reset()
-				r := newXorReader(s, readers[mode](bytes.NewBuffer(crypt[0:maxio])))
-
-				// read from crypt in increasingly large chunks: 1, 1, 2, 4, 8, ...
-				// if frag == 1, move the 1 to the end to cause fragmentation.
-				if frag == 0 {
-					_, err := io.Copyn(b, r, 1)
-					if err != nil {
-						t.Errorf("%s: first Copyn: %s", test, err)
-						continue
-					}
-				}
-				for n := 1; n <= maxio/2; n *= 2 {
-					_, err := io.Copyn(b, r, int64(n))
-					if err != nil {
-						t.Errorf("%s: Copyn %d: %s", test, n, err)
-					}
-				}
-
-				// check output
-				data := b.Bytes()
-				crypt := crypt[0 : maxio-frag]
-				plain := plain[0 : maxio-frag]
-				if len(data) != len(plain) {
-					t.Errorf("%s: want %d bytes, got %d", test, len(plain), len(data))
-					continue
-				}
-
-				if string(data) != string(plain) {
-					t.Errorf("%s: input=%x want %x got %x", test, crypt, plain, data)
-				}
-			}
-		}
-	}
-}
-
-func TestXorReader(t *testing.T) {
-	// Do shorter I/O sizes first; they're easier to debug.
-	for n := 1; n <= 256 && !t.Failed(); n *= 2 {
-		testXorReader(t, n)
-	}
-}
-
-// TODO(rsc): Test handling of writes after write errors.
