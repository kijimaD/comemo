commit 1e3570ac86f6aeb7f8ce70b5ad236a5dd92ec804
Author: Matthew Dempsky <mdempsky@google.com>
Date:   Tue Apr 18 12:53:25 2017 -0700

    cmd/internal/objabi: extract shared functionality from obj
    
    Now only cmd/asm and cmd/compile depend on cmd/internal/obj. Changing
    the assembler backends no longer requires reinstalling cmd/link or
    cmd/addr2line.
    
    There's also now one canonical definition of the object file format in
    cmd/internal/objabi/doc.go, with a warning to update all three
    implementations.
    
    objabi is still something of a grab bag of unrelated code (e.g., flag
    and environment variable handling probably belong in a separate "tool"
    package), but this is still progress.
    
    Fixes #15165.
    Fixes #20026.
    
    Change-Id: Ic4b92fac7d0d35438e0d20c9579aad4085c5534c
    Reviewed-on: https://go-review.googlesource.com/40972
    Run-TryBot: Matthew Dempsky <mdempsky@google.com>
    TryBot-Result: Gobot Gobot <gobot@golang.org>
    Reviewed-by: Josh Bleecher Snyder <josharian@gmail.com>
---
 src/cmd/asm/internal/asm/asm.go                    |   3 +-
 src/cmd/asm/internal/asm/operand_test.go           |   5 +-
 src/cmd/asm/internal/lex/tokenizer.go              |   4 +-
 src/cmd/asm/main.go                                |   5 +-
 src/cmd/compile/internal/amd64/galign.go           |   4 +-
 src/cmd/compile/internal/amd64/ggen.go             |   3 +-
 src/cmd/compile/internal/arm64/ggen.go             |   3 +-
 src/cmd/compile/internal/gc/gsubr.go               |   5 +-
 src/cmd/compile/internal/gc/lex.go                 |   4 +-
 src/cmd/compile/internal/gc/main.go                |  63 ++--
 src/cmd/compile/internal/gc/noder.go               |   4 +-
 src/cmd/compile/internal/gc/obj.go                 |   5 +-
 src/cmd/compile/internal/gc/pgen.go                |   7 +-
 src/cmd/compile/internal/gc/reflect.go             |  63 ++--
 src/cmd/compile/internal/gc/ssa.go                 |   3 +-
 src/cmd/compile/internal/gc/subr.go                |   4 +-
 src/cmd/compile/internal/gc/typecheck.go           |   4 +-
 src/cmd/compile/internal/gc/walk.go                |   4 +-
 src/cmd/compile/internal/mips/galign.go            |   4 +-
 src/cmd/compile/internal/mips64/galign.go          |   4 +-
 src/cmd/compile/internal/ppc64/galign.go           |   4 +-
 src/cmd/compile/internal/ssa/compile.go            |   4 +-
 src/cmd/compile/internal/ssa/config.go             |   7 +-
 src/cmd/compile/internal/ssa/gen/ARM.rules         |   8 +-
 src/cmd/compile/internal/ssa/gen/rulegen.go        |   7 +-
 src/cmd/compile/internal/ssa/regalloc.go           |   4 +-
 src/cmd/compile/internal/ssa/rewrite386.go         |   7 +-
 src/cmd/compile/internal/ssa/rewriteAMD64.go       |   7 +-
 src/cmd/compile/internal/ssa/rewriteARM.go         |  23 +-
 src/cmd/compile/internal/ssa/rewriteARM64.go       |   7 +-
 src/cmd/compile/internal/ssa/rewriteMIPS.go        |   7 +-
 src/cmd/compile/internal/ssa/rewriteMIPS64.go      |   7 +-
 src/cmd/compile/internal/ssa/rewritePPC64.go       |   7 +-
 src/cmd/compile/internal/ssa/rewriteS390X.go       |   7 +-
 src/cmd/compile/internal/ssa/rewritedec.go         |   7 +-
 src/cmd/compile/internal/ssa/rewritedec64.go       |   7 +-
 src/cmd/compile/internal/ssa/rewritegeneric.go     |   7 +-
 src/cmd/compile/internal/x86/galign.go             |   4 +-
 src/cmd/compile/main.go                            |   6 +-
 src/cmd/dist/buildruntime.go                       |   6 +-
 src/cmd/dist/buildtool.go                          |   3 +-
 src/cmd/internal/goobj/read.go                     | 123 +------
 src/cmd/internal/obj/arm/asm5.go                   |  31 +-
 src/cmd/internal/obj/arm/obj5.go                   |  21 +-
 src/cmd/internal/obj/arm64/asm7.go                 |  25 +-
 src/cmd/internal/obj/arm64/obj7.go                 |  17 +-
 src/cmd/internal/obj/data.go                       |   9 +-
 src/cmd/internal/obj/go.go                         |  72 ----
 src/cmd/internal/obj/line.go                       |  61 ----
 src/cmd/internal/obj/link.go                       | 359 +------------------
 src/cmd/internal/obj/mips/asm0.go                  |  31 +-
 src/cmd/internal/obj/mips/obj0.go                  |  13 +-
 src/cmd/internal/obj/objfile.go                    | 127 +------
 src/cmd/internal/obj/plist.go                      |  25 +-
 src/cmd/internal/obj/ppc64/asm9.go                 |  27 +-
 src/cmd/internal/obj/ppc64/obj9.go                 |  19 +-
 src/cmd/internal/obj/s390x/asmz.go                 |  17 +-
 src/cmd/internal/obj/s390x/objz.go                 |  19 +-
 src/cmd/internal/obj/sym.go                        |  23 +-
 src/cmd/internal/obj/util.go                       |  53 +--
 src/cmd/internal/obj/x86/asm6.go                   |  91 ++---
 src/cmd/internal/obj/x86/obj6.go                   |  55 +--
 src/cmd/internal/objabi/autotype.go                |  37 ++
 src/cmd/internal/objabi/doc.go                     | 119 +++++++
 src/cmd/internal/{obj => objabi}/flag.go           |   2 +-
 src/cmd/internal/{obj => objabi}/funcdata.go       |   2 +-
 src/cmd/internal/objabi/head.go                    | 104 ++++++
 src/cmd/internal/objabi/line.go                    |  82 +++++
 src/cmd/internal/objabi/reloctype.go               | 200 +++++++++++
 .../internal/{obj => objabi}/reloctype_string.go   |   4 +-
 src/cmd/internal/{obj => objabi}/stack.go          |   3 +-
 src/cmd/internal/objabi/symkind.go                 | 137 ++++++++
 src/cmd/internal/{obj => objabi}/symkind_string.go |   4 +-
 src/cmd/internal/{obj => objabi}/typekind.go       |   2 +-
 src/cmd/internal/objabi/util.go                    | 112 ++++++
 src/cmd/internal/objfile/goobj.go                  |  11 +-
 src/cmd/link/internal/amd64/asm.go                 | 196 +++++------
 src/cmd/link/internal/amd64/obj.go                 |  24 +-
 src/cmd/link/internal/arm/asm.go                   | 148 ++++----
 src/cmd/link/internal/arm/obj.go                   |  16 +-
 src/cmd/link/internal/arm64/asm.go                 | 100 +++---
 src/cmd/link/internal/arm64/obj.go                 |  10 +-
 src/cmd/link/internal/ld/ar.go                     |   6 +-
 src/cmd/link/internal/ld/config.go                 |  30 +-
 src/cmd/link/internal/ld/data.go                   | 390 ++++++++++-----------
 src/cmd/link/internal/ld/deadcode.go               |  16 +-
 src/cmd/link/internal/ld/decodesym.go              |  10 +-
 src/cmd/link/internal/ld/dwarf.go                  |  98 +++---
 src/cmd/link/internal/ld/elf.go                    |  96 ++---
 src/cmd/link/internal/ld/go.go                     |  20 +-
 src/cmd/link/internal/ld/ld.go                     |   3 +-
 src/cmd/link/internal/ld/ldelf.go                  |  36 +-
 src/cmd/link/internal/ld/ldmacho.go                |  20 +-
 src/cmd/link/internal/ld/ldpe.go                   |  32 +-
 src/cmd/link/internal/ld/lib.go                    | 182 +++++-----
 src/cmd/link/internal/ld/link.go                   |  22 +-
 src/cmd/link/internal/ld/macho.go                  |  22 +-
 src/cmd/link/internal/ld/main.go                   |  30 +-
 src/cmd/link/internal/ld/objfile.go                | 130 +------
 src/cmd/link/internal/ld/pcln.go                   |  36 +-
 src/cmd/link/internal/ld/pe.go                     |  38 +-
 src/cmd/link/internal/ld/sym.go                    |  26 +-
 src/cmd/link/internal/ld/symtab.go                 | 118 +++----
 src/cmd/link/internal/ld/typelink.go               |   7 +-
 src/cmd/link/internal/ld/util.go                   |  10 +
 src/cmd/link/internal/mips/asm.go                  |  50 +--
 src/cmd/link/internal/mips/obj.go                  |   6 +-
 src/cmd/link/internal/mips64/asm.go                |  72 ++--
 src/cmd/link/internal/mips64/obj.go                |  10 +-
 src/cmd/link/internal/ppc64/asm.go                 | 146 ++++----
 src/cmd/link/internal/ppc64/obj.go                 |  10 +-
 src/cmd/link/internal/s390x/asm.go                 |  82 ++---
 src/cmd/link/internal/s390x/obj.go                 |   4 +-
 src/cmd/link/internal/x86/asm.go                   | 158 ++++-----
 src/cmd/link/internal/x86/obj.go                   |  18 +-
 src/cmd/link/linkbig_test.go                       |   8 +-
 src/cmd/link/main.go                               |   6 +-
 test/nosplit.go                                    |   2 +-
 118 files changed, 2420 insertions(+), 2408 deletions(-)

diff --git a/src/cmd/asm/internal/asm/asm.go b/src/cmd/asm/internal/asm/asm.go
index 2c9eeadb82..b0df240997 100644
--- a/src/cmd/asm/internal/asm/asm.go
+++ b/src/cmd/asm/internal/asm/asm.go
@@ -13,6 +13,7 @@ import (
 	"cmd/asm/internal/flags"
 	"cmd/asm/internal/lex"
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 )
 
@@ -151,7 +152,7 @@ func (p *Parser) asmText(word string, operands [][]lex.Token) {
 		frameSize = -frameSize
 	}
 	op = op[1:]
-	argSize := int64(obj.ArgsSizeUnknown)
+	argSize := int64(objabi.ArgsSizeUnknown)
 	if len(op) > 0 {
 		// There is an argument size. It must be a minus sign followed by a non-negative integer literal.
 		if len(op) != 2 || op[0].ScanToken != '-' || op[1].ScanToken != scanner.Int {
diff --git a/src/cmd/asm/internal/asm/operand_test.go b/src/cmd/asm/internal/asm/operand_test.go
index f1531a8c79..ca692bf828 100644
--- a/src/cmd/asm/internal/asm/operand_test.go
+++ b/src/cmd/asm/internal/asm/operand_test.go
@@ -10,13 +10,14 @@ import (
 	"cmd/asm/internal/arch"
 	"cmd/asm/internal/lex"
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 )
 
 // A simple in-out test: Do we print what we parse?
 
 func setArch(goarch string) (*arch.Arch, *obj.Link) {
-	obj.GOOS = "linux" // obj can handle this OS for all architectures.
-	obj.GOARCH = goarch
+	objabi.GOOS = "linux" // obj can handle this OS for all architectures.
+	objabi.GOARCH = goarch
 	architecture := arch.Set(goarch)
 	if architecture == nil {
 		panic("asm: unrecognized architecture " + goarch)
diff --git a/src/cmd/asm/internal/lex/tokenizer.go b/src/cmd/asm/internal/lex/tokenizer.go
index 6c17085115..aef9ea8636 100644
--- a/src/cmd/asm/internal/lex/tokenizer.go
+++ b/src/cmd/asm/internal/lex/tokenizer.go
@@ -12,7 +12,7 @@ import (
 	"unicode"
 
 	"cmd/asm/internal/flags"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/src"
 )
 
@@ -43,7 +43,7 @@ func NewTokenizer(name string, r io.Reader, file *os.File) *Tokenizer {
 	s.IsIdentRune = isIdentRune
 	return &Tokenizer{
 		s:    &s,
-		base: src.NewFileBase(name, obj.AbsFile(obj.WorkingDir(), name, *flags.TrimPath)),
+		base: src.NewFileBase(name, objabi.AbsFile(objabi.WorkingDir(), name, *flags.TrimPath)),
 		line: 1,
 		file: file,
 	}
diff --git a/src/cmd/asm/main.go b/src/cmd/asm/main.go
index 737d2f102c..2e799163af 100644
--- a/src/cmd/asm/main.go
+++ b/src/cmd/asm/main.go
@@ -18,13 +18,14 @@ import (
 
 	"cmd/internal/bio"
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 )
 
 func main() {
 	log.SetFlags(0)
 	log.SetPrefix("asm: ")
 
-	GOARCH := obj.GOARCH
+	GOARCH := objabi.GOARCH
 
 	architecture := arch.Set(GOARCH)
 	if architecture == nil {
@@ -52,7 +53,7 @@ func main() {
 	defer bio.MustClose(out)
 	buf := bufio.NewWriter(bio.MustWriter(out))
 
-	fmt.Fprintf(buf, "go object %s %s %s\n", obj.GOOS, obj.GOARCH, obj.Version)
+	fmt.Fprintf(buf, "go object %s %s %s\n", objabi.GOOS, objabi.GOARCH, objabi.Version)
 	fmt.Fprintf(buf, "!\n")
 
 	var ok, diag bool
diff --git a/src/cmd/compile/internal/amd64/galign.go b/src/cmd/compile/internal/amd64/galign.go
index 90ee895364..14defb2cac 100644
--- a/src/cmd/compile/internal/amd64/galign.go
+++ b/src/cmd/compile/internal/amd64/galign.go
@@ -6,15 +6,15 @@ package amd64
 
 import (
 	"cmd/compile/internal/gc"
-	"cmd/internal/obj"
 	"cmd/internal/obj/x86"
+	"cmd/internal/objabi"
 )
 
 var leaptr = x86.ALEAQ
 
 func Init(arch *gc.Arch) {
 	arch.LinkArch = &x86.Linkamd64
-	if obj.GOARCH == "amd64p32" {
+	if objabi.GOARCH == "amd64p32" {
 		arch.LinkArch = &x86.Linkamd64p32
 		leaptr = x86.ALEAL
 	}
diff --git a/src/cmd/compile/internal/amd64/ggen.go b/src/cmd/compile/internal/amd64/ggen.go
index beb07ef2d0..85d9567c72 100644
--- a/src/cmd/compile/internal/amd64/ggen.go
+++ b/src/cmd/compile/internal/amd64/ggen.go
@@ -8,10 +8,11 @@ import (
 	"cmd/compile/internal/gc"
 	"cmd/internal/obj"
 	"cmd/internal/obj/x86"
+	"cmd/internal/objabi"
 )
 
 // no floating point in note handlers on Plan 9
-var isPlan9 = obj.GOOS == "plan9"
+var isPlan9 = objabi.GOOS == "plan9"
 
 func defframe(pp *gc.Progs, fn *gc.Node, sz int64) {
 	// fill in argument size, stack size
diff --git a/src/cmd/compile/internal/arm64/ggen.go b/src/cmd/compile/internal/arm64/ggen.go
index 2e44303c8b..caf8545417 100644
--- a/src/cmd/compile/internal/arm64/ggen.go
+++ b/src/cmd/compile/internal/arm64/ggen.go
@@ -8,6 +8,7 @@ import (
 	"cmd/compile/internal/gc"
 	"cmd/internal/obj"
 	"cmd/internal/obj/arm64"
+	"cmd/internal/objabi"
 )
 
 func defframe(pp *gc.Progs, fn *gc.Node, sz int64) {
@@ -65,7 +66,7 @@ func defframe(pp *gc.Progs, fn *gc.Node, sz int64) {
 	zerorange(pp, p, int64(frame), lo, hi)
 }
 
-var darwin = obj.GOOS == "darwin"
+var darwin = objabi.GOOS == "darwin"
 
 func zerorange(pp *gc.Progs, p *obj.Prog, frame int64, lo int64, hi int64) *obj.Prog {
 	cnt := hi - lo
diff --git a/src/cmd/compile/internal/gc/gsubr.go b/src/cmd/compile/internal/gc/gsubr.go
index 3a384cba8e..99dec575f4 100644
--- a/src/cmd/compile/internal/gc/gsubr.go
+++ b/src/cmd/compile/internal/gc/gsubr.go
@@ -33,6 +33,7 @@ package gc
 import (
 	"cmd/compile/internal/types"
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/src"
 )
 
@@ -158,13 +159,13 @@ func (pp *Progs) settext(fn *Node) {
 	ptxt.From.Sym = fn.Func.lsym
 
 	p := pp.Prog(obj.AFUNCDATA)
-	Addrconst(&p.From, obj.FUNCDATA_ArgsPointerMaps)
+	Addrconst(&p.From, objabi.FUNCDATA_ArgsPointerMaps)
 	p.To.Type = obj.TYPE_MEM
 	p.To.Name = obj.NAME_EXTERN
 	p.To.Sym = &fn.Func.lsym.Func.GCArgs
 
 	p = pp.Prog(obj.AFUNCDATA)
-	Addrconst(&p.From, obj.FUNCDATA_LocalsPointerMaps)
+	Addrconst(&p.From, objabi.FUNCDATA_LocalsPointerMaps)
 	p.To.Type = obj.TYPE_MEM
 	p.To.Name = obj.NAME_EXTERN
 	p.To.Sym = &fn.Func.lsym.Func.GCLocals
diff --git a/src/cmd/compile/internal/gc/lex.go b/src/cmd/compile/internal/gc/lex.go
index 7d68431dc0..9d14f53382 100644
--- a/src/cmd/compile/internal/gc/lex.go
+++ b/src/cmd/compile/internal/gc/lex.go
@@ -6,7 +6,7 @@ package gc
 
 import (
 	"cmd/compile/internal/syntax"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/src"
 	"fmt"
 	"strings"
@@ -64,7 +64,7 @@ const (
 func pragmaValue(verb string) syntax.Pragma {
 	switch verb {
 	case "go:nointerface":
-		if obj.Fieldtrack_enabled != 0 {
+		if objabi.Fieldtrack_enabled != 0 {
 			return Nointerface
 		}
 	case "go:noescape":
diff --git a/src/cmd/compile/internal/gc/main.go b/src/cmd/compile/internal/gc/main.go
index 560e7c68e5..c4b43fc53b 100644
--- a/src/cmd/compile/internal/gc/main.go
+++ b/src/cmd/compile/internal/gc/main.go
@@ -12,6 +12,7 @@ import (
 	"cmd/compile/internal/ssa"
 	"cmd/compile/internal/types"
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/src"
 	"cmd/internal/sys"
 	"flag"
@@ -68,7 +69,7 @@ var debugtab = []struct {
 
 func usage() {
 	fmt.Printf("usage: compile [options] file.go...\n")
-	obj.Flagprint(1)
+	objabi.Flagprint(1)
 	Exit(2)
 }
 
@@ -85,7 +86,7 @@ func hidePanic() {
 }
 
 func doversion() {
-	p := obj.Expstring()
+	p := objabi.Expstring()
 	if p == "X:none" {
 		p = ""
 	}
@@ -93,7 +94,7 @@ func doversion() {
 	if p != "" {
 		sep = " "
 	}
-	fmt.Printf("compile version %s%s%s\n", obj.Version, sep, p)
+	fmt.Printf("compile version %s%s%s\n", objabi.Version, sep, p)
 	os.Exit(0)
 }
 
@@ -162,49 +163,49 @@ func Main(archInit func(*Arch)) {
 	mappkg.Name = "go.map"
 	mappkg.Prefix = "go.map"
 
-	Nacl = obj.GOOS == "nacl"
+	Nacl = objabi.GOOS == "nacl"
 
 	flag.BoolVar(&compiling_runtime, "+", false, "compiling runtime")
-	obj.Flagcount("%", "debug non-static initializers", &Debug['%'])
-	obj.Flagcount("B", "disable bounds checking", &Debug['B'])
-	obj.Flagcount("C", "disable printing of columns in error messages", &Debug['C']) // TODO(gri) remove eventually
+	objabi.Flagcount("%", "debug non-static initializers", &Debug['%'])
+	objabi.Flagcount("B", "disable bounds checking", &Debug['B'])
+	objabi.Flagcount("C", "disable printing of columns in error messages", &Debug['C']) // TODO(gri) remove eventually
 	flag.StringVar(&localimport, "D", "", "set relative `path` for local imports")
-	obj.Flagcount("E", "debug symbol export", &Debug['E'])
-	obj.Flagfn1("I", "add `directory` to import search path", addidir)
-	obj.Flagcount("K", "debug missing line numbers", &Debug['K'])
-	obj.Flagcount("N", "disable optimizations", &Debug['N'])
+	objabi.Flagcount("E", "debug symbol export", &Debug['E'])
+	objabi.Flagfn1("I", "add `directory` to import search path", addidir)
+	objabi.Flagcount("K", "debug missing line numbers", &Debug['K'])
+	objabi.Flagcount("N", "disable optimizations", &Debug['N'])
 	flag.BoolVar(&Debug_asm, "S", false, "print assembly listing")
-	obj.Flagfn0("V", "print compiler version", doversion)
-	obj.Flagcount("W", "debug parse tree after type checking", &Debug['W'])
+	objabi.Flagfn0("V", "print compiler version", doversion)
+	objabi.Flagcount("W", "debug parse tree after type checking", &Debug['W'])
 	flag.StringVar(&asmhdr, "asmhdr", "", "write assembly header to `file`")
 	flag.StringVar(&buildid, "buildid", "", "record `id` as the build id in the export metadata")
 	flag.BoolVar(&pure_go, "complete", false, "compiling complete package (no C or assembly)")
 	flag.StringVar(&debugstr, "d", "", "print debug information about items in `list`")
 	flag.BoolVar(&flagDWARF, "dwarf", true, "generate DWARF symbols")
-	obj.Flagcount("e", "no limit on number of errors reported", &Debug['e'])
-	obj.Flagcount("f", "debug stack frames", &Debug['f'])
-	obj.Flagcount("h", "halt on error", &Debug['h'])
-	obj.Flagcount("i", "debug line number stack", &Debug['i'])
-	obj.Flagfn1("importmap", "add `definition` of the form source=actual to import map", addImportMap)
+	objabi.Flagcount("e", "no limit on number of errors reported", &Debug['e'])
+	objabi.Flagcount("f", "debug stack frames", &Debug['f'])
+	objabi.Flagcount("h", "halt on error", &Debug['h'])
+	objabi.Flagcount("i", "debug line number stack", &Debug['i'])
+	objabi.Flagfn1("importmap", "add `definition` of the form source=actual to import map", addImportMap)
 	flag.StringVar(&flag_installsuffix, "installsuffix", "", "set pkg directory `suffix`")
-	obj.Flagcount("j", "debug runtime-initialized variables", &Debug['j'])
-	obj.Flagcount("l", "disable inlining", &Debug['l'])
+	objabi.Flagcount("j", "debug runtime-initialized variables", &Debug['j'])
+	objabi.Flagcount("l", "disable inlining", &Debug['l'])
 	flag.StringVar(&linkobj, "linkobj", "", "write linker-specific object to `file`")
-	obj.Flagcount("live", "debug liveness analysis", &debuglive)
-	obj.Flagcount("m", "print optimization decisions", &Debug['m'])
+	objabi.Flagcount("live", "debug liveness analysis", &debuglive)
+	objabi.Flagcount("m", "print optimization decisions", &Debug['m'])
 	flag.BoolVar(&flag_msan, "msan", false, "build code compatible with C/C++ memory sanitizer")
 	flag.BoolVar(&dolinkobj, "dolinkobj", true, "generate linker-specific objects; if false, some invalid code may compile")
 	flag.BoolVar(&nolocalimports, "nolocalimports", false, "reject local (relative) imports")
 	flag.StringVar(&outfile, "o", "", "write output to `file`")
 	flag.StringVar(&myimportpath, "p", "", "set expected package import `path`")
 	flag.BoolVar(&writearchive, "pack", false, "write package file instead of object file")
-	obj.Flagcount("r", "debug generated wrappers", &Debug['r'])
+	objabi.Flagcount("r", "debug generated wrappers", &Debug['r'])
 	flag.BoolVar(&flag_race, "race", false, "enable race detector")
-	obj.Flagcount("s", "warn about composite literals that can be simplified", &Debug['s'])
+	objabi.Flagcount("s", "warn about composite literals that can be simplified", &Debug['s'])
 	flag.StringVar(&pathPrefix, "trimpath", "", "remove `prefix` from recorded source file paths")
 	flag.BoolVar(&safemode, "u", false, "reject unsafe code")
 	flag.BoolVar(&Debug_vlog, "v", false, "increase debug verbosity")
-	obj.Flagcount("w", "debug type checking", &Debug['w'])
+	objabi.Flagcount("w", "debug type checking", &Debug['w'])
 	flag.BoolVar(&use_writebarrier, "wb", true, "enable write barrier")
 	var flag_shared bool
 	var flag_dynlink bool
@@ -219,7 +220,7 @@ func Main(archInit func(*Arch)) {
 	flag.StringVar(&blockprofile, "blockprofile", "", "write block profile to `file`")
 	flag.StringVar(&mutexprofile, "mutexprofile", "", "write mutex profile to `file`")
 	flag.StringVar(&benchfile, "bench", "", "append benchmark times to `file`")
-	obj.Flagparse(usage)
+	objabi.Flagparse(usage)
 
 	Ctxt.Flag_shared = flag_dynlink || flag_shared
 	Ctxt.Flag_dynlink = flag_dynlink
@@ -600,7 +601,7 @@ func writebench(filename string) error {
 	}
 
 	var buf bytes.Buffer
-	fmt.Fprintln(&buf, "commit:", obj.Version)
+	fmt.Fprintln(&buf, "commit:", objabi.Version)
 	fmt.Fprintln(&buf, "goos:", runtime.GOOS)
 	fmt.Fprintln(&buf, "goarch:", runtime.GOARCH)
 	timings.Write(&buf, "BenchmarkCompile:"+myimportpath+":")
@@ -723,7 +724,7 @@ func findpkg(name string) (file string, ok bool) {
 		}
 	}
 
-	if obj.GOROOT != "" {
+	if objabi.GOROOT != "" {
 		suffix := ""
 		suffixsep := ""
 		if flag_installsuffix != "" {
@@ -737,11 +738,11 @@ func findpkg(name string) (file string, ok bool) {
 			suffix = "msan"
 		}
 
-		file = fmt.Sprintf("%s/pkg/%s_%s%s%s/%s.a", obj.GOROOT, obj.GOOS, obj.GOARCH, suffixsep, suffix, name)
+		file = fmt.Sprintf("%s/pkg/%s_%s%s%s/%s.a", objabi.GOROOT, objabi.GOOS, objabi.GOARCH, suffixsep, suffix, name)
 		if _, err := os.Stat(file); err == nil {
 			return file, true
 		}
-		file = fmt.Sprintf("%s/pkg/%s_%s%s%s/%s.o", obj.GOROOT, obj.GOOS, obj.GOARCH, suffixsep, suffix, name)
+		file = fmt.Sprintf("%s/pkg/%s_%s%s%s/%s.o", objabi.GOROOT, objabi.GOOS, objabi.GOARCH, suffixsep, suffix, name)
 		if _, err := os.Stat(file); err == nil {
 			return file, true
 		}
@@ -887,7 +888,7 @@ func importfile(f *Val) *types.Pkg {
 			errorexit()
 		}
 
-		q := fmt.Sprintf("%s %s %s %s", obj.GOOS, obj.GOARCH, obj.Version, obj.Expstring())
+		q := fmt.Sprintf("%s %s %s %s", objabi.GOOS, objabi.GOARCH, objabi.Version, objabi.Expstring())
 		if p[10:] != q {
 			yyerror("import %s: object is [%s] expected [%s]", file, p[10:], q)
 			errorexit()
diff --git a/src/cmd/compile/internal/gc/noder.go b/src/cmd/compile/internal/gc/noder.go
index 3d6eaf6e81..cc93766fe2 100644
--- a/src/cmd/compile/internal/gc/noder.go
+++ b/src/cmd/compile/internal/gc/noder.go
@@ -13,7 +13,7 @@ import (
 
 	"cmd/compile/internal/syntax"
 	"cmd/compile/internal/types"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/src"
 )
 
@@ -66,7 +66,7 @@ func yyerrorpos(pos src.Pos, format string, args ...interface{}) {
 var pathPrefix string
 
 func absFilename(name string) string {
-	return obj.AbsFile(Ctxt.Pathname, name, pathPrefix)
+	return objabi.AbsFile(Ctxt.Pathname, name, pathPrefix)
 }
 
 // noder transforms package syntax's AST into a Node tree.
diff --git a/src/cmd/compile/internal/gc/obj.go b/src/cmd/compile/internal/gc/obj.go
index 9b3eca0b44..419a6ec057 100644
--- a/src/cmd/compile/internal/gc/obj.go
+++ b/src/cmd/compile/internal/gc/obj.go
@@ -8,6 +8,7 @@ import (
 	"cmd/compile/internal/types"
 	"cmd/internal/bio"
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"crypto/sha256"
 	"fmt"
 	"io"
@@ -73,7 +74,7 @@ func dumpobj1(outfile string, mode int) {
 	}
 
 	printheader := func() {
-		fmt.Fprintf(bout, "go object %s %s %s %s\n", obj.GOOS, obj.GOARCH, obj.Version, obj.Expstring())
+		fmt.Fprintf(bout, "go object %s %s %s %s\n", objabi.GOOS, objabi.GOARCH, objabi.Version, objabi.Expstring())
 		if buildid != "" {
 			fmt.Fprintf(bout, "build id %q\n", buildid)
 		}
@@ -277,7 +278,7 @@ func duintxx(s *types.Sym, off int, v uint64, wid int) int {
 func duintxxLSym(s *obj.LSym, off int, v uint64, wid int) int {
 	if s.Type == 0 {
 		// TODO(josharian): Do this in obj.prepwrite instead.
-		s.Type = obj.SDATA
+		s.Type = objabi.SDATA
 	}
 	if off&(wid-1) != 0 {
 		Fatalf("duintxxLSym: misaligned: v=%d wid=%d off=%d", v, wid, off)
diff --git a/src/cmd/compile/internal/gc/pgen.go b/src/cmd/compile/internal/gc/pgen.go
index 1299756295..6e182f9dd2 100644
--- a/src/cmd/compile/internal/gc/pgen.go
+++ b/src/cmd/compile/internal/gc/pgen.go
@@ -9,6 +9,7 @@ import (
 	"cmd/compile/internal/types"
 	"cmd/internal/dwarf"
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/src"
 	"cmd/internal/sys"
 	"fmt"
@@ -250,7 +251,7 @@ func debuginfo(fnsym *obj.LSym, curfn interface{}) []*dwarf.Var {
 			if Ctxt.FixedFrameSize() == 0 {
 				offs -= int64(Widthptr)
 			}
-			if obj.Framepointer_enabled(obj.GOOS, obj.GOARCH) {
+			if objabi.Framepointer_enabled(objabi.GOOS, objabi.GOARCH) {
 				offs -= int64(Widthptr)
 			}
 
@@ -297,7 +298,7 @@ func fieldtrack(fnsym *obj.LSym, tracked map[*types.Sym]struct{}) {
 	if fnsym == nil {
 		return
 	}
-	if obj.Fieldtrack_enabled == 0 || len(tracked) == 0 {
+	if objabi.Fieldtrack_enabled == 0 || len(tracked) == 0 {
 		return
 	}
 
@@ -309,7 +310,7 @@ func fieldtrack(fnsym *obj.LSym, tracked map[*types.Sym]struct{}) {
 	for _, sym := range trackSyms {
 		r := obj.Addrel(fnsym)
 		r.Sym = Linksym(sym)
-		r.Type = obj.R_USEFIELD
+		r.Type = objabi.R_USEFIELD
 	}
 }
 
diff --git a/src/cmd/compile/internal/gc/reflect.go b/src/cmd/compile/internal/gc/reflect.go
index 9597aa893d..aa2146c5fb 100644
--- a/src/cmd/compile/internal/gc/reflect.go
+++ b/src/cmd/compile/internal/gc/reflect.go
@@ -8,6 +8,7 @@ import (
 	"cmd/compile/internal/types"
 	"cmd/internal/gcprog"
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/src"
 	"fmt"
 	"os"
@@ -677,38 +678,38 @@ func dmethodptrOffLSym(s *obj.LSym, ot int, x *obj.LSym) int {
 	r.Off = int32(ot)
 	r.Siz = 4
 	r.Sym = x
-	r.Type = obj.R_METHODOFF
+	r.Type = objabi.R_METHODOFF
 	return ot + 4
 }
 
 var kinds = []int{
-	TINT:        obj.KindInt,
-	TUINT:       obj.KindUint,
-	TINT8:       obj.KindInt8,
-	TUINT8:      obj.KindUint8,
-	TINT16:      obj.KindInt16,
-	TUINT16:     obj.KindUint16,
-	TINT32:      obj.KindInt32,
-	TUINT32:     obj.KindUint32,
-	TINT64:      obj.KindInt64,
-	TUINT64:     obj.KindUint64,
-	TUINTPTR:    obj.KindUintptr,
-	TFLOAT32:    obj.KindFloat32,
-	TFLOAT64:    obj.KindFloat64,
-	TBOOL:       obj.KindBool,
-	TSTRING:     obj.KindString,
-	TPTR32:      obj.KindPtr,
-	TPTR64:      obj.KindPtr,
-	TSTRUCT:     obj.KindStruct,
-	TINTER:      obj.KindInterface,
-	TCHAN:       obj.KindChan,
-	TMAP:        obj.KindMap,
-	TARRAY:      obj.KindArray,
-	TSLICE:      obj.KindSlice,
-	TFUNC:       obj.KindFunc,
-	TCOMPLEX64:  obj.KindComplex64,
-	TCOMPLEX128: obj.KindComplex128,
-	TUNSAFEPTR:  obj.KindUnsafePointer,
+	TINT:        objabi.KindInt,
+	TUINT:       objabi.KindUint,
+	TINT8:       objabi.KindInt8,
+	TUINT8:      objabi.KindUint8,
+	TINT16:      objabi.KindInt16,
+	TUINT16:     objabi.KindUint16,
+	TINT32:      objabi.KindInt32,
+	TUINT32:     objabi.KindUint32,
+	TINT64:      objabi.KindInt64,
+	TUINT64:     objabi.KindUint64,
+	TUINTPTR:    objabi.KindUintptr,
+	TFLOAT32:    objabi.KindFloat32,
+	TFLOAT64:    objabi.KindFloat64,
+	TBOOL:       objabi.KindBool,
+	TSTRING:     objabi.KindString,
+	TPTR32:      objabi.KindPtr,
+	TPTR64:      objabi.KindPtr,
+	TSTRUCT:     objabi.KindStruct,
+	TINTER:      objabi.KindInterface,
+	TCHAN:       objabi.KindChan,
+	TMAP:        objabi.KindMap,
+	TARRAY:      objabi.KindArray,
+	TSLICE:      objabi.KindSlice,
+	TFUNC:       objabi.KindFunc,
+	TCOMPLEX64:  objabi.KindComplex64,
+	TCOMPLEX128: objabi.KindComplex128,
+	TUNSAFEPTR:  objabi.KindUnsafePointer,
 }
 
 // typeptrdata returns the length in bytes of the prefix of t
@@ -867,13 +868,13 @@ func dcommontype(s *types.Sym, ot int, t *types.Type) int {
 
 	i = kinds[t.Etype]
 	if !types.Haspointers(t) {
-		i |= obj.KindNoPointers
+		i |= objabi.KindNoPointers
 	}
 	if isdirectiface(t) {
-		i |= obj.KindDirectIface
+		i |= objabi.KindDirectIface
 	}
 	if useGCProg {
-		i |= obj.KindGCProg
+		i |= objabi.KindGCProg
 	}
 	ot = duint8(s, ot, uint8(i)) // kind
 	if algsym == nil {
diff --git a/src/cmd/compile/internal/gc/ssa.go b/src/cmd/compile/internal/gc/ssa.go
index cfb973405d..9bd731a39a 100644
--- a/src/cmd/compile/internal/gc/ssa.go
+++ b/src/cmd/compile/internal/gc/ssa.go
@@ -15,6 +15,7 @@ import (
 	"cmd/compile/internal/ssa"
 	"cmd/compile/internal/types"
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/src"
 	"cmd/internal/sys"
 )
@@ -4663,7 +4664,7 @@ func (s *SSAGenState) Call(v *ssa.Value) *obj.Prog {
 		Fatalf("missing stack map index for %v", v.LongString())
 	}
 	p := s.Prog(obj.APCDATA)
-	Addrconst(&p.From, obj.PCDATA_StackMapIndex)
+	Addrconst(&p.From, objabi.PCDATA_StackMapIndex)
 	Addrconst(&p.To, int64(idx))
 
 	if sym, _ := v.Aux.(*obj.LSym); sym == Deferreturn {
diff --git a/src/cmd/compile/internal/gc/subr.go b/src/cmd/compile/internal/gc/subr.go
index a3be163c4e..cda650b055 100644
--- a/src/cmd/compile/internal/gc/subr.go
+++ b/src/cmd/compile/internal/gc/subr.go
@@ -7,7 +7,7 @@ package gc
 import (
 	"bytes"
 	"cmd/compile/internal/types"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/src"
 	"crypto/md5"
 	"encoding/binary"
@@ -168,7 +168,7 @@ func Fatalf(fmt_ string, args ...interface{}) {
 	fmt.Printf("\n")
 
 	// If this is a released compiler version, ask for a bug report.
-	if strings.HasPrefix(obj.Version, "release") {
+	if strings.HasPrefix(objabi.Version, "release") {
 		fmt.Printf("\n")
 		fmt.Printf("Please file a bug report including a short program that triggers the error.\n")
 		fmt.Printf("https://golang.org/issue/new\n")
diff --git a/src/cmd/compile/internal/gc/typecheck.go b/src/cmd/compile/internal/gc/typecheck.go
index b8c81b528a..58961a8b16 100644
--- a/src/cmd/compile/internal/gc/typecheck.go
+++ b/src/cmd/compile/internal/gc/typecheck.go
@@ -6,7 +6,7 @@ package gc
 
 import (
 	"cmd/compile/internal/types"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/src"
 	"fmt"
 	"math"
@@ -2463,7 +2463,7 @@ func lookdot(n *Node, t *types.Type, dostrcmp int) *types.Field {
 		}
 		n.Xoffset = f1.Offset
 		n.Type = f1.Type
-		if obj.Fieldtrack_enabled > 0 {
+		if objabi.Fieldtrack_enabled > 0 {
 			dotField[typeSymKey{t.Orig, s}] = f1
 		}
 		if t.IsInterface() {
diff --git a/src/cmd/compile/internal/gc/walk.go b/src/cmd/compile/internal/gc/walk.go
index 954433c447..f9a81d7dbf 100644
--- a/src/cmd/compile/internal/gc/walk.go
+++ b/src/cmd/compile/internal/gc/walk.go
@@ -6,7 +6,7 @@ package gc
 
 import (
 	"cmd/compile/internal/types"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"fmt"
 	"strings"
@@ -3477,7 +3477,7 @@ func usemethod(n *Node) {
 }
 
 func usefield(n *Node) {
-	if obj.Fieldtrack_enabled == 0 {
+	if objabi.Fieldtrack_enabled == 0 {
 		return
 	}
 
diff --git a/src/cmd/compile/internal/mips/galign.go b/src/cmd/compile/internal/mips/galign.go
index 30e3e985eb..cb72b6d728 100644
--- a/src/cmd/compile/internal/mips/galign.go
+++ b/src/cmd/compile/internal/mips/galign.go
@@ -7,13 +7,13 @@ package mips
 import (
 	"cmd/compile/internal/gc"
 	"cmd/compile/internal/ssa"
-	"cmd/internal/obj"
 	"cmd/internal/obj/mips"
+	"cmd/internal/objabi"
 )
 
 func Init(arch *gc.Arch) {
 	arch.LinkArch = &mips.Linkmips
-	if obj.GOARCH == "mipsle" {
+	if objabi.GOARCH == "mipsle" {
 		arch.LinkArch = &mips.Linkmipsle
 	}
 	arch.REGSP = mips.REGSP
diff --git a/src/cmd/compile/internal/mips64/galign.go b/src/cmd/compile/internal/mips64/galign.go
index cd17c62d61..698f60573d 100644
--- a/src/cmd/compile/internal/mips64/galign.go
+++ b/src/cmd/compile/internal/mips64/galign.go
@@ -7,13 +7,13 @@ package mips64
 import (
 	"cmd/compile/internal/gc"
 	"cmd/compile/internal/ssa"
-	"cmd/internal/obj"
 	"cmd/internal/obj/mips"
+	"cmd/internal/objabi"
 )
 
 func Init(arch *gc.Arch) {
 	arch.LinkArch = &mips.Linkmips64
-	if obj.GOARCH == "mips64le" {
+	if objabi.GOARCH == "mips64le" {
 		arch.LinkArch = &mips.Linkmips64le
 	}
 	arch.REGSP = mips.REGSP
diff --git a/src/cmd/compile/internal/ppc64/galign.go b/src/cmd/compile/internal/ppc64/galign.go
index c8ce1e21ba..3dbe8ff35c 100644
--- a/src/cmd/compile/internal/ppc64/galign.go
+++ b/src/cmd/compile/internal/ppc64/galign.go
@@ -6,13 +6,13 @@ package ppc64
 
 import (
 	"cmd/compile/internal/gc"
-	"cmd/internal/obj"
 	"cmd/internal/obj/ppc64"
+	"cmd/internal/objabi"
 )
 
 func Init(arch *gc.Arch) {
 	arch.LinkArch = &ppc64.Linkppc64
-	if obj.GOARCH == "ppc64le" {
+	if objabi.GOARCH == "ppc64le" {
 		arch.LinkArch = &ppc64.Linkppc64le
 	}
 	arch.REGSP = ppc64.REGSP
diff --git a/src/cmd/compile/internal/ssa/compile.go b/src/cmd/compile/internal/ssa/compile.go
index 551521bbe8..38054a1fde 100644
--- a/src/cmd/compile/internal/ssa/compile.go
+++ b/src/cmd/compile/internal/ssa/compile.go
@@ -5,7 +5,7 @@
 package ssa
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/src"
 	"fmt"
 	"log"
@@ -352,7 +352,7 @@ var passes = [...]pass{
 	{name: "fuse", fn: fuse},
 	{name: "dse", fn: dse},
 	{name: "insert resched checks", fn: insertLoopReschedChecks,
-		disabled: obj.Preemptibleloops_enabled == 0}, // insert resched checks in loops.
+		disabled: objabi.Preemptibleloops_enabled == 0}, // insert resched checks in loops.
 	{name: "tighten", fn: tighten}, // move values closer to their uses
 	{name: "lower", fn: lower, required: true},
 	{name: "lowered cse", fn: cse},
diff --git a/src/cmd/compile/internal/ssa/config.go b/src/cmd/compile/internal/ssa/config.go
index 96a4c2b8ae..d87cbca61f 100644
--- a/src/cmd/compile/internal/ssa/config.go
+++ b/src/cmd/compile/internal/ssa/config.go
@@ -6,6 +6,7 @@ package ssa
 
 import (
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/src"
 	"os"
 	"strconv"
@@ -202,7 +203,7 @@ func NewConfig(arch string, types Types, ctxt *obj.Link, optimize bool) *Config
 		c.FPReg = framepointerRegARM64
 		c.LinkReg = linkRegARM64
 		c.hasGReg = true
-		c.noDuffDevice = obj.GOOS == "darwin" // darwin linker cannot handle BR26 reloc with non-zero addend
+		c.noDuffDevice = objabi.GOOS == "darwin" // darwin linker cannot handle BR26 reloc with non-zero addend
 	case "ppc64":
 		c.BigEndian = true
 		fallthrough
@@ -271,11 +272,11 @@ func NewConfig(arch string, types Types, ctxt *obj.Link, optimize bool) *Config
 	}
 	c.ctxt = ctxt
 	c.optimize = optimize
-	c.nacl = obj.GOOS == "nacl"
+	c.nacl = objabi.GOOS == "nacl"
 
 	// Don't use Duff's device on Plan 9 AMD64, because floating
 	// point operations are not allowed in note handler.
-	if obj.GOOS == "plan9" && arch == "amd64" {
+	if objabi.GOOS == "plan9" && arch == "amd64" {
 		c.noDuffDevice = true
 	}
 
diff --git a/src/cmd/compile/internal/ssa/gen/ARM.rules b/src/cmd/compile/internal/ssa/gen/ARM.rules
index 52612ec2c1..9a8bbad44e 100644
--- a/src/cmd/compile/internal/ssa/gen/ARM.rules
+++ b/src/cmd/compile/internal/ssa/gen/ARM.rules
@@ -89,10 +89,10 @@
 
 // count trailing zero for ARMv5 and ARMv6
 // 32 - CLZ(x&-x - 1)
-(Ctz32 <t> x) && obj.GOARM<=6 -> (RSBconst [32] (CLZ <t> (SUBconst <t> (AND <t> x (RSBconst <t> [0] x)) [1])))
+(Ctz32 <t> x) && objabi.GOARM<=6 -> (RSBconst [32] (CLZ <t> (SUBconst <t> (AND <t> x (RSBconst <t> [0] x)) [1])))
 
 // count trailing zero for ARMv7
-(Ctz32 <t> x) && obj.GOARM==7 -> (CLZ <t> (RBIT <t> x))
+(Ctz32 <t> x) && objabi.GOARM==7 -> (CLZ <t> (RBIT <t> x))
 
 // bit length
 (BitLen32 <t> x) -> (RSBconst [32] (CLZ <t> x))
@@ -106,13 +106,13 @@
 // t5 = x right rotate 8 bits  -- (d,   a,   b,   c  )
 // result = t4 ^ t5            -- (d,   c,   b,   a  )
 // using shifted ops this can be done in 4 instructions.
-(Bswap32 <t> x) && obj.GOARM==5 ->
+(Bswap32 <t> x) && objabi.GOARM==5 ->
 	(XOR <t>
 		(SRLconst <t> (BICconst <t> (XOR <t> x (SRRconst <t> [16] x)) [0xff0000]) [8])
 		(SRRconst <t> x [8]))
 
 // byte swap for ARMv6 and above
-(Bswap32 x) && obj.GOARM>=6 -> (REV x)
+(Bswap32 x) && objabi.GOARM>=6 -> (REV x)
 
 // boolean ops -- booleans are represented with 0=false, 1=true
 (AndB x y) -> (AND x y)
diff --git a/src/cmd/compile/internal/ssa/gen/rulegen.go b/src/cmd/compile/internal/ssa/gen/rulegen.go
index 35c5313a66..c522035550 100644
--- a/src/cmd/compile/internal/ssa/gen/rulegen.go
+++ b/src/cmd/compile/internal/ssa/gen/rulegen.go
@@ -156,8 +156,11 @@ func genRules(arch arch) {
 	fmt.Fprintln(w, "package ssa")
 	fmt.Fprintln(w, "import \"math\"")
 	fmt.Fprintln(w, "import \"cmd/internal/obj\"")
-	fmt.Fprintln(w, "var _ = math.MinInt8 // in case not otherwise used")
-	fmt.Fprintln(w, "var _ = obj.ANOP     // in case not otherwise used")
+	fmt.Fprintln(w, "import \"cmd/internal/objabi\"")
+	fmt.Fprintln(w, "var _ = math.MinInt8  // in case not otherwise used")
+	fmt.Fprintln(w, "var _ = obj.ANOP      // in case not otherwise used")
+	fmt.Fprintln(w, "var _ = objabi.GOROOT // in case not otherwise used")
+	fmt.Fprintln(w)
 
 	// Main rewrite routine is a switch on v.Op.
 	fmt.Fprintf(w, "func rewriteValue%s(v *Value) bool {\n", arch.name)
diff --git a/src/cmd/compile/internal/ssa/regalloc.go b/src/cmd/compile/internal/ssa/regalloc.go
index 7361e1392b..08b4d3aca1 100644
--- a/src/cmd/compile/internal/ssa/regalloc.go
+++ b/src/cmd/compile/internal/ssa/regalloc.go
@@ -114,7 +114,7 @@
 package ssa
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/src"
 	"fmt"
 	"unsafe"
@@ -552,7 +552,7 @@ func (s *regAllocState) init(f *Func) {
 			// Leaf functions don't save/restore the link register.
 			s.allocatable &^= 1 << uint(s.f.Config.LinkReg)
 		}
-		if s.f.Config.arch == "arm" && obj.GOARM == 5 {
+		if s.f.Config.arch == "arm" && objabi.GOARM == 5 {
 			// On ARMv5 we insert softfloat calls at each FP instruction.
 			// This clobbers LR almost everywhere. Disable allocating LR
 			// on ARMv5.
diff --git a/src/cmd/compile/internal/ssa/rewrite386.go b/src/cmd/compile/internal/ssa/rewrite386.go
index ee77124a6e..55b8a4d018 100644
--- a/src/cmd/compile/internal/ssa/rewrite386.go
+++ b/src/cmd/compile/internal/ssa/rewrite386.go
@@ -5,9 +5,12 @@ package ssa
 
 import "math"
 import "cmd/internal/obj"
+import "cmd/internal/objabi"
+
+var _ = math.MinInt8  // in case not otherwise used
+var _ = obj.ANOP      // in case not otherwise used
+var _ = objabi.GOROOT // in case not otherwise used
 
-var _ = math.MinInt8 // in case not otherwise used
-var _ = obj.ANOP     // in case not otherwise used
 func rewriteValue386(v *Value) bool {
 	switch v.Op {
 	case Op386ADCL:
diff --git a/src/cmd/compile/internal/ssa/rewriteAMD64.go b/src/cmd/compile/internal/ssa/rewriteAMD64.go
index b6a54239bd..2163629419 100644
--- a/src/cmd/compile/internal/ssa/rewriteAMD64.go
+++ b/src/cmd/compile/internal/ssa/rewriteAMD64.go
@@ -5,9 +5,12 @@ package ssa
 
 import "math"
 import "cmd/internal/obj"
+import "cmd/internal/objabi"
+
+var _ = math.MinInt8  // in case not otherwise used
+var _ = obj.ANOP      // in case not otherwise used
+var _ = objabi.GOROOT // in case not otherwise used
 
-var _ = math.MinInt8 // in case not otherwise used
-var _ = obj.ANOP     // in case not otherwise used
 func rewriteValueAMD64(v *Value) bool {
 	switch v.Op {
 	case OpAMD64ADDL:
diff --git a/src/cmd/compile/internal/ssa/rewriteARM.go b/src/cmd/compile/internal/ssa/rewriteARM.go
index 623f3475fd..3651c6de36 100644
--- a/src/cmd/compile/internal/ssa/rewriteARM.go
+++ b/src/cmd/compile/internal/ssa/rewriteARM.go
@@ -5,9 +5,12 @@ package ssa
 
 import "math"
 import "cmd/internal/obj"
+import "cmd/internal/objabi"
+
+var _ = math.MinInt8  // in case not otherwise used
+var _ = obj.ANOP      // in case not otherwise used
+var _ = objabi.GOROOT // in case not otherwise used
 
-var _ = math.MinInt8 // in case not otherwise used
-var _ = obj.ANOP     // in case not otherwise used
 func rewriteValueARM(v *Value) bool {
 	switch v.Op {
 	case OpARMADC:
@@ -13196,12 +13199,12 @@ func rewriteValueARM_OpBswap32(v *Value) bool {
 	b := v.Block
 	_ = b
 	// match: (Bswap32 <t> x)
-	// cond: obj.GOARM==5
+	// cond: objabi.GOARM==5
 	// result: (XOR <t> 		(SRLconst <t> (BICconst <t> (XOR <t> x (SRRconst <t> [16] x)) [0xff0000]) [8]) 		(SRRconst <t> x [8]))
 	for {
 		t := v.Type
 		x := v.Args[0]
-		if !(obj.GOARM == 5) {
+		if !(objabi.GOARM == 5) {
 			break
 		}
 		v.reset(OpARMXOR)
@@ -13226,11 +13229,11 @@ func rewriteValueARM_OpBswap32(v *Value) bool {
 		return true
 	}
 	// match: (Bswap32 x)
-	// cond: obj.GOARM>=6
+	// cond: objabi.GOARM>=6
 	// result: (REV x)
 	for {
 		x := v.Args[0]
-		if !(obj.GOARM >= 6) {
+		if !(objabi.GOARM >= 6) {
 			break
 		}
 		v.reset(OpARMREV)
@@ -13382,12 +13385,12 @@ func rewriteValueARM_OpCtz32(v *Value) bool {
 	b := v.Block
 	_ = b
 	// match: (Ctz32 <t> x)
-	// cond: obj.GOARM<=6
+	// cond: objabi.GOARM<=6
 	// result: (RSBconst [32] (CLZ <t> (SUBconst <t> (AND <t> x (RSBconst <t> [0] x)) [1])))
 	for {
 		t := v.Type
 		x := v.Args[0]
-		if !(obj.GOARM <= 6) {
+		if !(objabi.GOARM <= 6) {
 			break
 		}
 		v.reset(OpARMRSBconst)
@@ -13407,12 +13410,12 @@ func rewriteValueARM_OpCtz32(v *Value) bool {
 		return true
 	}
 	// match: (Ctz32 <t> x)
-	// cond: obj.GOARM==7
+	// cond: objabi.GOARM==7
 	// result: (CLZ <t> (RBIT <t> x))
 	for {
 		t := v.Type
 		x := v.Args[0]
-		if !(obj.GOARM == 7) {
+		if !(objabi.GOARM == 7) {
 			break
 		}
 		v.reset(OpARMCLZ)
diff --git a/src/cmd/compile/internal/ssa/rewriteARM64.go b/src/cmd/compile/internal/ssa/rewriteARM64.go
index 31d8002fe8..2cda941412 100644
--- a/src/cmd/compile/internal/ssa/rewriteARM64.go
+++ b/src/cmd/compile/internal/ssa/rewriteARM64.go
@@ -5,9 +5,12 @@ package ssa
 
 import "math"
 import "cmd/internal/obj"
+import "cmd/internal/objabi"
+
+var _ = math.MinInt8  // in case not otherwise used
+var _ = obj.ANOP      // in case not otherwise used
+var _ = objabi.GOROOT // in case not otherwise used
 
-var _ = math.MinInt8 // in case not otherwise used
-var _ = obj.ANOP     // in case not otherwise used
 func rewriteValueARM64(v *Value) bool {
 	switch v.Op {
 	case OpARM64ADD:
diff --git a/src/cmd/compile/internal/ssa/rewriteMIPS.go b/src/cmd/compile/internal/ssa/rewriteMIPS.go
index 740b62a83f..0a2adbd47b 100644
--- a/src/cmd/compile/internal/ssa/rewriteMIPS.go
+++ b/src/cmd/compile/internal/ssa/rewriteMIPS.go
@@ -5,9 +5,12 @@ package ssa
 
 import "math"
 import "cmd/internal/obj"
+import "cmd/internal/objabi"
+
+var _ = math.MinInt8  // in case not otherwise used
+var _ = obj.ANOP      // in case not otherwise used
+var _ = objabi.GOROOT // in case not otherwise used
 
-var _ = math.MinInt8 // in case not otherwise used
-var _ = obj.ANOP     // in case not otherwise used
 func rewriteValueMIPS(v *Value) bool {
 	switch v.Op {
 	case OpAdd16:
diff --git a/src/cmd/compile/internal/ssa/rewriteMIPS64.go b/src/cmd/compile/internal/ssa/rewriteMIPS64.go
index 8b4ff379a4..d4f2893ca9 100644
--- a/src/cmd/compile/internal/ssa/rewriteMIPS64.go
+++ b/src/cmd/compile/internal/ssa/rewriteMIPS64.go
@@ -5,9 +5,12 @@ package ssa
 
 import "math"
 import "cmd/internal/obj"
+import "cmd/internal/objabi"
+
+var _ = math.MinInt8  // in case not otherwise used
+var _ = obj.ANOP      // in case not otherwise used
+var _ = objabi.GOROOT // in case not otherwise used
 
-var _ = math.MinInt8 // in case not otherwise used
-var _ = obj.ANOP     // in case not otherwise used
 func rewriteValueMIPS64(v *Value) bool {
 	switch v.Op {
 	case OpAdd16:
diff --git a/src/cmd/compile/internal/ssa/rewritePPC64.go b/src/cmd/compile/internal/ssa/rewritePPC64.go
index 9829cf0763..4afb276312 100644
--- a/src/cmd/compile/internal/ssa/rewritePPC64.go
+++ b/src/cmd/compile/internal/ssa/rewritePPC64.go
@@ -5,9 +5,12 @@ package ssa
 
 import "math"
 import "cmd/internal/obj"
+import "cmd/internal/objabi"
+
+var _ = math.MinInt8  // in case not otherwise used
+var _ = obj.ANOP      // in case not otherwise used
+var _ = objabi.GOROOT // in case not otherwise used
 
-var _ = math.MinInt8 // in case not otherwise used
-var _ = obj.ANOP     // in case not otherwise used
 func rewriteValuePPC64(v *Value) bool {
 	switch v.Op {
 	case OpAdd16:
diff --git a/src/cmd/compile/internal/ssa/rewriteS390X.go b/src/cmd/compile/internal/ssa/rewriteS390X.go
index adb4ee92a1..4c121f4fc3 100644
--- a/src/cmd/compile/internal/ssa/rewriteS390X.go
+++ b/src/cmd/compile/internal/ssa/rewriteS390X.go
@@ -5,9 +5,12 @@ package ssa
 
 import "math"
 import "cmd/internal/obj"
+import "cmd/internal/objabi"
+
+var _ = math.MinInt8  // in case not otherwise used
+var _ = obj.ANOP      // in case not otherwise used
+var _ = objabi.GOROOT // in case not otherwise used
 
-var _ = math.MinInt8 // in case not otherwise used
-var _ = obj.ANOP     // in case not otherwise used
 func rewriteValueS390X(v *Value) bool {
 	switch v.Op {
 	case OpAdd16:
diff --git a/src/cmd/compile/internal/ssa/rewritedec.go b/src/cmd/compile/internal/ssa/rewritedec.go
index 9c99b83070..305fc7bd72 100644
--- a/src/cmd/compile/internal/ssa/rewritedec.go
+++ b/src/cmd/compile/internal/ssa/rewritedec.go
@@ -5,9 +5,12 @@ package ssa
 
 import "math"
 import "cmd/internal/obj"
+import "cmd/internal/objabi"
+
+var _ = math.MinInt8  // in case not otherwise used
+var _ = obj.ANOP      // in case not otherwise used
+var _ = objabi.GOROOT // in case not otherwise used
 
-var _ = math.MinInt8 // in case not otherwise used
-var _ = obj.ANOP     // in case not otherwise used
 func rewriteValuedec(v *Value) bool {
 	switch v.Op {
 	case OpComplexImag:
diff --git a/src/cmd/compile/internal/ssa/rewritedec64.go b/src/cmd/compile/internal/ssa/rewritedec64.go
index 605128c767..4b9b3783e2 100644
--- a/src/cmd/compile/internal/ssa/rewritedec64.go
+++ b/src/cmd/compile/internal/ssa/rewritedec64.go
@@ -5,9 +5,12 @@ package ssa
 
 import "math"
 import "cmd/internal/obj"
+import "cmd/internal/objabi"
+
+var _ = math.MinInt8  // in case not otherwise used
+var _ = obj.ANOP      // in case not otherwise used
+var _ = objabi.GOROOT // in case not otherwise used
 
-var _ = math.MinInt8 // in case not otherwise used
-var _ = obj.ANOP     // in case not otherwise used
 func rewriteValuedec64(v *Value) bool {
 	switch v.Op {
 	case OpAdd64:
diff --git a/src/cmd/compile/internal/ssa/rewritegeneric.go b/src/cmd/compile/internal/ssa/rewritegeneric.go
index a602279d1d..33e777025f 100644
--- a/src/cmd/compile/internal/ssa/rewritegeneric.go
+++ b/src/cmd/compile/internal/ssa/rewritegeneric.go
@@ -5,9 +5,12 @@ package ssa
 
 import "math"
 import "cmd/internal/obj"
+import "cmd/internal/objabi"
+
+var _ = math.MinInt8  // in case not otherwise used
+var _ = obj.ANOP      // in case not otherwise used
+var _ = objabi.GOROOT // in case not otherwise used
 
-var _ = math.MinInt8 // in case not otherwise used
-var _ = obj.ANOP     // in case not otherwise used
 func rewriteValuegeneric(v *Value) bool {
 	switch v.Op {
 	case OpAdd16:
diff --git a/src/cmd/compile/internal/x86/galign.go b/src/cmd/compile/internal/x86/galign.go
index b5cf044bc7..69f2011d25 100644
--- a/src/cmd/compile/internal/x86/galign.go
+++ b/src/cmd/compile/internal/x86/galign.go
@@ -6,8 +6,8 @@ package x86
 
 import (
 	"cmd/compile/internal/gc"
-	"cmd/internal/obj"
 	"cmd/internal/obj/x86"
+	"cmd/internal/objabi"
 	"fmt"
 	"os"
 )
@@ -15,7 +15,7 @@ import (
 func Init(arch *gc.Arch) {
 	arch.LinkArch = &x86.Link386
 	arch.REGSP = x86.REGSP
-	switch v := obj.GO386; v {
+	switch v := objabi.GO386; v {
 	case "387":
 		arch.Use387 = true
 		arch.SSAGenValue = ssaGenValue387
diff --git a/src/cmd/compile/main.go b/src/cmd/compile/main.go
index e67e862dd5..e699b91f5d 100644
--- a/src/cmd/compile/main.go
+++ b/src/cmd/compile/main.go
@@ -14,7 +14,7 @@ import (
 	"cmd/compile/internal/ppc64"
 	"cmd/compile/internal/s390x"
 	"cmd/compile/internal/x86"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"fmt"
 	"log"
 	"os"
@@ -40,9 +40,9 @@ func main() {
 	log.SetFlags(0)
 	log.SetPrefix("compile: ")
 
-	archInit, ok := archInits[obj.GOARCH]
+	archInit, ok := archInits[objabi.GOARCH]
 	if !ok {
-		fmt.Fprintf(os.Stderr, "compile: unknown architecture %q\n", obj.GOARCH)
+		fmt.Fprintf(os.Stderr, "compile: unknown architecture %q\n", objabi.GOARCH)
 		os.Exit(2)
 	}
 
diff --git a/src/cmd/dist/buildruntime.go b/src/cmd/dist/buildruntime.go
index d696beb5b3..1467c59c6c 100644
--- a/src/cmd/dist/buildruntime.go
+++ b/src/cmd/dist/buildruntime.go
@@ -36,9 +36,9 @@ func mkzversion(dir, file string) {
 	writefile(out, file, writeSkipSame)
 }
 
-// mkzbootstrap writes cmd/internal/obj/zbootstrap.go:
+// mkzbootstrap writes cmd/internal/objabi/zbootstrap.go:
 //
-//	package obj
+//	package objabi
 //
 //	const defaultGOROOT = <goroot>
 //	const defaultGO386 = <go386>
@@ -63,7 +63,7 @@ func mkzbootstrap(file string) {
 	out := fmt.Sprintf(
 		"// auto generated by go tool dist\n"+
 			"\n"+
-			"package obj\n"+
+			"package objabi\n"+
 			"\n"+
 			"import \"runtime\"\n"+
 			"\n"+
diff --git a/src/cmd/dist/buildtool.go b/src/cmd/dist/buildtool.go
index cedd41457d..8a3db32ad3 100644
--- a/src/cmd/dist/buildtool.go
+++ b/src/cmd/dist/buildtool.go
@@ -51,6 +51,7 @@ var bootstrapDirs = []string{
 	"cmd/internal/bio",
 	"cmd/internal/gcprog",
 	"cmd/internal/dwarf",
+	"cmd/internal/objabi",
 	"cmd/internal/obj",
 	"cmd/internal/obj/arm",
 	"cmd/internal/obj/arm64",
@@ -96,7 +97,7 @@ func bootstrapBuildTools() {
 	}
 	xprintf("##### Building Go toolchain using %s.\n", goroot_bootstrap)
 
-	mkzbootstrap(pathf("%s/src/cmd/internal/obj/zbootstrap.go", goroot))
+	mkzbootstrap(pathf("%s/src/cmd/internal/objabi/zbootstrap.go", goroot))
 
 	// Use $GOROOT/pkg/bootstrap as the bootstrap workspace root.
 	// We use a subdirectory of $GOROOT/pkg because that's the
diff --git a/src/cmd/internal/goobj/read.go b/src/cmd/internal/goobj/read.go
index d52eed1e66..5ed1a4163c 100644
--- a/src/cmd/internal/goobj/read.go
+++ b/src/cmd/internal/goobj/read.go
@@ -12,7 +12,7 @@ package goobj
 import (
 	"bufio"
 	"bytes"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"errors"
 	"fmt"
 	"io"
@@ -20,113 +20,16 @@ import (
 	"strings"
 )
 
-// A SymKind describes the kind of memory represented by a symbol.
-type SymKind int
-
-// This list is taken from include/link.h.
-
-// Defined SymKind values.
-// TODO(rsc): Give idiomatic Go names.
-// TODO(rsc): Reduce the number of symbol types in the object files.
-const (
-	// readonly, executable
-	STEXT      = SymKind(obj.STEXT)
-	SELFRXSECT = SymKind(obj.SELFRXSECT)
-
-	// readonly, non-executable
-	STYPE      = SymKind(obj.STYPE)
-	SSTRING    = SymKind(obj.SSTRING)
-	SGOSTRING  = SymKind(obj.SGOSTRING)
-	SGOFUNC    = SymKind(obj.SGOFUNC)
-	SRODATA    = SymKind(obj.SRODATA)
-	SFUNCTAB   = SymKind(obj.SFUNCTAB)
-	STYPELINK  = SymKind(obj.STYPELINK)
-	SITABLINK  = SymKind(obj.SITABLINK)
-	SSYMTAB    = SymKind(obj.SSYMTAB) // TODO: move to unmapped section
-	SPCLNTAB   = SymKind(obj.SPCLNTAB)
-	SELFROSECT = SymKind(obj.SELFROSECT)
-
-	// writable, non-executable
-	SMACHOPLT  = SymKind(obj.SMACHOPLT)
-	SELFSECT   = SymKind(obj.SELFSECT)
-	SMACHO     = SymKind(obj.SMACHO) // Mach-O __nl_symbol_ptr
-	SMACHOGOT  = SymKind(obj.SMACHOGOT)
-	SWINDOWS   = SymKind(obj.SWINDOWS)
-	SELFGOT    = SymKind(obj.SELFGOT)
-	SNOPTRDATA = SymKind(obj.SNOPTRDATA)
-	SINITARR   = SymKind(obj.SINITARR)
-	SDATA      = SymKind(obj.SDATA)
-	SBSS       = SymKind(obj.SBSS)
-	SNOPTRBSS  = SymKind(obj.SNOPTRBSS)
-	STLSBSS    = SymKind(obj.STLSBSS)
-
-	// not mapped
-	SXREF             = SymKind(obj.SXREF)
-	SMACHOSYMSTR      = SymKind(obj.SMACHOSYMSTR)
-	SMACHOSYMTAB      = SymKind(obj.SMACHOSYMTAB)
-	SMACHOINDIRECTPLT = SymKind(obj.SMACHOINDIRECTPLT)
-	SMACHOINDIRECTGOT = SymKind(obj.SMACHOINDIRECTGOT)
-	SFILE             = SymKind(obj.SFILE)
-	SFILEPATH         = SymKind(obj.SFILEPATH)
-	SCONST            = SymKind(obj.SCONST)
-	SDYNIMPORT        = SymKind(obj.SDYNIMPORT)
-	SHOSTOBJ          = SymKind(obj.SHOSTOBJ)
-)
-
-var symKindStrings = []string{
-	SBSS:              "SBSS",
-	SCONST:            "SCONST",
-	SDATA:             "SDATA",
-	SDYNIMPORT:        "SDYNIMPORT",
-	SELFROSECT:        "SELFROSECT",
-	SELFRXSECT:        "SELFRXSECT",
-	SELFSECT:          "SELFSECT",
-	SFILE:             "SFILE",
-	SFILEPATH:         "SFILEPATH",
-	SFUNCTAB:          "SFUNCTAB",
-	SGOFUNC:           "SGOFUNC",
-	SGOSTRING:         "SGOSTRING",
-	SHOSTOBJ:          "SHOSTOBJ",
-	SINITARR:          "SINITARR",
-	SMACHO:            "SMACHO",
-	SMACHOGOT:         "SMACHOGOT",
-	SMACHOINDIRECTGOT: "SMACHOINDIRECTGOT",
-	SMACHOINDIRECTPLT: "SMACHOINDIRECTPLT",
-	SMACHOPLT:         "SMACHOPLT",
-	SMACHOSYMSTR:      "SMACHOSYMSTR",
-	SMACHOSYMTAB:      "SMACHOSYMTAB",
-	SNOPTRBSS:         "SNOPTRBSS",
-	SNOPTRDATA:        "SNOPTRDATA",
-	SPCLNTAB:          "SPCLNTAB",
-	SRODATA:           "SRODATA",
-	SSTRING:           "SSTRING",
-	SSYMTAB:           "SSYMTAB",
-	STEXT:             "STEXT",
-	STLSBSS:           "STLSBSS",
-	STYPE:             "STYPE",
-	STYPELINK:         "STYPELINK",
-	SITABLINK:         "SITABLINK",
-	SWINDOWS:          "SWINDOWS",
-	SXREF:             "SXREF",
-}
-
-func (k SymKind) String() string {
-	if k < 0 || int(k) >= len(symKindStrings) {
-		return fmt.Sprintf("SymKind(%d)", k)
-	}
-	return symKindStrings[k]
-}
-
 // A Sym is a named symbol in an object file.
 type Sym struct {
-	SymID         // symbol identifier (name and version)
-	Kind  SymKind // kind of symbol
-	DupOK bool    // are duplicate definitions okay?
-	Size  int     // size of corresponding data
-	Type  SymID   // symbol for Go type information
-	Data  Data    // memory image of symbol
-	Reloc []Reloc // relocations to apply to Data
-	Func  *Func   // additional data for functions
+	SymID                // symbol identifier (name and version)
+	Kind  objabi.SymKind // kind of symbol
+	DupOK bool           // are duplicate definitions okay?
+	Size  int            // size of corresponding data
+	Type  SymID          // symbol for Go type information
+	Data  Data           // memory image of symbol
+	Reloc []Reloc        // relocations to apply to Data
+	Func  *Func          // additional data for functions
 }
 
 // A SymID - the combination of Name and Version - uniquely identifies
@@ -172,7 +75,7 @@ type Reloc struct {
 	// The Type records the form of address expected in the bytes
 	// described by the previous fields: absolute, PC-relative, and so on.
 	// TODO(rsc): The interpretation of Type is not exposed by this package.
-	Type obj.RelocType
+	Type objabi.RelocType
 }
 
 // A Var describes a variable in a function stack frame: a declared
@@ -646,7 +549,7 @@ func (r *objReader) parseObject(prefix []byte) error {
 		typ := r.readInt()
 		s := &Sym{SymID: r.readSymID()}
 		r.p.Syms = append(r.p.Syms, s)
-		s.Kind = SymKind(typ)
+		s.Kind = objabi.SymKind(typ)
 		flags := r.readInt()
 		s.DupOK = flags&1 != 0
 		s.Size = r.readInt()
@@ -657,12 +560,12 @@ func (r *objReader) parseObject(prefix []byte) error {
 			rel := &s.Reloc[i]
 			rel.Offset = r.readInt()
 			rel.Size = r.readInt()
-			rel.Type = obj.RelocType(r.readInt())
+			rel.Type = objabi.RelocType(r.readInt())
 			rel.Add = r.readInt()
 			rel.Sym = r.readSymID()
 		}
 
-		if s.Kind == STEXT {
+		if s.Kind == objabi.STEXT {
 			f := new(Func)
 			s.Func = f
 			f.Args = r.readInt()
diff --git a/src/cmd/internal/obj/arm/asm5.go b/src/cmd/internal/obj/arm/asm5.go
index 4725737b2b..4476439350 100644
--- a/src/cmd/internal/obj/arm/asm5.go
+++ b/src/cmd/internal/obj/arm/asm5.go
@@ -32,6 +32,7 @@ package arm
 
 import (
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"fmt"
 	"log"
 	"math"
@@ -602,7 +603,7 @@ func span5(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
 
 		p.Pc = int64(pc)
 		o = c.oplook(p)
-		if ctxt.Headtype != obj.Hnacl {
+		if ctxt.Headtype != objabi.Hnacl {
 			m = int(o.size)
 		} else {
 			m = c.asmoutnacl(pc, p, o, nil)
@@ -696,7 +697,7 @@ func span5(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
 			*/
 			opc = int32(p.Pc)
 
-			if ctxt.Headtype != obj.Hnacl {
+			if ctxt.Headtype != objabi.Hnacl {
 				m = int(o.size)
 			} else {
 				m = c.asmoutnacl(pc, p, o, nil)
@@ -756,7 +757,7 @@ func span5(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
 		c.pc = p.Pc
 		o = c.oplook(p)
 		opc = int32(p.Pc)
-		if ctxt.Headtype != obj.Hnacl {
+		if ctxt.Headtype != objabi.Hnacl {
 			c.asmout(p, o, out[:])
 			m = int(o.size)
 		} else {
@@ -834,7 +835,7 @@ func (c *ctxt5) flushpool(p *obj.Prog, skip int, force int) bool {
 		} else if force == 0 && (p.Pc+int64(12+c.pool.size)-int64(c.pool.start) < 2048) { // 12 take into account the maximum nacl literal pool alignment padding size
 			return false
 		}
-		if c.ctxt.Headtype == obj.Hnacl && c.pool.size%16 != 0 {
+		if c.ctxt.Headtype == objabi.Hnacl && c.pool.size%16 != 0 {
 			// if pool is not multiple of 16 bytes, add an alignment marker
 			q := c.newprog()
 
@@ -902,7 +903,7 @@ func (c *ctxt5) addpool(p *obj.Prog, a *obj.Addr) {
 		}
 	}
 
-	if c.ctxt.Headtype == obj.Hnacl && c.pool.size%16 == 0 {
+	if c.ctxt.Headtype == objabi.Hnacl && c.pool.size%16 == 0 {
 		// start a new data bundle
 		q := c.newprog()
 		q.As = ADATABUNDLE
@@ -1019,7 +1020,7 @@ func (c *ctxt5) aclass(a *obj.Addr) int {
 			}
 
 			c.instoffset = 0 // s.b. unused but just in case
-			if a.Sym.Type == obj.STLSBSS {
+			if a.Sym.Type == objabi.STLSBSS {
 				if c.ctxt.Flag_shared {
 					return C_TLS_IE
 				} else {
@@ -1584,7 +1585,7 @@ func (c *ctxt5) asmout(p *obj.Prog, o *Optab, out []uint32) {
 			rel.Sym = p.To.Sym
 			v += int32(p.To.Offset)
 			rel.Add = int64(o1) | (int64(v)>>2)&0xffffff
-			rel.Type = obj.R_CALLARM
+			rel.Type = objabi.R_CALLARM
 			break
 		}
 
@@ -1612,7 +1613,7 @@ func (c *ctxt5) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel := obj.Addrel(c.cursym)
 		rel.Off = int32(c.pc)
 		rel.Siz = 0
-		rel.Type = obj.R_CALLIND
+		rel.Type = objabi.R_CALLIND
 
 	case 8: /* sll $c,[R],R -> mov (R<<$c),R */
 		c.aclass(&p.From)
@@ -1661,13 +1662,13 @@ func (c *ctxt5) asmout(p *obj.Prog, o *Optab, out []uint32) {
 
 			if c.ctxt.Flag_shared {
 				if p.To.Name == obj.NAME_GOTREF {
-					rel.Type = obj.R_GOTPCREL
+					rel.Type = objabi.R_GOTPCREL
 				} else {
-					rel.Type = obj.R_PCREL
+					rel.Type = objabi.R_PCREL
 				}
 				rel.Add += c.pc - p.Rel.Pc - 8
 			} else {
-				rel.Type = obj.R_ADDR
+				rel.Type = objabi.R_ADDR
 			}
 			o1 = 0
 		}
@@ -2080,7 +2081,7 @@ func (c *ctxt5) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Off = int32(c.pc)
 		rel.Siz = 4
 		rel.Sym = p.To.Sym
-		rel.Type = obj.R_TLS_LE
+		rel.Type = objabi.R_TLS_LE
 		o1 = 0
 
 	case 104: /* word tlsvar, initial exec */
@@ -2094,7 +2095,7 @@ func (c *ctxt5) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Off = int32(c.pc)
 		rel.Siz = 4
 		rel.Sym = p.To.Sym
-		rel.Type = obj.R_TLS_IE
+		rel.Type = objabi.R_TLS_IE
 		rel.Add = c.pc - p.Rel.Pc - 8 - int64(rel.Siz)
 
 	case 68: /* floating point store -> ADDR */
@@ -2849,7 +2850,7 @@ func (c *ctxt5) omvl(p *obj.Prog, a *obj.Addr, dr int) uint32 {
 
 func (c *ctxt5) chipzero5(e float64) int {
 	// We use GOARM=7 to gate the use of VFPv3 vmov (imm) instructions.
-	if obj.GOARM < 7 || e != 0 {
+	if objabi.GOARM < 7 || e != 0 {
 		return -1
 	}
 	return 0
@@ -2857,7 +2858,7 @@ func (c *ctxt5) chipzero5(e float64) int {
 
 func (c *ctxt5) chipfloat5(e float64) int {
 	// We use GOARM=7 to gate the use of VFPv3 vmov (imm) instructions.
-	if obj.GOARM < 7 {
+	if objabi.GOARM < 7 {
 		return -1
 	}
 
diff --git a/src/cmd/internal/obj/arm/obj5.go b/src/cmd/internal/obj/arm/obj5.go
index cb34d16705..49a24c9b5f 100644
--- a/src/cmd/internal/obj/arm/obj5.go
+++ b/src/cmd/internal/obj/arm/obj5.go
@@ -32,6 +32,7 @@ package arm
 
 import (
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 )
 
@@ -62,7 +63,7 @@ func progedit(ctxt *obj.Link, p *obj.Prog, newprog obj.ProgAlloc) {
 				ctxt.Diag("%v: TLS MRC instruction must write to R0 as it might get translated into a BL instruction", p.Line())
 			}
 
-			if obj.GOARM < 7 {
+			if objabi.GOARM < 7 {
 				// Replace it with BL runtime.read_tls_fallback(SB) for ARM CPUs that lack the tls extension.
 				if progedit_tlsfallback == nil {
 					progedit_tlsfallback = ctxt.Lookup("runtime.read_tls_fallback", 0)
@@ -205,7 +206,7 @@ func (c *ctxt5) rewriteToUseGot(p *obj.Prog) {
 	if p.As == obj.ATEXT || p.As == obj.AFUNCDATA || p.As == obj.ACALL || p.As == obj.ARET || p.As == obj.AJMP {
 		return
 	}
-	if source.Sym.Type == obj.STLSBSS {
+	if source.Sym.Type == objabi.STLSBSS {
 		return
 	}
 	if source.Type != obj.TYPE_MEM {
@@ -632,7 +633,7 @@ func isfloatreg(a *obj.Addr) bool {
 }
 
 func (c *ctxt5) softfloat() {
-	if obj.GOARM > 5 {
+	if objabi.GOARM > 5 {
 		return
 	}
 
@@ -722,7 +723,7 @@ func (c *ctxt5) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 	p.To.Type = obj.TYPE_REG
 	p.To.Reg = REG_R1
 
-	if framesize <= obj.StackSmall {
+	if framesize <= objabi.StackSmall {
 		// small stack: SP < stackguard
 		//	CMP	stackguard, SP
 		p = obj.Appendp(p, c.newprog)
@@ -731,7 +732,7 @@ func (c *ctxt5) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 		p.From.Type = obj.TYPE_REG
 		p.From.Reg = REG_R1
 		p.Reg = REGSP
-	} else if framesize <= obj.StackBig {
+	} else if framesize <= objabi.StackBig {
 		// large stack: SP-framesize < stackguard-StackSmall
 		//	MOVW $-(framesize-StackSmall)(SP), R2
 		//	CMP stackguard, R2
@@ -740,7 +741,7 @@ func (c *ctxt5) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 		p.As = AMOVW
 		p.From.Type = obj.TYPE_ADDR
 		p.From.Reg = REGSP
-		p.From.Offset = -(int64(framesize) - obj.StackSmall)
+		p.From.Offset = -(int64(framesize) - objabi.StackSmall)
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_R2
 
@@ -764,14 +765,14 @@ func (c *ctxt5) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 
 		p.As = ACMP
 		p.From.Type = obj.TYPE_CONST
-		p.From.Offset = int64(uint32(obj.StackPreempt & (1<<32 - 1)))
+		p.From.Offset = int64(uint32(objabi.StackPreempt & (1<<32 - 1)))
 		p.Reg = REG_R1
 
 		p = obj.Appendp(p, c.newprog)
 		p.As = AMOVW
 		p.From.Type = obj.TYPE_ADDR
 		p.From.Reg = REGSP
-		p.From.Offset = obj.StackGuard
+		p.From.Offset = objabi.StackGuard
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_R2
 		p.Scond = C_SCOND_NE
@@ -787,7 +788,7 @@ func (c *ctxt5) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 		p = obj.Appendp(p, c.newprog)
 		p.As = AMOVW
 		p.From.Type = obj.TYPE_ADDR
-		p.From.Offset = int64(framesize) + (obj.StackGuard - obj.StackSmall)
+		p.From.Offset = int64(framesize) + (objabi.StackGuard - objabi.StackSmall)
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_R3
 		p.Scond = C_SCOND_NE
@@ -820,7 +821,7 @@ func (c *ctxt5) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 	pcdata.Pos = c.cursym.Func.Text.Pos
 	pcdata.As = obj.APCDATA
 	pcdata.From.Type = obj.TYPE_CONST
-	pcdata.From.Offset = obj.PCDATA_StackMapIndex
+	pcdata.From.Offset = objabi.PCDATA_StackMapIndex
 	pcdata.To.Type = obj.TYPE_CONST
 	pcdata.To.Offset = -1 // pcdata starts at -1 at function entry
 
diff --git a/src/cmd/internal/obj/arm64/asm7.go b/src/cmd/internal/obj/arm64/asm7.go
index 4bc72aab51..b0510267fe 100644
--- a/src/cmd/internal/obj/arm64/asm7.go
+++ b/src/cmd/internal/obj/arm64/asm7.go
@@ -32,6 +32,7 @@ package arm64
 
 import (
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"fmt"
 	"log"
 	"math"
@@ -1100,7 +1101,7 @@ func (c *ctxt7) aclass(a *obj.Addr) int {
 			}
 			c.instoffset = a.Offset
 			if a.Sym != nil { // use relocation
-				if a.Sym.Type == obj.STLSBSS {
+				if a.Sym.Type == objabi.STLSBSS {
 					if c.ctxt.Flag_shared {
 						return C_TLS_IE
 					} else {
@@ -1187,7 +1188,7 @@ func (c *ctxt7) aclass(a *obj.Addr) int {
 			if a.Sym == nil {
 				break
 			}
-			if a.Sym.Type == obj.STLSBSS {
+			if a.Sym.Type == objabi.STLSBSS {
 				c.ctxt.Diag("taking address of TLS variable is not supported")
 			}
 			c.instoffset = a.Offset
@@ -2035,7 +2036,7 @@ func (c *ctxt7) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Siz = 4
 		rel.Sym = p.To.Sym
 		rel.Add = p.To.Offset
-		rel.Type = obj.R_CALLARM64
+		rel.Type = objabi.R_CALLARM64
 
 	case 6: /* b ,O(R); bl ,O(R) */
 		o1 = c.opbrr(p, p.As)
@@ -2044,7 +2045,7 @@ func (c *ctxt7) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel := obj.Addrel(c.cursym)
 		rel.Off = int32(c.pc)
 		rel.Siz = 0
-		rel.Type = obj.R_CALLIND
+		rel.Type = objabi.R_CALLIND
 
 	case 7: /* beq s */
 		o1 = c.opbra(p, p.As)
@@ -2116,7 +2117,7 @@ func (c *ctxt7) asmout(p *obj.Prog, o *Optab, out []uint32) {
 			rel.Siz = 8
 			rel.Sym = p.To.Sym
 			rel.Add = p.To.Offset
-			rel.Type = obj.R_ADDR
+			rel.Type = objabi.R_ADDR
 			o2 = 0
 			o1 = o2
 		}
@@ -2164,7 +2165,7 @@ func (c *ctxt7) asmout(p *obj.Prog, o *Optab, out []uint32) {
 			rel.Siz = 4
 			rel.Sym = p.To.Sym
 			rel.Add = p.To.Offset
-			rel.Type = obj.R_ADDR
+			rel.Type = objabi.R_ADDR
 			o1 = 0
 		}
 
@@ -2875,7 +2876,7 @@ func (c *ctxt7) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Siz = 8
 		rel.Sym = p.To.Sym
 		rel.Add = p.To.Offset
-		rel.Type = obj.R_ADDRARM64
+		rel.Type = objabi.R_ADDRARM64
 		o3 = c.olsr12u(p, int32(c.opstr12(p, p.As)), 0, REGTMP, int(p.From.Reg))
 
 	case 65: /* movT addr,R -> adrp + add + movT (REGTMP), R */
@@ -2886,7 +2887,7 @@ func (c *ctxt7) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Siz = 8
 		rel.Sym = p.From.Sym
 		rel.Add = p.From.Offset
-		rel.Type = obj.R_ADDRARM64
+		rel.Type = objabi.R_ADDRARM64
 		o3 = c.olsr12u(p, int32(c.opldr12(p, p.As)), 0, REGTMP, int(p.To.Reg))
 
 	case 66: /* ldp O(R)!, (r1, r2); ldp (R)O!, (r1, r2) */
@@ -2927,7 +2928,7 @@ func (c *ctxt7) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Siz = 8
 		rel.Sym = p.From.Sym
 		rel.Add = p.From.Offset
-		rel.Type = obj.R_ADDRARM64
+		rel.Type = objabi.R_ADDRARM64
 
 	case 69: /* LE model movd $tlsvar, reg -> movz reg, 0 + reloc */
 		o1 = c.opirr(p, AMOVZ)
@@ -2936,7 +2937,7 @@ func (c *ctxt7) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Off = int32(c.pc)
 		rel.Siz = 4
 		rel.Sym = p.From.Sym
-		rel.Type = obj.R_ARM64_TLS_LE
+		rel.Type = objabi.R_ARM64_TLS_LE
 		if p.From.Offset != 0 {
 			c.ctxt.Diag("invalid offset on MOVW $tlsvar")
 		}
@@ -2949,7 +2950,7 @@ func (c *ctxt7) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Siz = 8
 		rel.Sym = p.From.Sym
 		rel.Add = 0
-		rel.Type = obj.R_ARM64_TLS_IE
+		rel.Type = objabi.R_ARM64_TLS_IE
 		if p.From.Offset != 0 {
 			c.ctxt.Diag("invalid offset on MOVW $tlsvar")
 		}
@@ -2962,7 +2963,7 @@ func (c *ctxt7) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Siz = 8
 		rel.Sym = p.From.Sym
 		rel.Add = 0
-		rel.Type = obj.R_ARM64_GOTPCREL
+		rel.Type = objabi.R_ARM64_GOTPCREL
 
 	// This is supposed to be something that stops execution.
 	// It's not supposed to be reached, ever, but if it is, we'd
diff --git a/src/cmd/internal/obj/arm64/obj7.go b/src/cmd/internal/obj/arm64/obj7.go
index 4dec0a7cda..a4d9ee4a8b 100644
--- a/src/cmd/internal/obj/arm64/obj7.go
+++ b/src/cmd/internal/obj/arm64/obj7.go
@@ -32,6 +32,7 @@ package arm64
 
 import (
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"math"
 )
@@ -62,7 +63,7 @@ func (c *ctxt7) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 	p.To.Reg = REG_R1
 
 	q := (*obj.Prog)(nil)
-	if framesize <= obj.StackSmall {
+	if framesize <= objabi.StackSmall {
 		// small stack: SP < stackguard
 		//	MOV	SP, R2
 		//	CMP	stackguard, R2
@@ -79,7 +80,7 @@ func (c *ctxt7) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 		p.From.Type = obj.TYPE_REG
 		p.From.Reg = REG_R1
 		p.Reg = REG_R2
-	} else if framesize <= obj.StackBig {
+	} else if framesize <= objabi.StackBig {
 		// large stack: SP-framesize < stackguard-StackSmall
 		//	SUB	$(framesize-StackSmall), SP, R2
 		//	CMP	stackguard, R2
@@ -87,7 +88,7 @@ func (c *ctxt7) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 
 		p.As = ASUB
 		p.From.Type = obj.TYPE_CONST
-		p.From.Offset = int64(framesize) - obj.StackSmall
+		p.From.Offset = int64(framesize) - objabi.StackSmall
 		p.Reg = REGSP
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_R2
@@ -113,7 +114,7 @@ func (c *ctxt7) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 
 		p.As = ACMP
 		p.From.Type = obj.TYPE_CONST
-		p.From.Offset = obj.StackPreempt
+		p.From.Offset = objabi.StackPreempt
 		p.Reg = REG_R1
 
 		p = obj.Appendp(p, c.newprog)
@@ -124,7 +125,7 @@ func (c *ctxt7) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 		p = obj.Appendp(p, c.newprog)
 		p.As = AADD
 		p.From.Type = obj.TYPE_CONST
-		p.From.Offset = obj.StackGuard
+		p.From.Offset = objabi.StackGuard
 		p.Reg = REGSP
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_R2
@@ -139,7 +140,7 @@ func (c *ctxt7) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 		p = obj.Appendp(p, c.newprog)
 		p.As = AMOVD
 		p.From.Type = obj.TYPE_CONST
-		p.From.Offset = int64(framesize) + (obj.StackGuard - obj.StackSmall)
+		p.From.Offset = int64(framesize) + (objabi.StackGuard - objabi.StackSmall)
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_R3
 
@@ -170,7 +171,7 @@ func (c *ctxt7) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 	pcdata.Pos = c.cursym.Func.Text.Pos
 	pcdata.As = obj.APCDATA
 	pcdata.From.Type = obj.TYPE_CONST
-	pcdata.From.Offset = obj.PCDATA_StackMapIndex
+	pcdata.From.Offset = objabi.PCDATA_StackMapIndex
 	pcdata.To.Type = obj.TYPE_CONST
 	pcdata.To.Offset = -1 // pcdata starts at -1 at function entry
 
@@ -401,7 +402,7 @@ func (c *ctxt7) rewriteToUseGot(p *obj.Prog) {
 	if p.As == obj.ATEXT || p.As == obj.AFUNCDATA || p.As == obj.ACALL || p.As == obj.ARET || p.As == obj.AJMP {
 		return
 	}
-	if source.Sym.Type == obj.STLSBSS {
+	if source.Sym.Type == objabi.STLSBSS {
 		return
 	}
 	if source.Type != obj.TYPE_MEM {
diff --git a/src/cmd/internal/obj/data.go b/src/cmd/internal/obj/data.go
index e67852ac3b..ab873123fc 100644
--- a/src/cmd/internal/obj/data.go
+++ b/src/cmd/internal/obj/data.go
@@ -32,6 +32,7 @@
 package obj
 
 import (
+	"cmd/internal/objabi"
 	"log"
 	"math"
 )
@@ -72,7 +73,7 @@ func (s *LSym) prepwrite(ctxt *Link, off int64, siz int) {
 	if off < 0 || siz < 0 || off >= 1<<30 {
 		ctxt.Diag("prepwrite: bad off=%d siz=%d s=%v", off, siz, s)
 	}
-	if s.Type == SBSS || s.Type == STLSBSS {
+	if s.Type == objabi.SBSS || s.Type == objabi.STLSBSS {
 		ctxt.Diag("cannot supply data for BSS var")
 	}
 	l := off + int64(siz)
@@ -125,7 +126,7 @@ func (s *LSym) WriteAddr(ctxt *Link, off int64, siz int, rsym *LSym, roff int64)
 	}
 	r.Siz = uint8(siz)
 	r.Sym = rsym
-	r.Type = R_ADDR
+	r.Type = objabi.R_ADDR
 	r.Add = roff
 }
 
@@ -141,7 +142,7 @@ func (s *LSym) WriteOff(ctxt *Link, off int64, rsym *LSym, roff int64) {
 	}
 	r.Siz = 4
 	r.Sym = rsym
-	r.Type = R_ADDROFF
+	r.Type = objabi.R_ADDROFF
 	r.Add = roff
 }
 
@@ -157,7 +158,7 @@ func (s *LSym) WriteWeakOff(ctxt *Link, off int64, rsym *LSym, roff int64) {
 	}
 	r.Siz = 4
 	r.Sym = rsym
-	r.Type = R_WEAKADDROFF
+	r.Type = objabi.R_WEAKADDROFF
 	r.Add = roff
 }
 
diff --git a/src/cmd/internal/obj/go.go b/src/cmd/internal/obj/go.go
index 732ce19634..f0b2c46e4f 100644
--- a/src/cmd/internal/obj/go.go
+++ b/src/cmd/internal/obj/go.go
@@ -4,67 +4,8 @@
 
 package obj
 
-import (
-	"fmt"
-	"os"
-	"strings"
-)
-
 // go-specific code shared across loaders (5l, 6l, 8l).
 
-var (
-	framepointer_enabled     int
-	Fieldtrack_enabled       int
-	Preemptibleloops_enabled int
-)
-
-// Toolchain experiments.
-// These are controlled by the GOEXPERIMENT environment
-// variable recorded when the toolchain is built.
-// This list is also known to cmd/gc.
-var exper = []struct {
-	name string
-	val  *int
-}{
-	{"fieldtrack", &Fieldtrack_enabled},
-	{"framepointer", &framepointer_enabled},
-	{"preemptibleloops", &Preemptibleloops_enabled},
-}
-
-func addexp(s string) {
-	// Could do general integer parsing here, but the runtime copy doesn't yet.
-	v := 1
-	name := s
-	if len(name) > 2 && name[:2] == "no" {
-		v = 0
-		name = name[2:]
-	}
-	for i := 0; i < len(exper); i++ {
-		if exper[i].name == name {
-			if exper[i].val != nil {
-				*exper[i].val = v
-			}
-			return
-		}
-	}
-
-	fmt.Printf("unknown experiment %s\n", s)
-	os.Exit(2)
-}
-
-func init() {
-	framepointer_enabled = 1 // default
-	for _, f := range strings.Split(goexperiment, ",") {
-		if f != "" {
-			addexp(f)
-		}
-	}
-}
-
-func Framepointer_enabled(goos, goarch string) bool {
-	return framepointer_enabled != 0 && goarch == "amd64" && goos != "nacl"
-}
-
 func Nopout(p *Prog) {
 	p.As = ANOP
 	p.Scond = 0
@@ -73,16 +14,3 @@ func Nopout(p *Prog) {
 	p.Reg = 0
 	p.To = Addr{}
 }
-
-func Expstring() string {
-	buf := "X"
-	for i := range exper {
-		if *exper[i].val != 0 {
-			buf += "," + exper[i].name
-		}
-	}
-	if buf == "X" {
-		buf += ",none"
-	}
-	return "X:" + buf[2:]
-}
diff --git a/src/cmd/internal/obj/line.go b/src/cmd/internal/obj/line.go
index 0fb915ba30..fecf90c491 100644
--- a/src/cmd/internal/obj/line.go
+++ b/src/cmd/internal/obj/line.go
@@ -6,69 +6,8 @@ package obj
 
 import (
 	"cmd/internal/src"
-	"path/filepath"
 )
 
-// AbsFile returns the absolute filename for file in the given directory.
-// It also removes a leading pathPrefix, or else rewrites a leading $GOROOT
-// prefix to the literal "$GOROOT".
-// If the resulting path is the empty string, the result is "??".
-func AbsFile(dir, file, pathPrefix string) string {
-	abs := file
-	if dir != "" && !filepath.IsAbs(file) {
-		abs = filepath.Join(dir, file)
-	}
-
-	if pathPrefix != "" && hasPathPrefix(abs, pathPrefix) {
-		if abs == pathPrefix {
-			abs = ""
-		} else {
-			abs = abs[len(pathPrefix)+1:]
-		}
-	} else if hasPathPrefix(abs, GOROOT) {
-		abs = "$GOROOT" + abs[len(GOROOT):]
-	}
-	if abs == "" {
-		abs = "??"
-	}
-
-	return filepath.Clean(abs)
-}
-
-// Does s have t as a path prefix?
-// That is, does s == t or does s begin with t followed by a slash?
-// For portability, we allow ASCII case folding, so that hasPathPrefix("a/b/c", "A/B") is true.
-// Similarly, we allow slash folding, so that hasPathPrefix("a/b/c", "a\\b") is true.
-// We do not allow full Unicode case folding, for fear of causing more confusion
-// or harm than good. (For an example of the kinds of things that can go wrong,
-// see http://article.gmane.org/gmane.linux.kernel/1853266.)
-func hasPathPrefix(s string, t string) bool {
-	if len(t) > len(s) {
-		return false
-	}
-	var i int
-	for i = 0; i < len(t); i++ {
-		cs := int(s[i])
-		ct := int(t[i])
-		if 'A' <= cs && cs <= 'Z' {
-			cs += 'a' - 'A'
-		}
-		if 'A' <= ct && ct <= 'Z' {
-			ct += 'a' - 'A'
-		}
-		if cs == '\\' {
-			cs = '/'
-		}
-		if ct == '\\' {
-			ct = '/'
-		}
-		if cs != ct {
-			return false
-		}
-	}
-	return i >= len(s) || s[i] == '/' || s[i] == '\\'
-}
-
 // AddImport adds a package to the list of imported packages.
 func (ctxt *Link) AddImport(pkg string) {
 	ctxt.Imports = append(ctxt.Imports, pkg)
diff --git a/src/cmd/internal/obj/link.go b/src/cmd/internal/obj/link.go
index 568abd58ef..840df52256 100644
--- a/src/cmd/internal/obj/link.go
+++ b/src/cmd/internal/obj/link.go
@@ -33,6 +33,7 @@ package obj
 import (
 	"bufio"
 	"cmd/internal/dwarf"
+	"cmd/internal/objabi"
 	"cmd/internal/src"
 	"cmd/internal/sys"
 	"fmt"
@@ -308,7 +309,7 @@ const (
 // An LSym is the sort of symbol that is written to an object file.
 type LSym struct {
 	Name    string
-	Type    SymKind
+	Type    objabi.SymKind
 	Version int16
 	Attribute
 
@@ -447,289 +448,14 @@ type Pcln struct {
 	InlTree     InlTree // per-function inlining tree extracted from the global tree
 }
 
-// A SymKind describes the kind of memory represented by a symbol.
-type SymKind int16
-
-// Defined SymKind values.
-//
-// TODO(rsc): Give idiomatic Go names.
-// TODO(rsc): Reduce the number of symbol types in the object files.
-//go:generate stringer -type=SymKind
-const (
-	Sxxx SymKind = iota
-	STEXT
-	SELFRXSECT
-
-	// Read-only sections.
-	STYPE
-	SSTRING
-	SGOSTRING
-	SGOFUNC
-	SGCBITS
-	SRODATA
-	SFUNCTAB
-
-	SELFROSECT
-	SMACHOPLT
-
-	// Read-only sections with relocations.
-	//
-	// Types STYPE-SFUNCTAB above are written to the .rodata section by default.
-	// When linking a shared object, some conceptually "read only" types need to
-	// be written to by relocations and putting them in a section called
-	// ".rodata" interacts poorly with the system linkers. The GNU linkers
-	// support this situation by arranging for sections of the name
-	// ".data.rel.ro.XXX" to be mprotected read only by the dynamic linker after
-	// relocations have applied, so when the Go linker is creating a shared
-	// object it checks all objects of the above types and bumps any object that
-	// has a relocation to it to the corresponding type below, which are then
-	// written to sections with appropriate magic names.
-	STYPERELRO
-	SSTRINGRELRO
-	SGOSTRINGRELRO
-	SGOFUNCRELRO
-	SGCBITSRELRO
-	SRODATARELRO
-	SFUNCTABRELRO
-
-	// Part of .data.rel.ro if it exists, otherwise part of .rodata.
-	STYPELINK
-	SITABLINK
-	SSYMTAB
-	SPCLNTAB
-
-	// Writable sections.
-	SELFSECT
-	SMACHO
-	SMACHOGOT
-	SWINDOWS
-	SELFGOT
-	SNOPTRDATA
-	SINITARR
-	SDATA
-	SBSS
-	SNOPTRBSS
-	STLSBSS
-	SXREF
-	SMACHOSYMSTR
-	SMACHOSYMTAB
-	SMACHOINDIRECTPLT
-	SMACHOINDIRECTGOT
-	SFILE
-	SFILEPATH
-	SCONST
-	SDYNIMPORT
-	SHOSTOBJ
-	SDWARFSECT
-	SDWARFINFO
-	SSUB       = SymKind(1 << 8)
-	SMASK      = SymKind(SSUB - 1)
-	SHIDDEN    = SymKind(1 << 9)
-	SCONTAINER = SymKind(1 << 10) // has a sub-symbol
-)
-
-// ReadOnly are the symbol kinds that form read-only sections. In some
-// cases, if they will require relocations, they are transformed into
-// rel-ro sections using RelROMap.
-var ReadOnly = []SymKind{
-	STYPE,
-	SSTRING,
-	SGOSTRING,
-	SGOFUNC,
-	SGCBITS,
-	SRODATA,
-	SFUNCTAB,
-}
-
-// RelROMap describes the transformation of read-only symbols to rel-ro
-// symbols.
-var RelROMap = map[SymKind]SymKind{
-	STYPE:     STYPERELRO,
-	SSTRING:   SSTRINGRELRO,
-	SGOSTRING: SGOSTRINGRELRO,
-	SGOFUNC:   SGOFUNCRELRO,
-	SGCBITS:   SGCBITSRELRO,
-	SRODATA:   SRODATARELRO,
-	SFUNCTAB:  SFUNCTABRELRO,
-}
-
 type Reloc struct {
 	Off  int32
 	Siz  uint8
-	Type RelocType
+	Type objabi.RelocType
 	Add  int64
 	Sym  *LSym
 }
 
-type RelocType int32
-
-//go:generate stringer -type=RelocType
-const (
-	R_ADDR RelocType = 1 + iota
-	// R_ADDRPOWER relocates a pair of "D-form" instructions (instructions with 16-bit
-	// immediates in the low half of the instruction word), usually addis followed by
-	// another add or a load, inserting the "high adjusted" 16 bits of the address of
-	// the referenced symbol into the immediate field of the first instruction and the
-	// low 16 bits into that of the second instruction.
-	R_ADDRPOWER
-	// R_ADDRARM64 relocates an adrp, add pair to compute the address of the
-	// referenced symbol.
-	R_ADDRARM64
-	// R_ADDRMIPS (only used on mips/mips64) resolves to the low 16 bits of an external
-	// address, by encoding it into the instruction.
-	R_ADDRMIPS
-	// R_ADDROFF resolves to a 32-bit offset from the beginning of the section
-	// holding the data being relocated to the referenced symbol.
-	R_ADDROFF
-	// R_WEAKADDROFF resolves just like R_ADDROFF but is a weak relocation.
-	// A weak relocation does not make the symbol it refers to reachable,
-	// and is only honored by the linker if the symbol is in some other way
-	// reachable.
-	R_WEAKADDROFF
-	R_SIZE
-	R_CALL
-	R_CALLARM
-	R_CALLARM64
-	R_CALLIND
-	R_CALLPOWER
-	// R_CALLMIPS (only used on mips64) resolves to non-PC-relative target address
-	// of a CALL (JAL) instruction, by encoding the address into the instruction.
-	R_CALLMIPS
-	R_CONST
-	R_PCREL
-	// R_TLS_LE, used on 386, amd64, and ARM, resolves to the offset of the
-	// thread-local symbol from the thread local base and is used to implement the
-	// "local exec" model for tls access (r.Sym is not set on intel platforms but is
-	// set to a TLS symbol -- runtime.tlsg -- in the linker when externally linking).
-	R_TLS_LE
-	// R_TLS_IE, used 386, amd64, and ARM resolves to the PC-relative offset to a GOT
-	// slot containing the offset from the thread-local symbol from the thread local
-	// base and is used to implemented the "initial exec" model for tls access (r.Sym
-	// is not set on intel platforms but is set to a TLS symbol -- runtime.tlsg -- in
-	// the linker when externally linking).
-	R_TLS_IE
-	R_GOTOFF
-	R_PLT0
-	R_PLT1
-	R_PLT2
-	R_USEFIELD
-	// R_USETYPE resolves to an *rtype, but no relocation is created. The
-	// linker uses this as a signal that the pointed-to type information
-	// should be linked into the final binary, even if there are no other
-	// direct references. (This is used for types reachable by reflection.)
-	R_USETYPE
-	// R_METHODOFF resolves to a 32-bit offset from the beginning of the section
-	// holding the data being relocated to the referenced symbol.
-	// It is a variant of R_ADDROFF used when linking from the uncommonType of a
-	// *rtype, and may be set to zero by the linker if it determines the method
-	// text is unreachable by the linked program.
-	R_METHODOFF
-	R_POWER_TOC
-	R_GOTPCREL
-	// R_JMPMIPS (only used on mips64) resolves to non-PC-relative target address
-	// of a JMP instruction, by encoding the address into the instruction.
-	// The stack nosplit check ignores this since it is not a function call.
-	R_JMPMIPS
-	// R_DWARFREF resolves to the offset of the symbol from its section.
-	R_DWARFREF
-
-	// Platform dependent relocations. Architectures with fixed width instructions
-	// have the inherent issue that a 32-bit (or 64-bit!) displacement cannot be
-	// stuffed into a 32-bit instruction, so an address needs to be spread across
-	// several instructions, and in turn this requires a sequence of relocations, each
-	// updating a part of an instruction. This leads to relocation codes that are
-	// inherently processor specific.
-
-	// Arm64.
-
-	// Set a MOV[NZ] immediate field to bits [15:0] of the offset from the thread
-	// local base to the thread local variable defined by the referenced (thread
-	// local) symbol. Error if the offset does not fit into 16 bits.
-	R_ARM64_TLS_LE
-
-	// Relocates an ADRP; LD64 instruction sequence to load the offset between
-	// the thread local base and the thread local variable defined by the
-	// referenced (thread local) symbol from the GOT.
-	R_ARM64_TLS_IE
-
-	// R_ARM64_GOTPCREL relocates an adrp, ld64 pair to compute the address of the GOT
-	// slot of the referenced symbol.
-	R_ARM64_GOTPCREL
-
-	// PPC64.
-
-	// R_POWER_TLS_LE is used to implement the "local exec" model for tls
-	// access. It resolves to the offset of the thread-local symbol from the
-	// thread pointer (R13) and inserts this value into the low 16 bits of an
-	// instruction word.
-	R_POWER_TLS_LE
-
-	// R_POWER_TLS_IE is used to implement the "initial exec" model for tls access. It
-	// relocates a D-form, DS-form instruction sequence like R_ADDRPOWER_DS. It
-	// inserts to the offset of GOT slot for the thread-local symbol from the TOC (the
-	// GOT slot is filled by the dynamic linker with the offset of the thread-local
-	// symbol from the thread pointer (R13)).
-	R_POWER_TLS_IE
-
-	// R_POWER_TLS marks an X-form instruction such as "MOVD 0(R13)(R31*1), g" as
-	// accessing a particular thread-local symbol. It does not affect code generation
-	// but is used by the system linker when relaxing "initial exec" model code to
-	// "local exec" model code.
-	R_POWER_TLS
-
-	// R_ADDRPOWER_DS is similar to R_ADDRPOWER above, but assumes the second
-	// instruction is a "DS-form" instruction, which has an immediate field occupying
-	// bits [15:2] of the instruction word. Bits [15:2] of the address of the
-	// relocated symbol are inserted into this field; it is an error if the last two
-	// bits of the address are not 0.
-	R_ADDRPOWER_DS
-
-	// R_ADDRPOWER_PCREL relocates a D-form, DS-form instruction sequence like
-	// R_ADDRPOWER_DS but inserts the offset of the GOT slot for the referenced symbol
-	// from the TOC rather than the symbol's address.
-	R_ADDRPOWER_GOT
-
-	// R_ADDRPOWER_PCREL relocates two D-form instructions like R_ADDRPOWER, but
-	// inserts the displacement from the place being relocated to the address of the
-	// the relocated symbol instead of just its address.
-	R_ADDRPOWER_PCREL
-
-	// R_ADDRPOWER_TOCREL relocates two D-form instructions like R_ADDRPOWER, but
-	// inserts the offset from the TOC to the address of the relocated symbol
-	// rather than the symbol's address.
-	R_ADDRPOWER_TOCREL
-
-	// R_ADDRPOWER_TOCREL relocates a D-form, DS-form instruction sequence like
-	// R_ADDRPOWER_DS but inserts the offset from the TOC to the address of the the
-	// relocated symbol rather than the symbol's address.
-	R_ADDRPOWER_TOCREL_DS
-
-	// R_PCRELDBL relocates s390x 2-byte aligned PC-relative addresses.
-	// TODO(mundaym): remove once variants can be serialized - see issue 14218.
-	R_PCRELDBL
-
-	// R_ADDRMIPSU (only used on mips/mips64) resolves to the sign-adjusted "upper" 16
-	// bits (bit 16-31) of an external address, by encoding it into the instruction.
-	R_ADDRMIPSU
-	// R_ADDRMIPSTLS (only used on mips64) resolves to the low 16 bits of a TLS
-	// address (offset from thread pointer), by encoding it into the instruction.
-	R_ADDRMIPSTLS
-)
-
-// IsDirectJump returns whether r is a relocation for a direct jump.
-// A direct jump is a CALL or JMP instruction that takes the target address
-// as immediate. The address is embedded into the instruction, possibly
-// with limited width.
-// An indirect jump is a CALL or JMP instruction that takes the target address
-// in register or memory.
-func (r RelocType) IsDirectJump() bool {
-	switch r {
-	case R_CALL, R_CALLARM, R_CALLARM64, R_CALLPOWER, R_CALLMIPS, R_JMPMIPS:
-		return true
-	}
-	return false
-}
-
 type Auto struct {
 	Asym    *LSym
 	Aoffset int32
@@ -737,12 +463,6 @@ type Auto struct {
 	Gotype  *LSym
 }
 
-// Auto.name
-const (
-	A_AUTO = 1 + iota
-	A_PARAM
-)
-
 type Pcdata struct {
 	P []byte
 }
@@ -750,7 +470,7 @@ type Pcdata struct {
 // Link holds the context for writing object code from a compiler
 // to be linker input or for reading that input into the linker.
 type Link struct {
-	Headtype      HeadType
+	Headtype      objabi.HeadType
 	Arch          *LinkArch
 	Debugasm      bool
 	Debugvlog     bool
@@ -816,74 +536,3 @@ type LinkArch struct {
 	Progedit   func(*Link, *Prog, ProgAlloc)
 	UnaryDst   map[As]bool // Instruction takes one operand, a destination.
 }
-
-// HeadType is the executable header type.
-type HeadType uint8
-
-const (
-	Hunknown HeadType = iota
-	Hdarwin
-	Hdragonfly
-	Hfreebsd
-	Hlinux
-	Hnacl
-	Hnetbsd
-	Hopenbsd
-	Hplan9
-	Hsolaris
-	Hwindows
-)
-
-func (h *HeadType) Set(s string) error {
-	switch s {
-	case "darwin":
-		*h = Hdarwin
-	case "dragonfly":
-		*h = Hdragonfly
-	case "freebsd":
-		*h = Hfreebsd
-	case "linux", "android":
-		*h = Hlinux
-	case "nacl":
-		*h = Hnacl
-	case "netbsd":
-		*h = Hnetbsd
-	case "openbsd":
-		*h = Hopenbsd
-	case "plan9":
-		*h = Hplan9
-	case "solaris":
-		*h = Hsolaris
-	case "windows":
-		*h = Hwindows
-	default:
-		return fmt.Errorf("invalid headtype: %q", s)
-	}
-	return nil
-}
-
-func (h *HeadType) String() string {
-	switch *h {
-	case Hdarwin:
-		return "darwin"
-	case Hdragonfly:
-		return "dragonfly"
-	case Hfreebsd:
-		return "freebsd"
-	case Hlinux:
-		return "linux"
-	case Hnacl:
-		return "nacl"
-	case Hnetbsd:
-		return "netbsd"
-	case Hopenbsd:
-		return "openbsd"
-	case Hplan9:
-		return "plan9"
-	case Hsolaris:
-		return "solaris"
-	case Hwindows:
-		return "windows"
-	}
-	return fmt.Sprintf("HeadType(%d)", *h)
-}
diff --git a/src/cmd/internal/obj/mips/asm0.go b/src/cmd/internal/obj/mips/asm0.go
index dc9ca46db8..39c4d4750b 100644
--- a/src/cmd/internal/obj/mips/asm0.go
+++ b/src/cmd/internal/obj/mips/asm0.go
@@ -31,6 +31,7 @@ package mips
 
 import (
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"fmt"
 	"log"
@@ -545,7 +546,7 @@ func (c *ctxt0) aclass(a *obj.Addr) int {
 			}
 			c.instoffset = a.Offset
 			if a.Sym != nil { // use relocation
-				if a.Sym.Type == obj.STLSBSS {
+				if a.Sym.Type == objabi.STLSBSS {
 					return C_TLS
 				}
 				return C_ADDR
@@ -605,13 +606,13 @@ func (c *ctxt0) aclass(a *obj.Addr) int {
 			if s == nil {
 				break
 			}
-			if s.Type == obj.SCONST {
+			if s.Type == objabi.SCONST {
 				c.instoffset = a.Offset
 				goto consize
 			}
 
 			c.instoffset = a.Offset
-			if s.Type == obj.STLSBSS {
+			if s.Type == objabi.STLSBSS {
 				return C_STCON // address of TLS variable
 			}
 			return C_LECON
@@ -1219,9 +1220,9 @@ func (c *ctxt0) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Sym = p.To.Sym
 		rel.Add = p.To.Offset
 		if p.As == AJAL {
-			rel.Type = obj.R_CALLMIPS
+			rel.Type = objabi.R_CALLMIPS
 		} else {
-			rel.Type = obj.R_JMPMIPS
+			rel.Type = objabi.R_JMPMIPS
 		}
 
 	case 12: /* movbs r,r */
@@ -1278,7 +1279,7 @@ func (c *ctxt0) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel := obj.Addrel(c.cursym)
 		rel.Off = int32(c.pc)
 		rel.Siz = 0
-		rel.Type = obj.R_CALLIND
+		rel.Type = objabi.R_CALLIND
 
 	case 19: /* mov $lcon,r ==> lu+or */
 		v := c.regoff(&p.From)
@@ -1474,14 +1475,14 @@ func (c *ctxt0) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Siz = 4
 		rel.Sym = p.To.Sym
 		rel.Add = p.To.Offset
-		rel.Type = obj.R_ADDRMIPSU
+		rel.Type = objabi.R_ADDRMIPSU
 		o2 = OP_IRR(c.opirr(p.As), uint32(0), uint32(REGTMP), uint32(p.From.Reg))
 		rel2 := obj.Addrel(c.cursym)
 		rel2.Off = int32(c.pc + 4)
 		rel2.Siz = 4
 		rel2.Sym = p.To.Sym
 		rel2.Add = p.To.Offset
-		rel2.Type = obj.R_ADDRMIPS
+		rel2.Type = objabi.R_ADDRMIPS
 
 		if o.size == 12 {
 			o3 = o2
@@ -1496,14 +1497,14 @@ func (c *ctxt0) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Siz = 4
 		rel.Sym = p.From.Sym
 		rel.Add = p.From.Offset
-		rel.Type = obj.R_ADDRMIPSU
+		rel.Type = objabi.R_ADDRMIPSU
 		o2 = OP_IRR(c.opirr(-p.As), uint32(0), uint32(REGTMP), uint32(p.To.Reg))
 		rel2 := obj.Addrel(c.cursym)
 		rel2.Off = int32(c.pc + 4)
 		rel2.Siz = 4
 		rel2.Sym = p.From.Sym
 		rel2.Add = p.From.Offset
-		rel2.Type = obj.R_ADDRMIPS
+		rel2.Type = objabi.R_ADDRMIPS
 
 		if o.size == 12 {
 			o3 = o2
@@ -1518,14 +1519,14 @@ func (c *ctxt0) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Siz = 4
 		rel.Sym = p.From.Sym
 		rel.Add = p.From.Offset
-		rel.Type = obj.R_ADDRMIPSU
+		rel.Type = objabi.R_ADDRMIPSU
 		o2 = OP_IRR(c.opirr(add), uint32(0), uint32(p.To.Reg), uint32(p.To.Reg))
 		rel2 := obj.Addrel(c.cursym)
 		rel2.Off = int32(c.pc + 4)
 		rel2.Siz = 4
 		rel2.Sym = p.From.Sym
 		rel2.Add = p.From.Offset
-		rel2.Type = obj.R_ADDRMIPS
+		rel2.Type = objabi.R_ADDRMIPS
 
 		if o.size == 12 {
 			o3 = o2
@@ -1543,7 +1544,7 @@ func (c *ctxt0) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Siz = 4
 		rel.Sym = p.To.Sym
 		rel.Add = p.To.Offset
-		rel.Type = obj.R_ADDRMIPSTLS
+		rel.Type = objabi.R_ADDRMIPSTLS
 
 	case 54: /* mov tlsvar, r ==> rdhwr + lw o(r3) */
 		// clobbers R3 !
@@ -1554,7 +1555,7 @@ func (c *ctxt0) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Siz = 4
 		rel.Sym = p.From.Sym
 		rel.Add = p.From.Offset
-		rel.Type = obj.R_ADDRMIPSTLS
+		rel.Type = objabi.R_ADDRMIPSTLS
 
 	case 55: /* mov $tlsvar, r ==> rdhwr + add */
 		// clobbers R3 !
@@ -1565,7 +1566,7 @@ func (c *ctxt0) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Siz = 4
 		rel.Sym = p.From.Sym
 		rel.Add = p.From.Offset
-		rel.Type = obj.R_ADDRMIPSTLS
+		rel.Type = objabi.R_ADDRMIPSTLS
 	}
 
 	out[0] = o1
diff --git a/src/cmd/internal/obj/mips/obj0.go b/src/cmd/internal/obj/mips/obj0.go
index 2316bc64ec..fd53c3212e 100644
--- a/src/cmd/internal/obj/mips/obj0.go
+++ b/src/cmd/internal/obj/mips/obj0.go
@@ -31,6 +31,7 @@ package mips
 
 import (
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"encoding/binary"
 	"fmt"
@@ -634,7 +635,7 @@ func (c *ctxt0) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 	p.To.Reg = REG_R1
 
 	var q *obj.Prog
-	if framesize <= obj.StackSmall {
+	if framesize <= objabi.StackSmall {
 		// small stack: SP < stackguard
 		//	AGTU	SP, stackguard, R1
 		p = obj.Appendp(p, c.newprog)
@@ -645,7 +646,7 @@ func (c *ctxt0) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 		p.Reg = REG_R1
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_R1
-	} else if framesize <= obj.StackBig {
+	} else if framesize <= objabi.StackBig {
 		// large stack: SP-framesize < stackguard-StackSmall
 		//	ADD	$-(framesize-StackSmall), SP, R2
 		//	SGTU	R2, stackguard, R1
@@ -653,7 +654,7 @@ func (c *ctxt0) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 
 		p.As = add
 		p.From.Type = obj.TYPE_CONST
-		p.From.Offset = -(int64(framesize) - obj.StackSmall)
+		p.From.Offset = -(int64(framesize) - objabi.StackSmall)
 		p.Reg = REGSP
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_R2
@@ -685,7 +686,7 @@ func (c *ctxt0) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 
 		p.As = mov
 		p.From.Type = obj.TYPE_CONST
-		p.From.Offset = obj.StackPreempt
+		p.From.Offset = objabi.StackPreempt
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_R2
 
@@ -701,7 +702,7 @@ func (c *ctxt0) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 		p = obj.Appendp(p, c.newprog)
 		p.As = add
 		p.From.Type = obj.TYPE_CONST
-		p.From.Offset = obj.StackGuard
+		p.From.Offset = objabi.StackGuard
 		p.Reg = REGSP
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_R2
@@ -716,7 +717,7 @@ func (c *ctxt0) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 		p = obj.Appendp(p, c.newprog)
 		p.As = mov
 		p.From.Type = obj.TYPE_CONST
-		p.From.Offset = int64(framesize) + obj.StackGuard - obj.StackSmall
+		p.From.Offset = int64(framesize) + objabi.StackGuard - objabi.StackSmall
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_R1
 
diff --git a/src/cmd/internal/obj/objfile.go b/src/cmd/internal/obj/objfile.go
index 2e9e65a99f..d83ccca9a6 100644
--- a/src/cmd/internal/obj/objfile.go
+++ b/src/cmd/internal/obj/objfile.go
@@ -3,118 +3,13 @@
 // license that can be found in the LICENSE file.
 
 // Writing of Go object files.
-//
-// Originally, Go object files were Plan 9 object files, but no longer.
-// Now they are more like standard object files, in that each symbol is defined
-// by an associated memory image (bytes) and a list of relocations to apply
-// during linking. We do not (yet?) use a standard file format, however.
-// For now, the format is chosen to be as simple as possible to read and write.
-// It may change for reasons of efficiency, or we may even switch to a
-// standard file format if there are compelling benefits to doing so.
-// See golang.org/s/go13linker for more background.
-//
-// The file format is:
-//
-//	- magic header: "\x00\x00go19ld"
-//	- byte 1 - version number
-//	- sequence of strings giving dependencies (imported packages)
-//	- empty string (marks end of sequence)
-//	- sequence of symbol references used by the defined symbols
-//	- byte 0xff (marks end of sequence)
-//	- sequence of integer lengths:
-//		- total data length
-//		- total number of relocations
-//		- total number of pcdata
-//		- total number of automatics
-//		- total number of funcdata
-//		- total number of files
-//	- data, the content of the defined symbols
-//	- sequence of defined symbols
-//	- byte 0xff (marks end of sequence)
-//	- magic footer: "\xff\xffgo19ld"
-//
-// All integers are stored in a zigzag varint format.
-// See golang.org/s/go12symtab for a definition.
-//
-// Data blocks and strings are both stored as an integer
-// followed by that many bytes.
-//
-// A symbol reference is a string name followed by a version.
-//
-// A symbol points to other symbols using an index into the symbol
-// reference sequence. Index 0 corresponds to a nil LSym* pointer.
-// In the symbol layout described below "symref index" stands for this
-// index.
-//
-// Each symbol is laid out as the following fields (taken from LSym*):
-//
-//	- byte 0xfe (sanity check for synchronization)
-//	- type [int]
-//	- name & version [symref index]
-//	- flags [int]
-//		1<<0 dupok
-//		1<<1 local
-//		1<<2 add to typelink table
-//	- size [int]
-//	- gotype [symref index]
-//	- p [data block]
-//	- nr [int]
-//	- r [nr relocations, sorted by off]
-//
-// If type == STEXT, there are a few more fields:
-//
-//	- args [int]
-//	- locals [int]
-//	- nosplit [int]
-//	- flags [int]
-//		1<<0 leaf
-//		1<<1 C function
-//		1<<2 function may call reflect.Type.Method
-//	- nlocal [int]
-//	- local [nlocal automatics]
-//	- pcln [pcln table]
-//
-// Each relocation has the encoding:
-//
-//	- off [int]
-//	- siz [int]
-//	- type [int]
-//	- add [int]
-//	- sym [symref index]
-//
-// Each local has the encoding:
-//
-//	- asym [symref index]
-//	- offset [int]
-//	- type [int]
-//	- gotype [symref index]
-//
-// The pcln table has the encoding:
-//
-//	- pcsp [data block]
-//	- pcfile [data block]
-//	- pcline [data block]
-//	- pcinline [data block]
-//	- npcdata [int]
-//	- pcdata [npcdata data blocks]
-//	- nfuncdata [int]
-//	- funcdata [nfuncdata symref index]
-//	- funcdatasym [nfuncdata ints]
-//	- nfile [int]
-//	- file [nfile symref index]
-//	- ninlinedcall [int]
-//	- inlinedcall [ninlinedcall int symref int symref]
-//
-// The file layout and meaning of type integers are architecture-independent.
-//
-// TODO(rsc): The file format is good for a first pass but needs work.
-//	- There are SymID in the object file that should really just be strings.
 
 package obj
 
 import (
 	"bufio"
 	"cmd/internal/dwarf"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"fmt"
 	"log"
@@ -149,7 +44,7 @@ func (w *objWriter) addLengths(s *LSym) {
 	w.nData += len(s.P)
 	w.nReloc += len(s.R)
 
-	if s.Type != STEXT {
+	if s.Type != objabi.STEXT {
 		return
 	}
 
@@ -289,7 +184,7 @@ func (w *objWriter) writeRefs(s *LSym) {
 		w.writeRef(s.R[i].Sym, false)
 	}
 
-	if s.Type == STEXT {
+	if s.Type == objabi.STEXT {
 		for _, a := range s.Func.Autom {
 			w.writeRef(a.Asym, false)
 			w.writeRef(a.Gotype, false)
@@ -330,14 +225,14 @@ func (w *objWriter) writeSymDebug(s *LSym) {
 		fmt.Fprintf(ctxt.Bso, "nosplit ")
 	}
 	fmt.Fprintf(ctxt.Bso, "size=%d", s.Size)
-	if s.Type == STEXT {
+	if s.Type == objabi.STEXT {
 		fmt.Fprintf(ctxt.Bso, " args=%#x locals=%#x", uint64(s.Func.Args), uint64(s.Func.Locals))
 		if s.Leaf() {
 			fmt.Fprintf(ctxt.Bso, " leaf")
 		}
 	}
 	fmt.Fprintf(ctxt.Bso, "\n")
-	if s.Type == STEXT {
+	if s.Type == objabi.STEXT {
 		for p := s.Func.Text; p != nil; p = p.Link {
 			fmt.Fprintf(ctxt.Bso, "\t%#04x %v\n", uint(int(p.Pc)), p)
 		}
@@ -369,7 +264,7 @@ func (w *objWriter) writeSymDebug(s *LSym) {
 		name := ""
 		if r.Sym != nil {
 			name = r.Sym.Name
-		} else if r.Type == R_TLS_LE {
+		} else if r.Type == objabi.R_TLS_LE {
 			name = "TLS"
 		}
 		if ctxt.Arch.InFamily(sys.ARM, sys.PPC64) {
@@ -415,7 +310,7 @@ func (w *objWriter) writeSym(s *LSym) {
 		w.writeRefIndex(r.Sym)
 	}
 
-	if s.Type != STEXT {
+	if s.Type != objabi.STEXT {
 		return
 	}
 
@@ -442,9 +337,9 @@ func (w *objWriter) writeSym(s *LSym) {
 		w.writeRefIndex(a.Asym)
 		w.writeInt(int64(a.Aoffset))
 		if a.Name == NAME_AUTO {
-			w.writeInt(A_AUTO)
+			w.writeInt(objabi.A_AUTO)
 		} else if a.Name == NAME_PARAM {
-			w.writeInt(A_PARAM)
+			w.writeInt(objabi.A_PARAM)
 		} else {
 			log.Fatalf("%s: invalid local variable type %d", s.Name, a.Name)
 		}
@@ -552,12 +447,12 @@ func (c dwCtxt) AddSectionOffset(s dwarf.Sym, size int, t interface{}, ofs int64
 	rsym := t.(*LSym)
 	ls.WriteAddr(c.Link, ls.Size, size, rsym, ofs)
 	r := &ls.R[len(ls.R)-1]
-	r.Type = R_DWARFREF
+	r.Type = objabi.R_DWARFREF
 }
 
 // dwarfSym returns the DWARF symbol for TEXT symbol.
 func (ctxt *Link) dwarfSym(s *LSym) *LSym {
-	if s.Type != STEXT {
+	if s.Type != objabi.STEXT {
 		ctxt.Diag("dwarfSym of non-TEXT %v", s)
 	}
 	if s.Func.dwarfSym == nil {
diff --git a/src/cmd/internal/obj/plist.go b/src/cmd/internal/obj/plist.go
index 2b01e079c1..84858b479c 100644
--- a/src/cmd/internal/obj/plist.go
+++ b/src/cmd/internal/obj/plist.go
@@ -5,6 +5,7 @@
 package obj
 
 import (
+	"cmd/internal/objabi"
 	"fmt"
 	"strings"
 )
@@ -54,7 +55,7 @@ func Flushplist(ctxt *Link, plist *Plist, newprog ProgAlloc) {
 				continue
 			}
 			if p.To.Sym.Name == "go_args_stackmap" {
-				if p.From.Type != TYPE_CONST || p.From.Offset != FUNCDATA_ArgsPointerMaps {
+				if p.From.Type != TYPE_CONST || p.From.Offset != objabi.FUNCDATA_ArgsPointerMaps {
 					ctxt.Diag("FUNCDATA use of go_args_stackmap(SB) without FUNCDATA_ArgsPointerMaps")
 				}
 				p.To.Sym = ctxt.Lookup(fmt.Sprintf("%s.args_stackmap", curtext.Name), int(curtext.Version))
@@ -81,7 +82,7 @@ func Flushplist(ctxt *Link, plist *Plist, newprog ProgAlloc) {
 		}
 		found := false
 		for p := s.Func.Text; p != nil; p = p.Link {
-			if p.As == AFUNCDATA && p.From.Type == TYPE_CONST && p.From.Offset == FUNCDATA_ArgsPointerMaps {
+			if p.As == AFUNCDATA && p.From.Type == TYPE_CONST && p.From.Offset == objabi.FUNCDATA_ArgsPointerMaps {
 				found = true
 				break
 			}
@@ -91,7 +92,7 @@ func Flushplist(ctxt *Link, plist *Plist, newprog ProgAlloc) {
 			p := Appendp(s.Func.Text, newprog)
 			p.As = AFUNCDATA
 			p.From.Type = TYPE_CONST
-			p.From.Offset = FUNCDATA_ArgsPointerMaps
+			p.From.Offset = objabi.FUNCDATA_ArgsPointerMaps
 			p.To.Type = TYPE_MEM
 			p.To.Name = NAME_EXTERN
 			p.To.Sym = ctxt.Lookup(fmt.Sprintf("%s.args_stackmap", s.Name), int(s.Version))
@@ -131,12 +132,12 @@ func (ctxt *Link) InitTextSym(s *LSym, flag int) {
 	s.Set(AttrWrapper, flag&WRAPPER != 0)
 	s.Set(AttrNeedCtxt, flag&NEEDCTXT != 0)
 	s.Set(AttrNoFrame, flag&NOFRAME != 0)
-	s.Type = STEXT
+	s.Type = objabi.STEXT
 	ctxt.Text = append(ctxt.Text, s)
 
 	// Set up DWARF entry for s.
 	dsym := ctxt.dwarfSym(s)
-	dsym.Type = SDWARFINFO
+	dsym.Type = objabi.SDWARFINFO
 	dsym.Set(AttrDuplicateOK, s.DuplicateOK())
 	ctxt.Data = append(ctxt.Data, dsym)
 
@@ -144,10 +145,10 @@ func (ctxt *Link) InitTextSym(s *LSym, flag int) {
 	// They will be filled in later if needed.
 	gcargs := &s.Func.GCArgs
 	gcargs.Set(AttrDuplicateOK, true)
-	gcargs.Type = SRODATA
+	gcargs.Type = objabi.SRODATA
 	gclocals := &s.Func.GCLocals
 	gclocals.Set(AttrDuplicateOK, true)
-	gclocals.Type = SRODATA
+	gclocals.Type = objabi.SRODATA
 }
 
 func (ctxt *Link) Globl(s *LSym, size int64, flag int) {
@@ -161,17 +162,17 @@ func (ctxt *Link) Globl(s *LSym, size int64, flag int) {
 	s.Set(AttrOnList, true)
 	ctxt.Data = append(ctxt.Data, s)
 	s.Size = size
-	if s.Type == 0 || s.Type == SXREF {
-		s.Type = SBSS
+	if s.Type == 0 || s.Type == objabi.SXREF {
+		s.Type = objabi.SBSS
 	}
 	if flag&DUPOK != 0 {
 		s.Set(AttrDuplicateOK, true)
 	}
 	if flag&RODATA != 0 {
-		s.Type = SRODATA
+		s.Type = objabi.SRODATA
 	} else if flag&NOPTR != 0 {
-		s.Type = SNOPTRBSS
+		s.Type = objabi.SNOPTRBSS
 	} else if flag&TLSBSS != 0 {
-		s.Type = STLSBSS
+		s.Type = objabi.STLSBSS
 	}
 }
diff --git a/src/cmd/internal/obj/ppc64/asm9.go b/src/cmd/internal/obj/ppc64/asm9.go
index abf15196ec..033203bfd4 100644
--- a/src/cmd/internal/obj/ppc64/asm9.go
+++ b/src/cmd/internal/obj/ppc64/asm9.go
@@ -31,6 +31,7 @@ package ppc64
 
 import (
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"encoding/binary"
 	"fmt"
 	"log"
@@ -742,7 +743,7 @@ func (c *ctxt9) aclass(a *obj.Addr) int {
 			}
 			c.instoffset = a.Offset
 			if a.Sym != nil { // use relocation
-				if a.Sym.Type == obj.STLSBSS {
+				if a.Sym.Type == objabi.STLSBSS {
 					if c.ctxt.Flag_shared {
 						return C_TLS_IE
 					} else {
@@ -809,7 +810,7 @@ func (c *ctxt9) aclass(a *obj.Addr) int {
 			if s == nil {
 				break
 			}
-			if s.Type == obj.SCONST {
+			if s.Type == objabi.SCONST {
 				c.instoffset = a.Offset
 				goto consize
 			}
@@ -2052,17 +2053,17 @@ func (c *ctxt9) symbolAccess(s *obj.LSym, d int64, reg int16, op uint32) (o1, o2
 	if c.ctxt.Flag_shared {
 		switch form {
 		case D_FORM:
-			rel.Type = obj.R_ADDRPOWER_TOCREL
+			rel.Type = objabi.R_ADDRPOWER_TOCREL
 		case DS_FORM:
-			rel.Type = obj.R_ADDRPOWER_TOCREL_DS
+			rel.Type = objabi.R_ADDRPOWER_TOCREL_DS
 		}
 
 	} else {
 		switch form {
 		case D_FORM:
-			rel.Type = obj.R_ADDRPOWER
+			rel.Type = objabi.R_ADDRPOWER
 		case DS_FORM:
-			rel.Type = obj.R_ADDRPOWER_DS
+			rel.Type = objabi.R_ADDRPOWER_DS
 		}
 	}
 	return
@@ -2280,7 +2281,7 @@ func (c *ctxt9) asmout(p *obj.Prog, o *Optab, out []uint32) {
 				// we could add some assembly syntax so that the name
 				// of the variable does not have to be assumed.
 				rel.Sym = c.ctxt.Lookup("runtime.tls_g", 0)
-				rel.Type = obj.R_POWER_TLS
+				rel.Type = objabi.R_POWER_TLS
 			}
 			o1 = AOP_RRR(c.opstorex(p.As), uint32(p.From.Reg), uint32(p.To.Index), uint32(r))
 		} else {
@@ -2311,7 +2312,7 @@ func (c *ctxt9) asmout(p *obj.Prog, o *Optab, out []uint32) {
 				rel.Off = int32(c.pc)
 				rel.Siz = 4
 				rel.Sym = c.ctxt.Lookup("runtime.tls_g", 0)
-				rel.Type = obj.R_POWER_TLS
+				rel.Type = objabi.R_POWER_TLS
 			}
 			o1 = AOP_RRR(c.oploadx(p.As), uint32(p.To.Reg), uint32(p.From.Index), uint32(r))
 		} else {
@@ -2379,7 +2380,7 @@ func (c *ctxt9) asmout(p *obj.Prog, o *Optab, out []uint32) {
 			}
 
 			rel.Add = int64(v)
-			rel.Type = obj.R_CALLPOWER
+			rel.Type = objabi.R_CALLPOWER
 		}
 		o2 = 0x60000000 // nop, sometimes overwritten by ld r2, 24(r1) when dynamic linking
 
@@ -2787,7 +2788,7 @@ func (c *ctxt9) asmout(p *obj.Prog, o *Optab, out []uint32) {
 			rel.Siz = 8
 			rel.Sym = p.From.Sym
 			rel.Add = p.From.Offset
-			rel.Type = obj.R_ADDR
+			rel.Type = objabi.R_ADDR
 			o2 = 0
 			o1 = o2
 		}
@@ -3195,7 +3196,7 @@ func (c *ctxt9) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Off = int32(c.pc)
 		rel.Siz = 4
 		rel.Sym = p.From.Sym
-		rel.Type = obj.R_POWER_TLS_LE
+		rel.Type = objabi.R_POWER_TLS_LE
 
 	case 80:
 		if p.From.Offset != 0 {
@@ -3207,7 +3208,7 @@ func (c *ctxt9) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Off = int32(c.pc)
 		rel.Siz = 8
 		rel.Sym = p.From.Sym
-		rel.Type = obj.R_POWER_TLS_IE
+		rel.Type = objabi.R_POWER_TLS_IE
 
 	case 81:
 		v := c.vregoff(&p.To)
@@ -3221,7 +3222,7 @@ func (c *ctxt9) asmout(p *obj.Prog, o *Optab, out []uint32) {
 		rel.Off = int32(c.pc)
 		rel.Siz = 8
 		rel.Sym = p.From.Sym
-		rel.Type = obj.R_ADDRPOWER_GOT
+		rel.Type = objabi.R_ADDRPOWER_GOT
 	case 82: /* vector instructions, VX-form and VC-form */
 		if p.From.Type == obj.TYPE_REG {
 			/* reg reg none OR reg reg reg */
diff --git a/src/cmd/internal/obj/ppc64/obj9.go b/src/cmd/internal/obj/ppc64/obj9.go
index 0adab5b79a..e4c6f63ca2 100644
--- a/src/cmd/internal/obj/ppc64/obj9.go
+++ b/src/cmd/internal/obj/ppc64/obj9.go
@@ -31,6 +31,7 @@ package ppc64
 
 import (
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 )
 
@@ -195,7 +196,7 @@ func (c *ctxt9) rewriteToUseGot(p *obj.Prog) {
 	if p.As == obj.ATEXT || p.As == obj.AFUNCDATA || p.As == obj.ACALL || p.As == obj.ARET || p.As == obj.AJMP {
 		return
 	}
-	if source.Sym.Type == obj.STLSBSS {
+	if source.Sym.Type == objabi.STLSBSS {
 		return
 	}
 	if source.Type != obj.TYPE_MEM {
@@ -448,7 +449,7 @@ func preprocess(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
 				autosize += int32(c.ctxt.FixedFrameSize())
 			}
 
-			if p.Mark&LEAF != 0 && autosize < obj.StackSmall {
+			if p.Mark&LEAF != 0 && autosize < objabi.StackSmall {
 				// A leaf function with a small stack can be marked
 				// NOSPLIT, avoiding a stack check.
 				p.From.Sym.Set(obj.AttrNoSplit, true)
@@ -489,7 +490,7 @@ func preprocess(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
 				rel.Off = 0
 				rel.Siz = 8
 				rel.Sym = c.ctxt.Lookup(".TOC.", 0)
-				rel.Type = obj.R_ADDRPOWER_PCREL
+				rel.Type = objabi.R_ADDRPOWER_PCREL
 			}
 
 			if !c.cursym.Func.Text.From.Sym.NoSplit() {
@@ -840,7 +841,7 @@ func (c *ctxt9) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 	p.To.Reg = REG_R3
 
 	var q *obj.Prog
-	if framesize <= obj.StackSmall {
+	if framesize <= objabi.StackSmall {
 		// small stack: SP < stackguard
 		//	CMP	stackguard, SP
 		p = obj.Appendp(p, c.newprog)
@@ -850,7 +851,7 @@ func (c *ctxt9) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 		p.From.Reg = REG_R3
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REGSP
-	} else if framesize <= obj.StackBig {
+	} else if framesize <= objabi.StackBig {
 		// large stack: SP-framesize < stackguard-StackSmall
 		//	ADD $-(framesize-StackSmall), SP, R4
 		//	CMP stackguard, R4
@@ -858,7 +859,7 @@ func (c *ctxt9) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 
 		p.As = AADD
 		p.From.Type = obj.TYPE_CONST
-		p.From.Offset = -(int64(framesize) - obj.StackSmall)
+		p.From.Offset = -(int64(framesize) - objabi.StackSmall)
 		p.Reg = REGSP
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_R4
@@ -891,7 +892,7 @@ func (c *ctxt9) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 		p.From.Type = obj.TYPE_REG
 		p.From.Reg = REG_R3
 		p.To.Type = obj.TYPE_CONST
-		p.To.Offset = obj.StackPreempt
+		p.To.Offset = objabi.StackPreempt
 
 		p = obj.Appendp(p, c.newprog)
 		q = p
@@ -901,7 +902,7 @@ func (c *ctxt9) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 		p = obj.Appendp(p, c.newprog)
 		p.As = AADD
 		p.From.Type = obj.TYPE_CONST
-		p.From.Offset = obj.StackGuard
+		p.From.Offset = objabi.StackGuard
 		p.Reg = REGSP
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_R4
@@ -916,7 +917,7 @@ func (c *ctxt9) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 		p = obj.Appendp(p, c.newprog)
 		p.As = AMOVD
 		p.From.Type = obj.TYPE_CONST
-		p.From.Offset = int64(framesize) + obj.StackGuard - obj.StackSmall
+		p.From.Offset = int64(framesize) + objabi.StackGuard - objabi.StackSmall
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REGTMP
 
diff --git a/src/cmd/internal/obj/s390x/asmz.go b/src/cmd/internal/obj/s390x/asmz.go
index d2b58d616c..7b25b88fa8 100644
--- a/src/cmd/internal/obj/s390x/asmz.go
+++ b/src/cmd/internal/obj/s390x/asmz.go
@@ -31,6 +31,7 @@ package s390x
 
 import (
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"log"
 	"math"
 	"sort"
@@ -487,7 +488,7 @@ func (c *ctxtz) aclass(a *obj.Addr) int {
 				break
 			}
 			c.instoffset = a.Offset
-			if a.Sym.Type == obj.STLSBSS {
+			if a.Sym.Type == objabi.STLSBSS {
 				if c.ctxt.Flag_shared {
 					return C_TLS_IE // initial exec model
 				}
@@ -557,7 +558,7 @@ func (c *ctxtz) aclass(a *obj.Addr) int {
 				break
 			}
 			c.instoffset = a.Offset
-			if s.Type == obj.SCONST {
+			if s.Type == objabi.SCONST {
 				goto consize
 			}
 
@@ -2508,7 +2509,7 @@ func (c *ctxtz) addrilreloc(sym *obj.LSym, add int64) *obj.Reloc {
 	rel.Siz = 4
 	rel.Sym = sym
 	rel.Add = add + offset + int64(rel.Siz)
-	rel.Type = obj.R_PCRELDBL
+	rel.Type = objabi.R_PCRELDBL
 	return rel
 }
 
@@ -2522,7 +2523,7 @@ func (c *ctxtz) addrilrelocoffset(sym *obj.LSym, add, offset int64) *obj.Reloc {
 	rel.Siz = 4
 	rel.Sym = sym
 	rel.Add = add + offset + int64(rel.Siz)
-	rel.Type = obj.R_PCRELDBL
+	rel.Type = objabi.R_PCRELDBL
 	return rel
 }
 
@@ -2538,7 +2539,7 @@ func (c *ctxtz) addcallreloc(sym *obj.LSym, add int64) *obj.Reloc {
 	rel.Siz = 4
 	rel.Sym = sym
 	rel.Add = add + offset + int64(rel.Siz)
-	rel.Type = obj.R_CALL
+	rel.Type = objabi.R_CALL
 	return rel
 }
 
@@ -3716,7 +3717,7 @@ func (c *ctxtz) asmout(p *obj.Prog, asm *[]byte) {
 		rel.Off = int32(c.pc + 2)
 		rel.Siz = 4
 		rel.Sym = p.From.Sym
-		rel.Type = obj.R_GOTPCREL
+		rel.Type = objabi.R_GOTPCREL
 		rel.Add = 2 + int64(rel.Siz)
 
 	case 94: // TLS local exec model
@@ -3728,7 +3729,7 @@ func (c *ctxtz) asmout(p *obj.Prog, asm *[]byte) {
 		rel.Off = int32(c.pc + sizeRIL + sizeRXY + sizeRI)
 		rel.Siz = 8
 		rel.Sym = p.From.Sym
-		rel.Type = obj.R_TLS_LE
+		rel.Type = objabi.R_TLS_LE
 		rel.Add = 0
 
 	case 95: // TLS initial exec model
@@ -3748,7 +3749,7 @@ func (c *ctxtz) asmout(p *obj.Prog, asm *[]byte) {
 		ieent.Off = int32(c.pc + 2)
 		ieent.Siz = 4
 		ieent.Sym = p.From.Sym
-		ieent.Type = obj.R_TLS_IE
+		ieent.Type = objabi.R_TLS_IE
 		ieent.Add = 2 + int64(ieent.Siz)
 
 		// R_390_TLS_LOAD
diff --git a/src/cmd/internal/obj/s390x/objz.go b/src/cmd/internal/obj/s390x/objz.go
index e716eb00b1..80aee60fd2 100644
--- a/src/cmd/internal/obj/s390x/objz.go
+++ b/src/cmd/internal/obj/s390x/objz.go
@@ -31,6 +31,7 @@ package s390x
 
 import (
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"math"
 )
@@ -159,7 +160,7 @@ func (c *ctxtz) rewriteToUseGot(p *obj.Prog) {
 	if p.As == obj.ATEXT || p.As == obj.AFUNCDATA || p.As == obj.ACALL || p.As == obj.ARET || p.As == obj.AJMP {
 		return
 	}
-	if source.Sym.Type == obj.STLSBSS {
+	if source.Sym.Type == objabi.STLSBSS {
 		return
 	}
 	if source.Type != obj.TYPE_MEM {
@@ -302,7 +303,7 @@ func preprocess(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
 				autosize += int32(c.ctxt.FixedFrameSize())
 			}
 
-			if p.Mark&LEAF != 0 && autosize < obj.StackSmall {
+			if p.Mark&LEAF != 0 && autosize < objabi.StackSmall {
 				// A leaf function with a small stack can be marked
 				// NOSPLIT, avoiding a stack check.
 				p.From.Sym.Set(obj.AttrNoSplit, true)
@@ -537,7 +538,7 @@ func (c *ctxtz) stacksplitPre(p *obj.Prog, framesize int32) (*obj.Prog, *obj.Pro
 	p.To.Reg = REG_R3
 
 	q = nil
-	if framesize <= obj.StackSmall {
+	if framesize <= objabi.StackSmall {
 		// small stack: SP < stackguard
 		//	CMP	stackguard, SP
 
@@ -565,7 +566,7 @@ func (c *ctxtz) stacksplitPre(p *obj.Prog, framesize int32) (*obj.Prog, *obj.Pro
 		//p.As = ABGE
 		//p.To.Type = obj.TYPE_BRANCH
 
-	} else if framesize <= obj.StackBig {
+	} else if framesize <= objabi.StackBig {
 		// large stack: SP-framesize < stackguard-StackSmall
 		//	ADD $-(framesize-StackSmall), SP, R4
 		//	CMP stackguard, R4
@@ -573,7 +574,7 @@ func (c *ctxtz) stacksplitPre(p *obj.Prog, framesize int32) (*obj.Prog, *obj.Pro
 
 		p.As = AADD
 		p.From.Type = obj.TYPE_CONST
-		p.From.Offset = -(int64(framesize) - obj.StackSmall)
+		p.From.Offset = -(int64(framesize) - objabi.StackSmall)
 		p.Reg = REGSP
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_R4
@@ -607,7 +608,7 @@ func (c *ctxtz) stacksplitPre(p *obj.Prog, framesize int32) (*obj.Prog, *obj.Pro
 		p.From.Type = obj.TYPE_REG
 		p.From.Reg = REG_R3
 		p.To.Type = obj.TYPE_CONST
-		p.To.Offset = obj.StackPreempt
+		p.To.Offset = objabi.StackPreempt
 
 		p = obj.Appendp(p, c.newprog)
 		q = p
@@ -617,7 +618,7 @@ func (c *ctxtz) stacksplitPre(p *obj.Prog, framesize int32) (*obj.Prog, *obj.Pro
 		p = obj.Appendp(p, c.newprog)
 		p.As = AADD
 		p.From.Type = obj.TYPE_CONST
-		p.From.Offset = obj.StackGuard
+		p.From.Offset = objabi.StackGuard
 		p.Reg = REGSP
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_R4
@@ -632,7 +633,7 @@ func (c *ctxtz) stacksplitPre(p *obj.Prog, framesize int32) (*obj.Prog, *obj.Pro
 		p = obj.Appendp(p, c.newprog)
 		p.As = AMOVD
 		p.From.Type = obj.TYPE_CONST
-		p.From.Offset = int64(framesize) + obj.StackGuard - obj.StackSmall
+		p.From.Offset = int64(framesize) + objabi.StackGuard - objabi.StackSmall
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REGTMP
 
@@ -659,7 +660,7 @@ func (c *ctxtz) stacksplitPost(p *obj.Prog, pPre *obj.Prog, pPreempt *obj.Prog,
 	pcdata.Pos = c.cursym.Func.Text.Pos
 	pcdata.As = obj.APCDATA
 	pcdata.From.Type = obj.TYPE_CONST
-	pcdata.From.Offset = obj.PCDATA_StackMapIndex
+	pcdata.From.Offset = objabi.PCDATA_StackMapIndex
 	pcdata.To.Type = obj.TYPE_CONST
 	pcdata.To.Offset = -1 // pcdata starts at -1 at function entry
 
diff --git a/src/cmd/internal/obj/sym.go b/src/cmd/internal/obj/sym.go
index bb844cdb0d..ec50aad7bf 100644
--- a/src/cmd/internal/obj/sym.go
+++ b/src/cmd/internal/obj/sym.go
@@ -32,38 +32,25 @@
 package obj
 
 import (
+	"cmd/internal/objabi"
 	"fmt"
 	"log"
 	"math"
-	"os"
-	"path/filepath"
 )
 
-// WorkingDir returns the current working directory
-// (or "/???" if the directory cannot be identified),
-// with "/" as separator.
-func WorkingDir() string {
-	var path string
-	path, _ = os.Getwd()
-	if path == "" {
-		path = "/???"
-	}
-	return filepath.ToSlash(path)
-}
-
 func Linknew(arch *LinkArch) *Link {
 	ctxt := new(Link)
 	ctxt.hash = make(map[SymVer]*LSym)
 	ctxt.Arch = arch
-	ctxt.Pathname = WorkingDir()
+	ctxt.Pathname = objabi.WorkingDir()
 
-	ctxt.Headtype.Set(GOOS)
+	ctxt.Headtype.Set(objabi.GOOS)
 	if ctxt.Headtype < 0 {
-		log.Fatalf("unknown goos %s", GOOS)
+		log.Fatalf("unknown goos %s", objabi.GOOS)
 	}
 
 	ctxt.Flag_optimize = true
-	ctxt.Framepointer_enabled = Framepointer_enabled(GOOS, arch.Name)
+	ctxt.Framepointer_enabled = objabi.Framepointer_enabled(objabi.GOOS, arch.Name)
 	return ctxt
 }
 
diff --git a/src/cmd/internal/obj/util.go b/src/cmd/internal/obj/util.go
index e800ea6efb..2e3ba15542 100644
--- a/src/cmd/internal/obj/util.go
+++ b/src/cmd/internal/obj/util.go
@@ -6,58 +6,13 @@ package obj
 
 import (
 	"bytes"
+	"cmd/internal/objabi"
 	"fmt"
-	"log"
-	"os"
 	"strings"
-	"time"
 )
 
 const REG_NONE = 0
 
-var start time.Time
-
-func Cputime() float64 {
-	if start.IsZero() {
-		start = time.Now()
-	}
-	return time.Since(start).Seconds()
-}
-
-func envOr(key, value string) string {
-	if x := os.Getenv(key); x != "" {
-		return x
-	}
-	return value
-}
-
-var (
-	GOROOT  = envOr("GOROOT", defaultGOROOT)
-	GOARCH  = envOr("GOARCH", defaultGOARCH)
-	GOOS    = envOr("GOOS", defaultGOOS)
-	GO386   = envOr("GO386", defaultGO386)
-	GOARM   = goarm()
-	Version = version
-)
-
-func goarm() int {
-	switch v := envOr("GOARM", defaultGOARM); v {
-	case "5":
-		return 5
-	case "6":
-		return 6
-	case "7":
-		return 7
-	}
-	// Fail here, rather than validate at multiple call sites.
-	log.Fatalf("Invalid GOARM value. Must be 5, 6, or 7.")
-	panic("unreachable")
-}
-
-func Getgoextlinkenabled() string {
-	return envOr("GO_EXTLINK_ENABLED", defaultGO_EXTLINK_ENABLED)
-}
-
 func (p *Prog) Line() string {
 	return p.Ctxt.OutermostPos(p.Pos).Format(false)
 }
@@ -240,7 +195,7 @@ func Dconv(p *Prog, a *Addr) string {
 		}
 
 	case TYPE_TEXTSIZE:
-		if a.Val.(int32) == ArgsSizeUnknown {
+		if a.Val.(int32) == objabi.ArgsSizeUnknown {
 			str = fmt.Sprintf("$%d", a.Offset)
 		} else {
 			str = fmt.Sprintf("$%d-%d", a.Offset, a.Val.(int32))
@@ -263,7 +218,7 @@ func Dconv(p *Prog, a *Addr) string {
 	case TYPE_SHIFT:
 		v := int(a.Offset)
 		ops := "<<>>->@>"
-		switch GOARCH {
+		switch objabi.GOARCH {
 		case "arm":
 			op := ops[((v>>5)&3)<<1:]
 			if v&(1<<4) != 0 {
@@ -278,7 +233,7 @@ func Dconv(p *Prog, a *Addr) string {
 			op := ops[((v>>22)&3)<<1:]
 			str = fmt.Sprintf("R%d%c%c%d", (v>>16)&31, op[0], op[1], (v>>10)&63)
 		default:
-			panic("TYPE_SHIFT is not supported on " + GOARCH)
+			panic("TYPE_SHIFT is not supported on " + objabi.GOARCH)
 		}
 
 	case TYPE_REGREG:
diff --git a/src/cmd/internal/obj/x86/asm6.go b/src/cmd/internal/obj/x86/asm6.go
index 8902725471..cee1a6516d 100644
--- a/src/cmd/internal/obj/x86/asm6.go
+++ b/src/cmd/internal/obj/x86/asm6.go
@@ -32,6 +32,7 @@ package x86
 
 import (
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"encoding/binary"
 	"fmt"
@@ -1844,7 +1845,7 @@ func span6(ctxt *obj.Link, s *obj.LSym, newprog obj.ProgAlloc) {
 		s.P = s.P[:0]
 		c = 0
 		for p := s.Func.Text; p != nil; p = p.Link {
-			if ctxt.Headtype == obj.Hnacl && p.Isize > 0 {
+			if ctxt.Headtype == objabi.Hnacl && p.Isize > 0 {
 
 				// pad everything to avoid crossing 32-byte boundary
 				if c>>5 != (c+int32(p.Isize)-1)>>5 {
@@ -1939,7 +1940,7 @@ func span6(ctxt *obj.Link, s *obj.LSym, newprog obj.ProgAlloc) {
 		}
 	}
 
-	if ctxt.Headtype == obj.Hnacl {
+	if ctxt.Headtype == objabi.Hnacl {
 		c = naclpad(ctxt, s, c, -c&31)
 	}
 
@@ -1975,9 +1976,9 @@ func instinit(ctxt *obj.Link) {
 	}
 
 	switch ctxt.Headtype {
-	case obj.Hplan9:
+	case objabi.Hplan9:
 		plan9privates = ctxt.Lookup("_privates", 0)
-	case obj.Hnacl:
+	case objabi.Hnacl:
 		deferreturn = ctxt.Lookup("runtime.deferreturn", 0)
 	}
 
@@ -2121,7 +2122,7 @@ func instinit(ctxt *obj.Link) {
 	}
 }
 
-var isAndroid = (obj.GOOS == "android")
+var isAndroid = (objabi.GOOS == "android")
 
 func prefixof(ctxt *obj.Link, p *obj.Prog, a *obj.Addr) int {
 	if a.Reg < REG_CS && a.Index < REG_CS { // fast path
@@ -2159,11 +2160,11 @@ func prefixof(ctxt *obj.Link, p *obj.Prog, a *obj.Addr) int {
 					}
 					log.Fatalf("unknown TLS base register for %v", ctxt.Headtype)
 
-				case obj.Hdarwin,
-					obj.Hdragonfly,
-					obj.Hfreebsd,
-					obj.Hnetbsd,
-					obj.Hopenbsd:
+				case objabi.Hdarwin,
+					objabi.Hdragonfly,
+					objabi.Hfreebsd,
+					objabi.Hnetbsd,
+					objabi.Hopenbsd:
 					return 0x65 // GS
 				}
 			}
@@ -2172,7 +2173,7 @@ func prefixof(ctxt *obj.Link, p *obj.Prog, a *obj.Addr) int {
 			default:
 				log.Fatalf("unknown TLS base register for %v", ctxt.Headtype)
 
-			case obj.Hlinux:
+			case objabi.Hlinux:
 				if isAndroid {
 					return 0x64 // FS
 				}
@@ -2183,14 +2184,14 @@ func prefixof(ctxt *obj.Link, p *obj.Prog, a *obj.Addr) int {
 					return 0x64 // FS
 				}
 
-			case obj.Hdragonfly,
-				obj.Hfreebsd,
-				obj.Hnetbsd,
-				obj.Hopenbsd,
-				obj.Hsolaris:
+			case objabi.Hdragonfly,
+				objabi.Hfreebsd,
+				objabi.Hnetbsd,
+				objabi.Hopenbsd,
+				objabi.Hsolaris:
 				return 0x64 // FS
 
-			case obj.Hdarwin:
+			case objabi.Hdarwin:
 				return 0x65 // GS
 			}
 		}
@@ -2800,13 +2801,13 @@ func vaddr(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, r *obj.Reloc) int64 {
 
 		if a.Name == obj.NAME_GOTREF {
 			r.Siz = 4
-			r.Type = obj.R_GOTPCREL
+			r.Type = objabi.R_GOTPCREL
 		} else if isextern(s) || (ctxt.Arch.Family != sys.AMD64 && !ctxt.Flag_shared) {
 			r.Siz = 4
-			r.Type = obj.R_ADDR
+			r.Type = objabi.R_ADDR
 		} else {
 			r.Siz = 4
-			r.Type = obj.R_PCREL
+			r.Type = objabi.R_PCREL
 		}
 
 		r.Off = -1 // caller must fill in
@@ -2822,8 +2823,8 @@ func vaddr(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, r *obj.Reloc) int64 {
 			log.Fatalf("reloc")
 		}
 
-		if !ctxt.Flag_shared || isAndroid || ctxt.Headtype == obj.Hdarwin {
-			r.Type = obj.R_TLS_LE
+		if !ctxt.Flag_shared || isAndroid || ctxt.Headtype == objabi.Hdarwin {
+			r.Type = objabi.R_TLS_LE
 			r.Siz = 4
 			r.Off = -1 // caller must fill in
 			r.Add = a.Offset
@@ -2992,7 +2993,7 @@ func (asmbuf *AsmBuf) asmandsz(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog, a
 	if REG_AX <= base && base <= REG_R15 {
 		if a.Index == REG_TLS && !ctxt.Flag_shared {
 			rel = obj.Reloc{}
-			rel.Type = obj.R_TLS_LE
+			rel.Type = objabi.R_TLS_LE
 			rel.Siz = 4
 			rel.Sym = nil
 			rel.Add = int64(v)
@@ -3625,7 +3626,7 @@ func (asmbuf *AsmBuf) doasm(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 			case Zcallindreg:
 				r = obj.Addrel(cursym)
 				r.Off = int32(p.Pc)
-				r.Type = obj.R_CALLIND
+				r.Type = objabi.R_CALLIND
 				r.Siz = 0
 				fallthrough
 
@@ -3786,7 +3787,7 @@ func (asmbuf *AsmBuf) doasm(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 				}
 				r = obj.Addrel(cursym)
 				r.Off = int32(p.Pc + int64(asmbuf.Len()))
-				r.Type = obj.R_PCREL
+				r.Type = objabi.R_PCREL
 				r.Siz = 4
 				r.Add = p.To.Offset
 				asmbuf.PutInt32(0)
@@ -3796,9 +3797,9 @@ func (asmbuf *AsmBuf) doasm(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 				r = obj.Addrel(cursym)
 				r.Off = int32(p.Pc + int64(asmbuf.Len()))
 				if ctxt.Arch.Family == sys.AMD64 {
-					r.Type = obj.R_PCREL
+					r.Type = objabi.R_PCREL
 				} else {
-					r.Type = obj.R_ADDR
+					r.Type = objabi.R_ADDR
 				}
 				r.Siz = 4
 				r.Add = p.To.Offset
@@ -3830,7 +3831,7 @@ func (asmbuf *AsmBuf) doasm(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 				r.Off = int32(p.Pc + int64(asmbuf.Len()))
 				r.Sym = p.To.Sym
 				r.Add = p.To.Offset
-				r.Type = obj.R_CALL
+				r.Type = objabi.R_CALL
 				r.Siz = 4
 				asmbuf.PutInt32(0)
 
@@ -3855,7 +3856,7 @@ func (asmbuf *AsmBuf) doasm(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 					r = obj.Addrel(cursym)
 					r.Off = int32(p.Pc + int64(asmbuf.Len()))
 					r.Sym = p.To.Sym
-					r.Type = obj.R_PCREL
+					r.Type = objabi.R_PCREL
 					r.Siz = 4
 					asmbuf.PutInt32(0)
 					break
@@ -4072,8 +4073,8 @@ func (asmbuf *AsmBuf) doasm(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 						default:
 							log.Fatalf("unknown TLS base location for %v", ctxt.Headtype)
 
-						case obj.Hlinux,
-							obj.Hnacl:
+						case objabi.Hlinux,
+							objabi.Hnacl:
 							if ctxt.Flag_shared {
 								// Note that this is not generating the same insns as the other cases.
 								//     MOV TLS, dst
@@ -4090,7 +4091,7 @@ func (asmbuf *AsmBuf) doasm(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 								asmbuf.Put1(0xe8)
 								r = obj.Addrel(cursym)
 								r.Off = int32(p.Pc + int64(asmbuf.Len()))
-								r.Type = obj.R_CALL
+								r.Type = objabi.R_CALL
 								r.Siz = 4
 								r.Sym = ctxt.Lookup("__x86.get_pc_thunk."+strings.ToLower(rconv(int(dst))), 0)
 								asmbuf.PutInt32(0)
@@ -4098,7 +4099,7 @@ func (asmbuf *AsmBuf) doasm(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 								asmbuf.Put2(0x8B, byte(2<<6|reg[dst]|(reg[dst]<<3)))
 								r = obj.Addrel(cursym)
 								r.Off = int32(p.Pc + int64(asmbuf.Len()))
-								r.Type = obj.R_TLS_IE
+								r.Type = objabi.R_TLS_IE
 								r.Siz = 4
 								r.Add = 2
 								asmbuf.PutInt32(0)
@@ -4115,7 +4116,7 @@ func (asmbuf *AsmBuf) doasm(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 									0x8B)
 								asmbuf.asmand(ctxt, cursym, p, &pp.From, &p.To)
 							}
-						case obj.Hplan9:
+						case objabi.Hplan9:
 							pp.From = obj.Addr{}
 							pp.From.Type = obj.TYPE_MEM
 							pp.From.Name = obj.NAME_EXTERN
@@ -4125,7 +4126,7 @@ func (asmbuf *AsmBuf) doasm(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 							asmbuf.Put1(0x8B)
 							asmbuf.asmand(ctxt, cursym, p, &pp.From, &p.To)
 
-						case obj.Hwindows:
+						case objabi.Hwindows:
 							// Windows TLS base is always 0x14(FS).
 							pp.From = p.From
 
@@ -4145,7 +4146,7 @@ func (asmbuf *AsmBuf) doasm(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 					default:
 						log.Fatalf("unknown TLS base location for %v", ctxt.Headtype)
 
-					case obj.Hlinux:
+					case objabi.Hlinux:
 						if !ctxt.Flag_shared {
 							log.Fatalf("unknown TLS base location for linux without -shared")
 						}
@@ -4163,12 +4164,12 @@ func (asmbuf *AsmBuf) doasm(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 						asmbuf.Put2(0x8B, byte(0x05|(reg[p.To.Reg]<<3)))
 						r = obj.Addrel(cursym)
 						r.Off = int32(p.Pc + int64(asmbuf.Len()))
-						r.Type = obj.R_TLS_IE
+						r.Type = objabi.R_TLS_IE
 						r.Siz = 4
 						r.Add = -4
 						asmbuf.PutInt32(0)
 
-					case obj.Hplan9:
+					case objabi.Hplan9:
 						pp.From = obj.Addr{}
 						pp.From.Type = obj.TYPE_MEM
 						pp.From.Name = obj.NAME_EXTERN
@@ -4179,7 +4180,7 @@ func (asmbuf *AsmBuf) doasm(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 						asmbuf.Put1(0x8B)
 						asmbuf.asmand(ctxt, cursym, p, &pp.From, &p.To)
 
-					case obj.Hsolaris: // TODO(rsc): Delete Hsolaris from list. Should not use this code. See progedit in obj6.c.
+					case objabi.Hsolaris: // TODO(rsc): Delete Hsolaris from list. Should not use this code. See progedit in obj6.c.
 						// TLS base is 0(FS).
 						pp.From = p.From
 
@@ -4194,7 +4195,7 @@ func (asmbuf *AsmBuf) doasm(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 							0x8B)
 						asmbuf.asmand(ctxt, cursym, p, &pp.From, &p.To)
 
-					case obj.Hwindows:
+					case objabi.Hwindows:
 						// Windows TLS base is always 0x28(GS).
 						pp.From = p.From
 
@@ -4434,7 +4435,7 @@ func (asmbuf *AsmBuf) nacltrunc(ctxt *obj.Link, reg int) {
 func (asmbuf *AsmBuf) asmins(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 	asmbuf.Reset()
 
-	if ctxt.Headtype == obj.Hnacl && ctxt.Arch.Family == sys.I386 {
+	if ctxt.Headtype == objabi.Hnacl && ctxt.Arch.Family == sys.I386 {
 		switch p.As {
 		case obj.ARET:
 			asmbuf.Put(naclret8)
@@ -4452,7 +4453,7 @@ func (asmbuf *AsmBuf) asmins(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 		}
 	}
 
-	if ctxt.Headtype == obj.Hnacl && ctxt.Arch.Family == sys.AMD64 {
+	if ctxt.Headtype == objabi.Hnacl && ctxt.Arch.Family == sys.AMD64 {
 		if p.As == AREP {
 			asmbuf.rep++
 			return
@@ -4567,7 +4568,7 @@ func (asmbuf *AsmBuf) asmins(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 		if asmbuf.rexflag != 0 {
 			r.Off++
 		}
-		if r.Type == obj.R_PCREL {
+		if r.Type == objabi.R_PCREL {
 			if ctxt.Arch.Family == sys.AMD64 || p.As == obj.AJMP || p.As == obj.ACALL {
 				// PC-relative addressing is relative to the end of the instruction,
 				// but the relocations applied by the linker are relative to the end
@@ -4585,14 +4586,14 @@ func (asmbuf *AsmBuf) asmins(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog) {
 				r.Add += int64(r.Off) - p.Pc + int64(r.Siz)
 			}
 		}
-		if r.Type == obj.R_GOTPCREL && ctxt.Arch.Family == sys.I386 {
+		if r.Type == objabi.R_GOTPCREL && ctxt.Arch.Family == sys.I386 {
 			// On 386, R_GOTPCREL makes the same assumptions as R_PCREL.
 			r.Add += int64(r.Off) - p.Pc + int64(r.Siz)
 		}
 
 	}
 
-	if ctxt.Arch.Family == sys.AMD64 && ctxt.Headtype == obj.Hnacl && p.As != ACMPL && p.As != ACMPQ && p.To.Type == obj.TYPE_REG {
+	if ctxt.Arch.Family == sys.AMD64 && ctxt.Headtype == objabi.Hnacl && p.As != ACMPL && p.As != ACMPQ && p.To.Type == obj.TYPE_REG {
 		switch p.To.Reg {
 		case REG_SP:
 			asmbuf.Put(naclspfix)
diff --git a/src/cmd/internal/obj/x86/obj6.go b/src/cmd/internal/obj/x86/obj6.go
index 172a3cb4b5..c25352d0bc 100644
--- a/src/cmd/internal/obj/x86/obj6.go
+++ b/src/cmd/internal/obj/x86/obj6.go
@@ -32,6 +32,7 @@ package x86
 
 import (
 	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"math"
 	"strings"
@@ -50,10 +51,10 @@ func CanUse1InsnTLS(ctxt *obj.Link) bool {
 
 	if ctxt.Arch.Family == sys.I386 {
 		switch ctxt.Headtype {
-		case obj.Hlinux,
-			obj.Hnacl,
-			obj.Hplan9,
-			obj.Hwindows:
+		case objabi.Hlinux,
+			objabi.Hnacl,
+			objabi.Hplan9,
+			objabi.Hwindows:
 			return false
 		}
 
@@ -61,9 +62,9 @@ func CanUse1InsnTLS(ctxt *obj.Link) bool {
 	}
 
 	switch ctxt.Headtype {
-	case obj.Hplan9, obj.Hwindows:
+	case objabi.Hplan9, objabi.Hwindows:
 		return false
-	case obj.Hlinux:
+	case objabi.Hlinux:
 		return !ctxt.Flag_shared
 	}
 
@@ -123,7 +124,7 @@ func progedit(ctxt *obj.Link, p *obj.Prog, newprog obj.ProgAlloc) {
 		// TODO(rsc): Remove the Hsolaris special case. It exists only to
 		// guarantee we are producing byte-identical binaries as before this code.
 		// But it should be unnecessary.
-		if (p.As == AMOVQ || p.As == AMOVL) && p.From.Type == obj.TYPE_REG && p.From.Reg == REG_TLS && p.To.Type == obj.TYPE_REG && REG_AX <= p.To.Reg && p.To.Reg <= REG_R15 && ctxt.Headtype != obj.Hsolaris {
+		if (p.As == AMOVQ || p.As == AMOVL) && p.From.Type == obj.TYPE_REG && p.From.Reg == REG_TLS && p.To.Type == obj.TYPE_REG && REG_AX <= p.To.Reg && p.To.Reg <= REG_R15 && ctxt.Headtype != objabi.Hsolaris {
 			obj.Nopout(p)
 		}
 		if p.From.Type == obj.TYPE_MEM && p.From.Index == REG_TLS && REG_AX <= p.From.Reg && p.From.Reg <= REG_R15 {
@@ -161,7 +162,7 @@ func progedit(ctxt *obj.Link, p *obj.Prog, newprog obj.ProgAlloc) {
 	}
 
 	// TODO: Remove.
-	if ctxt.Headtype == obj.Hwindows && ctxt.Arch.Family == sys.AMD64 || ctxt.Headtype == obj.Hplan9 {
+	if ctxt.Headtype == objabi.Hwindows && ctxt.Arch.Family == sys.AMD64 || ctxt.Headtype == objabi.Hplan9 {
 		if p.From.Scale == 1 && p.From.Index == REG_TLS {
 			p.From.Scale = 2
 		}
@@ -199,7 +200,7 @@ func progedit(ctxt *obj.Link, p *obj.Prog, newprog obj.ProgAlloc) {
 		}
 	}
 
-	if ctxt.Headtype == obj.Hnacl && ctxt.Arch.Family == sys.AMD64 {
+	if ctxt.Headtype == objabi.Hnacl && ctxt.Arch.Family == sys.AMD64 {
 		if p.From3 != nil {
 			nacladdr(ctxt, p, p.From3)
 		}
@@ -496,7 +497,7 @@ func rewriteToPcrel(ctxt *obj.Link, p *obj.Prog, newprog obj.ProgAlloc) {
 		if a.Sym == nil || (a.Type != obj.TYPE_MEM && a.Type != obj.TYPE_ADDR) || a.Reg != 0 {
 			return false
 		}
-		if a.Sym.Type == obj.STLSBSS {
+		if a.Sym.Type == objabi.STLSBSS {
 			return false
 		}
 		return a.Name == obj.NAME_EXTERN || a.Name == obj.NAME_STATIC || a.Name == obj.NAME_GOTREF
@@ -637,7 +638,7 @@ func preprocess(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
 	}
 
 	// TODO(rsc): Remove 'ctxt.Arch.Family == sys.AMD64 &&'.
-	if ctxt.Arch.Family == sys.AMD64 && autoffset < obj.StackSmall && !p.From.Sym.NoSplit() {
+	if ctxt.Arch.Family == sys.AMD64 && autoffset < objabi.StackSmall && !p.From.Sym.NoSplit() {
 		leaf := true
 	LeafSearch:
 		for q := p; q != nil; q = q.Link {
@@ -651,7 +652,7 @@ func preprocess(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
 				}
 				fallthrough
 			case obj.ADUFFCOPY, obj.ADUFFZERO:
-				if autoffset >= obj.StackSmall-8 {
+				if autoffset >= objabi.StackSmall-8 {
 					leaf = false
 					break LeafSearch
 				}
@@ -741,7 +742,7 @@ func preprocess(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
 		p.From.Offset = 4 * int64(ctxt.Arch.PtrSize) // g_panic
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_BX
-		if ctxt.Headtype == obj.Hnacl && ctxt.Arch.Family == sys.AMD64 {
+		if ctxt.Headtype == objabi.Hnacl && ctxt.Arch.Family == sys.AMD64 {
 			p.As = AMOVL
 			p.From.Type = obj.TYPE_MEM
 			p.From.Reg = REG_R15
@@ -759,7 +760,7 @@ func preprocess(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
 		p.From.Reg = REG_BX
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_BX
-		if ctxt.Headtype == obj.Hnacl || ctxt.Arch.Family == sys.I386 {
+		if ctxt.Headtype == objabi.Hnacl || ctxt.Arch.Family == sys.I386 {
 			p.As = ATESTL
 		}
 
@@ -786,7 +787,7 @@ func preprocess(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
 		p.From.Offset = int64(autoffset) + int64(ctxt.Arch.RegSize)
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_DI
-		if ctxt.Headtype == obj.Hnacl || ctxt.Arch.Family == sys.I386 {
+		if ctxt.Headtype == objabi.Hnacl || ctxt.Arch.Family == sys.I386 {
 			p.As = ALEAL
 		}
 
@@ -801,7 +802,7 @@ func preprocess(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
 		p.From.Offset = 0 // Panic.argp
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_DI
-		if ctxt.Headtype == obj.Hnacl && ctxt.Arch.Family == sys.AMD64 {
+		if ctxt.Headtype == objabi.Hnacl && ctxt.Arch.Family == sys.AMD64 {
 			p.As = ACMPL
 			p.From.Type = obj.TYPE_MEM
 			p.From.Reg = REG_R15
@@ -826,7 +827,7 @@ func preprocess(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
 		p.To.Type = obj.TYPE_MEM
 		p.To.Reg = REG_BX
 		p.To.Offset = 0 // Panic.argp
-		if ctxt.Headtype == obj.Hnacl && ctxt.Arch.Family == sys.AMD64 {
+		if ctxt.Headtype == objabi.Hnacl && ctxt.Arch.Family == sys.AMD64 {
 			p.As = AMOVL
 			p.To.Type = obj.TYPE_MEM
 			p.To.Reg = REG_R15
@@ -958,7 +959,7 @@ func isZeroArgRuntimeCall(s *obj.LSym) bool {
 }
 
 func indir_cx(ctxt *obj.Link, p *obj.Prog, a *obj.Addr) {
-	if ctxt.Headtype == obj.Hnacl && ctxt.Arch.Family == sys.AMD64 {
+	if ctxt.Headtype == objabi.Hnacl && ctxt.Arch.Family == sys.AMD64 {
 		a.Type = obj.TYPE_MEM
 		a.Reg = REG_R15
 		a.Index = REG_CX
@@ -1009,7 +1010,7 @@ func stacksplit(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog, newprog obj.ProgA
 	mov := AMOVQ
 	sub := ASUBQ
 
-	if ctxt.Headtype == obj.Hnacl || ctxt.Arch.Family == sys.I386 {
+	if ctxt.Headtype == objabi.Hnacl || ctxt.Arch.Family == sys.I386 {
 		cmp = ACMPL
 		lea = ALEAL
 		mov = AMOVL
@@ -1017,7 +1018,7 @@ func stacksplit(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog, newprog obj.ProgA
 	}
 
 	var q1 *obj.Prog
-	if framesize <= obj.StackSmall {
+	if framesize <= objabi.StackSmall {
 		// small stack: SP <= stackguard
 		//	CMPQ SP, stackguard
 		p = obj.Appendp(p, newprog)
@@ -1030,7 +1031,7 @@ func stacksplit(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog, newprog obj.ProgA
 		if cursym.CFunc() {
 			p.To.Offset = 3 * int64(ctxt.Arch.PtrSize) // G.stackguard1
 		}
-	} else if framesize <= obj.StackBig {
+	} else if framesize <= objabi.StackBig {
 		// large stack: SP-framesize <= stackguard-StackSmall
 		//	LEAQ -xxx(SP), AX
 		//	CMPQ AX, stackguard
@@ -1039,7 +1040,7 @@ func stacksplit(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog, newprog obj.ProgA
 		p.As = lea
 		p.From.Type = obj.TYPE_MEM
 		p.From.Reg = REG_SP
-		p.From.Offset = -(int64(framesize) - obj.StackSmall)
+		p.From.Offset = -(int64(framesize) - objabi.StackSmall)
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_AX
 
@@ -1084,9 +1085,9 @@ func stacksplit(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog, newprog obj.ProgA
 		p.From.Type = obj.TYPE_REG
 		p.From.Reg = REG_SI
 		p.To.Type = obj.TYPE_CONST
-		p.To.Offset = obj.StackPreempt
+		p.To.Offset = objabi.StackPreempt
 		if ctxt.Arch.Family == sys.I386 {
-			p.To.Offset = int64(uint32(obj.StackPreempt & (1<<32 - 1)))
+			p.To.Offset = int64(uint32(objabi.StackPreempt & (1<<32 - 1)))
 		}
 
 		p = obj.Appendp(p, newprog)
@@ -1098,7 +1099,7 @@ func stacksplit(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog, newprog obj.ProgA
 		p.As = lea
 		p.From.Type = obj.TYPE_MEM
 		p.From.Reg = REG_SP
-		p.From.Offset = obj.StackGuard
+		p.From.Offset = objabi.StackGuard
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = REG_AX
 
@@ -1114,7 +1115,7 @@ func stacksplit(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog, newprog obj.ProgA
 		p.From.Type = obj.TYPE_REG
 		p.From.Reg = REG_AX
 		p.To.Type = obj.TYPE_CONST
-		p.To.Offset = int64(framesize) + (obj.StackGuard - obj.StackSmall)
+		p.To.Offset = int64(framesize) + (objabi.StackGuard - objabi.StackSmall)
 	}
 
 	// common
@@ -1137,7 +1138,7 @@ func stacksplit(ctxt *obj.Link, cursym *obj.LSym, p *obj.Prog, newprog obj.ProgA
 	pcdata.Pos = cursym.Func.Text.Pos
 	pcdata.As = obj.APCDATA
 	pcdata.From.Type = obj.TYPE_CONST
-	pcdata.From.Offset = obj.PCDATA_StackMapIndex
+	pcdata.From.Offset = objabi.PCDATA_StackMapIndex
 	pcdata.To.Type = obj.TYPE_CONST
 	pcdata.To.Offset = -1 // pcdata starts at -1 at function entry
 
diff --git a/src/cmd/internal/objabi/autotype.go b/src/cmd/internal/objabi/autotype.go
new file mode 100644
index 0000000000..17c4293131
--- /dev/null
+++ b/src/cmd/internal/objabi/autotype.go
@@ -0,0 +1,37 @@
+// Derived from Inferno utils/6l/l.h and related files.
+// https://bitbucket.org/inferno-os/inferno-os/src/default/utils/6l/l.h
+//
+//	Copyright  1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright  1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright  1997-1999 Vita Nuova Limited
+//	Portions Copyright  2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright  2004,2006 Bruce Ellis
+//	Portions Copyright  2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright  2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright  2009 The Go Authors. All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+package objabi
+
+// Auto.name
+const (
+	A_AUTO = 1 + iota
+	A_PARAM
+)
diff --git a/src/cmd/internal/objabi/doc.go b/src/cmd/internal/objabi/doc.go
new file mode 100644
index 0000000000..7b93fc19e5
--- /dev/null
+++ b/src/cmd/internal/objabi/doc.go
@@ -0,0 +1,119 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// NOTE: There are *three* independent implementations of this object
+// file format in the Go source tree:
+//
+//	- cmd/internal/goobj/read.go (used by cmd/addr2line, cmd/nm, cmd/objdump, cmd/pprof)
+//	- cmd/internal/obj/objfile.go (used by cmd/asm and cmd/compile)
+//	- cmd/link/internal/objfile.go (used by cmd/link)
+//
+// When changing the object file format, remember to change all three.
+
+// Originally, Go object files were Plan 9 object files, but no longer.
+// Now they are more like standard object files, in that each symbol is defined
+// by an associated memory image (bytes) and a list of relocations to apply
+// during linking. We do not (yet?) use a standard file format, however.
+// For now, the format is chosen to be as simple as possible to read and write.
+// It may change for reasons of efficiency, or we may even switch to a
+// standard file format if there are compelling benefits to doing so.
+// See golang.org/s/go13linker for more background.
+//
+// The file format is:
+//
+//	- magic header: "\x00\x00go19ld"
+//	- byte 1 - version number
+//	- sequence of strings giving dependencies (imported packages)
+//	- empty string (marks end of sequence)
+//	- sequence of symbol references used by the defined symbols
+//	- byte 0xff (marks end of sequence)
+//	- sequence of integer lengths:
+//		- total data length
+//		- total number of relocations
+//		- total number of pcdata
+//		- total number of automatics
+//		- total number of funcdata
+//		- total number of files
+//	- data, the content of the defined symbols
+//	- sequence of defined symbols
+//	- byte 0xff (marks end of sequence)
+//	- magic footer: "\xff\xffgo19ld"
+//
+// All integers are stored in a zigzag varint format.
+// See golang.org/s/go12symtab for a definition.
+//
+// Data blocks and strings are both stored as an integer
+// followed by that many bytes.
+//
+// A symbol reference is a string name followed by a version.
+//
+// A symbol points to other symbols using an index into the symbol
+// reference sequence. Index 0 corresponds to a nil symbol pointer.
+// In the symbol layout described below "symref index" stands for this
+// index.
+//
+// Each symbol is laid out as the following fields:
+//
+//	- byte 0xfe (sanity check for synchronization)
+//	- type [int]
+//	- name & version [symref index]
+//	- flags [int]
+//		1<<0 dupok
+//		1<<1 local
+//		1<<2 add to typelink table
+//	- size [int]
+//	- gotype [symref index]
+//	- p [data block]
+//	- nr [int]
+//	- r [nr relocations, sorted by off]
+//
+// If type == STEXT, there are a few more fields:
+//
+//	- args [int]
+//	- locals [int]
+//	- nosplit [int]
+//	- flags [int]
+//		1<<0 leaf
+//		1<<1 C function
+//		1<<2 function may call reflect.Type.Method
+//	- nlocal [int]
+//	- local [nlocal automatics]
+//	- pcln [pcln table]
+//
+// Each relocation has the encoding:
+//
+//	- off [int]
+//	- siz [int]
+//	- type [int]
+//	- add [int]
+//	- sym [symref index]
+//
+// Each local has the encoding:
+//
+//	- asym [symref index]
+//	- offset [int]
+//	- type [int]
+//	- gotype [symref index]
+//
+// The pcln table has the encoding:
+//
+//	- pcsp [data block]
+//	- pcfile [data block]
+//	- pcline [data block]
+//	- pcinline [data block]
+//	- npcdata [int]
+//	- pcdata [npcdata data blocks]
+//	- nfuncdata [int]
+//	- funcdata [nfuncdata symref index]
+//	- funcdatasym [nfuncdata ints]
+//	- nfile [int]
+//	- file [nfile symref index]
+//	- ninlinedcall [int]
+//	- inlinedcall [ninlinedcall int symref int symref]
+//
+// The file layout and meaning of type integers are architecture-independent.
+//
+// TODO(rsc): The file format is good for a first pass but needs work.
+//	- There are SymID in the object file that should really just be strings.
+package objabi
diff --git a/src/cmd/internal/obj/flag.go b/src/cmd/internal/objabi/flag.go
similarity index 99%
rename from src/cmd/internal/obj/flag.go
rename to src/cmd/internal/objabi/flag.go
index ff69fd9d57..e349b41324 100644
--- a/src/cmd/internal/obj/flag.go
+++ b/src/cmd/internal/objabi/flag.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package obj
+package objabi
 
 import (
 	"flag"
diff --git a/src/cmd/internal/obj/funcdata.go b/src/cmd/internal/objabi/funcdata.go
similarity index 98%
rename from src/cmd/internal/obj/funcdata.go
rename to src/cmd/internal/objabi/funcdata.go
index af1dbc271d..80874edeb0 100644
--- a/src/cmd/internal/obj/funcdata.go
+++ b/src/cmd/internal/objabi/funcdata.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package obj
+package objabi
 
 // This file defines the IDs for PCDATA and FUNCDATA instructions
 // in Go binaries.
diff --git a/src/cmd/internal/objabi/head.go b/src/cmd/internal/objabi/head.go
new file mode 100644
index 0000000000..ff19606cd2
--- /dev/null
+++ b/src/cmd/internal/objabi/head.go
@@ -0,0 +1,104 @@
+// Derived from Inferno utils/6l/l.h and related files.
+// https://bitbucket.org/inferno-os/inferno-os/src/default/utils/6l/l.h
+//
+//	Copyright  1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright  1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright  1997-1999 Vita Nuova Limited
+//	Portions Copyright  2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright  2004,2006 Bruce Ellis
+//	Portions Copyright  2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright  2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright  2009 The Go Authors. All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+package objabi
+
+import "fmt"
+
+// HeadType is the executable header type.
+type HeadType uint8
+
+const (
+	Hunknown HeadType = iota
+	Hdarwin
+	Hdragonfly
+	Hfreebsd
+	Hlinux
+	Hnacl
+	Hnetbsd
+	Hopenbsd
+	Hplan9
+	Hsolaris
+	Hwindows
+)
+
+func (h *HeadType) Set(s string) error {
+	switch s {
+	case "darwin":
+		*h = Hdarwin
+	case "dragonfly":
+		*h = Hdragonfly
+	case "freebsd":
+		*h = Hfreebsd
+	case "linux", "android":
+		*h = Hlinux
+	case "nacl":
+		*h = Hnacl
+	case "netbsd":
+		*h = Hnetbsd
+	case "openbsd":
+		*h = Hopenbsd
+	case "plan9":
+		*h = Hplan9
+	case "solaris":
+		*h = Hsolaris
+	case "windows":
+		*h = Hwindows
+	default:
+		return fmt.Errorf("invalid headtype: %q", s)
+	}
+	return nil
+}
+
+func (h *HeadType) String() string {
+	switch *h {
+	case Hdarwin:
+		return "darwin"
+	case Hdragonfly:
+		return "dragonfly"
+	case Hfreebsd:
+		return "freebsd"
+	case Hlinux:
+		return "linux"
+	case Hnacl:
+		return "nacl"
+	case Hnetbsd:
+		return "netbsd"
+	case Hopenbsd:
+		return "openbsd"
+	case Hplan9:
+		return "plan9"
+	case Hsolaris:
+		return "solaris"
+	case Hwindows:
+		return "windows"
+	}
+	return fmt.Sprintf("HeadType(%d)", *h)
+}
diff --git a/src/cmd/internal/objabi/line.go b/src/cmd/internal/objabi/line.go
new file mode 100644
index 0000000000..ed509b7001
--- /dev/null
+++ b/src/cmd/internal/objabi/line.go
@@ -0,0 +1,82 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package objabi
+
+import (
+	"os"
+	"path/filepath"
+)
+
+// WorkingDir returns the current working directory
+// (or "/???" if the directory cannot be identified),
+// with "/" as separator.
+func WorkingDir() string {
+	var path string
+	path, _ = os.Getwd()
+	if path == "" {
+		path = "/???"
+	}
+	return filepath.ToSlash(path)
+}
+
+// AbsFile returns the absolute filename for file in the given directory.
+// It also removes a leading pathPrefix, or else rewrites a leading $GOROOT
+// prefix to the literal "$GOROOT".
+// If the resulting path is the empty string, the result is "??".
+func AbsFile(dir, file, pathPrefix string) string {
+	abs := file
+	if dir != "" && !filepath.IsAbs(file) {
+		abs = filepath.Join(dir, file)
+	}
+
+	if pathPrefix != "" && hasPathPrefix(abs, pathPrefix) {
+		if abs == pathPrefix {
+			abs = ""
+		} else {
+			abs = abs[len(pathPrefix)+1:]
+		}
+	} else if hasPathPrefix(abs, GOROOT) {
+		abs = "$GOROOT" + abs[len(GOROOT):]
+	}
+	if abs == "" {
+		abs = "??"
+	}
+
+	return filepath.Clean(abs)
+}
+
+// Does s have t as a path prefix?
+// That is, does s == t or does s begin with t followed by a slash?
+// For portability, we allow ASCII case folding, so that hasPathPrefix("a/b/c", "A/B") is true.
+// Similarly, we allow slash folding, so that hasPathPrefix("a/b/c", "a\\b") is true.
+// We do not allow full Unicode case folding, for fear of causing more confusion
+// or harm than good. (For an example of the kinds of things that can go wrong,
+// see http://article.gmane.org/gmane.linux.kernel/1853266.)
+func hasPathPrefix(s string, t string) bool {
+	if len(t) > len(s) {
+		return false
+	}
+	var i int
+	for i = 0; i < len(t); i++ {
+		cs := int(s[i])
+		ct := int(t[i])
+		if 'A' <= cs && cs <= 'Z' {
+			cs += 'a' - 'A'
+		}
+		if 'A' <= ct && ct <= 'Z' {
+			ct += 'a' - 'A'
+		}
+		if cs == '\\' {
+			cs = '/'
+		}
+		if ct == '\\' {
+			ct = '/'
+		}
+		if cs != ct {
+			return false
+		}
+	}
+	return i >= len(s) || s[i] == '/' || s[i] == '\\'
+}
diff --git a/src/cmd/internal/objabi/reloctype.go b/src/cmd/internal/objabi/reloctype.go
new file mode 100644
index 0000000000..179f049de7
--- /dev/null
+++ b/src/cmd/internal/objabi/reloctype.go
@@ -0,0 +1,200 @@
+// Derived from Inferno utils/6l/l.h and related files.
+// https://bitbucket.org/inferno-os/inferno-os/src/default/utils/6l/l.h
+//
+//	Copyright  1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright  1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright  1997-1999 Vita Nuova Limited
+//	Portions Copyright  2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright  2004,2006 Bruce Ellis
+//	Portions Copyright  2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright  2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright  2009 The Go Authors. All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+package objabi
+
+type RelocType int32
+
+//go:generate stringer -type=RelocType
+const (
+	R_ADDR RelocType = 1 + iota
+	// R_ADDRPOWER relocates a pair of "D-form" instructions (instructions with 16-bit
+	// immediates in the low half of the instruction word), usually addis followed by
+	// another add or a load, inserting the "high adjusted" 16 bits of the address of
+	// the referenced symbol into the immediate field of the first instruction and the
+	// low 16 bits into that of the second instruction.
+	R_ADDRPOWER
+	// R_ADDRARM64 relocates an adrp, add pair to compute the address of the
+	// referenced symbol.
+	R_ADDRARM64
+	// R_ADDRMIPS (only used on mips/mips64) resolves to the low 16 bits of an external
+	// address, by encoding it into the instruction.
+	R_ADDRMIPS
+	// R_ADDROFF resolves to a 32-bit offset from the beginning of the section
+	// holding the data being relocated to the referenced symbol.
+	R_ADDROFF
+	// R_WEAKADDROFF resolves just like R_ADDROFF but is a weak relocation.
+	// A weak relocation does not make the symbol it refers to reachable,
+	// and is only honored by the linker if the symbol is in some other way
+	// reachable.
+	R_WEAKADDROFF
+	R_SIZE
+	R_CALL
+	R_CALLARM
+	R_CALLARM64
+	R_CALLIND
+	R_CALLPOWER
+	// R_CALLMIPS (only used on mips64) resolves to non-PC-relative target address
+	// of a CALL (JAL) instruction, by encoding the address into the instruction.
+	R_CALLMIPS
+	R_CONST
+	R_PCREL
+	// R_TLS_LE, used on 386, amd64, and ARM, resolves to the offset of the
+	// thread-local symbol from the thread local base and is used to implement the
+	// "local exec" model for tls access (r.Sym is not set on intel platforms but is
+	// set to a TLS symbol -- runtime.tlsg -- in the linker when externally linking).
+	R_TLS_LE
+	// R_TLS_IE, used 386, amd64, and ARM resolves to the PC-relative offset to a GOT
+	// slot containing the offset from the thread-local symbol from the thread local
+	// base and is used to implemented the "initial exec" model for tls access (r.Sym
+	// is not set on intel platforms but is set to a TLS symbol -- runtime.tlsg -- in
+	// the linker when externally linking).
+	R_TLS_IE
+	R_GOTOFF
+	R_PLT0
+	R_PLT1
+	R_PLT2
+	R_USEFIELD
+	// R_USETYPE resolves to an *rtype, but no relocation is created. The
+	// linker uses this as a signal that the pointed-to type information
+	// should be linked into the final binary, even if there are no other
+	// direct references. (This is used for types reachable by reflection.)
+	R_USETYPE
+	// R_METHODOFF resolves to a 32-bit offset from the beginning of the section
+	// holding the data being relocated to the referenced symbol.
+	// It is a variant of R_ADDROFF used when linking from the uncommonType of a
+	// *rtype, and may be set to zero by the linker if it determines the method
+	// text is unreachable by the linked program.
+	R_METHODOFF
+	R_POWER_TOC
+	R_GOTPCREL
+	// R_JMPMIPS (only used on mips64) resolves to non-PC-relative target address
+	// of a JMP instruction, by encoding the address into the instruction.
+	// The stack nosplit check ignores this since it is not a function call.
+	R_JMPMIPS
+	// R_DWARFREF resolves to the offset of the symbol from its section.
+	R_DWARFREF
+
+	// Platform dependent relocations. Architectures with fixed width instructions
+	// have the inherent issue that a 32-bit (or 64-bit!) displacement cannot be
+	// stuffed into a 32-bit instruction, so an address needs to be spread across
+	// several instructions, and in turn this requires a sequence of relocations, each
+	// updating a part of an instruction. This leads to relocation codes that are
+	// inherently processor specific.
+
+	// Arm64.
+
+	// Set a MOV[NZ] immediate field to bits [15:0] of the offset from the thread
+	// local base to the thread local variable defined by the referenced (thread
+	// local) symbol. Error if the offset does not fit into 16 bits.
+	R_ARM64_TLS_LE
+
+	// Relocates an ADRP; LD64 instruction sequence to load the offset between
+	// the thread local base and the thread local variable defined by the
+	// referenced (thread local) symbol from the GOT.
+	R_ARM64_TLS_IE
+
+	// R_ARM64_GOTPCREL relocates an adrp, ld64 pair to compute the address of the GOT
+	// slot of the referenced symbol.
+	R_ARM64_GOTPCREL
+
+	// PPC64.
+
+	// R_POWER_TLS_LE is used to implement the "local exec" model for tls
+	// access. It resolves to the offset of the thread-local symbol from the
+	// thread pointer (R13) and inserts this value into the low 16 bits of an
+	// instruction word.
+	R_POWER_TLS_LE
+
+	// R_POWER_TLS_IE is used to implement the "initial exec" model for tls access. It
+	// relocates a D-form, DS-form instruction sequence like R_ADDRPOWER_DS. It
+	// inserts to the offset of GOT slot for the thread-local symbol from the TOC (the
+	// GOT slot is filled by the dynamic linker with the offset of the thread-local
+	// symbol from the thread pointer (R13)).
+	R_POWER_TLS_IE
+
+	// R_POWER_TLS marks an X-form instruction such as "MOVD 0(R13)(R31*1), g" as
+	// accessing a particular thread-local symbol. It does not affect code generation
+	// but is used by the system linker when relaxing "initial exec" model code to
+	// "local exec" model code.
+	R_POWER_TLS
+
+	// R_ADDRPOWER_DS is similar to R_ADDRPOWER above, but assumes the second
+	// instruction is a "DS-form" instruction, which has an immediate field occupying
+	// bits [15:2] of the instruction word. Bits [15:2] of the address of the
+	// relocated symbol are inserted into this field; it is an error if the last two
+	// bits of the address are not 0.
+	R_ADDRPOWER_DS
+
+	// R_ADDRPOWER_PCREL relocates a D-form, DS-form instruction sequence like
+	// R_ADDRPOWER_DS but inserts the offset of the GOT slot for the referenced symbol
+	// from the TOC rather than the symbol's address.
+	R_ADDRPOWER_GOT
+
+	// R_ADDRPOWER_PCREL relocates two D-form instructions like R_ADDRPOWER, but
+	// inserts the displacement from the place being relocated to the address of the
+	// the relocated symbol instead of just its address.
+	R_ADDRPOWER_PCREL
+
+	// R_ADDRPOWER_TOCREL relocates two D-form instructions like R_ADDRPOWER, but
+	// inserts the offset from the TOC to the address of the relocated symbol
+	// rather than the symbol's address.
+	R_ADDRPOWER_TOCREL
+
+	// R_ADDRPOWER_TOCREL relocates a D-form, DS-form instruction sequence like
+	// R_ADDRPOWER_DS but inserts the offset from the TOC to the address of the the
+	// relocated symbol rather than the symbol's address.
+	R_ADDRPOWER_TOCREL_DS
+
+	// R_PCRELDBL relocates s390x 2-byte aligned PC-relative addresses.
+	// TODO(mundaym): remove once variants can be serialized - see issue 14218.
+	R_PCRELDBL
+
+	// R_ADDRMIPSU (only used on mips/mips64) resolves to the sign-adjusted "upper" 16
+	// bits (bit 16-31) of an external address, by encoding it into the instruction.
+	R_ADDRMIPSU
+	// R_ADDRMIPSTLS (only used on mips64) resolves to the low 16 bits of a TLS
+	// address (offset from thread pointer), by encoding it into the instruction.
+	R_ADDRMIPSTLS
+)
+
+// IsDirectJump returns whether r is a relocation for a direct jump.
+// A direct jump is a CALL or JMP instruction that takes the target address
+// as immediate. The address is embedded into the instruction, possibly
+// with limited width.
+// An indirect jump is a CALL or JMP instruction that takes the target address
+// in register or memory.
+func (r RelocType) IsDirectJump() bool {
+	switch r {
+	case R_CALL, R_CALLARM, R_CALLARM64, R_CALLPOWER, R_CALLMIPS, R_JMPMIPS:
+		return true
+	}
+	return false
+}
diff --git a/src/cmd/internal/obj/reloctype_string.go b/src/cmd/internal/objabi/reloctype_string.go
similarity index 92%
rename from src/cmd/internal/obj/reloctype_string.go
rename to src/cmd/internal/objabi/reloctype_string.go
index 09c1312df5..182d03f78c 100644
--- a/src/cmd/internal/obj/reloctype_string.go
+++ b/src/cmd/internal/objabi/reloctype_string.go
@@ -1,6 +1,6 @@
-// Code generated by "stringer -type=RelocType"; DO NOT EDIT
+// Code generated by "stringer -type=RelocType"; DO NOT EDIT.
 
-package obj
+package objabi
 
 import "fmt"
 
diff --git a/src/cmd/internal/obj/stack.go b/src/cmd/internal/objabi/stack.go
similarity index 86%
rename from src/cmd/internal/obj/stack.go
rename to src/cmd/internal/objabi/stack.go
index 687adf20f3..11433932e2 100644
--- a/src/cmd/internal/obj/stack.go
+++ b/src/cmd/internal/objabi/stack.go
@@ -2,10 +2,9 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package obj
+package objabi
 
 // For the linkers. Must match Go definitions.
-// TODO(rsc): Share Go definitions with linkers directly.
 
 const (
 	STACKSYSTEM = 0
diff --git a/src/cmd/internal/objabi/symkind.go b/src/cmd/internal/objabi/symkind.go
new file mode 100644
index 0000000000..c1e88aabe1
--- /dev/null
+++ b/src/cmd/internal/objabi/symkind.go
@@ -0,0 +1,137 @@
+// Derived from Inferno utils/6l/l.h and related files.
+// https://bitbucket.org/inferno-os/inferno-os/src/default/utils/6l/l.h
+//
+//	Copyright  1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright  1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright  1997-1999 Vita Nuova Limited
+//	Portions Copyright  2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright  2004,2006 Bruce Ellis
+//	Portions Copyright  2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright  2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright  2009 The Go Authors. All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+package objabi
+
+// A SymKind describes the kind of memory represented by a symbol.
+type SymKind int16
+
+// Defined SymKind values.
+//
+// TODO(rsc): Give idiomatic Go names.
+// TODO(rsc): Reduce the number of symbol types in the object files.
+//go:generate stringer -type=SymKind
+const (
+	Sxxx SymKind = iota
+	STEXT
+	SELFRXSECT
+
+	// Read-only sections.
+	STYPE
+	SSTRING
+	SGOSTRING
+	SGOFUNC
+	SGCBITS
+	SRODATA
+	SFUNCTAB
+
+	SELFROSECT
+	SMACHOPLT
+
+	// Read-only sections with relocations.
+	//
+	// Types STYPE-SFUNCTAB above are written to the .rodata section by default.
+	// When linking a shared object, some conceptually "read only" types need to
+	// be written to by relocations and putting them in a section called
+	// ".rodata" interacts poorly with the system linkers. The GNU linkers
+	// support this situation by arranging for sections of the name
+	// ".data.rel.ro.XXX" to be mprotected read only by the dynamic linker after
+	// relocations have applied, so when the Go linker is creating a shared
+	// object it checks all objects of the above types and bumps any object that
+	// has a relocation to it to the corresponding type below, which are then
+	// written to sections with appropriate magic names.
+	STYPERELRO
+	SSTRINGRELRO
+	SGOSTRINGRELRO
+	SGOFUNCRELRO
+	SGCBITSRELRO
+	SRODATARELRO
+	SFUNCTABRELRO
+
+	// Part of .data.rel.ro if it exists, otherwise part of .rodata.
+	STYPELINK
+	SITABLINK
+	SSYMTAB
+	SPCLNTAB
+
+	// Writable sections.
+	SELFSECT
+	SMACHO
+	SMACHOGOT
+	SWINDOWS
+	SELFGOT
+	SNOPTRDATA
+	SINITARR
+	SDATA
+	SBSS
+	SNOPTRBSS
+	STLSBSS
+	SXREF
+	SMACHOSYMSTR
+	SMACHOSYMTAB
+	SMACHOINDIRECTPLT
+	SMACHOINDIRECTGOT
+	SFILE
+	SFILEPATH
+	SCONST
+	SDYNIMPORT
+	SHOSTOBJ
+	SDWARFSECT
+	SDWARFINFO
+	SSUB       = SymKind(1 << 8)
+	SMASK      = SymKind(SSUB - 1)
+	SHIDDEN    = SymKind(1 << 9)
+	SCONTAINER = SymKind(1 << 10) // has a sub-symbol
+)
+
+// ReadOnly are the symbol kinds that form read-only sections. In some
+// cases, if they will require relocations, they are transformed into
+// rel-ro sections using RelROMap.
+var ReadOnly = []SymKind{
+	STYPE,
+	SSTRING,
+	SGOSTRING,
+	SGOFUNC,
+	SGCBITS,
+	SRODATA,
+	SFUNCTAB,
+}
+
+// RelROMap describes the transformation of read-only symbols to rel-ro
+// symbols.
+var RelROMap = map[SymKind]SymKind{
+	STYPE:     STYPERELRO,
+	SSTRING:   SSTRINGRELRO,
+	SGOSTRING: SGOSTRINGRELRO,
+	SGOFUNC:   SGOFUNCRELRO,
+	SGCBITS:   SGCBITSRELRO,
+	SRODATA:   SRODATARELRO,
+	SFUNCTAB:  SFUNCTABRELRO,
+}
diff --git a/src/cmd/internal/obj/symkind_string.go b/src/cmd/internal/objabi/symkind_string.go
similarity index 92%
rename from src/cmd/internal/obj/symkind_string.go
rename to src/cmd/internal/objabi/symkind_string.go
index fef8c355e4..d89876093d 100644
--- a/src/cmd/internal/obj/symkind_string.go
+++ b/src/cmd/internal/objabi/symkind_string.go
@@ -1,6 +1,6 @@
-// Code generated by "stringer -type=SymKind"; DO NOT EDIT
+// Code generated by "stringer -type=SymKind"; DO NOT EDIT.
 
-package obj
+package objabi
 
 import "fmt"
 
diff --git a/src/cmd/internal/obj/typekind.go b/src/cmd/internal/objabi/typekind.go
similarity index 97%
rename from src/cmd/internal/obj/typekind.go
rename to src/cmd/internal/objabi/typekind.go
index 2193271678..f0e6f472e5 100644
--- a/src/cmd/internal/obj/typekind.go
+++ b/src/cmd/internal/objabi/typekind.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package obj
+package objabi
 
 // Must match runtime and reflect.
 // Included by cmd/gc.
diff --git a/src/cmd/internal/objabi/util.go b/src/cmd/internal/objabi/util.go
new file mode 100644
index 0000000000..d00edf2a8c
--- /dev/null
+++ b/src/cmd/internal/objabi/util.go
@@ -0,0 +1,112 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package objabi
+
+import (
+	"fmt"
+	"log"
+	"os"
+	"strings"
+)
+
+func envOr(key, value string) string {
+	if x := os.Getenv(key); x != "" {
+		return x
+	}
+	return value
+}
+
+var (
+	GOROOT  = envOr("GOROOT", defaultGOROOT)
+	GOARCH  = envOr("GOARCH", defaultGOARCH)
+	GOOS    = envOr("GOOS", defaultGOOS)
+	GO386   = envOr("GO386", defaultGO386)
+	GOARM   = goarm()
+	Version = version
+)
+
+func goarm() int {
+	switch v := envOr("GOARM", defaultGOARM); v {
+	case "5":
+		return 5
+	case "6":
+		return 6
+	case "7":
+		return 7
+	}
+	// Fail here, rather than validate at multiple call sites.
+	log.Fatalf("Invalid GOARM value. Must be 5, 6, or 7.")
+	panic("unreachable")
+}
+
+func Getgoextlinkenabled() string {
+	return envOr("GO_EXTLINK_ENABLED", defaultGO_EXTLINK_ENABLED)
+}
+
+func init() {
+	framepointer_enabled = 1 // default
+	for _, f := range strings.Split(goexperiment, ",") {
+		if f != "" {
+			addexp(f)
+		}
+	}
+}
+
+func Framepointer_enabled(goos, goarch string) bool {
+	return framepointer_enabled != 0 && goarch == "amd64" && goos != "nacl"
+}
+
+func addexp(s string) {
+	// Could do general integer parsing here, but the runtime copy doesn't yet.
+	v := 1
+	name := s
+	if len(name) > 2 && name[:2] == "no" {
+		v = 0
+		name = name[2:]
+	}
+	for i := 0; i < len(exper); i++ {
+		if exper[i].name == name {
+			if exper[i].val != nil {
+				*exper[i].val = v
+			}
+			return
+		}
+	}
+
+	fmt.Printf("unknown experiment %s\n", s)
+	os.Exit(2)
+}
+
+var (
+	framepointer_enabled     int
+	Fieldtrack_enabled       int
+	Preemptibleloops_enabled int
+)
+
+// Toolchain experiments.
+// These are controlled by the GOEXPERIMENT environment
+// variable recorded when the toolchain is built.
+// This list is also known to cmd/gc.
+var exper = []struct {
+	name string
+	val  *int
+}{
+	{"fieldtrack", &Fieldtrack_enabled},
+	{"framepointer", &framepointer_enabled},
+	{"preemptibleloops", &Preemptibleloops_enabled},
+}
+
+func Expstring() string {
+	buf := "X"
+	for i := range exper {
+		if *exper[i].val != 0 {
+			buf += "," + exper[i].name
+		}
+	}
+	if buf == "X" {
+		buf += ",none"
+	}
+	return "X:" + buf[2:]
+}
diff --git a/src/cmd/internal/objfile/goobj.go b/src/cmd/internal/objfile/goobj.go
index c04987cc82..847861d822 100644
--- a/src/cmd/internal/objfile/goobj.go
+++ b/src/cmd/internal/objfile/goobj.go
@@ -8,6 +8,7 @@ package objfile
 
 import (
 	"cmd/internal/goobj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"debug/dwarf"
 	"debug/gosym"
@@ -44,15 +45,15 @@ func (f *goobjFile) symbols() ([]Sym, error) {
 		seen[s.SymID] = true
 		sym := Sym{Addr: uint64(s.Data.Offset), Name: goobjName(s.SymID), Size: int64(s.Size), Type: s.Type.Name, Code: '?'}
 		switch s.Kind {
-		case goobj.STEXT, goobj.SELFRXSECT:
+		case objabi.STEXT, objabi.SELFRXSECT:
 			sym.Code = 'T'
-		case goobj.STYPE, goobj.SSTRING, goobj.SGOSTRING, goobj.SGOFUNC, goobj.SRODATA, goobj.SFUNCTAB, goobj.STYPELINK, goobj.SITABLINK, goobj.SSYMTAB, goobj.SPCLNTAB, goobj.SELFROSECT:
+		case objabi.STYPE, objabi.SSTRING, objabi.SGOSTRING, objabi.SGOFUNC, objabi.SRODATA, objabi.SFUNCTAB, objabi.STYPELINK, objabi.SITABLINK, objabi.SSYMTAB, objabi.SPCLNTAB, objabi.SELFROSECT:
 			sym.Code = 'R'
-		case goobj.SMACHOPLT, goobj.SELFSECT, goobj.SMACHO, goobj.SMACHOGOT, goobj.SNOPTRDATA, goobj.SINITARR, goobj.SDATA, goobj.SWINDOWS:
+		case objabi.SMACHOPLT, objabi.SELFSECT, objabi.SMACHO, objabi.SMACHOGOT, objabi.SNOPTRDATA, objabi.SINITARR, objabi.SDATA, objabi.SWINDOWS:
 			sym.Code = 'D'
-		case goobj.SBSS, goobj.SNOPTRBSS, goobj.STLSBSS:
+		case objabi.SBSS, objabi.SNOPTRBSS, objabi.STLSBSS:
 			sym.Code = 'B'
-		case goobj.SXREF, goobj.SMACHOSYMSTR, goobj.SMACHOSYMTAB, goobj.SMACHOINDIRECTPLT, goobj.SMACHOINDIRECTGOT, goobj.SFILE, goobj.SFILEPATH, goobj.SCONST, goobj.SDYNIMPORT, goobj.SHOSTOBJ:
+		case objabi.SXREF, objabi.SMACHOSYMSTR, objabi.SMACHOSYMTAB, objabi.SMACHOINDIRECTPLT, objabi.SMACHOINDIRECTGOT, objabi.SFILE, objabi.SFILEPATH, objabi.SCONST, objabi.SDYNIMPORT, objabi.SHOSTOBJ:
 			sym.Code = 'X' // should not see
 		}
 		if s.Version != 0 {
diff --git a/src/cmd/link/internal/amd64/asm.go b/src/cmd/link/internal/amd64/asm.go
index af3d6e7b13..cc2cebc0c1 100644
--- a/src/cmd/link/internal/amd64/asm.go
+++ b/src/cmd/link/internal/amd64/asm.go
@@ -31,7 +31,7 @@
 package amd64
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/link/internal/ld"
 	"debug/elf"
 	"log"
@@ -49,7 +49,7 @@ func Addcall(ctxt *ld.Link, s *ld.Symbol, t *ld.Symbol) int64 {
 	r := ld.Addrel(s)
 	r.Sym = t
 	r.Off = int32(i)
-	r.Type = obj.R_CALL
+	r.Type = objabi.R_CALL
 	r.Siz = 4
 	return i + int64(r.Siz)
 }
@@ -59,14 +59,14 @@ func gentext(ctxt *ld.Link) {
 		return
 	}
 	addmoduledata := ctxt.Syms.Lookup("runtime.addmoduledata", 0)
-	if addmoduledata.Type == obj.STEXT && ld.Buildmode != ld.BuildmodePlugin {
+	if addmoduledata.Type == objabi.STEXT && ld.Buildmode != ld.BuildmodePlugin {
 		// we're linking a module containing the runtime -> no need for
 		// an init function
 		return
 	}
 	addmoduledata.Attr |= ld.AttrReachable
 	initfunc := ctxt.Syms.Lookup("go.link.addmoduledata", 0)
-	initfunc.Type = obj.STEXT
+	initfunc.Type = objabi.STEXT
 	initfunc.Attr |= ld.AttrLocal
 	initfunc.Attr |= ld.AttrReachable
 	o := func(op ...uint8) {
@@ -92,7 +92,7 @@ func gentext(ctxt *ld.Link) {
 	initarray_entry := ctxt.Syms.Lookup("go.link.addmoduledatainit", 0)
 	initarray_entry.Attr |= ld.AttrReachable
 	initarray_entry.Attr |= ld.AttrLocal
-	initarray_entry.Type = obj.SINITARR
+	initarray_entry.Type = objabi.SINITARR
 	ld.Addaddr(ctxt, initarray_entry, initfunc)
 }
 
@@ -108,20 +108,20 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 
 		// Handle relocations found in ELF object files.
 	case 256 + ld.R_X86_64_PC32:
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			ld.Errorf(s, "unexpected R_X86_64_PC32 relocation for dynamic symbol %s", targ.Name)
 		}
-		if targ.Type == 0 || targ.Type == obj.SXREF {
+		if targ.Type == 0 || targ.Type == objabi.SXREF {
 			ld.Errorf(s, "unknown symbol %s in pcrel", targ.Name)
 		}
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Add += 4
 		return true
 
 	case 256 + ld.R_X86_64_PLT32:
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Add += 4
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			addpltsym(ctxt, targ)
 			r.Sym = ctxt.Syms.Lookup(".plt", 0)
 			r.Add += int64(targ.Plt)
@@ -130,13 +130,13 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 		return true
 
 	case 256 + ld.R_X86_64_GOTPCREL, 256 + ld.R_X86_64_GOTPCRELX, 256 + ld.R_X86_64_REX_GOTPCRELX:
-		if targ.Type != obj.SDYNIMPORT {
+		if targ.Type != objabi.SDYNIMPORT {
 			// have symbol
 			if r.Off >= 2 && s.P[r.Off-2] == 0x8b {
 				// turn MOVQ of GOT entry into LEAQ of symbol itself
 				s.P[r.Off-2] = 0x8d
 
-				r.Type = obj.R_PCREL
+				r.Type = objabi.R_PCREL
 				r.Add += 4
 				return true
 			}
@@ -146,17 +146,17 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 		// TODO: just needs relocation, no need to put in .dynsym
 		addgotsym(ctxt, targ)
 
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Sym = ctxt.Syms.Lookup(".got", 0)
 		r.Add += 4
 		r.Add += int64(targ.Got)
 		return true
 
 	case 256 + ld.R_X86_64_64:
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			ld.Errorf(s, "unexpected R_X86_64_64 relocation for dynamic symbol %s", targ.Name)
 		}
-		r.Type = obj.R_ADDR
+		r.Type = objabi.R_ADDR
 		return true
 
 	// Handle relocations found in Mach-O object files.
@@ -164,19 +164,19 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 		512 + ld.MACHO_X86_64_RELOC_SIGNED*2 + 0,
 		512 + ld.MACHO_X86_64_RELOC_BRANCH*2 + 0:
 		// TODO: What is the difference between all these?
-		r.Type = obj.R_ADDR
+		r.Type = objabi.R_ADDR
 
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			ld.Errorf(s, "unexpected reloc for dynamic symbol %s", targ.Name)
 		}
 		return true
 
 	case 512 + ld.MACHO_X86_64_RELOC_BRANCH*2 + 1:
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			addpltsym(ctxt, targ)
 			r.Sym = ctxt.Syms.Lookup(".plt", 0)
 			r.Add = int64(targ.Plt)
-			r.Type = obj.R_PCREL
+			r.Type = objabi.R_PCREL
 			return true
 		}
 		fallthrough
@@ -187,15 +187,15 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 		512 + ld.MACHO_X86_64_RELOC_SIGNED_1*2 + 1,
 		512 + ld.MACHO_X86_64_RELOC_SIGNED_2*2 + 1,
 		512 + ld.MACHO_X86_64_RELOC_SIGNED_4*2 + 1:
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			ld.Errorf(s, "unexpected pc-relative reloc for dynamic symbol %s", targ.Name)
 		}
 		return true
 
 	case 512 + ld.MACHO_X86_64_RELOC_GOT_LOAD*2 + 1:
-		if targ.Type != obj.SDYNIMPORT {
+		if targ.Type != objabi.SDYNIMPORT {
 			// have symbol
 			// turn MOVQ of GOT entry into LEAQ of symbol itself
 			if r.Off < 2 || s.P[r.Off-2] != 0x8b {
@@ -204,31 +204,31 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 			}
 
 			s.P[r.Off-2] = 0x8d
-			r.Type = obj.R_PCREL
+			r.Type = objabi.R_PCREL
 			return true
 		}
 		fallthrough
 
 		// fall through
 	case 512 + ld.MACHO_X86_64_RELOC_GOT*2 + 1:
-		if targ.Type != obj.SDYNIMPORT {
+		if targ.Type != objabi.SDYNIMPORT {
 			ld.Errorf(s, "unexpected GOT reloc for non-dynamic symbol %s", targ.Name)
 		}
 		addgotsym(ctxt, targ)
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Sym = ctxt.Syms.Lookup(".got", 0)
 		r.Add += int64(targ.Got)
 		return true
 	}
 
 	switch r.Type {
-	case obj.R_CALL,
-		obj.R_PCREL:
-		if targ.Type != obj.SDYNIMPORT {
+	case objabi.R_CALL,
+		objabi.R_PCREL:
+		if targ.Type != objabi.SDYNIMPORT {
 			// nothing to do, the relocation will be laid out in reloc
 			return true
 		}
-		if ld.Headtype == obj.Hwindows {
+		if ld.Headtype == objabi.Hwindows {
 			// nothing to do, the relocation will be laid out in pereloc1
 			return true
 		} else {
@@ -239,9 +239,9 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 			return true
 		}
 
-	case obj.R_ADDR:
-		if s.Type == obj.STEXT && ld.Iself {
-			if ld.Headtype == obj.Hsolaris {
+	case objabi.R_ADDR:
+		if s.Type == objabi.STEXT && ld.Iself {
+			if ld.Headtype == objabi.Hsolaris {
 				addpltsym(ctxt, targ)
 				r.Sym = ctxt.Syms.Lookup(".plt", 0)
 				r.Add += int64(targ.Plt)
@@ -294,7 +294,7 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 			// linking, in which case the relocation will be
 			// prepared in the 'reloc' phase and passed to the
 			// external linker in the 'asmb' phase.
-			if s.Type != obj.SDATA && s.Type != obj.SRODATA {
+			if s.Type != objabi.SDATA && s.Type != objabi.SRODATA {
 				break
 			}
 		}
@@ -317,7 +317,7 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 			return true
 		}
 
-		if ld.Headtype == obj.Hdarwin && s.Size == int64(ld.SysArch.PtrSize) && r.Off == 0 {
+		if ld.Headtype == objabi.Hdarwin && s.Size == int64(ld.SysArch.PtrSize) && r.Off == 0 {
 			// Mach-O relocations are a royal pain to lay out.
 			// They use a compact stateful bytecode representation
 			// that is too much bother to deal with.
@@ -331,7 +331,7 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 			ld.Adddynsym(ctxt, targ)
 
 			got := ctxt.Syms.Lookup(".got", 0)
-			s.Type = got.Type | obj.SSUB
+			s.Type = got.Type | objabi.SSUB
 			s.Outer = got
 			s.Sub = got.Sub
 			got.Sub = s
@@ -342,7 +342,7 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 			return true
 		}
 
-		if ld.Headtype == obj.Hwindows {
+		if ld.Headtype == objabi.Hwindows {
 			// nothing to do, the relocation will be laid out in pereloc1
 			return true
 		}
@@ -359,7 +359,7 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 	default:
 		return -1
 
-	case obj.R_ADDR:
+	case objabi.R_ADDR:
 		if r.Siz == 4 {
 			ld.Thearch.Vput(ld.R_X86_64_32 | uint64(elfsym)<<32)
 		} else if r.Siz == 8 {
@@ -368,23 +368,23 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 			return -1
 		}
 
-	case obj.R_TLS_LE:
+	case objabi.R_TLS_LE:
 		if r.Siz == 4 {
 			ld.Thearch.Vput(ld.R_X86_64_TPOFF32 | uint64(elfsym)<<32)
 		} else {
 			return -1
 		}
 
-	case obj.R_TLS_IE:
+	case objabi.R_TLS_IE:
 		if r.Siz == 4 {
 			ld.Thearch.Vput(ld.R_X86_64_GOTTPOFF | uint64(elfsym)<<32)
 		} else {
 			return -1
 		}
 
-	case obj.R_CALL:
+	case objabi.R_CALL:
 		if r.Siz == 4 {
-			if r.Xsym.Type == obj.SDYNIMPORT {
+			if r.Xsym.Type == objabi.SDYNIMPORT {
 				if ctxt.DynlinkingGo() {
 					ld.Thearch.Vput(ld.R_X86_64_PLT32 | uint64(elfsym)<<32)
 				} else {
@@ -397,9 +397,9 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 			return -1
 		}
 
-	case obj.R_PCREL:
+	case objabi.R_PCREL:
 		if r.Siz == 4 {
-			if r.Xsym.Type == obj.SDYNIMPORT && r.Xsym.ElfType == elf.STT_FUNC {
+			if r.Xsym.Type == objabi.SDYNIMPORT && r.Xsym.ElfType == elf.STT_FUNC {
 				ld.Thearch.Vput(ld.R_X86_64_PLT32 | uint64(elfsym)<<32)
 			} else {
 				ld.Thearch.Vput(ld.R_X86_64_PC32 | uint64(elfsym)<<32)
@@ -408,7 +408,7 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 			return -1
 		}
 
-	case obj.R_GOTPCREL:
+	case objabi.R_GOTPCREL:
 		if r.Siz == 4 {
 			ld.Thearch.Vput(ld.R_X86_64_GOTPCREL | uint64(elfsym)<<32)
 		} else {
@@ -425,7 +425,7 @@ func machoreloc1(s *ld.Symbol, r *ld.Reloc, sectoff int64) int {
 
 	rs := r.Xsym
 
-	if rs.Type == obj.SHOSTOBJ || r.Type == obj.R_PCREL || r.Type == obj.R_GOTPCREL {
+	if rs.Type == objabi.SHOSTOBJ || r.Type == objabi.R_PCREL || r.Type == objabi.R_GOTPCREL {
 		if rs.Dynid < 0 {
 			ld.Errorf(s, "reloc %d to non-macho symbol %s type=%d", r.Type, rs.Name, rs.Type)
 			return -1
@@ -445,18 +445,18 @@ func machoreloc1(s *ld.Symbol, r *ld.Reloc, sectoff int64) int {
 	default:
 		return -1
 
-	case obj.R_ADDR:
+	case objabi.R_ADDR:
 		v |= ld.MACHO_X86_64_RELOC_UNSIGNED << 28
 
-	case obj.R_CALL:
+	case objabi.R_CALL:
 		v |= 1 << 24 // pc-relative bit
 		v |= ld.MACHO_X86_64_RELOC_BRANCH << 28
 
 		// NOTE: Only works with 'external' relocation. Forced above.
-	case obj.R_PCREL:
+	case objabi.R_PCREL:
 		v |= 1 << 24 // pc-relative bit
 		v |= ld.MACHO_X86_64_RELOC_SIGNED << 28
-	case obj.R_GOTPCREL:
+	case objabi.R_GOTPCREL:
 		v |= 1 << 24 // pc-relative bit
 		v |= ld.MACHO_X86_64_RELOC_GOT_LOAD << 28
 	}
@@ -500,18 +500,18 @@ func pereloc1(s *ld.Symbol, r *ld.Reloc, sectoff int64) bool {
 	default:
 		return false
 
-	case obj.R_DWARFREF:
+	case objabi.R_DWARFREF:
 		v = ld.IMAGE_REL_AMD64_SECREL
 
-	case obj.R_ADDR:
+	case objabi.R_ADDR:
 		if r.Siz == 8 {
 			v = ld.IMAGE_REL_AMD64_ADDR64
 		} else {
 			v = ld.IMAGE_REL_AMD64_ADDR32
 		}
 
-	case obj.R_CALL,
-		obj.R_PCREL:
+	case objabi.R_CALL,
+		objabi.R_PCREL:
 		v = ld.IMAGE_REL_AMD64_REL32
 	}
 
@@ -597,7 +597,7 @@ func addpltsym(ctxt *ld.Link, s *ld.Symbol) {
 		ld.Adduint64(ctxt, rela, 0)
 
 		s.Plt = int32(plt.Size - 16)
-	} else if ld.Headtype == obj.Hdarwin {
+	} else if ld.Headtype == objabi.Hdarwin {
 		// To do lazy symbol lookup right, we're supposed
 		// to tell the dynamic loader which library each
 		// symbol comes from and format the link info
@@ -639,7 +639,7 @@ func addgotsym(ctxt *ld.Link, s *ld.Symbol) {
 		ld.Addaddrplus(ctxt, rela, got, int64(s.Got))
 		ld.Adduint64(ctxt, rela, ld.ELF64_R_INFO(uint32(s.Dynid), ld.R_X86_64_GLOB_DAT))
 		ld.Adduint64(ctxt, rela, 0)
-	} else if ld.Headtype == obj.Hdarwin {
+	} else if ld.Headtype == objabi.Hdarwin {
 		ld.Adduint32(ctxt, ctxt.Syms.Lookup(".linkedit.got", 0), uint32(s.Dynid))
 	} else {
 		ld.Errorf(s, "addgotsym: unsupported binary format")
@@ -648,11 +648,11 @@ func addgotsym(ctxt *ld.Link, s *ld.Symbol) {
 
 func asmb(ctxt *ld.Link) {
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f asmb\n", obj.Cputime())
+		ctxt.Logf("%5.2f asmb\n", ld.Cputime())
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f codeblk\n", obj.Cputime())
+		ctxt.Logf("%5.2f codeblk\n", ld.Cputime())
 	}
 
 	if ld.Iself {
@@ -670,21 +670,21 @@ func asmb(ctxt *ld.Link) {
 
 	if ld.Segrodata.Filelen > 0 {
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f rodatblk\n", obj.Cputime())
+			ctxt.Logf("%5.2f rodatblk\n", ld.Cputime())
 		}
 		ld.Cseek(int64(ld.Segrodata.Fileoff))
 		ld.Datblk(ctxt, int64(ld.Segrodata.Vaddr), int64(ld.Segrodata.Filelen))
 	}
 	if ld.Segrelrodata.Filelen > 0 {
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f relrodatblk\n", obj.Cputime())
+			ctxt.Logf("%5.2f relrodatblk\n", ld.Cputime())
 		}
 		ld.Cseek(int64(ld.Segrelrodata.Fileoff))
 		ld.Datblk(ctxt, int64(ld.Segrelrodata.Vaddr), int64(ld.Segrelrodata.Filelen))
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f datblk\n", obj.Cputime())
+		ctxt.Logf("%5.2f datblk\n", ld.Cputime())
 	}
 
 	ld.Cseek(int64(ld.Segdata.Fileoff))
@@ -694,7 +694,7 @@ func asmb(ctxt *ld.Link) {
 	ld.Dwarfblk(ctxt, int64(ld.Segdwarf.Vaddr), int64(ld.Segdwarf.Filelen))
 
 	machlink := int64(0)
-	if ld.Headtype == obj.Hdarwin {
+	if ld.Headtype == objabi.Hdarwin {
 		machlink = ld.Domacholink(ctxt)
 	}
 
@@ -703,22 +703,22 @@ func asmb(ctxt *ld.Link) {
 		ld.Errorf(nil, "unknown header type %v", ld.Headtype)
 		fallthrough
 
-	case obj.Hplan9:
+	case objabi.Hplan9:
 		break
 
-	case obj.Hdarwin:
+	case objabi.Hdarwin:
 		ld.Flag8 = true /* 64-bit addresses */
 
-	case obj.Hlinux,
-		obj.Hfreebsd,
-		obj.Hnetbsd,
-		obj.Hopenbsd,
-		obj.Hdragonfly,
-		obj.Hsolaris:
+	case objabi.Hlinux,
+		objabi.Hfreebsd,
+		objabi.Hnetbsd,
+		objabi.Hopenbsd,
+		objabi.Hdragonfly,
+		objabi.Hsolaris:
 		ld.Flag8 = true /* 64-bit addresses */
 
-	case obj.Hnacl,
-		obj.Hwindows:
+	case objabi.Hnacl,
+		objabi.Hwindows:
 		break
 	}
 
@@ -728,28 +728,28 @@ func asmb(ctxt *ld.Link) {
 	symo := int64(0)
 	if !*ld.FlagS {
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f sym\n", obj.Cputime())
+			ctxt.Logf("%5.2f sym\n", ld.Cputime())
 		}
 		switch ld.Headtype {
 		default:
-		case obj.Hplan9:
+		case objabi.Hplan9:
 			*ld.FlagS = true
 			symo = int64(ld.Segdata.Fileoff + ld.Segdata.Filelen)
 
-		case obj.Hdarwin:
+		case objabi.Hdarwin:
 			symo = int64(ld.Segdwarf.Fileoff + uint64(ld.Rnd(int64(ld.Segdwarf.Filelen), int64(*ld.FlagRound))) + uint64(machlink))
 
-		case obj.Hlinux,
-			obj.Hfreebsd,
-			obj.Hnetbsd,
-			obj.Hopenbsd,
-			obj.Hdragonfly,
-			obj.Hsolaris,
-			obj.Hnacl:
+		case objabi.Hlinux,
+			objabi.Hfreebsd,
+			objabi.Hnetbsd,
+			objabi.Hopenbsd,
+			objabi.Hdragonfly,
+			objabi.Hsolaris,
+			objabi.Hnacl:
 			symo = int64(ld.Segdwarf.Fileoff + ld.Segdwarf.Filelen)
 			symo = ld.Rnd(symo, int64(*ld.FlagRound))
 
-		case obj.Hwindows:
+		case objabi.Hwindows:
 			symo = int64(ld.Segdwarf.Fileoff + ld.Segdwarf.Filelen)
 			symo = ld.Rnd(symo, ld.PEFILEALIGN)
 		}
@@ -764,7 +764,7 @@ func asmb(ctxt *ld.Link) {
 				ld.Cwrite(ld.Elfstrdat)
 
 				if ctxt.Debugvlog != 0 {
-					ctxt.Logf("%5.2f dwarf\n", obj.Cputime())
+					ctxt.Logf("%5.2f dwarf\n", ld.Cputime())
 				}
 
 				if ld.Linkmode == ld.LinkExternal {
@@ -772,7 +772,7 @@ func asmb(ctxt *ld.Link) {
 				}
 			}
 
-		case obj.Hplan9:
+		case objabi.Hplan9:
 			ld.Asmplan9sym(ctxt)
 			ld.Cflush()
 
@@ -786,12 +786,12 @@ func asmb(ctxt *ld.Link) {
 				ld.Cflush()
 			}
 
-		case obj.Hwindows:
+		case objabi.Hwindows:
 			if ctxt.Debugvlog != 0 {
-				ctxt.Logf("%5.2f dwarf\n", obj.Cputime())
+				ctxt.Logf("%5.2f dwarf\n", ld.Cputime())
 			}
 
-		case obj.Hdarwin:
+		case objabi.Hdarwin:
 			if ld.Linkmode == ld.LinkExternal {
 				ld.Machoemitreloc(ctxt)
 			}
@@ -799,12 +799,12 @@ func asmb(ctxt *ld.Link) {
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f headr\n", obj.Cputime())
+		ctxt.Logf("%5.2f headr\n", ld.Cputime())
 	}
 	ld.Cseek(0)
 	switch ld.Headtype {
 	default:
-	case obj.Hplan9: /* plan9 */
+	case objabi.Hplan9: /* plan9 */
 		magic := int32(4*26*26 + 7)
 
 		magic |= 0x00008000                  /* fat header */
@@ -819,19 +819,19 @@ func asmb(ctxt *ld.Link) {
 		ld.Lputb(uint32(ld.Lcsize)) /* line offsets */
 		ld.Vputb(uint64(vl))        /* va of entry */
 
-	case obj.Hdarwin:
+	case objabi.Hdarwin:
 		ld.Asmbmacho(ctxt)
 
-	case obj.Hlinux,
-		obj.Hfreebsd,
-		obj.Hnetbsd,
-		obj.Hopenbsd,
-		obj.Hdragonfly,
-		obj.Hsolaris,
-		obj.Hnacl:
+	case objabi.Hlinux,
+		objabi.Hfreebsd,
+		objabi.Hnetbsd,
+		objabi.Hopenbsd,
+		objabi.Hdragonfly,
+		objabi.Hsolaris,
+		objabi.Hnacl:
 		ld.Asmbelf(ctxt, symo)
 
-	case obj.Hwindows:
+	case objabi.Hwindows:
 		ld.Asmbpe(ctxt)
 	}
 
diff --git a/src/cmd/link/internal/amd64/obj.go b/src/cmd/link/internal/amd64/obj.go
index aa7b9cd731..ef69c269c1 100644
--- a/src/cmd/link/internal/amd64/obj.go
+++ b/src/cmd/link/internal/amd64/obj.go
@@ -31,7 +31,7 @@
 package amd64
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"cmd/link/internal/ld"
 	"fmt"
@@ -39,7 +39,7 @@ import (
 
 func Init() {
 	ld.SysArch = sys.ArchAMD64
-	if obj.GOARCH == "amd64p32" {
+	if objabi.GOARCH == "amd64p32" {
 		ld.SysArch = sys.ArchAMD64P32
 	}
 
@@ -80,7 +80,7 @@ func archinit(ctxt *ld.Link) {
 	default:
 		ld.Exitf("unknown -H option: %v", ld.Headtype)
 
-	case obj.Hplan9: /* plan 9 */
+	case objabi.Hplan9: /* plan 9 */
 		ld.HEADR = 32 + 8
 
 		if *ld.FlagTextAddr == -1 {
@@ -93,7 +93,7 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagRound = 0x200000
 		}
 
-	case obj.Hdarwin: /* apple MACH */
+	case objabi.Hdarwin: /* apple MACH */
 		ld.Machoinit()
 
 		ld.HEADR = ld.INITIAL_MACHO_HEADR
@@ -107,12 +107,12 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagDataAddr = 0
 		}
 
-	case obj.Hlinux, /* elf64 executable */
-		obj.Hfreebsd,   /* freebsd */
-		obj.Hnetbsd,    /* netbsd */
-		obj.Hopenbsd,   /* openbsd */
-		obj.Hdragonfly, /* dragonfly */
-		obj.Hsolaris:   /* solaris */
+	case objabi.Hlinux, /* elf64 executable */
+		objabi.Hfreebsd,   /* freebsd */
+		objabi.Hnetbsd,    /* netbsd */
+		objabi.Hopenbsd,   /* openbsd */
+		objabi.Hdragonfly, /* dragonfly */
+		objabi.Hsolaris:   /* solaris */
 		ld.Elfinit(ctxt)
 
 		ld.HEADR = ld.ELFRESERVE
@@ -126,7 +126,7 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagRound = 4096
 		}
 
-	case obj.Hnacl:
+	case objabi.Hnacl:
 		ld.Elfinit(ctxt)
 		*ld.FlagW = true // disable dwarf, which gets confused and is useless anyway
 		ld.HEADR = 0x10000
@@ -141,7 +141,7 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagRound = 0x10000
 		}
 
-	case obj.Hwindows: /* PE executable */
+	case objabi.Hwindows: /* PE executable */
 		// ld.HEADR, ld.FlagTextAddr, ld.FlagDataAddr and ld.FlagRound are set in ld.Peinit
 		return
 	}
diff --git a/src/cmd/link/internal/arm/asm.go b/src/cmd/link/internal/arm/asm.go
index 53811c02fd..51c2613add 100644
--- a/src/cmd/link/internal/arm/asm.go
+++ b/src/cmd/link/internal/arm/asm.go
@@ -31,7 +31,7 @@
 package arm
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/link/internal/ld"
 	"fmt"
 	"log"
@@ -63,14 +63,14 @@ func gentext(ctxt *ld.Link) {
 		return
 	}
 	addmoduledata := ctxt.Syms.Lookup("runtime.addmoduledata", 0)
-	if addmoduledata.Type == obj.STEXT && ld.Buildmode != ld.BuildmodePlugin {
+	if addmoduledata.Type == objabi.STEXT && ld.Buildmode != ld.BuildmodePlugin {
 		// we're linking a module containing the runtime -> no need for
 		// an init function
 		return
 	}
 	addmoduledata.Attr |= ld.AttrReachable
 	initfunc := ctxt.Syms.Lookup("go.link.addmoduledata", 0)
-	initfunc.Type = obj.STEXT
+	initfunc.Type = objabi.STEXT
 	initfunc.Attr |= ld.AttrLocal
 	initfunc.Attr |= ld.AttrReachable
 	o := func(op uint32) {
@@ -84,7 +84,7 @@ func gentext(ctxt *ld.Link) {
 	rel.Off = 8
 	rel.Siz = 4
 	rel.Sym = ctxt.Syms.Lookup("runtime.addmoduledata", 0)
-	rel.Type = obj.R_CALLARM
+	rel.Type = objabi.R_CALLARM
 	rel.Add = 0xeafffffe // vomit
 
 	o(0x00000000)
@@ -92,7 +92,7 @@ func gentext(ctxt *ld.Link) {
 	rel.Off = 12
 	rel.Siz = 4
 	rel.Sym = ctxt.Moduledata
-	rel.Type = obj.R_PCREL
+	rel.Type = objabi.R_PCREL
 	rel.Add = 4
 
 	if ld.Buildmode == ld.BuildmodePlugin {
@@ -102,7 +102,7 @@ func gentext(ctxt *ld.Link) {
 	initarray_entry := ctxt.Syms.Lookup("go.link.addmoduledatainit", 0)
 	initarray_entry.Attr |= ld.AttrReachable
 	initarray_entry.Attr |= ld.AttrLocal
-	initarray_entry.Type = obj.SINITARR
+	initarray_entry.Type = objabi.SINITARR
 	ld.Addaddr(ctxt, initarray_entry, initfunc)
 }
 
@@ -124,9 +124,9 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 
 		// Handle relocations found in ELF object files.
 	case 256 + ld.R_ARM_PLT32:
-		r.Type = obj.R_CALLARM
+		r.Type = objabi.R_CALLARM
 
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			addpltsym(ctxt, targ)
 			r.Sym = ctxt.Syms.Lookup(".plt", 0)
 			r.Add = int64(braddoff(int32(r.Add), targ.Plt/4))
@@ -139,44 +139,44 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 		return false
 
 	case 256 + ld.R_ARM_GOT32: // R_ARM_GOT_BREL
-		if targ.Type != obj.SDYNIMPORT {
+		if targ.Type != objabi.SDYNIMPORT {
 			addgotsyminternal(ctxt, targ)
 		} else {
 			addgotsym(ctxt, targ)
 		}
 
-		r.Type = obj.R_CONST // write r->add during relocsym
+		r.Type = objabi.R_CONST // write r->add during relocsym
 		r.Sym = nil
 		r.Add += int64(targ.Got)
 		return true
 
 	case 256 + ld.R_ARM_GOT_PREL: // GOT(nil) + A - nil
-		if targ.Type != obj.SDYNIMPORT {
+		if targ.Type != objabi.SDYNIMPORT {
 			addgotsyminternal(ctxt, targ)
 		} else {
 			addgotsym(ctxt, targ)
 		}
 
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Sym = ctxt.Syms.Lookup(".got", 0)
 		r.Add += int64(targ.Got) + 4
 		return true
 
 	case 256 + ld.R_ARM_GOTOFF: // R_ARM_GOTOFF32
-		r.Type = obj.R_GOTOFF
+		r.Type = objabi.R_GOTOFF
 
 		return true
 
 	case 256 + ld.R_ARM_GOTPC: // R_ARM_BASE_PREL
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 
 		r.Sym = ctxt.Syms.Lookup(".got", 0)
 		r.Add += 4
 		return true
 
 	case 256 + ld.R_ARM_CALL:
-		r.Type = obj.R_CALLARM
-		if targ.Type == obj.SDYNIMPORT {
+		r.Type = objabi.R_CALLARM
+		if targ.Type == objabi.SDYNIMPORT {
 			addpltsym(ctxt, targ)
 			r.Sym = ctxt.Syms.Lookup(".plt", 0)
 			r.Add = int64(braddoff(int32(r.Add), targ.Plt/4))
@@ -185,16 +185,16 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 		return true
 
 	case 256 + ld.R_ARM_REL32: // R_ARM_REL32
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 
 		r.Add += 4
 		return true
 
 	case 256 + ld.R_ARM_ABS32:
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			ld.Errorf(s, "unexpected R_ARM_ABS32 relocation for dynamic symbol %s", targ.Name)
 		}
-		r.Type = obj.R_ADDR
+		r.Type = objabi.R_ADDR
 		return true
 
 		// we can just ignore this, because we are targeting ARM V5+ anyway
@@ -209,8 +209,8 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 
 	case 256 + ld.R_ARM_PC24,
 		256 + ld.R_ARM_JUMP24:
-		r.Type = obj.R_CALLARM
-		if targ.Type == obj.SDYNIMPORT {
+		r.Type = objabi.R_CALLARM
+		if targ.Type == objabi.SDYNIMPORT {
 			addpltsym(ctxt, targ)
 			r.Sym = ctxt.Syms.Lookup(".plt", 0)
 			r.Add = int64(braddoff(int32(r.Add), targ.Plt/4))
@@ -220,19 +220,19 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 	}
 
 	// Handle references to ELF symbols from our own object files.
-	if targ.Type != obj.SDYNIMPORT {
+	if targ.Type != objabi.SDYNIMPORT {
 		return true
 	}
 
 	switch r.Type {
-	case obj.R_CALLARM:
+	case objabi.R_CALLARM:
 		addpltsym(ctxt, targ)
 		r.Sym = ctxt.Syms.Lookup(".plt", 0)
 		r.Add = int64(targ.Plt)
 		return true
 
-	case obj.R_ADDR:
-		if s.Type != obj.SDATA {
+	case objabi.R_ADDR:
+		if s.Type != objabi.SDATA {
 			break
 		}
 		if ld.Iself {
@@ -240,7 +240,7 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 			rel := ctxt.Syms.Lookup(".rel", 0)
 			ld.Addaddrplus(ctxt, rel, s, int64(r.Off))
 			ld.Adduint32(ctxt, rel, ld.ELF32_R_INFO(uint32(targ.Dynid), ld.R_ARM_GLOB_DAT)) // we need a nil + A dynamic reloc
-			r.Type = obj.R_CONST                                                            // write r->add during relocsym
+			r.Type = objabi.R_CONST                                                         // write r->add during relocsym
 			r.Sym = nil
 			return true
 		}
@@ -257,21 +257,21 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 	default:
 		return -1
 
-	case obj.R_ADDR:
+	case objabi.R_ADDR:
 		if r.Siz == 4 {
 			ld.Thearch.Lput(ld.R_ARM_ABS32 | uint32(elfsym)<<8)
 		} else {
 			return -1
 		}
 
-	case obj.R_PCREL:
+	case objabi.R_PCREL:
 		if r.Siz == 4 {
 			ld.Thearch.Lput(ld.R_ARM_REL32 | uint32(elfsym)<<8)
 		} else {
 			return -1
 		}
 
-	case obj.R_CALLARM:
+	case objabi.R_CALLARM:
 		if r.Siz == 4 {
 			if r.Add&0xff000000 == 0xeb000000 { // BL
 				ld.Thearch.Lput(ld.R_ARM_CALL | uint32(elfsym)<<8)
@@ -282,13 +282,13 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 			return -1
 		}
 
-	case obj.R_TLS_LE:
+	case objabi.R_TLS_LE:
 		ld.Thearch.Lput(ld.R_ARM_TLS_LE32 | uint32(elfsym)<<8)
 
-	case obj.R_TLS_IE:
+	case objabi.R_TLS_IE:
 		ld.Thearch.Lput(ld.R_ARM_TLS_IE32 | uint32(elfsym)<<8)
 
-	case obj.R_GOTPCREL:
+	case objabi.R_GOTPCREL:
 		if r.Siz == 4 {
 			ld.Thearch.Lput(ld.R_ARM_GOT_PREL | uint32(elfsym)<<8)
 		} else {
@@ -331,8 +331,8 @@ func machoreloc1(s *ld.Symbol, r *ld.Reloc, sectoff int64) int {
 
 	rs := r.Xsym
 
-	if r.Type == obj.R_PCREL {
-		if rs.Type == obj.SHOSTOBJ {
+	if r.Type == objabi.R_PCREL {
+		if rs.Type == objabi.SHOSTOBJ {
 			ld.Errorf(s, "pc-relative relocation of external symbol is not supported")
 			return -1
 		}
@@ -361,7 +361,7 @@ func machoreloc1(s *ld.Symbol, r *ld.Reloc, sectoff int64) int {
 		return 0
 	}
 
-	if rs.Type == obj.SHOSTOBJ || r.Type == obj.R_CALLARM {
+	if rs.Type == objabi.SHOSTOBJ || r.Type == objabi.R_CALLARM {
 		if rs.Dynid < 0 {
 			ld.Errorf(s, "reloc %d to non-macho symbol %s type=%d", r.Type, rs.Name, rs.Type)
 			return -1
@@ -381,10 +381,10 @@ func machoreloc1(s *ld.Symbol, r *ld.Reloc, sectoff int64) int {
 	default:
 		return -1
 
-	case obj.R_ADDR:
+	case objabi.R_ADDR:
 		v |= ld.MACHO_GENERIC_RELOC_VANILLA << 28
 
-	case obj.R_CALLARM:
+	case objabi.R_CALLARM:
 		v |= 1 << 24 // pc-relative bit
 		v |= ld.MACHO_ARM_RELOC_BR24 << 28
 	}
@@ -430,7 +430,7 @@ func immrot(v uint32) uint32 {
 // Convert the direct jump relocation r to refer to a trampoline if the target is too far
 func trampoline(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol) {
 	switch r.Type {
-	case obj.R_CALLARM:
+	case objabi.R_CALLARM:
 		// r.Add is the instruction
 		// low 24-bit encodes the target address
 		t := (ld.Symaddr(r.Sym) + int64(signext24(r.Add&0xffffff)*4) - (s.Value + int64(r.Off))) / 4
@@ -443,7 +443,7 @@ func trampoline(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol) {
 			for i := 0; ; i++ {
 				name := r.Sym.Name + fmt.Sprintf("%+d-tramp%d", offset, i)
 				tramp = ctxt.Syms.Lookup(name, int(r.Sym.Version))
-				if tramp.Type == obj.SDYNIMPORT {
+				if tramp.Type == objabi.SDYNIMPORT {
 					// don't reuse trampoline defined in other module
 					continue
 				}
@@ -500,7 +500,7 @@ func gentramp(tramp, target *ld.Symbol, offset int64) {
 	if ld.Linkmode == ld.LinkExternal {
 		r := ld.Addrel(tramp)
 		r.Off = 8
-		r.Type = obj.R_ADDR
+		r.Type = objabi.R_ADDR
 		r.Siz = 4
 		r.Sym = target
 		r.Add = offset
@@ -522,7 +522,7 @@ func gentramppic(tramp, target *ld.Symbol, offset int64) {
 
 	r := ld.Addrel(tramp)
 	r.Off = 12
-	r.Type = obj.R_PCREL
+	r.Type = objabi.R_PCREL
 	r.Siz = 4
 	r.Sym = target
 	r.Add = offset + 4
@@ -557,7 +557,7 @@ func gentrampdyn(tramp, target *ld.Symbol, offset int64) {
 
 	r := ld.Addrel(tramp)
 	r.Off = 16
-	r.Type = obj.R_GOTPCREL
+	r.Type = objabi.R_GOTPCREL
 	r.Siz = 4
 	r.Sym = target
 	r.Add = 8
@@ -571,7 +571,7 @@ func gentrampdyn(tramp, target *ld.Symbol, offset int64) {
 func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 	if ld.Linkmode == ld.LinkExternal {
 		switch r.Type {
-		case obj.R_CALLARM:
+		case objabi.R_CALLARM:
 			r.Done = 0
 
 			// set up addend for eventual relocation via outer symbol.
@@ -584,7 +584,7 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 				rs = rs.Outer
 			}
 
-			if rs.Type != obj.SHOSTOBJ && rs.Type != obj.SDYNIMPORT && rs.Sect == nil {
+			if rs.Type != objabi.SHOSTOBJ && rs.Type != objabi.SDYNIMPORT && rs.Sect == nil {
 				ld.Errorf(s, "missing section for %s", rs.Name)
 			}
 			r.Xsym = rs
@@ -594,7 +594,7 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 			// the section load address.
 			// we need to compensate that by removing the instruction's address
 			// from addend.
-			if ld.Headtype == obj.Hdarwin {
+			if ld.Headtype == objabi.Hdarwin {
 				r.Xadd -= ld.Symaddr(s) + int64(r.Off)
 			}
 
@@ -610,34 +610,34 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 	}
 
 	switch r.Type {
-	case obj.R_CONST:
+	case objabi.R_CONST:
 		*val = r.Add
 		return 0
 
-	case obj.R_GOTOFF:
+	case objabi.R_GOTOFF:
 		*val = ld.Symaddr(r.Sym) + r.Add - ld.Symaddr(ctxt.Syms.Lookup(".got", 0))
 		return 0
 
 	// The following three arch specific relocations are only for generation of
 	// Linux/ARM ELF's PLT entry (3 assembler instruction)
-	case obj.R_PLT0: // add ip, pc, #0xXX00000
+	case objabi.R_PLT0: // add ip, pc, #0xXX00000
 		if ld.Symaddr(ctxt.Syms.Lookup(".got.plt", 0)) < ld.Symaddr(ctxt.Syms.Lookup(".plt", 0)) {
 			ld.Errorf(s, ".got.plt should be placed after .plt section.")
 		}
 		*val = 0xe28fc600 + (0xff & (int64(uint32(ld.Symaddr(r.Sym)-(ld.Symaddr(ctxt.Syms.Lookup(".plt", 0))+int64(r.Off))+r.Add)) >> 20))
 		return 0
 
-	case obj.R_PLT1: // add ip, ip, #0xYY000
+	case objabi.R_PLT1: // add ip, ip, #0xYY000
 		*val = 0xe28cca00 + (0xff & (int64(uint32(ld.Symaddr(r.Sym)-(ld.Symaddr(ctxt.Syms.Lookup(".plt", 0))+int64(r.Off))+r.Add+4)) >> 12))
 
 		return 0
 
-	case obj.R_PLT2: // ldr pc, [ip, #0xZZZ]!
+	case objabi.R_PLT2: // ldr pc, [ip, #0xZZZ]!
 		*val = 0xe5bcf000 + (0xfff & int64(uint32(ld.Symaddr(r.Sym)-(ld.Symaddr(ctxt.Syms.Lookup(".plt", 0))+int64(r.Off))+r.Add+8)))
 
 		return 0
 
-	case obj.R_CALLARM: // bl XXXXXX or b YYYYYY
+	case objabi.R_CALLARM: // bl XXXXXX or b YYYYYY
 		// r.Add is the instruction
 		// low 24-bit encodes the target address
 		t := (ld.Symaddr(r.Sym) + int64(signext24(r.Add&0xffffff)*4) - (s.Value + int64(r.Off))) / 4
@@ -657,7 +657,7 @@ func archrelocvariant(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, t int64) int64 {
 	return t
 }
 
-func addpltreloc(ctxt *ld.Link, plt *ld.Symbol, got *ld.Symbol, sym *ld.Symbol, typ obj.RelocType) *ld.Reloc {
+func addpltreloc(ctxt *ld.Link, plt *ld.Symbol, got *ld.Symbol, sym *ld.Symbol, typ objabi.RelocType) *ld.Reloc {
 	r := ld.Addrel(plt)
 	r.Sym = got
 	r.Off = int32(plt.Size)
@@ -698,9 +698,9 @@ func addpltsym(ctxt *ld.Link, s *ld.Symbol) {
 		// .plt entry, this depends on the .got entry
 		s.Plt = int32(plt.Size)
 
-		addpltreloc(ctxt, plt, got, s, obj.R_PLT0) // add lr, pc, #0xXX00000
-		addpltreloc(ctxt, plt, got, s, obj.R_PLT1) // add lr, lr, #0xYY000
-		addpltreloc(ctxt, plt, got, s, obj.R_PLT2) // ldr pc, [lr, #0xZZZ]!
+		addpltreloc(ctxt, plt, got, s, objabi.R_PLT0) // add lr, pc, #0xXX00000
+		addpltreloc(ctxt, plt, got, s, objabi.R_PLT1) // add lr, lr, #0xYY000
+		addpltreloc(ctxt, plt, got, s, objabi.R_PLT2) // ldr pc, [lr, #0xZZZ]!
 
 		// rel
 		ld.Addaddrplus(ctxt, rel, got, int64(s.Got))
@@ -748,7 +748,7 @@ func addgotsym(ctxt *ld.Link, s *ld.Symbol) {
 
 func asmb(ctxt *ld.Link) {
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f asmb\n", obj.Cputime())
+		ctxt.Logf("%5.2f asmb\n", ld.Cputime())
 	}
 
 	if ld.Iself {
@@ -765,21 +765,21 @@ func asmb(ctxt *ld.Link) {
 
 	if ld.Segrodata.Filelen > 0 {
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f rodatblk\n", obj.Cputime())
+			ctxt.Logf("%5.2f rodatblk\n", ld.Cputime())
 		}
 		ld.Cseek(int64(ld.Segrodata.Fileoff))
 		ld.Datblk(ctxt, int64(ld.Segrodata.Vaddr), int64(ld.Segrodata.Filelen))
 	}
 	if ld.Segrelrodata.Filelen > 0 {
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f relrodatblk\n", obj.Cputime())
+			ctxt.Logf("%5.2f relrodatblk\n", ld.Cputime())
 		}
 		ld.Cseek(int64(ld.Segrelrodata.Fileoff))
 		ld.Datblk(ctxt, int64(ld.Segrelrodata.Vaddr), int64(ld.Segrelrodata.Filelen))
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f datblk\n", obj.Cputime())
+		ctxt.Logf("%5.2f datblk\n", ld.Cputime())
 	}
 
 	ld.Cseek(int64(ld.Segdata.Fileoff))
@@ -789,7 +789,7 @@ func asmb(ctxt *ld.Link) {
 	ld.Dwarfblk(ctxt, int64(ld.Segdwarf.Vaddr), int64(ld.Segdwarf.Filelen))
 
 	machlink := uint32(0)
-	if ld.Headtype == obj.Hdarwin {
+	if ld.Headtype == objabi.Hdarwin {
 		machlink = uint32(ld.Domacholink(ctxt))
 	}
 
@@ -801,7 +801,7 @@ func asmb(ctxt *ld.Link) {
 	if !*ld.FlagS {
 		// TODO: rationalize
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f sym\n", obj.Cputime())
+			ctxt.Logf("%5.2f sym\n", ld.Cputime())
 		}
 		switch ld.Headtype {
 		default:
@@ -810,10 +810,10 @@ func asmb(ctxt *ld.Link) {
 				symo = uint32(ld.Rnd(int64(symo), int64(*ld.FlagRound)))
 			}
 
-		case obj.Hplan9:
+		case objabi.Hplan9:
 			symo = uint32(ld.Segdata.Fileoff + ld.Segdata.Filelen)
 
-		case obj.Hdarwin:
+		case objabi.Hdarwin:
 			symo = uint32(ld.Segdwarf.Fileoff + uint64(ld.Rnd(int64(ld.Segdwarf.Filelen), int64(*ld.FlagRound))) + uint64(machlink))
 		}
 
@@ -822,7 +822,7 @@ func asmb(ctxt *ld.Link) {
 		default:
 			if ld.Iself {
 				if ctxt.Debugvlog != 0 {
-					ctxt.Logf("%5.2f elfsym\n", obj.Cputime())
+					ctxt.Logf("%5.2f elfsym\n", ld.Cputime())
 				}
 				ld.Asmelfsym(ctxt)
 				ld.Cflush()
@@ -833,7 +833,7 @@ func asmb(ctxt *ld.Link) {
 				}
 			}
 
-		case obj.Hplan9:
+		case objabi.Hplan9:
 			ld.Asmplan9sym(ctxt)
 			ld.Cflush()
 
@@ -847,7 +847,7 @@ func asmb(ctxt *ld.Link) {
 				ld.Cflush()
 			}
 
-		case obj.Hdarwin:
+		case objabi.Hdarwin:
 			if ld.Linkmode == ld.LinkExternal {
 				ld.Machoemitreloc(ctxt)
 			}
@@ -855,12 +855,12 @@ func asmb(ctxt *ld.Link) {
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f header\n", obj.Cputime())
+		ctxt.Logf("%5.2f header\n", ld.Cputime())
 	}
 	ld.Cseek(0)
 	switch ld.Headtype {
 	default:
-	case obj.Hplan9: /* plan 9 */
+	case objabi.Hplan9: /* plan 9 */
 		ld.Lputb(0x647)                      /* magic */
 		ld.Lputb(uint32(ld.Segtext.Filelen)) /* sizes */
 		ld.Lputb(uint32(ld.Segdata.Filelen))
@@ -870,14 +870,14 @@ func asmb(ctxt *ld.Link) {
 		ld.Lputb(0)
 		ld.Lputb(uint32(ld.Lcsize))
 
-	case obj.Hlinux,
-		obj.Hfreebsd,
-		obj.Hnetbsd,
-		obj.Hopenbsd,
-		obj.Hnacl:
+	case objabi.Hlinux,
+		objabi.Hfreebsd,
+		objabi.Hnetbsd,
+		objabi.Hopenbsd,
+		objabi.Hnacl:
 		ld.Asmbelf(ctxt, int64(symo))
 
-	case obj.Hdarwin:
+	case objabi.Hdarwin:
 		ld.Asmbmacho(ctxt)
 	}
 
diff --git a/src/cmd/link/internal/arm/obj.go b/src/cmd/link/internal/arm/obj.go
index 05b90d20f2..2975e5d45a 100644
--- a/src/cmd/link/internal/arm/obj.go
+++ b/src/cmd/link/internal/arm/obj.go
@@ -31,7 +31,7 @@
 package arm
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"cmd/link/internal/ld"
 	"fmt"
@@ -76,7 +76,7 @@ func archinit(ctxt *ld.Link) {
 	default:
 		ld.Exitf("unknown -H option: %v", ld.Headtype)
 
-	case obj.Hplan9: /* plan 9 */
+	case objabi.Hplan9: /* plan 9 */
 		ld.HEADR = 32
 
 		if *ld.FlagTextAddr == -1 {
@@ -89,10 +89,10 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagRound = 4096
 		}
 
-	case obj.Hlinux, /* arm elf */
-		obj.Hfreebsd,
-		obj.Hnetbsd,
-		obj.Hopenbsd:
+	case objabi.Hlinux, /* arm elf */
+		objabi.Hfreebsd,
+		objabi.Hnetbsd,
+		objabi.Hopenbsd:
 		*ld.FlagD = false
 		// with dynamic linking
 		ld.Elfinit(ctxt)
@@ -107,7 +107,7 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagRound = 0x10000
 		}
 
-	case obj.Hnacl:
+	case objabi.Hnacl:
 		ld.Elfinit(ctxt)
 		ld.HEADR = 0x10000
 		ld.Funcalign = 16
@@ -121,7 +121,7 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagRound = 0x10000
 		}
 
-	case obj.Hdarwin: /* apple MACH */
+	case objabi.Hdarwin: /* apple MACH */
 		*ld.FlagW = true // disable DWARF generation
 		ld.Machoinit()
 		ld.HEADR = ld.INITIAL_MACHO_HEADR
diff --git a/src/cmd/link/internal/arm64/asm.go b/src/cmd/link/internal/arm64/asm.go
index d7576b1686..597e271d0c 100644
--- a/src/cmd/link/internal/arm64/asm.go
+++ b/src/cmd/link/internal/arm64/asm.go
@@ -31,7 +31,7 @@
 package arm64
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/link/internal/ld"
 	"encoding/binary"
 	"fmt"
@@ -43,14 +43,14 @@ func gentext(ctxt *ld.Link) {
 		return
 	}
 	addmoduledata := ctxt.Syms.Lookup("runtime.addmoduledata", 0)
-	if addmoduledata.Type == obj.STEXT {
+	if addmoduledata.Type == objabi.STEXT {
 		// we're linking a module containing the runtime -> no need for
 		// an init function
 		return
 	}
 	addmoduledata.Attr |= ld.AttrReachable
 	initfunc := ctxt.Syms.Lookup("go.link.addmoduledata", 0)
-	initfunc.Type = obj.STEXT
+	initfunc.Type = objabi.STEXT
 	initfunc.Attr |= ld.AttrLocal
 	initfunc.Attr |= ld.AttrReachable
 	o := func(op uint32) {
@@ -67,7 +67,7 @@ func gentext(ctxt *ld.Link) {
 	rel.Off = 0
 	rel.Siz = 8
 	rel.Sym = ctxt.Moduledata
-	rel.Type = obj.R_ADDRARM64
+	rel.Type = objabi.R_ADDRARM64
 
 	// 8:	14000000 	bl	0 <runtime.addmoduledata>
 	// 	8: R_AARCH64_CALL26	runtime.addmoduledata
@@ -76,13 +76,13 @@ func gentext(ctxt *ld.Link) {
 	rel.Off = 8
 	rel.Siz = 4
 	rel.Sym = ctxt.Syms.Lookup("runtime.addmoduledata", 0)
-	rel.Type = obj.R_CALLARM64 // Really should be R_AARCH64_JUMP26 but doesn't seem to make any difference
+	rel.Type = objabi.R_CALLARM64 // Really should be R_AARCH64_JUMP26 but doesn't seem to make any difference
 
 	ctxt.Textp = append(ctxt.Textp, initfunc)
 	initarray_entry := ctxt.Syms.Lookup("go.link.addmoduledatainit", 0)
 	initarray_entry.Attr |= ld.AttrReachable
 	initarray_entry.Attr |= ld.AttrLocal
-	initarray_entry.Type = obj.SINITARR
+	initarray_entry.Type = objabi.SINITARR
 	ld.Addaddr(ctxt, initarray_entry, initfunc)
 }
 
@@ -99,7 +99,7 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 	default:
 		return -1
 
-	case obj.R_ADDR:
+	case objabi.R_ADDR:
 		switch r.Siz {
 		case 4:
 			ld.Thearch.Vput(ld.R_AARCH64_ABS32 | uint64(elfsym)<<32)
@@ -109,29 +109,29 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 			return -1
 		}
 
-	case obj.R_ADDRARM64:
+	case objabi.R_ADDRARM64:
 		// two relocations: R_AARCH64_ADR_PREL_PG_HI21 and R_AARCH64_ADD_ABS_LO12_NC
 		ld.Thearch.Vput(ld.R_AARCH64_ADR_PREL_PG_HI21 | uint64(elfsym)<<32)
 		ld.Thearch.Vput(uint64(r.Xadd))
 		ld.Thearch.Vput(uint64(sectoff + 4))
 		ld.Thearch.Vput(ld.R_AARCH64_ADD_ABS_LO12_NC | uint64(elfsym)<<32)
 
-	case obj.R_ARM64_TLS_LE:
+	case objabi.R_ARM64_TLS_LE:
 		ld.Thearch.Vput(ld.R_AARCH64_TLSLE_MOVW_TPREL_G0 | uint64(elfsym)<<32)
 
-	case obj.R_ARM64_TLS_IE:
+	case objabi.R_ARM64_TLS_IE:
 		ld.Thearch.Vput(ld.R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21 | uint64(elfsym)<<32)
 		ld.Thearch.Vput(uint64(r.Xadd))
 		ld.Thearch.Vput(uint64(sectoff + 4))
 		ld.Thearch.Vput(ld.R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC | uint64(elfsym)<<32)
 
-	case obj.R_ARM64_GOTPCREL:
+	case objabi.R_ARM64_GOTPCREL:
 		ld.Thearch.Vput(ld.R_AARCH64_ADR_GOT_PAGE | uint64(elfsym)<<32)
 		ld.Thearch.Vput(uint64(r.Xadd))
 		ld.Thearch.Vput(uint64(sectoff + 4))
 		ld.Thearch.Vput(ld.R_AARCH64_LD64_GOT_LO12_NC | uint64(elfsym)<<32)
 
-	case obj.R_CALLARM64:
+	case objabi.R_CALLARM64:
 		if r.Siz != 4 {
 			return -1
 		}
@@ -156,7 +156,7 @@ func machoreloc1(s *ld.Symbol, r *ld.Reloc, sectoff int64) int {
 	// ld64 has a bug handling MACHO_ARM64_RELOC_UNSIGNED with !extern relocation.
 	// see cmd/internal/ld/data.go for details. The workaround is that don't use !extern
 	// UNSIGNED relocation at all.
-	if rs.Type == obj.SHOSTOBJ || r.Type == obj.R_CALLARM64 || r.Type == obj.R_ADDRARM64 || r.Type == obj.R_ADDR {
+	if rs.Type == objabi.SHOSTOBJ || r.Type == objabi.R_CALLARM64 || r.Type == objabi.R_ADDRARM64 || r.Type == objabi.R_ADDR {
 		if rs.Dynid < 0 {
 			ld.Errorf(s, "reloc %d to non-macho symbol %s type=%d", r.Type, rs.Name, rs.Type)
 			return -1
@@ -176,10 +176,10 @@ func machoreloc1(s *ld.Symbol, r *ld.Reloc, sectoff int64) int {
 	default:
 		return -1
 
-	case obj.R_ADDR:
+	case objabi.R_ADDR:
 		v |= ld.MACHO_ARM64_RELOC_UNSIGNED << 28
 
-	case obj.R_CALLARM64:
+	case objabi.R_CALLARM64:
 		if r.Xadd != 0 {
 			ld.Errorf(s, "ld64 doesn't allow BR26 reloc with non-zero addend: %s+%d", rs.Name, r.Xadd)
 		}
@@ -187,7 +187,7 @@ func machoreloc1(s *ld.Symbol, r *ld.Reloc, sectoff int64) int {
 		v |= 1 << 24 // pc-relative bit
 		v |= ld.MACHO_ARM64_RELOC_BRANCH26 << 28
 
-	case obj.R_ADDRARM64:
+	case objabi.R_ADDRARM64:
 		r.Siz = 4
 		// Two relocation entries: MACHO_ARM64_RELOC_PAGEOFF12 MACHO_ARM64_RELOC_PAGE21
 		// if r.Xadd is non-zero, add two MACHO_ARM64_RELOC_ADDEND.
@@ -233,7 +233,7 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 		default:
 			return -1
 
-		case obj.R_ARM64_GOTPCREL:
+		case objabi.R_ARM64_GOTPCREL:
 			var o1, o2 uint32
 			if ctxt.Arch.ByteOrder == binary.BigEndian {
 				o1 = uint32(*val >> 32)
@@ -250,12 +250,12 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 			// (https://sourceware.org/bugzilla/show_bug.cgi?id=18270). So
 			// we convert the adrp; ld64 + R_ARM64_GOTPCREL into adrp;
 			// add + R_ADDRARM64.
-			if !(r.Sym.Version != 0 || (r.Sym.Type&obj.SHIDDEN != 0) || r.Sym.Attr.Local()) && r.Sym.Type == obj.STEXT && ctxt.DynlinkingGo() {
+			if !(r.Sym.Version != 0 || (r.Sym.Type&objabi.SHIDDEN != 0) || r.Sym.Attr.Local()) && r.Sym.Type == objabi.STEXT && ctxt.DynlinkingGo() {
 				if o2&0xffc00000 != 0xf9400000 {
 					ld.Errorf(s, "R_ARM64_GOTPCREL against unexpected instruction %x", o2)
 				}
 				o2 = 0x91000000 | (o2 & 0x000003ff)
-				r.Type = obj.R_ADDRARM64
+				r.Type = objabi.R_ADDRARM64
 			}
 			if ctxt.Arch.ByteOrder == binary.BigEndian {
 				*val = int64(o1)<<32 | int64(o2)
@@ -264,7 +264,7 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 			}
 			fallthrough
 
-		case obj.R_ADDRARM64:
+		case objabi.R_ADDRARM64:
 			r.Done = 0
 
 			// set up addend for eventual relocation via outer symbol.
@@ -275,7 +275,7 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 				rs = rs.Outer
 			}
 
-			if rs.Type != obj.SHOSTOBJ && rs.Type != obj.SDYNIMPORT && rs.Sect == nil {
+			if rs.Type != objabi.SHOSTOBJ && rs.Type != objabi.SDYNIMPORT && rs.Sect == nil {
 				ld.Errorf(s, "missing section for %s", rs.Name)
 			}
 			r.Xsym = rs
@@ -285,7 +285,7 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 			// the BR26 relocation should be fully resolved at link time.
 			// That is the reason why the next if block is disabled. When the bug in ld64
 			// is fixed, we can enable this block and also enable duff's device in cmd/7g.
-			if false && ld.Headtype == obj.Hdarwin {
+			if false && ld.Headtype == objabi.Hdarwin {
 				var o0, o1 uint32
 
 				if ctxt.Arch.ByteOrder == binary.BigEndian {
@@ -314,9 +314,9 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 
 			return 0
 
-		case obj.R_CALLARM64,
-			obj.R_ARM64_TLS_LE,
-			obj.R_ARM64_TLS_IE:
+		case objabi.R_CALLARM64,
+			objabi.R_ARM64_TLS_LE,
+			objabi.R_ARM64_TLS_IE:
 			r.Done = 0
 			r.Xsym = r.Sym
 			r.Xadd = r.Add
@@ -325,15 +325,15 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 	}
 
 	switch r.Type {
-	case obj.R_CONST:
+	case objabi.R_CONST:
 		*val = r.Add
 		return 0
 
-	case obj.R_GOTOFF:
+	case objabi.R_GOTOFF:
 		*val = ld.Symaddr(r.Sym) + r.Add - ld.Symaddr(ctxt.Syms.Lookup(".got", 0))
 		return 0
 
-	case obj.R_ADDRARM64:
+	case objabi.R_ADDRARM64:
 		t := ld.Symaddr(r.Sym) + r.Add - ((s.Value + int64(r.Off)) &^ 0xfff)
 		if t >= 1<<32 || t < -1<<32 {
 			ld.Errorf(s, "program too large, address relocation distance = %d", t)
@@ -360,9 +360,9 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 		}
 		return 0
 
-	case obj.R_ARM64_TLS_LE:
+	case objabi.R_ARM64_TLS_LE:
 		r.Done = 0
-		if ld.Headtype != obj.Hlinux {
+		if ld.Headtype != objabi.Hlinux {
 			ld.Errorf(s, "TLS reloc on unsupported OS %v", ld.Headtype)
 		}
 		// The TCB is two pointers. This is not documented anywhere, but is
@@ -374,7 +374,7 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 		*val |= v << 5
 		return 0
 
-	case obj.R_CALLARM64:
+	case objabi.R_CALLARM64:
 		t := (ld.Symaddr(r.Sym) + r.Add) - (s.Value + int64(r.Off))
 		if t >= 1<<27 || t < -1<<27 {
 			ld.Errorf(s, "program too large, call relocation distance = %d", t)
@@ -393,7 +393,7 @@ func archrelocvariant(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, t int64) int64 {
 
 func asmb(ctxt *ld.Link) {
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f asmb\n", obj.Cputime())
+		ctxt.Logf("%5.2f asmb\n", ld.Cputime())
 	}
 
 	if ld.Iself {
@@ -410,21 +410,21 @@ func asmb(ctxt *ld.Link) {
 
 	if ld.Segrodata.Filelen > 0 {
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f rodatblk\n", obj.Cputime())
+			ctxt.Logf("%5.2f rodatblk\n", ld.Cputime())
 		}
 		ld.Cseek(int64(ld.Segrodata.Fileoff))
 		ld.Datblk(ctxt, int64(ld.Segrodata.Vaddr), int64(ld.Segrodata.Filelen))
 	}
 	if ld.Segrelrodata.Filelen > 0 {
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f relrodatblk\n", obj.Cputime())
+			ctxt.Logf("%5.2f relrodatblk\n", ld.Cputime())
 		}
 		ld.Cseek(int64(ld.Segrelrodata.Fileoff))
 		ld.Datblk(ctxt, int64(ld.Segrelrodata.Vaddr), int64(ld.Segrelrodata.Filelen))
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f datblk\n", obj.Cputime())
+		ctxt.Logf("%5.2f datblk\n", ld.Cputime())
 	}
 
 	ld.Cseek(int64(ld.Segdata.Fileoff))
@@ -434,7 +434,7 @@ func asmb(ctxt *ld.Link) {
 	ld.Dwarfblk(ctxt, int64(ld.Segdwarf.Vaddr), int64(ld.Segdwarf.Filelen))
 
 	machlink := uint32(0)
-	if ld.Headtype == obj.Hdarwin {
+	if ld.Headtype == objabi.Hdarwin {
 		machlink = uint32(ld.Domacholink(ctxt))
 	}
 
@@ -446,7 +446,7 @@ func asmb(ctxt *ld.Link) {
 	if !*ld.FlagS {
 		// TODO: rationalize
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f sym\n", obj.Cputime())
+			ctxt.Logf("%5.2f sym\n", ld.Cputime())
 		}
 		switch ld.Headtype {
 		default:
@@ -455,10 +455,10 @@ func asmb(ctxt *ld.Link) {
 				symo = uint32(ld.Rnd(int64(symo), int64(*ld.FlagRound)))
 			}
 
-		case obj.Hplan9:
+		case objabi.Hplan9:
 			symo = uint32(ld.Segdata.Fileoff + ld.Segdata.Filelen)
 
-		case obj.Hdarwin:
+		case objabi.Hdarwin:
 			symo = uint32(ld.Segdwarf.Fileoff + uint64(ld.Rnd(int64(ld.Segdwarf.Filelen), int64(*ld.FlagRound))) + uint64(machlink))
 		}
 
@@ -467,7 +467,7 @@ func asmb(ctxt *ld.Link) {
 		default:
 			if ld.Iself {
 				if ctxt.Debugvlog != 0 {
-					ctxt.Logf("%5.2f elfsym\n", obj.Cputime())
+					ctxt.Logf("%5.2f elfsym\n", ld.Cputime())
 				}
 				ld.Asmelfsym(ctxt)
 				ld.Cflush()
@@ -478,7 +478,7 @@ func asmb(ctxt *ld.Link) {
 				}
 			}
 
-		case obj.Hplan9:
+		case objabi.Hplan9:
 			ld.Asmplan9sym(ctxt)
 			ld.Cflush()
 
@@ -492,7 +492,7 @@ func asmb(ctxt *ld.Link) {
 				ld.Cflush()
 			}
 
-		case obj.Hdarwin:
+		case objabi.Hdarwin:
 			if ld.Linkmode == ld.LinkExternal {
 				ld.Machoemitreloc(ctxt)
 			}
@@ -500,12 +500,12 @@ func asmb(ctxt *ld.Link) {
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f header\n", obj.Cputime())
+		ctxt.Logf("%5.2f header\n", ld.Cputime())
 	}
 	ld.Cseek(0)
 	switch ld.Headtype {
 	default:
-	case obj.Hplan9: /* plan 9 */
+	case objabi.Hplan9: /* plan 9 */
 		ld.Thearch.Lput(0x647)                      /* magic */
 		ld.Thearch.Lput(uint32(ld.Segtext.Filelen)) /* sizes */
 		ld.Thearch.Lput(uint32(ld.Segdata.Filelen))
@@ -515,14 +515,14 @@ func asmb(ctxt *ld.Link) {
 		ld.Thearch.Lput(0)
 		ld.Thearch.Lput(uint32(ld.Lcsize))
 
-	case obj.Hlinux,
-		obj.Hfreebsd,
-		obj.Hnetbsd,
-		obj.Hopenbsd,
-		obj.Hnacl:
+	case objabi.Hlinux,
+		objabi.Hfreebsd,
+		objabi.Hnetbsd,
+		objabi.Hopenbsd,
+		objabi.Hnacl:
 		ld.Asmbelf(ctxt, int64(symo))
 
-	case obj.Hdarwin:
+	case objabi.Hdarwin:
 		ld.Asmbmacho(ctxt)
 	}
 
diff --git a/src/cmd/link/internal/arm64/obj.go b/src/cmd/link/internal/arm64/obj.go
index 7d49163e90..dce9beb150 100644
--- a/src/cmd/link/internal/arm64/obj.go
+++ b/src/cmd/link/internal/arm64/obj.go
@@ -31,7 +31,7 @@
 package arm64
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"cmd/link/internal/ld"
 	"fmt"
@@ -76,7 +76,7 @@ func archinit(ctxt *ld.Link) {
 	default:
 		ld.Exitf("unknown -H option: %v", ld.Headtype)
 
-	case obj.Hplan9: /* plan 9 */
+	case objabi.Hplan9: /* plan 9 */
 		ld.HEADR = 32
 
 		if *ld.FlagTextAddr == -1 {
@@ -89,7 +89,7 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagRound = 4096
 		}
 
-	case obj.Hlinux: /* arm64 elf */
+	case objabi.Hlinux: /* arm64 elf */
 		ld.Elfinit(ctxt)
 		ld.HEADR = ld.ELFRESERVE
 		if *ld.FlagTextAddr == -1 {
@@ -102,7 +102,7 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagRound = 0x10000
 		}
 
-	case obj.Hdarwin: /* apple MACH */
+	case objabi.Hdarwin: /* apple MACH */
 		*ld.FlagW = true // disable DWARF generation
 		ld.Machoinit()
 		ld.HEADR = ld.INITIAL_MACHO_HEADR
@@ -116,7 +116,7 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagRound = 4096
 		}
 
-	case obj.Hnacl:
+	case objabi.Hnacl:
 		ld.Elfinit(ctxt)
 		ld.HEADR = 0x10000
 		ld.Funcalign = 16
diff --git a/src/cmd/link/internal/ld/ar.go b/src/cmd/link/internal/ld/ar.go
index 6db672f7a1..a8c63007c4 100644
--- a/src/cmd/link/internal/ld/ar.go
+++ b/src/cmd/link/internal/ld/ar.go
@@ -32,7 +32,7 @@ package ld
 
 import (
 	"cmd/internal/bio"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"encoding/binary"
 	"fmt"
 	"io"
@@ -101,7 +101,7 @@ func hostArchive(ctxt *Link, name string) {
 		var load []uint64
 		for _, s := range ctxt.Syms.Allsym {
 			for _, r := range s.R {
-				if r.Sym != nil && r.Sym.Type&obj.SMASK == obj.SXREF {
+				if r.Sym != nil && r.Sym.Type&objabi.SMASK == objabi.SXREF {
 					if off := armap[r.Sym.Name]; off != 0 && !loaded[off] {
 						load = append(load, off)
 						loaded[off] = true
@@ -166,7 +166,7 @@ func readArmap(filename string, f *bio.Reader, arhdr ArHdr) archiveMap {
 
 		// For Mach-O and PE/386 files we strip a leading
 		// underscore from the symbol name.
-		if obj.GOOS == "darwin" || (obj.GOOS == "windows" && obj.GOARCH == "386") {
+		if objabi.GOOS == "darwin" || (objabi.GOOS == "windows" && objabi.GOARCH == "386") {
 			if name[0] == '_' && len(name) > 1 {
 				name = name[1:]
 			}
diff --git a/src/cmd/link/internal/ld/config.go b/src/cmd/link/internal/ld/config.go
index fd9119bcaa..342351b4bc 100644
--- a/src/cmd/link/internal/ld/config.go
+++ b/src/cmd/link/internal/ld/config.go
@@ -5,7 +5,7 @@
 package ld
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"fmt"
 	"log"
@@ -34,7 +34,7 @@ const (
 
 func (mode *BuildMode) Set(s string) error {
 	badmode := func() error {
-		return fmt.Errorf("buildmode %s not supported on %s/%s", s, obj.GOOS, obj.GOARCH)
+		return fmt.Errorf("buildmode %s not supported on %s/%s", s, objabi.GOOS, objabi.GOARCH)
 	}
 	switch s {
 	default:
@@ -42,17 +42,17 @@ func (mode *BuildMode) Set(s string) error {
 	case "exe":
 		*mode = BuildmodeExe
 	case "pie":
-		switch obj.GOOS {
+		switch objabi.GOOS {
 		case "android", "linux":
 		default:
 			return badmode()
 		}
 		*mode = BuildmodePIE
 	case "c-archive":
-		switch obj.GOOS {
+		switch objabi.GOOS {
 		case "darwin", "linux":
 		case "windows":
-			switch obj.GOARCH {
+			switch objabi.GOARCH {
 			case "amd64", "386":
 			default:
 				return badmode()
@@ -62,16 +62,16 @@ func (mode *BuildMode) Set(s string) error {
 		}
 		*mode = BuildmodeCArchive
 	case "c-shared":
-		switch obj.GOARCH {
+		switch objabi.GOARCH {
 		case "386", "amd64", "arm", "arm64":
 		default:
 			return badmode()
 		}
 		*mode = BuildmodeCShared
 	case "shared":
-		switch obj.GOOS {
+		switch objabi.GOOS {
 		case "linux":
-			switch obj.GOARCH {
+			switch objabi.GOARCH {
 			case "386", "amd64", "arm", "arm64", "ppc64le", "s390x":
 			default:
 				return badmode()
@@ -81,15 +81,15 @@ func (mode *BuildMode) Set(s string) error {
 		}
 		*mode = BuildmodeShared
 	case "plugin":
-		switch obj.GOOS {
+		switch objabi.GOOS {
 		case "linux":
-			switch obj.GOARCH {
+			switch objabi.GOARCH {
 			case "386", "amd64", "arm", "arm64", "s390x":
 			default:
 				return badmode()
 			}
 		case "darwin":
-			switch obj.GOARCH {
+			switch objabi.GOARCH {
 			case "amd64":
 			default:
 				return badmode()
@@ -168,7 +168,7 @@ func mustLinkExternal(ctxt *Link) (res bool, reason string) {
 		}()
 	}
 
-	switch obj.GOOS {
+	switch objabi.GOOS {
 	case "android":
 		return true, "android"
 	case "darwin":
@@ -185,7 +185,7 @@ func mustLinkExternal(ctxt *Link) (res bool, reason string) {
 	// https://golang.org/issue/10373
 	// https://golang.org/issue/14449
 	if iscgo && SysArch.InFamily(sys.ARM64, sys.MIPS64, sys.MIPS) {
-		return true, obj.GOARCH + " does not support internal cgo"
+		return true, objabi.GOARCH + " does not support internal cgo"
 	}
 
 	// Some build modes require work the internal linker cannot do (yet).
@@ -195,7 +195,7 @@ func mustLinkExternal(ctxt *Link) (res bool, reason string) {
 	case BuildmodeCShared:
 		return true, "buildmode=c-shared"
 	case BuildmodePIE:
-		switch obj.GOOS + "/" + obj.GOARCH {
+		switch objabi.GOOS + "/" + objabi.GOARCH {
 		case "linux/amd64":
 		default:
 			// Internal linking does not support TLS_IE.
@@ -225,7 +225,7 @@ func determineLinkMode(ctxt *Link) {
 		// default value of -linkmode. If it is not set when the
 		// linker is called we take the value it was set to when
 		// cmd/link was compiled. (See make.bash.)
-		switch obj.Getgoextlinkenabled() {
+		switch objabi.Getgoextlinkenabled() {
 		case "0":
 			if needed, reason := mustLinkExternal(ctxt); needed {
 				Exitf("internal linking requested via GO_EXTLINK_ENABLED, but external linking required: %s", reason)
diff --git a/src/cmd/link/internal/ld/data.go b/src/cmd/link/internal/ld/data.go
index 9198cfef31..f75614f006 100644
--- a/src/cmd/link/internal/ld/data.go
+++ b/src/cmd/link/internal/ld/data.go
@@ -33,7 +33,7 @@ package ld
 
 import (
 	"cmd/internal/gcprog"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"fmt"
 	"log"
@@ -65,7 +65,7 @@ func Addrel(s *Symbol) *Reloc {
 
 func setuintxx(ctxt *Link, s *Symbol, off int64, v uint64, wid int64) int64 {
 	if s.Type == 0 {
-		s.Type = obj.SDATA
+		s.Type = objabi.SDATA
 	}
 	s.Attr |= AttrReachable
 	if s.Size < off+wid {
@@ -89,7 +89,7 @@ func setuintxx(ctxt *Link, s *Symbol, off int64, v uint64, wid int64) int64 {
 
 func Addbytes(s *Symbol, bytes []byte) int64 {
 	if s.Type == 0 {
-		s.Type = obj.SDATA
+		s.Type = objabi.SDATA
 	}
 	s.Attr |= AttrReachable
 	s.P = append(s.P, bytes...)
@@ -107,7 +107,7 @@ func adduintxx(ctxt *Link, s *Symbol, v uint64, wid int) int64 {
 func Adduint8(ctxt *Link, s *Symbol, v uint8) int64 {
 	off := s.Size
 	if s.Type == 0 {
-		s.Type = obj.SDATA
+		s.Type = objabi.SDATA
 	}
 	s.Attr |= AttrReachable
 	s.Size++
@@ -142,7 +142,7 @@ func setuint32(ctxt *Link, s *Symbol, r int64, v uint32) int64 {
 
 func Addaddrplus(ctxt *Link, s *Symbol, t *Symbol, add int64) int64 {
 	if s.Type == 0 {
-		s.Type = obj.SDATA
+		s.Type = objabi.SDATA
 	}
 	s.Attr |= AttrReachable
 	i := s.Size
@@ -152,14 +152,14 @@ func Addaddrplus(ctxt *Link, s *Symbol, t *Symbol, add int64) int64 {
 	r.Sym = t
 	r.Off = int32(i)
 	r.Siz = uint8(ctxt.Arch.PtrSize)
-	r.Type = obj.R_ADDR
+	r.Type = objabi.R_ADDR
 	r.Add = add
 	return i + int64(r.Siz)
 }
 
 func Addpcrelplus(ctxt *Link, s *Symbol, t *Symbol, add int64) int64 {
 	if s.Type == 0 {
-		s.Type = obj.SDATA
+		s.Type = objabi.SDATA
 	}
 	s.Attr |= AttrReachable
 	i := s.Size
@@ -169,7 +169,7 @@ func Addpcrelplus(ctxt *Link, s *Symbol, t *Symbol, add int64) int64 {
 	r.Sym = t
 	r.Off = int32(i)
 	r.Add = add
-	r.Type = obj.R_PCREL
+	r.Type = objabi.R_PCREL
 	r.Siz = 4
 	if SysArch.Family == sys.S390X {
 		r.Variant = RV_390_DBL
@@ -183,7 +183,7 @@ func Addaddr(ctxt *Link, s *Symbol, t *Symbol) int64 {
 
 func setaddrplus(ctxt *Link, s *Symbol, off int64, t *Symbol, add int64) int64 {
 	if s.Type == 0 {
-		s.Type = obj.SDATA
+		s.Type = objabi.SDATA
 	}
 	s.Attr |= AttrReachable
 	if off+int64(ctxt.Arch.PtrSize) > s.Size {
@@ -195,7 +195,7 @@ func setaddrplus(ctxt *Link, s *Symbol, off int64, t *Symbol, add int64) int64 {
 	r.Sym = t
 	r.Off = int32(off)
 	r.Siz = uint8(ctxt.Arch.PtrSize)
-	r.Type = obj.R_ADDR
+	r.Type = objabi.R_ADDR
 	r.Add = add
 	return off + int64(r.Siz)
 }
@@ -206,7 +206,7 @@ func setaddr(ctxt *Link, s *Symbol, off int64, t *Symbol) int64 {
 
 func addsize(ctxt *Link, s *Symbol, t *Symbol) int64 {
 	if s.Type == 0 {
-		s.Type = obj.SDATA
+		s.Type = objabi.SDATA
 	}
 	s.Attr |= AttrReachable
 	i := s.Size
@@ -216,13 +216,13 @@ func addsize(ctxt *Link, s *Symbol, t *Symbol) int64 {
 	r.Sym = t
 	r.Off = int32(i)
 	r.Siz = uint8(ctxt.Arch.PtrSize)
-	r.Type = obj.R_SIZE
+	r.Type = objabi.R_SIZE
 	return i + int64(r.Siz)
 }
 
 func addaddrplus4(ctxt *Link, s *Symbol, t *Symbol, add int64) int64 {
 	if s.Type == 0 {
-		s.Type = obj.SDATA
+		s.Type = objabi.SDATA
 	}
 	s.Attr |= AttrReachable
 	i := s.Size
@@ -232,7 +232,7 @@ func addaddrplus4(ctxt *Link, s *Symbol, t *Symbol, add int64) int64 {
 	r.Sym = t
 	r.Off = int32(i)
 	r.Siz = 4
-	r.Type = obj.R_ADDR
+	r.Type = objabi.R_ADDR
 	r.Add = add
 	return i + int64(r.Siz)
 }
@@ -341,7 +341,7 @@ func trampoline(ctxt *Link, s *Symbol) {
 		if !r.Type.IsDirectJump() {
 			continue
 		}
-		if Symaddr(r.Sym) == 0 && r.Sym.Type != obj.SDYNIMPORT {
+		if Symaddr(r.Sym) == 0 && r.Sym.Type != objabi.SDYNIMPORT {
 			if r.Sym.File != s.File {
 				if !isRuntimeDepPkg(s.File) || !isRuntimeDepPkg(r.Sym.File) {
 					Errorf(s, "unresolved inter-package jump to %s(%s)", r.Sym, r.Sym.File)
@@ -382,12 +382,12 @@ func relocsym(ctxt *Link, s *Symbol) {
 			continue
 		}
 
-		if r.Sym != nil && (r.Sym.Type&(obj.SMASK|obj.SHIDDEN) == 0 || r.Sym.Type&obj.SMASK == obj.SXREF) {
+		if r.Sym != nil && (r.Sym.Type&(objabi.SMASK|objabi.SHIDDEN) == 0 || r.Sym.Type&objabi.SMASK == objabi.SXREF) {
 			// When putting the runtime but not main into a shared library
 			// these symbols are undefined and that's OK.
 			if Buildmode == BuildmodeShared {
 				if r.Sym.Name == "main.main" || r.Sym.Name == "main.init" {
-					r.Sym.Type = obj.SDYNIMPORT
+					r.Sym.Type = objabi.SDYNIMPORT
 				} else if strings.HasPrefix(r.Sym.Name, "go.info.") {
 					// Skip go.info symbols. They are only needed to communicate
 					// DWARF info between the compiler and linker.
@@ -408,22 +408,22 @@ func relocsym(ctxt *Link, s *Symbol) {
 
 		// We need to be able to reference dynimport symbols when linking against
 		// shared libraries, and Solaris needs it always
-		if Headtype != obj.Hsolaris && r.Sym != nil && r.Sym.Type == obj.SDYNIMPORT && !ctxt.DynlinkingGo() {
+		if Headtype != objabi.Hsolaris && r.Sym != nil && r.Sym.Type == objabi.SDYNIMPORT && !ctxt.DynlinkingGo() {
 			if !(SysArch.Family == sys.PPC64 && Linkmode == LinkExternal && r.Sym.Name == ".TOC.") {
 				Errorf(s, "unhandled relocation for %s (type %d rtype %d)", r.Sym.Name, r.Sym.Type, r.Type)
 			}
 		}
-		if r.Sym != nil && r.Sym.Type != obj.STLSBSS && r.Type != obj.R_WEAKADDROFF && !r.Sym.Attr.Reachable() {
+		if r.Sym != nil && r.Sym.Type != objabi.STLSBSS && r.Type != objabi.R_WEAKADDROFF && !r.Sym.Attr.Reachable() {
 			Errorf(s, "unreachable sym in relocation: %s", r.Sym.Name)
 		}
 
 		// TODO(mundaym): remove this special case - see issue 14218.
 		if SysArch.Family == sys.S390X {
 			switch r.Type {
-			case obj.R_PCRELDBL:
-				r.Type = obj.R_PCREL
+			case objabi.R_PCRELDBL:
+				r.Type = objabi.R_PCREL
 				r.Variant = RV_390_DBL
-			case obj.R_CALL:
+			case objabi.R_CALL:
 				r.Variant = RV_390_DBL
 			}
 		}
@@ -446,8 +446,8 @@ func relocsym(ctxt *Link, s *Symbol) {
 				Errorf(s, "unknown reloc to %v: %v", r.Sym.Name, r.Type)
 			}
 
-		case obj.R_TLS_LE:
-			isAndroidX86 := obj.GOOS == "android" && (SysArch.InFamily(sys.AMD64, sys.I386))
+		case objabi.R_TLS_LE:
+			isAndroidX86 := objabi.GOOS == "android" && (SysArch.InFamily(sys.AMD64, sys.I386))
 
 			if Linkmode == LinkExternal && Iself && !isAndroidX86 {
 				r.Done = 0
@@ -472,16 +472,16 @@ func relocsym(ctxt *Link, s *Symbol) {
 				// related to the fact that our own TLS storage happens
 				// to take up 8 bytes.
 				o = 8 + r.Sym.Value
-			} else if Iself || Headtype == obj.Hplan9 || Headtype == obj.Hdarwin || isAndroidX86 {
+			} else if Iself || Headtype == objabi.Hplan9 || Headtype == objabi.Hdarwin || isAndroidX86 {
 				o = int64(ctxt.Tlsoffset) + r.Add
-			} else if Headtype == obj.Hwindows {
+			} else if Headtype == objabi.Hwindows {
 				o = r.Add
 			} else {
 				log.Fatalf("unexpected R_TLS_LE relocation for %v", Headtype)
 			}
 
-		case obj.R_TLS_IE:
-			isAndroidX86 := obj.GOOS == "android" && (SysArch.InFamily(sys.AMD64, sys.I386))
+		case objabi.R_TLS_IE:
+			isAndroidX86 := objabi.GOOS == "android" && (SysArch.InFamily(sys.AMD64, sys.I386))
 
 			if Linkmode == LinkExternal && Iself && !isAndroidX86 {
 				r.Done = 0
@@ -511,8 +511,8 @@ func relocsym(ctxt *Link, s *Symbol) {
 				log.Fatalf("cannot handle R_TLS_IE (sym %s) when linking internally", s.Name)
 			}
 
-		case obj.R_ADDR:
-			if Linkmode == LinkExternal && r.Sym.Type != obj.SCONST {
+		case objabi.R_ADDR:
+			if Linkmode == LinkExternal && r.Sym.Type != objabi.SCONST {
 				r.Done = 0
 
 				// set up addend for eventual relocation via outer symbol.
@@ -524,7 +524,7 @@ func relocsym(ctxt *Link, s *Symbol) {
 					rs = rs.Outer
 				}
 
-				if rs.Type != obj.SHOSTOBJ && rs.Type != obj.SDYNIMPORT && rs.Sect == nil {
+				if rs.Type != objabi.SHOSTOBJ && rs.Type != objabi.SDYNIMPORT && rs.Sect == nil {
 					Errorf(s, "missing section for relocation target %s", rs.Name)
 				}
 				r.Xsym = rs
@@ -534,13 +534,13 @@ func relocsym(ctxt *Link, s *Symbol) {
 					if SysArch.Family == sys.AMD64 {
 						o = 0
 					}
-				} else if Headtype == obj.Hdarwin {
+				} else if Headtype == objabi.Hdarwin {
 					// ld64 for arm64 has a bug where if the address pointed to by o exists in the
 					// symbol table (dynid >= 0), or is inside a symbol that exists in the symbol
 					// table, then it will add o twice into the relocated value.
 					// The workaround is that on arm64 don't ever add symaddr to o and always use
 					// extern relocation by requiring rs->dynid >= 0.
-					if rs.Type != obj.SHOSTOBJ {
+					if rs.Type != objabi.SHOSTOBJ {
 						if SysArch.Family == sys.ARM64 && rs.Dynid < 0 {
 							Errorf(s, "R_ADDR reloc to %s+%d is not supported on darwin/arm64", rs.Name, o)
 						}
@@ -548,7 +548,7 @@ func relocsym(ctxt *Link, s *Symbol) {
 							o += Symaddr(rs)
 						}
 					}
-				} else if Headtype == obj.Hwindows {
+				} else if Headtype == objabi.Hwindows {
 					// nothing to do
 				} else {
 					Errorf(s, "unhandled pcrel relocation to %s on %v", rs.Name, Headtype)
@@ -569,7 +569,7 @@ func relocsym(ctxt *Link, s *Symbol) {
 				errorexit()
 			}
 
-		case obj.R_DWARFREF:
+		case objabi.R_DWARFREF:
 			if r.Sym.Sect == nil {
 				Errorf(s, "missing DWARF section for relocation target %s", r.Sym.Name)
 			}
@@ -580,8 +580,8 @@ func relocsym(ctxt *Link, s *Symbol) {
 				// IMAGE_REL_I386_DIR32, IMAGE_REL_AMD64_ADDR64 and IMAGE_REL_AMD64_ADDR32.
 				// Do not replace R_DWARFREF with R_ADDR for windows -
 				// let PE code emit correct relocations.
-				if Headtype != obj.Hwindows {
-					r.Type = obj.R_ADDR
+				if Headtype != objabi.Hwindows {
+					r.Type = objabi.R_ADDR
 				}
 
 				r.Xsym = ctxt.Syms.ROLookup(r.Sym.Sect.Name, 0)
@@ -595,12 +595,12 @@ func relocsym(ctxt *Link, s *Symbol) {
 			}
 			o = Symaddr(r.Sym) + r.Add - int64(r.Sym.Sect.Vaddr)
 
-		case obj.R_WEAKADDROFF:
+		case objabi.R_WEAKADDROFF:
 			if !r.Sym.Attr.Reachable() {
 				continue
 			}
 			fallthrough
-		case obj.R_ADDROFF:
+		case objabi.R_ADDROFF:
 			// The method offset tables using this relocation expect the offset to be relative
 			// to the start of the first text section, even if there are multiple.
 
@@ -611,8 +611,8 @@ func relocsym(ctxt *Link, s *Symbol) {
 			}
 
 			// r->sym can be null when CALL $(constant) is transformed from absolute PC to relative PC call.
-		case obj.R_GOTPCREL:
-			if ctxt.DynlinkingGo() && Headtype == obj.Hdarwin && r.Sym != nil && r.Sym.Type != obj.SCONST {
+		case objabi.R_GOTPCREL:
+			if ctxt.DynlinkingGo() && Headtype == objabi.Hdarwin && r.Sym != nil && r.Sym.Type != objabi.SCONST {
 				r.Done = 0
 				r.Xadd = r.Add
 				r.Xadd -= int64(r.Siz) // relative to address after the relocated chunk
@@ -623,8 +623,8 @@ func relocsym(ctxt *Link, s *Symbol) {
 				break
 			}
 			fallthrough
-		case obj.R_CALL, obj.R_PCREL:
-			if Linkmode == LinkExternal && r.Sym != nil && r.Sym.Type != obj.SCONST && (r.Sym.Sect != s.Sect || r.Type == obj.R_GOTPCREL) {
+		case objabi.R_CALL, objabi.R_PCREL:
+			if Linkmode == LinkExternal && r.Sym != nil && r.Sym.Type != objabi.SCONST && (r.Sym.Sect != s.Sect || r.Type == objabi.R_GOTPCREL) {
 				r.Done = 0
 
 				// set up addend for eventual relocation via outer symbol.
@@ -637,7 +637,7 @@ func relocsym(ctxt *Link, s *Symbol) {
 				}
 
 				r.Xadd -= int64(r.Siz) // relative to address after the relocated chunk
-				if rs.Type != obj.SHOSTOBJ && rs.Type != obj.SDYNIMPORT && rs.Sect == nil {
+				if rs.Type != objabi.SHOSTOBJ && rs.Type != objabi.SDYNIMPORT && rs.Sect == nil {
 					Errorf(s, "missing section for relocation target %s", rs.Name)
 				}
 				r.Xsym = rs
@@ -647,9 +647,9 @@ func relocsym(ctxt *Link, s *Symbol) {
 					if SysArch.Family == sys.AMD64 {
 						o = 0
 					}
-				} else if Headtype == obj.Hdarwin {
-					if r.Type == obj.R_CALL {
-						if rs.Type != obj.SHOSTOBJ {
+				} else if Headtype == objabi.Hdarwin {
+					if r.Type == objabi.R_CALL {
+						if rs.Type != objabi.SHOSTOBJ {
 							o += int64(uint64(Symaddr(rs)) - rs.Sect.Vaddr)
 						}
 						o -= int64(r.Off) // relative to section offset, not symbol
@@ -659,7 +659,7 @@ func relocsym(ctxt *Link, s *Symbol) {
 					} else {
 						o += int64(r.Siz)
 					}
-				} else if Headtype == obj.Hwindows && SysArch.Family == sys.AMD64 { // only amd64 needs PCREL
+				} else if Headtype == objabi.Hwindows && SysArch.Family == sys.AMD64 { // only amd64 needs PCREL
 					// PE/COFF's PC32 relocation uses the address after the relocated
 					// bytes as the base. Compensate by skewing the addend.
 					o += int64(r.Siz)
@@ -677,7 +677,7 @@ func relocsym(ctxt *Link, s *Symbol) {
 
 			o += r.Add - (s.Value + int64(r.Off) + int64(r.Siz))
 
-		case obj.R_SIZE:
+		case objabi.R_SIZE:
 			o = r.Sym.Size + r.Add
 		}
 
@@ -709,7 +709,7 @@ func relocsym(ctxt *Link, s *Symbol) {
 			ctxt.Arch.ByteOrder.PutUint16(s.P[off:], uint16(i16))
 
 		case 4:
-			if r.Type == obj.R_PCREL || r.Type == obj.R_CALL {
+			if r.Type == objabi.R_PCREL || r.Type == objabi.R_CALL {
 				if o != int64(int32(o)) {
 					Errorf(s, "pc-relative relocation address for %s is too big: %#x", r.Sym.Name, o)
 				}
@@ -730,7 +730,7 @@ func relocsym(ctxt *Link, s *Symbol) {
 
 func (ctxt *Link) reloc() {
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f reloc\n", obj.Cputime())
+		ctxt.Logf("%5.2f reloc\n", Cputime())
 	}
 
 	for _, s := range ctxt.Textp {
@@ -745,7 +745,7 @@ func (ctxt *Link) reloc() {
 }
 
 func dynrelocsym(ctxt *Link, s *Symbol) {
-	if Headtype == obj.Hwindows && Linkmode != LinkExternal {
+	if Headtype == objabi.Hwindows && Linkmode != LinkExternal {
 		rel := ctxt.Syms.Lookup(".rel", 0)
 		if s == rel {
 			return
@@ -757,7 +757,7 @@ func dynrelocsym(ctxt *Link, s *Symbol) {
 				continue
 			}
 			if !targ.Attr.Reachable() {
-				if r.Type == obj.R_WEAKADDROFF {
+				if r.Type == objabi.R_WEAKADDROFF {
 					continue
 				}
 				Errorf(s, "dynamic relocation to unreachable symbol %s", targ.Name)
@@ -799,7 +799,7 @@ func dynrelocsym(ctxt *Link, s *Symbol) {
 			Thearch.Adddynrel(ctxt, s, r)
 			continue
 		}
-		if r.Sym != nil && r.Sym.Type == obj.SDYNIMPORT || r.Type >= 256 {
+		if r.Sym != nil && r.Sym.Type == objabi.SDYNIMPORT || r.Type >= 256 {
 			if r.Sym != nil && !r.Sym.Attr.Reachable() {
 				Errorf(s, "dynamic relocation to unreachable symbol %s", r.Sym.Name)
 			}
@@ -810,14 +810,14 @@ func dynrelocsym(ctxt *Link, s *Symbol) {
 	}
 }
 
-func dynreloc(ctxt *Link, data *[obj.SXREF][]*Symbol) {
+func dynreloc(ctxt *Link, data *[objabi.SXREF][]*Symbol) {
 	// -d suppresses dynamic loader format, so we may as well not
 	// compute these sections or mark their symbols as reachable.
-	if *FlagD && Headtype != obj.Hwindows {
+	if *FlagD && Headtype != objabi.Hwindows {
 		return
 	}
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f reloc\n", obj.Cputime())
+		ctxt.Logf("%5.2f reloc\n", Cputime())
 	}
 
 	for _, s := range ctxt.Textp {
@@ -902,7 +902,7 @@ func CodeblkPad(ctxt *Link, addr int64, size int64, pad []byte) {
 
 func blk(ctxt *Link, syms []*Symbol, addr, size int64, pad []byte) {
 	for i, s := range syms {
-		if s.Type&obj.SSUB == 0 && s.Value >= addr {
+		if s.Type&objabi.SSUB == 0 && s.Value >= addr {
 			syms = syms[i:]
 			break
 		}
@@ -910,7 +910,7 @@ func blk(ctxt *Link, syms []*Symbol, addr, size int64, pad []byte) {
 
 	eaddr := addr + size
 	for _, s := range syms {
-		if s.Type&obj.SSUB != 0 {
+		if s.Type&objabi.SSUB != 0 {
 			continue
 		}
 		if s.Value >= eaddr {
@@ -999,11 +999,11 @@ func Datblk(ctxt *Link, addr int64, size int64) {
 			}
 			typ := "?"
 			switch r.Type {
-			case obj.R_ADDR:
+			case objabi.R_ADDR:
 				typ = "addr"
-			case obj.R_PCREL:
+			case objabi.R_PCREL:
 				typ = "pcrel"
-			case obj.R_CALL:
+			case objabi.R_CALL:
 				typ = "call"
 			}
 			ctxt.Logf("\treloc %.8x/%d %s %s+%#x [%#x]\n", uint(sym.Value+int64(r.Off)), r.Siz, typ, rsname, r.Add, r.Sym.Value+r.Add)
@@ -1067,7 +1067,7 @@ func addstrdata(ctxt *Link, name string, value string) {
 	sp := ctxt.Syms.Lookup(p, 0)
 
 	Addstring(sp, value)
-	sp.Type = obj.SRODATA
+	sp.Type = objabi.SRODATA
 
 	s := ctxt.Syms.Lookup(name, 0)
 	s.Size = 0
@@ -1088,7 +1088,7 @@ func addstrdata(ctxt *Link, name string, value string) {
 
 func (ctxt *Link) checkstrdata() {
 	for _, s := range strdata {
-		if s.Type == obj.STEXT {
+		if s.Type == objabi.STEXT {
 			Errorf(s, "cannot use -X with text symbol")
 		} else if s.Gotype != nil && s.Gotype.Name != "type.string" {
 			Errorf(s, "cannot use -X with non-string symbol")
@@ -1098,7 +1098,7 @@ func (ctxt *Link) checkstrdata() {
 
 func Addstring(s *Symbol, str string) int64 {
 	if s.Type == 0 {
-		s.Type = obj.SNOPTRDATA
+		s.Type = objabi.SNOPTRDATA
 	}
 	s.Attr |= AttrReachable
 	r := s.Size
@@ -1115,12 +1115,12 @@ func Addstring(s *Symbol, str string) int64 {
 // symbol used to define the string data and must be unique per linked object.
 func addgostring(ctxt *Link, s *Symbol, symname, str string) {
 	sym := ctxt.Syms.Lookup(symname, 0)
-	if sym.Type != obj.Sxxx {
+	if sym.Type != objabi.Sxxx {
 		Errorf(s, "duplicate symname in addgostring: %s", symname)
 	}
 	sym.Attr |= AttrReachable
 	sym.Attr |= AttrLocal
-	sym.Type = obj.SRODATA
+	sym.Type = objabi.SRODATA
 	sym.Size = int64(len(str))
 	sym.P = []byte(str)
 	Addaddr(ctxt, s, sym)
@@ -1130,7 +1130,7 @@ func addgostring(ctxt *Link, s *Symbol, symname, str string) {
 func addinitarrdata(ctxt *Link, s *Symbol) {
 	p := s.Name + ".ptr"
 	sp := ctxt.Syms.Lookup(p, 0)
-	sp.Type = obj.SINITARR
+	sp.Type = objabi.SINITARR
 	sp.Size = 0
 	sp.Attr |= AttrDuplicateOK
 	Addaddr(ctxt, sp, s)
@@ -1139,11 +1139,11 @@ func addinitarrdata(ctxt *Link, s *Symbol) {
 func dosymtype(ctxt *Link) {
 	for _, s := range ctxt.Syms.Allsym {
 		if len(s.P) > 0 {
-			if s.Type == obj.SBSS {
-				s.Type = obj.SDATA
+			if s.Type == objabi.SBSS {
+				s.Type = objabi.SDATA
 			}
-			if s.Type == obj.SNOPTRBSS {
-				s.Type = obj.SNOPTRDATA
+			if s.Type == objabi.SNOPTRBSS {
+				s.Type = objabi.SNOPTRDATA
 			}
 		}
 		// Create a new entry in the .init_array section that points to the
@@ -1275,7 +1275,7 @@ func (d bySizeAndName) Less(i, j int) bool {
 
 const cutoff int64 = 2e9 // 2 GB (or so; looks better in errors than 2^31)
 
-func checkdatsize(ctxt *Link, datsize int64, symn obj.SymKind) {
+func checkdatsize(ctxt *Link, datsize int64, symn objabi.SymKind) {
 	if datsize > cutoff {
 		Errorf(nil, "too much data in section %v (over %d bytes)", symn, cutoff)
 	}
@@ -1287,10 +1287,10 @@ var datap []*Symbol
 
 func (ctxt *Link) dodata() {
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f dodata\n", obj.Cputime())
+		ctxt.Logf("%5.2f dodata\n", Cputime())
 	}
 
-	if ctxt.DynlinkingGo() && Headtype == obj.Hdarwin {
+	if ctxt.DynlinkingGo() && Headtype == objabi.Hdarwin {
 		// The values in moduledata are filled out by relocations
 		// pointing to the addresses of these special symbols.
 		// Typically these symbols have no size and are not laid
@@ -1321,22 +1321,22 @@ func (ctxt *Link) dodata() {
 		ctxt.Syms.Lookup("runtime.edata", 0).Attr.Set(AttrSpecial, false)
 
 		types := ctxt.Syms.Lookup("runtime.types", 0)
-		types.Type = obj.STYPE
+		types.Type = objabi.STYPE
 		types.Size = 8
 		types.Attr.Set(AttrSpecial, false)
 
 		etypes := ctxt.Syms.Lookup("runtime.etypes", 0)
-		etypes.Type = obj.SFUNCTAB
+		etypes.Type = objabi.SFUNCTAB
 		etypes.Attr.Set(AttrSpecial, false)
 	}
 
 	// Collect data symbols by type into data.
-	var data [obj.SXREF][]*Symbol
+	var data [objabi.SXREF][]*Symbol
 	for _, s := range ctxt.Syms.Allsym {
 		if !s.Attr.Reachable() || s.Attr.Special() {
 			continue
 		}
-		if s.Type <= obj.STEXT || s.Type >= obj.SXREF {
+		if s.Type <= objabi.STEXT || s.Type >= objabi.SXREF {
 			continue
 		}
 		data[s.Type] = append(data[s.Type], s)
@@ -1348,7 +1348,7 @@ func (ctxt *Link) dodata() {
 	// symbol, which is itself data.
 	//
 	// On darwin, we need the symbol table numbers for dynreloc.
-	if Headtype == obj.Hdarwin {
+	if Headtype == objabi.Hdarwin {
 		machosymorder(ctxt)
 	}
 	dynreloc(ctxt, &data)
@@ -1357,8 +1357,8 @@ func (ctxt *Link) dodata() {
 		// "read only" data with relocations needs to go in its own section
 		// when building a shared library. We do this by boosting objects of
 		// type SXXX with relocations to type SXXXRELRO.
-		for _, symnro := range obj.ReadOnly {
-			symnrelro := obj.RelROMap[symnro]
+		for _, symnro := range objabi.ReadOnly {
+			symnrelro := objabi.RelROMap[symnro]
 
 			ro := []*Symbol{}
 			relro := data[symnrelro]
@@ -1366,7 +1366,7 @@ func (ctxt *Link) dodata() {
 			for _, s := range data[symnro] {
 				isRelro := len(s.R) > 0
 				switch s.Type {
-				case obj.STYPE, obj.STYPERELRO, obj.SGOFUNCRELRO:
+				case objabi.STYPE, objabi.STYPERELRO, objabi.SGOFUNCRELRO:
 					// Symbols are not sorted yet, so it is possible
 					// that an Outer symbol has been changed to a
 					// relro Type before it reaches here.
@@ -1400,10 +1400,10 @@ func (ctxt *Link) dodata() {
 	}
 
 	// Sort symbols.
-	var dataMaxAlign [obj.SXREF]int32
+	var dataMaxAlign [objabi.SXREF]int32
 	var wg sync.WaitGroup
 	for symn := range data {
-		symn := obj.SymKind(symn)
+		symn := objabi.SymKind(symn)
 		wg.Add(1)
 		go func() {
 			data[symn], dataMaxAlign[symn] = dodataSect(ctxt, symn, data[symn])
@@ -1419,11 +1419,11 @@ func (ctxt *Link) dodata() {
 	datsize := int64(0)
 
 	// Writable data sections that do not need any specialized handling.
-	writable := []obj.SymKind{
-		obj.SELFSECT,
-		obj.SMACHO,
-		obj.SMACHOGOT,
-		obj.SWINDOWS,
+	writable := []objabi.SymKind{
+		objabi.SELFSECT,
+		objabi.SMACHO,
+		objabi.SMACHOGOT,
+		objabi.SWINDOWS,
 	}
 	for _, symn := range writable {
 		for _, s := range data[symn] {
@@ -1432,7 +1432,7 @@ func (ctxt *Link) dodata() {
 			datsize = Rnd(datsize, int64(sect.Align))
 			sect.Vaddr = uint64(datsize)
 			s.Sect = sect
-			s.Type = obj.SDATA
+			s.Type = objabi.SDATA
 			s.Value = int64(uint64(datsize) - sect.Vaddr)
 			datsize += s.Size
 			sect.Length = uint64(datsize) - sect.Vaddr
@@ -1441,16 +1441,16 @@ func (ctxt *Link) dodata() {
 	}
 
 	// .got (and .toc on ppc64)
-	if len(data[obj.SELFGOT]) > 0 {
+	if len(data[objabi.SELFGOT]) > 0 {
 		sect := addsection(&Segdata, ".got", 06)
-		sect.Align = dataMaxAlign[obj.SELFGOT]
+		sect.Align = dataMaxAlign[objabi.SELFGOT]
 		datsize = Rnd(datsize, int64(sect.Align))
 		sect.Vaddr = uint64(datsize)
 		var toc *Symbol
-		for _, s := range data[obj.SELFGOT] {
+		for _, s := range data[objabi.SELFGOT] {
 			datsize = aligndatsize(datsize, s)
 			s.Sect = sect
-			s.Type = obj.SDATA
+			s.Type = objabi.SDATA
 			s.Value = int64(uint64(datsize) - sect.Vaddr)
 
 			// Resolve .TOC. symbol for this object file (ppc64)
@@ -1466,25 +1466,25 @@ func (ctxt *Link) dodata() {
 
 			datsize += s.Size
 		}
-		checkdatsize(ctxt, datsize, obj.SELFGOT)
+		checkdatsize(ctxt, datsize, objabi.SELFGOT)
 		sect.Length = uint64(datsize) - sect.Vaddr
 	}
 
 	/* pointer-free data */
 	sect := addsection(&Segdata, ".noptrdata", 06)
-	sect.Align = dataMaxAlign[obj.SNOPTRDATA]
+	sect.Align = dataMaxAlign[objabi.SNOPTRDATA]
 	datsize = Rnd(datsize, int64(sect.Align))
 	sect.Vaddr = uint64(datsize)
 	ctxt.Syms.Lookup("runtime.noptrdata", 0).Sect = sect
 	ctxt.Syms.Lookup("runtime.enoptrdata", 0).Sect = sect
-	for _, s := range data[obj.SNOPTRDATA] {
+	for _, s := range data[objabi.SNOPTRDATA] {
 		datsize = aligndatsize(datsize, s)
 		s.Sect = sect
-		s.Type = obj.SDATA
+		s.Type = objabi.SDATA
 		s.Value = int64(uint64(datsize) - sect.Vaddr)
 		datsize += s.Size
 	}
-	checkdatsize(ctxt, datsize, obj.SNOPTRDATA)
+	checkdatsize(ctxt, datsize, objabi.SNOPTRDATA)
 	sect.Length = uint64(datsize) - sect.Vaddr
 
 	hasinitarr := *FlagLinkshared
@@ -1496,68 +1496,68 @@ func (ctxt *Link) dodata() {
 	}
 	if hasinitarr {
 		sect := addsection(&Segdata, ".init_array", 06)
-		sect.Align = dataMaxAlign[obj.SINITARR]
+		sect.Align = dataMaxAlign[objabi.SINITARR]
 		datsize = Rnd(datsize, int64(sect.Align))
 		sect.Vaddr = uint64(datsize)
-		for _, s := range data[obj.SINITARR] {
+		for _, s := range data[objabi.SINITARR] {
 			datsize = aligndatsize(datsize, s)
 			s.Sect = sect
 			s.Value = int64(uint64(datsize) - sect.Vaddr)
 			datsize += s.Size
 		}
 		sect.Length = uint64(datsize) - sect.Vaddr
-		checkdatsize(ctxt, datsize, obj.SINITARR)
+		checkdatsize(ctxt, datsize, objabi.SINITARR)
 	}
 
 	/* data */
 	sect = addsection(&Segdata, ".data", 06)
-	sect.Align = dataMaxAlign[obj.SDATA]
+	sect.Align = dataMaxAlign[objabi.SDATA]
 	datsize = Rnd(datsize, int64(sect.Align))
 	sect.Vaddr = uint64(datsize)
 	ctxt.Syms.Lookup("runtime.data", 0).Sect = sect
 	ctxt.Syms.Lookup("runtime.edata", 0).Sect = sect
 	var gc GCProg
 	gc.Init(ctxt, "runtime.gcdata")
-	for _, s := range data[obj.SDATA] {
+	for _, s := range data[objabi.SDATA] {
 		s.Sect = sect
-		s.Type = obj.SDATA
+		s.Type = objabi.SDATA
 		datsize = aligndatsize(datsize, s)
 		s.Value = int64(uint64(datsize) - sect.Vaddr)
 		gc.AddSym(s)
 		datsize += s.Size
 	}
-	checkdatsize(ctxt, datsize, obj.SDATA)
+	checkdatsize(ctxt, datsize, objabi.SDATA)
 	sect.Length = uint64(datsize) - sect.Vaddr
 	gc.End(int64(sect.Length))
 
 	/* bss */
 	sect = addsection(&Segdata, ".bss", 06)
-	sect.Align = dataMaxAlign[obj.SBSS]
+	sect.Align = dataMaxAlign[objabi.SBSS]
 	datsize = Rnd(datsize, int64(sect.Align))
 	sect.Vaddr = uint64(datsize)
 	ctxt.Syms.Lookup("runtime.bss", 0).Sect = sect
 	ctxt.Syms.Lookup("runtime.ebss", 0).Sect = sect
 	gc = GCProg{}
 	gc.Init(ctxt, "runtime.gcbss")
-	for _, s := range data[obj.SBSS] {
+	for _, s := range data[objabi.SBSS] {
 		s.Sect = sect
 		datsize = aligndatsize(datsize, s)
 		s.Value = int64(uint64(datsize) - sect.Vaddr)
 		gc.AddSym(s)
 		datsize += s.Size
 	}
-	checkdatsize(ctxt, datsize, obj.SBSS)
+	checkdatsize(ctxt, datsize, objabi.SBSS)
 	sect.Length = uint64(datsize) - sect.Vaddr
 	gc.End(int64(sect.Length))
 
 	/* pointer-free bss */
 	sect = addsection(&Segdata, ".noptrbss", 06)
-	sect.Align = dataMaxAlign[obj.SNOPTRBSS]
+	sect.Align = dataMaxAlign[objabi.SNOPTRBSS]
 	datsize = Rnd(datsize, int64(sect.Align))
 	sect.Vaddr = uint64(datsize)
 	ctxt.Syms.Lookup("runtime.noptrbss", 0).Sect = sect
 	ctxt.Syms.Lookup("runtime.enoptrbss", 0).Sect = sect
-	for _, s := range data[obj.SNOPTRBSS] {
+	for _, s := range data[objabi.SNOPTRBSS] {
 		datsize = aligndatsize(datsize, s)
 		s.Sect = sect
 		s.Value = int64(uint64(datsize) - sect.Vaddr)
@@ -1566,9 +1566,9 @@ func (ctxt *Link) dodata() {
 
 	sect.Length = uint64(datsize) - sect.Vaddr
 	ctxt.Syms.Lookup("runtime.end", 0).Sect = sect
-	checkdatsize(ctxt, datsize, obj.SNOPTRBSS)
+	checkdatsize(ctxt, datsize, objabi.SNOPTRBSS)
 
-	if len(data[obj.STLSBSS]) > 0 {
+	if len(data[objabi.STLSBSS]) > 0 {
 		var sect *Section
 		if Iself && (Linkmode == LinkExternal || !*FlagD) {
 			sect = addsection(&Segdata, ".tbss", 06)
@@ -1577,13 +1577,13 @@ func (ctxt *Link) dodata() {
 		}
 		datsize = 0
 
-		for _, s := range data[obj.STLSBSS] {
+		for _, s := range data[objabi.STLSBSS] {
 			datsize = aligndatsize(datsize, s)
 			s.Sect = sect
 			s.Value = datsize
 			datsize += s.Size
 		}
-		checkdatsize(ctxt, datsize, obj.STLSBSS)
+		checkdatsize(ctxt, datsize, objabi.STLSBSS)
 
 		if sect != nil {
 			sect.Length = uint64(datsize)
@@ -1610,20 +1610,20 @@ func (ctxt *Link) dodata() {
 	datsize = 0
 
 	/* read-only executable ELF, Mach-O sections */
-	if len(data[obj.STEXT]) != 0 {
-		Errorf(nil, "dodata found an STEXT symbol: %s", data[obj.STEXT][0].Name)
+	if len(data[objabi.STEXT]) != 0 {
+		Errorf(nil, "dodata found an STEXT symbol: %s", data[objabi.STEXT][0].Name)
 	}
-	for _, s := range data[obj.SELFRXSECT] {
+	for _, s := range data[objabi.SELFRXSECT] {
 		sect := addsection(&Segtext, s.Name, 04)
 		sect.Align = symalign(s)
 		datsize = Rnd(datsize, int64(sect.Align))
 		sect.Vaddr = uint64(datsize)
 		s.Sect = sect
-		s.Type = obj.SRODATA
+		s.Type = objabi.SRODATA
 		s.Value = int64(uint64(datsize) - sect.Vaddr)
 		datsize += s.Size
 		sect.Length = uint64(datsize) - sect.Vaddr
-		checkdatsize(ctxt, datsize, obj.SELFRXSECT)
+		checkdatsize(ctxt, datsize, objabi.SELFRXSECT)
 	}
 
 	/* read-only data */
@@ -1636,18 +1636,18 @@ func (ctxt *Link) dodata() {
 		ctxt.Syms.Lookup("runtime.types", 0).Sect = sect
 		ctxt.Syms.Lookup("runtime.etypes", 0).Sect = sect
 	}
-	for _, symn := range obj.ReadOnly {
+	for _, symn := range objabi.ReadOnly {
 		align := dataMaxAlign[symn]
 		if sect.Align < align {
 			sect.Align = align
 		}
 	}
 	datsize = Rnd(datsize, int64(sect.Align))
-	for _, symn := range obj.ReadOnly {
+	for _, symn := range objabi.ReadOnly {
 		for _, s := range data[symn] {
 			datsize = aligndatsize(datsize, s)
 			s.Sect = sect
-			s.Type = obj.SRODATA
+			s.Type = objabi.SRODATA
 			s.Value = int64(uint64(datsize) - sect.Vaddr)
 			datsize += s.Size
 		}
@@ -1656,31 +1656,31 @@ func (ctxt *Link) dodata() {
 	sect.Length = uint64(datsize) - sect.Vaddr
 
 	/* read-only ELF, Mach-O sections */
-	for _, s := range data[obj.SELFROSECT] {
+	for _, s := range data[objabi.SELFROSECT] {
 		sect = addsection(segro, s.Name, 04)
 		sect.Align = symalign(s)
 		datsize = Rnd(datsize, int64(sect.Align))
 		sect.Vaddr = uint64(datsize)
 		s.Sect = sect
-		s.Type = obj.SRODATA
+		s.Type = objabi.SRODATA
 		s.Value = int64(uint64(datsize) - sect.Vaddr)
 		datsize += s.Size
 		sect.Length = uint64(datsize) - sect.Vaddr
 	}
-	checkdatsize(ctxt, datsize, obj.SELFROSECT)
+	checkdatsize(ctxt, datsize, objabi.SELFROSECT)
 
-	for _, s := range data[obj.SMACHOPLT] {
+	for _, s := range data[objabi.SMACHOPLT] {
 		sect = addsection(segro, s.Name, 04)
 		sect.Align = symalign(s)
 		datsize = Rnd(datsize, int64(sect.Align))
 		sect.Vaddr = uint64(datsize)
 		s.Sect = sect
-		s.Type = obj.SRODATA
+		s.Type = objabi.SRODATA
 		s.Value = int64(uint64(datsize) - sect.Vaddr)
 		datsize += s.Size
 		sect.Length = uint64(datsize) - sect.Vaddr
 	}
-	checkdatsize(ctxt, datsize, obj.SMACHOPLT)
+	checkdatsize(ctxt, datsize, objabi.SMACHOPLT)
 
 	// There is some data that are conceptually read-only but are written to by
 	// relocations. On GNU systems, we can arrange for the dynamic linker to
@@ -1716,23 +1716,23 @@ func (ctxt *Link) dodata() {
 		sect.Vaddr = 0
 		ctxt.Syms.Lookup("runtime.types", 0).Sect = sect
 		ctxt.Syms.Lookup("runtime.etypes", 0).Sect = sect
-		for _, symnro := range obj.ReadOnly {
-			symn := obj.RelROMap[symnro]
+		for _, symnro := range objabi.ReadOnly {
+			symn := objabi.RelROMap[symnro]
 			align := dataMaxAlign[symn]
 			if sect.Align < align {
 				sect.Align = align
 			}
 		}
 		datsize = Rnd(datsize, int64(sect.Align))
-		for _, symnro := range obj.ReadOnly {
-			symn := obj.RelROMap[symnro]
+		for _, symnro := range objabi.ReadOnly {
+			symn := objabi.RelROMap[symnro]
 			for _, s := range data[symn] {
 				datsize = aligndatsize(datsize, s)
 				if s.Outer != nil && s.Outer.Sect != nil && s.Outer.Sect != sect {
 					Errorf(s, "s.Outer (%s) in different section from s, %s != %s", s.Outer.Name, s.Outer.Sect.Name, sect.Name)
 				}
 				s.Sect = sect
-				s.Type = obj.SRODATA
+				s.Type = objabi.SRODATA
 				s.Value = int64(uint64(datsize) - sect.Vaddr)
 				datsize += s.Size
 			}
@@ -1744,65 +1744,65 @@ func (ctxt *Link) dodata() {
 
 	/* typelink */
 	sect = addrelrosection(".typelink")
-	sect.Align = dataMaxAlign[obj.STYPELINK]
+	sect.Align = dataMaxAlign[objabi.STYPELINK]
 	datsize = Rnd(datsize, int64(sect.Align))
 	sect.Vaddr = uint64(datsize)
 	typelink := ctxt.Syms.Lookup("runtime.typelink", 0)
 	typelink.Sect = sect
-	typelink.Type = obj.RODATA
+	typelink.Type = objabi.SRODATA
 	datsize += typelink.Size
-	checkdatsize(ctxt, datsize, obj.STYPELINK)
+	checkdatsize(ctxt, datsize, objabi.STYPELINK)
 	sect.Length = uint64(datsize) - sect.Vaddr
 
 	/* itablink */
 	sect = addrelrosection(".itablink")
-	sect.Align = dataMaxAlign[obj.SITABLINK]
+	sect.Align = dataMaxAlign[objabi.SITABLINK]
 	datsize = Rnd(datsize, int64(sect.Align))
 	sect.Vaddr = uint64(datsize)
 	ctxt.Syms.Lookup("runtime.itablink", 0).Sect = sect
 	ctxt.Syms.Lookup("runtime.eitablink", 0).Sect = sect
-	for _, s := range data[obj.SITABLINK] {
+	for _, s := range data[objabi.SITABLINK] {
 		datsize = aligndatsize(datsize, s)
 		s.Sect = sect
-		s.Type = obj.SRODATA
+		s.Type = objabi.SRODATA
 		s.Value = int64(uint64(datsize) - sect.Vaddr)
 		datsize += s.Size
 	}
-	checkdatsize(ctxt, datsize, obj.SITABLINK)
+	checkdatsize(ctxt, datsize, objabi.SITABLINK)
 	sect.Length = uint64(datsize) - sect.Vaddr
 
 	/* gosymtab */
 	sect = addrelrosection(".gosymtab")
-	sect.Align = dataMaxAlign[obj.SSYMTAB]
+	sect.Align = dataMaxAlign[objabi.SSYMTAB]
 	datsize = Rnd(datsize, int64(sect.Align))
 	sect.Vaddr = uint64(datsize)
 	ctxt.Syms.Lookup("runtime.symtab", 0).Sect = sect
 	ctxt.Syms.Lookup("runtime.esymtab", 0).Sect = sect
-	for _, s := range data[obj.SSYMTAB] {
+	for _, s := range data[objabi.SSYMTAB] {
 		datsize = aligndatsize(datsize, s)
 		s.Sect = sect
-		s.Type = obj.SRODATA
+		s.Type = objabi.SRODATA
 		s.Value = int64(uint64(datsize) - sect.Vaddr)
 		datsize += s.Size
 	}
-	checkdatsize(ctxt, datsize, obj.SSYMTAB)
+	checkdatsize(ctxt, datsize, objabi.SSYMTAB)
 	sect.Length = uint64(datsize) - sect.Vaddr
 
 	/* gopclntab */
 	sect = addrelrosection(".gopclntab")
-	sect.Align = dataMaxAlign[obj.SPCLNTAB]
+	sect.Align = dataMaxAlign[objabi.SPCLNTAB]
 	datsize = Rnd(datsize, int64(sect.Align))
 	sect.Vaddr = uint64(datsize)
 	ctxt.Syms.Lookup("runtime.pclntab", 0).Sect = sect
 	ctxt.Syms.Lookup("runtime.epclntab", 0).Sect = sect
-	for _, s := range data[obj.SPCLNTAB] {
+	for _, s := range data[objabi.SPCLNTAB] {
 		datsize = aligndatsize(datsize, s)
 		s.Sect = sect
-		s.Type = obj.SRODATA
+		s.Type = objabi.SRODATA
 		s.Value = int64(uint64(datsize) - sect.Vaddr)
 		datsize += s.Size
 	}
-	checkdatsize(ctxt, datsize, obj.SRODATA)
+	checkdatsize(ctxt, datsize, objabi.SRODATA)
 	sect.Length = uint64(datsize) - sect.Vaddr
 
 	// 6g uses 4-byte relocation offsets, so the entire segment must fit in 32 bits.
@@ -1810,7 +1810,7 @@ func (ctxt *Link) dodata() {
 		Errorf(nil, "read-only data segment too large: %d", datsize)
 	}
 
-	for symn := obj.SELFRXSECT; symn < obj.SXREF; symn++ {
+	for symn := objabi.SELFRXSECT; symn < objabi.SXREF; symn++ {
 		datap = append(datap, data[symn]...)
 	}
 
@@ -1819,7 +1819,7 @@ func (ctxt *Link) dodata() {
 	var s *Symbol
 	var i int
 	for i, s = range dwarfp {
-		if s.Type != obj.SDWARFSECT {
+		if s.Type != objabi.SDWARFSECT {
 			break
 		}
 		sect = addsection(&Segdwarf, s.Name, 04)
@@ -1827,12 +1827,12 @@ func (ctxt *Link) dodata() {
 		datsize = Rnd(datsize, int64(sect.Align))
 		sect.Vaddr = uint64(datsize)
 		s.Sect = sect
-		s.Type = obj.SRODATA
+		s.Type = objabi.SRODATA
 		s.Value = int64(uint64(datsize) - sect.Vaddr)
 		datsize += s.Size
 		sect.Length = uint64(datsize) - sect.Vaddr
 	}
-	checkdatsize(ctxt, datsize, obj.SDWARFSECT)
+	checkdatsize(ctxt, datsize, objabi.SDWARFSECT)
 
 	if i < len(dwarfp) {
 		sect = addsection(&Segdwarf, ".debug_info", 04)
@@ -1840,17 +1840,17 @@ func (ctxt *Link) dodata() {
 		datsize = Rnd(datsize, int64(sect.Align))
 		sect.Vaddr = uint64(datsize)
 		for _, s := range dwarfp[i:] {
-			if s.Type != obj.SDWARFINFO {
+			if s.Type != objabi.SDWARFINFO {
 				break
 			}
 			s.Sect = sect
-			s.Type = obj.SRODATA
+			s.Type = objabi.SRODATA
 			s.Value = int64(uint64(datsize) - sect.Vaddr)
 			s.Attr |= AttrLocal
 			datsize += s.Size
 		}
 		sect.Length = uint64(datsize) - sect.Vaddr
-		checkdatsize(ctxt, datsize, obj.SDWARFINFO)
+		checkdatsize(ctxt, datsize, objabi.SDWARFINFO)
 	}
 
 	/* number the sections */
@@ -1878,8 +1878,8 @@ func (ctxt *Link) dodata() {
 	}
 }
 
-func dodataSect(ctxt *Link, symn obj.SymKind, syms []*Symbol) (result []*Symbol, maxAlign int32) {
-	if Headtype == obj.Hdarwin {
+func dodataSect(ctxt *Link, symn objabi.SymKind, syms []*Symbol) (result []*Symbol, maxAlign int32) {
+	if Headtype == objabi.Hdarwin {
 		// Some symbols may no longer belong in syms
 		// due to movement in machosymorder.
 		newSyms := make([]*Symbol, 0, len(syms))
@@ -1910,7 +1910,7 @@ func dodataSect(ctxt *Link, symn obj.SymKind, syms []*Symbol) (result []*Symbol,
 		// If the usually-special section-marker symbols are being laid
 		// out as regular symbols, put them either at the beginning or
 		// end of their section.
-		if ctxt.DynlinkingGo() && Headtype == obj.Hdarwin {
+		if ctxt.DynlinkingGo() && Headtype == objabi.Hdarwin {
 			switch s.Name {
 			case "runtime.text", "runtime.bss", "runtime.data", "runtime.types":
 				head = s
@@ -1928,7 +1928,7 @@ func dodataSect(ctxt *Link, symn obj.SymKind, syms []*Symbol) (result []*Symbol,
 		}
 
 		switch s.Type {
-		case obj.SELFGOT:
+		case objabi.SELFGOT:
 			// For ppc64, we want to interleave the .got and .toc sections
 			// from input files. Both are type SELFGOT, so in that case
 			// we skip size comparison and fall through to the name
@@ -1957,7 +1957,7 @@ func dodataSect(ctxt *Link, symn obj.SymKind, syms []*Symbol) (result []*Symbol,
 		syms[len(syms)-1] = tail
 	}
 
-	if Iself && symn == obj.SELFROSECT {
+	if Iself && symn == objabi.SELFROSECT {
 		// Make .rela and .rela.plt contiguous, the ELF ABI requires this
 		// and Solaris actually cares.
 		reli, plti := -1, -1
@@ -2008,7 +2008,7 @@ func (ctxt *Link) textbuildid() {
 	// The \xff is invalid UTF-8, meant to make it less likely
 	// to find one of these accidentally.
 	data := "\xff Go build ID: " + strconv.Quote(*flagBuildid) + "\n \xff"
-	sym.Type = obj.STEXT
+	sym.Type = objabi.STEXT
 	sym.P = []byte(data)
 	sym.Size = int64(len(sym.P))
 
@@ -2031,7 +2031,7 @@ func (ctxt *Link) textaddress() {
 	text := ctxt.Syms.Lookup("runtime.text", 0)
 	text.Sect = sect
 
-	if ctxt.DynlinkingGo() && Headtype == obj.Hdarwin {
+	if ctxt.DynlinkingGo() && Headtype == objabi.Hdarwin {
 		etext := ctxt.Syms.Lookup("runtime.etext", 0)
 		etext.Sect = sect
 
@@ -2080,7 +2080,7 @@ func (ctxt *Link) textaddress() {
 // will not need to create new text sections, and so no need to return sect and n.
 func assignAddress(ctxt *Link, sect *Section, n int, sym *Symbol, va uint64) (*Section, int, uint64) {
 	sym.Sect = sect
-	if sym.Type&obj.SSUB != 0 {
+	if sym.Type&objabi.SSUB != 0 {
 		return sect, n, va
 	}
 	if sym.Align != 0 {
@@ -2140,7 +2140,7 @@ func (ctxt *Link) address() {
 
 	Segtext.Length = va - uint64(*FlagTextAddr)
 	Segtext.Filelen = Segtext.Length
-	if Headtype == obj.Hnacl {
+	if Headtype == objabi.Hnacl {
 		va += 32 // room for the "halt sled"
 	}
 
@@ -2197,10 +2197,10 @@ func (ctxt *Link) address() {
 	Segdata.Vaddr = va
 	Segdata.Fileoff = va - Segtext.Vaddr + Segtext.Fileoff
 	Segdata.Filelen = 0
-	if Headtype == obj.Hwindows {
+	if Headtype == objabi.Hwindows {
 		Segdata.Fileoff = Segtext.Fileoff + uint64(Rnd(int64(Segtext.Length), PEFILEALIGN))
 	}
-	if Headtype == obj.Hplan9 {
+	if Headtype == objabi.Hplan9 {
 		Segdata.Fileoff = Segtext.Fileoff + Segtext.Filelen
 	}
 	var data *Section
@@ -2240,7 +2240,7 @@ func (ctxt *Link) address() {
 	Segdwarf.Vaddr = va
 	Segdwarf.Fileoff = Segdata.Fileoff + uint64(Rnd(int64(Segdata.Filelen), int64(*FlagRound)))
 	Segdwarf.Filelen = 0
-	if Headtype == obj.Hwindows {
+	if Headtype == objabi.Hwindows {
 		Segdwarf.Fileoff = Segdata.Fileoff + uint64(Rnd(int64(Segdata.Filelen), int64(PEFILEALIGN)))
 	}
 	for i, s := range Segdwarf.Sections {
@@ -2250,7 +2250,7 @@ func (ctxt *Link) address() {
 		}
 		s.Vaddr = va
 		va += uint64(vlen)
-		if Headtype == obj.Hwindows {
+		if Headtype == objabi.Hwindows {
 			va = uint64(Rnd(int64(va), PEFILEALIGN))
 		}
 		Segdwarf.Length = va - Segdwarf.Vaddr
@@ -2299,8 +2299,8 @@ func (ctxt *Link) address() {
 		s.Value = int64(sectSym.Sect.Vaddr + 16)
 	}
 
-	ctxt.xdefine("runtime.text", obj.STEXT, int64(text.Vaddr))
-	ctxt.xdefine("runtime.etext", obj.STEXT, int64(lasttext.Vaddr+lasttext.Length))
+	ctxt.xdefine("runtime.text", objabi.STEXT, int64(text.Vaddr))
+	ctxt.xdefine("runtime.etext", objabi.STEXT, int64(lasttext.Vaddr+lasttext.Length))
 
 	// If there are multiple text sections, create runtime.text.n for
 	// their section Vaddr, using n for index
@@ -2308,48 +2308,48 @@ func (ctxt *Link) address() {
 	for _, sect := range Segtext.Sections[1:] {
 		if sect.Name == ".text" {
 			symname := fmt.Sprintf("runtime.text.%d", n)
-			ctxt.xdefine(symname, obj.STEXT, int64(sect.Vaddr))
+			ctxt.xdefine(symname, objabi.STEXT, int64(sect.Vaddr))
 			n++
 		} else {
 			break
 		}
 	}
 
-	ctxt.xdefine("runtime.rodata", obj.SRODATA, int64(rodata.Vaddr))
-	ctxt.xdefine("runtime.erodata", obj.SRODATA, int64(rodata.Vaddr+rodata.Length))
-	ctxt.xdefine("runtime.types", obj.SRODATA, int64(types.Vaddr))
-	ctxt.xdefine("runtime.etypes", obj.SRODATA, int64(types.Vaddr+types.Length))
-	ctxt.xdefine("runtime.itablink", obj.SRODATA, int64(itablink.Vaddr))
-	ctxt.xdefine("runtime.eitablink", obj.SRODATA, int64(itablink.Vaddr+itablink.Length))
+	ctxt.xdefine("runtime.rodata", objabi.SRODATA, int64(rodata.Vaddr))
+	ctxt.xdefine("runtime.erodata", objabi.SRODATA, int64(rodata.Vaddr+rodata.Length))
+	ctxt.xdefine("runtime.types", objabi.SRODATA, int64(types.Vaddr))
+	ctxt.xdefine("runtime.etypes", objabi.SRODATA, int64(types.Vaddr+types.Length))
+	ctxt.xdefine("runtime.itablink", objabi.SRODATA, int64(itablink.Vaddr))
+	ctxt.xdefine("runtime.eitablink", objabi.SRODATA, int64(itablink.Vaddr+itablink.Length))
 
 	sym := ctxt.Syms.Lookup("runtime.gcdata", 0)
 	sym.Attr |= AttrLocal
-	ctxt.xdefine("runtime.egcdata", obj.SRODATA, Symaddr(sym)+sym.Size)
+	ctxt.xdefine("runtime.egcdata", objabi.SRODATA, Symaddr(sym)+sym.Size)
 	ctxt.Syms.Lookup("runtime.egcdata", 0).Sect = sym.Sect
 
 	sym = ctxt.Syms.Lookup("runtime.gcbss", 0)
 	sym.Attr |= AttrLocal
-	ctxt.xdefine("runtime.egcbss", obj.SRODATA, Symaddr(sym)+sym.Size)
+	ctxt.xdefine("runtime.egcbss", objabi.SRODATA, Symaddr(sym)+sym.Size)
 	ctxt.Syms.Lookup("runtime.egcbss", 0).Sect = sym.Sect
 
-	ctxt.xdefine("runtime.symtab", obj.SRODATA, int64(symtab.Vaddr))
-	ctxt.xdefine("runtime.esymtab", obj.SRODATA, int64(symtab.Vaddr+symtab.Length))
-	ctxt.xdefine("runtime.pclntab", obj.SRODATA, int64(pclntab.Vaddr))
-	ctxt.xdefine("runtime.epclntab", obj.SRODATA, int64(pclntab.Vaddr+pclntab.Length))
-	ctxt.xdefine("runtime.noptrdata", obj.SNOPTRDATA, int64(noptr.Vaddr))
-	ctxt.xdefine("runtime.enoptrdata", obj.SNOPTRDATA, int64(noptr.Vaddr+noptr.Length))
-	ctxt.xdefine("runtime.bss", obj.SBSS, int64(bss.Vaddr))
-	ctxt.xdefine("runtime.ebss", obj.SBSS, int64(bss.Vaddr+bss.Length))
-	ctxt.xdefine("runtime.data", obj.SDATA, int64(data.Vaddr))
-	ctxt.xdefine("runtime.edata", obj.SDATA, int64(data.Vaddr+data.Length))
-	ctxt.xdefine("runtime.noptrbss", obj.SNOPTRBSS, int64(noptrbss.Vaddr))
-	ctxt.xdefine("runtime.enoptrbss", obj.SNOPTRBSS, int64(noptrbss.Vaddr+noptrbss.Length))
-	ctxt.xdefine("runtime.end", obj.SBSS, int64(Segdata.Vaddr+Segdata.Length))
+	ctxt.xdefine("runtime.symtab", objabi.SRODATA, int64(symtab.Vaddr))
+	ctxt.xdefine("runtime.esymtab", objabi.SRODATA, int64(symtab.Vaddr+symtab.Length))
+	ctxt.xdefine("runtime.pclntab", objabi.SRODATA, int64(pclntab.Vaddr))
+	ctxt.xdefine("runtime.epclntab", objabi.SRODATA, int64(pclntab.Vaddr+pclntab.Length))
+	ctxt.xdefine("runtime.noptrdata", objabi.SNOPTRDATA, int64(noptr.Vaddr))
+	ctxt.xdefine("runtime.enoptrdata", objabi.SNOPTRDATA, int64(noptr.Vaddr+noptr.Length))
+	ctxt.xdefine("runtime.bss", objabi.SBSS, int64(bss.Vaddr))
+	ctxt.xdefine("runtime.ebss", objabi.SBSS, int64(bss.Vaddr+bss.Length))
+	ctxt.xdefine("runtime.data", objabi.SDATA, int64(data.Vaddr))
+	ctxt.xdefine("runtime.edata", objabi.SDATA, int64(data.Vaddr+data.Length))
+	ctxt.xdefine("runtime.noptrbss", objabi.SNOPTRBSS, int64(noptrbss.Vaddr))
+	ctxt.xdefine("runtime.enoptrbss", objabi.SNOPTRBSS, int64(noptrbss.Vaddr+noptrbss.Length))
+	ctxt.xdefine("runtime.end", objabi.SBSS, int64(Segdata.Vaddr+Segdata.Length))
 }
 
 // add a trampoline with symbol s (to be laid down after the current function)
 func (ctxt *Link) AddTramp(s *Symbol) {
-	s.Type = obj.STEXT
+	s.Type = objabi.STEXT
 	s.Attr |= AttrReachable
 	s.Attr |= AttrOnList
 	ctxt.tramps = append(ctxt.tramps, s)
diff --git a/src/cmd/link/internal/ld/deadcode.go b/src/cmd/link/internal/ld/deadcode.go
index c616d5d5a8..a7b9cb3a3a 100644
--- a/src/cmd/link/internal/ld/deadcode.go
+++ b/src/cmd/link/internal/ld/deadcode.go
@@ -5,7 +5,7 @@
 package ld
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"fmt"
 	"strings"
@@ -46,7 +46,7 @@ import (
 // Any unreached text symbols are removed from ctxt.Textp.
 func deadcode(ctxt *Link) {
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f deadcode\n", obj.Cputime())
+		ctxt.Logf("%5.2f deadcode\n", Cputime())
 	}
 
 	d := &deadcodepass{
@@ -156,7 +156,7 @@ type deadcodepass struct {
 
 func (d *deadcodepass) cleanupReloc(r *Reloc) {
 	if r.Sym.Attr.Reachable() {
-		r.Type = obj.R_ADDROFF
+		r.Type = objabi.R_ADDROFF
 	} else {
 		if d.ctxt.Debugvlog > 1 {
 			d.ctxt.Logf("removing method %s\n", r.Sym.Name)
@@ -190,7 +190,7 @@ func (d *deadcodepass) mark(s, parent *Symbol) {
 func (d *deadcodepass) markMethod(m methodref) {
 	for _, r := range m.r {
 		d.mark(r.Sym, m.src)
-		r.Type = obj.R_ADDROFF
+		r.Type = objabi.R_ADDROFF
 	}
 }
 
@@ -208,7 +208,7 @@ func (d *deadcodepass) init() {
 		// Mark all symbols defined in this library as reachable when
 		// building a shared library.
 		for _, s := range d.ctxt.Syms.Allsym {
-			if s.Type != 0 && s.Type != obj.SDYNIMPORT {
+			if s.Type != 0 && s.Type != objabi.SDYNIMPORT {
 				d.mark(s, nil)
 			}
 		}
@@ -246,7 +246,7 @@ func (d *deadcodepass) flood() {
 	for len(d.markQueue) > 0 {
 		s := d.markQueue[0]
 		d.markQueue = d.markQueue[1:]
-		if s.Type == obj.STEXT {
+		if s.Type == objabi.STEXT {
 			if d.ctxt.Debugvlog > 1 {
 				d.ctxt.Logf("marktext %s\n", s.Name)
 			}
@@ -281,13 +281,13 @@ func (d *deadcodepass) flood() {
 			if r.Sym == nil {
 				continue
 			}
-			if r.Type == obj.R_WEAKADDROFF {
+			if r.Type == objabi.R_WEAKADDROFF {
 				// An R_WEAKADDROFF relocation is not reason
 				// enough to mark the pointed-to symbol as
 				// reachable.
 				continue
 			}
-			if r.Type != obj.R_METHODOFF {
+			if r.Type != objabi.R_METHODOFF {
 				d.mark(r.Sym, s)
 				continue
 			}
diff --git a/src/cmd/link/internal/ld/decodesym.go b/src/cmd/link/internal/ld/decodesym.go
index d898c40c1c..0b2873a389 100644
--- a/src/cmd/link/internal/ld/decodesym.go
+++ b/src/cmd/link/internal/ld/decodesym.go
@@ -6,7 +6,7 @@ package ld
 
 import (
 	"bytes"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"debug/elf"
 	"fmt"
@@ -65,12 +65,12 @@ func uncommonSize() int    { return 4 + 2 + 2 + 4 + 4 }         // runtime.uncom
 
 // Type.commonType.kind
 func decodetypeKind(s *Symbol) uint8 {
-	return s.P[2*SysArch.PtrSize+7] & obj.KindMask //  0x13 / 0x1f
+	return s.P[2*SysArch.PtrSize+7] & objabi.KindMask //  0x13 / 0x1f
 }
 
 // Type.commonType.kind
 func decodetypeUsegcprog(s *Symbol) uint8 {
-	return s.P[2*SysArch.PtrSize+7] & obj.KindGCProg //  0x13 / 0x1f
+	return s.P[2*SysArch.PtrSize+7] & objabi.KindGCProg //  0x13 / 0x1f
 }
 
 // Type.commonType.size
@@ -104,7 +104,7 @@ func findShlibSection(ctxt *Link, path string, addr uint64) *elf.Section {
 
 // Type.commonType.gc
 func decodetypeGcprog(ctxt *Link, s *Symbol) []byte {
-	if s.Type == obj.SDYNIMPORT {
+	if s.Type == objabi.SDYNIMPORT {
 		addr := decodetypeGcprogShlib(ctxt, s)
 		sect := findShlibSection(ctxt, s.File, addr)
 		if sect != nil {
@@ -135,7 +135,7 @@ func decodetypeGcprogShlib(ctxt *Link, s *Symbol) uint64 {
 }
 
 func decodetypeGcmask(ctxt *Link, s *Symbol) []byte {
-	if s.Type == obj.SDYNIMPORT {
+	if s.Type == objabi.SDYNIMPORT {
 		addr := decodetypeGcprogShlib(ctxt, s)
 		ptrdata := decodetypePtrdata(ctxt.Arch, s)
 		sect := findShlibSection(ctxt, s.File, addr)
diff --git a/src/cmd/link/internal/ld/dwarf.go b/src/cmd/link/internal/ld/dwarf.go
index e42c8cfe56..1f80f8cdcd 100644
--- a/src/cmd/link/internal/ld/dwarf.go
+++ b/src/cmd/link/internal/ld/dwarf.go
@@ -16,7 +16,7 @@ package ld
 
 import (
 	"cmd/internal/dwarf"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"fmt"
 	"log"
 	"os"
@@ -64,7 +64,7 @@ func (c dwctxt) AddSectionOffset(s dwarf.Sym, size int, t interface{}, ofs int64
 		addaddrplus4(c.linkctxt, ls, t.(*Symbol), 0)
 	}
 	r := &ls.R[len(ls.R)-1]
-	r.Type = obj.R_DWARFREF
+	r.Type = objabi.R_DWARFREF
 	r.Add = ofs
 }
 
@@ -83,7 +83,7 @@ var dwarfp []*Symbol
 
 func writeabbrev(ctxt *Link, syms []*Symbol) []*Symbol {
 	s := ctxt.Syms.Lookup(".debug_abbrev", 0)
-	s.Type = obj.SDWARFSECT
+	s.Type = objabi.SDWARFSECT
 	abbrevsym = s
 	Addbytes(s, dwarf.GetAbbrev())
 	return append(syms, s)
@@ -148,7 +148,7 @@ func newdie(ctxt *Link, parent *dwarf.DWDie, abbrev int, name string, version in
 		if abbrev != dwarf.DW_ABRV_VARIABLE || version == 0 {
 			sym := ctxt.Syms.Lookup(dwarf.InfoPrefix+name, version)
 			sym.Attr |= AttrHidden
-			sym.Type = obj.SDWARFINFO
+			sym.Type = objabi.SDWARFINFO
 			die.Sym = sym
 		}
 	}
@@ -202,7 +202,7 @@ func find(ctxt *Link, name string) *Symbol {
 	// The string allocation below is optimized away because it is only used in a map lookup.
 	s := ctxt.Syms.ROLookup(string(n), 0)
 	prefixBuf = n[:len(dwarf.InfoPrefix)]
-	if s != nil && s.Type == obj.SDWARFINFO {
+	if s != nil && s.Type == objabi.SDWARFINFO {
 		return s
 	}
 	return nil
@@ -228,7 +228,7 @@ func adddwarfref(ctxt *Link, s *Symbol, t *Symbol, size int) int64 {
 		result = addaddrplus4(ctxt, s, t, 0)
 	}
 	r := &s.R[len(s.R)-1]
-	r.Type = obj.R_DWARFREF
+	r.Type = objabi.R_DWARFREF
 	return result
 }
 
@@ -340,7 +340,7 @@ func dotypedef(ctxt *Link, parent *dwarf.DWDie, name string, def *dwarf.DWDie) {
 
 	sym := ctxt.Syms.Lookup(dtolsym(def.Sym).Name+"..def", 0)
 	sym.Attr |= AttrHidden
-	sym.Type = obj.SDWARFINFO
+	sym.Type = objabi.SDWARFINFO
 	def.Sym = sym
 
 	// The typedef entry must be created after the def,
@@ -381,43 +381,43 @@ func newtype(ctxt *Link, gotype *Symbol) *dwarf.DWDie {
 
 	var die *dwarf.DWDie
 	switch kind {
-	case obj.KindBool:
+	case objabi.KindBool:
 		die = newdie(ctxt, &dwtypes, dwarf.DW_ABRV_BASETYPE, name, 0)
 		newattr(die, dwarf.DW_AT_encoding, dwarf.DW_CLS_CONSTANT, dwarf.DW_ATE_boolean, 0)
 		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 
-	case obj.KindInt,
-		obj.KindInt8,
-		obj.KindInt16,
-		obj.KindInt32,
-		obj.KindInt64:
+	case objabi.KindInt,
+		objabi.KindInt8,
+		objabi.KindInt16,
+		objabi.KindInt32,
+		objabi.KindInt64:
 		die = newdie(ctxt, &dwtypes, dwarf.DW_ABRV_BASETYPE, name, 0)
 		newattr(die, dwarf.DW_AT_encoding, dwarf.DW_CLS_CONSTANT, dwarf.DW_ATE_signed, 0)
 		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 
-	case obj.KindUint,
-		obj.KindUint8,
-		obj.KindUint16,
-		obj.KindUint32,
-		obj.KindUint64,
-		obj.KindUintptr:
+	case objabi.KindUint,
+		objabi.KindUint8,
+		objabi.KindUint16,
+		objabi.KindUint32,
+		objabi.KindUint64,
+		objabi.KindUintptr:
 		die = newdie(ctxt, &dwtypes, dwarf.DW_ABRV_BASETYPE, name, 0)
 		newattr(die, dwarf.DW_AT_encoding, dwarf.DW_CLS_CONSTANT, dwarf.DW_ATE_unsigned, 0)
 		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 
-	case obj.KindFloat32,
-		obj.KindFloat64:
+	case objabi.KindFloat32,
+		objabi.KindFloat64:
 		die = newdie(ctxt, &dwtypes, dwarf.DW_ABRV_BASETYPE, name, 0)
 		newattr(die, dwarf.DW_AT_encoding, dwarf.DW_CLS_CONSTANT, dwarf.DW_ATE_float, 0)
 		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 
-	case obj.KindComplex64,
-		obj.KindComplex128:
+	case objabi.KindComplex64,
+		objabi.KindComplex128:
 		die = newdie(ctxt, &dwtypes, dwarf.DW_ABRV_BASETYPE, name, 0)
 		newattr(die, dwarf.DW_AT_encoding, dwarf.DW_CLS_CONSTANT, dwarf.DW_ATE_complex_float, 0)
 		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 
-	case obj.KindArray:
+	case objabi.KindArray:
 		die = newdie(ctxt, &dwtypes, dwarf.DW_ABRV_ARRAYTYPE, name, 0)
 		dotypedef(ctxt, &dwtypes, name, die)
 		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
@@ -430,7 +430,7 @@ func newtype(ctxt *Link, gotype *Symbol) *dwarf.DWDie {
 
 		newrefattr(fld, dwarf.DW_AT_type, mustFind(ctxt, "uintptr"))
 
-	case obj.KindChan:
+	case objabi.KindChan:
 		die = newdie(ctxt, &dwtypes, dwarf.DW_ABRV_CHANTYPE, name, 0)
 		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 		s := decodetypeChanElem(gotype)
@@ -439,7 +439,7 @@ func newtype(ctxt *Link, gotype *Symbol) *dwarf.DWDie {
 		// but that would change the order of DIEs we output.
 		newrefattr(die, dwarf.DW_AT_type, s)
 
-	case obj.KindFunc:
+	case objabi.KindFunc:
 		die = newdie(ctxt, &dwtypes, dwarf.DW_ABRV_FUNCTYPE, name, 0)
 		dotypedef(ctxt, &dwtypes, name, die)
 		newrefattr(die, dwarf.DW_AT_type, mustFind(ctxt, "void"))
@@ -462,7 +462,7 @@ func newtype(ctxt *Link, gotype *Symbol) *dwarf.DWDie {
 			newrefattr(fld, dwarf.DW_AT_type, defptrto(ctxt, defgotype(ctxt, s)))
 		}
 
-	case obj.KindInterface:
+	case objabi.KindInterface:
 		die = newdie(ctxt, &dwtypes, dwarf.DW_ABRV_IFACETYPE, name, 0)
 		dotypedef(ctxt, &dwtypes, name, die)
 		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
@@ -475,7 +475,7 @@ func newtype(ctxt *Link, gotype *Symbol) *dwarf.DWDie {
 		}
 		newrefattr(die, dwarf.DW_AT_type, defgotype(ctxt, s))
 
-	case obj.KindMap:
+	case objabi.KindMap:
 		die = newdie(ctxt, &dwtypes, dwarf.DW_ABRV_MAPTYPE, name, 0)
 		s := decodetypeMapKey(gotype)
 		newrefattr(die, dwarf.DW_AT_go_key, defgotype(ctxt, s))
@@ -485,13 +485,13 @@ func newtype(ctxt *Link, gotype *Symbol) *dwarf.DWDie {
 		// but that would change the order of the DIEs.
 		newrefattr(die, dwarf.DW_AT_type, gotype)
 
-	case obj.KindPtr:
+	case objabi.KindPtr:
 		die = newdie(ctxt, &dwtypes, dwarf.DW_ABRV_PTRTYPE, name, 0)
 		dotypedef(ctxt, &dwtypes, name, die)
 		s := decodetypePtrElem(gotype)
 		newrefattr(die, dwarf.DW_AT_type, defgotype(ctxt, s))
 
-	case obj.KindSlice:
+	case objabi.KindSlice:
 		die = newdie(ctxt, &dwtypes, dwarf.DW_ABRV_SLICETYPE, name, 0)
 		dotypedef(ctxt, &dwtypes, name, die)
 		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
@@ -499,11 +499,11 @@ func newtype(ctxt *Link, gotype *Symbol) *dwarf.DWDie {
 		elem := defgotype(ctxt, s)
 		newrefattr(die, dwarf.DW_AT_go_elem, elem)
 
-	case obj.KindString:
+	case objabi.KindString:
 		die = newdie(ctxt, &dwtypes, dwarf.DW_ABRV_STRINGTYPE, name, 0)
 		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 
-	case obj.KindStruct:
+	case objabi.KindStruct:
 		die = newdie(ctxt, &dwtypes, dwarf.DW_ABRV_STRUCTTYPE, name, 0)
 		dotypedef(ctxt, &dwtypes, name, die)
 		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
@@ -522,7 +522,7 @@ func newtype(ctxt *Link, gotype *Symbol) *dwarf.DWDie {
 			newmemberoffsetattr(fld, int32(decodetypeStructFieldOffs(ctxt.Arch, gotype, i)))
 		}
 
-	case obj.KindUnsafePointer:
+	case objabi.KindUnsafePointer:
 		die = newdie(ctxt, &dwtypes, dwarf.DW_ABRV_BARE_PTRTYPE, name, 0)
 
 	default:
@@ -659,7 +659,7 @@ func mkinternaltype(ctxt *Link, abbrev int, typename, keyname, valname string, f
 	name := mkinternaltypename(typename, keyname, valname)
 	symname := dwarf.InfoPrefix + name
 	s := ctxt.Syms.ROLookup(symname, 0)
-	if s != nil && s.Type == obj.SDWARFINFO {
+	if s != nil && s.Type == objabi.SDWARFINFO {
 		return s
 	}
 	die := newdie(ctxt, &dwtypes, abbrev, name, 0)
@@ -995,7 +995,7 @@ func writelines(ctxt *Link, syms []*Symbol) ([]*Symbol, []*Symbol) {
 	if linesec == nil {
 		linesec = ctxt.Syms.Lookup(".debug_line", 0)
 	}
-	linesec.Type = obj.SDWARFSECT
+	linesec.Type = objabi.SDWARFSECT
 	linesec.R = linesec.R[:0]
 
 	ls := linesec
@@ -1012,7 +1012,7 @@ func writelines(ctxt *Link, syms []*Symbol) ([]*Symbol, []*Symbol) {
 	lang := dwarf.DW_LANG_Go
 
 	s := ctxt.Textp[0]
-	if ctxt.DynlinkingGo() && Headtype == obj.Hdarwin {
+	if ctxt.DynlinkingGo() && Headtype == objabi.Hdarwin {
 		s = ctxt.Textp[1] // skip runtime.text
 	}
 
@@ -1081,9 +1081,9 @@ func writelines(ctxt *Link, syms []*Symbol) ([]*Symbol, []*Symbol) {
 
 		dsym := ctxt.Syms.Lookup(dwarf.InfoPrefix+s.Name, int(s.Version))
 		dsym.Attr |= AttrHidden | AttrReachable
-		dsym.Type = obj.SDWARFINFO
+		dsym.Type = objabi.SDWARFINFO
 		for _, r := range dsym.R {
-			if r.Type == obj.R_DWARFREF && r.Sym.Size == 0 {
+			if r.Type == objabi.R_DWARFREF && r.Sym.Size == 0 {
 				if Buildmode == BuildmodeShared {
 					// These type symbols may not be present in BuildmodeShared. Skip.
 					continue
@@ -1178,7 +1178,7 @@ func writeframes(ctxt *Link, syms []*Symbol) []*Symbol {
 	if framesec == nil {
 		framesec = ctxt.Syms.Lookup(".debug_frame", 0)
 	}
-	framesec.Type = obj.SDWARFSECT
+	framesec.Type = objabi.SDWARFSECT
 	framesec.R = framesec.R[:0]
 	fs := framesec
 	syms = append(syms, fs)
@@ -1300,7 +1300,7 @@ func writeinfo(ctxt *Link, syms []*Symbol, funcs []*Symbol) []*Symbol {
 		infosec = ctxt.Syms.Lookup(".debug_info", 0)
 	}
 	infosec.R = infosec.R[:0]
-	infosec.Type = obj.SDWARFINFO
+	infosec.Type = objabi.SDWARFINFO
 	infosec.Attr |= AttrReachable
 	syms = append(syms, infosec)
 
@@ -1366,7 +1366,7 @@ func ispubtype(die *dwarf.DWDie) bool {
 
 func writepub(ctxt *Link, sname string, ispub func(*dwarf.DWDie) bool, syms []*Symbol) []*Symbol {
 	s := ctxt.Syms.Lookup(sname, 0)
-	s.Type = obj.SDWARFSECT
+	s.Type = objabi.SDWARFSECT
 	syms = append(syms, s)
 
 	for compunit := dwroot.Child; compunit != nil; compunit = compunit.Link {
@@ -1406,7 +1406,7 @@ func writepub(ctxt *Link, sname string, ispub func(*dwarf.DWDie) bool, syms []*S
  */
 func writearanges(ctxt *Link, syms []*Symbol) []*Symbol {
 	s := ctxt.Syms.Lookup(".debug_aranges", 0)
-	s.Type = obj.SDWARFSECT
+	s.Type = objabi.SDWARFSECT
 	// The first tuple is aligned to a multiple of the size of a single tuple
 	// (twice the size of an address)
 	headersize := int(Rnd(4+2+4+1+1, int64(SysArch.PtrSize*2))) // don't count unit_length field itself
@@ -1450,7 +1450,7 @@ func writegdbscript(ctxt *Link, syms []*Symbol) []*Symbol {
 
 	if gdbscript != "" {
 		s := ctxt.Syms.Lookup(".debug_gdb_scripts", 0)
-		s.Type = obj.SDWARFSECT
+		s.Type = objabi.SDWARFSECT
 		syms = append(syms, s)
 		Adduint8(ctxt, s, 1) // magic 1 byte?
 		Addstring(s, gdbscript)
@@ -1474,25 +1474,25 @@ func dwarfgeneratedebugsyms(ctxt *Link) {
 	if *FlagW { // disable dwarf
 		return
 	}
-	if *FlagS && Headtype != obj.Hdarwin {
+	if *FlagS && Headtype != objabi.Hdarwin {
 		return
 	}
-	if Headtype == obj.Hplan9 {
+	if Headtype == objabi.Hplan9 {
 		return
 	}
 
 	if Linkmode == LinkExternal {
 		switch {
 		case Iself:
-		case Headtype == obj.Hdarwin:
-		case Headtype == obj.Hwindows:
+		case Headtype == objabi.Hdarwin:
+		case Headtype == objabi.Hwindows:
 		default:
 			return
 		}
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f dwarf\n", obj.Cputime())
+		ctxt.Logf("%5.2f dwarf\n", Cputime())
 	}
 
 	// Forctxt.Diagnostic messages.
@@ -1507,7 +1507,7 @@ func dwarfgeneratedebugsyms(ctxt *Link) {
 	die := newdie(ctxt, &dwtypes, dwarf.DW_ABRV_BASETYPE, "uintptr", 0) // needed for array size
 	newattr(die, dwarf.DW_AT_encoding, dwarf.DW_CLS_CONSTANT, dwarf.DW_ATE_unsigned, 0)
 	newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, int64(SysArch.PtrSize), 0)
-	newattr(die, dwarf.DW_AT_go_kind, dwarf.DW_CLS_CONSTANT, obj.KindUintptr, 0)
+	newattr(die, dwarf.DW_AT_go_kind, dwarf.DW_CLS_CONSTANT, objabi.KindUintptr, 0)
 
 	// Prototypes needed for type synthesis.
 	prototypedies = map[string]*dwarf.DWDie{
diff --git a/src/cmd/link/internal/ld/elf.go b/src/cmd/link/internal/ld/elf.go
index 18514b90ed..2fde4e0d56 100644
--- a/src/cmd/link/internal/ld/elf.go
+++ b/src/cmd/link/internal/ld/elf.go
@@ -5,7 +5,7 @@
 package ld
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"crypto/sha1"
 	"encoding/binary"
@@ -950,7 +950,7 @@ func Elfinit(ctxt *Link) {
 	case sys.ARM, sys.MIPS:
 		if SysArch.Family == sys.ARM {
 			// we use EABI on linux/arm, freebsd/arm, netbsd/arm.
-			if Headtype == obj.Hlinux || Headtype == obj.Hfreebsd || Headtype == obj.Hnetbsd {
+			if Headtype == objabi.Hlinux || Headtype == objabi.Hfreebsd || Headtype == objabi.Hnetbsd {
 				// We set a value here that makes no indication of which
 				// float ABI the object uses, because this is information
 				// used by the dynamic linker to compare executables and
@@ -1451,7 +1451,7 @@ func elfdynhash(ctxt *Link) {
 
 	nsym := Nelfsym
 	s := ctxt.Syms.Lookup(".hash", 0)
-	s.Type = obj.SELFROSECT
+	s.Type = objabi.SELFROSECT
 	s.Attr |= AttrReachable
 
 	i := nsym
@@ -1856,7 +1856,7 @@ func Elfemitreloc(ctxt *Link) {
 func addgonote(ctxt *Link, sectionName string, tag uint32, desc []byte) {
 	s := ctxt.Syms.Lookup(sectionName, 0)
 	s.Attr |= AttrReachable
-	s.Type = obj.SELFROSECT
+	s.Type = objabi.SELFROSECT
 	// namesz
 	Adduint32(ctxt, s, uint32(len(ELF_NOTE_GO_NAME)))
 	// descsz
@@ -1884,7 +1884,7 @@ func (ctxt *Link) doelf() {
 	/* predefine strings we need for section headers */
 	shstrtab := ctxt.Syms.Lookup(".shstrtab", 0)
 
-	shstrtab.Type = obj.SELFROSECT
+	shstrtab.Type = objabi.SELFROSECT
 	shstrtab.Attr |= AttrReachable
 
 	Addstring(shstrtab, "")
@@ -1900,10 +1900,10 @@ func (ctxt *Link) doelf() {
 	if !*FlagD || Linkmode == LinkExternal {
 		Addstring(shstrtab, ".tbss")
 	}
-	if Headtype == obj.Hnetbsd {
+	if Headtype == objabi.Hnetbsd {
 		Addstring(shstrtab, ".note.netbsd.ident")
 	}
-	if Headtype == obj.Hopenbsd {
+	if Headtype == objabi.Hopenbsd {
 		Addstring(shstrtab, ".note.openbsd.ident")
 	}
 	if len(buildinfo) > 0 {
@@ -1992,7 +1992,7 @@ func (ctxt *Link) doelf() {
 		/* dynamic symbol table - first entry all zeros */
 		s := ctxt.Syms.Lookup(".dynsym", 0)
 
-		s.Type = obj.SELFROSECT
+		s.Type = objabi.SELFROSECT
 		s.Attr |= AttrReachable
 		if elf64 {
 			s.Size += ELF64SYMSIZE
@@ -2003,7 +2003,7 @@ func (ctxt *Link) doelf() {
 		/* dynamic string table */
 		s = ctxt.Syms.Lookup(".dynstr", 0)
 
-		s.Type = obj.SELFROSECT
+		s.Type = objabi.SELFROSECT
 		s.Attr |= AttrReachable
 		if s.Size == 0 {
 			Addstring(s, "")
@@ -2013,30 +2013,30 @@ func (ctxt *Link) doelf() {
 		/* relocation table */
 		s = ctxt.Syms.Lookup(elfRelType, 0)
 		s.Attr |= AttrReachable
-		s.Type = obj.SELFROSECT
+		s.Type = objabi.SELFROSECT
 
 		/* global offset table */
 		s = ctxt.Syms.Lookup(".got", 0)
 
 		s.Attr |= AttrReachable
-		s.Type = obj.SELFGOT // writable
+		s.Type = objabi.SELFGOT // writable
 
 		/* ppc64 glink resolver */
 		if SysArch.Family == sys.PPC64 {
 			s := ctxt.Syms.Lookup(".glink", 0)
 			s.Attr |= AttrReachable
-			s.Type = obj.SELFRXSECT
+			s.Type = objabi.SELFRXSECT
 		}
 
 		/* hash */
 		s = ctxt.Syms.Lookup(".hash", 0)
 
 		s.Attr |= AttrReachable
-		s.Type = obj.SELFROSECT
+		s.Type = objabi.SELFROSECT
 
 		s = ctxt.Syms.Lookup(".got.plt", 0)
 		s.Attr |= AttrReachable
-		s.Type = obj.SELFSECT // writable
+		s.Type = objabi.SELFSECT // writable
 
 		s = ctxt.Syms.Lookup(".plt", 0)
 
@@ -2044,30 +2044,30 @@ func (ctxt *Link) doelf() {
 		if SysArch.Family == sys.PPC64 {
 			// In the ppc64 ABI, .plt is a data section
 			// written by the dynamic linker.
-			s.Type = obj.SELFSECT
+			s.Type = objabi.SELFSECT
 		} else {
-			s.Type = obj.SELFRXSECT
+			s.Type = objabi.SELFRXSECT
 		}
 
 		Thearch.Elfsetupplt(ctxt)
 
 		s = ctxt.Syms.Lookup(elfRelType+".plt", 0)
 		s.Attr |= AttrReachable
-		s.Type = obj.SELFROSECT
+		s.Type = objabi.SELFROSECT
 
 		s = ctxt.Syms.Lookup(".gnu.version", 0)
 		s.Attr |= AttrReachable
-		s.Type = obj.SELFROSECT
+		s.Type = objabi.SELFROSECT
 
 		s = ctxt.Syms.Lookup(".gnu.version_r", 0)
 		s.Attr |= AttrReachable
-		s.Type = obj.SELFROSECT
+		s.Type = objabi.SELFROSECT
 
 		/* define dynamic elf table */
 		s = ctxt.Syms.Lookup(".dynamic", 0)
 
 		s.Attr |= AttrReachable
-		s.Type = obj.SELFSECT // writable
+		s.Type = objabi.SELFSECT // writable
 
 		/*
 		 * .dynamic table
@@ -2120,7 +2120,7 @@ func (ctxt *Link) doelf() {
 		// part of the .note.go.abihash section in data.go:func address().
 		s := ctxt.Syms.Lookup("go.link.abihashbytes", 0)
 		s.Attr |= AttrLocal
-		s.Type = obj.SRODATA
+		s.Type = objabi.SRODATA
 		s.Attr |= AttrSpecial
 		s.Attr |= AttrReachable
 		s.Size = int64(sha1.Size)
@@ -2276,7 +2276,7 @@ func Asmbelf(ctxt *Link, symo int64) {
 	 * segment boundaries downwards to include it.
 	 * Except on NaCl where it must not be loaded.
 	 */
-	if Headtype != obj.Hnacl {
+	if Headtype != objabi.Hnacl {
 		o := int64(Segtext.Vaddr - pph.vaddr)
 		Segtext.Vaddr -= uint64(o)
 		Segtext.Length += uint64(o)
@@ -2294,22 +2294,22 @@ func Asmbelf(ctxt *Link, symo int64) {
 		sh.addralign = 1
 		if interpreter == "" {
 			switch Headtype {
-			case obj.Hlinux:
+			case objabi.Hlinux:
 				interpreter = Thearch.Linuxdynld
 
-			case obj.Hfreebsd:
+			case objabi.Hfreebsd:
 				interpreter = Thearch.Freebsddynld
 
-			case obj.Hnetbsd:
+			case objabi.Hnetbsd:
 				interpreter = Thearch.Netbsddynld
 
-			case obj.Hopenbsd:
+			case objabi.Hopenbsd:
 				interpreter = Thearch.Openbsddynld
 
-			case obj.Hdragonfly:
+			case objabi.Hdragonfly:
 				interpreter = Thearch.Dragonflydynld
 
-			case obj.Hsolaris:
+			case objabi.Hsolaris:
 				interpreter = Thearch.Solarisdynld
 			}
 		}
@@ -2323,14 +2323,14 @@ func Asmbelf(ctxt *Link, symo int64) {
 	}
 
 	pnote = nil
-	if Headtype == obj.Hnetbsd || Headtype == obj.Hopenbsd {
+	if Headtype == objabi.Hnetbsd || Headtype == objabi.Hopenbsd {
 		var sh *ElfShdr
 		switch Headtype {
-		case obj.Hnetbsd:
+		case objabi.Hnetbsd:
 			sh = elfshname(".note.netbsd.ident")
 			resoff -= int64(elfnetbsdsig(sh, uint64(startva), uint64(resoff)))
 
-		case obj.Hopenbsd:
+		case objabi.Hopenbsd:
 			sh = elfshname(".note.openbsd.ident")
 			resoff -= int64(elfopenbsdsig(sh, uint64(startva), uint64(resoff)))
 		}
@@ -2537,7 +2537,7 @@ func Asmbelf(ctxt *Link, symo int64) {
 		}
 	}
 
-	if Headtype == obj.Hlinux {
+	if Headtype == objabi.Hlinux {
 		ph := newElfPhdr()
 		ph.type_ = PT_GNU_STACK
 		ph.flags = PF_W + PF_R
@@ -2547,7 +2547,7 @@ func Asmbelf(ctxt *Link, symo int64) {
 		ph.type_ = PT_PAX_FLAGS
 		ph.flags = 0x2a00 // mprotect, randexec, emutramp disabled
 		ph.align = uint64(SysArch.RegSize)
-	} else if Headtype == obj.Hsolaris {
+	} else if Headtype == objabi.Hsolaris {
 		ph := newElfPhdr()
 		ph.type_ = PT_SUNWSTACK
 		ph.flags = PF_W + PF_R
@@ -2596,10 +2596,10 @@ elfobj:
 			elfshreloc(sect)
 		}
 		for _, s := range dwarfp {
-			if len(s.R) > 0 || s.Type == obj.SDWARFINFO {
+			if len(s.R) > 0 || s.Type == objabi.SDWARFINFO {
 				elfshreloc(s.Sect)
 			}
-			if s.Type == obj.SDWARFINFO {
+			if s.Type == objabi.SDWARFINFO {
 				break
 			}
 		}
@@ -2634,13 +2634,13 @@ elfobj:
 	eh.ident[EI_MAG1] = 'E'
 	eh.ident[EI_MAG2] = 'L'
 	eh.ident[EI_MAG3] = 'F'
-	if Headtype == obj.Hfreebsd {
+	if Headtype == objabi.Hfreebsd {
 		eh.ident[EI_OSABI] = ELFOSABI_FREEBSD
-	} else if Headtype == obj.Hnetbsd {
+	} else if Headtype == objabi.Hnetbsd {
 		eh.ident[EI_OSABI] = ELFOSABI_NETBSD
-	} else if Headtype == obj.Hopenbsd {
+	} else if Headtype == objabi.Hopenbsd {
 		eh.ident[EI_OSABI] = ELFOSABI_OPENBSD
-	} else if Headtype == obj.Hdragonfly {
+	} else if Headtype == objabi.Hdragonfly {
 		eh.ident[EI_OSABI] = ELFOSABI_NONE
 	}
 	if elf64 {
@@ -2683,10 +2683,10 @@ elfobj:
 		a += int64(elfwriteinterp())
 	}
 	if Linkmode != LinkExternal {
-		if Headtype == obj.Hnetbsd {
+		if Headtype == objabi.Hnetbsd {
 			a += int64(elfwritenetbsdsig())
 		}
-		if Headtype == obj.Hopenbsd {
+		if Headtype == objabi.Hopenbsd {
 			a += int64(elfwriteopenbsdsig())
 		}
 		if len(buildinfo) > 0 {
@@ -2715,7 +2715,7 @@ func Elfadddynsym(ctxt *Link, s *Symbol) {
 		/* type */
 		t := STB_GLOBAL << 4
 
-		if s.Attr.CgoExport() && s.Type&obj.SMASK == obj.STEXT {
+		if s.Attr.CgoExport() && s.Type&objabi.SMASK == objabi.STEXT {
 			t |= STT_FUNC
 		} else {
 			t |= STT_OBJECT
@@ -2726,14 +2726,14 @@ func Elfadddynsym(ctxt *Link, s *Symbol) {
 		Adduint8(ctxt, d, 0)
 
 		/* section where symbol is defined */
-		if s.Type == obj.SDYNIMPORT {
+		if s.Type == objabi.SDYNIMPORT {
 			Adduint16(ctxt, d, SHN_UNDEF)
 		} else {
 			Adduint16(ctxt, d, 1)
 		}
 
 		/* value */
-		if s.Type == obj.SDYNIMPORT {
+		if s.Type == objabi.SDYNIMPORT {
 			Adduint64(ctxt, d, 0)
 		} else {
 			Addaddr(ctxt, d, s)
@@ -2757,7 +2757,7 @@ func Elfadddynsym(ctxt *Link, s *Symbol) {
 		Adduint32(ctxt, d, uint32(Addstring(ctxt.Syms.Lookup(".dynstr", 0), name)))
 
 		/* value */
-		if s.Type == obj.SDYNIMPORT {
+		if s.Type == objabi.SDYNIMPORT {
 			Adduint32(ctxt, d, 0)
 		} else {
 			Addaddr(ctxt, d, s)
@@ -2770,9 +2770,9 @@ func Elfadddynsym(ctxt *Link, s *Symbol) {
 		t := STB_GLOBAL << 4
 
 		// TODO(mwhudson): presumably the behavior should actually be the same on both arm and 386.
-		if SysArch.Family == sys.I386 && s.Attr.CgoExport() && s.Type&obj.SMASK == obj.STEXT {
+		if SysArch.Family == sys.I386 && s.Attr.CgoExport() && s.Type&objabi.SMASK == objabi.STEXT {
 			t |= STT_FUNC
-		} else if SysArch.Family == sys.ARM && s.Attr.CgoExportDynamic() && s.Type&obj.SMASK == obj.STEXT {
+		} else if SysArch.Family == sys.ARM && s.Attr.CgoExportDynamic() && s.Type&objabi.SMASK == objabi.STEXT {
 			t |= STT_FUNC
 		} else {
 			t |= STT_OBJECT
@@ -2781,7 +2781,7 @@ func Elfadddynsym(ctxt *Link, s *Symbol) {
 		Adduint8(ctxt, d, 0)
 
 		/* shndx */
-		if s.Type == obj.SDYNIMPORT {
+		if s.Type == objabi.SDYNIMPORT {
 			Adduint16(ctxt, d, SHN_UNDEF)
 		} else {
 			Adduint16(ctxt, d, 1)
diff --git a/src/cmd/link/internal/ld/go.go b/src/cmd/link/internal/ld/go.go
index 5b84c3d718..0d7f3f769f 100644
--- a/src/cmd/link/internal/ld/go.go
+++ b/src/cmd/link/internal/ld/go.go
@@ -9,7 +9,7 @@ package ld
 import (
 	"bytes"
 	"cmd/internal/bio"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"fmt"
 	"io"
 	"os"
@@ -174,7 +174,7 @@ func loadcgo(ctxt *Link, file string, pkg string, p string) {
 				// to force a link of foo.so.
 				havedynamic = 1
 
-				if Headtype == obj.Hdarwin {
+				if Headtype == objabi.Hdarwin {
 					Machoadddynlib(lib)
 				} else {
 					dynlib = append(dynlib, lib)
@@ -190,12 +190,12 @@ func loadcgo(ctxt *Link, file string, pkg string, p string) {
 			s = ctxt.Syms.Lookup(local, 0)
 			if local != f[1] {
 			}
-			if s.Type == 0 || s.Type == obj.SXREF || s.Type == obj.SHOSTOBJ {
+			if s.Type == 0 || s.Type == objabi.SXREF || s.Type == objabi.SHOSTOBJ {
 				s.Dynimplib = lib
 				s.Extname = remote
 				s.Dynimpvers = q
-				if s.Type != obj.SHOSTOBJ {
-					s.Type = obj.SDYNIMPORT
+				if s.Type != objabi.SHOSTOBJ {
+					s.Type = objabi.SDYNIMPORT
 				}
 				havedynamic = 1
 			}
@@ -209,7 +209,7 @@ func loadcgo(ctxt *Link, file string, pkg string, p string) {
 			}
 			local = f[1]
 			s = ctxt.Syms.Lookup(local, 0)
-			s.Type = obj.SHOSTOBJ
+			s.Type = objabi.SHOSTOBJ
 			s.Size = 0
 			continue
 		}
@@ -322,9 +322,9 @@ func Adddynsym(ctxt *Link, s *Symbol) {
 
 	if Iself {
 		Elfadddynsym(ctxt, s)
-	} else if Headtype == obj.Hdarwin {
+	} else if Headtype == objabi.Hdarwin {
 		Errorf(s, "adddynsym: missed symbol (Extname=%s)", s.Extname)
-	} else if Headtype == obj.Hwindows {
+	} else if Headtype == objabi.Hwindows {
 		// already taken care of
 	} else {
 		Errorf(s, "adddynsym: unsupported binary format")
@@ -347,7 +347,7 @@ func fieldtrack(ctxt *Link) {
 				buf.WriteString("\n")
 			}
 
-			s.Type = obj.SCONST
+			s.Type = objabi.SCONST
 			s.Value = 0
 		}
 	}
@@ -363,7 +363,7 @@ func fieldtrack(ctxt *Link) {
 }
 
 func (ctxt *Link) addexport() {
-	if Headtype == obj.Hdarwin {
+	if Headtype == objabi.Hdarwin {
 		return
 	}
 
diff --git a/src/cmd/link/internal/ld/ld.go b/src/cmd/link/internal/ld/ld.go
index 4750e828bf..52f82c3b87 100644
--- a/src/cmd/link/internal/ld/ld.go
+++ b/src/cmd/link/internal/ld/ld.go
@@ -32,7 +32,6 @@
 package ld
 
 import (
-	"cmd/internal/obj"
 	"io/ioutil"
 	"os"
 	"path"
@@ -105,7 +104,7 @@ func addlibpath(ctxt *Link, srcref string, objref string, file string, pkg strin
 	}
 
 	if ctxt.Debugvlog > 1 {
-		ctxt.Logf("%5.2f addlibpath: srcref: %s objref: %s file: %s pkg: %s shlibnamefile: %s\n", obj.Cputime(), srcref, objref, file, pkg, shlibnamefile)
+		ctxt.Logf("%5.2f addlibpath: srcref: %s objref: %s file: %s pkg: %s shlibnamefile: %s\n", Cputime(), srcref, objref, file, pkg, shlibnamefile)
 	}
 
 	ctxt.Library = append(ctxt.Library, &Library{})
diff --git a/src/cmd/link/internal/ld/ldelf.go b/src/cmd/link/internal/ld/ldelf.go
index 00e8f37523..61c1331b5b 100644
--- a/src/cmd/link/internal/ld/ldelf.go
+++ b/src/cmd/link/internal/ld/ldelf.go
@@ -3,7 +3,7 @@ package ld
 import (
 	"bytes"
 	"cmd/internal/bio"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"encoding/binary"
 	"fmt"
@@ -444,7 +444,7 @@ func parseArmAttributes(ctxt *Link, e binary.ByteOrder, data []byte) {
 
 func ldelf(ctxt *Link, f *bio.Reader, pkg string, length int64, pn string) {
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f ldelf %s\n", obj.Cputime(), pn)
+		ctxt.Logf("%5.2f ldelf %s\n", Cputime(), pn)
 	}
 
 	localSymVersion := ctxt.Syms.IncVersion()
@@ -718,21 +718,21 @@ func ldelf(ctxt *Link, f *bio.Reader, pkg string, length int64, pn string) {
 			goto bad
 
 		case ElfSectFlagAlloc:
-			s.Type = obj.SRODATA
+			s.Type = objabi.SRODATA
 
 		case ElfSectFlagAlloc + ElfSectFlagWrite:
 			if sect.type_ == ElfSectNobits {
-				s.Type = obj.SNOPTRBSS
+				s.Type = objabi.SNOPTRBSS
 			} else {
-				s.Type = obj.SNOPTRDATA
+				s.Type = objabi.SNOPTRDATA
 			}
 
 		case ElfSectFlagAlloc + ElfSectFlagExec:
-			s.Type = obj.STEXT
+			s.Type = objabi.STEXT
 		}
 
 		if sect.name == ".got" || sect.name == ".toc" {
-			s.Type = obj.SELFGOT
+			s.Type = objabi.SELFGOT
 		}
 		if sect.type_ == ElfSectProgbits {
 			s.P = sect.base
@@ -761,8 +761,8 @@ func ldelf(ctxt *Link, f *bio.Reader, pkg string, length int64, pn string) {
 			if uint64(s.Size) < sym.size {
 				s.Size = int64(sym.size)
 			}
-			if s.Type == 0 || s.Type == obj.SXREF {
-				s.Type = obj.SNOPTRBSS
+			if s.Type == 0 || s.Type == objabi.SXREF {
+				s.Type = objabi.SNOPTRBSS
 			}
 			continue
 		}
@@ -804,14 +804,14 @@ func ldelf(ctxt *Link, f *bio.Reader, pkg string, length int64, pn string) {
 
 		s.Sub = sect.sym.Sub
 		sect.sym.Sub = s
-		s.Type = sect.sym.Type | s.Type&^obj.SMASK | obj.SSUB
+		s.Type = sect.sym.Type | s.Type&^objabi.SMASK | objabi.SSUB
 		if !s.Attr.CgoExportDynamic() {
 			s.Dynimplib = "" // satisfy dynimport
 		}
 		s.Value = int64(sym.value)
 		s.Size = int64(sym.size)
 		s.Outer = sect.sym
-		if sect.sym.Type == obj.STEXT {
+		if sect.sym.Type == objabi.STEXT {
 			if s.Attr.External() && !s.Attr.DuplicateOK() {
 				Errorf(s, "%s: duplicate symbol definition", pn)
 			}
@@ -838,7 +838,7 @@ func ldelf(ctxt *Link, f *bio.Reader, pkg string, length int64, pn string) {
 		if s.Sub != nil {
 			s.Sub = listsort(s.Sub)
 		}
-		if s.Type == obj.STEXT {
+		if s.Type == objabi.STEXT {
 			if s.Attr.OnList() {
 				log.Fatalf("symbol %s listed multiple times", s.Name)
 			}
@@ -923,7 +923,7 @@ func ldelf(ctxt *Link, f *bio.Reader, pkg string, length int64, pn string) {
 				rp.Sym = sym.sym
 			}
 
-			rp.Type = 256 + obj.RelocType(info)
+			rp.Type = 256 + objabi.RelocType(info)
 			rp.Siz = relSize(ctxt, pn, uint32(info))
 			if rela != 0 {
 				rp.Add = int64(add)
@@ -1051,7 +1051,7 @@ func readelfsym(ctxt *Link, elfobj *ElfObj, i int, sym *ElfSym, needSym int, loc
 				// set dupok generally. See http://codereview.appspot.com/5823055/
 				// comment #5 for details.
 				if s != nil && sym.other == 2 {
-					s.Type |= obj.SHIDDEN
+					s.Type |= objabi.SHIDDEN
 					s.Attr |= AttrDuplicateOK
 				}
 			}
@@ -1068,7 +1068,7 @@ func readelfsym(ctxt *Link, elfobj *ElfObj, i int, sym *ElfSym, needSym int, loc
 				// so put it in the hash table.
 				if needSym != 0 {
 					s = ctxt.Syms.Lookup(sym.name, localSymVersion)
-					s.Type |= obj.SHIDDEN
+					s.Type |= objabi.SHIDDEN
 				}
 
 				break
@@ -1080,14 +1080,14 @@ func readelfsym(ctxt *Link, elfobj *ElfObj, i int, sym *ElfSym, needSym int, loc
 				// don't bother to add them into the hash table
 				s = ctxt.Syms.newsym(sym.name, localSymVersion)
 
-				s.Type |= obj.SHIDDEN
+				s.Type |= objabi.SHIDDEN
 			}
 
 		case ElfSymBindWeak:
 			if needSym != 0 {
 				s = ctxt.Syms.Lookup(sym.name, 0)
 				if sym.other == 2 {
-					s.Type |= obj.SHIDDEN
+					s.Type |= objabi.SHIDDEN
 				}
 			}
 
@@ -1098,7 +1098,7 @@ func readelfsym(ctxt *Link, elfobj *ElfObj, i int, sym *ElfSym, needSym int, loc
 	}
 
 	if s != nil && s.Type == 0 && sym.type_ != ElfSymTypeSection {
-		s.Type = obj.SXREF
+		s.Type = objabi.SXREF
 	}
 	sym.sym = s
 
diff --git a/src/cmd/link/internal/ld/ldmacho.go b/src/cmd/link/internal/ld/ldmacho.go
index 54812b1808..f9d185ca9e 100644
--- a/src/cmd/link/internal/ld/ldmacho.go
+++ b/src/cmd/link/internal/ld/ldmacho.go
@@ -2,7 +2,7 @@ package ld
 
 import (
 	"cmd/internal/bio"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"encoding/binary"
 	"fmt"
@@ -602,16 +602,16 @@ func ldmacho(ctxt *Link, f *bio.Reader, pkg string, length int64, pn string) {
 
 		if sect.segname == "__TEXT" {
 			if sect.name == "__text" {
-				s.Type = obj.STEXT
+				s.Type = objabi.STEXT
 			} else {
-				s.Type = obj.SRODATA
+				s.Type = objabi.SRODATA
 			}
 		} else {
 			if sect.name == "__bss" {
-				s.Type = obj.SNOPTRBSS
+				s.Type = objabi.SNOPTRBSS
 				s.P = s.P[:0]
 			} else {
-				s.Type = obj.SNOPTRDATA
+				s.Type = objabi.SNOPTRDATA
 			}
 		}
 
@@ -663,7 +663,7 @@ func ldmacho(ctxt *Link, f *bio.Reader, pkg string, length int64, pn string) {
 			Exitf("%s: duplicate symbol reference: %s in both %s and %s", pn, s.Name, s.Outer.Name, sect.sym.Name)
 		}
 
-		s.Type = outer.Type | obj.SSUB
+		s.Type = outer.Type | objabi.SSUB
 		s.Sub = outer.Sub
 		outer.Sub = s
 		s.Outer = outer
@@ -671,7 +671,7 @@ func ldmacho(ctxt *Link, f *bio.Reader, pkg string, length int64, pn string) {
 		if !s.Attr.CgoExportDynamic() {
 			s.Dynimplib = "" // satisfy dynimport
 		}
-		if outer.Type == obj.STEXT {
+		if outer.Type == objabi.STEXT {
 			if s.Attr.External() && !s.Attr.DuplicateOK() {
 				Errorf(s, "%s: duplicate symbol definition", pn)
 			}
@@ -702,7 +702,7 @@ func ldmacho(ctxt *Link, f *bio.Reader, pkg string, length int64, pn string) {
 			}
 		}
 
-		if s.Type == obj.STEXT {
+		if s.Type == objabi.STEXT {
 			if s.Attr.OnList() {
 				log.Fatalf("symbol %s listed multiple times", s.Name)
 			}
@@ -772,7 +772,7 @@ func ldmacho(ctxt *Link, f *bio.Reader, pkg string, length int64, pn string) {
 				// want to make it pc-relative aka relative to rp->off+4
 				// but the scatter asks for relative to off = sect->rel[j+1].value - sect->addr.
 				// adjust rp->add accordingly.
-				rp.Type = obj.R_PCREL
+				rp.Type = objabi.R_PCREL
 
 				rp.Add += int64(uint64(int64(rp.Off)+4) - (uint64(sect.rel[j+1].value) - sect.addr))
 
@@ -828,7 +828,7 @@ func ldmacho(ctxt *Link, f *bio.Reader, pkg string, length int64, pn string) {
 			}
 
 			rp.Siz = rel.length
-			rp.Type = 512 + (obj.RelocType(rel.type_) << 1) + obj.RelocType(rel.pcrel)
+			rp.Type = 512 + (objabi.RelocType(rel.type_) << 1) + objabi.RelocType(rel.pcrel)
 			rp.Off = int32(rel.addr)
 
 			// Handle X86_64_RELOC_SIGNED referencing a section (rel->extrn == 0).
diff --git a/src/cmd/link/internal/ld/ldpe.go b/src/cmd/link/internal/ld/ldpe.go
index f867dbf7ad..8c7864dcef 100644
--- a/src/cmd/link/internal/ld/ldpe.go
+++ b/src/cmd/link/internal/ld/ldpe.go
@@ -6,7 +6,7 @@ package ld
 
 import (
 	"cmd/internal/bio"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"debug/pe"
 	"errors"
@@ -127,7 +127,7 @@ func ldpe(ctxt *Link, input *bio.Reader, pkg string, length int64, pn string) {
 
 func ldpeError(ctxt *Link, input *bio.Reader, pkg string, length int64, pn string) error {
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f ldpe %s\n", obj.Cputime(), pn)
+		ctxt.Logf("%5.2f ldpe %s\n", Cputime(), pn)
 	}
 
 	localSymVersion := ctxt.Syms.IncVersion()
@@ -173,16 +173,16 @@ func ldpeError(ctxt *Link, input *bio.Reader, pkg string, length int64, pn strin
 
 		switch sect.Characteristics & (IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE) {
 		case IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ: //.rdata
-			s.Type = obj.SRODATA
+			s.Type = objabi.SRODATA
 
 		case IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE: //.bss
-			s.Type = obj.SNOPTRBSS
+			s.Type = objabi.SNOPTRBSS
 
 		case IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE: //.data
-			s.Type = obj.SNOPTRDATA
+			s.Type = objabi.SNOPTRDATA
 
 		case IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ: //.text
-			s.Type = obj.STEXT
+			s.Type = objabi.STEXT
 
 		default:
 			return fmt.Errorf("unexpected flags %#06x for PE section %s", sect.Characteristics, sect.Name)
@@ -243,12 +243,12 @@ func ldpeError(ctxt *Link, input *bio.Reader, pkg string, length int64, pn strin
 			case IMAGE_REL_I386_REL32, IMAGE_REL_AMD64_REL32,
 				IMAGE_REL_AMD64_ADDR32, // R_X86_64_PC32
 				IMAGE_REL_AMD64_ADDR32NB:
-				rp.Type = obj.R_PCREL
+				rp.Type = objabi.R_PCREL
 
 				rp.Add = int64(int32(Le32(sectdata[rsect][rp.Off:])))
 
 			case IMAGE_REL_I386_DIR32NB, IMAGE_REL_I386_DIR32:
-				rp.Type = obj.R_ADDR
+				rp.Type = objabi.R_ADDR
 
 				// load addend from image
 				rp.Add = int64(int32(Le32(sectdata[rsect][rp.Off:])))
@@ -256,7 +256,7 @@ func ldpeError(ctxt *Link, input *bio.Reader, pkg string, length int64, pn strin
 			case IMAGE_REL_AMD64_ADDR64: // R_X86_64_64
 				rp.Siz = 8
 
-				rp.Type = obj.R_ADDR
+				rp.Type = objabi.R_ADDR
 
 				// load addend from image
 				rp.Add = int64(Le64(sectdata[rsect][rp.Off:]))
@@ -313,11 +313,11 @@ func ldpeError(ctxt *Link, input *bio.Reader, pkg string, length int64, pn strin
 		}
 
 		if pesym.SectionNumber == 0 { // extern
-			if s.Type == obj.SDYNIMPORT {
+			if s.Type == objabi.SDYNIMPORT {
 				s.Plt = -2 // flag for dynimport in PE object files.
 			}
-			if s.Type == obj.SXREF && pesym.Value > 0 { // global data
-				s.Type = obj.SNOPTRDATA
+			if s.Type == objabi.SXREF && pesym.Value > 0 { // global data
+				s.Type = objabi.SNOPTRDATA
 				s.Size = int64(pesym.Value)
 			}
 
@@ -345,11 +345,11 @@ func ldpeError(ctxt *Link, input *bio.Reader, pkg string, length int64, pn strin
 		sectsym := sectsyms[sect]
 		s.Sub = sectsym.Sub
 		sectsym.Sub = s
-		s.Type = sectsym.Type | obj.SSUB
+		s.Type = sectsym.Type | objabi.SSUB
 		s.Value = int64(pesym.Value)
 		s.Size = 4
 		s.Outer = sectsym
-		if sectsym.Type == obj.STEXT {
+		if sectsym.Type == objabi.STEXT {
 			if s.Attr.External() && !s.Attr.DuplicateOK() {
 				Errorf(s, "%s: duplicate symbol definition", pn)
 			}
@@ -367,7 +367,7 @@ func ldpeError(ctxt *Link, input *bio.Reader, pkg string, length int64, pn strin
 		if s.Sub != nil {
 			s.Sub = listsort(s.Sub)
 		}
-		if s.Type == obj.STEXT {
+		if s.Type == objabi.STEXT {
 			if s.Attr.OnList() {
 				log.Fatalf("symbol %s listed multiple times", s.Name)
 			}
@@ -433,7 +433,7 @@ func readpesym(ctxt *Link, f *pe.File, sym *pe.COFFSymbol, sectsyms map[*pe.Sect
 	}
 
 	if s != nil && s.Type == 0 && (sym.StorageClass != IMAGE_SYM_CLASS_STATIC || sym.Value != 0) {
-		s.Type = obj.SXREF
+		s.Type = objabi.SXREF
 	}
 	if strings.HasPrefix(symname, "__imp_") {
 		s.Got = -2 // flag for __imp_
diff --git a/src/cmd/link/internal/ld/lib.go b/src/cmd/link/internal/ld/lib.go
index 814a403d42..303d0b9304 100644
--- a/src/cmd/link/internal/ld/lib.go
+++ b/src/cmd/link/internal/ld/lib.go
@@ -34,7 +34,7 @@ import (
 	"bufio"
 	"bytes"
 	"cmd/internal/bio"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"crypto/sha1"
 	"debug/elf"
@@ -196,7 +196,7 @@ var (
 
 	debug_s  bool // backup old value of debug['s']
 	HEADR    int32
-	Headtype obj.HeadType
+	Headtype objabi.HeadType
 
 	nerrors  int
 	liveness int64
@@ -286,7 +286,7 @@ func libinit(ctxt *Link) {
 		suffix = "msan"
 	}
 
-	Lflag(ctxt, filepath.Join(obj.GOROOT, "pkg", fmt.Sprintf("%s_%s%s%s", obj.GOOS, obj.GOARCH, suffixsep, suffix)))
+	Lflag(ctxt, filepath.Join(objabi.GOROOT, "pkg", fmt.Sprintf("%s_%s%s%s", objabi.GOOS, objabi.GOARCH, suffixsep, suffix)))
 
 	mayberemoveoutfile()
 	f, err := os.OpenFile(*flagOutfile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0775)
@@ -300,9 +300,9 @@ func libinit(ctxt *Link) {
 	if *flagEntrySymbol == "" {
 		switch Buildmode {
 		case BuildmodeCShared, BuildmodeCArchive:
-			*flagEntrySymbol = fmt.Sprintf("_rt0_%s_%s_lib", obj.GOARCH, obj.GOOS)
+			*flagEntrySymbol = fmt.Sprintf("_rt0_%s_%s_lib", objabi.GOARCH, objabi.GOOS)
 		case BuildmodeExe, BuildmodePIE:
-			*flagEntrySymbol = fmt.Sprintf("_rt0_%s_%s", obj.GOARCH, obj.GOOS)
+			*flagEntrySymbol = fmt.Sprintf("_rt0_%s_%s", objabi.GOARCH, objabi.GOOS)
 		case BuildmodeShared, BuildmodePlugin:
 			// No *flagEntrySymbol for -buildmode=shared and plugin
 		default:
@@ -411,7 +411,7 @@ func (ctxt *Link) loadlib() {
 		iscgo = iscgo || ctxt.Library[i].Pkg == "runtime/cgo"
 		if ctxt.Library[i].Shlib == "" {
 			if ctxt.Debugvlog > 1 {
-				ctxt.Logf("%5.2f autolib: %s (from %s)\n", obj.Cputime(), ctxt.Library[i].File, ctxt.Library[i].Objref)
+				ctxt.Logf("%5.2f autolib: %s (from %s)\n", Cputime(), ctxt.Library[i].File, ctxt.Library[i].Objref)
 			}
 			objfile(ctxt, ctxt.Library[i])
 		}
@@ -420,7 +420,7 @@ func (ctxt *Link) loadlib() {
 	for i = 0; i < len(ctxt.Library); i++ {
 		if ctxt.Library[i].Shlib != "" {
 			if ctxt.Debugvlog > 1 {
-				ctxt.Logf("%5.2f autolib: %s (from %s)\n", obj.Cputime(), ctxt.Library[i].Shlib, ctxt.Library[i].Objref)
+				ctxt.Logf("%5.2f autolib: %s (from %s)\n", Cputime(), ctxt.Library[i].Shlib, ctxt.Library[i].Objref)
 			}
 			ldshlibsyms(ctxt, ctxt.Library[i].Shlib)
 		}
@@ -430,17 +430,17 @@ func (ctxt *Link) loadlib() {
 	determineLinkMode(ctxt)
 
 	// Recalculate pe parameters now that we have Linkmode set.
-	if Headtype == obj.Hwindows {
+	if Headtype == objabi.Hwindows {
 		Peinit(ctxt)
 	}
 
-	if Headtype == obj.Hdarwin && Linkmode == LinkExternal {
+	if Headtype == objabi.Hdarwin && Linkmode == LinkExternal {
 		*FlagTextAddr = 0
 	}
 
 	if Linkmode == LinkExternal && SysArch.Family == sys.PPC64 {
 		toc := ctxt.Syms.Lookup(".TOC.", 0)
-		toc.Type = obj.SDYNIMPORT
+		toc.Type = objabi.SDYNIMPORT
 	}
 
 	if Linkmode == LinkExternal && !iscgo {
@@ -466,13 +466,13 @@ func (ctxt *Link) loadlib() {
 		// Drop all the cgo_import_static declarations.
 		// Turns out we won't be needing them.
 		for _, s := range ctxt.Syms.Allsym {
-			if s.Type == obj.SHOSTOBJ {
+			if s.Type == objabi.SHOSTOBJ {
 				// If a symbol was marked both
 				// cgo_import_static and cgo_import_dynamic,
 				// then we want to make it cgo_import_dynamic
 				// now.
 				if s.Extname != "" && s.Dynimplib != "" && !s.Attr.CgoExport() {
-					s.Type = obj.SDYNIMPORT
+					s.Type = objabi.SDYNIMPORT
 				} else {
 					s.Type = 0
 				}
@@ -485,9 +485,9 @@ func (ctxt *Link) loadlib() {
 	// runtime.tlsg is used for external linking on platforms that do not define
 	// a variable to hold g in assembly (currently only intel).
 	if tlsg.Type == 0 {
-		tlsg.Type = obj.STLSBSS
+		tlsg.Type = objabi.STLSBSS
 		tlsg.Size = int64(SysArch.PtrSize)
-	} else if tlsg.Type != obj.SDYNIMPORT {
+	} else if tlsg.Type != objabi.SDYNIMPORT {
 		Errorf(nil, "runtime declared tlsg variable %v", tlsg.Type)
 	}
 	tlsg.Attr |= AttrReachable
@@ -500,7 +500,7 @@ func (ctxt *Link) loadlib() {
 	} else {
 		moduledata = ctxt.Syms.Lookup("runtime.firstmoduledata", 0)
 	}
-	if moduledata.Type != 0 && moduledata.Type != obj.SDYNIMPORT {
+	if moduledata.Type != 0 && moduledata.Type != objabi.SDYNIMPORT {
 		// If the module (toolchain-speak for "executable or shared
 		// library") we are linking contains the runtime package, it
 		// will define the runtime.firstmoduledata symbol and we
@@ -512,14 +512,14 @@ func (ctxt *Link) loadlib() {
 		// recording the value of GOARM.
 		if SysArch.Family == sys.ARM {
 			s := ctxt.Syms.Lookup("runtime.goarm", 0)
-			s.Type = obj.SRODATA
+			s.Type = objabi.SRODATA
 			s.Size = 0
-			Adduint8(ctxt, s, uint8(obj.GOARM))
+			Adduint8(ctxt, s, uint8(objabi.GOARM))
 		}
 
-		if obj.Framepointer_enabled(obj.GOOS, obj.GOARCH) {
+		if objabi.Framepointer_enabled(objabi.GOOS, objabi.GOARCH) {
 			s := ctxt.Syms.Lookup("runtime.framepointer_enabled", 0)
-			s.Type = obj.SRODATA
+			s.Type = objabi.SRODATA
 			s.Size = 0
 			Adduint8(ctxt, s, 1)
 		}
@@ -531,7 +531,7 @@ func (ctxt *Link) loadlib() {
 	}
 	// In all cases way we mark the moduledata as noptrdata to hide it from
 	// the GC.
-	moduledata.Type = obj.SNOPTRDATA
+	moduledata.Type = objabi.SNOPTRDATA
 	moduledata.Attr |= AttrReachable
 	ctxt.Moduledata = moduledata
 
@@ -559,7 +559,7 @@ func (ctxt *Link) loadlib() {
 		any := false
 		for _, s := range ctxt.Syms.Allsym {
 			for _, r := range s.R {
-				if r.Sym != nil && r.Sym.Type&obj.SMASK == obj.SXREF && r.Sym.Name != ".got" {
+				if r.Sym != nil && r.Sym.Type&objabi.SMASK == objabi.SXREF && r.Sym.Name != ".got" {
 					any = true
 					break
 				}
@@ -572,7 +572,7 @@ func (ctxt *Link) loadlib() {
 			if *flagLibGCC != "none" {
 				hostArchive(ctxt, *flagLibGCC)
 			}
-			if Headtype == obj.Hwindows {
+			if Headtype == objabi.Hwindows {
 				if p := ctxt.findLibPath("libmingwex.a"); p != "none" {
 					hostArchive(ctxt, p)
 				}
@@ -607,7 +607,7 @@ func (ctxt *Link) loadlib() {
 	// Also leave it enabled on Solaris which doesn't support
 	// statically linked binaries.
 	if Buildmode == BuildmodeExe {
-		if havedynamic == 0 && Headtype != obj.Hdarwin && Headtype != obj.Hsolaris {
+		if havedynamic == 0 && Headtype != objabi.Hdarwin && Headtype != objabi.Hsolaris {
 			*FlagD = true
 		}
 	}
@@ -625,7 +625,7 @@ func (ctxt *Link) loadlib() {
 	if SysArch == sys.Arch386 {
 		if (Buildmode == BuildmodeCArchive && Iself) || Buildmode == BuildmodeCShared || Buildmode == BuildmodePIE || ctxt.DynlinkingGo() {
 			got := ctxt.Syms.Lookup("_GLOBAL_OFFSET_TABLE_", 0)
-			got.Type = obj.SDYNIMPORT
+			got.Type = objabi.SDYNIMPORT
 			got.Attr |= AttrReachable
 		}
 	}
@@ -663,7 +663,7 @@ func (ctxt *Link) loadlib() {
 		// pcln table entries for these any more so remove them from Textp.
 		textp := make([]*Symbol, 0, len(ctxt.Textp))
 		for _, s := range ctxt.Textp {
-			if s.Type != obj.SDYNIMPORT {
+			if s.Type != objabi.SDYNIMPORT {
 				textp = append(textp, s)
 			}
 		}
@@ -755,7 +755,7 @@ func objfile(ctxt *Link, lib *Library) {
 	pkg := pathtoprefix(lib.Pkg)
 
 	if ctxt.Debugvlog > 1 {
-		ctxt.Logf("%5.2f ldobj: %s (%s)\n", obj.Cputime(), lib.File, pkg)
+		ctxt.Logf("%5.2f ldobj: %s (%s)\n", Cputime(), lib.File, pkg)
 	}
 	f, err := bio.Open(lib.File)
 	if err != nil {
@@ -866,7 +866,7 @@ func ldhostobj(ld func(*Link, *bio.Reader, string, int64, string), f *bio.Reader
 	// force external linking for any libraries that link in code that
 	// uses errno. This can be removed if the Go linker ever supports
 	// these relocation types.
-	if Headtype == obj.Hdragonfly {
+	if Headtype == objabi.Hdragonfly {
 		if pkg == "net" || pkg == "os/user" {
 			isinternal = false
 		}
@@ -1037,7 +1037,7 @@ func (l *Link) hostlink() {
 
 	if !*FlagS && !debug_s {
 		argv = append(argv, "-gdwarf-2")
-	} else if Headtype == obj.Hdarwin {
+	} else if Headtype == objabi.Hdarwin {
 		// Recent versions of macOS print
 		//	ld: warning: option -s is obsolete and being ignored
 		// so do not pass any arguments.
@@ -1046,16 +1046,16 @@ func (l *Link) hostlink() {
 	}
 
 	switch Headtype {
-	case obj.Hdarwin:
+	case objabi.Hdarwin:
 		argv = append(argv, "-Wl,-headerpad,1144")
 		if l.DynlinkingGo() {
 			argv = append(argv, "-Wl,-flat_namespace")
 		} else {
 			argv = append(argv, "-Wl,-no_pie")
 		}
-	case obj.Hopenbsd:
+	case objabi.Hopenbsd:
 		argv = append(argv, "-Wl,-nopie")
-	case obj.Hwindows:
+	case objabi.Hwindows:
 		if windowsgui {
 			argv = append(argv, "-mwindows")
 		} else {
@@ -1065,7 +1065,7 @@ func (l *Link) hostlink() {
 
 	switch Buildmode {
 	case BuildmodeExe:
-		if Headtype == obj.Hdarwin {
+		if Headtype == objabi.Hdarwin {
 			argv = append(argv, "-Wl,-pagezero_size,4000000")
 		}
 	case BuildmodePIE:
@@ -1074,7 +1074,7 @@ func (l *Link) hostlink() {
 		}
 		argv = append(argv, "-pie")
 	case BuildmodeCShared:
-		if Headtype == obj.Hdarwin {
+		if Headtype == objabi.Hdarwin {
 			argv = append(argv, "-dynamiclib", "-Wl,-read_only_relocs,suppress")
 		} else {
 			// ELF.
@@ -1092,7 +1092,7 @@ func (l *Link) hostlink() {
 		}
 		argv = append(argv, "-shared")
 	case BuildmodePlugin:
-		if Headtype == obj.Hdarwin {
+		if Headtype == objabi.Hdarwin {
 			argv = append(argv, "-dynamiclib")
 		} else {
 			if UseRelro() {
@@ -1147,7 +1147,7 @@ func (l *Link) hostlink() {
 	// only want to do this when producing a Windows output file
 	// on a Windows host.
 	outopt := *flagOutfile
-	if obj.GOOS == "windows" && runtime.GOOS == "windows" && filepath.Ext(outopt) == "" {
+	if objabi.GOOS == "windows" && runtime.GOOS == "windows" && filepath.Ext(outopt) == "" {
 		outopt += "."
 	}
 	argv = append(argv, "-o")
@@ -1243,7 +1243,7 @@ func (l *Link) hostlink() {
 			}
 		}
 	}
-	if Headtype == obj.Hwindows {
+	if Headtype == objabi.Hwindows {
 		// libmingw32 and libmingwex have some inter-dependencies,
 		// so must use linker groups.
 		argv = append(argv, "-Wl,--start-group", "-lmingwex", "-lmingw32", "-Wl,--end-group")
@@ -1251,7 +1251,7 @@ func (l *Link) hostlink() {
 	}
 
 	if l.Debugvlog != 0 {
-		l.Logf("%5.2f host link:", obj.Cputime())
+		l.Logf("%5.2f host link:", Cputime())
 		for _, v := range argv {
 			l.Logf(" %q", v)
 		}
@@ -1264,7 +1264,7 @@ func (l *Link) hostlink() {
 		l.Logf("%s", out)
 	}
 
-	if !*FlagS && !*FlagW && !debug_s && Headtype == obj.Hdarwin {
+	if !*FlagS && !*FlagW && !debug_s && Headtype == objabi.Hdarwin {
 		// Skip combining dwarf on arm.
 		if !SysArch.InFamily(sys.ARM, sys.ARM64) {
 			dsym := filepath.Join(*flagTmpdir, "go.dwarf")
@@ -1359,7 +1359,7 @@ func ldobj(ctxt *Link, f *bio.Reader, lib *Library, length int64, pn string, fil
 	}
 
 	// First, check that the basic GOOS, GOARCH, and Version match.
-	t := fmt.Sprintf("%s %s %s ", obj.GOOS, obj.GOARCH, obj.Version)
+	t := fmt.Sprintf("%s %s %s ", objabi.GOOS, objabi.GOARCH, objabi.Version)
 
 	line = strings.TrimRight(line, "\n")
 	if !strings.HasPrefix(line[10:]+" ", t) && !*flagF {
@@ -1489,7 +1489,7 @@ func ldshlibsyms(ctxt *Link, shlib string) {
 		}
 	}
 	if ctxt.Debugvlog > 1 {
-		ctxt.Logf("%5.2f ldshlibsyms: found library with name %s at %s\n", obj.Cputime(), shlib, libpath)
+		ctxt.Logf("%5.2f ldshlibsyms: found library with name %s at %s\n", Cputime(), shlib, libpath)
 	}
 
 	f, err := elf.Open(libpath)
@@ -1526,10 +1526,10 @@ func ldshlibsyms(ctxt *Link, shlib string) {
 		// libraries, any non-dynimport symbols we find that duplicate symbols
 		// already loaded should be ignored (the symbols from the .a files
 		// "win").
-		if lsym.Type != 0 && lsym.Type != obj.SDYNIMPORT {
+		if lsym.Type != 0 && lsym.Type != objabi.SDYNIMPORT {
 			continue
 		}
-		lsym.Type = obj.SDYNIMPORT
+		lsym.Type = objabi.SDYNIMPORT
 		lsym.ElfType = elf.ST_TYPE(elfsym.Info)
 		lsym.Size = int64(elfsym.Size)
 		if elfsym.Section != elf.SHN_UNDEF {
@@ -1667,7 +1667,7 @@ func (ctxt *Link) dostkcheck() {
 	// of non-splitting functions.
 	ch.up = nil
 
-	ch.limit = obj.StackLimit - callsize(ctxt)
+	ch.limit = objabi.StackLimit - callsize(ctxt)
 
 	// Check every function, but do the nosplit functions in a first pass,
 	// to make the printed failure chains as short as possible.
@@ -1699,7 +1699,7 @@ func stkcheck(ctxt *Link, up *chain, depth int) int {
 
 	// Don't duplicate work: only need to consider each
 	// function at top of safe zone once.
-	top := limit == obj.StackLimit-callsize(ctxt)
+	top := limit == objabi.StackLimit-callsize(ctxt)
 	if top {
 		if s.Attr.StackCheck() {
 			return 0
@@ -1718,7 +1718,7 @@ func stkcheck(ctxt *Link, up *chain, depth int) int {
 		// should never be called directly.
 		// onlyctxt.Diagnose the direct caller.
 		// TODO(mwhudson): actually think about this.
-		if depth == 1 && s.Type != obj.SXREF && !ctxt.DynlinkingGo() &&
+		if depth == 1 && s.Type != objabi.SXREF && !ctxt.DynlinkingGo() &&
 			Buildmode != BuildmodeCArchive && Buildmode != BuildmodePIE && Buildmode != BuildmodeCShared && Buildmode != BuildmodePlugin {
 
 			Errorf(s, "call to external function")
@@ -1755,7 +1755,7 @@ func stkcheck(ctxt *Link, up *chain, depth int) int {
 		if s.FuncInfo != nil {
 			locals = s.FuncInfo.Locals
 		}
-		limit = int(obj.StackLimit+locals) + int(ctxt.FixedFrameSize())
+		limit = int(objabi.StackLimit+locals) + int(ctxt.FixedFrameSize())
 	}
 
 	// Walk through sp adjustments in function, consuming relocs.
@@ -1779,7 +1779,7 @@ func stkcheck(ctxt *Link, up *chain, depth int) int {
 			r = &s.R[ri]
 			switch r.Type {
 			// Direct call.
-			case obj.R_CALL, obj.R_CALLARM, obj.R_CALLARM64, obj.R_CALLPOWER, obj.R_CALLMIPS:
+			case objabi.R_CALL, objabi.R_CALLARM, objabi.R_CALLARM64, objabi.R_CALLPOWER, objabi.R_CALLMIPS:
 				ch.limit = int(int32(limit) - pcsp.value - int32(callsize(ctxt)))
 				ch.sym = r.Sym
 				if stkcheck(ctxt, &ch, depth+1) < 0 {
@@ -1790,7 +1790,7 @@ func stkcheck(ctxt *Link, up *chain, depth int) int {
 			// so we have to make sure it can call morestack.
 			// Arrange the data structures to report both calls, so that
 			// if there is an error, stkprint shows all the steps involved.
-			case obj.R_CALLIND:
+			case objabi.R_CALLIND:
 				ch.limit = int(int32(limit) - pcsp.value - int32(callsize(ctxt)))
 
 				ch.sym = nil
@@ -1875,12 +1875,12 @@ func Cput(c uint8) {
 
 func usage() {
 	fmt.Fprintf(os.Stderr, "usage: link [options] main.o\n")
-	obj.Flagprint(2)
+	objabi.Flagprint(2)
 	Exit(2)
 }
 
 func doversion() {
-	Exitf("version %s", obj.Version)
+	Exitf("version %s", objabi.Version)
 }
 
 type SymbolType int8
@@ -1901,7 +1901,7 @@ func genasmsym(ctxt *Link, put func(*Link, *Symbol, string, SymbolType, int64, *
 	// These symbols won't show up in the first loop below because we
 	// skip STEXT symbols. Normal STEXT symbols are emitted by walking textp.
 	s := ctxt.Syms.Lookup("runtime.text", 0)
-	if s.Type == obj.STEXT {
+	if s.Type == objabi.STEXT {
 		put(ctxt, s, s.Name, TextSym, s.Value, nil)
 	}
 
@@ -1920,14 +1920,14 @@ func genasmsym(ctxt *Link, put func(*Link, *Symbol, string, SymbolType, int64, *
 		if s == nil {
 			break
 		}
-		if s.Type == obj.STEXT {
+		if s.Type == objabi.STEXT {
 			put(ctxt, s, s.Name, TextSym, s.Value, nil)
 		}
 		n++
 	}
 
 	s = ctxt.Syms.Lookup("runtime.etext", 0)
-	if s.Type == obj.STEXT {
+	if s.Type == objabi.STEXT {
 		put(ctxt, s, s.Name, TextSym, s.Value, nil)
 	}
 
@@ -1938,36 +1938,36 @@ func genasmsym(ctxt *Link, put func(*Link, *Symbol, string, SymbolType, int64, *
 		if (s.Name == "" || s.Name[0] == '.') && s.Version == 0 && s.Name != ".rathole" && s.Name != ".TOC." {
 			continue
 		}
-		switch s.Type & obj.SMASK {
-		case obj.SCONST,
-			obj.SRODATA,
-			obj.SSYMTAB,
-			obj.SPCLNTAB,
-			obj.SINITARR,
-			obj.SDATA,
-			obj.SNOPTRDATA,
-			obj.SELFROSECT,
-			obj.SMACHOGOT,
-			obj.STYPE,
-			obj.SSTRING,
-			obj.SGOSTRING,
-			obj.SGOFUNC,
-			obj.SGCBITS,
-			obj.STYPERELRO,
-			obj.SSTRINGRELRO,
-			obj.SGOSTRINGRELRO,
-			obj.SGOFUNCRELRO,
-			obj.SGCBITSRELRO,
-			obj.SRODATARELRO,
-			obj.STYPELINK,
-			obj.SITABLINK,
-			obj.SWINDOWS:
+		switch s.Type & objabi.SMASK {
+		case objabi.SCONST,
+			objabi.SRODATA,
+			objabi.SSYMTAB,
+			objabi.SPCLNTAB,
+			objabi.SINITARR,
+			objabi.SDATA,
+			objabi.SNOPTRDATA,
+			objabi.SELFROSECT,
+			objabi.SMACHOGOT,
+			objabi.STYPE,
+			objabi.SSTRING,
+			objabi.SGOSTRING,
+			objabi.SGOFUNC,
+			objabi.SGCBITS,
+			objabi.STYPERELRO,
+			objabi.SSTRINGRELRO,
+			objabi.SGOSTRINGRELRO,
+			objabi.SGOFUNCRELRO,
+			objabi.SGCBITSRELRO,
+			objabi.SRODATARELRO,
+			objabi.STYPELINK,
+			objabi.SITABLINK,
+			objabi.SWINDOWS:
 			if !s.Attr.Reachable() {
 				continue
 			}
 			put(ctxt, s, s.Name, DataSym, Symaddr(s), s.Gotype)
 
-		case obj.SBSS, obj.SNOPTRBSS:
+		case objabi.SBSS, objabi.SNOPTRBSS:
 			if !s.Attr.Reachable() {
 				continue
 			}
@@ -1976,21 +1976,21 @@ func genasmsym(ctxt *Link, put func(*Link, *Symbol, string, SymbolType, int64, *
 			}
 			put(ctxt, s, s.Name, BSSSym, Symaddr(s), s.Gotype)
 
-		case obj.SFILE:
+		case objabi.SFILE:
 			put(ctxt, nil, s.Name, FileSym, s.Value, nil)
 
-		case obj.SHOSTOBJ:
-			if Headtype == obj.Hwindows || Iself {
+		case objabi.SHOSTOBJ:
+			if Headtype == objabi.Hwindows || Iself {
 				put(ctxt, s, s.Name, UndefinedSym, s.Value, nil)
 			}
 
-		case obj.SDYNIMPORT:
+		case objabi.SDYNIMPORT:
 			if !s.Attr.Reachable() {
 				continue
 			}
 			put(ctxt, s, s.Extname, UndefinedSym, 0, nil)
 
-		case obj.STLSBSS:
+		case objabi.STLSBSS:
 			if Linkmode == LinkExternal {
 				put(ctxt, s, s.Name, TLSSym, Symaddr(s), s.Gotype)
 			}
@@ -2014,12 +2014,12 @@ func genasmsym(ctxt *Link, put func(*Link, *Symbol, string, SymbolType, int64, *
 		for _, a := range s.FuncInfo.Autom {
 			// Emit a or p according to actual offset, even if label is wrong.
 			// This avoids negative offsets, which cannot be encoded.
-			if a.Name != obj.A_AUTO && a.Name != obj.A_PARAM {
+			if a.Name != objabi.A_AUTO && a.Name != objabi.A_PARAM {
 				continue
 			}
 
 			// compute offset relative to FP
-			if a.Name == obj.A_PARAM {
+			if a.Name == objabi.A_PARAM {
 				off = a.Aoffset
 			} else {
 				off = a.Aoffset - int32(SysArch.PtrSize)
@@ -2042,7 +2042,7 @@ func genasmsym(ctxt *Link, put func(*Link, *Symbol, string, SymbolType, int64, *
 	}
 
 	if ctxt.Debugvlog != 0 || *flagN {
-		ctxt.Logf("%5.2f symsize = %d\n", obj.Cputime(), uint32(Symsize))
+		ctxt.Logf("%5.2f symsize = %d\n", Cputime(), uint32(Symsize))
 	}
 }
 
@@ -2053,7 +2053,7 @@ func Symaddr(s *Symbol) int64 {
 	return s.Value
 }
 
-func (ctxt *Link) xdefine(p string, t obj.SymKind, v int64) {
+func (ctxt *Link) xdefine(p string, t objabi.SymKind, v int64) {
 	s := ctxt.Syms.Lookup(p, 0)
 	s.Type = t
 	s.Value = v
@@ -2082,7 +2082,7 @@ func Entryvalue(ctxt *Link) int64 {
 	if s.Type == 0 {
 		return *FlagTextAddr
 	}
-	if s.Type != obj.STEXT {
+	if s.Type != objabi.STEXT {
 		Errorf(s, "entry not text")
 	}
 	return s.Value
@@ -2096,10 +2096,10 @@ func undefsym(ctxt *Link, s *Symbol) {
 		if r.Sym == nil { // happens for some external ARM relocs
 			continue
 		}
-		if r.Sym.Type == obj.Sxxx || r.Sym.Type == obj.SXREF {
+		if r.Sym.Type == objabi.Sxxx || r.Sym.Type == objabi.SXREF {
 			Errorf(s, "undefined: %q", r.Sym.Name)
 		}
-		if !r.Sym.Attr.Reachable() && r.Type != obj.R_WEAKADDROFF {
+		if !r.Sym.Attr.Reachable() && r.Type != objabi.R_WEAKADDROFF {
 			Errorf(s, "relocation target %q", r.Sym.Name)
 		}
 	}
@@ -2130,7 +2130,7 @@ func (ctxt *Link) callgraph() {
 			if r.Sym == nil {
 				continue
 			}
-			if (r.Type == obj.R_CALL || r.Type == obj.R_CALLARM || r.Type == obj.R_CALLPOWER || r.Type == obj.R_CALLMIPS) && r.Sym.Type == obj.STEXT {
+			if (r.Type == objabi.R_CALL || r.Type == objabi.R_CALLARM || r.Type == objabi.R_CALLPOWER || r.Type == objabi.R_CALLMIPS) && r.Sym.Type == objabi.STEXT {
 				ctxt.Logf("%s calls %s\n", s.Name, r.Sym.Name)
 			}
 		}
diff --git a/src/cmd/link/internal/ld/link.go b/src/cmd/link/internal/ld/link.go
index 1c61835da6..96e084f0f7 100644
--- a/src/cmd/link/internal/ld/link.go
+++ b/src/cmd/link/internal/ld/link.go
@@ -32,7 +32,7 @@ package ld
 
 import (
 	"bufio"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"debug/elf"
 	"fmt"
@@ -42,7 +42,7 @@ import (
 type Symbol struct {
 	Name        string
 	Extname     string
-	Type        obj.SymKind
+	Type        objabi.SymKind
 	Version     int16
 	Attr        Attribute
 	Localentry  uint8
@@ -146,15 +146,15 @@ func (a *Attribute) Set(flag Attribute, value bool) {
 //
 // Some relocations are created by cmd/link.
 type Reloc struct {
-	Off     int32         // offset to rewrite
-	Siz     uint8         // number of bytes to rewrite, 1, 2, or 4
-	Done    uint8         // set to 1 when relocation is complete
-	Variant RelocVariant  // variation on Type
-	Type    obj.RelocType // the relocation type
-	Add     int64         // addend
-	Xadd    int64         // addend passed to external linker
-	Sym     *Symbol       // symbol the relocation addresses
-	Xsym    *Symbol       // symbol passed to external linker
+	Off     int32            // offset to rewrite
+	Siz     uint8            // number of bytes to rewrite, 1, 2, or 4
+	Done    uint8            // set to 1 when relocation is complete
+	Variant RelocVariant     // variation on Type
+	Type    objabi.RelocType // the relocation type
+	Add     int64            // addend
+	Xadd    int64            // addend passed to external linker
+	Sym     *Symbol          // symbol the relocation addresses
+	Xsym    *Symbol          // symbol passed to external linker
 }
 
 type Auto struct {
diff --git a/src/cmd/link/internal/ld/macho.go b/src/cmd/link/internal/ld/macho.go
index 9234be1aef..50a681fabd 100644
--- a/src/cmd/link/internal/ld/macho.go
+++ b/src/cmd/link/internal/ld/macho.go
@@ -5,7 +5,7 @@
 package ld
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"sort"
 	"strings"
@@ -302,31 +302,31 @@ func (ctxt *Link) domacho() {
 	// empirically, string table must begin with " \x00".
 	s := ctxt.Syms.Lookup(".machosymstr", 0)
 
-	s.Type = obj.SMACHOSYMSTR
+	s.Type = objabi.SMACHOSYMSTR
 	s.Attr |= AttrReachable
 	Adduint8(ctxt, s, ' ')
 	Adduint8(ctxt, s, '\x00')
 
 	s = ctxt.Syms.Lookup(".machosymtab", 0)
-	s.Type = obj.SMACHOSYMTAB
+	s.Type = objabi.SMACHOSYMTAB
 	s.Attr |= AttrReachable
 
 	if Linkmode != LinkExternal {
 		s := ctxt.Syms.Lookup(".plt", 0) // will be __symbol_stub
-		s.Type = obj.SMACHOPLT
+		s.Type = objabi.SMACHOPLT
 		s.Attr |= AttrReachable
 
 		s = ctxt.Syms.Lookup(".got", 0) // will be __nl_symbol_ptr
-		s.Type = obj.SMACHOGOT
+		s.Type = objabi.SMACHOGOT
 		s.Attr |= AttrReachable
 		s.Align = 4
 
 		s = ctxt.Syms.Lookup(".linkedit.plt", 0) // indirect table for .plt
-		s.Type = obj.SMACHOINDIRECTPLT
+		s.Type = objabi.SMACHOINDIRECTPLT
 		s.Attr |= AttrReachable
 
 		s = ctxt.Syms.Lookup(".linkedit.got", 0) // indirect table for .got
-		s.Type = obj.SMACHOINDIRECTGOT
+		s.Type = objabi.SMACHOINDIRECTGOT
 		s.Attr |= AttrReachable
 	}
 }
@@ -603,7 +603,7 @@ func Asmbmacho(ctxt *Link) {
 }
 
 func symkind(s *Symbol) int {
-	if s.Type == obj.SDYNIMPORT {
+	if s.Type == objabi.SDYNIMPORT {
 		return SymKindUndef
 	}
 	if s.Attr.CgoExport() {
@@ -659,7 +659,7 @@ func (x machoscmp) Less(i, j int) bool {
 func machogenasmsym(ctxt *Link) {
 	genasmsym(ctxt, addsym)
 	for _, s := range ctxt.Syms.Allsym {
-		if s.Type == obj.SDYNIMPORT || s.Type == obj.SHOSTOBJ {
+		if s.Type == objabi.SDYNIMPORT || s.Type == objabi.SHOSTOBJ {
 			if s.Attr.Reachable() {
 				addsym(ctxt, s, "", DataSym, 0, nil)
 			}
@@ -704,7 +704,7 @@ func machoShouldExport(ctxt *Link, s *Symbol) bool {
 	if strings.HasPrefix(s.Name, "go.link.pkghash") {
 		return true
 	}
-	return s.Type >= obj.SELFSECT // only writable sections
+	return s.Type >= objabi.SELFSECT // only writable sections
 }
 
 func machosymtab(ctxt *Link) {
@@ -732,7 +732,7 @@ func machosymtab(ctxt *Link) {
 		// replace "" as ".", because DTrace cannot handle it.
 		Addstring(symstr, strings.Replace(s.Extname, "", ".", -1))
 
-		if s.Type == obj.SDYNIMPORT || s.Type == obj.SHOSTOBJ {
+		if s.Type == objabi.SDYNIMPORT || s.Type == objabi.SHOSTOBJ {
 			Adduint8(ctxt, symtab, 0x01)                // type N_EXT, external symbol
 			Adduint8(ctxt, symtab, 0)                   // no section
 			Adduint16(ctxt, symtab, 0)                  // desc
diff --git a/src/cmd/link/internal/ld/main.go b/src/cmd/link/internal/ld/main.go
index 89326fd65f..0078064f28 100644
--- a/src/cmd/link/internal/ld/main.go
+++ b/src/cmd/link/internal/ld/main.go
@@ -32,7 +32,7 @@ package ld
 
 import (
 	"bufio"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"flag"
 	"log"
@@ -114,21 +114,21 @@ func Main() {
 	}
 
 	// TODO(matloob): define these above and then check flag values here
-	if SysArch.Family == sys.AMD64 && obj.GOOS == "plan9" {
+	if SysArch.Family == sys.AMD64 && objabi.GOOS == "plan9" {
 		flag.BoolVar(&Flag8, "8", false, "use 64-bit addresses in symbol table")
 	}
-	obj.Flagfn1("B", "add an ELF NT_GNU_BUILD_ID `note` when using ELF", addbuildinfo)
-	obj.Flagfn1("L", "add specified `directory` to library path", func(a string) { Lflag(ctxt, a) })
-	obj.Flagfn0("V", "print version and exit", doversion)
-	obj.Flagfn1("X", "add string value `definition` of the form importpath.name=value", func(s string) { addstrdata1(ctxt, s) })
-	obj.Flagcount("v", "print link trace", &ctxt.Debugvlog)
+	objabi.Flagfn1("B", "add an ELF NT_GNU_BUILD_ID `note` when using ELF", addbuildinfo)
+	objabi.Flagfn1("L", "add specified `directory` to library path", func(a string) { Lflag(ctxt, a) })
+	objabi.Flagfn0("V", "print version and exit", doversion)
+	objabi.Flagfn1("X", "add string value `definition` of the form importpath.name=value", func(s string) { addstrdata1(ctxt, s) })
+	objabi.Flagcount("v", "print link trace", &ctxt.Debugvlog)
 
-	obj.Flagparse(usage)
+	objabi.Flagparse(usage)
 
 	switch *flagHeadtype {
 	case "":
 	case "windowsgui":
-		Headtype = obj.Hwindows
+		Headtype = objabi.Hwindows
 		windowsgui = true
 	default:
 		if err := Headtype.Set(*flagHeadtype); err != nil {
@@ -148,7 +148,7 @@ func Main() {
 
 	if *flagOutfile == "" {
 		*flagOutfile = "a.out"
-		if Headtype == obj.Hwindows {
+		if Headtype == objabi.Hwindows {
 			*flagOutfile += ".exe"
 		}
 	}
@@ -157,8 +157,8 @@ func Main() {
 
 	libinit(ctxt) // creates outfile
 
-	if Headtype == obj.Hunknown {
-		Headtype.Set(obj.GOOS)
+	if Headtype == objabi.Hunknown {
+		Headtype.Set(objabi.GOOS)
 	}
 
 	ctxt.computeTLSOffset()
@@ -200,11 +200,11 @@ func Main() {
 	ctxt.callgraph()
 
 	ctxt.doelf()
-	if Headtype == obj.Hdarwin {
+	if Headtype == objabi.Hdarwin {
 		ctxt.domacho()
 	}
 	ctxt.dostkcheck()
-	if Headtype == obj.Hwindows {
+	if Headtype == objabi.Hwindows {
 		ctxt.dope()
 	}
 	ctxt.addexport()
@@ -223,7 +223,7 @@ func Main() {
 	ctxt.hostlink()
 	ctxt.archive()
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f cpu time\n", obj.Cputime())
+		ctxt.Logf("%5.2f cpu time\n", Cputime())
 		ctxt.Logf("%d symbols\n", len(ctxt.Syms.Allsym))
 		ctxt.Logf("%d liveness data\n", liveness)
 	}
diff --git a/src/cmd/link/internal/ld/objfile.go b/src/cmd/link/internal/ld/objfile.go
index 0ad4c6a404..d543b12b2b 100644
--- a/src/cmd/link/internal/ld/objfile.go
+++ b/src/cmd/link/internal/ld/objfile.go
@@ -5,119 +5,13 @@
 package ld
 
 // Reading of Go object files.
-//
-// Originally, Go object files were Plan 9 object files, but no longer.
-// Now they are more like standard object files, in that each symbol is defined
-// by an associated memory image (bytes) and a list of relocations to apply
-// during linking. We do not (yet?) use a standard file format, however.
-// For now, the format is chosen to be as simple as possible to read and write.
-// It may change for reasons of efficiency, or we may even switch to a
-// standard file format if there are compelling benefits to doing so.
-// See golang.org/s/go13linker for more background.
-//
-// The file format is:
-//
-//	- magic header: "\x00\x00go19ld"
-//	- byte 1 - version number
-//	- sequence of strings giving dependencies (imported packages)
-//	- empty string (marks end of sequence)
-//	- sequence of symbol references used by the defined symbols
-//	- byte 0xff (marks end of sequence)
-//	- sequence of integer lengths:
-//		- total data length
-//		- total number of relocations
-//		- total number of pcdata
-//		- total number of automatics
-//		- total number of funcdata
-//		- total number of files
-//	- data, the content of the defined symbols
-//	- sequence of defined symbols
-//	- byte 0xff (marks end of sequence)
-//	- magic footer: "\xff\xffgo19ld"
-//
-// All integers are stored in a zigzag varint format.
-// See golang.org/s/go12symtab for a definition.
-//
-// Data blocks and strings are both stored as an integer
-// followed by that many bytes.
-//
-// A symbol reference is a string name followed by a version.
-//
-// A symbol points to other symbols using an index into the symbol
-// reference sequence. Index 0 corresponds to a nil Object* pointer.
-// In the symbol layout described below "symref index" stands for this
-// index.
-//
-// Each symbol is laid out as the following fields (taken from Object*):
-//
-//	- byte 0xfe (sanity check for synchronization)
-//	- type [int]
-//	- name & version [symref index]
-//	- flags [int]
-//		1<<0 dupok
-//		1<<1 local
-//		1<<2 add to typelink table
-//	- size [int]
-//	- gotype [symref index]
-//	- p [data block]
-//	- nr [int]
-//	- r [nr relocations, sorted by off]
-//
-// If type == STEXT, there are a few more fields:
-//
-//	- args [int]
-//	- locals [int]
-//	- nosplit [int]
-//	- flags [int]
-//		1<<0 leaf
-//		1<<1 C function
-//		1<<2 function may call reflect.Type.Method
-//	- nlocal [int]
-//	- local [nlocal automatics]
-//	- pcln [pcln table]
-//
-// Each relocation has the encoding:
-//
-//	- off [int]
-//	- siz [int]
-//	- type [int]
-//	- add [int]
-//	- sym [symref index]
-//
-// Each local has the encoding:
-//
-//	- asym [symref index]
-//	- offset [int]
-//	- type [int]
-//	- gotype [symref index]
-//
-// The pcln table has the encoding:
-//
-//	- pcsp [data block]
-//	- pcfile [data block]
-//	- pcline [data block]
-//	- pcinline [data block]
-//	- npcdata [int]
-//	- pcdata [npcdata data blocks]
-//	- nfuncdata [int]
-//	- funcdata [nfuncdata symref index]
-//	- funcdatasym [nfuncdata ints]
-//	- nfile [int]
-//	- file [nfile symref index]
-//	- ninlinedcall [int]
-//	- inlinedcall [ninlinedcall int symref int symref]
-//
-// The file layout and meaning of type integers are architecture-independent.
-//
-// TODO(rsc): The file format is good for a first pass but needs work.
-//	- There are SymID in the object file that should really just be strings.
 
 import (
 	"bufio"
 	"bytes"
 	"cmd/internal/bio"
 	"cmd/internal/dwarf"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"crypto/sha1"
 	"encoding/base64"
 	"io"
@@ -264,7 +158,7 @@ func (r *objReader) readSym() {
 	if c, err := r.rd.ReadByte(); c != symPrefix || err != nil {
 		log.Fatalln("readSym out of sync")
 	}
-	t := obj.SymKind(r.readInt())
+	t := objabi.SymKind(r.readInt())
 	s := r.readSymIndex()
 	flags := r.readInt()
 	dupok := flags&1 != 0
@@ -278,8 +172,8 @@ func (r *objReader) readSym() {
 	isdup := false
 
 	var dup *Symbol
-	if s.Type != 0 && s.Type != obj.SXREF {
-		if (t == obj.SDATA || t == obj.SBSS || t == obj.SNOPTRBSS) && len(data) == 0 && nreloc == 0 {
+	if s.Type != 0 && s.Type != objabi.SXREF {
+		if (t == objabi.SDATA || t == objabi.SBSS || t == objabi.SNOPTRBSS) && len(data) == 0 && nreloc == 0 {
 			if s.Size < int64(size) {
 				s.Size = int64(size)
 			}
@@ -289,10 +183,10 @@ func (r *objReader) readSym() {
 			return
 		}
 
-		if (s.Type == obj.SDATA || s.Type == obj.SBSS || s.Type == obj.SNOPTRBSS) && len(s.P) == 0 && len(s.R) == 0 {
+		if (s.Type == objabi.SDATA || s.Type == objabi.SBSS || s.Type == objabi.SNOPTRBSS) && len(s.P) == 0 && len(s.R) == 0 {
 			goto overwrite
 		}
-		if s.Type != obj.SBSS && s.Type != obj.SNOPTRBSS && !dupok && !s.Attr.DuplicateOK() {
+		if s.Type != objabi.SBSS && s.Type != objabi.SNOPTRBSS && !dupok && !s.Attr.DuplicateOK() {
 			log.Fatalf("duplicate symbol %s (types %d and %d) in %s and %s", s.Name, s.Type, t, s.File, r.pn)
 		}
 		if len(s.P) > 0 {
@@ -307,13 +201,13 @@ overwrite:
 	if dupok {
 		s.Attr |= AttrDuplicateOK
 	}
-	if t == obj.SXREF {
+	if t == objabi.SXREF {
 		log.Fatalf("bad sxref")
 	}
 	if t == 0 {
 		log.Fatalf("missing type for %s in %s", s.Name, r.pn)
 	}
-	if t == obj.SBSS && (s.Type == obj.SRODATA || s.Type == obj.SNOPTRBSS) {
+	if t == objabi.SBSS && (s.Type == objabi.SRODATA || s.Type == objabi.SNOPTRBSS) {
 		t = s.Type
 	}
 	s.Type = t
@@ -339,14 +233,14 @@ overwrite:
 			s.R[i] = Reloc{
 				Off:  r.readInt32(),
 				Siz:  r.readUint8(),
-				Type: obj.RelocType(r.readInt32()),
+				Type: objabi.RelocType(r.readInt32()),
 				Add:  r.readInt64(),
 				Sym:  r.readSymIndex(),
 			}
 		}
 	}
 
-	if s.Type == obj.STEXT {
+	if s.Type == objabi.STEXT {
 		s.FuncInfo = new(FuncInfo)
 		pc := s.FuncInfo
 
@@ -432,7 +326,7 @@ overwrite:
 			}
 		}
 	}
-	if s.Type == obj.SDWARFINFO {
+	if s.Type == objabi.SDWARFINFO {
 		r.patchDWARFName(s)
 	}
 }
@@ -495,7 +389,7 @@ func (r *objReader) readRef() {
 		if err != nil {
 			log.Panicf("failed to parse $-symbol %s: %v", s.Name, err)
 		}
-		s.Type = obj.SRODATA
+		s.Type = objabi.SRODATA
 		s.Attr |= AttrLocal
 		switch s.Name[:5] {
 		case "$f32.":
diff --git a/src/cmd/link/internal/ld/pcln.go b/src/cmd/link/internal/ld/pcln.go
index 6df09bd817..396114fa3a 100644
--- a/src/cmd/link/internal/ld/pcln.go
+++ b/src/cmd/link/internal/ld/pcln.go
@@ -5,7 +5,7 @@
 package ld
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/src"
 	"log"
 	"os"
@@ -111,10 +111,10 @@ func ftabaddstring(ctxt *Link, ftab *Symbol, s string) int32 {
 
 // numberfile assigns a file number to the file if it hasn't been assigned already.
 func numberfile(ctxt *Link, file *Symbol) {
-	if file.Type != obj.SFILEPATH {
+	if file.Type != objabi.SFILEPATH {
 		ctxt.Filesyms = append(ctxt.Filesyms, file)
 		file.Value = int64(len(ctxt.Filesyms))
-		file.Type = obj.SFILEPATH
+		file.Type = objabi.SFILEPATH
 		path := file.Name[len(src.FileSymPrefix):]
 		file.Name = expandGoroot(path)
 	}
@@ -175,12 +175,12 @@ func container(s *Symbol) int {
 	if s == nil {
 		return 0
 	}
-	if Buildmode == BuildmodePlugin && Headtype == obj.Hdarwin && onlycsymbol(s) {
+	if Buildmode == BuildmodePlugin && Headtype == objabi.Hdarwin && onlycsymbol(s) {
 		return 1
 	}
 	// We want to generate func table entries only for the "lowest level" symbols,
 	// not containers of subsymbols.
-	if s.Type&obj.SCONTAINER != 0 {
+	if s.Type&objabi.SCONTAINER != 0 {
 		return 1
 	}
 	return 0
@@ -201,7 +201,7 @@ var pclntabLastFunc *Symbol
 func (ctxt *Link) pclntab() {
 	funcdataBytes := int64(0)
 	ftab := ctxt.Syms.Lookup("runtime.pclntab", 0)
-	ftab.Type = obj.SPCLNTAB
+	ftab.Type = objabi.SPCLNTAB
 	ftab.Attr |= AttrReachable
 
 	// See golang.org/s/go12symtab for the format. Briefly:
@@ -215,7 +215,7 @@ func (ctxt *Link) pclntab() {
 	// Find container symbols, mark them with SCONTAINER
 	for _, s := range ctxt.Textp {
 		if s.Outer != nil {
-			s.Outer.Type |= obj.SCONTAINER
+			s.Outer.Type |= objabi.SCONTAINER
 		}
 	}
 
@@ -260,17 +260,17 @@ func (ctxt *Link) pclntab() {
 		}
 
 		if len(pcln.InlTree) > 0 {
-			if len(pcln.Pcdata) <= obj.PCDATA_InlTreeIndex {
+			if len(pcln.Pcdata) <= objabi.PCDATA_InlTreeIndex {
 				// Create inlining pcdata table.
-				pcdata := make([]Pcdata, obj.PCDATA_InlTreeIndex+1)
+				pcdata := make([]Pcdata, objabi.PCDATA_InlTreeIndex+1)
 				copy(pcdata, pcln.Pcdata)
 				pcln.Pcdata = pcdata
 			}
 
-			if len(pcln.Funcdataoff) <= obj.FUNCDATA_InlTree {
+			if len(pcln.Funcdataoff) <= objabi.FUNCDATA_InlTree {
 				// Create inline tree funcdata.
-				funcdata := make([]*Symbol, obj.FUNCDATA_InlTree+1)
-				funcdataoff := make([]int64, obj.FUNCDATA_InlTree+1)
+				funcdata := make([]*Symbol, objabi.FUNCDATA_InlTree+1)
+				funcdataoff := make([]int64, objabi.FUNCDATA_InlTree+1)
 				copy(funcdata, pcln.Funcdata)
 				copy(funcdataoff, pcln.Funcdataoff)
 				pcln.Funcdata = funcdata
@@ -334,7 +334,7 @@ func (ctxt *Link) pclntab() {
 
 		if len(pcln.InlTree) > 0 {
 			inlTreeSym := ctxt.Syms.Lookup("inltree."+s.Name, 0)
-			inlTreeSym.Type = obj.SRODATA
+			inlTreeSym.Type = objabi.SRODATA
 			inlTreeSym.Attr |= AttrReachable | AttrDuplicateOK
 
 			for i, call := range pcln.InlTree {
@@ -352,8 +352,8 @@ func (ctxt *Link) pclntab() {
 				setuint32(ctxt, inlTreeSym, int64(i*16+12), uint32(nameoff))
 			}
 
-			pcln.Funcdata[obj.FUNCDATA_InlTree] = inlTreeSym
-			pcln.Pcdata[obj.PCDATA_InlTreeIndex] = pcln.Pcinline
+			pcln.Funcdata[objabi.FUNCDATA_InlTree] = inlTreeSym
+			pcln.Pcdata[objabi.PCDATA_InlTreeIndex] = pcln.Pcinline
 		}
 
 		// pcdata
@@ -416,14 +416,14 @@ func (ctxt *Link) pclntab() {
 	ftab.Size = int64(len(ftab.P))
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f pclntab=%d bytes, funcdata total %d bytes\n", obj.Cputime(), ftab.Size, funcdataBytes)
+		ctxt.Logf("%5.2f pclntab=%d bytes, funcdata total %d bytes\n", Cputime(), ftab.Size, funcdataBytes)
 	}
 }
 
 func expandGoroot(s string) string {
 	const n = len("$GOROOT")
 	if len(s) >= n+1 && s[:n] == "$GOROOT" && (s[n] == '/' || s[n] == '\\') {
-		root := obj.GOROOT
+		root := objabi.GOROOT
 		if final := os.Getenv("GOROOT_FINAL"); final != "" {
 			root = final
 		}
@@ -443,7 +443,7 @@ const (
 // function for a pc. See src/runtime/symtab.go:findfunc for details.
 func (ctxt *Link) findfunctab() {
 	t := ctxt.Syms.Lookup("runtime.findfunctab", 0)
-	t.Type = obj.SRODATA
+	t.Type = objabi.SRODATA
 	t.Attr |= AttrReachable
 	t.Attr |= AttrLocal
 
diff --git a/src/cmd/link/internal/ld/pe.go b/src/cmd/link/internal/ld/pe.go
index 17683efcff..dfe7ffe3a4 100644
--- a/src/cmd/link/internal/ld/pe.go
+++ b/src/cmd/link/internal/ld/pe.go
@@ -5,7 +5,7 @@
 package ld
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"encoding/binary"
 	"fmt"
@@ -460,8 +460,8 @@ func Peinit(ctxt *Link) {
 
 	if Linkmode == LinkInternal {
 		// some mingw libs depend on this symbol, for example, FindPESectionByName
-		ctxt.xdefine("__image_base__", obj.SDATA, PEBASE)
-		ctxt.xdefine("_image_base__", obj.SDATA, PEBASE)
+		ctxt.xdefine("__image_base__", objabi.SDATA, PEBASE)
+		ctxt.xdefine("_image_base__", objabi.SDATA, PEBASE)
 	}
 
 	HEADR = PEFILEHEADR
@@ -516,7 +516,7 @@ func initdynimport(ctxt *Link) *Dll {
 	dr = nil
 	var m *Imp
 	for _, s := range ctxt.Syms.Allsym {
-		if !s.Attr.Reachable() || s.Type != obj.SDYNIMPORT {
+		if !s.Attr.Reachable() || s.Type != objabi.SDYNIMPORT {
 			continue
 		}
 		for d = dr; d != nil; d = d.next {
@@ -558,7 +558,7 @@ func initdynimport(ctxt *Link) *Dll {
 		// Add real symbol name
 		for d := dr; d != nil; d = d.next {
 			for m = d.ms; m != nil; m = m.next {
-				m.s.Type = obj.SDATA
+				m.s.Type = objabi.SDATA
 				Symgrow(m.s, int64(SysArch.PtrSize))
 				dynName := m.s.Extname
 				// only windows/386 requires stdcall decoration
@@ -567,21 +567,21 @@ func initdynimport(ctxt *Link) *Dll {
 				}
 				dynSym := ctxt.Syms.Lookup(dynName, 0)
 				dynSym.Attr |= AttrReachable
-				dynSym.Type = obj.SHOSTOBJ
+				dynSym.Type = objabi.SHOSTOBJ
 				r := Addrel(m.s)
 				r.Sym = dynSym
 				r.Off = 0
 				r.Siz = uint8(SysArch.PtrSize)
-				r.Type = obj.R_ADDR
+				r.Type = objabi.R_ADDR
 			}
 		}
 	} else {
 		dynamic := ctxt.Syms.Lookup(".windynamic", 0)
 		dynamic.Attr |= AttrReachable
-		dynamic.Type = obj.SWINDOWS
+		dynamic.Type = objabi.SWINDOWS
 		for d := dr; d != nil; d = d.next {
 			for m = d.ms; m != nil; m = m.next {
-				m.s.Type = obj.SWINDOWS | obj.SSUB
+				m.s.Type = objabi.SWINDOWS | objabi.SSUB
 				m.s.Sub = dynamic.Sub
 				dynamic.Sub = m.s
 				m.s.Value = dynamic.Size
@@ -919,9 +919,9 @@ dwarfLoop:
 		dottext := ctxt.Syms.Lookup(".text", 0)
 		Lputl(0)
 		Lputl(uint32(dottext.Dynid))
-		switch obj.GOARCH {
+		switch objabi.GOARCH {
 		default:
-			Errorf(dottext, "unknown architecture for PE: %q\n", obj.GOARCH)
+			Errorf(dottext, "unknown architecture for PE: %q\n", objabi.GOARCH)
 		case "386":
 			Wputl(IMAGE_REL_I386_DIR32)
 		case "amd64":
@@ -936,7 +936,7 @@ func (ctxt *Link) dope() {
 	rel := ctxt.Syms.Lookup(".rel", 0)
 
 	rel.Attr |= AttrReachable
-	rel.Type = obj.SELFROSECT
+	rel.Type = objabi.SELFROSECT
 
 	initdynimport(ctxt)
 	initdynexport(ctxt)
@@ -1009,7 +1009,7 @@ func writePESymTableRecords(ctxt *Link) int {
 		// Only windows/386 requires underscore prefix on external symbols.
 		if SysArch.Family == sys.I386 &&
 			Linkmode == LinkExternal &&
-			(s.Type == obj.SHOSTOBJ || s.Attr.CgoExport()) {
+			(s.Type == objabi.SHOSTOBJ || s.Attr.CgoExport()) {
 			s.Name = "_" + s.Name
 		}
 
@@ -1020,10 +1020,10 @@ func writePESymTableRecords(ctxt *Link) int {
 		// it still belongs to the .data section, not the .bss section.
 		// Same for runtime.epclntab (type STEXT), it belongs to .text
 		// section, not the .data section.
-		if uint64(s.Value) >= Segdata.Vaddr+Segdata.Filelen && s.Type != obj.SDATA && Linkmode == LinkExternal {
+		if uint64(s.Value) >= Segdata.Vaddr+Segdata.Filelen && s.Type != objabi.SDATA && Linkmode == LinkExternal {
 			value = int64(uint64(s.Value) - Segdata.Vaddr - Segdata.Filelen)
 			sect = bsssect
-		} else if uint64(s.Value) >= Segdata.Vaddr && s.Type != obj.STEXT {
+		} else if uint64(s.Value) >= Segdata.Vaddr && s.Type != objabi.STEXT {
 			value = int64(uint64(s.Value) - Segdata.Vaddr)
 			sect = datasect
 		} else if uint64(s.Value) >= Segtext.Vaddr {
@@ -1041,7 +1041,7 @@ func writePESymTableRecords(ctxt *Link) int {
 			typ = 0x0308 // "array of structs"
 		}
 		class := IMAGE_SYM_CLASS_EXTERNAL
-		if s.Version != 0 || (s.Type&obj.SHIDDEN != 0) || s.Attr.Local() {
+		if s.Version != 0 || (s.Type&objabi.SHIDDEN != 0) || s.Attr.Local() {
 			class = IMAGE_SYM_CLASS_STATIC
 		}
 		writeOneSymbol(s, value, sect, typ, uint8(class))
@@ -1143,9 +1143,9 @@ func addinitarray(ctxt *Link) (c *IMAGE_SECTION_HEADER) {
 	// However, the entire Go runtime is initialized from just one function, so it is unlikely
 	// that this will need to grow in the future.
 	var size int
-	switch obj.GOARCH {
+	switch objabi.GOARCH {
 	default:
-		fmt.Fprintf(os.Stderr, "link: unknown architecture for PE: %q\n", obj.GOARCH)
+		fmt.Fprintf(os.Stderr, "link: unknown architecture for PE: %q\n", objabi.GOARCH)
 		os.Exit(2)
 	case "386":
 		size = 4
@@ -1162,7 +1162,7 @@ func addinitarray(ctxt *Link) (c *IMAGE_SECTION_HEADER) {
 	init_entry := ctxt.Syms.Lookup(*flagEntrySymbol, 0)
 	addr := uint64(init_entry.Value) - init_entry.Sect.Vaddr
 
-	switch obj.GOARCH {
+	switch objabi.GOARCH {
 	case "386":
 		Lputl(uint32(addr))
 	case "amd64":
diff --git a/src/cmd/link/internal/ld/sym.go b/src/cmd/link/internal/ld/sym.go
index abe0aa685c..f1bbdeb58b 100644
--- a/src/cmd/link/internal/ld/sym.go
+++ b/src/cmd/link/internal/ld/sym.go
@@ -32,7 +32,7 @@
 package ld
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"log"
 )
@@ -50,8 +50,8 @@ func linknew(arch *sys.Arch) *Link {
 		Arch: arch,
 	}
 
-	if obj.GOARCH != arch.Name {
-		log.Fatalf("invalid obj.GOARCH %s (want %s)", obj.GOARCH, arch.Name)
+	if objabi.GOARCH != arch.Name {
+		log.Fatalf("invalid objabi.GOARCH %s (want %s)", objabi.GOARCH, arch.Name)
 	}
 
 	return ctxt
@@ -63,7 +63,7 @@ func (ctxt *Link) computeTLSOffset() {
 	default:
 		log.Fatalf("unknown thread-local storage offset for %v", Headtype)
 
-	case obj.Hplan9, obj.Hwindows:
+	case objabi.Hplan9, objabi.Hwindows:
 		break
 
 		/*
@@ -71,13 +71,13 @@ func (ctxt *Link) computeTLSOffset() {
 		 * Translate 0(FS) and 8(FS) into -16(FS) and -8(FS).
 		 * Known to low-level assembly in package runtime and runtime/cgo.
 		 */
-	case obj.Hlinux,
-		obj.Hfreebsd,
-		obj.Hnetbsd,
-		obj.Hopenbsd,
-		obj.Hdragonfly,
-		obj.Hsolaris:
-		if obj.GOOS == "android" {
+	case objabi.Hlinux,
+		objabi.Hfreebsd,
+		objabi.Hnetbsd,
+		objabi.Hopenbsd,
+		objabi.Hdragonfly,
+		objabi.Hsolaris:
+		if objabi.GOOS == "android" {
 			switch ctxt.Arch.Family {
 			case sys.AMD64:
 				// Android/amd64 constant - offset from 0(FS) to our TLS slot.
@@ -93,7 +93,7 @@ func (ctxt *Link) computeTLSOffset() {
 			ctxt.Tlsoffset = -1 * ctxt.Arch.PtrSize
 		}
 
-	case obj.Hnacl:
+	case objabi.Hnacl:
 		switch ctxt.Arch.Family {
 		default:
 			log.Fatalf("unknown thread-local storage offset for nacl/%s", ctxt.Arch.Name)
@@ -112,7 +112,7 @@ func (ctxt *Link) computeTLSOffset() {
 		 * OS X system constants - offset from 0(GS) to our TLS.
 		 * Explained in src/runtime/cgo/gcc_darwin_*.c.
 		 */
-	case obj.Hdarwin:
+	case objabi.Hdarwin:
 		switch ctxt.Arch.Family {
 		default:
 			log.Fatalf("unknown thread-local storage offset for darwin/%s", ctxt.Arch.Name)
diff --git a/src/cmd/link/internal/ld/symtab.go b/src/cmd/link/internal/ld/symtab.go
index e796fe0816..c765ef6043 100644
--- a/src/cmd/link/internal/ld/symtab.go
+++ b/src/cmd/link/internal/ld/symtab.go
@@ -31,7 +31,7 @@
 package ld
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"fmt"
 	"path/filepath"
@@ -109,7 +109,7 @@ func putelfsym(ctxt *Link, x *Symbol, s string, t SymbolType, addr int64, go_ *S
 	}
 
 	var elfshnum int
-	if xo.Type == obj.SDYNIMPORT || xo.Type == obj.SHOSTOBJ {
+	if xo.Type == objabi.SDYNIMPORT || xo.Type == objabi.SHOSTOBJ {
 		elfshnum = SHN_UNDEF
 	} else {
 		if xo.Sect == nil {
@@ -127,7 +127,7 @@ func putelfsym(ctxt *Link, x *Symbol, s string, t SymbolType, addr int64, go_ *S
 	// maybe one day STB_WEAK.
 	bind := STB_GLOBAL
 
-	if x.Version != 0 || (x.Type&obj.SHIDDEN != 0) || x.Attr.Local() {
+	if x.Version != 0 || (x.Type&objabi.SHIDDEN != 0) || x.Attr.Local() {
 		bind = STB_LOCAL
 	}
 
@@ -144,7 +144,7 @@ func putelfsym(ctxt *Link, x *Symbol, s string, t SymbolType, addr int64, go_ *S
 		addr -= int64(xo.Sect.Vaddr)
 	}
 	other := STV_DEFAULT
-	if x.Type&obj.SHIDDEN != 0 {
+	if x.Type&objabi.SHIDDEN != 0 {
 		other = STV_HIDDEN
 	}
 	if (Buildmode == BuildmodeCArchive || Buildmode == BuildmodePIE || ctxt.DynlinkingGo()) && SysArch.Family == sys.PPC64 && typ == STT_FUNC && x.Name != "runtime.duffzero" && x.Name != "runtime.duffcopy" {
@@ -162,7 +162,7 @@ func putelfsym(ctxt *Link, x *Symbol, s string, t SymbolType, addr int64, go_ *S
 		s = strings.Replace(s, "", ".", -1)
 	}
 
-	if ctxt.DynlinkingGo() && bind == STB_GLOBAL && elfbind == STB_LOCAL && x.Type == obj.STEXT {
+	if ctxt.DynlinkingGo() && bind == STB_GLOBAL && elfbind == STB_LOCAL && x.Type == objabi.STEXT {
 		// When dynamically linking, we want references to functions defined
 		// in this module to always be to the function object, not to the
 		// PLT. We force this by writing an additional local symbol for every
@@ -222,7 +222,7 @@ func putplan9sym(ctxt *Link, x *Symbol, s string, typ SymbolType, addr int64, go
 
 	case AutoSym, ParamSym, FileSym, FrameSym:
 		l := 4
-		if Headtype == obj.Hplan9 && SysArch.Family == sys.AMD64 && !Flag8 {
+		if Headtype == objabi.Hplan9 && SysArch.Family == sys.AMD64 && !Flag8 {
 			Lputb(uint32(addr >> 32))
 			l = 8
 		}
@@ -307,7 +307,7 @@ func (libs byPkg) Swap(a, b int) {
 func textsectionmap(ctxt *Link) uint32 {
 
 	t := ctxt.Syms.Lookup("runtime.textsectionmap", 0)
-	t.Type = obj.SRODATA
+	t.Type = objabi.SRODATA
 	t.Attr |= AttrReachable
 	nsections := int64(0)
 
@@ -363,40 +363,40 @@ func (ctxt *Link) symtab() {
 
 	// Define these so that they'll get put into the symbol table.
 	// data.c:/^address will provide the actual values.
-	ctxt.xdefine("runtime.text", obj.STEXT, 0)
-
-	ctxt.xdefine("runtime.etext", obj.STEXT, 0)
-	ctxt.xdefine("runtime.itablink", obj.SRODATA, 0)
-	ctxt.xdefine("runtime.eitablink", obj.SRODATA, 0)
-	ctxt.xdefine("runtime.rodata", obj.SRODATA, 0)
-	ctxt.xdefine("runtime.erodata", obj.SRODATA, 0)
-	ctxt.xdefine("runtime.types", obj.SRODATA, 0)
-	ctxt.xdefine("runtime.etypes", obj.SRODATA, 0)
-	ctxt.xdefine("runtime.noptrdata", obj.SNOPTRDATA, 0)
-	ctxt.xdefine("runtime.enoptrdata", obj.SNOPTRDATA, 0)
-	ctxt.xdefine("runtime.data", obj.SDATA, 0)
-	ctxt.xdefine("runtime.edata", obj.SDATA, 0)
-	ctxt.xdefine("runtime.bss", obj.SBSS, 0)
-	ctxt.xdefine("runtime.ebss", obj.SBSS, 0)
-	ctxt.xdefine("runtime.noptrbss", obj.SNOPTRBSS, 0)
-	ctxt.xdefine("runtime.enoptrbss", obj.SNOPTRBSS, 0)
-	ctxt.xdefine("runtime.end", obj.SBSS, 0)
-	ctxt.xdefine("runtime.epclntab", obj.SRODATA, 0)
-	ctxt.xdefine("runtime.esymtab", obj.SRODATA, 0)
+	ctxt.xdefine("runtime.text", objabi.STEXT, 0)
+
+	ctxt.xdefine("runtime.etext", objabi.STEXT, 0)
+	ctxt.xdefine("runtime.itablink", objabi.SRODATA, 0)
+	ctxt.xdefine("runtime.eitablink", objabi.SRODATA, 0)
+	ctxt.xdefine("runtime.rodata", objabi.SRODATA, 0)
+	ctxt.xdefine("runtime.erodata", objabi.SRODATA, 0)
+	ctxt.xdefine("runtime.types", objabi.SRODATA, 0)
+	ctxt.xdefine("runtime.etypes", objabi.SRODATA, 0)
+	ctxt.xdefine("runtime.noptrdata", objabi.SNOPTRDATA, 0)
+	ctxt.xdefine("runtime.enoptrdata", objabi.SNOPTRDATA, 0)
+	ctxt.xdefine("runtime.data", objabi.SDATA, 0)
+	ctxt.xdefine("runtime.edata", objabi.SDATA, 0)
+	ctxt.xdefine("runtime.bss", objabi.SBSS, 0)
+	ctxt.xdefine("runtime.ebss", objabi.SBSS, 0)
+	ctxt.xdefine("runtime.noptrbss", objabi.SNOPTRBSS, 0)
+	ctxt.xdefine("runtime.enoptrbss", objabi.SNOPTRBSS, 0)
+	ctxt.xdefine("runtime.end", objabi.SBSS, 0)
+	ctxt.xdefine("runtime.epclntab", objabi.SRODATA, 0)
+	ctxt.xdefine("runtime.esymtab", objabi.SRODATA, 0)
 
 	// garbage collection symbols
 	s := ctxt.Syms.Lookup("runtime.gcdata", 0)
 
-	s.Type = obj.SRODATA
+	s.Type = objabi.SRODATA
 	s.Size = 0
 	s.Attr |= AttrReachable
-	ctxt.xdefine("runtime.egcdata", obj.SRODATA, 0)
+	ctxt.xdefine("runtime.egcdata", objabi.SRODATA, 0)
 
 	s = ctxt.Syms.Lookup("runtime.gcbss", 0)
-	s.Type = obj.SRODATA
+	s.Type = objabi.SRODATA
 	s.Size = 0
 	s.Attr |= AttrReachable
-	ctxt.xdefine("runtime.egcbss", obj.SRODATA, 0)
+	ctxt.xdefine("runtime.egcbss", objabi.SRODATA, 0)
 
 	// pseudo-symbols to mark locations of type, string, and go string data.
 	var symtype *Symbol
@@ -404,28 +404,28 @@ func (ctxt *Link) symtab() {
 	if UseRelro() && (Buildmode == BuildmodeCArchive || Buildmode == BuildmodeCShared || Buildmode == BuildmodePIE) {
 		s = ctxt.Syms.Lookup("type.*", 0)
 
-		s.Type = obj.STYPE
+		s.Type = objabi.STYPE
 		s.Size = 0
 		s.Attr |= AttrReachable
 		symtype = s
 
 		s = ctxt.Syms.Lookup("typerel.*", 0)
 
-		s.Type = obj.STYPERELRO
+		s.Type = objabi.STYPERELRO
 		s.Size = 0
 		s.Attr |= AttrReachable
 		symtyperel = s
 	} else if !ctxt.DynlinkingGo() {
 		s = ctxt.Syms.Lookup("type.*", 0)
 
-		s.Type = obj.STYPE
+		s.Type = objabi.STYPE
 		s.Size = 0
 		s.Attr |= AttrReachable
 		symtype = s
 		symtyperel = s
 	}
 
-	groupSym := func(name string, t obj.SymKind) *Symbol {
+	groupSym := func(name string, t objabi.SymKind) *Symbol {
 		s := ctxt.Syms.Lookup(name, 0)
 		s.Type = t
 		s.Size = 0
@@ -433,26 +433,26 @@ func (ctxt *Link) symtab() {
 		return s
 	}
 	var (
-		symgostring = groupSym("go.string.*", obj.SGOSTRING)
-		symgofunc   = groupSym("go.func.*", obj.SGOFUNC)
-		symgcbits   = groupSym("runtime.gcbits.*", obj.SGCBITS)
+		symgostring = groupSym("go.string.*", objabi.SGOSTRING)
+		symgofunc   = groupSym("go.func.*", objabi.SGOFUNC)
+		symgcbits   = groupSym("runtime.gcbits.*", objabi.SGCBITS)
 	)
 
 	var symgofuncrel *Symbol
 	if !ctxt.DynlinkingGo() {
 		if UseRelro() {
-			symgofuncrel = groupSym("go.funcrel.*", obj.SGOFUNCRELRO)
+			symgofuncrel = groupSym("go.funcrel.*", objabi.SGOFUNCRELRO)
 		} else {
 			symgofuncrel = symgofunc
 		}
 	}
 
 	symitablink := ctxt.Syms.Lookup("runtime.itablink", 0)
-	symitablink.Type = obj.SITABLINK
+	symitablink.Type = objabi.SITABLINK
 
 	symt = ctxt.Syms.Lookup("runtime.symtab", 0)
 	symt.Attr |= AttrLocal
-	symt.Type = obj.SSYMTAB
+	symt.Type = objabi.SSYMTAB
 	symt.Size = 0
 	symt.Attr |= AttrReachable
 
@@ -463,7 +463,7 @@ func (ctxt *Link) symtab() {
 	// just defined above will be first.
 	// hide the specific symbols.
 	for _, s := range ctxt.Syms.Allsym {
-		if !s.Attr.Reachable() || s.Attr.Special() || s.Type != obj.SRODATA {
+		if !s.Attr.Reachable() || s.Attr.Special() || s.Type != objabi.SRODATA {
 			continue
 		}
 
@@ -473,31 +473,31 @@ func (ctxt *Link) symtab() {
 				s.Attr |= AttrHidden
 			}
 			if UseRelro() {
-				s.Type = obj.STYPERELRO
+				s.Type = objabi.STYPERELRO
 				s.Outer = symtyperel
 			} else {
-				s.Type = obj.STYPE
+				s.Type = objabi.STYPE
 				s.Outer = symtype
 			}
 
 		case strings.HasPrefix(s.Name, "go.importpath.") && UseRelro():
 			// Keep go.importpath symbols in the same section as types and
 			// names, as they can be referred to by a section offset.
-			s.Type = obj.STYPERELRO
+			s.Type = objabi.STYPERELRO
 
 		case strings.HasPrefix(s.Name, "go.itablink."):
 			nitablinks++
-			s.Type = obj.SITABLINK
+			s.Type = objabi.SITABLINK
 			s.Attr |= AttrHidden
 			s.Outer = symitablink
 
 		case strings.HasPrefix(s.Name, "go.string."):
-			s.Type = obj.SGOSTRING
+			s.Type = objabi.SGOSTRING
 			s.Attr |= AttrHidden
 			s.Outer = symgostring
 
 		case strings.HasPrefix(s.Name, "runtime.gcbits."):
-			s.Type = obj.SGCBITS
+			s.Type = objabi.SGCBITS
 			s.Attr |= AttrHidden
 			s.Outer = symgcbits
 
@@ -506,10 +506,10 @@ func (ctxt *Link) symtab() {
 				s.Attr |= AttrHidden
 			}
 			if UseRelro() {
-				s.Type = obj.SGOFUNCRELRO
+				s.Type = objabi.SGOFUNCRELRO
 				s.Outer = symgofuncrel
 			} else {
-				s.Type = obj.SGOFUNC
+				s.Type = objabi.SGOFUNC
 				s.Outer = symgofunc
 			}
 
@@ -517,7 +517,7 @@ func (ctxt *Link) symtab() {
 			strings.HasPrefix(s.Name, "gclocals."),
 			strings.HasPrefix(s.Name, "gclocals"),
 			strings.HasPrefix(s.Name, "inltree."):
-			s.Type = obj.SGOFUNC
+			s.Type = objabi.SGOFUNC
 			s.Attr |= AttrHidden
 			s.Outer = symgofunc
 			s.Align = 4
@@ -528,7 +528,7 @@ func (ctxt *Link) symtab() {
 	if Buildmode == BuildmodeShared {
 		abihashgostr := ctxt.Syms.Lookup("go.link.abihash."+filepath.Base(*flagOutfile), 0)
 		abihashgostr.Attr |= AttrReachable
-		abihashgostr.Type = obj.SRODATA
+		abihashgostr.Type = objabi.SRODATA
 		hashsym := ctxt.Syms.Lookup("go.link.abihashbytes", 0)
 		Addaddr(ctxt, abihashgostr, hashsym)
 		adduint(ctxt, abihashgostr, uint64(hashsym.Size))
@@ -537,12 +537,12 @@ func (ctxt *Link) symtab() {
 		for _, l := range ctxt.Library {
 			s := ctxt.Syms.Lookup("go.link.pkghashbytes."+l.Pkg, 0)
 			s.Attr |= AttrReachable
-			s.Type = obj.SRODATA
+			s.Type = objabi.SRODATA
 			s.Size = int64(len(l.hash))
 			s.P = []byte(l.hash)
 			str := ctxt.Syms.Lookup("go.link.pkghash."+l.Pkg, 0)
 			str.Attr |= AttrReachable
-			str.Type = obj.SRODATA
+			str.Type = objabi.SRODATA
 			Addaddr(ctxt, str, s)
 			adduint(ctxt, str, uint64(len(l.hash)))
 		}
@@ -607,7 +607,7 @@ func (ctxt *Link) symtab() {
 	// The ptab slice
 	if ptab := ctxt.Syms.ROLookup("go.plugin.tabs", 0); ptab != nil && ptab.Attr.Reachable() {
 		ptab.Attr |= AttrLocal
-		ptab.Type = obj.SRODATA
+		ptab.Type = objabi.SRODATA
 
 		nentries := uint64(len(ptab.P) / 8) // sizeof(nameOff) + sizeof(typeOff)
 		Addaddr(ctxt, moduledata, ptab)
@@ -624,7 +624,7 @@ func (ctxt *Link) symtab() {
 		pkghashes := ctxt.Syms.Lookup("go.link.pkghashes", 0)
 		pkghashes.Attr |= AttrReachable
 		pkghashes.Attr |= AttrLocal
-		pkghashes.Type = obj.SRODATA
+		pkghashes.Type = objabi.SRODATA
 
 		for i, l := range ctxt.Library {
 			// pkghashes[i].name
@@ -658,7 +658,7 @@ func (ctxt *Link) symtab() {
 		modulehashes := ctxt.Syms.Lookup("go.link.abihashes", 0)
 		modulehashes.Attr |= AttrReachable
 		modulehashes.Attr |= AttrLocal
-		modulehashes.Type = obj.SRODATA
+		modulehashes.Type = objabi.SRODATA
 
 		for i, shlib := range ctxt.Shlibs {
 			// modulehashes[i].modulename
@@ -688,8 +688,8 @@ func (ctxt *Link) symtab() {
 	Symgrow(moduledata, moduledata.Size)
 
 	lastmoduledatap := ctxt.Syms.Lookup("runtime.lastmoduledatap", 0)
-	if lastmoduledatap.Type != obj.SDYNIMPORT {
-		lastmoduledatap.Type = obj.SNOPTRDATA
+	if lastmoduledatap.Type != objabi.SDYNIMPORT {
+		lastmoduledatap.Type = objabi.SNOPTRDATA
 		lastmoduledatap.Size = 0 // overwrite existing value
 		Addaddr(ctxt, lastmoduledatap, moduledata)
 	}
diff --git a/src/cmd/link/internal/ld/typelink.go b/src/cmd/link/internal/ld/typelink.go
index 48a1104998..c9eb06b681 100644
--- a/src/cmd/link/internal/ld/typelink.go
+++ b/src/cmd/link/internal/ld/typelink.go
@@ -5,9 +5,8 @@
 package ld
 
 import (
+	"cmd/internal/objabi"
 	"sort"
-
-	"cmd/internal/obj"
 )
 
 type byTypeStr []typelinkSortKey
@@ -34,7 +33,7 @@ func (ctxt *Link) typelink() {
 	sort.Sort(typelinks)
 
 	tl := ctxt.Syms.Lookup("runtime.typelink", 0)
-	tl.Type = obj.STYPELINK
+	tl.Type = objabi.STYPELINK
 	tl.Attr |= AttrReachable | AttrLocal
 	tl.Size = int64(4 * len(typelinks))
 	tl.P = make([]byte, tl.Size)
@@ -44,6 +43,6 @@ func (ctxt *Link) typelink() {
 		r.Sym = s.Type
 		r.Off = int32(i * 4)
 		r.Siz = 4
-		r.Type = obj.R_ADDROFF
+		r.Type = objabi.R_ADDROFF
 	}
 }
diff --git a/src/cmd/link/internal/ld/util.go b/src/cmd/link/internal/ld/util.go
index 925aab6b36..4b726367e8 100644
--- a/src/cmd/link/internal/ld/util.go
+++ b/src/cmd/link/internal/ld/util.go
@@ -13,6 +13,16 @@ import (
 	"time"
 )
 
+var startTime time.Time
+
+// TODO(josharian): delete. See issue 19865.
+func Cputime() float64 {
+	if startTime.IsZero() {
+		startTime = time.Now()
+	}
+	return time.Since(startTime).Seconds()
+}
+
 func cstring(x []byte) string {
 	i := bytes.IndexByte(x, '\x00')
 	if i >= 0 {
diff --git a/src/cmd/link/internal/mips/asm.go b/src/cmd/link/internal/mips/asm.go
index 9b43790874..b1a903846d 100644
--- a/src/cmd/link/internal/mips/asm.go
+++ b/src/cmd/link/internal/mips/asm.go
@@ -31,7 +31,7 @@
 package mips
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/link/internal/ld"
 	"fmt"
 	"log"
@@ -54,22 +54,22 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 	default:
 		return -1
 
-	case obj.R_ADDR:
+	case objabi.R_ADDR:
 		if r.Siz != 4 {
 			return -1
 		}
 		ld.Thearch.Lput(ld.R_MIPS_32 | uint32(elfsym)<<8)
 
-	case obj.R_ADDRMIPS:
+	case objabi.R_ADDRMIPS:
 		ld.Thearch.Lput(ld.R_MIPS_LO16 | uint32(elfsym)<<8)
 
-	case obj.R_ADDRMIPSU:
+	case objabi.R_ADDRMIPSU:
 		ld.Thearch.Lput(ld.R_MIPS_HI16 | uint32(elfsym)<<8)
 
-	case obj.R_ADDRMIPSTLS:
+	case objabi.R_ADDRMIPSTLS:
 		ld.Thearch.Lput(ld.R_MIPS_TLS_TPREL_LO16 | uint32(elfsym)<<8)
 
-	case obj.R_CALLMIPS, obj.R_JMPMIPS:
+	case objabi.R_CALLMIPS, objabi.R_JMPMIPS:
 		ld.Thearch.Lput(ld.R_MIPS_26 | uint32(elfsym)<<8)
 	}
 
@@ -87,11 +87,11 @@ func machoreloc1(s *ld.Symbol, r *ld.Reloc, sectoff int64) int {
 func applyrel(r *ld.Reloc, s *ld.Symbol, val *int64, t int64) {
 	o := ld.SysArch.ByteOrder.Uint32(s.P[r.Off:])
 	switch r.Type {
-	case obj.R_ADDRMIPS, obj.R_ADDRMIPSTLS:
+	case objabi.R_ADDRMIPS, objabi.R_ADDRMIPSTLS:
 		*val = int64(o&0xffff0000 | uint32(t)&0xffff)
-	case obj.R_ADDRMIPSU:
+	case objabi.R_ADDRMIPSU:
 		*val = int64(o&0xffff0000 | uint32((t+(1<<15))>>16)&0xffff)
-	case obj.R_CALLMIPS, obj.R_JMPMIPS:
+	case objabi.R_CALLMIPS, objabi.R_JMPMIPS:
 		*val = int64(o&0xfc000000 | uint32(t>>2)&^0xfc000000)
 	}
 }
@@ -102,7 +102,7 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 		default:
 			return -1
 
-		case obj.R_ADDRMIPS, obj.R_ADDRMIPSU:
+		case objabi.R_ADDRMIPS, objabi.R_ADDRMIPSU:
 
 			r.Done = 0
 
@@ -114,14 +114,14 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 				rs = rs.Outer
 			}
 
-			if rs.Type != obj.SHOSTOBJ && rs.Type != obj.SDYNIMPORT && rs.Sect == nil {
+			if rs.Type != objabi.SHOSTOBJ && rs.Type != objabi.SDYNIMPORT && rs.Sect == nil {
 				ld.Errorf(s, "missing section for %s", rs.Name)
 			}
 			r.Xsym = rs
 			applyrel(r, s, val, r.Xadd)
 			return 0
 
-		case obj.R_ADDRMIPSTLS, obj.R_CALLMIPS, obj.R_JMPMIPS:
+		case objabi.R_ADDRMIPSTLS, objabi.R_CALLMIPS, objabi.R_JMPMIPS:
 			r.Done = 0
 			r.Xsym = r.Sym
 			r.Xadd = r.Add
@@ -131,20 +131,20 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 	}
 
 	switch r.Type {
-	case obj.R_CONST:
+	case objabi.R_CONST:
 		*val = r.Add
 		return 0
 
-	case obj.R_GOTOFF:
+	case objabi.R_GOTOFF:
 		*val = ld.Symaddr(r.Sym) + r.Add - ld.Symaddr(ctxt.Syms.Lookup(".got", 0))
 		return 0
 
-	case obj.R_ADDRMIPS, obj.R_ADDRMIPSU:
+	case objabi.R_ADDRMIPS, objabi.R_ADDRMIPSU:
 		t := ld.Symaddr(r.Sym) + r.Add
 		applyrel(r, s, val, t)
 		return 0
 
-	case obj.R_CALLMIPS, obj.R_JMPMIPS:
+	case objabi.R_CALLMIPS, objabi.R_JMPMIPS:
 		t := ld.Symaddr(r.Sym) + r.Add
 
 		if t&3 != 0 {
@@ -159,7 +159,7 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 		applyrel(r, s, val, t)
 		return 0
 
-	case obj.R_ADDRMIPSTLS:
+	case objabi.R_ADDRMIPSTLS:
 		// thread pointer is at 0x7000 offset from the start of TLS data area
 		t := ld.Symaddr(r.Sym) + r.Add - 0x7000
 		if t < -32768 || t >= 32678 {
@@ -178,7 +178,7 @@ func archrelocvariant(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, t int64) int64 {
 
 func asmb(ctxt *ld.Link) {
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f asmb\n", obj.Cputime())
+		ctxt.Logf("%5.2f asmb\n", ld.Cputime())
 	}
 
 	if ld.Iself {
@@ -195,7 +195,7 @@ func asmb(ctxt *ld.Link) {
 
 	if ld.Segrodata.Filelen > 0 {
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f rodatblk\n", obj.Cputime())
+			ctxt.Logf("%5.2f rodatblk\n", ld.Cputime())
 		}
 
 		ld.Cseek(int64(ld.Segrodata.Fileoff))
@@ -203,7 +203,7 @@ func asmb(ctxt *ld.Link) {
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f datblk\n", obj.Cputime())
+		ctxt.Logf("%5.2f datblk\n", ld.Cputime())
 	}
 
 	ld.Cseek(int64(ld.Segdata.Fileoff))
@@ -222,21 +222,21 @@ func asmb(ctxt *ld.Link) {
 			ld.Errorf(nil, "unsupported executable format")
 		}
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f sym\n", obj.Cputime())
+			ctxt.Logf("%5.2f sym\n", ld.Cputime())
 		}
 		symo = uint32(ld.Segdwarf.Fileoff + ld.Segdwarf.Filelen)
 		symo = uint32(ld.Rnd(int64(symo), int64(*ld.FlagRound)))
 
 		ld.Cseek(int64(symo))
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f elfsym\n", obj.Cputime())
+			ctxt.Logf("%5.2f elfsym\n", ld.Cputime())
 		}
 		ld.Asmelfsym(ctxt)
 		ld.Cflush()
 		ld.Cwrite(ld.Elfstrdat)
 
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f dwarf\n", obj.Cputime())
+			ctxt.Logf("%5.2f dwarf\n", ld.Cputime())
 		}
 
 		if ld.Linkmode == ld.LinkExternal {
@@ -245,14 +245,14 @@ func asmb(ctxt *ld.Link) {
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f header\n", obj.Cputime())
+		ctxt.Logf("%5.2f header\n", ld.Cputime())
 	}
 
 	ld.Cseek(0)
 	switch ld.Headtype {
 	default:
 		ld.Errorf(nil, "unsupported operating system")
-	case obj.Hlinux:
+	case objabi.Hlinux:
 		ld.Asmbelf(ctxt, int64(symo))
 	}
 
diff --git a/src/cmd/link/internal/mips/obj.go b/src/cmd/link/internal/mips/obj.go
index a33387658c..3ba02b794a 100644
--- a/src/cmd/link/internal/mips/obj.go
+++ b/src/cmd/link/internal/mips/obj.go
@@ -31,7 +31,7 @@
 package mips
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"cmd/link/internal/ld"
 	"fmt"
@@ -40,7 +40,7 @@ import (
 // Reading object files.
 
 func Init() {
-	if obj.GOARCH == "mipsle" {
+	if objabi.GOARCH == "mipsle" {
 		ld.SysArch = sys.ArchMIPSLE
 	} else {
 		ld.SysArch = sys.ArchMIPS
@@ -90,7 +90,7 @@ func archinit(ctxt *ld.Link) {
 	switch ld.Headtype {
 	default:
 		ld.Exitf("unknown -H option: %v", ld.Headtype)
-	case obj.Hlinux: /* mips elf */
+	case objabi.Hlinux: /* mips elf */
 		ld.Elfinit(ctxt)
 		ld.HEADR = ld.ELFRESERVE
 		if *ld.FlagTextAddr == -1 {
diff --git a/src/cmd/link/internal/mips64/asm.go b/src/cmd/link/internal/mips64/asm.go
index 0ddb4727fe..06ff1d364e 100644
--- a/src/cmd/link/internal/mips64/asm.go
+++ b/src/cmd/link/internal/mips64/asm.go
@@ -31,7 +31,7 @@
 package mips64
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"cmd/link/internal/ld"
 	"fmt"
@@ -66,7 +66,7 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 	default:
 		return -1
 
-	case obj.R_ADDR:
+	case objabi.R_ADDR:
 		switch r.Siz {
 		case 4:
 			ld.Cput(ld.R_MIPS_32)
@@ -76,17 +76,17 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 			return -1
 		}
 
-	case obj.R_ADDRMIPS:
+	case objabi.R_ADDRMIPS:
 		ld.Cput(ld.R_MIPS_LO16)
 
-	case obj.R_ADDRMIPSU:
+	case objabi.R_ADDRMIPSU:
 		ld.Cput(ld.R_MIPS_HI16)
 
-	case obj.R_ADDRMIPSTLS:
+	case objabi.R_ADDRMIPSTLS:
 		ld.Cput(ld.R_MIPS_TLS_TPREL_LO16)
 
-	case obj.R_CALLMIPS,
-		obj.R_JMPMIPS:
+	case objabi.R_CALLMIPS,
+		objabi.R_JMPMIPS:
 		ld.Cput(ld.R_MIPS_26)
 	}
 	ld.Thearch.Vput(uint64(r.Xadd))
@@ -108,8 +108,8 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 		default:
 			return -1
 
-		case obj.R_ADDRMIPS,
-			obj.R_ADDRMIPSU:
+		case objabi.R_ADDRMIPS,
+			objabi.R_ADDRMIPSU:
 			r.Done = 0
 
 			// set up addend for eventual relocation via outer symbol.
@@ -120,16 +120,16 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 				rs = rs.Outer
 			}
 
-			if rs.Type != obj.SHOSTOBJ && rs.Type != obj.SDYNIMPORT && rs.Sect == nil {
+			if rs.Type != objabi.SHOSTOBJ && rs.Type != objabi.SDYNIMPORT && rs.Sect == nil {
 				ld.Errorf(s, "missing section for %s", rs.Name)
 			}
 			r.Xsym = rs
 
 			return 0
 
-		case obj.R_ADDRMIPSTLS,
-			obj.R_CALLMIPS,
-			obj.R_JMPMIPS:
+		case objabi.R_ADDRMIPSTLS,
+			objabi.R_CALLMIPS,
+			objabi.R_JMPMIPS:
 			r.Done = 0
 			r.Xsym = r.Sym
 			r.Xadd = r.Add
@@ -138,26 +138,26 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 	}
 
 	switch r.Type {
-	case obj.R_CONST:
+	case objabi.R_CONST:
 		*val = r.Add
 		return 0
 
-	case obj.R_GOTOFF:
+	case objabi.R_GOTOFF:
 		*val = ld.Symaddr(r.Sym) + r.Add - ld.Symaddr(ctxt.Syms.Lookup(".got", 0))
 		return 0
 
-	case obj.R_ADDRMIPS,
-		obj.R_ADDRMIPSU:
+	case objabi.R_ADDRMIPS,
+		objabi.R_ADDRMIPSU:
 		t := ld.Symaddr(r.Sym) + r.Add
 		o1 := ld.SysArch.ByteOrder.Uint32(s.P[r.Off:])
-		if r.Type == obj.R_ADDRMIPS {
+		if r.Type == objabi.R_ADDRMIPS {
 			*val = int64(o1&0xffff0000 | uint32(t)&0xffff)
 		} else {
 			*val = int64(o1&0xffff0000 | uint32((t+1<<15)>>16)&0xffff)
 		}
 		return 0
 
-	case obj.R_ADDRMIPSTLS:
+	case objabi.R_ADDRMIPSTLS:
 		// thread pointer is at 0x7000 offset from the start of TLS data area
 		t := ld.Symaddr(r.Sym) + r.Add - 0x7000
 		if t < -32768 || t >= 32678 {
@@ -167,8 +167,8 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 		*val = int64(o1&0xffff0000 | uint32(t)&0xffff)
 		return 0
 
-	case obj.R_CALLMIPS,
-		obj.R_JMPMIPS:
+	case objabi.R_CALLMIPS,
+		objabi.R_JMPMIPS:
 		// Low 26 bits = (S + A) >> 2
 		t := ld.Symaddr(r.Sym) + r.Add
 		o1 := ld.SysArch.ByteOrder.Uint32(s.P[r.Off:])
@@ -185,7 +185,7 @@ func archrelocvariant(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, t int64) int64 {
 
 func asmb(ctxt *ld.Link) {
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f asmb\n", obj.Cputime())
+		ctxt.Logf("%5.2f asmb\n", ld.Cputime())
 	}
 
 	if ld.Iself {
@@ -202,21 +202,21 @@ func asmb(ctxt *ld.Link) {
 
 	if ld.Segrodata.Filelen > 0 {
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f rodatblk\n", obj.Cputime())
+			ctxt.Logf("%5.2f rodatblk\n", ld.Cputime())
 		}
 		ld.Cseek(int64(ld.Segrodata.Fileoff))
 		ld.Datblk(ctxt, int64(ld.Segrodata.Vaddr), int64(ld.Segrodata.Filelen))
 	}
 	if ld.Segrelrodata.Filelen > 0 {
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f rodatblk\n", obj.Cputime())
+			ctxt.Logf("%5.2f rodatblk\n", ld.Cputime())
 		}
 		ld.Cseek(int64(ld.Segrelrodata.Fileoff))
 		ld.Datblk(ctxt, int64(ld.Segrelrodata.Vaddr), int64(ld.Segrelrodata.Filelen))
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f datblk\n", obj.Cputime())
+		ctxt.Logf("%5.2f datblk\n", ld.Cputime())
 	}
 
 	ld.Cseek(int64(ld.Segdata.Fileoff))
@@ -233,7 +233,7 @@ func asmb(ctxt *ld.Link) {
 	if !*ld.FlagS {
 		// TODO: rationalize
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f sym\n", obj.Cputime())
+			ctxt.Logf("%5.2f sym\n", ld.Cputime())
 		}
 		switch ld.Headtype {
 		default:
@@ -242,7 +242,7 @@ func asmb(ctxt *ld.Link) {
 				symo = uint32(ld.Rnd(int64(symo), int64(*ld.FlagRound)))
 			}
 
-		case obj.Hplan9:
+		case objabi.Hplan9:
 			symo = uint32(ld.Segdata.Fileoff + ld.Segdata.Filelen)
 		}
 
@@ -251,7 +251,7 @@ func asmb(ctxt *ld.Link) {
 		default:
 			if ld.Iself {
 				if ctxt.Debugvlog != 0 {
-					ctxt.Logf("%5.2f elfsym\n", obj.Cputime())
+					ctxt.Logf("%5.2f elfsym\n", ld.Cputime())
 				}
 				ld.Asmelfsym(ctxt)
 				ld.Cflush()
@@ -262,7 +262,7 @@ func asmb(ctxt *ld.Link) {
 				}
 			}
 
-		case obj.Hplan9:
+		case objabi.Hplan9:
 			ld.Asmplan9sym(ctxt)
 			ld.Cflush()
 
@@ -279,12 +279,12 @@ func asmb(ctxt *ld.Link) {
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f header\n", obj.Cputime())
+		ctxt.Logf("%5.2f header\n", ld.Cputime())
 	}
 	ld.Cseek(0)
 	switch ld.Headtype {
 	default:
-	case obj.Hplan9: /* plan 9 */
+	case objabi.Hplan9: /* plan 9 */
 		magic := uint32(4*18*18 + 7)
 		if ld.SysArch == sys.ArchMIPS64LE {
 			magic = uint32(4*26*26 + 7)
@@ -298,11 +298,11 @@ func asmb(ctxt *ld.Link) {
 		ld.Thearch.Lput(0)
 		ld.Thearch.Lput(uint32(ld.Lcsize))
 
-	case obj.Hlinux,
-		obj.Hfreebsd,
-		obj.Hnetbsd,
-		obj.Hopenbsd,
-		obj.Hnacl:
+	case objabi.Hlinux,
+		objabi.Hfreebsd,
+		objabi.Hnetbsd,
+		objabi.Hopenbsd,
+		objabi.Hnacl:
 		ld.Asmbelf(ctxt, int64(symo))
 	}
 
diff --git a/src/cmd/link/internal/mips64/obj.go b/src/cmd/link/internal/mips64/obj.go
index b79cd9df4f..1a24a7eede 100644
--- a/src/cmd/link/internal/mips64/obj.go
+++ b/src/cmd/link/internal/mips64/obj.go
@@ -31,14 +31,14 @@
 package mips64
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"cmd/link/internal/ld"
 	"fmt"
 )
 
 func Init() {
-	if obj.GOARCH == "mips64le" {
+	if objabi.GOARCH == "mips64le" {
 		ld.SysArch = sys.ArchMIPS64LE
 	} else {
 		ld.SysArch = sys.ArchMIPS64
@@ -89,7 +89,7 @@ func archinit(ctxt *ld.Link) {
 	default:
 		ld.Exitf("unknown -H option: %v", ld.Headtype)
 
-	case obj.Hplan9: /* plan 9 */
+	case objabi.Hplan9: /* plan 9 */
 		ld.HEADR = 32
 
 		if *ld.FlagTextAddr == -1 {
@@ -102,7 +102,7 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagRound = 16 * 1024
 		}
 
-	case obj.Hlinux: /* mips64 elf */
+	case objabi.Hlinux: /* mips64 elf */
 		ld.Elfinit(ctxt)
 		ld.HEADR = ld.ELFRESERVE
 		if *ld.FlagTextAddr == -1 {
@@ -115,7 +115,7 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagRound = 0x10000
 		}
 
-	case obj.Hnacl:
+	case objabi.Hnacl:
 		ld.Elfinit(ctxt)
 		ld.HEADR = 0x10000
 		ld.Funcalign = 16
diff --git a/src/cmd/link/internal/ppc64/asm.go b/src/cmd/link/internal/ppc64/asm.go
index f13d830027..6e023e841f 100644
--- a/src/cmd/link/internal/ppc64/asm.go
+++ b/src/cmd/link/internal/ppc64/asm.go
@@ -31,7 +31,7 @@
 package ppc64
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/link/internal/ld"
 	"encoding/binary"
 	"fmt"
@@ -91,7 +91,7 @@ func genplt(ctxt *ld.Link) {
 	for _, s := range ctxt.Textp {
 		for i := range s.R {
 			r := &s.R[i]
-			if r.Type != 256+ld.R_PPC64_REL24 || r.Sym.Type != obj.SDYNIMPORT {
+			if r.Type != 256+ld.R_PPC64_REL24 || r.Sym.Type != objabi.SDYNIMPORT {
 				continue
 			}
 
@@ -131,12 +131,12 @@ func genplt(ctxt *ld.Link) {
 
 func genaddmoduledata(ctxt *ld.Link) {
 	addmoduledata := ctxt.Syms.ROLookup("runtime.addmoduledata", 0)
-	if addmoduledata.Type == obj.STEXT {
+	if addmoduledata.Type == objabi.STEXT {
 		return
 	}
 	addmoduledata.Attr |= ld.AttrReachable
 	initfunc := ctxt.Syms.Lookup("go.link.addmoduledata", 0)
-	initfunc.Type = obj.STEXT
+	initfunc.Type = objabi.STEXT
 	initfunc.Attr |= ld.AttrLocal
 	initfunc.Attr |= ld.AttrReachable
 	o := func(op uint32) {
@@ -147,7 +147,7 @@ func genaddmoduledata(ctxt *ld.Link) {
 	rel.Off = int32(initfunc.Size)
 	rel.Siz = 8
 	rel.Sym = ctxt.Syms.Lookup(".TOC.", 0)
-	rel.Type = obj.R_ADDRPOWER_PCREL
+	rel.Type = objabi.R_ADDRPOWER_PCREL
 	o(0x3c4c0000)
 	// addi r2, r2, .TOC.-func@l
 	o(0x38420000)
@@ -160,7 +160,7 @@ func genaddmoduledata(ctxt *ld.Link) {
 	rel.Off = int32(initfunc.Size)
 	rel.Siz = 8
 	rel.Sym = ctxt.Syms.Lookup("local.moduledata", 0)
-	rel.Type = obj.R_ADDRPOWER_GOT
+	rel.Type = objabi.R_ADDRPOWER_GOT
 	o(0x3c620000)
 	// ld r3, local.moduledata@got@l(r3)
 	o(0xe8630000)
@@ -169,7 +169,7 @@ func genaddmoduledata(ctxt *ld.Link) {
 	rel.Off = int32(initfunc.Size)
 	rel.Siz = 4
 	rel.Sym = addmoduledata
-	rel.Type = obj.R_CALLPOWER
+	rel.Type = objabi.R_CALLPOWER
 	o(0x48000001)
 	// nop
 	o(0x60000000)
@@ -186,7 +186,7 @@ func genaddmoduledata(ctxt *ld.Link) {
 	ctxt.Textp = append(ctxt.Textp, initfunc)
 	initarray_entry.Attr |= ld.AttrReachable
 	initarray_entry.Attr |= ld.AttrLocal
-	initarray_entry.Type = obj.SINITARR
+	initarray_entry.Type = objabi.SINITARR
 	ld.Addaddr(ctxt, initarray_entry, initfunc)
 }
 
@@ -211,7 +211,7 @@ func gencallstub(ctxt *ld.Link, abicase int, stub *ld.Symbol, targ *ld.Symbol) {
 
 	plt := ctxt.Syms.Lookup(".plt", 0)
 
-	stub.Type = obj.STEXT
+	stub.Type = objabi.STEXT
 
 	// Save TOC pointer in TOC save slot
 	ld.Adduint32(ctxt, stub, 0xf8410018) // std r2,24(r1)
@@ -226,7 +226,7 @@ func gencallstub(ctxt *ld.Link, abicase int, stub *ld.Symbol, targ *ld.Symbol) {
 	if ctxt.Arch.ByteOrder == binary.BigEndian {
 		r.Off += int32(r.Siz)
 	}
-	r.Type = obj.R_POWER_TOC
+	r.Type = objabi.R_POWER_TOC
 	r.Variant = ld.RV_POWER_HA
 	ld.Adduint32(ctxt, stub, 0x3d820000) // addis r12,r2,targ@plt@toc@ha
 	r = ld.Addrel(stub)
@@ -237,7 +237,7 @@ func gencallstub(ctxt *ld.Link, abicase int, stub *ld.Symbol, targ *ld.Symbol) {
 	if ctxt.Arch.ByteOrder == binary.BigEndian {
 		r.Off += int32(r.Siz)
 	}
-	r.Type = obj.R_POWER_TOC
+	r.Type = objabi.R_POWER_TOC
 	r.Variant = ld.RV_POWER_LO
 	ld.Adduint32(ctxt, stub, 0xe98c0000) // ld r12,targ@plt@toc@l(r12)
 
@@ -258,7 +258,7 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 
 		// Handle relocations found in ELF object files.
 	case 256 + ld.R_PPC64_REL24:
-		r.Type = obj.R_CALLPOWER
+		r.Type = objabi.R_CALLPOWER
 
 		// This is a local call, so the caller isn't setting
 		// up r12 and r2 is the same for the caller and
@@ -267,7 +267,7 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 		// to use r12 to compute r2.)
 		r.Add += int64(r.Sym.Localentry) * 4
 
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			// Should have been handled in elfsetupplt
 			ld.Errorf(s, "unexpected R_PPC64_REL24 for dyn import")
 		}
@@ -275,18 +275,18 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 		return true
 
 	case 256 + ld.R_PPC_REL32:
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Add += 4
 
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			ld.Errorf(s, "unexpected R_PPC_REL32 for dyn import")
 		}
 
 		return true
 
 	case 256 + ld.R_PPC64_ADDR64:
-		r.Type = obj.R_ADDR
-		if targ.Type == obj.SDYNIMPORT {
+		r.Type = objabi.R_ADDR
+		if targ.Type == objabi.SDYNIMPORT {
 			// These happen in .toc sections
 			ld.Adddynsym(ctxt, targ)
 
@@ -300,56 +300,56 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 		return true
 
 	case 256 + ld.R_PPC64_TOC16:
-		r.Type = obj.R_POWER_TOC
+		r.Type = objabi.R_POWER_TOC
 		r.Variant = ld.RV_POWER_LO | ld.RV_CHECK_OVERFLOW
 		return true
 
 	case 256 + ld.R_PPC64_TOC16_LO:
-		r.Type = obj.R_POWER_TOC
+		r.Type = objabi.R_POWER_TOC
 		r.Variant = ld.RV_POWER_LO
 		return true
 
 	case 256 + ld.R_PPC64_TOC16_HA:
-		r.Type = obj.R_POWER_TOC
+		r.Type = objabi.R_POWER_TOC
 		r.Variant = ld.RV_POWER_HA | ld.RV_CHECK_OVERFLOW
 		return true
 
 	case 256 + ld.R_PPC64_TOC16_HI:
-		r.Type = obj.R_POWER_TOC
+		r.Type = objabi.R_POWER_TOC
 		r.Variant = ld.RV_POWER_HI | ld.RV_CHECK_OVERFLOW
 		return true
 
 	case 256 + ld.R_PPC64_TOC16_DS:
-		r.Type = obj.R_POWER_TOC
+		r.Type = objabi.R_POWER_TOC
 		r.Variant = ld.RV_POWER_DS | ld.RV_CHECK_OVERFLOW
 		return true
 
 	case 256 + ld.R_PPC64_TOC16_LO_DS:
-		r.Type = obj.R_POWER_TOC
+		r.Type = objabi.R_POWER_TOC
 		r.Variant = ld.RV_POWER_DS
 		return true
 
 	case 256 + ld.R_PPC64_REL16_LO:
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Variant = ld.RV_POWER_LO
 		r.Add += 2 // Compensate for relocation size of 2
 		return true
 
 	case 256 + ld.R_PPC64_REL16_HI:
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Variant = ld.RV_POWER_HI | ld.RV_CHECK_OVERFLOW
 		r.Add += 2
 		return true
 
 	case 256 + ld.R_PPC64_REL16_HA:
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Variant = ld.RV_POWER_HA | ld.RV_CHECK_OVERFLOW
 		r.Add += 2
 		return true
 	}
 
 	// Handle references to ELF symbols from our own object files.
-	if targ.Type != obj.SDYNIMPORT {
+	if targ.Type != objabi.SDYNIMPORT {
 		return true
 	}
 
@@ -366,7 +366,7 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 	default:
 		return -1
 
-	case obj.R_ADDR:
+	case objabi.R_ADDR:
 		switch r.Siz {
 		case 4:
 			ld.Thearch.Vput(ld.R_PPC64_ADDR32 | uint64(elfsym)<<32)
@@ -376,56 +376,56 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 			return -1
 		}
 
-	case obj.R_POWER_TLS:
+	case objabi.R_POWER_TLS:
 		ld.Thearch.Vput(ld.R_PPC64_TLS | uint64(elfsym)<<32)
 
-	case obj.R_POWER_TLS_LE:
+	case objabi.R_POWER_TLS_LE:
 		ld.Thearch.Vput(ld.R_PPC64_TPREL16 | uint64(elfsym)<<32)
 
-	case obj.R_POWER_TLS_IE:
+	case objabi.R_POWER_TLS_IE:
 		ld.Thearch.Vput(ld.R_PPC64_GOT_TPREL16_HA | uint64(elfsym)<<32)
 		ld.Thearch.Vput(uint64(r.Xadd))
 		ld.Thearch.Vput(uint64(sectoff + 4))
 		ld.Thearch.Vput(ld.R_PPC64_GOT_TPREL16_LO_DS | uint64(elfsym)<<32)
 
-	case obj.R_ADDRPOWER:
+	case objabi.R_ADDRPOWER:
 		ld.Thearch.Vput(ld.R_PPC64_ADDR16_HA | uint64(elfsym)<<32)
 		ld.Thearch.Vput(uint64(r.Xadd))
 		ld.Thearch.Vput(uint64(sectoff + 4))
 		ld.Thearch.Vput(ld.R_PPC64_ADDR16_LO | uint64(elfsym)<<32)
 
-	case obj.R_ADDRPOWER_DS:
+	case objabi.R_ADDRPOWER_DS:
 		ld.Thearch.Vput(ld.R_PPC64_ADDR16_HA | uint64(elfsym)<<32)
 		ld.Thearch.Vput(uint64(r.Xadd))
 		ld.Thearch.Vput(uint64(sectoff + 4))
 		ld.Thearch.Vput(ld.R_PPC64_ADDR16_LO_DS | uint64(elfsym)<<32)
 
-	case obj.R_ADDRPOWER_GOT:
+	case objabi.R_ADDRPOWER_GOT:
 		ld.Thearch.Vput(ld.R_PPC64_GOT16_HA | uint64(elfsym)<<32)
 		ld.Thearch.Vput(uint64(r.Xadd))
 		ld.Thearch.Vput(uint64(sectoff + 4))
 		ld.Thearch.Vput(ld.R_PPC64_GOT16_LO_DS | uint64(elfsym)<<32)
 
-	case obj.R_ADDRPOWER_PCREL:
+	case objabi.R_ADDRPOWER_PCREL:
 		ld.Thearch.Vput(ld.R_PPC64_REL16_HA | uint64(elfsym)<<32)
 		ld.Thearch.Vput(uint64(r.Xadd))
 		ld.Thearch.Vput(uint64(sectoff + 4))
 		ld.Thearch.Vput(ld.R_PPC64_REL16_LO | uint64(elfsym)<<32)
 		r.Xadd += 4
 
-	case obj.R_ADDRPOWER_TOCREL:
+	case objabi.R_ADDRPOWER_TOCREL:
 		ld.Thearch.Vput(ld.R_PPC64_TOC16_HA | uint64(elfsym)<<32)
 		ld.Thearch.Vput(uint64(r.Xadd))
 		ld.Thearch.Vput(uint64(sectoff + 4))
 		ld.Thearch.Vput(ld.R_PPC64_TOC16_LO | uint64(elfsym)<<32)
 
-	case obj.R_ADDRPOWER_TOCREL_DS:
+	case objabi.R_ADDRPOWER_TOCREL_DS:
 		ld.Thearch.Vput(ld.R_PPC64_TOC16_HA | uint64(elfsym)<<32)
 		ld.Thearch.Vput(uint64(r.Xadd))
 		ld.Thearch.Vput(uint64(sectoff + 4))
 		ld.Thearch.Vput(ld.R_PPC64_TOC16_LO_DS | uint64(elfsym)<<32)
 
-	case obj.R_CALLPOWER:
+	case objabi.R_CALLPOWER:
 		if r.Siz != 4 {
 			return -1
 		}
@@ -496,11 +496,11 @@ func archrelocaddr(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 	}
 
 	switch r.Type {
-	case obj.R_ADDRPOWER:
+	case objabi.R_ADDRPOWER:
 		o1 |= (uint32(t) >> 16) & 0xffff
 		o2 |= uint32(t) & 0xffff
 
-	case obj.R_ADDRPOWER_DS:
+	case objabi.R_ADDRPOWER_DS:
 		o1 |= (uint32(t) >> 16) & 0xffff
 		if t&3 != 0 {
 			ld.Errorf(s, "bad DS reloc for %s: %d", s.Name, ld.Symaddr(r.Sym))
@@ -524,7 +524,7 @@ func trampoline(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol) {
 
 	t := ld.Symaddr(r.Sym) + r.Add - (s.Value + int64(r.Off))
 	switch r.Type {
-	case obj.R_CALLPOWER:
+	case objabi.R_CALLPOWER:
 
 		// If branch offset is too far then create a trampoline.
 
@@ -588,19 +588,19 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 		default:
 			return -1
 
-		case obj.R_POWER_TLS, obj.R_POWER_TLS_LE, obj.R_POWER_TLS_IE:
+		case objabi.R_POWER_TLS, objabi.R_POWER_TLS_LE, objabi.R_POWER_TLS_IE:
 			r.Done = 0
 			// check Outer is nil, Type is TLSBSS?
 			r.Xadd = r.Add
 			r.Xsym = r.Sym
 			return 0
 
-		case obj.R_ADDRPOWER,
-			obj.R_ADDRPOWER_DS,
-			obj.R_ADDRPOWER_TOCREL,
-			obj.R_ADDRPOWER_TOCREL_DS,
-			obj.R_ADDRPOWER_GOT,
-			obj.R_ADDRPOWER_PCREL:
+		case objabi.R_ADDRPOWER,
+			objabi.R_ADDRPOWER_DS,
+			objabi.R_ADDRPOWER_TOCREL,
+			objabi.R_ADDRPOWER_TOCREL_DS,
+			objabi.R_ADDRPOWER_GOT,
+			objabi.R_ADDRPOWER_PCREL:
 			r.Done = 0
 
 			// set up addend for eventual relocation via outer symbol.
@@ -611,14 +611,14 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 				rs = rs.Outer
 			}
 
-			if rs.Type != obj.SHOSTOBJ && rs.Type != obj.SDYNIMPORT && rs.Sect == nil {
+			if rs.Type != objabi.SHOSTOBJ && rs.Type != objabi.SDYNIMPORT && rs.Sect == nil {
 				ld.Errorf(s, "missing section for %s", rs.Name)
 			}
 			r.Xsym = rs
 
 			return 0
 
-		case obj.R_CALLPOWER:
+		case objabi.R_CALLPOWER:
 			r.Done = 0
 			r.Xsym = r.Sym
 			r.Xadd = r.Add
@@ -627,18 +627,18 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 	}
 
 	switch r.Type {
-	case obj.R_CONST:
+	case objabi.R_CONST:
 		*val = r.Add
 		return 0
 
-	case obj.R_GOTOFF:
+	case objabi.R_GOTOFF:
 		*val = ld.Symaddr(r.Sym) + r.Add - ld.Symaddr(ctxt.Syms.Lookup(".got", 0))
 		return 0
 
-	case obj.R_ADDRPOWER, obj.R_ADDRPOWER_DS:
+	case objabi.R_ADDRPOWER, objabi.R_ADDRPOWER_DS:
 		return archrelocaddr(ctxt, r, s, val)
 
-	case obj.R_CALLPOWER:
+	case objabi.R_CALLPOWER:
 		// Bits 6 through 29 = (S + A - P) >> 2
 
 		t := ld.Symaddr(r.Sym) + r.Add - (s.Value + int64(r.Off))
@@ -654,12 +654,12 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 		*val |= int64(uint32(t) &^ 0xfc000003)
 		return 0
 
-	case obj.R_POWER_TOC: // S + A - .TOC.
+	case objabi.R_POWER_TOC: // S + A - .TOC.
 		*val = ld.Symaddr(r.Sym) + r.Add - symtoc(ctxt, s)
 
 		return 0
 
-	case obj.R_POWER_TLS_LE:
+	case objabi.R_POWER_TLS_LE:
 		// The thread pointer points 0x7000 bytes after the start of the the
 		// thread local storage area as documented in section "3.7.2 TLS
 		// Runtime Handling" of "Power Architecture 64-Bit ELF V2 ABI
@@ -790,7 +790,7 @@ func addpltsym(ctxt *ld.Link, s *ld.Symbol) {
 		r.Sym = glink
 		r.Off = int32(glink.Size)
 		r.Siz = 4
-		r.Type = obj.R_CALLPOWER
+		r.Type = objabi.R_CALLPOWER
 		ld.Adduint32(ctxt, glink, 0x48000000) // b .glink
 
 		// In the ppc64 ABI, the dynamic linker is responsible
@@ -845,7 +845,7 @@ func ensureglinkresolver(ctxt *ld.Link) *ld.Symbol {
 	r.Off = int32(glink.Size)
 	r.Sym = ctxt.Syms.Lookup(".plt", 0)
 	r.Siz = 8
-	r.Type = obj.R_ADDRPOWER
+	r.Type = objabi.R_ADDRPOWER
 
 	ld.Adduint32(ctxt, glink, 0x3d600000) // addis r11,0,.plt@ha
 	ld.Adduint32(ctxt, glink, 0x396b0000) // addi r11,r11,.plt@l
@@ -873,7 +873,7 @@ func ensureglinkresolver(ctxt *ld.Link) *ld.Symbol {
 
 func asmb(ctxt *ld.Link) {
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f asmb\n", obj.Cputime())
+		ctxt.Logf("%5.2f asmb\n", ld.Cputime())
 	}
 
 	if ld.Iself {
@@ -892,21 +892,21 @@ func asmb(ctxt *ld.Link) {
 
 	if ld.Segrodata.Filelen > 0 {
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f rodatblk\n", obj.Cputime())
+			ctxt.Logf("%5.2f rodatblk\n", ld.Cputime())
 		}
 		ld.Cseek(int64(ld.Segrodata.Fileoff))
 		ld.Datblk(ctxt, int64(ld.Segrodata.Vaddr), int64(ld.Segrodata.Filelen))
 	}
 	if ld.Segrelrodata.Filelen > 0 {
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f relrodatblk\n", obj.Cputime())
+			ctxt.Logf("%5.2f relrodatblk\n", ld.Cputime())
 		}
 		ld.Cseek(int64(ld.Segrelrodata.Fileoff))
 		ld.Datblk(ctxt, int64(ld.Segrelrodata.Vaddr), int64(ld.Segrelrodata.Filelen))
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f datblk\n", obj.Cputime())
+		ctxt.Logf("%5.2f datblk\n", ld.Cputime())
 	}
 
 	ld.Cseek(int64(ld.Segdata.Fileoff))
@@ -923,7 +923,7 @@ func asmb(ctxt *ld.Link) {
 	if !*ld.FlagS {
 		// TODO: rationalize
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f sym\n", obj.Cputime())
+			ctxt.Logf("%5.2f sym\n", ld.Cputime())
 		}
 		switch ld.Headtype {
 		default:
@@ -932,7 +932,7 @@ func asmb(ctxt *ld.Link) {
 				symo = uint32(ld.Rnd(int64(symo), int64(*ld.FlagRound)))
 			}
 
-		case obj.Hplan9:
+		case objabi.Hplan9:
 			symo = uint32(ld.Segdata.Fileoff + ld.Segdata.Filelen)
 		}
 
@@ -941,7 +941,7 @@ func asmb(ctxt *ld.Link) {
 		default:
 			if ld.Iself {
 				if ctxt.Debugvlog != 0 {
-					ctxt.Logf("%5.2f elfsym\n", obj.Cputime())
+					ctxt.Logf("%5.2f elfsym\n", ld.Cputime())
 				}
 				ld.Asmelfsym(ctxt)
 				ld.Cflush()
@@ -952,7 +952,7 @@ func asmb(ctxt *ld.Link) {
 				}
 			}
 
-		case obj.Hplan9:
+		case objabi.Hplan9:
 			ld.Asmplan9sym(ctxt)
 			ld.Cflush()
 
@@ -969,12 +969,12 @@ func asmb(ctxt *ld.Link) {
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f header\n", obj.Cputime())
+		ctxt.Logf("%5.2f header\n", ld.Cputime())
 	}
 	ld.Cseek(0)
 	switch ld.Headtype {
 	default:
-	case obj.Hplan9: /* plan 9 */
+	case objabi.Hplan9: /* plan 9 */
 		ld.Thearch.Lput(0x647)                      /* magic */
 		ld.Thearch.Lput(uint32(ld.Segtext.Filelen)) /* sizes */
 		ld.Thearch.Lput(uint32(ld.Segdata.Filelen))
@@ -984,11 +984,11 @@ func asmb(ctxt *ld.Link) {
 		ld.Thearch.Lput(0)
 		ld.Thearch.Lput(uint32(ld.Lcsize))
 
-	case obj.Hlinux,
-		obj.Hfreebsd,
-		obj.Hnetbsd,
-		obj.Hopenbsd,
-		obj.Hnacl:
+	case objabi.Hlinux,
+		objabi.Hfreebsd,
+		objabi.Hnetbsd,
+		objabi.Hopenbsd,
+		objabi.Hnacl:
 		ld.Asmbelf(ctxt, int64(symo))
 	}
 
diff --git a/src/cmd/link/internal/ppc64/obj.go b/src/cmd/link/internal/ppc64/obj.go
index 6eff2f416d..2d11eb5e49 100644
--- a/src/cmd/link/internal/ppc64/obj.go
+++ b/src/cmd/link/internal/ppc64/obj.go
@@ -31,14 +31,14 @@
 package ppc64
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"cmd/link/internal/ld"
 	"fmt"
 )
 
 func Init() {
-	if obj.GOARCH == "ppc64le" {
+	if objabi.GOARCH == "ppc64le" {
 		ld.SysArch = sys.ArchPPC64LE
 	} else {
 		ld.SysArch = sys.ArchPPC64
@@ -91,7 +91,7 @@ func archinit(ctxt *ld.Link) {
 	default:
 		ld.Exitf("unknown -H option: %v", ld.Headtype)
 
-	case obj.Hplan9: /* plan 9 */
+	case objabi.Hplan9: /* plan 9 */
 		ld.HEADR = 32
 
 		if *ld.FlagTextAddr == -1 {
@@ -104,7 +104,7 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagRound = 4096
 		}
 
-	case obj.Hlinux: /* ppc64 elf */
+	case objabi.Hlinux: /* ppc64 elf */
 		if ld.SysArch == sys.ArchPPC64 {
 			*ld.FlagD = true // TODO(austin): ELF ABI v1 not supported yet
 		}
@@ -120,7 +120,7 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagRound = 0x10000
 		}
 
-	case obj.Hnacl:
+	case objabi.Hnacl:
 		ld.Elfinit(ctxt)
 		ld.HEADR = 0x10000
 		ld.Funcalign = 16
diff --git a/src/cmd/link/internal/s390x/asm.go b/src/cmd/link/internal/s390x/asm.go
index 2db9428d00..1a42b7a3a3 100644
--- a/src/cmd/link/internal/s390x/asm.go
+++ b/src/cmd/link/internal/s390x/asm.go
@@ -31,7 +31,7 @@
 package s390x
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/link/internal/ld"
 	"debug/elf"
 	"fmt"
@@ -52,14 +52,14 @@ func gentext(ctxt *ld.Link) {
 		return
 	}
 	addmoduledata := ctxt.Syms.Lookup("runtime.addmoduledata", 0)
-	if addmoduledata.Type == obj.STEXT && ld.Buildmode != ld.BuildmodePlugin {
+	if addmoduledata.Type == objabi.STEXT && ld.Buildmode != ld.BuildmodePlugin {
 		// we're linking a module containing the runtime -> no need for
 		// an init function
 		return
 	}
 	addmoduledata.Attr |= ld.AttrReachable
 	initfunc := ctxt.Syms.Lookup("go.link.addmoduledata", 0)
-	initfunc.Type = obj.STEXT
+	initfunc.Type = objabi.STEXT
 	initfunc.Attr |= ld.AttrLocal
 	initfunc.Attr |= ld.AttrReachable
 
@@ -70,7 +70,7 @@ func gentext(ctxt *ld.Link) {
 	lmd.Off = int32(initfunc.Size)
 	lmd.Siz = 4
 	lmd.Sym = ctxt.Moduledata
-	lmd.Type = obj.R_PCREL
+	lmd.Type = objabi.R_PCREL
 	lmd.Variant = ld.RV_390_DBL
 	lmd.Add = 2 + int64(lmd.Siz)
 	ld.Adduint32(ctxt, initfunc, 0)
@@ -82,7 +82,7 @@ func gentext(ctxt *ld.Link) {
 	rel.Off = int32(initfunc.Size)
 	rel.Siz = 4
 	rel.Sym = ctxt.Syms.Lookup("runtime.addmoduledata", 0)
-	rel.Type = obj.R_CALL
+	rel.Type = objabi.R_CALL
 	rel.Variant = ld.RV_390_DBL
 	rel.Add = 2 + int64(rel.Siz)
 	ld.Adduint32(ctxt, initfunc, 0)
@@ -96,7 +96,7 @@ func gentext(ctxt *ld.Link) {
 	initarray_entry := ctxt.Syms.Lookup("go.link.addmoduledatainit", 0)
 	initarray_entry.Attr |= ld.AttrLocal
 	initarray_entry.Attr |= ld.AttrReachable
-	initarray_entry.Type = obj.SINITARR
+	initarray_entry.Type = objabi.SINITARR
 	ld.Addaddr(ctxt, initarray_entry, initfunc)
 }
 
@@ -120,22 +120,22 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 		256 + ld.R_390_16,
 		256 + ld.R_390_32,
 		256 + ld.R_390_64:
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			ld.Errorf(s, "unexpected R_390_nn relocation for dynamic symbol %s", targ.Name)
 		}
-		r.Type = obj.R_ADDR
+		r.Type = objabi.R_ADDR
 		return true
 
 	case 256 + ld.R_390_PC16,
 		256 + ld.R_390_PC32,
 		256 + ld.R_390_PC64:
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			ld.Errorf(s, "unexpected R_390_PCnn relocation for dynamic symbol %s", targ.Name)
 		}
-		if targ.Type == 0 || targ.Type == obj.SXREF {
+		if targ.Type == 0 || targ.Type == objabi.SXREF {
 			ld.Errorf(s, "unknown symbol %s in pcrel", targ.Name)
 		}
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Add += int64(r.Siz)
 		return true
 
@@ -147,10 +147,10 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 
 	case 256 + ld.R_390_PLT16DBL,
 		256 + ld.R_390_PLT32DBL:
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Variant = ld.RV_390_DBL
 		r.Add += int64(r.Siz)
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			addpltsym(ctxt, targ)
 			r.Sym = ctxt.Syms.Lookup(".plt", 0)
 			r.Add += int64(targ.Plt)
@@ -159,9 +159,9 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 
 	case 256 + ld.R_390_PLT32,
 		256 + ld.R_390_PLT64:
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Add += int64(r.Siz)
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			addpltsym(ctxt, targ)
 			r.Sym = ctxt.Syms.Lookup(".plt", 0)
 			r.Add += int64(targ.Plt)
@@ -185,30 +185,30 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 		return false
 
 	case 256 + ld.R_390_GOTOFF:
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			ld.Errorf(s, "unexpected R_390_GOTOFF relocation for dynamic symbol %s", targ.Name)
 		}
-		r.Type = obj.R_GOTOFF
+		r.Type = objabi.R_GOTOFF
 		return true
 
 	case 256 + ld.R_390_GOTPC:
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Sym = ctxt.Syms.Lookup(".got", 0)
 		r.Add += int64(r.Siz)
 		return true
 
 	case 256 + ld.R_390_PC16DBL,
 		256 + ld.R_390_PC32DBL:
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Variant = ld.RV_390_DBL
 		r.Add += int64(r.Siz)
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			ld.Errorf(s, "unexpected R_390_PCnnDBL relocation for dynamic symbol %s", targ.Name)
 		}
 		return true
 
 	case 256 + ld.R_390_GOTPCDBL:
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Variant = ld.RV_390_DBL
 		r.Sym = ctxt.Syms.Lookup(".got", 0)
 		r.Add += int64(r.Siz)
@@ -217,7 +217,7 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 	case 256 + ld.R_390_GOTENT:
 		addgotsym(ctxt, targ)
 
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Variant = ld.RV_390_DBL
 		r.Sym = ctxt.Syms.Lookup(".got", 0)
 		r.Add += int64(targ.Got)
@@ -225,7 +225,7 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 		return true
 	}
 	// Handle references to ELF symbols from our own object files.
-	if targ.Type != obj.SDYNIMPORT {
+	if targ.Type != objabi.SDYNIMPORT {
 		return true
 	}
 
@@ -240,7 +240,7 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 	default:
 		return -1
 
-	case obj.R_TLS_LE:
+	case objabi.R_TLS_LE:
 		switch r.Siz {
 		default:
 			return -1
@@ -252,7 +252,7 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 			ld.Thearch.Vput(ld.R_390_TLS_LE64 | uint64(elfsym)<<32)
 		}
 
-	case obj.R_TLS_IE:
+	case objabi.R_TLS_IE:
 		switch r.Siz {
 		default:
 			return -1
@@ -260,7 +260,7 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 			ld.Thearch.Vput(ld.R_390_TLS_IEENT | uint64(elfsym)<<32)
 		}
 
-	case obj.R_ADDR:
+	case objabi.R_ADDR:
 		switch r.Siz {
 		default:
 			return -1
@@ -270,23 +270,23 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 			ld.Thearch.Vput(ld.R_390_64 | uint64(elfsym)<<32)
 		}
 
-	case obj.R_GOTPCREL:
+	case objabi.R_GOTPCREL:
 		if r.Siz == 4 {
 			ld.Thearch.Vput(ld.R_390_GOTENT | uint64(elfsym)<<32)
 		} else {
 			return -1
 		}
 
-	case obj.R_PCREL, obj.R_PCRELDBL, obj.R_CALL:
+	case objabi.R_PCREL, objabi.R_PCRELDBL, objabi.R_CALL:
 		elfrel := ld.R_390_NONE
 		isdbl := r.Variant&ld.RV_TYPE_MASK == ld.RV_390_DBL
 		// TODO(mundaym): all DBL style relocations should be
 		// signalled using the variant - see issue 14218.
 		switch r.Type {
-		case obj.R_PCRELDBL, obj.R_CALL:
+		case objabi.R_PCRELDBL, objabi.R_CALL:
 			isdbl = true
 		}
-		if r.Xsym.Type == obj.SDYNIMPORT && (r.Xsym.ElfType == elf.STT_FUNC || r.Type == obj.R_CALL) {
+		if r.Xsym.Type == objabi.SDYNIMPORT && (r.Xsym.ElfType == elf.STT_FUNC || r.Type == objabi.R_CALL) {
 			if isdbl {
 				switch r.Siz {
 				case 2:
@@ -391,11 +391,11 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 	}
 
 	switch r.Type {
-	case obj.R_CONST:
+	case objabi.R_CONST:
 		*val = r.Add
 		return 0
 
-	case obj.R_GOTOFF:
+	case objabi.R_GOTOFF:
 		*val = ld.Symaddr(r.Sym) + r.Add - ld.Symaddr(ctxt.Syms.Lookup(".got", 0))
 		return 0
 	}
@@ -505,7 +505,7 @@ func addgotsym(ctxt *ld.Link, s *ld.Symbol) {
 
 func asmb(ctxt *ld.Link) {
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f asmb\n", obj.Cputime())
+		ctxt.Logf("%5.2f asmb\n", ld.Cputime())
 	}
 
 	if ld.Iself {
@@ -522,21 +522,21 @@ func asmb(ctxt *ld.Link) {
 
 	if ld.Segrodata.Filelen > 0 {
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f rodatblk\n", obj.Cputime())
+			ctxt.Logf("%5.2f rodatblk\n", ld.Cputime())
 		}
 		ld.Cseek(int64(ld.Segrodata.Fileoff))
 		ld.Datblk(ctxt, int64(ld.Segrodata.Vaddr), int64(ld.Segrodata.Filelen))
 	}
 	if ld.Segrelrodata.Filelen > 0 {
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f rodatblk\n", obj.Cputime())
+			ctxt.Logf("%5.2f rodatblk\n", ld.Cputime())
 		}
 		ld.Cseek(int64(ld.Segrelrodata.Fileoff))
 		ld.Datblk(ctxt, int64(ld.Segrelrodata.Vaddr), int64(ld.Segrelrodata.Filelen))
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f datblk\n", obj.Cputime())
+		ctxt.Logf("%5.2f datblk\n", ld.Cputime())
 	}
 
 	ld.Cseek(int64(ld.Segdata.Fileoff))
@@ -555,21 +555,21 @@ func asmb(ctxt *ld.Link) {
 			ld.Errorf(nil, "unsupported executable format")
 		}
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f sym\n", obj.Cputime())
+			ctxt.Logf("%5.2f sym\n", ld.Cputime())
 		}
 		symo = uint32(ld.Segdwarf.Fileoff + ld.Segdwarf.Filelen)
 		symo = uint32(ld.Rnd(int64(symo), int64(*ld.FlagRound)))
 
 		ld.Cseek(int64(symo))
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f elfsym\n", obj.Cputime())
+			ctxt.Logf("%5.2f elfsym\n", ld.Cputime())
 		}
 		ld.Asmelfsym(ctxt)
 		ld.Cflush()
 		ld.Cwrite(ld.Elfstrdat)
 
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f dwarf\n", obj.Cputime())
+			ctxt.Logf("%5.2f dwarf\n", ld.Cputime())
 		}
 
 		if ld.Linkmode == ld.LinkExternal {
@@ -578,13 +578,13 @@ func asmb(ctxt *ld.Link) {
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f header\n", obj.Cputime())
+		ctxt.Logf("%5.2f header\n", ld.Cputime())
 	}
 	ld.Cseek(0)
 	switch ld.Headtype {
 	default:
 		ld.Errorf(nil, "unsupported operating system")
-	case obj.Hlinux:
+	case objabi.Hlinux:
 		ld.Asmbelf(ctxt, int64(symo))
 	}
 
diff --git a/src/cmd/link/internal/s390x/obj.go b/src/cmd/link/internal/s390x/obj.go
index eea8978080..cd5da6a42c 100644
--- a/src/cmd/link/internal/s390x/obj.go
+++ b/src/cmd/link/internal/s390x/obj.go
@@ -31,7 +31,7 @@
 package s390x
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"cmd/link/internal/ld"
 	"fmt"
@@ -77,7 +77,7 @@ func archinit(ctxt *ld.Link) {
 	default:
 		ld.Exitf("unknown -H option: %v", ld.Headtype)
 
-	case obj.Hlinux: // s390x ELF
+	case objabi.Hlinux: // s390x ELF
 		ld.Elfinit(ctxt)
 		ld.HEADR = ld.ELFRESERVE
 		if *ld.FlagTextAddr == -1 {
diff --git a/src/cmd/link/internal/x86/asm.go b/src/cmd/link/internal/x86/asm.go
index 6ba00d72d5..2817326237 100644
--- a/src/cmd/link/internal/x86/asm.go
+++ b/src/cmd/link/internal/x86/asm.go
@@ -31,7 +31,7 @@
 package x86
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/link/internal/ld"
 	"log"
 )
@@ -45,7 +45,7 @@ func addcall(ctxt *ld.Link, s *ld.Symbol, t *ld.Symbol) {
 	r := ld.Addrel(s)
 	r.Sym = t
 	r.Off = int32(i)
-	r.Type = obj.R_CALL
+	r.Type = objabi.R_CALL
 	r.Siz = 4
 }
 
@@ -81,7 +81,7 @@ func gentext(ctxt *ld.Link) {
 		{"di", 7},
 	} {
 		thunkfunc := ctxt.Syms.Lookup("__x86.get_pc_thunk."+r.name, 0)
-		thunkfunc.Type = obj.STEXT
+		thunkfunc.Type = objabi.STEXT
 		thunkfunc.Attr |= ld.AttrLocal
 		thunkfunc.Attr |= ld.AttrReachable //TODO: remove?
 		o := func(op ...uint8) {
@@ -100,7 +100,7 @@ func gentext(ctxt *ld.Link) {
 	ctxt.Textp = append(thunks, ctxt.Textp...) // keep Textp in dependency order
 
 	addmoduledata := ctxt.Syms.Lookup("runtime.addmoduledata", 0)
-	if addmoduledata.Type == obj.STEXT && ld.Buildmode != ld.BuildmodePlugin {
+	if addmoduledata.Type == objabi.STEXT && ld.Buildmode != ld.BuildmodePlugin {
 		// we're linking a module containing the runtime -> no need for
 		// an init function
 		return
@@ -109,7 +109,7 @@ func gentext(ctxt *ld.Link) {
 	addmoduledata.Attr |= ld.AttrReachable
 
 	initfunc := ctxt.Syms.Lookup("go.link.addmoduledata", 0)
-	initfunc.Type = obj.STEXT
+	initfunc.Type = objabi.STEXT
 	initfunc.Attr |= ld.AttrLocal
 	initfunc.Attr |= ld.AttrReachable
 	o := func(op ...uint8) {
@@ -142,7 +142,7 @@ func gentext(ctxt *ld.Link) {
 	r := ld.Addrel(initfunc)
 	r.Sym = ctxt.Syms.Lookup("_GLOBAL_OFFSET_TABLE_", 0)
 	r.Off = int32(i)
-	r.Type = obj.R_PCREL
+	r.Type = objabi.R_PCREL
 	r.Add = 12
 	r.Siz = 4
 
@@ -160,7 +160,7 @@ func gentext(ctxt *ld.Link) {
 	initarray_entry := ctxt.Syms.Lookup("go.link.addmoduledatainit", 0)
 	initarray_entry.Attr |= ld.AttrReachable
 	initarray_entry.Attr |= ld.AttrLocal
-	initarray_entry.Type = obj.SINITARR
+	initarray_entry.Type = objabi.SINITARR
 	ld.Addaddr(ctxt, initarray_entry, initfunc)
 }
 
@@ -176,20 +176,20 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 
 		// Handle relocations found in ELF object files.
 	case 256 + ld.R_386_PC32:
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			ld.Errorf(s, "unexpected R_386_PC32 relocation for dynamic symbol %s", targ.Name)
 		}
-		if targ.Type == 0 || targ.Type == obj.SXREF {
+		if targ.Type == 0 || targ.Type == objabi.SXREF {
 			ld.Errorf(s, "unknown symbol %s in pcrel", targ.Name)
 		}
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Add += 4
 		return true
 
 	case 256 + ld.R_386_PLT32:
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Add += 4
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			addpltsym(ctxt, targ)
 			r.Sym = ctxt.Syms.Lookup(".plt", 0)
 			r.Add += int64(targ.Plt)
@@ -198,13 +198,13 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 		return true
 
 	case 256 + ld.R_386_GOT32, 256 + ld.R_386_GOT32X:
-		if targ.Type != obj.SDYNIMPORT {
+		if targ.Type != objabi.SDYNIMPORT {
 			// have symbol
 			if r.Off >= 2 && s.P[r.Off-2] == 0x8b {
 				// turn MOVL of GOT entry into LEAL of symbol address, relative to GOT.
 				s.P[r.Off-2] = 0x8d
 
-				r.Type = obj.R_GOTOFF
+				r.Type = objabi.R_GOTOFF
 				return true
 			}
 
@@ -214,7 +214,7 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 				s.P[r.Off-2] = 0x36
 
 				s.P[r.Off-1] = 0x68
-				r.Type = obj.R_ADDR
+				r.Type = objabi.R_ADDR
 				return true
 			}
 
@@ -223,49 +223,49 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 		}
 
 		addgotsym(ctxt, targ)
-		r.Type = obj.R_CONST // write r->add during relocsym
+		r.Type = objabi.R_CONST // write r->add during relocsym
 		r.Sym = nil
 		r.Add += int64(targ.Got)
 		return true
 
 	case 256 + ld.R_386_GOTOFF:
-		r.Type = obj.R_GOTOFF
+		r.Type = objabi.R_GOTOFF
 		return true
 
 	case 256 + ld.R_386_GOTPC:
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		r.Sym = ctxt.Syms.Lookup(".got", 0)
 		r.Add += 4
 		return true
 
 	case 256 + ld.R_386_32:
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			ld.Errorf(s, "unexpected R_386_32 relocation for dynamic symbol %s", targ.Name)
 		}
-		r.Type = obj.R_ADDR
+		r.Type = objabi.R_ADDR
 		return true
 
 	case 512 + ld.MACHO_GENERIC_RELOC_VANILLA*2 + 0:
-		r.Type = obj.R_ADDR
-		if targ.Type == obj.SDYNIMPORT {
+		r.Type = objabi.R_ADDR
+		if targ.Type == objabi.SDYNIMPORT {
 			ld.Errorf(s, "unexpected reloc for dynamic symbol %s", targ.Name)
 		}
 		return true
 
 	case 512 + ld.MACHO_GENERIC_RELOC_VANILLA*2 + 1:
-		if targ.Type == obj.SDYNIMPORT {
+		if targ.Type == objabi.SDYNIMPORT {
 			addpltsym(ctxt, targ)
 			r.Sym = ctxt.Syms.Lookup(".plt", 0)
 			r.Add = int64(targ.Plt)
-			r.Type = obj.R_PCREL
+			r.Type = objabi.R_PCREL
 			return true
 		}
 
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		return true
 
 	case 512 + ld.MACHO_FAKE_GOTPCREL:
-		if targ.Type != obj.SDYNIMPORT {
+		if targ.Type != objabi.SDYNIMPORT {
 			// have symbol
 			// turn MOVL of GOT entry into LEAL of symbol itself
 			if r.Off < 2 || s.P[r.Off-2] != 0x8b {
@@ -274,31 +274,31 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 			}
 
 			s.P[r.Off-2] = 0x8d
-			r.Type = obj.R_PCREL
+			r.Type = objabi.R_PCREL
 			return true
 		}
 
 		addgotsym(ctxt, targ)
 		r.Sym = ctxt.Syms.Lookup(".got", 0)
 		r.Add += int64(targ.Got)
-		r.Type = obj.R_PCREL
+		r.Type = objabi.R_PCREL
 		return true
 	}
 
 	// Handle references to ELF symbols from our own object files.
-	if targ.Type != obj.SDYNIMPORT {
+	if targ.Type != objabi.SDYNIMPORT {
 		return true
 	}
 	switch r.Type {
-	case obj.R_CALL,
-		obj.R_PCREL:
+	case objabi.R_CALL,
+		objabi.R_PCREL:
 		addpltsym(ctxt, targ)
 		r.Sym = ctxt.Syms.Lookup(".plt", 0)
 		r.Add = int64(targ.Plt)
 		return true
 
-	case obj.R_ADDR:
-		if s.Type != obj.SDATA {
+	case objabi.R_ADDR:
+		if s.Type != objabi.SDATA {
 			break
 		}
 		if ld.Iself {
@@ -306,12 +306,12 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 			rel := ctxt.Syms.Lookup(".rel", 0)
 			ld.Addaddrplus(ctxt, rel, s, int64(r.Off))
 			ld.Adduint32(ctxt, rel, ld.ELF32_R_INFO(uint32(targ.Dynid), ld.R_386_32))
-			r.Type = obj.R_CONST // write r->add during relocsym
+			r.Type = objabi.R_CONST // write r->add during relocsym
 			r.Sym = nil
 			return true
 		}
 
-		if ld.Headtype == obj.Hdarwin && s.Size == int64(ld.SysArch.PtrSize) && r.Off == 0 {
+		if ld.Headtype == objabi.Hdarwin && s.Size == int64(ld.SysArch.PtrSize) && r.Off == 0 {
 			// Mach-O relocations are a royal pain to lay out.
 			// They use a compact stateful bytecode representation
 			// that is too much bother to deal with.
@@ -325,7 +325,7 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 			ld.Adddynsym(ctxt, targ)
 
 			got := ctxt.Syms.Lookup(".got", 0)
-			s.Type = got.Type | obj.SSUB
+			s.Type = got.Type | objabi.SSUB
 			s.Outer = got
 			s.Sub = got.Sub
 			got.Sub = s
@@ -336,7 +336,7 @@ func adddynrel(ctxt *ld.Link, s *ld.Symbol, r *ld.Reloc) bool {
 			return true
 		}
 
-		if ld.Headtype == obj.Hwindows && s.Size == int64(ld.SysArch.PtrSize) {
+		if ld.Headtype == objabi.Hwindows && s.Size == int64(ld.SysArch.PtrSize) {
 			// nothing to do, the relocation will be laid out in pereloc1
 			return true
 		}
@@ -353,14 +353,14 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 	default:
 		return -1
 
-	case obj.R_ADDR:
+	case objabi.R_ADDR:
 		if r.Siz == 4 {
 			ld.Thearch.Lput(ld.R_386_32 | uint32(elfsym)<<8)
 		} else {
 			return -1
 		}
 
-	case obj.R_GOTPCREL:
+	case objabi.R_GOTPCREL:
 		if r.Siz == 4 {
 			ld.Thearch.Lput(ld.R_386_GOTPC)
 			if r.Xsym.Name != "_GLOBAL_OFFSET_TABLE_" {
@@ -371,9 +371,9 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 			return -1
 		}
 
-	case obj.R_CALL:
+	case objabi.R_CALL:
 		if r.Siz == 4 {
-			if r.Xsym.Type == obj.SDYNIMPORT {
+			if r.Xsym.Type == objabi.SDYNIMPORT {
 				ld.Thearch.Lput(ld.R_386_PLT32 | uint32(elfsym)<<8)
 			} else {
 				ld.Thearch.Lput(ld.R_386_PC32 | uint32(elfsym)<<8)
@@ -382,21 +382,21 @@ func elfreloc1(ctxt *ld.Link, r *ld.Reloc, sectoff int64) int {
 			return -1
 		}
 
-	case obj.R_PCREL:
+	case objabi.R_PCREL:
 		if r.Siz == 4 {
 			ld.Thearch.Lput(ld.R_386_PC32 | uint32(elfsym)<<8)
 		} else {
 			return -1
 		}
 
-	case obj.R_TLS_LE:
+	case objabi.R_TLS_LE:
 		if r.Siz == 4 {
 			ld.Thearch.Lput(ld.R_386_TLS_LE | uint32(elfsym)<<8)
 		} else {
 			return -1
 		}
 
-	case obj.R_TLS_IE:
+	case objabi.R_TLS_IE:
 		if r.Siz == 4 {
 			ld.Thearch.Lput(ld.R_386_GOTPC)
 			ld.Thearch.Lput(uint32(sectoff))
@@ -414,7 +414,7 @@ func machoreloc1(s *ld.Symbol, r *ld.Reloc, sectoff int64) int {
 
 	rs := r.Xsym
 
-	if rs.Type == obj.SHOSTOBJ {
+	if rs.Type == objabi.SHOSTOBJ {
 		if rs.Dynid < 0 {
 			ld.Errorf(s, "reloc %d to non-macho symbol %s type=%d", r.Type, rs.Name, rs.Type)
 			return -1
@@ -434,11 +434,11 @@ func machoreloc1(s *ld.Symbol, r *ld.Reloc, sectoff int64) int {
 	default:
 		return -1
 
-	case obj.R_ADDR:
+	case objabi.R_ADDR:
 		v |= ld.MACHO_GENERIC_RELOC_VANILLA << 28
 
-	case obj.R_CALL,
-		obj.R_PCREL:
+	case objabi.R_CALL,
+		objabi.R_PCREL:
 		v |= 1 << 24 // pc-relative bit
 		v |= ld.MACHO_GENERIC_RELOC_VANILLA << 28
 	}
@@ -482,14 +482,14 @@ func pereloc1(s *ld.Symbol, r *ld.Reloc, sectoff int64) bool {
 	default:
 		return false
 
-	case obj.R_DWARFREF:
+	case objabi.R_DWARFREF:
 		v = ld.IMAGE_REL_I386_SECREL
 
-	case obj.R_ADDR:
+	case objabi.R_ADDR:
 		v = ld.IMAGE_REL_I386_DIR32
 
-	case obj.R_CALL,
-		obj.R_PCREL:
+	case objabi.R_CALL,
+		objabi.R_PCREL:
 		v = ld.IMAGE_REL_I386_REL32
 	}
 
@@ -503,11 +503,11 @@ func archreloc(ctxt *ld.Link, r *ld.Reloc, s *ld.Symbol, val *int64) int {
 		return -1
 	}
 	switch r.Type {
-	case obj.R_CONST:
+	case objabi.R_CONST:
 		*val = r.Add
 		return 0
 
-	case obj.R_GOTOFF:
+	case objabi.R_GOTOFF:
 		*val = ld.Symaddr(r.Sym) + r.Add - ld.Symaddr(ctxt.Syms.Lookup(".got", 0))
 		return 0
 	}
@@ -587,7 +587,7 @@ func addpltsym(ctxt *ld.Link, s *ld.Symbol) {
 		ld.Adduint32(ctxt, rel, ld.ELF32_R_INFO(uint32(s.Dynid), ld.R_386_JMP_SLOT))
 
 		s.Plt = int32(plt.Size - 16)
-	} else if ld.Headtype == obj.Hdarwin {
+	} else if ld.Headtype == objabi.Hdarwin {
 		// Same laziness as in 6l.
 
 		plt := ctxt.Syms.Lookup(".plt", 0)
@@ -621,7 +621,7 @@ func addgotsym(ctxt *ld.Link, s *ld.Symbol) {
 		rel := ctxt.Syms.Lookup(".rel", 0)
 		ld.Addaddrplus(ctxt, rel, got, int64(s.Got))
 		ld.Adduint32(ctxt, rel, ld.ELF32_R_INFO(uint32(s.Dynid), ld.R_386_GLOB_DAT))
-	} else if ld.Headtype == obj.Hdarwin {
+	} else if ld.Headtype == objabi.Hdarwin {
 		ld.Adduint32(ctxt, ctxt.Syms.Lookup(".linkedit.got", 0), uint32(s.Dynid))
 	} else {
 		ld.Errorf(s, "addgotsym: unsupported binary format")
@@ -630,7 +630,7 @@ func addgotsym(ctxt *ld.Link, s *ld.Symbol) {
 
 func asmb(ctxt *ld.Link) {
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f asmb\n", obj.Cputime())
+		ctxt.Logf("%5.2f asmb\n", ld.Cputime())
 	}
 
 	if ld.Iself {
@@ -648,7 +648,7 @@ func asmb(ctxt *ld.Link) {
 
 	if ld.Segrodata.Filelen > 0 {
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f rodatblk\n", obj.Cputime())
+			ctxt.Logf("%5.2f rodatblk\n", ld.Cputime())
 		}
 
 		ld.Cseek(int64(ld.Segrodata.Fileoff))
@@ -656,14 +656,14 @@ func asmb(ctxt *ld.Link) {
 	}
 	if ld.Segrelrodata.Filelen > 0 {
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f relrodatblk\n", obj.Cputime())
+			ctxt.Logf("%5.2f relrodatblk\n", ld.Cputime())
 		}
 		ld.Cseek(int64(ld.Segrelrodata.Fileoff))
 		ld.Datblk(ctxt, int64(ld.Segrelrodata.Vaddr), int64(ld.Segrelrodata.Filelen))
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f datblk\n", obj.Cputime())
+		ctxt.Logf("%5.2f datblk\n", ld.Cputime())
 	}
 
 	ld.Cseek(int64(ld.Segdata.Fileoff))
@@ -673,7 +673,7 @@ func asmb(ctxt *ld.Link) {
 	ld.Dwarfblk(ctxt, int64(ld.Segdwarf.Vaddr), int64(ld.Segdwarf.Filelen))
 
 	machlink := uint32(0)
-	if ld.Headtype == obj.Hdarwin {
+	if ld.Headtype == objabi.Hdarwin {
 		machlink = uint32(ld.Domacholink(ctxt))
 	}
 
@@ -684,7 +684,7 @@ func asmb(ctxt *ld.Link) {
 	if !*ld.FlagS {
 		// TODO: rationalize
 		if ctxt.Debugvlog != 0 {
-			ctxt.Logf("%5.2f sym\n", obj.Cputime())
+			ctxt.Logf("%5.2f sym\n", ld.Cputime())
 		}
 		switch ld.Headtype {
 		default:
@@ -693,13 +693,13 @@ func asmb(ctxt *ld.Link) {
 				symo = uint32(ld.Rnd(int64(symo), int64(*ld.FlagRound)))
 			}
 
-		case obj.Hplan9:
+		case objabi.Hplan9:
 			symo = uint32(ld.Segdata.Fileoff + ld.Segdata.Filelen)
 
-		case obj.Hdarwin:
+		case objabi.Hdarwin:
 			symo = uint32(ld.Segdwarf.Fileoff + uint64(ld.Rnd(int64(ld.Segdwarf.Filelen), int64(*ld.FlagRound))) + uint64(machlink))
 
-		case obj.Hwindows:
+		case objabi.Hwindows:
 			symo = uint32(ld.Segdwarf.Fileoff + ld.Segdwarf.Filelen)
 			symo = uint32(ld.Rnd(int64(symo), ld.PEFILEALIGN))
 		}
@@ -709,7 +709,7 @@ func asmb(ctxt *ld.Link) {
 		default:
 			if ld.Iself {
 				if ctxt.Debugvlog != 0 {
-					ctxt.Logf("%5.2f elfsym\n", obj.Cputime())
+					ctxt.Logf("%5.2f elfsym\n", ld.Cputime())
 				}
 				ld.Asmelfsym(ctxt)
 				ld.Cflush()
@@ -720,7 +720,7 @@ func asmb(ctxt *ld.Link) {
 				}
 			}
 
-		case obj.Hplan9:
+		case objabi.Hplan9:
 			ld.Asmplan9sym(ctxt)
 			ld.Cflush()
 
@@ -734,12 +734,12 @@ func asmb(ctxt *ld.Link) {
 				ld.Cflush()
 			}
 
-		case obj.Hwindows:
+		case objabi.Hwindows:
 			if ctxt.Debugvlog != 0 {
-				ctxt.Logf("%5.2f dwarf\n", obj.Cputime())
+				ctxt.Logf("%5.2f dwarf\n", ld.Cputime())
 			}
 
-		case obj.Hdarwin:
+		case objabi.Hdarwin:
 			if ld.Linkmode == ld.LinkExternal {
 				ld.Machoemitreloc(ctxt)
 			}
@@ -747,12 +747,12 @@ func asmb(ctxt *ld.Link) {
 	}
 
 	if ctxt.Debugvlog != 0 {
-		ctxt.Logf("%5.2f headr\n", obj.Cputime())
+		ctxt.Logf("%5.2f headr\n", ld.Cputime())
 	}
 	ld.Cseek(0)
 	switch ld.Headtype {
 	default:
-	case obj.Hplan9: /* plan9 */
+	case objabi.Hplan9: /* plan9 */
 		magic := int32(4*11*11 + 7)
 
 		ld.Lputb(uint32(magic))              /* magic */
@@ -764,17 +764,17 @@ func asmb(ctxt *ld.Link) {
 		ld.Lputb(uint32(ld.Spsize))           /* sp offsets */
 		ld.Lputb(uint32(ld.Lcsize))           /* line offsets */
 
-	case obj.Hdarwin:
+	case objabi.Hdarwin:
 		ld.Asmbmacho(ctxt)
 
-	case obj.Hlinux,
-		obj.Hfreebsd,
-		obj.Hnetbsd,
-		obj.Hopenbsd,
-		obj.Hnacl:
+	case objabi.Hlinux,
+		objabi.Hfreebsd,
+		objabi.Hnetbsd,
+		objabi.Hopenbsd,
+		objabi.Hnacl:
 		ld.Asmbelf(ctxt, int64(symo))
 
-	case obj.Hwindows:
+	case objabi.Hwindows:
 		ld.Asmbpe(ctxt)
 	}
 
diff --git a/src/cmd/link/internal/x86/obj.go b/src/cmd/link/internal/x86/obj.go
index bd85eed4d7..fa925d1aec 100644
--- a/src/cmd/link/internal/x86/obj.go
+++ b/src/cmd/link/internal/x86/obj.go
@@ -31,7 +31,7 @@
 package x86
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"cmd/link/internal/ld"
 	"fmt"
@@ -75,7 +75,7 @@ func archinit(ctxt *ld.Link) {
 	default:
 		ld.Exitf("unknown -H option: %v", ld.Headtype)
 
-	case obj.Hplan9: /* plan 9 */
+	case objabi.Hplan9: /* plan 9 */
 		ld.HEADR = 32
 
 		if *ld.FlagTextAddr == -1 {
@@ -88,7 +88,7 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagRound = 4096
 		}
 
-	case obj.Hdarwin: /* apple MACH */
+	case objabi.Hdarwin: /* apple MACH */
 		ld.Machoinit()
 
 		ld.HEADR = ld.INITIAL_MACHO_HEADR
@@ -102,10 +102,10 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagRound = 4096
 		}
 
-	case obj.Hlinux, /* elf32 executable */
-		obj.Hfreebsd,
-		obj.Hnetbsd,
-		obj.Hopenbsd:
+	case objabi.Hlinux, /* elf32 executable */
+		objabi.Hfreebsd,
+		objabi.Hnetbsd,
+		objabi.Hopenbsd:
 		ld.Elfinit(ctxt)
 
 		ld.HEADR = ld.ELFRESERVE
@@ -119,7 +119,7 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagRound = 4096
 		}
 
-	case obj.Hnacl:
+	case objabi.Hnacl:
 		ld.Elfinit(ctxt)
 		ld.HEADR = 0x10000
 		ld.Funcalign = 32
@@ -133,7 +133,7 @@ func archinit(ctxt *ld.Link) {
 			*ld.FlagRound = 0x10000
 		}
 
-	case obj.Hwindows: /* PE executable */
+	case objabi.Hwindows: /* PE executable */
 		// ld.HEADR, ld.FlagTextAddr, ld.FlagDataAddr and ld.FlagRound are set in ld.Peinit
 		return
 	}
diff --git a/src/cmd/link/linkbig_test.go b/src/cmd/link/linkbig_test.go
index 960d89fd21..21208e86e4 100644
--- a/src/cmd/link/linkbig_test.go
+++ b/src/cmd/link/linkbig_test.go
@@ -10,7 +10,7 @@ package main
 
 import (
 	"bytes"
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"fmt"
 	"internal/testenv"
 	"io/ioutil"
@@ -20,8 +20,8 @@ import (
 )
 
 func TestLargeText(t *testing.T) {
-	if testing.Short() || (obj.GOARCH != "ppc64le" && obj.GOARCH != "ppc64" && obj.GOARCH != "arm") {
-		t.Skipf("Skipping large text section test in short mode or on %s", obj.GOARCH)
+	if testing.Short() || (objabi.GOARCH != "ppc64le" && objabi.GOARCH != "ppc64" && objabi.GOARCH != "arm") {
+		t.Skipf("Skipping large text section test in short mode or on %s", objabi.GOARCH)
 	}
 	testenv.MustHaveGoBuild(t)
 
@@ -41,7 +41,7 @@ func TestLargeText(t *testing.T) {
 		"ppc64le": "\tMOVD\tR0,R3\n",
 		"arm":     "\tMOVW\tR0,R1\n",
 	}
-	inst := instOnArch[obj.GOARCH]
+	inst := instOnArch[objabi.GOARCH]
 	for j := 0; j < FN; j++ {
 		testname := fmt.Sprintf("bigfn%d", j)
 		fmt.Fprintf(&w, "TEXT %s(SB),$0\n", testname)
diff --git a/src/cmd/link/main.go b/src/cmd/link/main.go
index a9aeb1e6bb..eab190d5b1 100644
--- a/src/cmd/link/main.go
+++ b/src/cmd/link/main.go
@@ -5,7 +5,7 @@
 package main
 
 import (
-	"cmd/internal/obj"
+	"cmd/internal/objabi"
 	"cmd/link/internal/amd64"
 	"cmd/link/internal/arm"
 	"cmd/link/internal/arm64"
@@ -34,9 +34,9 @@ import (
 // via the ld.Thearch.Archinit function.
 
 func main() {
-	switch obj.GOARCH {
+	switch objabi.GOARCH {
 	default:
-		fmt.Fprintf(os.Stderr, "link: unknown architecture %q\n", obj.GOARCH)
+		fmt.Fprintf(os.Stderr, "link: unknown architecture %q\n", objabi.GOARCH)
 		os.Exit(2)
 	case "386":
 		x86.Init()
diff --git a/test/nosplit.go b/test/nosplit.go
index e0d531c116..3244df53c5 100644
--- a/test/nosplit.go
+++ b/test/nosplit.go
@@ -310,7 +310,7 @@ TestCases:
 					size += (880 - 128) - 128
 					// Noopt builds have a larger stackguard.
 					// See ../src/cmd/dist/buildruntime.go:stackGuardMultiplier
-					// This increase is included in obj.StackGuard
+					// This increase is included in objabi.StackGuard
 					for _, s := range strings.Split(os.Getenv("GO_GCFLAGS"), " ") {
 						if s == "-N" {
 							size += 880
