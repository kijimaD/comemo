commit 5b814d02f2e4ea8336e1555474724c84e9022de1
Author: Rob Pike <r@golang.org>
Date:   Thu Mar 5 13:31:03 2009 -0800

    delete deprecated files.
    deletion beats documentation for deprecation.
    
    R=rsc,gri
    DELTA=509  (2 added, 490 deleted, 17 changed)
    OCL=25737
    CL=25768
---
 src/lib/Makefile                      |   8 +-
 src/lib/container/array/Makefile      |  63 ------------
 src/lib/container/array/array.go      | 186 ----------------------------------
 src/lib/container/array/array_test.go | 172 -------------------------------
 src/lib/container/array/intarray.go   |  68 -------------
 src/lib/json/generic.go               |   8 +-
 src/lib/json/parse.go                 |   1 -
 src/lib/regexp/regexp.go              |  12 +--
 8 files changed, 12 insertions(+), 506 deletions(-)

diff --git a/src/lib/Makefile b/src/lib/Makefile
index 39dce2b901..2f65396195 100644
--- a/src/lib/Makefile
+++ b/src/lib/Makefile
@@ -8,7 +8,6 @@ GC=6g
 
 DIRS=\
 	container\
-	container/array\
 	fmt\
 	hash\
 	http\
@@ -55,9 +54,6 @@ install.files: $(addsuffix .install, $(FILES))
 nuke.dirs: $(addsuffix .dirnuke, $(DIRS))
 test.files: $(addsuffix .test, $(TEST))
 
-%.6: container/%.go
-	$(GC) container/$*.go
-
 %.6: %.go
 	$(GC) $*.go
 
@@ -106,7 +102,7 @@ fmt.dirinstall: io.dirinstall reflect.dirinstall strconv.dirinstall
 hash.dirinstall: os.dirinstall
 http.dirinstall: bufio.install io.dirinstall net.dirinstall os.dirinstall strings.install log.install
 io.dirinstall: os.dirinstall syscall.dirinstall sync.dirinstall
-json.dirinstall: container/array.dirinstall fmt.dirinstall io.dirinstall math.dirinstall \
+json.dirinstall: container.dirinstall fmt.dirinstall io.dirinstall math.dirinstall \
 	strconv.dirinstall strings.install utf8.install
 lang.dirinstall: strconv.dirinstall utf8.install unicode.dirinstall
 # TODO(rsc): net is not supposed to depend on fmt or strings or strconv
@@ -115,7 +111,7 @@ os.dirinstall: syscall.dirinstall once.install
 regexp.dirinstall: os.dirinstall
 reflect.dirinstall: strconv.dirinstall sync.dirinstall
 strconv.dirinstall: math.dirinstall os.dirinstall utf8.install
-tabwriter.dirinstall: os.dirinstall io.dirinstall container/array.dirinstall
+tabwriter.dirinstall: os.dirinstall io.dirinstall container.dirinstall
 time.dirinstall: once.install os.dirinstall io.dirinstall
 sync.dirinstall:
 syscall.dirinstall: sync.dirinstall
diff --git a/src/lib/container/array/Makefile b/src/lib/container/array/Makefile
deleted file mode 100644
index bf76c44eb6..0000000000
--- a/src/lib/container/array/Makefile
+++ /dev/null
@@ -1,63 +0,0 @@
-# Copyright 2009 The Go Authors.  All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-# DO NOT EDIT.  Automatically generated by gobuild.
-# gobuild -m >Makefile
-O=6
-GC=$(O)g
-CC=$(O)c -w
-AS=$(O)a
-AR=$(O)ar
-
-default: packages
-
-clean:
-	rm -f *.$O *.a $O.out
-
-test: packages
-	gotest
-
-coverage: packages
-	gotest
-	6cov -g `pwd` | grep -v '_test\.go:'
-
-%.$O: %.go
-	$(GC) $*.go
-
-%.$O: %.c
-	$(CC) $*.c
-
-%.$O: %.s
-	$(AS) $*.s
-
-O1=\
-	array.$O\
-
-O2=\
-	intarray.$O\
-
-array.a: a1 a2
-
-a1:	$(O1)
-	$(AR) grc array.a array.$O
-	rm -f $(O1)
-
-a2:	$(O2)
-	$(AR) grc array.a intarray.$O
-	rm -f $(O2)
-
-newpkg: clean
-	$(AR) grc array.a
-
-$(O1): newpkg
-$(O2): a1
-
-nuke: clean
-	rm -f $(GOROOT)/pkg/array.a
-
-packages: array.a
-
-install: packages
-	cp array.a $(GOROOT)/pkg/array.a
-
diff --git a/src/lib/container/array/array.go b/src/lib/container/array/array.go
deleted file mode 100644
index 4b8f686ccb..0000000000
--- a/src/lib/container/array/array.go
+++ /dev/null
@@ -1,186 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//
-// *** DEPRECATED PACKAGE - USE package vector INSTEAD ***
-//
-
-package array
-
-type (
-	Element interface {};
-	Array struct {
-		a []Element
-	}
-)
-
-
-func copy(dst, src []Element) {
-	for i := 0; i < len(src); i++ {
-		dst[i] = src[i]
-	}
-}
-
-
-// Insert n elements at position i.
-func expand(a []Element, i, n int) []Element {
-	// make sure we have enough space
-	len0 := len(a);
-	len1 := len0 + n;
-	if len1 < cap(a) {
-		// enough space - just expand
-		a = a[0 : len1]
-	} else {
-		// not enough space - double capacity
-		capb := cap(a)*2;
-		if capb < len1 {
-			// still not enough - use required length
-			capb = len1
-		}
-		// capb >= len1
-		b := make([]Element, len1, capb);
-		copy(b, a);
-		a = b
-	}
-
-	// make a hole
-	for j := len0-1; j >= i ; j-- {
-		a[j+n] = a[j]
-	}
-	return a
-}
-
-
-func (p *Array) Init(initial_len int) *Array {
-	a := p.a;
-
-	if cap(a) == 0 || cap(a) < initial_len {
-		n := 8;  // initial capacity
-		if initial_len > n {
-			n = initial_len
-		}
-		a = make([]Element, n);
-	} else {
-		// nil out entries
-		for j := len(a) - 1; j >= 0; j-- {
-			a[j] = nil
-		}
-	}
-
-	p.a = a[0 : initial_len];
-	return p
-}
-
-
-func New(len int) *Array {
-	return new(Array).Init(len)
-}
-
-
-func (p *Array) Len() int {
-	return len(p.a)
-}
-
-
-func (p *Array) At(i int) Element {
-	return p.a[i]
-}
-
-
-func (p *Array) Set(i int, x Element) {
-	p.a[i] = x
-}
-
-
-func (p *Array) Last() Element {
-	return p.a[len(p.a) - 1]
-}
-
-
-func (p *Array) Insert(i int, x Element) {
-	p.a = expand(p.a, i, 1);
-	p.a[i] = x;
-}
-
-
-func (p *Array) Delete(i int) Element {
-	a := p.a;
-	n := len(a);
-
-	x := a[i];
-	copy(a[i : n-1], a[i+1 : n]);
-	a[n-1] = nil;  // support GC, nil out entry
-	p.a = a[0 : n-1];
-
-	return x
-}
-
-
-func (p *Array) InsertArray(i int, x *Array) {
-	p.a = expand(p.a, i, len(x.a));
-	copy(p.a[i : i + len(x.a)], x.a);
-}
-
-
-func (p *Array) Cut(i, j int) {
-	a := p.a;
-	n := len(a);
-	m := n - (j - i);
-
-	copy(a[i : m], a[j : n]);
-	for k := m; k < n; k++ {
-		a[k] = nil  // support GC, nil out entries
-	}
-
-	p.a = a[0 : m];
-}
-
-
-func (p *Array) Slice(i, j int) *Array {
-	s := New(j - i);  // will fail in Init() if j < j
-	copy(s.a, p.a[i : j]);
-	return s;
-}
-
-
-func (p *Array) Do(f func(elem Element)) {
-	for i := 0; i < len(p.a); i++ {
-		f(p.a[i])	// not too safe if f changes the Array
-	}
-}
-
-
-// Convenience wrappers
-
-func (p *Array) Push(x Element) {
-	p.Insert(len(p.a), x)
-}
-
-
-func (p *Array) Pop() Element {
-	return p.Delete(len(p.a) - 1)
-}
-
-
-func (p *Array) AppendArray(x *Array) {
-	p.InsertArray(len(p.a), x);
-}
-
-
-// Partial SortInterface support
-
-type LessInterface interface {
-	Less(y Element) bool
-}
-
-
-func (p *Array) Less(i, j int) bool {
-	return p.a[i].(LessInterface).Less(p.a[j])
-}
-
-
-func (p *Array) Swap(i, j int) {
-	a := p.a;
-	a[i], a[j] = a[j], a[i]
-}
diff --git a/src/lib/container/array/array_test.go b/src/lib/container/array/array_test.go
deleted file mode 100644
index 43ac702abc..0000000000
--- a/src/lib/container/array/array_test.go
+++ /dev/null
@@ -1,172 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package array
-
-import "array"
-import "testing"
-import "sort"
-
-
-func TestInit(t *testing.T) {
-	var a array.Array;
-	if a.Init(0).Len() != 0 { t.Error("A") }
-	if a.Init(1).Len() != 1 { t.Error("B") }
-	if a.Init(10).Len() != 10 { t.Error("C") }
-}
-
-
-func TestNew(t *testing.T) {
-	if array.New(0).Len() != 0 { t.Error("A") }
-	if array.New(1).Len() != 1 { t.Error("B") }
-	if array.New(10).Len() != 10 { t.Error("C") }
-}
-
-
-func val(i int) int {
-	return i*991 - 1234
-}
-
-
-func TestAccess(t *testing.T) {
-	const n = 100;
-	var a array.Array;
-	a.Init(n);
-	for i := 0; i < n; i++ {
-		a.Set(i, val(i));
-	}
-	for i := 0; i < n; i++ {
-		if a.At(i).(int) != val(i) { t.Error(i) }
-	}
-}
-
-
-func TestInsertDeleteClear(t *testing.T) {
-	const n = 100;
-	a := array.New(0);
-
-	for i := 0; i < n; i++ {
-		if a.Len() != i { t.Errorf("A) wrong len %d (expected %d)", a.Len(), i) }
-		a.Insert(0, val(i));
-		if a.Last().(int) != val(0) { t.Error("B") }
-	}
-	for i := n-1; i >= 0; i-- {
-		if a.Last().(int) != val(0) { t.Error("C") }
-		if a.Delete(0).(int) != val(i) { t.Error("D") }
-		if a.Len() != i { t.Errorf("E) wrong len %d (expected %d)", a.Len(), i) }
-	}
-
-	if a.Len() != 0 { t.Errorf("F) wrong len %d (expected 0)", a.Len()) }
-	for i := 0; i < n; i++ {
-		a.Push(val(i));
-		if a.Len() != i+1 { t.Errorf("G) wrong len %d (expected %d)", a.Len(), i+1) }
-		if a.Last().(int) != val(i) { t.Error("H") }
-	}
-	a.Init(0);
-	if a.Len() != 0 { t.Errorf("I wrong len %d (expected 0)", a.Len()) }
-
-	const m = 5;
-	for j := 0; j < m; j++ {
-		a.Push(j);
-		for i := 0; i < n; i++ {
-			x := val(i);
-			a.Push(x);
-			if a.Pop().(int) != x { t.Error("J") }
-			if a.Len() != j+1 { t.Errorf("K) wrong len %d (expected %d)", a.Len(), j+1) }
-		}
-	}
-	if a.Len() != m { t.Errorf("L) wrong len %d (expected %d)", a.Len(), m) }
-}
-
-
-func verify_slice(t *testing.T, x *array.Array, elt, i, j int) {
-	for k := i; k < j; k++ {
-		if x.At(k).(int) != elt {
-			t.Errorf("M) wrong [%d] element %d (expected %d)", k, x.At(k).(int), elt)
-		}
-	}
-
-	s := x.Slice(i, j);
-	for k, n := 0, j-i; k < n; k++ {
-		if s.At(k).(int) != elt {
-			t.Errorf("N) wrong [%d] element %d (expected %d)", k, x.At(k).(int), elt)
-		}
-	}
-}
-
-
-func verify_pattern(t *testing.T, x *array.Array, a, b, c int) {
-	n := a + b + c;
-	if x.Len() != n {
-		t.Errorf("O) wrong len %d (expected %d)", x.Len(), n)
-	}
-	verify_slice(t, x, 0, 0, a);
-	verify_slice(t, x, 1, a, a + b);
-	verify_slice(t, x, 0, a + b, n);
-}
-
-
-func make_array(elt, len int) *array.Array {
-	x := array.New(len);
-	for i := 0; i < len; i++ {
-		x.Set(i, elt);
-	}
-	return x;
-}
-
-
-func TestInsertArray(t *testing.T) {
-	// 1
-	a := make_array(0, 0);
-	b := make_array(1, 10);
-	a.InsertArray(0, b);
-	verify_pattern(t, a, 0, 10, 0);
-	// 2
-	a = make_array(0, 10);
-	b = make_array(1, 0);
-	a.InsertArray(5, b);
-	verify_pattern(t, a, 5, 0, 5);
-	// 3
-	a = make_array(0, 10);
-	b = make_array(1, 3);
-	a.InsertArray(3, b);
-	verify_pattern(t, a, 3, 3, 7);
-	// 4
-	a = make_array(0, 10);
-	b = make_array(1, 1000);
-	a.InsertArray(8, b);
-	verify_pattern(t, a, 8, 1000, 2);
-}
-
-func TestSorting(t *testing.T) {
-	const n = 100;
-	a := array.NewIntArray(n);
-	for i := n-1; i >= 0; i-- {
-		a.Set(i, n-1-i);
-	}
-	if sort.IsSorted(a) { t.Error("not sorted") }
-}
-
-
-func TestDo(t *testing.T) {
-	const n = 25;
-	const salt = 17;
-	a := array.NewIntArray(n);
-	for i := 0; i < n; i++ {
-		a.Set(i, salt * i);
-	}
-	count := 0;
-	a.Do(
-		func(e array.Element) {
-			i := e.(int);
-			if i != count*salt {
-				t.Error("value at", count, "should be", count*salt, "not", i)
-			}
-			count++;
-		}
-	);
-	if count != n {
-		t.Error("should visit", n, "values; did visit", count)
-	}
-}
diff --git a/src/lib/container/array/intarray.go b/src/lib/container/array/intarray.go
deleted file mode 100644
index 5f9549cfeb..0000000000
--- a/src/lib/container/array/intarray.go
+++ /dev/null
@@ -1,68 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//
-// *** DEPRECATED PACKAGE - USE package vector INSTEAD ***
-//
-
-package array
-
-import "array"
-
-type IntArray struct {
-	// TODO do not export field
-	array.Array;
-}
-
-
-func (p *IntArray) Init(len int) *IntArray {
-	p.Array.Init(len);
-	return p;
-}
-
-
-func NewIntArray(len int) *IntArray {
-	return new(IntArray).Init(len)
-}
-
-
-func (p *IntArray) At(i int) int {
-	return p.Array.At(i).(int)
-}
-
-
-func (p *IntArray) Set(i int, x int) {
-	p.Array.Set(i, x)
-}
-
-
-func (p *IntArray) Last() int {
-	return p.Array.Last().(int)
-}
-
-
-func (p *IntArray) Insert(i int, x int) {
-	p.Array.Insert(i, x)
-}
-
-
-func (p *IntArray) Delete(i int) int {
-	return p.Array.Delete(i).(int)
-}
-
-
-func (p *IntArray) Push(x int) {
-	p.Array.Push(x)
-}
-
-
-func (p *IntArray) Pop() int {
-	return p.Array.Pop().(int)
-}
-
-
-// SortInterface support
-func (p *IntArray) Less(i, j int) bool {
-	return p.At(i) < p.At(j)
-}
diff --git a/src/lib/json/generic.go b/src/lib/json/generic.go
index 08ae8dc29f..f42d411701 100644
--- a/src/lib/json/generic.go
+++ b/src/lib/json/generic.go
@@ -7,12 +7,12 @@
 package json
 
 import (
-	"array";
 	"fmt";
 	"math";
 	"json";
 	"strconv";
 	"strings";
+	"vector";
 )
 
 const (
@@ -68,7 +68,7 @@ func (j *_Number) String() string {
 	return fmt.Sprintf("%g", j.f);
 }
 
-type _Array struct { a *array.Array; _Null }
+type _Array struct { a *vector.Vector; _Null }
 func (j *_Array) Kind() int { return ArrayKind }
 func (j *_Array) Len() int { return j.a.Len() }
 func (j *_Array) Elem(i int) Json {
@@ -208,7 +208,7 @@ type _JsonBuilder struct {
 	ptr *Json;
 
 	// or to a[i] (can't set ptr = &a[i])
-	a *array.Array;
+	a *vector.Vector;
 	i int;
 
 	// or to m[k] (can't set ptr = &m[k])
@@ -265,7 +265,7 @@ func (b *_JsonBuilder) String(s string) {
 
 
 func (b *_JsonBuilder) Array() {
-	b.Put(&_Array{array.New(0), _Null{}})
+	b.Put(&_Array{vector.New(0), _Null{}})
 }
 
 func (b *_JsonBuilder) Map() {
diff --git a/src/lib/json/parse.go b/src/lib/json/parse.go
index 13d345e5ee..e9c4a31b51 100644
--- a/src/lib/json/parse.go
+++ b/src/lib/json/parse.go
@@ -8,7 +8,6 @@
 package json
 
 import (
-	"array";
 	"fmt";
 	"io";
 	"math";
diff --git a/src/lib/regexp/regexp.go b/src/lib/regexp/regexp.go
index bfaa999f47..86ef07c2e7 100644
--- a/src/lib/regexp/regexp.go
+++ b/src/lib/regexp/regexp.go
@@ -23,9 +23,9 @@
 package regexp
 
 import (
-	"array";
 	"os";
 	"utf8";
+	"vector";
 )
 
 var debug = false;
@@ -69,7 +69,7 @@ type Regexp struct {
 	expr	string;	// the original expression
 	ch	chan<- *Regexp;	// reply channel when we're done
 	error	*os.Error;	// compile- or run-time error; nil if OK
-	inst	*array.Array;
+	inst	*vector.Vector;
 	start	instr;
 	nbra	int;	// number of brackets in expression, for subexpressions
 }
@@ -142,8 +142,8 @@ type _CharClass struct {
 	common;
 	char	int;
 	negate	bool;	// is character class negated? ([^a-z])
-	// array of int, stored pairwise: [a-z] is (a,z); x is (x,x):
-	ranges	*array.IntArray;
+	// vector of int, stored pairwise: [a-z] is (a,z); x is (x,x):
+	ranges	*vector.IntVector;
 }
 
 func (cclass *_CharClass) kind() int { return _CHARCLASS }
@@ -183,7 +183,7 @@ func (cclass *_CharClass) matches(c int) bool {
 
 func newCharClass() *_CharClass {
 	c := new(_CharClass);
-	c.ranges = array.NewIntArray(0);
+	c.ranges = vector.NewIntVector(0);
 	return c;
 }
 
@@ -576,7 +576,7 @@ func (re *Regexp) doParse() {
 func compiler(str string, ch chan *Regexp) {
 	re := new(Regexp);
 	re.expr = str;
-	re.inst = array.New(0);
+	re.inst = vector.New(0);
 	re.ch = ch;
 	re.doParse();
 	ch <- re;
