commit db3a21d7c68bad988b5238ef48ae491c782fb105
Author: Kai Backman <kaib@golang.org>
Date:   Fri Mar 13 15:03:07 2009 -0700

    5a 5c 5l from inferno distribution
    
    R=rsc
    APPROVED=rsc
    DELTA=19042  (19042 added, 0 deleted, 0 changed)
    OCL=26268
    CL=26270
---
 src/cmd/5a/a.h     |  212 ++++++
 src/cmd/5a/a.y     |  703 ++++++++++++++++++++
 src/cmd/5a/lex.c   |  719 +++++++++++++++++++++
 src/cmd/5c/5.out.h |  227 +++++++
 src/cmd/5c/cgen.c  | 1186 ++++++++++++++++++++++++++++++++++
 src/cmd/5c/gc.h    |  379 +++++++++++
 src/cmd/5c/list.c  |  334 ++++++++++
 src/cmd/5c/mkenam  |   45 ++
 src/cmd/5c/mul.c   |  639 ++++++++++++++++++
 src/cmd/5c/peep.c  | 1471 +++++++++++++++++++++++++++++++++++++++++
 src/cmd/5c/reg.c   | 1187 ++++++++++++++++++++++++++++++++++
 src/cmd/5c/sgen.c  |  643 ++++++++++++++++++
 src/cmd/5c/swt.c   |  787 ++++++++++++++++++++++
 src/cmd/5c/txt.c   | 1280 ++++++++++++++++++++++++++++++++++++
 src/cmd/5l/asm.c   | 1831 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/cmd/5l/l.h     |  474 ++++++++++++++
 src/cmd/5l/list.c  |  390 +++++++++++
 src/cmd/5l/noop.c  |  924 ++++++++++++++++++++++++++
 src/cmd/5l/obj.c   | 1588 +++++++++++++++++++++++++++++++++++++++++++++
 src/cmd/5l/optab.c |  283 ++++++++
 src/cmd/5l/pass.c  |  972 ++++++++++++++++++++++++++++
 src/cmd/5l/span.c  | 1292 ++++++++++++++++++++++++++++++++++++
 src/cmd/5l/thumb.c | 1667 +++++++++++++++++++++++++++++++++++++++++++++++
 23 files changed, 19233 insertions(+)

diff --git a/src/cmd/5a/a.h b/src/cmd/5a/a.h
new file mode 100644
index 0000000000..c93b731219
--- /dev/null
+++ b/src/cmd/5a/a.h
@@ -0,0 +1,212 @@
+// Inferno utils/5a/a.h
+// http://code.google.com/p/inferno-os/source/browse/utils/5a/a.h
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#include <lib9.h>
+#include <bio.h>
+#include "../5c/5.out.h"
+
+#ifndef	EXTERN
+#define	EXTERN	extern
+#endif
+
+typedef	struct	Sym	Sym;
+typedef	struct	Gen	Gen;
+typedef	struct	Io	Io;
+typedef	struct	Hist	Hist;
+
+#define	MAXALIGN	7
+#define	FPCHIP		1
+#define	NSYMB		8192
+#define	BUFSIZ		8192
+#define	HISTSZ		20
+#define	NINCLUDE	10
+#define	NHUNK		10000
+#define	EOF		(-1)
+#define	IGN		(-2)
+#define	GETC()		((--fi.c < 0)? filbuf(): *fi.p++ & 0xff)
+#define	NHASH		503
+#define	STRINGSZ	200
+#define	NMACRO		10
+
+struct	Sym
+{
+	Sym*	link;
+	char*	macro;
+	long	value;
+	ushort	type;
+	char	*name;
+	char	sym;
+};
+#define	S	((Sym*)0)
+
+EXTERN	struct
+{
+	char*	p;
+	int	c;
+} fi;
+
+struct	Io
+{
+	Io*	link;
+	char	b[BUFSIZ];
+	char*	p;
+	short	c;
+	short	f;
+};
+#define	I	((Io*)0)
+
+EXTERN	struct
+{
+	Sym*	sym;
+	short	type;
+} h[NSYM];
+
+struct	Gen
+{
+	Sym*	sym;
+	long	offset;
+	short	type;
+	short	reg;
+	short	name;
+	double	dval;
+	char	sval[8];
+};
+
+struct	Hist
+{
+	Hist*	link;
+	char*	name;
+	long	line;
+	long	offset;
+};
+#define	H	((Hist*)0)
+
+enum
+{
+	CLAST,
+	CMACARG,
+	CMACRO,
+	CPREPROC,
+
+	Always	= 14,
+};
+
+EXTERN	char	debug[256];
+EXTERN	Sym*	hash[NHASH];
+EXTERN	char*	Dlist[30];
+EXTERN	int	nDlist;
+EXTERN	Hist*	ehist;
+EXTERN	int	newflag;
+EXTERN	Hist*	hist;
+EXTERN	char*	hunk;
+EXTERN	char*	include[NINCLUDE];
+EXTERN	Io*	iofree;
+EXTERN	Io*	ionext;
+EXTERN	Io*	iostack;
+EXTERN	long	lineno;
+EXTERN	int	nerrors;
+EXTERN	long	nhunk;
+EXTERN	int	ninclude;
+EXTERN	Gen	nullgen;
+EXTERN	char*	outfile;
+EXTERN	int	pass;
+EXTERN	char*	pathname;
+EXTERN	long	pc;
+EXTERN	int	peekc;
+EXTERN	int	sym;
+EXTERN	char	symb[NSYMB];
+EXTERN	int	thechar;
+EXTERN	char*	thestring;
+EXTERN	long	thunk;
+EXTERN	Biobuf	obuf;
+
+void*	alloc(long);
+void*	allocn(void*, long, long);
+void	errorexit(void);
+void	pushio(void);
+void	newio(void);
+void	newfile(char*, int);
+Sym*	slookup(char*);
+Sym*	lookup(void);
+void	syminit(Sym*);
+long	yylex(void);
+int	getc(void);
+int	getnsc(void);
+void	unget(int);
+int	escchar(int);
+void	cinit(void);
+void	pinit(char*);
+void	cclean(void);
+int	isreg(Gen*);
+void	outcode(int, int, Gen*, int, Gen*);
+void	zname(char*, int, int);
+void	zaddr(Gen*, int);
+void	ieeedtod(Ieee*, double);
+int	filbuf(void);
+Sym*	getsym(void);
+void	domacro(void);
+void	macund(void);
+void	macdef(void);
+void	macexpand(Sym*, char*);
+void	macinc(void);
+void	maclin(void);
+void	macprag(void);
+void	macif(int);
+void	macend(void);
+void	outhist(void);
+void	dodefine(char*);
+void	prfile(long);
+void	linehist(char*, int);
+void	gethunk(void);
+void	yyerror(char*, ...);
+int	yyparse(void);
+void	setinclude(char*);
+int	assemble(char*);
+
+/*
+ *	system-dependent stuff from ../cc/compat.c
+ */
+
+enum				/* keep in synch with ../cc/cc.h */
+{
+	Plan9	= 1<<0,
+	Unix	= 1<<1,
+	Windows	= 1<<2,
+};
+int	mywait(int*);
+int	mycreat(char*, int);
+int	systemtype(int);
+int	pathchar(void);
+char*	mygetwd(char*, int);
+int	myexec(char*, char*[]);
+int	mydup(int, int);
+int	myfork(void);
+int	mypipe(int*);
+void*	mysbrk(ulong);
diff --git a/src/cmd/5a/a.y b/src/cmd/5a/a.y
new file mode 100644
index 0000000000..b41f9b65db
--- /dev/null
+++ b/src/cmd/5a/a.y
@@ -0,0 +1,703 @@
+// Inferno utils/5a/a.y
+// http://code.google.com/p/inferno-os/source/browse/utils/5a/a.y
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+%{
+#include "a.h"
+%}
+%union
+{
+	Sym	*sym;
+	long	lval;
+	double	dval;
+	char	sval[8];
+	Gen	gen;
+}
+%left	'|'
+%left	'^'
+%left	'&'
+%left	'<' '>'
+%left	'+' '-'
+%left	'*' '/' '%'
+%token	<lval>	LTYPE1 LTYPE2 LTYPE3 LTYPE4 LTYPE5
+%token	<lval>	LTYPE6 LTYPE7 LTYPE8 LTYPE9 LTYPEA
+%token	<lval>	LTYPEB LTYPEC LTYPED LTYPEE LTYPEF
+%token	<lval>	LTYPEG LTYPEH LTYPEI LTYPEJ LTYPEK
+%token	<lval>	LTYPEL LTYPEM LTYPEN LTYPEBX
+%token	<lval>	LCONST LSP LSB LFP LPC
+%token	<lval>	LTYPEX LR LREG LF LFREG LC LCREG LPSR LFCR
+%token	<lval>	LCOND LS LAT
+%token	<dval>	LFCONST
+%token	<sval>	LSCONST
+%token	<sym>	LNAME LLAB LVAR
+%type	<lval>	con expr oexpr pointer offset sreg spreg creg
+%type	<lval>	rcon cond reglist
+%type	<gen>	gen rel reg regreg freg shift fcon frcon
+%type	<gen>	imm ximm name oreg ireg nireg ioreg imsr
+%%
+prog:
+|	prog line
+
+line:
+	LLAB ':'
+	{
+		if($1->value != pc)
+			yyerror("redeclaration of %s", $1->name);
+		$1->value = pc;
+	}
+	line
+|	LNAME ':'
+	{
+		$1->type = LLAB;
+		$1->value = pc;
+	}
+	line
+|	LNAME '=' expr ';'
+	{
+		$1->type = LVAR;
+		$1->value = $3;
+	}
+|	LVAR '=' expr ';'
+	{
+		if($1->value != $3)
+			yyerror("redeclaration of %s", $1->name);
+		$1->value = $3;
+	}
+|	';'
+|	inst ';'
+|	error ';'
+
+inst:
+/*
+ * ADD
+ */
+	LTYPE1 cond imsr ',' spreg ',' reg
+	{
+		outcode($1, $2, &$3, $5, &$7);
+	}
+|	LTYPE1 cond imsr ',' spreg ','
+	{
+		outcode($1, $2, &$3, $5, &nullgen);
+	}
+|	LTYPE1 cond imsr ',' reg
+	{
+		outcode($1, $2, &$3, NREG, &$5);
+	}
+/*
+ * MVN
+ */
+|	LTYPE2 cond imsr ',' reg
+	{
+		outcode($1, $2, &$3, NREG, &$5);
+	}
+/*
+ * MOVW
+ */
+|	LTYPE3 cond gen ',' gen
+	{
+		outcode($1, $2, &$3, NREG, &$5);
+	}
+/*
+ * B/BL
+ */
+|	LTYPE4 cond comma rel
+	{
+		outcode($1, $2, &nullgen, NREG, &$4);
+	}
+|	LTYPE4 cond comma nireg
+	{
+		outcode($1, $2, &nullgen, NREG, &$4);
+	}
+/*
+ * BX
+ */
+|	LTYPEBX comma ireg
+	{
+		outcode($1, Always, &nullgen, NREG, &$3);
+	}
+/*
+ * BEQ
+ */
+|	LTYPE5 comma rel
+	{
+		outcode($1, Always, &nullgen, NREG, &$3);
+	}
+/*
+ * SWI
+ */
+|	LTYPE6 cond comma gen
+	{
+		outcode($1, $2, &nullgen, NREG, &$4);
+	}
+/*
+ * CMP
+ */
+|	LTYPE7 cond imsr ',' spreg comma
+	{
+		outcode($1, $2, &$3, $5, &nullgen);
+	}
+/*
+ * MOVM
+ */
+|	LTYPE8 cond ioreg ',' '[' reglist ']'
+	{
+		Gen g;
+
+		g = nullgen;
+		g.type = D_CONST;
+		g.offset = $6;
+		outcode($1, $2, &$3, NREG, &g);
+	}
+|	LTYPE8 cond '[' reglist ']' ',' ioreg
+	{
+		Gen g;
+
+		g = nullgen;
+		g.type = D_CONST;
+		g.offset = $4;
+		outcode($1, $2, &g, NREG, &$7);
+	}
+/*
+ * SWAP
+ */
+|	LTYPE9 cond reg ',' ireg ',' reg
+	{
+		outcode($1, $2, &$5, $3.reg, &$7);
+	}
+|	LTYPE9 cond reg ',' ireg comma
+	{
+		outcode($1, $2, &$5, $3.reg, &$3);
+	}
+|	LTYPE9 cond comma ireg ',' reg
+	{
+		outcode($1, $2, &$4, $6.reg, &$6);
+	}
+/*
+ * RET
+ */
+|	LTYPEA cond comma
+	{
+		outcode($1, $2, &nullgen, NREG, &nullgen);
+	}
+/*
+ * TEXT/GLOBL
+ */
+|	LTYPEB name ',' imm
+	{
+		outcode($1, Always, &$2, NREG, &$4);
+	}
+|	LTYPEB name ',' con ',' imm
+	{
+		outcode($1, Always, &$2, $4, &$6);
+	}
+/*
+ * DATA
+ */
+|	LTYPEC name '/' con ',' ximm
+	{
+		outcode($1, Always, &$2, $4, &$6);
+	}
+/*
+ * CASE
+ */
+|	LTYPED cond reg comma
+	{
+		outcode($1, $2, &$3, NREG, &nullgen);
+	}
+/*
+ * word
+ */
+|	LTYPEH comma ximm
+	{
+		outcode($1, Always, &nullgen, NREG, &$3);
+	}
+/*
+ * floating-point coprocessor
+ */
+|	LTYPEI cond freg ',' freg
+	{
+		outcode($1, $2, &$3, NREG, &$5);
+	}
+|	LTYPEK cond frcon ',' freg
+	{
+		outcode($1, $2, &$3, NREG, &$5);
+	}
+|	LTYPEK cond frcon ',' LFREG ',' freg
+	{
+		outcode($1, $2, &$3, $5, &$7);
+	}
+|	LTYPEL cond freg ',' freg comma
+	{
+		outcode($1, $2, &$3, $5.reg, &nullgen);
+	}
+/*
+ * MCR MRC
+ */
+|	LTYPEJ cond con ',' expr ',' spreg ',' creg ',' creg oexpr
+	{
+		Gen g;
+
+		g = nullgen;
+		g.type = D_CONST;
+		g.offset =
+			(0xe << 24) |		/* opcode */
+			($1 << 20) |		/* MCR/MRC */
+			($2 << 28) |		/* scond */
+			(($3 & 15) << 8) |	/* coprocessor number */
+			(($5 & 7) << 21) |	/* coprocessor operation */
+			(($7 & 15) << 12) |	/* arm register */
+			(($9 & 15) << 16) |	/* Crn */
+			(($11 & 15) << 0) |	/* Crm */
+			(($12 & 7) << 5) |	/* coprocessor information */
+			(1<<4);			/* must be set */
+		outcode(AWORD, Always, &nullgen, NREG, &g);
+	}
+/*
+ * MULL hi,lo,r1,r2
+ */
+|	LTYPEM cond reg ',' reg ',' regreg
+	{
+		outcode($1, $2, &$3, $5.reg, &$7);
+	}
+/*
+ * MULA hi,lo,r1,r2
+ */
+|	LTYPEN cond reg ',' reg ',' reg ',' spreg 
+	{
+		$7.type = D_REGREG;
+		$7.offset = $9;
+		outcode($1, $2, &$3, $5.reg, &$7);
+	}
+/*
+ * END
+ */
+|	LTYPEE comma
+	{
+		outcode($1, Always, &nullgen, NREG, &nullgen);
+	}
+
+cond:
+	{
+		$$ = Always;
+	}
+|	cond LCOND
+	{
+		$$ = ($1 & ~C_SCOND) | $2;
+	}
+|	cond LS
+	{
+		$$ = $1 | $2;
+	}
+
+comma:
+|	',' comma
+
+rel:
+	con '(' LPC ')'
+	{
+		$$ = nullgen;
+		$$.type = D_BRANCH;
+		$$.offset = $1 + pc;
+	}
+|	LNAME offset
+	{
+		$$ = nullgen;
+		if(pass == 2)
+			yyerror("undefined label: %s", $1->name);
+		$$.type = D_BRANCH;
+		$$.sym = $1;
+		$$.offset = $2;
+	}
+|	LLAB offset
+	{
+		$$ = nullgen;
+		$$.type = D_BRANCH;
+		$$.sym = $1;
+		$$.offset = $1->value + $2;
+	}
+
+ximm:	'$' con
+	{
+		$$ = nullgen;
+		$$.type = D_CONST;
+		$$.offset = $2;
+	}
+|	'$' oreg
+	{
+		$$ = $2;
+		$$.type = D_CONST;
+	}
+|	'$' '*' '$' oreg
+	{
+		$$ = $4;
+		$$.type = D_OCONST;
+	}
+|	'$' LSCONST
+	{
+		$$ = nullgen;
+		$$.type = D_SCONST;
+		memcpy($$.sval, $2, sizeof($$.sval));
+	}
+|	fcon
+
+fcon:
+	'$' LFCONST
+	{
+		$$ = nullgen;
+		$$.type = D_FCONST;
+		$$.dval = $2;
+	}
+|	'$' '-' LFCONST
+	{
+		$$ = nullgen;
+		$$.type = D_FCONST;
+		$$.dval = -$3;
+	}
+
+reglist:
+	spreg
+	{
+		$$ = 1 << $1;
+	}
+|	spreg '-' spreg
+	{
+		int i;
+		$$=0;
+		for(i=$1; i<=$3; i++)
+			$$ |= 1<<i;
+		for(i=$3; i<=$1; i++)
+			$$ |= 1<<i;
+	}
+|	spreg comma reglist
+	{
+		$$ = (1<<$1) | $3;
+	}
+
+gen:
+	reg
+|	ximm
+|	shift
+|	shift '(' spreg ')'
+	{
+		$$ = $1;
+		$$.reg = $3;
+	}
+|	LPSR
+	{
+		$$ = nullgen;
+		$$.type = D_PSR;
+		$$.reg = $1;
+	}
+|	LFCR
+	{
+		$$ = nullgen;
+		$$.type = D_FPCR;
+		$$.reg = $1;
+	}
+|	con
+	{
+		$$ = nullgen;
+		$$.type = D_OREG;
+		$$.offset = $1;
+	}
+|	oreg
+|	freg
+
+nireg:
+	ireg
+|	name
+	{
+		$$ = $1;
+		if($1.name != D_EXTERN && $1.name != D_STATIC) {
+		}
+	}
+
+ireg:
+	'(' spreg ')'
+	{
+		$$ = nullgen;
+		$$.type = D_OREG;
+		$$.reg = $2;
+		$$.offset = 0;
+	}
+
+ioreg:
+	ireg
+|	con '(' sreg ')'
+	{
+		$$ = nullgen;
+		$$.type = D_OREG;
+		$$.reg = $3;
+		$$.offset = $1;
+	}
+
+oreg:
+	name
+|	name '(' sreg ')'
+	{
+		$$ = $1;
+		$$.type = D_OREG;
+		$$.reg = $3;
+	}
+|	ioreg
+
+imsr:
+	reg
+|	imm
+|	shift
+
+imm:	'$' con
+	{
+		$$ = nullgen;
+		$$.type = D_CONST;
+		$$.offset = $2;
+	}
+
+reg:
+	spreg
+	{
+		$$ = nullgen;
+		$$.type = D_REG;
+		$$.reg = $1;
+	}
+
+regreg:
+	'(' spreg ',' spreg ')'
+	{
+		$$ = nullgen;
+		$$.type = D_REGREG;
+		$$.reg = $2;
+		$$.offset = $4;
+	}
+
+shift:
+	spreg '<' '<' rcon
+	{
+		$$ = nullgen;
+		$$.type = D_SHIFT;
+		$$.offset = $1 | $4 | (0 << 5);
+	}
+|	spreg '>' '>' rcon
+	{
+		$$ = nullgen;
+		$$.type = D_SHIFT;
+		$$.offset = $1 | $4 | (1 << 5);
+	}
+|	spreg '-' '>' rcon
+	{
+		$$ = nullgen;
+		$$.type = D_SHIFT;
+		$$.offset = $1 | $4 | (2 << 5);
+	}
+|	spreg LAT '>' rcon
+	{
+		$$ = nullgen;
+		$$.type = D_SHIFT;
+		$$.offset = $1 | $4 | (3 << 5);
+	}
+
+rcon:
+	spreg
+	{
+		if($$ < 0 || $$ >= 16)
+			print("register value out of range\n");
+		$$ = (($1&15) << 8) | (1 << 4);
+	}
+|	con
+	{
+		if($$ < 0 || $$ >= 32)
+			print("shift value out of range\n");
+		$$ = ($1&31) << 7;
+	}
+
+sreg:
+	LREG
+|	LPC
+	{
+		$$ = REGPC;
+	}
+|	LR '(' expr ')'
+	{
+		if($3 < 0 || $3 >= NREG)
+			print("register value out of range\n");
+		$$ = $3;
+	}
+
+spreg:
+	sreg
+|	LSP
+	{
+		$$ = REGSP;
+	}
+
+creg:
+	LCREG
+|	LC '(' expr ')'
+	{
+		if($3 < 0 || $3 >= NREG)
+			print("register value out of range\n");
+		$$ = $3;
+	}
+
+frcon:
+	freg
+|	fcon
+
+freg:
+	LFREG
+	{
+		$$ = nullgen;
+		$$.type = D_FREG;
+		$$.reg = $1;
+	}
+|	LF '(' con ')'
+	{
+		$$ = nullgen;
+		$$.type = D_FREG;
+		$$.reg = $3;
+	}
+
+name:
+	con '(' pointer ')'
+	{
+		$$ = nullgen;
+		$$.type = D_OREG;
+		$$.name = $3;
+		$$.sym = S;
+		$$.offset = $1;
+	}
+|	LNAME offset '(' pointer ')'
+	{
+		$$ = nullgen;
+		$$.type = D_OREG;
+		$$.name = $4;
+		$$.sym = $1;
+		$$.offset = $2;
+	}
+|	LNAME '<' '>' offset '(' LSB ')'
+	{
+		$$ = nullgen;
+		$$.type = D_OREG;
+		$$.name = D_STATIC;
+		$$.sym = $1;
+		$$.offset = $4;
+	}
+
+offset:
+	{
+		$$ = 0;
+	}
+|	'+' con
+	{
+		$$ = $2;
+	}
+|	'-' con
+	{
+		$$ = -$2;
+	}
+
+pointer:
+	LSB
+|	LSP
+|	LFP
+
+con:
+	LCONST
+|	LVAR
+	{
+		$$ = $1->value;
+	}
+|	'-' con
+	{
+		$$ = -$2;
+	}
+|	'+' con
+	{
+		$$ = $2;
+	}
+|	'~' con
+	{
+		$$ = ~$2;
+	}
+|	'(' expr ')'
+	{
+		$$ = $2;
+	}
+
+oexpr:
+	{
+		$$ = 0;
+	}
+|	',' expr
+	{
+		$$ = $2;
+	}
+
+expr:
+	con
+|	expr '+' expr
+	{
+		$$ = $1 + $3;
+	}
+|	expr '-' expr
+	{
+		$$ = $1 - $3;
+	}
+|	expr '*' expr
+	{
+		$$ = $1 * $3;
+	}
+|	expr '/' expr
+	{
+		$$ = $1 / $3;
+	}
+|	expr '%' expr
+	{
+		$$ = $1 % $3;
+	}
+|	expr '<' '<' expr
+	{
+		$$ = $1 << $4;
+	}
+|	expr '>' '>' expr
+	{
+		$$ = $1 >> $4;
+	}
+|	expr '&' expr
+	{
+		$$ = $1 & $3;
+	}
+|	expr '^' expr
+	{
+		$$ = $1 ^ $3;
+	}
+|	expr '|' expr
+	{
+		$$ = $1 | $3;
+	}
diff --git a/src/cmd/5a/lex.c b/src/cmd/5a/lex.c
new file mode 100644
index 0000000000..82f2228bf4
--- /dev/null
+++ b/src/cmd/5a/lex.c
@@ -0,0 +1,719 @@
+// Inferno utils/5a/lex.c
+// http://code.google.com/p/inferno-os/source/browse/utils/5a/lex.c
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#define	EXTERN
+#include "a.h"
+#include "y.tab.h"
+#include <ctype.h>
+
+void
+main(int argc, char *argv[])
+{
+	char *p;
+	int nout, nproc, status, i, c;
+
+	thechar = '5';
+	thestring = "arm";
+	memset(debug, 0, sizeof(debug));
+	cinit();
+	outfile = 0;
+	include[ninclude++] = ".";
+	ARGBEGIN {
+	default:
+		c = ARGC();
+		if(c >= 0 || c < sizeof(debug))
+			debug[c] = 1;
+		break;
+
+	case 'o':
+		outfile = ARGF();
+		break;
+
+	case 'D':
+		p = ARGF();
+		if(p)
+			Dlist[nDlist++] = p;
+		break;
+
+	case 'I':
+		p = ARGF();
+		setinclude(p);
+		break;
+	case 't':
+		thechar = 't';
+		thestring = "thumb";
+		break;
+	} ARGEND
+	if(*argv == 0) {
+		print("usage: %ca [-options] file.s\n", thechar);
+		errorexit();
+	}
+	if(argc > 1 && systemtype(Windows)){
+		print("can't assemble multiple files on windows\n");
+		errorexit();
+	}
+	if(argc > 1 && !systemtype(Windows)) {
+		nproc = 1;
+		if(p = getenv("NPROC"))
+			nproc = atol(p);	/* */
+		c = 0;
+		nout = 0;
+		for(;;) {
+			while(nout < nproc && argc > 0) {
+				i = myfork();
+				if(i < 0) {
+					i = mywait(&status);
+					if(i < 0)
+						errorexit();
+					if(status)
+						c++;
+					nout--;
+					continue;
+				}
+				if(i == 0) {
+					print("%s:\n", *argv);
+					if(assemble(*argv))
+						errorexit();
+					exits(0);
+				}
+				nout++;
+				argc--;
+				argv++;
+			}
+			i = mywait(&status);
+			if(i < 0) {
+				if(c)
+					errorexit();
+				exits(0);
+			}
+			if(status)
+				c++;
+			nout--;
+		}
+	}
+	if(assemble(argv[0]))
+		errorexit();
+	exits(0);
+}
+
+int
+assemble(char *file)
+{
+	char ofile[100], incfile[20], *p;
+	int i, of;
+
+	strcpy(ofile, file);
+	p = utfrrune(ofile, pathchar());
+	if(p) {
+		include[0] = ofile;
+		*p++ = 0;
+	} else
+		p = ofile;
+	if(outfile == 0) {
+		outfile = p;
+		if(outfile){
+			p = utfrrune(outfile, '.');
+			if(p)
+				if(p[1] == 's' && p[2] == 0)
+					p[0] = 0;
+			p = utfrune(outfile, 0);
+			p[0] = '.';
+			p[1] = thechar;
+			p[2] = 0;
+		} else
+			outfile = "/dev/null";
+	}
+	p = getenv("INCLUDE");
+	if(p) {
+		setinclude(p);
+	} else {
+		if(systemtype(Plan9)) {
+			sprint(incfile,"/%s/include", thestring);
+			setinclude(strdup(incfile));
+		}
+	}
+
+	of = mycreat(outfile, 0664);
+	if(of < 0) {
+		yyerror("%ca: cannot create %s", thechar, outfile);
+		errorexit();
+	}
+	Binit(&obuf, of, OWRITE);
+
+	pass = 1;
+	pinit(file);
+	for(i=0; i<nDlist; i++)
+		dodefine(Dlist[i]);
+	yyparse();
+	if(nerrors) {
+		cclean();
+		return nerrors;
+	}
+
+	pass = 2;
+	outhist();
+	pinit(file);
+	for(i=0; i<nDlist; i++)
+		dodefine(Dlist[i]);
+	yyparse();
+	cclean();
+	return nerrors;
+}
+
+struct
+{
+	char	*name;
+	ushort	type;
+	ushort	value;
+} itab[] =
+{
+	"SP",		LSP,	D_AUTO,
+	"SB",		LSB,	D_EXTERN,
+	"FP",		LFP,	D_PARAM,
+	"PC",		LPC,	D_BRANCH,
+
+	"R",		LR,	0,
+	"R0",		LREG,	0,
+	"R1",		LREG,	1,
+	"R2",		LREG,	2,
+	"R3",		LREG,	3,
+	"R4",		LREG,	4,
+	"R5",		LREG,	5,
+	"R6",		LREG,	6,
+	"R7",		LREG,	7,
+	"R8",		LREG,	8,
+	"R9",		LREG,	9,
+	"R10",		LREG,	10,
+	"R11",		LREG,	11,
+	"R12",		LREG,	12,
+	"R13",		LREG,	13,
+	"R14",		LREG,	14,
+	"R15",		LREG,	15,
+
+	"F",		LF,	0,
+
+	"F0",		LFREG,	0,
+	"F1",		LFREG,	1,
+	"F2",		LFREG,	2,
+	"F3",		LFREG,	3,
+	"F4",		LFREG,	4,
+	"F5",		LFREG,	5,
+	"F6",		LFREG,	6,
+	"F7",		LFREG,	7,
+	"F8",		LFREG,	8,
+	"F9",		LFREG,	9,
+	"F10",		LFREG,	10,
+	"F11",		LFREG,	11,
+	"F12",		LFREG,	12,
+	"F13",		LFREG,	13,
+	"F14",		LFREG,	14,
+	"F15",		LFREG,	15,
+
+	"C",		LC,	0,
+
+	"C0",		LCREG,	0,
+	"C1",		LCREG,	1,
+	"C2",		LCREG,	2,
+	"C3",		LCREG,	3,
+	"C4",		LCREG,	4,
+	"C5",		LCREG,	5,
+	"C6",		LCREG,	6,
+	"C7",		LCREG,	7,
+	"C8",		LCREG,	8,
+	"C9",		LCREG,	9,
+	"C10",		LCREG,	10,
+	"C11",		LCREG,	11,
+	"C12",		LCREG,	12,
+	"C13",		LCREG,	13,
+	"C14",		LCREG,	14,
+	"C15",		LCREG,	15,
+
+	"CPSR",		LPSR,	0,
+	"SPSR",		LPSR,	1,
+
+	"FPSR",		LFCR,	0,
+	"FPCR",		LFCR,	1,
+
+	".EQ",		LCOND,	0,
+	".NE",		LCOND,	1,
+	".CS",		LCOND,	2,
+	".HS",		LCOND,	2,
+	".CC",		LCOND,	3,
+	".LO",		LCOND,	3,
+	".MI",		LCOND,	4,
+	".PL",		LCOND,	5,
+	".VS",		LCOND,	6,
+	".VC",		LCOND,	7,
+	".HI",		LCOND,	8,
+	".LS",		LCOND,	9,
+	".GE",		LCOND,	10,
+	".LT",		LCOND,	11,
+	".GT",		LCOND,	12,
+	".LE",		LCOND,	13,
+	".AL",		LCOND,	Always,
+
+	".U",		LS,	C_UBIT,
+	".S",		LS,	C_SBIT,
+	".W",		LS,	C_WBIT,
+	".P",		LS,	C_PBIT,
+	".PW",		LS,	C_WBIT|C_PBIT,
+	".WP",		LS,	C_WBIT|C_PBIT,
+
+	".F",		LS,	C_FBIT,
+
+	".IBW",		LS,	C_WBIT|C_PBIT|C_UBIT,
+	".IAW",		LS,	C_WBIT|C_UBIT,
+	".DBW",		LS,	C_WBIT|C_PBIT,
+	".DAW",		LS,	C_WBIT,
+	".IB",		LS,	C_PBIT|C_UBIT,
+	".IA",		LS,	C_UBIT,
+	".DB",		LS,	C_PBIT,
+	".DA",		LS,	0,
+
+	"@",		LAT,	0,
+
+	"AND",		LTYPE1,	AAND,
+	"EOR",		LTYPE1,	AEOR,
+	"SUB",		LTYPE1,	ASUB,
+	"RSB",		LTYPE1,	ARSB,
+	"ADD",		LTYPE1,	AADD,
+	"ADC",		LTYPE1,	AADC,
+	"SBC",		LTYPE1,	ASBC,
+	"RSC",		LTYPE1,	ARSC,
+	"ORR",		LTYPE1,	AORR,
+	"BIC",		LTYPE1,	ABIC,
+
+	"SLL",		LTYPE1,	ASLL,
+	"SRL",		LTYPE1,	ASRL,
+	"SRA",		LTYPE1,	ASRA,
+
+	"MUL",		LTYPE1, AMUL,
+	"MULA",		LTYPEN, AMULA,
+	"DIV",		LTYPE1,	ADIV,
+	"MOD",		LTYPE1,	AMOD,
+
+	"MULL",		LTYPEM, AMULL,
+	"MULAL",	LTYPEM, AMULAL,
+	"MULLU",	LTYPEM, AMULLU,
+	"MULALU",	LTYPEM, AMULALU,
+
+	"MVN",		LTYPE2, AMVN,	/* op2 ignored */
+
+	"MOVB",		LTYPE3, AMOVB,
+	"MOVBU",	LTYPE3, AMOVBU,
+	"MOVH",		LTYPE3, AMOVH,
+	"MOVHU",	LTYPE3, AMOVHU,
+	"MOVW",		LTYPE3, AMOVW,
+
+	"MOVD",		LTYPE3, AMOVD,
+	"MOVDF",		LTYPE3, AMOVDF,
+	"MOVDW",	LTYPE3, AMOVDW,
+	"MOVF",		LTYPE3, AMOVF,
+	"MOVFD",		LTYPE3, AMOVFD,
+	"MOVFW",		LTYPE3, AMOVFW,
+	"MOVWD",	LTYPE3, AMOVWD,
+	"MOVWF",		LTYPE3, AMOVWF,
+
+/*
+	"ABSF",		LTYPEI, AABSF,
+	"ABSD",		LTYPEI, AABSD,
+	"NEGF",		LTYPEI, ANEGF,
+	"NEGD",		LTYPEI, ANEGD,
+	"SQTF",		LTYPEI,	ASQTF,
+	"SQTD",		LTYPEI,	ASQTD,
+	"RNDF",		LTYPEI,	ARNDF,
+	"RNDD",		LTYPEI,	ARNDD,
+	"URDF",		LTYPEI,	AURDF,
+	"URDD",		LTYPEI,	AURDD,
+	"NRMF",		LTYPEI,	ANRMF,
+	"NRMD",		LTYPEI,	ANRMD,
+*/
+
+	"CMPF",		LTYPEL, ACMPF,
+	"CMPD",		LTYPEL, ACMPD,
+	"ADDF",		LTYPEK,	AADDF,
+	"ADDD",		LTYPEK,	AADDD,
+	"SUBF",		LTYPEK,	ASUBF,
+	"SUBD",		LTYPEK,	ASUBD,
+	"MULF",		LTYPEK,	AMULF,
+	"MULD",		LTYPEK,	AMULD,
+	"DIVF",		LTYPEK,	ADIVF,
+	"DIVD",		LTYPEK,	ADIVD,
+
+	"B",		LTYPE4, AB,
+	"BL",		LTYPE4, ABL,
+	"BX",		LTYPEBX,	ABX,
+
+	"BEQ",		LTYPE5,	ABEQ,
+	"BNE",		LTYPE5,	ABNE,
+	"BCS",		LTYPE5,	ABCS,
+	"BHS",		LTYPE5,	ABHS,
+	"BCC",		LTYPE5,	ABCC,
+	"BLO",		LTYPE5,	ABLO,
+	"BMI",		LTYPE5,	ABMI,
+	"BPL",		LTYPE5,	ABPL,
+	"BVS",		LTYPE5,	ABVS,
+	"BVC",		LTYPE5,	ABVC,
+	"BHI",		LTYPE5,	ABHI,
+	"BLS",		LTYPE5,	ABLS,
+	"BGE",		LTYPE5,	ABGE,
+	"BLT",		LTYPE5,	ABLT,
+	"BGT",		LTYPE5,	ABGT,
+	"BLE",		LTYPE5,	ABLE,
+	"BCASE",	LTYPE5,	ABCASE,
+
+	"SWI",		LTYPE6, ASWI,
+
+	"CMP",		LTYPE7,	ACMP,
+	"TST",		LTYPE7,	ATST,
+	"TEQ",		LTYPE7,	ATEQ,
+	"CMN",		LTYPE7,	ACMN,
+
+	"MOVM",		LTYPE8, AMOVM,
+
+	"SWPBU",	LTYPE9, ASWPBU,
+	"SWPW",		LTYPE9, ASWPW,
+
+	"RET",		LTYPEA, ARET,
+	"RFE",		LTYPEA, ARFE,
+
+	"TEXT",		LTYPEB, ATEXT,
+	"GLOBL",	LTYPEB, AGLOBL,
+	"DATA",		LTYPEC, ADATA,
+	"CASE",		LTYPED, ACASE,
+	"END",		LTYPEE, AEND,
+	"WORD",		LTYPEH, AWORD,
+	"NOP",		LTYPEI, ANOP,
+
+	"MCR",		LTYPEJ, 0,
+	"MRC",		LTYPEJ, 1,
+	0
+};
+
+void
+cinit(void)
+{
+	Sym *s;
+	int i;
+
+	nullgen.sym = S;
+	nullgen.offset = 0;
+	nullgen.type = D_NONE;
+	nullgen.name = D_NONE;
+	nullgen.reg = NREG;
+	if(FPCHIP)
+		nullgen.dval = 0;
+	for(i=0; i<sizeof(nullgen.sval); i++)
+		nullgen.sval[i] = 0;
+
+	nerrors = 0;
+	iostack = I;
+	iofree = I;
+	peekc = IGN;
+	nhunk = 0;
+	for(i=0; i<NHASH; i++)
+		hash[i] = S;
+	for(i=0; itab[i].name; i++) {
+		s = slookup(itab[i].name);
+		s->type = itab[i].type;
+		s->value = itab[i].value;
+	}
+
+	pathname = allocn(pathname, 0, 100);
+	if(mygetwd(pathname, 99) == 0) {
+		pathname = allocn(pathname, 100, 900);
+		if(mygetwd(pathname, 999) == 0)
+			strcpy(pathname, "/???");
+	}
+}
+
+void
+syminit(Sym *s)
+{
+
+	s->type = LNAME;
+	s->value = 0;
+}
+
+int
+isreg(Gen *g)
+{
+
+	USED(g);
+	return 1;
+}
+
+void
+cclean(void)
+{
+
+	outcode(AEND, Always, &nullgen, NREG, &nullgen);
+	Bflush(&obuf);
+}
+
+void
+zname(char *n, int t, int s)
+{
+
+	Bputc(&obuf, ANAME);
+	Bputc(&obuf, t);	/* type */
+	Bputc(&obuf, s);	/* sym */
+	while(*n) {
+		Bputc(&obuf, *n);
+		n++;
+	}
+	Bputc(&obuf, 0);
+}
+
+void
+zaddr(Gen *a, int s)
+{
+	long l;
+	int i;
+	char *n;
+	Ieee e;
+
+	Bputc(&obuf, a->type);
+	Bputc(&obuf, a->reg);
+	Bputc(&obuf, s);
+	Bputc(&obuf, a->name);
+	switch(a->type) {
+	default:
+		print("unknown type %d\n", a->type);
+		exits("arg");
+
+	case D_NONE:
+	case D_REG:
+	case D_FREG:
+	case D_PSR:
+	case D_FPCR:
+		break;
+
+	case D_REGREG:
+		Bputc(&obuf, a->offset);
+		break;
+
+	case D_OREG:
+	case D_CONST:
+	case D_BRANCH:
+	case D_SHIFT:
+		l = a->offset;
+		Bputc(&obuf, l);
+		Bputc(&obuf, l>>8);
+		Bputc(&obuf, l>>16);
+		Bputc(&obuf, l>>24);
+		break;
+
+	case D_SCONST:
+		n = a->sval;
+		for(i=0; i<NSNAME; i++) {
+			Bputc(&obuf, *n);
+			n++;
+		}
+		break;
+
+	case D_FCONST:
+		ieeedtod(&e, a->dval);
+		Bputc(&obuf, e.l);
+		Bputc(&obuf, e.l>>8);
+		Bputc(&obuf, e.l>>16);
+		Bputc(&obuf, e.l>>24);
+		Bputc(&obuf, e.h);
+		Bputc(&obuf, e.h>>8);
+		Bputc(&obuf, e.h>>16);
+		Bputc(&obuf, e.h>>24);
+		break;
+	}
+}
+
+static int bcode[] =
+{
+	ABEQ,
+	ABNE,
+	ABCS,
+	ABCC,
+	ABMI,
+	ABPL,
+	ABVS,
+	ABVC,
+	ABHI,
+	ABLS,
+	ABGE,
+	ABLT,
+	ABGT,
+	ABLE,
+	AB,
+	ANOP,
+};
+
+void
+outcode(int a, int scond, Gen *g1, int reg, Gen *g2)
+{
+	int sf, st, t;
+	Sym *s;
+
+	/* hack to make B.NE etc. work: turn it into the corresponding conditional */
+	if(a == AB){
+		a = bcode[scond&0xf];
+		scond = (scond & ~0xf) | Always;
+	}
+
+	if(pass == 1)
+		goto out;
+jackpot:
+	sf = 0;
+	s = g1->sym;
+	while(s != S) {
+		sf = s->sym;
+		if(sf < 0 || sf >= NSYM)
+			sf = 0;
+		t = g1->name;
+		if(h[sf].type == t)
+		if(h[sf].sym == s)
+			break;
+		zname(s->name, t, sym);
+		s->sym = sym;
+		h[sym].sym = s;
+		h[sym].type = t;
+		sf = sym;
+		sym++;
+		if(sym >= NSYM)
+			sym = 1;
+		break;
+	}
+	st = 0;
+	s = g2->sym;
+	while(s != S) {
+		st = s->sym;
+		if(st < 0 || st >= NSYM)
+			st = 0;
+		t = g2->name;
+		if(h[st].type == t)
+		if(h[st].sym == s)
+			break;
+		zname(s->name, t, sym);
+		s->sym = sym;
+		h[sym].sym = s;
+		h[sym].type = t;
+		st = sym;
+		sym++;
+		if(sym >= NSYM)
+			sym = 1;
+		if(st == sf)
+			goto jackpot;
+		break;
+	}
+	Bputc(&obuf, a);
+	Bputc(&obuf, scond);
+	Bputc(&obuf, reg);
+	Bputc(&obuf, lineno);
+	Bputc(&obuf, lineno>>8);
+	Bputc(&obuf, lineno>>16);
+	Bputc(&obuf, lineno>>24);
+	zaddr(g1, sf);
+	zaddr(g2, st);
+
+out:
+	if(a != AGLOBL && a != ADATA)
+		pc++;
+}
+
+void
+outhist(void)
+{
+	Gen g;
+	Hist *h;
+	char *p, *q, *op, c;
+	int n;
+
+	g = nullgen;
+	c = pathchar();
+	for(h = hist; h != H; h = h->link) {
+		p = h->name;
+		op = 0;
+		/* on windows skip drive specifier in pathname */
+		if(systemtype(Windows) && p && p[1] == ':'){
+			p += 2;
+			c = *p;
+		}
+		if(p && p[0] != c && h->offset == 0 && pathname){
+			/* on windows skip drive specifier in pathname */
+			if(systemtype(Windows) && pathname[1] == ':') {
+				op = p;
+				p = pathname+2;
+				c = *p;
+			} else if(pathname[0] == c){
+				op = p;
+				p = pathname;
+			}
+		}
+		while(p) {
+			q = strchr(p, c);
+			if(q) {
+				n = q-p;
+				if(n == 0){
+					n = 1;	/* leading "/" */
+					*p = '/';	/* don't emit "\" on windows */
+				}
+				q++;
+			} else {
+				n = strlen(p);
+				q = 0;
+			}
+			if(n) {
+				Bputc(&obuf, ANAME);
+				Bputc(&obuf, D_FILE);	/* type */
+				Bputc(&obuf, 1);	/* sym */
+				Bputc(&obuf, '<');
+				Bwrite(&obuf, p, n);
+				Bputc(&obuf, 0);
+			}
+			p = q;
+			if(p == 0 && op) {
+				p = op;
+				op = 0;
+			}
+		}
+		g.offset = h->offset;
+
+		Bputc(&obuf, AHISTORY);
+		Bputc(&obuf, Always);
+		Bputc(&obuf, 0);
+		Bputc(&obuf, h->line);
+		Bputc(&obuf, h->line>>8);
+		Bputc(&obuf, h->line>>16);
+		Bputc(&obuf, h->line>>24);
+		zaddr(&nullgen, 0);
+		zaddr(&g, 0);
+	}
+}
+
+#include "../cc/lexbody"
+#include "../cc/macbody"
diff --git a/src/cmd/5c/5.out.h b/src/cmd/5c/5.out.h
new file mode 100644
index 0000000000..8050cd5ece
--- /dev/null
+++ b/src/cmd/5c/5.out.h
@@ -0,0 +1,227 @@
+// Inferno utils/5c/5.out.h
+// http://code.google.com/p/inferno-os/source/browse/utils/5c/5.out.h
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#define	NSNAME		8
+#define	NSYM		50
+#define	NREG		16
+
+#define NOPROF		(1<<0)
+#define DUPOK		(1<<1)
+#define	ALLTHUMBS	(1<<2)
+
+#define	REGRET		0
+#define	REGARG		0
+/* compiler allocates R1 up as temps */
+/* compiler allocates register variables R3 up */
+#define	REGEXT		10
+/* compiler allocates external registers R10 down */
+#define	REGTMP		11
+#define	REGSB		12
+#define	REGSP		13
+#define	REGLINK		14
+#define	REGPC		15
+
+#define	REGTMPT		7	/* used by the loader for thumb code */
+
+#define	NFREG		8
+#define	FREGRET		0
+#define	FREGEXT		7
+/* compiler allocates register variables F0 up */
+/* compiler allocates external registers F7 down */
+
+enum	as
+{
+	AXXX,
+
+	AAND,
+	AEOR,
+	ASUB,
+	ARSB,
+	AADD,
+	AADC,
+	ASBC,
+	ARSC,
+	ATST,
+	ATEQ,
+	ACMP,
+	ACMN,
+	AORR,
+	ABIC,
+
+	AMVN,
+
+	AB,
+	ABL,
+
+/* 
+ * Do not reorder or fragment the conditional branch 
+ * opcodes, or the predication code will break 
+ */ 
+	ABEQ,
+	ABNE,
+	ABCS,
+	ABHS,
+	ABCC,
+	ABLO,
+	ABMI,
+	ABPL,
+	ABVS,
+	ABVC,
+	ABHI,
+	ABLS,
+	ABGE,
+	ABLT,
+	ABGT,
+	ABLE,
+
+	AMOVWD,
+	AMOVWF,
+	AMOVDW,
+	AMOVFW,
+	AMOVFD,
+	AMOVDF,
+	AMOVF,
+	AMOVD,
+
+	ACMPF,
+	ACMPD,
+	AADDF,
+	AADDD,
+	ASUBF,
+	ASUBD,
+	AMULF,
+	AMULD,
+	ADIVF,
+	ADIVD,
+
+	ASRL,
+	ASRA,
+	ASLL,
+	AMULU,
+	ADIVU,
+	AMUL,
+	ADIV,
+	AMOD,
+	AMODU,
+
+	AMOVB,
+	AMOVBU,
+	AMOVH,
+	AMOVHU,
+	AMOVW,
+	AMOVM,
+	ASWPBU,
+	ASWPW,
+
+	ANOP,
+	ARFE,
+	ASWI,
+	AMULA,
+
+	ADATA,
+	AGLOBL,
+	AGOK,
+	AHISTORY,
+	ANAME,
+	ARET,
+	ATEXT,
+	AWORD,
+	ADYNT,
+	AINIT,
+	ABCASE,
+	ACASE,
+
+	AEND,
+
+	AMULL,
+	AMULAL,
+	AMULLU,
+	AMULALU,
+
+	ABX,
+	ABXRET,
+	ADWORD,
+
+	ASIGNAME,
+
+	ALAST,
+};
+
+/* scond byte */
+#define	C_SCOND	((1<<4)-1)
+#define	C_SBIT	(1<<4)
+#define	C_PBIT	(1<<5)
+#define	C_WBIT	(1<<6)
+#define	C_FBIT	(1<<7)	/* psr flags-only */
+#define	C_UBIT	(1<<7)	/* up bit */
+
+/* type/name */
+#define	D_GOK	0
+#define	D_NONE	1
+
+/* type */
+#define	D_BRANCH	(D_NONE+1)
+#define	D_OREG		(D_NONE+2)
+#define	D_CONST		(D_NONE+7)
+#define	D_FCONST	(D_NONE+8)
+#define	D_SCONST	(D_NONE+9)
+#define	D_PSR		(D_NONE+10)
+#define	D_REG		(D_NONE+12)
+#define	D_FREG		(D_NONE+13)
+#define	D_FILE		(D_NONE+16)
+#define	D_OCONST	(D_NONE+17)
+#define	D_FILE1		(D_NONE+18)
+
+#define	D_SHIFT		(D_NONE+19)
+#define	D_FPCR		(D_NONE+20)
+#define 	D_REGREG	(D_NONE+21)
+
+/* name */
+#define	D_EXTERN	(D_NONE+3)
+#define	D_STATIC	(D_NONE+4)
+#define	D_AUTO		(D_NONE+5)
+#define	D_PARAM		(D_NONE+6)
+
+/*
+ * this is the ranlib header
+ */
+#define	SYMDEF	"__.SYMDEF"
+
+/*
+ * this is the simulated IEEE floating point
+ */
+typedef	struct	ieee	Ieee;
+struct	ieee
+{
+	long	l;	/* contains ls-man	0xffffffff */
+	long	h;	/* contains sign	0x80000000
+				    exp		0x7ff00000
+				    ms-man	0x000fffff */
+};
diff --git a/src/cmd/5c/cgen.c b/src/cmd/5c/cgen.c
new file mode 100644
index 0000000000..7e1012e0c1
--- /dev/null
+++ b/src/cmd/5c/cgen.c
@@ -0,0 +1,1186 @@
+// Inferno utils/5c/cgen.c
+// http://code.google.com/p/inferno-os/source/browse/utils/5c/cgen.c
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#include "gc.h"
+
+void
+cgen(Node *n, Node *nn, int inrel)
+{
+	Node *l, *r;
+	Prog *p1;
+	Node nod, nod1, nod2, nod3, nod4;
+	int o, t;
+	long v, curs;
+
+	if(debug['g']) {
+		prtree(nn, "cgen lhs");
+		prtree(n, "cgen");
+	}
+	if(n == Z || n->type == T)
+		return;
+	if(typesuv[n->type->etype]) {
+		sugen(n, nn, n->type->width);
+		return;
+	}
+	l = n->left;
+	r = n->right;
+	o = n->op;
+	if(n->addable >= INDEXED) {
+		if(nn == Z) {
+			switch(o) {
+			default:
+				nullwarn(Z, Z);
+				break;
+			case OINDEX:
+				nullwarn(l, r);
+				break;
+			}
+			return;
+		}
+		gmove(n, nn);
+		return;
+	}
+	curs = cursafe;
+
+	if(n->complex >= FNX)
+	if(l->complex >= FNX)
+	if(r != Z && r->complex >= FNX)
+	switch(o) {
+	default:
+		regret(&nod, r);
+		cgen(r, &nod, 0);
+
+		regsalloc(&nod1, r);
+		gopcode(OAS, &nod, Z, &nod1);
+
+		regfree(&nod);
+		nod = *n;
+		nod.right = &nod1;
+		cgen(&nod, nn, 0);
+		return;
+
+	case OFUNC:
+	case OCOMMA:
+	case OANDAND:
+	case OOROR:
+	case OCOND:
+	case ODOT:
+		break;
+	}
+
+	switch(o) {
+	default:
+		diag(n, "unknown op in cgen: %O", o);
+		break;
+
+	case OAS:
+		if(l->op == OBIT)
+			goto bitas;
+		if(l->addable >= INDEXED && l->complex < FNX) {
+			if(nn != Z || r->addable < INDEXED) {
+				if(r->complex >= FNX && nn == Z)
+					regret(&nod, r);
+				else
+					regalloc(&nod, r, nn);
+				cgen(r, &nod, 0);
+				gmove(&nod, l);
+				if(nn != Z)
+					gmove(&nod, nn);
+				regfree(&nod);
+			} else
+				gmove(r, l);
+			break;
+		}
+		if(l->complex >= r->complex) {
+			reglcgen(&nod1, l, Z);
+			if(r->addable >= INDEXED) {
+				gmove(r, &nod1);
+				if(nn != Z)
+					gmove(r, nn);
+				regfree(&nod1);
+				break;
+			}
+			regalloc(&nod, r, nn);
+			cgen(r, &nod, 0);
+		} else {
+			regalloc(&nod, r, nn);
+			cgen(r, &nod, 0);
+			reglcgen(&nod1, l, Z);
+		}
+		gmove(&nod, &nod1);
+		regfree(&nod);
+		regfree(&nod1);
+		break;
+
+	bitas:
+		n = l->left;
+		regalloc(&nod, r, nn);
+		if(l->complex >= r->complex) {
+			reglcgen(&nod1, n, Z);
+			cgen(r, &nod, 0);
+		} else {
+			cgen(r, &nod, 0);
+			reglcgen(&nod1, n, Z);
+		}
+		regalloc(&nod2, n, Z);
+		gopcode(OAS, &nod1, Z, &nod2);
+		bitstore(l, &nod, &nod1, &nod2, nn);
+		break;
+
+	case OBIT:
+		if(nn == Z) {
+			nullwarn(l, Z);
+			break;
+		}
+		bitload(n, &nod, Z, Z, nn);
+		gopcode(OAS, &nod, Z, nn);
+		regfree(&nod);
+		break;
+
+	case ODIV:
+	case OMOD:
+		if(nn != Z)
+		if((t = vlog(r)) >= 0) {
+			/* signed div/mod by constant power of 2 */
+			cgen(l, nn, 0);
+			gopcode(OGE, nodconst(0), nn, Z);
+			p1 = p;
+			if(o == ODIV) {
+				gopcode(OADD, nodconst((1<<t)-1), Z, nn);
+				patch(p1, pc);
+				gopcode(OASHR, nodconst(t), Z, nn);
+			} else {
+				gopcode(OSUB, nn, nodconst(0), nn);
+				gopcode(OAND, nodconst((1<<t)-1), Z, nn);
+				gopcode(OSUB, nn, nodconst(0), nn);
+				gbranch(OGOTO);
+				patch(p1, pc);
+				p1 = p;
+				gopcode(OAND, nodconst((1<<t)-1), Z, nn);
+				patch(p1, pc);
+			}
+			break;
+		}
+		goto muldiv;
+
+	case OSUB:
+		if(nn != Z)
+		if(l->op == OCONST)
+		if(!typefd[n->type->etype]) {
+			cgen(r, nn, 0);
+			gopcode(o, Z, l, nn);
+			break;
+		}
+	case OADD:
+	case OAND:
+	case OOR:
+	case OXOR:
+	case OLSHR:
+	case OASHL:
+	case OASHR:
+		/*
+		 * immediate operands
+		 */
+		if(nn != Z)
+		if(r->op == OCONST)
+		if(!typefd[n->type->etype]) {
+			cgen(l, nn, 0);
+			if(r->vconst == 0)
+			if(o != OAND)
+				break;
+			if(nn != Z)
+				gopcode(o, r, Z, nn);
+			break;
+		}
+
+	case OLMUL:
+	case OLDIV:
+	case OLMOD:
+	case OMUL:
+	muldiv:
+		if(nn == Z) {
+			nullwarn(l, r);
+			break;
+		}
+		if(o == OMUL || o == OLMUL) {
+			if(mulcon(n, nn))
+				break;
+		}
+		if(l->complex >= r->complex) {
+			regalloc(&nod, l, nn);
+			cgen(l, &nod, 0);
+			regalloc(&nod1, r, Z);
+			cgen(r, &nod1, 0);
+			gopcode(o, &nod1, Z, &nod);
+		} else {
+			regalloc(&nod, r, nn);
+			cgen(r, &nod, 0);
+			regalloc(&nod1, l, Z);
+			cgen(l, &nod1, 0);
+			gopcode(o, &nod, &nod1, &nod);
+		}
+		gopcode(OAS, &nod, Z, nn);
+		regfree(&nod);
+		regfree(&nod1);
+		break;
+
+	case OASLSHR:
+	case OASASHL:
+	case OASASHR:
+	case OASAND:
+	case OASADD:
+	case OASSUB:
+	case OASXOR:
+	case OASOR:
+		if(l->op == OBIT)
+			goto asbitop;
+		if(r->op == OCONST)
+		if(!typefd[r->type->etype])
+		if(!typefd[n->type->etype]) {
+			if(l->addable < INDEXED)
+				reglcgen(&nod2, l, Z);
+			else
+				nod2 = *l;
+			regalloc(&nod, r, nn);
+			gopcode(OAS, &nod2, Z, &nod);
+			gopcode(o, r, Z, &nod);
+			gopcode(OAS, &nod, Z, &nod2);
+	
+			regfree(&nod);
+			if(l->addable < INDEXED)
+				regfree(&nod2);
+			break;
+		}
+
+	case OASLMUL:
+	case OASLDIV:
+	case OASLMOD:
+	case OASMUL:
+	case OASDIV:
+	case OASMOD:
+		if(l->op == OBIT)
+			goto asbitop;
+		if(l->complex >= r->complex) {
+			if(l->addable < INDEXED)
+				reglcgen(&nod2, l, Z);
+			else
+				nod2 = *l;
+			regalloc(&nod1, r, Z);
+			cgen(r, &nod1, 0);
+		} else {
+			regalloc(&nod1, r, Z);
+			cgen(r, &nod1, 0);
+			if(l->addable < INDEXED)
+				reglcgen(&nod2, l, Z);
+			else
+				nod2 = *l;
+		}
+
+		regalloc(&nod, n, nn);
+		gmove(&nod2, &nod);
+		gopcode(o, &nod1, Z, &nod);
+		gmove(&nod, &nod2);
+		if(nn != Z)
+			gopcode(OAS, &nod, Z, nn);
+		regfree(&nod);
+		regfree(&nod1);
+		if(l->addable < INDEXED)
+			regfree(&nod2);
+		break;
+
+	asbitop:
+		regalloc(&nod4, n, nn);
+		if(l->complex >= r->complex) {
+			bitload(l, &nod, &nod1, &nod2, &nod4);
+			regalloc(&nod3, r, Z);
+			cgen(r, &nod3, 0);
+		} else {
+			regalloc(&nod3, r, Z);
+			cgen(r, &nod3, 0);
+			bitload(l, &nod, &nod1, &nod2, &nod4);
+		}
+		gmove(&nod, &nod4);
+		gopcode(o, &nod3, Z, &nod4);
+		regfree(&nod3);
+		gmove(&nod4, &nod);
+		regfree(&nod4);
+		bitstore(l, &nod, &nod1, &nod2, nn);
+		break;
+
+	case OADDR:
+		if(nn == Z) {
+			nullwarn(l, Z);
+			break;
+		}
+		lcgen(l, nn);
+		break;
+
+	case OFUNC:
+		if(l->complex >= FNX) {
+			if(l->op != OIND)
+				diag(n, "bad function call");
+
+			regret(&nod, l->left);
+			cgen(l->left, &nod, 0);
+			regsalloc(&nod1, l->left);
+			gopcode(OAS, &nod, Z, &nod1);
+			regfree(&nod);
+
+			nod = *n;
+			nod.left = &nod2;
+			nod2 = *l;
+			nod2.left = &nod1;
+			nod2.complex = 1;
+			cgen(&nod, nn, 0);
+
+			return;
+		}
+		if(REGARG >= 0)
+			o = reg[REGARG];
+		gargs(r, &nod, &nod1);
+		if(l->addable < INDEXED) {
+			reglcgen(&nod, l, Z);
+			gopcode(OFUNC, Z, Z, &nod);
+			regfree(&nod);
+		} else
+			gopcode(OFUNC, Z, Z, l);
+		if(REGARG >= 0)
+			if(o != reg[REGARG])
+				reg[REGARG]--;
+		if(nn != Z) {
+			regret(&nod, n);
+			gopcode(OAS, &nod, Z, nn);
+			regfree(&nod);
+		}
+		break;
+
+	case OIND:
+		if(nn == Z) {
+			nullwarn(l, Z);
+			break;
+		}
+		regialloc(&nod, n, nn);
+		r = l;
+		while(r->op == OADD)
+			r = r->right;
+		if(sconst(r) && (v = r->vconst+nod.xoffset) > -4096 && v < 4096) {
+			v = r->vconst;
+			r->vconst = 0;
+			cgen(l, &nod, 0);
+			nod.xoffset += v;
+			r->vconst = v;
+		} else
+			cgen(l, &nod, 0);
+		regind(&nod, n);
+		gopcode(OAS, &nod, Z, nn);
+		regfree(&nod);
+		break;
+
+	case OEQ:
+	case ONE:
+	case OLE:
+	case OLT:
+	case OGE:
+	case OGT:
+	case OLO:
+	case OLS:
+	case OHI:
+	case OHS:
+		if(nn == Z) {
+			nullwarn(l, r);
+			break;
+		}
+		boolgen(n, 1, nn);
+		break;
+
+	case OANDAND:
+	case OOROR:
+		boolgen(n, 1, nn);
+		if(nn == Z)
+			patch(p, pc);
+		break;
+
+	case ONOT:
+		if(nn == Z) {
+			nullwarn(l, Z);
+			break;
+		}
+		boolgen(n, 1, nn);
+		break;
+
+	case OCOMMA:
+		cgen(l, Z, 0);
+		cgen(r, nn, 0);
+		break;
+
+	case OCAST:
+		if(nn == Z) {
+			nullwarn(l, Z);
+			break;
+		}
+		/*
+		 * convert from types l->n->nn
+		 */
+		if(nocast(l->type, n->type)) {
+			if(nocast(n->type, nn->type)) {
+				cgen(l, nn, 0);
+				break;
+			}
+		}
+		regalloc(&nod, l, nn);
+		cgen(l, &nod, 0);
+		regalloc(&nod1, n, &nod);
+		if(inrel)
+			gmover(&nod, &nod1);
+		else
+			gopcode(OAS, &nod, Z, &nod1);
+		gopcode(OAS, &nod1, Z, nn);
+		regfree(&nod1);
+		regfree(&nod);
+		break;
+
+	case ODOT:
+		sugen(l, nodrat, l->type->width);
+		if(nn != Z) {
+			warn(n, "non-interruptable temporary");
+			nod = *nodrat;
+			if(!r || r->op != OCONST) {
+				diag(n, "DOT and no offset");
+				break;
+			}
+			nod.xoffset += (long)r->vconst;
+			nod.type = n->type;
+			cgen(&nod, nn, 0);
+		}
+		break;
+
+	case OCOND:
+		bcgen(l, 1);
+		p1 = p;
+		cgen(r->left, nn, 0);
+		gbranch(OGOTO);
+		patch(p1, pc);
+		p1 = p;
+		cgen(r->right, nn, 0);
+		patch(p1, pc);
+		break;
+
+	case OPOSTINC:
+	case OPOSTDEC:
+		v = 1;
+		if(l->type->etype == TIND)
+			v = l->type->link->width;
+		if(o == OPOSTDEC)
+			v = -v;
+		if(l->op == OBIT)
+			goto bitinc;
+		if(nn == Z)
+			goto pre;
+
+		if(l->addable < INDEXED)
+			reglcgen(&nod2, l, Z);
+		else
+			nod2 = *l;
+
+		regalloc(&nod, l, nn);
+		gopcode(OAS, &nod2, Z, &nod);
+		regalloc(&nod1, l, Z);
+		if(typefd[l->type->etype]) {
+			regalloc(&nod3, l, Z);
+			if(v < 0) {
+				gopcode(OAS, nodfconst(-v), Z, &nod3);
+				gopcode(OSUB, &nod3, &nod, &nod1);
+			} else {
+				gopcode(OAS, nodfconst(v), Z, &nod3);
+				gopcode(OADD, &nod3, &nod, &nod1);
+			}
+			regfree(&nod3);
+		} else
+			gopcode(OADD, nodconst(v), &nod, &nod1);
+		gopcode(OAS, &nod1, Z, &nod2);
+
+		regfree(&nod);
+		regfree(&nod1);
+		if(l->addable < INDEXED)
+			regfree(&nod2);
+		break;
+
+	case OPREINC:
+	case OPREDEC:
+		v = 1;
+		if(l->type->etype == TIND)
+			v = l->type->link->width;
+		if(o == OPREDEC)
+			v = -v;
+		if(l->op == OBIT)
+			goto bitinc;
+
+	pre:
+		if(l->addable < INDEXED)
+			reglcgen(&nod2, l, Z);
+		else
+			nod2 = *l;
+
+		regalloc(&nod, l, nn);
+		gopcode(OAS, &nod2, Z, &nod);
+		if(typefd[l->type->etype]) {
+			regalloc(&nod3, l, Z);
+			if(v < 0) {
+				gopcode(OAS, nodfconst(-v), Z, &nod3);
+				gopcode(OSUB, &nod3, Z, &nod);
+			} else {
+				gopcode(OAS, nodfconst(v), Z, &nod3);
+				gopcode(OADD, &nod3, Z, &nod);
+			}
+			regfree(&nod3);
+		} else
+			gopcode(OADD, nodconst(v), Z, &nod);
+		gopcode(OAS, &nod, Z, &nod2);
+
+		regfree(&nod);
+		if(l->addable < INDEXED)
+			regfree(&nod2);
+		break;
+
+	bitinc:
+		if(nn != Z && (o == OPOSTINC || o == OPOSTDEC)) {
+			bitload(l, &nod, &nod1, &nod2, Z);
+			gopcode(OAS, &nod, Z, nn);
+			gopcode(OADD, nodconst(v), Z, &nod);
+			bitstore(l, &nod, &nod1, &nod2, Z);
+			break;
+		}
+		bitload(l, &nod, &nod1, &nod2, nn);
+		gopcode(OADD, nodconst(v), Z, &nod);
+		bitstore(l, &nod, &nod1, &nod2, nn);
+		break;
+	}
+	cursafe = curs;
+	return;
+}
+
+void
+reglcgen(Node *t, Node *n, Node *nn)
+{
+	Node *r;
+	long v;
+
+	regialloc(t, n, nn);
+	if(n->op == OIND) {
+		r = n->left;
+		while(r->op == OADD)
+			r = r->right;
+		if(sconst(r) && (v = r->vconst+t->xoffset) > -4096 && v < 4096) {
+			v = r->vconst;
+			r->vconst = 0;
+			lcgen(n, t);
+			t->xoffset += v;
+			r->vconst = v;
+			regind(t, n);
+			return;
+		}
+	} else if(n->op == OINDREG) {
+		if((v = n->xoffset) > -4096 && v < 4096) {
+			n->op = OREGISTER;
+			cgen(n, t, 0);
+			t->xoffset += v;
+			n->op = OINDREG;
+			regind(t, n);
+			return;
+		}
+	}
+	lcgen(n, t);
+	regind(t, n);
+}
+
+void
+reglpcgen(Node *n, Node *nn, int f)
+{
+	Type *t;
+
+	t = nn->type;
+	nn->type = types[TLONG];
+	if(f)
+		reglcgen(n, nn, Z);
+	else {
+		regialloc(n, nn, Z);
+		lcgen(nn, n);
+		regind(n, nn);
+	}
+	nn->type = t;
+}
+
+void
+lcgen(Node *n, Node *nn)
+{
+	Prog *p1;
+	Node nod;
+
+	if(debug['g']) {
+		prtree(nn, "lcgen lhs");
+		prtree(n, "lcgen");
+	}
+	if(n == Z || n->type == T)
+		return;
+	if(nn == Z) {
+		nn = &nod;
+		regalloc(&nod, n, Z);
+	}
+	switch(n->op) {
+	default:
+		if(n->addable < INDEXED) {
+			diag(n, "unknown op in lcgen: %O", n->op);
+			break;
+		}
+		nod = *n;
+		nod.op = OADDR;
+		nod.left = n;
+		nod.right = Z;
+		nod.type = types[TIND];
+		gopcode(OAS, &nod, Z, nn);
+		break;
+
+	case OCOMMA:
+		cgen(n->left, n->left, 0);
+		lcgen(n->right, nn);
+		break;
+
+	case OIND:
+		cgen(n->left, nn, 0);
+		break;
+
+	case OCOND:
+		bcgen(n->left, 1);
+		p1 = p;
+		lcgen(n->right->left, nn);
+		gbranch(OGOTO);
+		patch(p1, pc);
+		p1 = p;
+		lcgen(n->right->right, nn);
+		patch(p1, pc);
+		break;
+	}
+}
+
+void
+bcgen(Node *n, int true)
+{
+
+	if(n->type == T)
+		gbranch(OGOTO);
+	else
+		boolgen(n, true, Z);
+}
+
+void
+boolgen(Node *n, int true, Node *nn)
+{
+	int o;
+	Prog *p1, *p2;
+	Node *l, *r, nod, nod1;
+	long curs;
+
+	if(debug['g']) {
+		prtree(nn, "boolgen lhs");
+		prtree(n, "boolgen");
+	}
+	curs = cursafe;
+	l = n->left;
+	r = n->right;
+	switch(n->op) {
+
+	default:
+		regalloc(&nod, n, nn);
+		cgen(n, &nod, 0);
+		o = ONE;
+		if(true)
+			o = comrel[relindex(o)];
+		if(typefd[n->type->etype]) {
+			gopcode(o, nodfconst(0), &nod, Z);
+		} else
+			gopcode(o, nodconst(0), &nod, Z);
+		regfree(&nod);
+		goto com;
+
+	case OCONST:
+		o = vconst(n);
+		if(!true)
+			o = !o;
+		gbranch(OGOTO);
+		if(o) {
+			p1 = p;
+			gbranch(OGOTO);
+			patch(p1, pc);
+		}
+		goto com;
+
+	case OCOMMA:
+		cgen(l, Z, 0);
+		boolgen(r, true, nn);
+		break;
+
+	case ONOT:
+		boolgen(l, !true, nn);
+		break;
+
+	case OCOND:
+		bcgen(l, 1);
+		p1 = p;
+		bcgen(r->left, true);
+		p2 = p;
+		gbranch(OGOTO);
+		patch(p1, pc);
+		p1 = p;
+		bcgen(r->right, !true);
+		patch(p2, pc);
+		p2 = p;
+		gbranch(OGOTO);
+		patch(p1, pc);
+		patch(p2, pc);
+		goto com;
+
+	case OANDAND:
+		if(!true)
+			goto caseor;
+
+	caseand:
+		bcgen(l, true);
+		p1 = p;
+		bcgen(r, !true);
+		p2 = p;
+		patch(p1, pc);
+		gbranch(OGOTO);
+		patch(p2, pc);
+		goto com;
+
+	case OOROR:
+		if(!true)
+			goto caseand;
+
+	caseor:
+		bcgen(l, !true);
+		p1 = p;
+		bcgen(r, !true);
+		p2 = p;
+		gbranch(OGOTO);
+		patch(p1, pc);
+		patch(p2, pc);
+		goto com;
+
+	case OEQ:
+	case ONE:
+	case OLE:
+	case OLT:
+	case OGE:
+	case OGT:
+	case OHI:
+	case OHS:
+	case OLO:
+	case OLS:
+		o = n->op;
+		if(true)
+			o = comrel[relindex(o)];
+		if(l->complex >= FNX && r->complex >= FNX) {
+			regret(&nod, r);
+			cgen(r, &nod, 1);
+			regsalloc(&nod1, r);
+			gopcode(OAS, &nod, Z, &nod1);
+			regfree(&nod);
+			nod = *n;
+			nod.right = &nod1;
+			boolgen(&nod, true, nn);
+			break;
+		}
+		if(sconst(l)) {
+			regalloc(&nod, r, nn);
+			cgen(r, &nod, 1);
+			o = invrel[relindex(o)];
+			gopcode(o, l, &nod, Z);
+			regfree(&nod);
+			goto com;
+		}
+		if(sconst(r)) {
+			regalloc(&nod, l, nn);
+			cgen(l, &nod, 1);
+			gopcode(o, r, &nod, Z);
+			regfree(&nod);
+			goto com;
+		}
+		if(l->complex >= r->complex) {
+			regalloc(&nod1, l, nn);
+			cgen(l, &nod1, 1);
+			regalloc(&nod, r, Z);
+			cgen(r, &nod, 1);
+		} else {
+			regalloc(&nod, r, nn);
+			cgen(r, &nod, 1);
+			regalloc(&nod1, l, Z);
+			cgen(l, &nod1, 1);
+		}
+		gopcode(o, &nod, &nod1, Z);
+		regfree(&nod);
+		regfree(&nod1);
+
+	com:
+		if(nn != Z) {
+			p1 = p;
+			gopcode(OAS, nodconst(1), Z, nn);
+			gbranch(OGOTO);
+			p2 = p;
+			patch(p1, pc);
+			gopcode(OAS, nodconst(0), Z, nn);
+			patch(p2, pc);
+		}
+		break;
+	}
+	cursafe = curs;
+}
+
+void
+sugen(Node *n, Node *nn, long w)
+{
+	Prog *p1;
+	Node nod0, nod1, nod2, nod3, nod4, *l, *r;
+	Type *t;
+	long pc1;
+	int i, m, c;
+
+	if(n == Z || n->type == T)
+		return;
+	if(debug['g']) {
+		prtree(nn, "sugen lhs");
+		prtree(n, "sugen");
+	}
+	if(nn == nodrat)
+		if(w > nrathole)
+			nrathole = w;
+	switch(n->op) {
+	case OIND:
+		if(nn == Z) {
+			nullwarn(n->left, Z);
+			break;
+		}
+
+	default:
+		goto copy;
+
+	case OCONST:
+		if(n->type && typev[n->type->etype]) {
+			if(nn == Z) {
+				nullwarn(n->left, Z);
+				break;
+			}
+
+			t = nn->type;
+			nn->type = types[TLONG];
+			reglcgen(&nod1, nn, Z);
+			nn->type = t;
+
+			if(1 || align(0, types[TCHAR], Aarg1))	/* isbigendian */
+				gopcode(OAS, nod32const(n->vconst>>32), Z, &nod1);
+			else
+				gopcode(OAS, nod32const(n->vconst), Z, &nod1);
+			nod1.xoffset += SZ_LONG;
+			if(1 || align(0, types[TCHAR], Aarg1))	/* isbigendian */
+				gopcode(OAS, nod32const(n->vconst), Z, &nod1);
+			else
+				gopcode(OAS, nod32const(n->vconst>>32), Z, &nod1);
+
+			regfree(&nod1);
+			break;
+		}
+		goto copy;
+
+	case ODOT:
+		l = n->left;
+		sugen(l, nodrat, l->type->width);
+		if(nn != Z) {
+			warn(n, "non-interruptable temporary");
+			nod1 = *nodrat;
+			r = n->right;
+			if(!r || r->op != OCONST) {
+				diag(n, "DOT and no offset");
+				break;
+			}
+			nod1.xoffset += (long)r->vconst;
+			nod1.type = n->type;
+			sugen(&nod1, nn, w);
+		}
+		break;
+
+	case OSTRUCT:
+		/*
+		 * rewrite so lhs has no fn call
+		 */
+		if(nn != Z && nn->complex >= FNX) {
+			nod1 = *n;
+			nod1.type = typ(TIND, n->type);
+			regret(&nod2, &nod1);
+			lcgen(nn, &nod2);
+			regsalloc(&nod0, &nod1);
+			gopcode(OAS, &nod2, Z, &nod0);
+			regfree(&nod2);
+
+			nod1 = *n;
+			nod1.op = OIND;
+			nod1.left = &nod0;
+			nod1.right = Z;
+			nod1.complex = 1;
+
+			sugen(n, &nod1, w);
+			return;
+		}
+
+		r = n->left;
+		for(t = n->type->link; t != T; t = t->down) {
+			l = r;
+			if(r->op == OLIST) {
+				l = r->left;
+				r = r->right;
+			}
+			if(nn == Z) {
+				cgen(l, nn, 0);
+				continue;
+			}
+			/*
+			 * hand craft *(&nn + o) = l
+			 */
+			nod0 = znode;
+			nod0.op = OAS;
+			nod0.type = t;
+			nod0.left = &nod1;
+			nod0.right = l;
+
+			nod1 = znode;
+			nod1.op = OIND;
+			nod1.type = t;
+			nod1.left = &nod2;
+
+			nod2 = znode;
+			nod2.op = OADD;
+			nod2.type = typ(TIND, t);
+			nod2.left = &nod3;
+			nod2.right = &nod4;
+
+			nod3 = znode;
+			nod3.op = OADDR;
+			nod3.type = nod2.type;
+			nod3.left = nn;
+
+			nod4 = znode;
+			nod4.op = OCONST;
+			nod4.type = nod2.type;
+			nod4.vconst = t->offset;
+
+			ccom(&nod0);
+			acom(&nod0);
+			xcom(&nod0);
+			nod0.addable = 0;
+
+			cgen(&nod0, Z, 0);
+		}
+		break;
+
+	case OAS:
+		if(nn == Z) {
+			if(n->addable < INDEXED)
+				sugen(n->right, n->left, w);
+			break;
+		}
+		sugen(n->right, nodrat, w);
+		warn(n, "non-interruptable temporary");
+		sugen(nodrat, n->left, w);
+		sugen(nodrat, nn, w);
+		break;
+
+	case OFUNC:
+		if(nn == Z) {
+			sugen(n, nodrat, w);
+			break;
+		}
+		if(nn->op != OIND) {
+			nn = new1(OADDR, nn, Z);
+			nn->type = types[TIND];
+			nn->addable = 0;
+		} else
+			nn = nn->left;
+		n = new(OFUNC, n->left, new(OLIST, nn, n->right));
+		n->type = types[TVOID];
+		n->left->type = types[TVOID];
+		cgen(n, Z, 0);
+		break;
+
+	case OCOND:
+		bcgen(n->left, 1);
+		p1 = p;
+		sugen(n->right->left, nn, w);
+		gbranch(OGOTO);
+		patch(p1, pc);
+		p1 = p;
+		sugen(n->right->right, nn, w);
+		patch(p1, pc);
+		break;
+
+	case OCOMMA:
+		cgen(n->left, Z, 0);
+		sugen(n->right, nn, w);
+		break;
+	}
+	return;
+
+copy:
+	if(nn == Z)
+		return;
+	if(n->complex >= FNX && nn->complex >= FNX) {
+		t = nn->type;
+		nn->type = types[TLONG];
+		regialloc(&nod1, nn, Z);
+		lcgen(nn, &nod1);
+		regsalloc(&nod2, nn);
+		nn->type = t;
+
+		gopcode(OAS, &nod1, Z, &nod2);
+		regfree(&nod1);
+
+		nod2.type = typ(TIND, t);
+
+		nod1 = nod2;
+		nod1.op = OIND;
+		nod1.left = &nod2;
+		nod1.right = Z;
+		nod1.complex = 1;
+		nod1.type = t;
+
+		sugen(n, &nod1, w);
+		return;
+	}
+
+	w /= SZ_LONG;
+	if(w <= 2) {
+		if(n->complex > nn->complex) {
+			reglpcgen(&nod1, n, 1);
+			reglpcgen(&nod2, nn, 1);
+		} else {
+			reglpcgen(&nod2, nn, 1);
+			reglpcgen(&nod1, n, 1);
+		}
+		regalloc(&nod3, &regnode, Z);
+		regalloc(&nod4, &regnode, Z);
+		nod0 = *nodconst((1<<nod3.reg)|(1<<nod4.reg));
+		if(w == 2 && nod1.xoffset == 0)
+			gmovm(&nod1, &nod0, 0);
+		else {
+			gmove(&nod1, &nod3);
+			if(w == 2) {
+				nod1.xoffset += SZ_LONG;
+				gmove(&nod1, &nod4);
+			}
+		}
+		if(w == 2 && nod2.xoffset == 0)
+			gmovm(&nod0, &nod2, 0);
+		else {
+			gmove(&nod3, &nod2);
+			if(w == 2) {
+				nod2.xoffset += SZ_LONG;
+				gmove(&nod4, &nod2);
+			}
+		}
+		regfree(&nod1);
+		regfree(&nod2);
+		regfree(&nod3);
+		regfree(&nod4);
+		return;
+	}
+
+	if(n->complex > nn->complex) {
+		reglpcgen(&nod1, n, 0);
+		reglpcgen(&nod2, nn, 0);
+	} else {
+		reglpcgen(&nod2, nn, 0);
+		reglpcgen(&nod1, n, 0);
+	}
+
+	m = 0;
+	for(c = 0; c < w && c < 4; c++) {
+		i = tmpreg();
+		if (i == 0)
+			break;
+		reg[i]++;
+		m |= 1<<i;
+	}
+	nod4 = *(nodconst(m));
+	if(w < 3*c) {
+		for (; w>c; w-=c) {
+			gmovm(&nod1, &nod4, 1);
+			gmovm(&nod4, &nod2, 1);
+		}
+		goto out;
+	}
+
+	regalloc(&nod3, &regnode, Z);
+	gopcode(OAS, nodconst(w/c), Z, &nod3);
+	w %= c;
+	
+	pc1 = pc;
+	gmovm(&nod1, &nod4, 1);
+	gmovm(&nod4, &nod2, 1);
+
+	gopcode(OSUB, nodconst(1), Z, &nod3);
+	gopcode(OEQ, nodconst(0), &nod3, Z);
+	p->as = ABGT;
+	patch(p, pc1);
+	regfree(&nod3);
+
+out:
+	if (w) {
+		i = 0;
+		while (c>w) {
+			while ((m&(1<<i)) == 0)
+				i++;
+			m &= ~(1<<i);
+			reg[i] = 0;
+			c--;
+			i++;
+		}
+		nod4.vconst = m;
+		gmovm(&nod1, &nod4, 0);
+		gmovm(&nod4, &nod2, 0);
+	}
+	i = 0;
+	do {
+		while ((m&(1<<i)) == 0)
+			i++;
+		reg[i] = 0;
+		c--;
+		i++;
+	} while (c>0);
+	regfree(&nod1);
+	regfree(&nod2);
+}
diff --git a/src/cmd/5c/gc.h b/src/cmd/5c/gc.h
new file mode 100644
index 0000000000..c62b091c12
--- /dev/null
+++ b/src/cmd/5c/gc.h
@@ -0,0 +1,379 @@
+// Inferno utils/5c/gc.h
+// http://code.google.com/p/inferno-os/source/browse/utils/5c/gc.h
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#include	"../cc/cc.h"
+#include	"../5c/5.out.h"
+
+/*
+ * 5c/arm
+ * Arm 7500
+ */
+#define	SZ_CHAR		1
+#define	SZ_SHORT	2
+#define	SZ_INT		4
+#define	SZ_LONG		4
+#define	SZ_IND		4
+#define	SZ_FLOAT	4
+#define	SZ_VLONG	8
+#define	SZ_DOUBLE	8
+#define	FNX		100
+
+typedef	struct	Adr	Adr;
+typedef	struct	Prog	Prog;
+typedef	struct	Case	Case;
+typedef	struct	C1	C1;
+typedef	struct	Multab	Multab;
+typedef	struct	Hintab	Hintab;
+typedef	struct	Var	Var;
+typedef	struct	Reg	Reg;
+typedef	struct	Rgn	Rgn;
+
+
+#define	R0ISZERO	0
+
+struct	Adr
+{
+	long	offset;
+	double	dval;
+	char	sval[NSNAME];
+	Ieee	ieee;
+
+	Sym*	sym;
+	char	type;
+	char	reg;
+	char	name;
+	char	etype;
+};
+#define	A	((Adr*)0)
+
+#define	INDEXED	9
+struct	Prog
+{
+	Adr	from;
+	Adr	to;
+	Prog*	link;
+	long	lineno;
+	char	as;
+	char	reg;
+	uchar	scond;
+};
+#define	P	((Prog*)0)
+
+struct	Case
+{
+	Case*	link;
+	long	val;
+	long	label;
+	char	def;
+};
+#define	C	((Case*)0)
+
+struct	C1
+{
+	long	val;
+	long	label;
+};
+
+struct	Multab
+{
+	long	val;
+	char	code[20];
+};
+
+struct	Hintab
+{
+	ushort	val;
+	char	hint[10];
+};
+
+struct	Var
+{
+	long	offset;
+	Sym*	sym;
+	char	name;
+	char	etype;
+};
+
+struct	Reg
+{
+	long	pc;
+	long	rpo;		/* reverse post ordering */
+
+	Bits	set;
+	Bits	use1;
+	Bits	use2;
+
+	Bits	refbehind;
+	Bits	refahead;
+	Bits	calbehind;
+	Bits	calahead;
+	Bits	regdiff;
+	Bits	act;
+
+	long	regu;
+	long	loop;		/* could be shorter */
+
+	
+	Reg*	log5;
+	long	active;
+
+	Reg*	p1;
+	Reg*	p2;
+	Reg*	p2link;
+	Reg*	s1;
+	Reg*	s2;
+	Reg*	link;
+	Prog*	prog;
+};
+#define	R	((Reg*)0)
+
+#define	NRGN	600
+struct	Rgn
+{
+	Reg*	enter;
+	short	cost;
+	short	varno;
+	short	regno;
+};
+
+EXTERN	long	breakpc;
+EXTERN	Case*	cases;
+EXTERN	Node	constnode;
+EXTERN	Node	fconstnode;
+EXTERN	long	continpc;
+EXTERN	long	curarg;
+EXTERN	long	cursafe;
+EXTERN	Prog*	firstp;
+EXTERN	Prog*	lastp;
+EXTERN	long	maxargsafe;
+EXTERN	int	mnstring;
+EXTERN	Multab	multab[20];
+EXTERN	int	retok;
+EXTERN	int	hintabsize;
+EXTERN	Node*	nodrat;
+EXTERN	Node*	nodret;
+EXTERN	Node*	nodsafe;
+EXTERN	long	nrathole;
+EXTERN	long	nstring;
+EXTERN	Prog*	p;
+EXTERN	long	pc;
+EXTERN	Node	regnode;
+EXTERN	char	string[NSNAME];
+EXTERN	Sym*	symrathole;
+EXTERN	Node	znode;
+EXTERN	Prog	zprog;
+EXTERN	char	reg[NREG+NFREG];
+EXTERN	long	exregoffset;
+EXTERN	long	exfregoffset;
+EXTERN	int	suppress;
+
+#define	BLOAD(r)	band(bnot(r->refbehind), r->refahead)
+#define	BSTORE(r)	band(bnot(r->calbehind), r->calahead)
+#define	LOAD(r)		(~r->refbehind.b[z] & r->refahead.b[z])
+#define	STORE(r)	(~r->calbehind.b[z] & r->calahead.b[z])
+
+#define	bset(a,n)	((a).b[(n)/32]&(1L<<(n)%32))
+
+#define	CLOAD	4
+#define	CREF	5
+#define	CINF	1000
+#define	LOOP	3
+
+EXTERN	Rgn	region[NRGN];
+EXTERN	Rgn*	rgp;
+EXTERN	int	nregion;
+EXTERN	int	nvar;
+
+EXTERN	Bits	externs;
+EXTERN	Bits	params;
+EXTERN	Bits	consts;
+EXTERN	Bits	addrs;
+
+EXTERN	long	regbits;
+EXTERN	long	exregbits;
+
+EXTERN	int	change;
+
+EXTERN	Reg*	firstr;
+EXTERN	Reg*	lastr;
+EXTERN	Reg	zreg;
+EXTERN	Reg*	freer;
+EXTERN	Var	var[NVAR];
+EXTERN	long*	idom;
+EXTERN	Reg**	rpo2r;
+EXTERN	long	maxnr;
+
+extern	char*	anames[];
+extern	Hintab	hintab[];
+
+/*
+ * sgen.c
+ */
+void	codgen(Node*, Node*);
+void	gen(Node*);
+void	noretval(int);
+void	usedset(Node*, int);
+void	xcom(Node*);
+int	bcomplex(Node*, Node*);
+
+/*
+ * cgen.c
+ */
+void	cgen(Node*, Node*, int);
+void	reglcgen(Node*, Node*, Node*);
+void	lcgen(Node*, Node*);
+void	bcgen(Node*, int);
+void	boolgen(Node*, int, Node*);
+void	sugen(Node*, Node*, long);
+void	layout(Node*, Node*, int, int, Node*);
+
+/*
+ * txt.c
+ */
+void	ginit(void);
+void	gclean(void);
+void	nextpc(void);
+void	gargs(Node*, Node*, Node*);
+void	garg1(Node*, Node*, Node*, int, Node**);
+Node*	nodconst(long);
+Node*	nod32const(vlong);
+Node*	nodfconst(double);
+void	nodreg(Node*, Node*, int);
+void	regret(Node*, Node*);
+int	tmpreg(void);
+void	regalloc(Node*, Node*, Node*);
+void	regfree(Node*);
+void	regialloc(Node*, Node*, Node*);
+void	regsalloc(Node*, Node*);
+void	regaalloc1(Node*, Node*);
+void	regaalloc(Node*, Node*);
+void	regind(Node*, Node*);
+void	gprep(Node*, Node*);
+void	raddr(Node*, Prog*);
+void	naddr(Node*, Adr*);
+void	gmovm(Node*, Node*, int);
+void	gmove(Node*, Node*);
+void	gmover(Node*, Node*);
+void	gins(int a, Node*, Node*);
+void	gopcode(int, Node*, Node*, Node*);
+int	samaddr(Node*, Node*);
+void	gbranch(int);
+void	patch(Prog*, long);
+int	sconst(Node*);
+int	sval(long);
+void	gpseudo(int, Sym*, Node*);
+
+/*
+ * swt.c
+ */
+int	swcmp(const void*, const void*);
+void	doswit(Node*);
+void	swit1(C1*, int, long, Node*, Node*);
+void	cas(void);
+void	bitload(Node*, Node*, Node*, Node*, Node*);
+void	bitstore(Node*, Node*, Node*, Node*, Node*);
+long	outstring(char*, long);
+int	mulcon(Node*, Node*);
+Multab*	mulcon0(long);
+void	nullwarn(Node*, Node*);
+void	sextern(Sym*, Node*, long, long);
+void	gextern(Sym*, Node*, long, long);
+void	outcode(void);
+void	ieeedtod(Ieee*, double);
+
+/*
+ * list
+ */
+void	listinit(void);
+int	Pconv(Fmt*);
+int	Aconv(Fmt*);
+int	Dconv(Fmt*);
+int	Sconv(Fmt*);
+int	Nconv(Fmt*);
+int	Bconv(Fmt*);
+int	Rconv(Fmt*);
+
+/*
+ * reg.c
+ */
+Reg*	rega(void);
+int	rcmp(const void*, const void*);
+void	regopt(Prog*);
+void	addmove(Reg*, int, int, int);
+Bits	mkvar(Adr*, int);
+void	prop(Reg*, Bits, Bits);
+void	loopit(Reg*, long);
+void	synch(Reg*, Bits);
+ulong	allreg(ulong, Rgn*);
+void	paint1(Reg*, int);
+ulong	paint2(Reg*, int);
+void	paint3(Reg*, int, long, int);
+void	addreg(Adr*, int);
+
+/*
+ * peep.c
+ */
+void	peep(void);
+void	excise(Reg*);
+Reg*	uniqp(Reg*);
+Reg*	uniqs(Reg*);
+int	regtyp(Adr*);
+int	regzer(Adr*);
+int	anyvar(Adr*);
+int	subprop(Reg*);
+int	copyprop(Reg*);
+int	shiftprop(Reg*);
+void	constprop(Adr*, Adr*, Reg*);
+int	copy1(Adr*, Adr*, Reg*, int);
+int	copyu(Prog*, Adr*, Adr*);
+
+int	copyas(Adr*, Adr*);
+int	copyau(Adr*, Adr*);
+int	copyau1(Prog*, Adr*);
+int	copysub(Adr*, Adr*, Adr*, int);
+int	copysub1(Prog*, Adr*, Adr*, int);
+
+long	RtoB(int);
+long	FtoB(int);
+int	BtoR(long);
+int	BtoF(long);
+
+void	predicate(void); 
+int	isbranch(Prog *); 
+int	predicable(Prog *p); 
+int	modifiescpsr(Prog *p); 
+
+#pragma	varargck	type	"A"	int
+#pragma	varargck	type	"B"	Bits
+#pragma	varargck	type	"D"	Adr*
+#pragma	varargck	type	"N"	Adr*
+#pragma	varargck	type	"R"	Adr*
+#pragma	varargck	type	"P"	Prog*
+#pragma	varargck	type	"S"	char*
diff --git a/src/cmd/5c/list.c b/src/cmd/5c/list.c
new file mode 100644
index 0000000000..14454abb05
--- /dev/null
+++ b/src/cmd/5c/list.c
@@ -0,0 +1,334 @@
+// Inferno utils/5c/list.c
+// http://code.google.com/p/inferno-os/source/browse/utils/5c/list.c
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#define	EXTERN
+#include "gc.h"
+
+void
+listinit(void)
+{
+
+	fmtinstall('A', Aconv);
+	fmtinstall('P', Pconv);
+	fmtinstall('S', Sconv);
+	fmtinstall('N', Nconv);
+	fmtinstall('B', Bconv);
+	fmtinstall('D', Dconv);
+	fmtinstall('R', Rconv);
+}
+
+int
+Bconv(Fmt *fp)
+{
+	char str[STRINGSZ], ss[STRINGSZ], *s;
+	Bits bits;
+	int i;
+
+	str[0] = 0;
+	bits = va_arg(fp->args, Bits);
+	while(bany(&bits)) {
+		i = bnum(bits);
+		if(str[0])
+			strcat(str, " ");
+		if(var[i].sym == S) {
+			sprint(ss, "$%ld", var[i].offset);
+			s = ss;
+		} else
+			s = var[i].sym->name;
+		if(strlen(str) + strlen(s) + 1 >= STRINGSZ)
+			break;
+		strcat(str, s);
+		bits.b[i/32] &= ~(1L << (i%32));
+	}
+	return fmtstrcpy(fp, str);
+}
+
+char *extra [] = {
+	".EQ", ".NE", ".CS", ".CC", 
+	".MI", ".PL", ".VS", ".VC", 
+	".HI", ".LS", ".GE", ".LT", 
+	".GT", ".LE", "", ".NV",
+};
+
+int
+Pconv(Fmt *fp)
+{
+	char str[STRINGSZ], sc[20];
+	Prog *p;
+	int a, s;
+
+	p = va_arg(fp->args, Prog*);
+	a = p->as;
+	s = p->scond; 
+	strcpy(sc, extra[s & C_SCOND]);
+	if(s & C_SBIT)
+		strcat(sc, ".S");
+	if(s & C_PBIT)
+		strcat(sc, ".P");
+	if(s & C_WBIT)
+		strcat(sc, ".W");
+	if(s & C_UBIT)		/* ambiguous with FBIT */
+		strcat(sc, ".U");
+	if(a == AMOVM) {
+		if(p->from.type == D_CONST)
+			sprint(str, "	%A%s	%R,%D", a, sc, &p->from, &p->to);
+		else
+		if(p->to.type == D_CONST)
+			sprint(str, "	%A%s	%D,%R", a, sc, &p->from, &p->to);
+		else
+			sprint(str, "	%A%s	%D,%D", a, sc, &p->from, &p->to);
+	} else
+	if(a == ADATA)
+		sprint(str, "	%A	%D/%d,%D", a, &p->from, p->reg, &p->to);
+	else
+	if(p->as == ATEXT)
+		sprint(str, "	%A	%D,%d,%D", a, &p->from, p->reg, &p->to);
+	else
+	if(p->reg == NREG)
+		sprint(str, "	%A%s	%D,%D", a, sc, &p->from, &p->to);
+	else
+	if(p->from.type != D_FREG)
+		sprint(str, "	%A%s	%D,R%d,%D", a, sc, &p->from, p->reg, &p->to);
+	else
+		sprint(str, "	%A%s	%D,F%d,%D", a, sc, &p->from, p->reg, &p->to);
+	return fmtstrcpy(fp, str);
+}
+
+int
+Aconv(Fmt *fp)
+{
+	char *s;
+	int a;
+
+	a = va_arg(fp->args, int);
+	s = "???";
+	if(a >= AXXX && a < ALAST)
+		s = anames[a];
+	return fmtstrcpy(fp, s);
+}
+
+int
+Dconv(Fmt *fp)
+{
+	char str[STRINGSZ];
+	Adr *a;
+	char *op;
+	int v;
+
+	a = va_arg(fp->args, Adr*);
+	switch(a->type) {
+
+	default:
+		sprint(str, "GOK-type(%d)", a->type);
+		break;
+
+	case D_NONE:
+		str[0] = 0;
+		if(a->name != D_NONE || a->reg != NREG || a->sym != S)
+			sprint(str, "%N(R%d)(NONE)", a, a->reg);
+		break;
+
+	case D_CONST:
+		if(a->reg != NREG)
+			sprint(str, "$%N(R%d)", a, a->reg);
+		else
+			sprint(str, "$%N", a);
+		break;
+
+	case D_SHIFT:
+		v = a->offset;
+		op = "<<>>->@>" + (((v>>5) & 3) << 1);
+		if(v & (1<<4))
+			sprint(str, "R%d%c%cR%d", v&15, op[0], op[1], (v>>8)&15);
+		else
+			sprint(str, "R%d%c%c%d", v&15, op[0], op[1], (v>>7)&31);
+		if(a->reg != NREG)
+			sprint(str+strlen(str), "(R%d)", a->reg);
+		break;
+
+	case D_OREG:
+		if(a->reg != NREG)
+			sprint(str, "%N(R%d)", a, a->reg);
+		else
+			sprint(str, "%N", a);
+		break;
+
+	case D_REG:
+		sprint(str, "R%d", a->reg);
+		if(a->name != D_NONE || a->sym != S)
+			sprint(str, "%N(R%d)(REG)", a, a->reg);
+		break;
+
+	case D_FREG:
+		sprint(str, "F%d", a->reg);
+		if(a->name != D_NONE || a->sym != S)
+			sprint(str, "%N(R%d)(REG)", a, a->reg);
+		break;
+
+	case D_PSR:
+		sprint(str, "PSR");
+		if(a->name != D_NONE || a->sym != S)
+			sprint(str, "%N(PSR)(REG)", a);
+		break;
+
+	case D_BRANCH:
+		sprint(str, "%ld(PC)", a->offset-pc);
+		break;
+
+	case D_FCONST:
+		sprint(str, "$%.17e", a->dval);
+		break;
+
+	case D_SCONST:
+		sprint(str, "$\"%S\"", a->sval);
+		break;
+	}
+	return fmtstrcpy(fp, str);
+}
+
+int
+Rconv(Fmt *fp)
+{
+	char str[STRINGSZ];
+	Adr *a;
+	int i, v;
+
+	a = va_arg(fp->args, Adr*);
+	sprint(str, "GOK-reglist");
+	switch(a->type) {
+	case D_CONST:
+		if(a->reg != NREG)
+			break;
+		if(a->sym != S)
+			break;
+		v = a->offset;
+		strcpy(str, "");
+		for(i=0; i<NREG; i++) {
+			if(v & (1<<i)) {
+				if(str[0] == 0)
+					strcat(str, "[R");
+				else
+					strcat(str, ",R");
+				sprint(strchr(str, 0), "%d", i);
+			}
+		}
+		strcat(str, "]");
+	}
+	return fmtstrcpy(fp, str);
+}
+
+int
+Sconv(Fmt *fp)
+{
+	int i, c;
+	char str[STRINGSZ], *p, *a;
+
+	a = va_arg(fp->args, char*);
+	p = str;
+	for(i=0; i<NSNAME; i++) {
+		c = a[i] & 0xff;
+		if(c >= 'a' && c <= 'z' ||
+		   c >= 'A' && c <= 'Z' ||
+		   c >= '0' && c <= '9' ||
+		   c == ' ' || c == '%') {
+			*p++ = c;
+			continue;
+		}
+		*p++ = '\\';
+		switch(c) {
+		case 0:
+			*p++ = 'z';
+			continue;
+		case '\\':
+		case '"':
+			*p++ = c;
+			continue;
+		case '\n':
+			*p++ = 'n';
+			continue;
+		case '\t':
+			*p++ = 't';
+			continue;
+		case '\r':
+			*p++ = 'r';
+			continue;
+		case '\f':
+			*p++ = 'f';
+			continue;
+		}
+		*p++ = (c>>6) + '0';
+		*p++ = ((c>>3) & 7) + '0';
+		*p++ = (c & 7) + '0';
+	}
+	*p = 0;
+	return fmtstrcpy(fp, str);
+}
+
+int
+Nconv(Fmt *fp)
+{
+	char str[STRINGSZ];
+	Adr *a;
+	Sym *s;
+
+	a = va_arg(fp->args, Adr*);
+	s = a->sym;
+	if(s == S) {
+		sprint(str, "%ld", a->offset);
+		goto out;
+	}
+	switch(a->name) {
+	default:
+		sprint(str, "GOK-name(%d)", a->name);
+		break;
+
+	case D_NONE:
+		sprint(str, "%ld", a->offset);
+		break;
+
+	case D_EXTERN:
+		sprint(str, "%s+%ld(SB)", s->name, a->offset);
+		break;
+
+	case D_STATIC:
+		sprint(str, "%s<>+%ld(SB)", s->name, a->offset);
+		break;
+
+	case D_AUTO:
+		sprint(str, "%s-%ld(SP)", s->name, -a->offset);
+		break;
+
+	case D_PARAM:
+		sprint(str, "%s+%ld(FP)", s->name, a->offset);
+		break;
+	}
+out:
+	return fmtstrcpy(fp, str);
+}
diff --git a/src/cmd/5c/mkenam b/src/cmd/5c/mkenam
new file mode 100644
index 0000000000..565e7e7f4a
--- /dev/null
+++ b/src/cmd/5c/mkenam
@@ -0,0 +1,45 @@
+# Inferno utils/5c/mkenam
+# http://code.google.com/p/inferno-os/source/browse/utils/5c/mkenam
+#
+#	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+#	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+#	Portions Copyright © 1997-1999 Vita Nuova Limited
+#	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+#	Portions Copyright © 2004,2006 Bruce Ellis
+#	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+#	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+#	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+# THE SOFTWARE.
+
+ed - ../5c/5.out.h <<'!'
+v/^	A/d
+,s/^	A/	"/
+g/ .*$/s///
+,s/,*$/",/
+1i
+char*	anames[] =
+{
+.
+$a
+};
+.
+w enam.c
+Q
+!
diff --git a/src/cmd/5c/mul.c b/src/cmd/5c/mul.c
new file mode 100644
index 0000000000..133ffa2d37
--- /dev/null
+++ b/src/cmd/5c/mul.c
@@ -0,0 +1,639 @@
+// Inferno utils/5c/mul.c
+// http://code.google.com/p/inferno-os/source/browse/utils/5c/mul.c
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#include "gc.h"
+
+/*
+ * code sequences for multiply by constant.
+ * [a-l][0-3]
+ *	lsl	$(A-'a'),r0,r1
+ * [+][0-7]
+ *	add	r0,r1,r2
+ * [-][0-7]
+ *	sub	r0,r1,r2
+ */
+
+static  int	maxmulops = 3;	/* max # of ops to replace mul with */
+static	int	multabp;
+static	long	mulval;
+static	char*	mulcp;
+static	long	valmax;
+static	int	shmax;
+
+static int	docode(char *hp, char *cp, int r0, int r1);
+static int	gen1(int len);
+static int	gen2(int len, long r1);
+static int	gen3(int len, long r0, long r1, int flag);
+enum
+{
+	SR1	= 1<<0,		/* r1 has been shifted */
+	SR0	= 1<<1,		/* r0 has been shifted */
+	UR1	= 1<<2,		/* r1 has not been used */
+	UR0	= 1<<3,		/* r0 has not been used */
+};
+
+Multab*
+mulcon0(long v)
+{
+	int a1, a2, g;
+	Multab *m, *m1;
+	char hint[10];
+
+	if(v < 0)
+		v = -v;
+
+	/*
+	 * look in cache
+	 */
+	m = multab;
+	for(g=0; g<nelem(multab); g++) {
+		if(m->val == v) {
+			if(m->code[0] == 0)
+				return 0;
+			return m;
+		}
+		m++;
+	}
+
+	/*
+	 * select a spot in cache to overwrite
+	 */
+	multabp++;
+	if(multabp < 0 || multabp >= nelem(multab))
+		multabp = 0;
+	m = multab+multabp;
+	m->val = v;
+	mulval = v;
+
+	/*
+	 * look in execption hint table
+	 */
+	a1 = 0;
+	a2 = hintabsize;
+	for(;;) {
+		if(a1 >= a2)
+			goto no;
+		g = (a2 + a1)/2;
+		if(v < hintab[g].val) {
+			a2 = g;
+			continue;
+		}
+		if(v > hintab[g].val) {
+			a1 = g+1;
+			continue;
+		}
+		break;
+	}
+
+	if(docode(hintab[g].hint, m->code, 1, 0))
+		return m;
+	print("multiply table failure %ld\n", v);
+	m->code[0] = 0;
+	return 0;
+
+no:
+	/*
+	 * try to search
+	 */
+	hint[0] = 0;
+	for(g=1; g<=maxmulops; g++) {
+		if(g >= maxmulops && v >= 65535)
+			break;
+		mulcp = hint+g;
+		*mulcp = 0;
+		if(gen1(g)) {
+			if(docode(hint, m->code, 1, 0))
+				return m;
+			print("multiply table failure %ld\n", v);
+			break;
+		}
+	}
+
+	/*
+	 * try a recur followed by a shift
+	 */
+	g = 0;
+	while(!(v & 1)) {
+		g++;
+		v >>= 1;
+	}
+	if(g) {
+		m1 = mulcon0(v);
+		if(m1) {
+			strcpy(m->code, m1->code);
+			sprint(strchr(m->code, 0), "%c0", g+'a');
+			return m;
+		}
+	}
+	m->code[0] = 0;
+	return 0;
+}
+
+static int
+docode(char *hp, char *cp, int r0, int r1)
+{
+	int c, i;
+
+	c = *hp++;
+	*cp = c;
+	cp += 2;
+	switch(c) {
+	default:
+		c -= 'a';
+		if(c < 1 || c >= 30)
+			break;
+		for(i=0; i<4; i++) {
+			switch(i) {
+			case 0:
+				if(docode(hp, cp, r0<<c, r1))
+					goto out;
+				break;
+			case 1:
+				if(docode(hp, cp, r1<<c, r1))
+					goto out;
+				break;
+			case 2:
+				if(docode(hp, cp, r0, r0<<c))
+					goto out;
+				break;
+			case 3:
+				if(docode(hp, cp, r0, r1<<c))
+					goto out;
+				break;
+			}
+		}
+		break;
+
+	case '+':
+		for(i=0; i<8; i++) {
+			cp[-1] = i+'0';
+			switch(i) {
+			case 1:
+				if(docode(hp, cp, r0+r1, r1))
+					goto out;
+				break;
+			case 5:
+				if(docode(hp, cp, r0, r0+r1))
+					goto out;
+				break;
+			}
+		}
+		break;
+
+	case '-':
+		for(i=0; i<8; i++) {
+			cp[-1] = i+'0';
+			switch(i) {
+			case 1:
+				if(docode(hp, cp, r0-r1, r1))
+					goto out;
+				break;
+			case 2:
+				if(docode(hp, cp, r1-r0, r1))
+					goto out;
+				break;
+			case 5:
+				if(docode(hp, cp, r0, r0-r1))
+					goto out;
+				break;
+			case 6:
+				if(docode(hp, cp, r0, r1-r0))
+					goto out;
+				break;
+			}
+		}
+		break;
+
+	case 0:
+		if(r0 == mulval)
+			return 1;
+	}
+	return 0;
+
+out:
+	cp[-1] = i+'0';
+	return 1;
+}
+
+static int
+gen1(int len)
+{
+	int i;
+
+	for(shmax=1; shmax<30; shmax++) {
+		valmax = 1<<shmax;
+		if(valmax >= mulval)
+			break;
+	}
+	if(mulval == 1)
+		return 1;
+
+	len--;
+	for(i=1; i<=shmax; i++)
+		if(gen2(len, 1<<i)) {
+			*--mulcp = 'a'+i;
+			return 1;
+		}
+	return 0;
+}
+
+static int
+gen2(int len, long r1)
+{
+	int i;
+
+	if(len <= 0) {
+		if(r1 == mulval)
+			return 1;
+		return 0;
+	}
+
+	len--;
+	if(len == 0)
+		goto calcr0;
+
+	if(gen3(len, r1, r1+1, UR1)) {
+		i = '+';
+		goto out;
+	}
+	if(gen3(len, r1-1, r1, UR0)) {
+		i = '-';
+		goto out;
+	}
+	if(gen3(len, 1, r1+1, UR1)) {
+		i = '+';
+		goto out;
+	}
+	if(gen3(len, 1, r1-1, UR1)) {
+		i = '-';
+		goto out;
+	}
+
+	return 0;
+
+calcr0:
+	if(mulval == r1+1) {
+		i = '+';
+		goto out;
+	}
+	if(mulval == r1-1) {
+		i = '-';
+		goto out;
+	}
+	return 0;
+
+out:
+	*--mulcp = i;
+	return 1;
+}
+
+static int
+gen3(int len, long r0, long r1, int flag)
+{
+	int i, f1, f2;
+	long x;
+
+	if(r0 <= 0 ||
+	   r0 >= r1 ||
+	   r1 > valmax)
+		return 0;
+
+	len--;
+	if(len == 0)
+		goto calcr0;
+
+	if(!(flag & UR1)) {
+		f1 = UR1|SR1;
+		for(i=1; i<=shmax; i++) {
+			x = r0<<i;
+			if(x > valmax)
+				break;
+			if(gen3(len, r0, x, f1)) {
+				i += 'a';
+				goto out;
+			}
+		}
+	}
+
+	if(!(flag & UR0)) {
+		f1 = UR1|SR1;
+		for(i=1; i<=shmax; i++) {
+			x = r1<<i;
+			if(x > valmax)
+				break;
+			if(gen3(len, r1, x, f1)) {
+				i += 'a';
+				goto out;
+			}
+		}
+	}
+
+	if(!(flag & SR1)) {
+		f1 = UR1|SR1|(flag&UR0);
+		for(i=1; i<=shmax; i++) {
+			x = r1<<i;
+			if(x > valmax)
+				break;
+			if(gen3(len, r0, x, f1)) {
+				i += 'a';
+				goto out;
+			}
+		}
+	}
+
+	if(!(flag & SR0)) {
+		f1 = UR0|SR0|(flag&(SR1|UR1));
+
+		f2 = UR1|SR1;
+		if(flag & UR1)
+			f2 |= UR0;
+		if(flag & SR1)
+			f2 |= SR0;
+
+		for(i=1; i<=shmax; i++) {
+			x = r0<<i;
+			if(x > valmax)
+				break;
+			if(x > r1) {
+				if(gen3(len, r1, x, f2)) {
+					i += 'a';
+					goto out;
+				}
+			} else
+				if(gen3(len, x, r1, f1)) {
+					i += 'a';
+					goto out;
+				}
+		}
+	}
+
+	x = r1+r0;
+	if(gen3(len, r0, x, UR1)) {
+		i = '+';
+		goto out;
+	}
+
+	if(gen3(len, r1, x, UR1)) {
+		i = '+';
+		goto out;
+	}
+
+	x = r1-r0;
+	if(gen3(len, x, r1, UR0)) {
+		i = '-';
+		goto out;
+	}
+
+	if(x > r0) {
+		if(gen3(len, r0, x, UR1)) {
+			i = '-';
+			goto out;
+		}
+	} else
+		if(gen3(len, x, r0, UR0)) {
+			i = '-';
+			goto out;
+		}
+
+	return 0;
+
+calcr0:
+	f1 = flag & (UR0|UR1);
+	if(f1 == UR1) {
+		for(i=1; i<=shmax; i++) {
+			x = r1<<i;
+			if(x >= mulval) {
+				if(x == mulval) {
+					i += 'a';
+					goto out;
+				}
+				break;
+			}
+		}
+	}
+
+	if(mulval == r1+r0) {
+		i = '+';
+		goto out;
+	}
+	if(mulval == r1-r0) {
+		i = '-';
+		goto out;
+	}
+
+	return 0;
+
+out:
+	*--mulcp = i;
+	return 1;
+}
+
+/*
+ * hint table has numbers that
+ * the search algorithm fails on.
+ * <1000:
+ *	all numbers
+ * <5000:
+ * 	÷ by 5
+ * <10000:
+ * 	÷ by 50
+ * <65536:
+ * 	÷ by 250
+ */
+Hintab	hintab[] =
+{
+	683,	"b++d+e+",
+	687,	"b+e++e-",
+	691,	"b++d+e+",
+	731,	"b++d+e+",
+	811,	"b++d+i+",
+	821,	"b++e+e+",
+	843,	"b+d++e+",
+	851,	"b+f-+e-",
+	853,	"b++e+e+",
+	877,	"c++++g-",
+	933,	"b+c++g-",
+	981,	"c-+e-d+",
+	1375,	"b+c+b+h-",
+	1675,	"d+b++h+",
+	2425,	"c++f-e+",
+	2675,	"c+d++f-",
+	2750,	"b+d-b+h-",
+	2775,	"c-+g-e-",
+	3125,	"b++e+g+",
+	3275,	"b+c+g+e+",
+	3350,	"c++++i+",
+	3475,	"c-+e-f-",
+	3525,	"c-+d+g-",
+	3625,	"c-+e-j+",
+	3675,	"b+d+d+e+",
+	3725,	"b+d-+h+",
+	3925,	"b+d+f-d-",
+	4275,	"b+g++e+",
+	4325,	"b+h-+d+",
+	4425,	"b+b+g-j-",
+	4525,	"b+d-d+f+",
+	4675,	"c++d-g+",
+	4775,	"b+d+b+g-",
+	4825,	"c+c-+i-",
+	4850,	"c++++i-",
+	4925,	"b++e-g-",
+	4975,	"c+f++e-",
+	5500,	"b+g-c+d+",
+	6700,	"d+b++i+",
+	9700,	"d++++j-",
+	11000,	"b+f-c-h-",
+	11750,	"b+d+g+j-",
+	12500,	"b+c+e-k+",
+	13250,	"b+d+e-f+",
+	13750,	"b+h-c-d+",
+	14250,	"b+g-c+e-",
+	14500,	"c+f+j-d-",
+	14750,	"d-g--f+",
+	16750,	"b+e-d-n+",
+	17750,	"c+h-b+e+",
+	18250,	"d+b+h-d+",
+	18750,	"b+g-++f+",
+	19250,	"b+e+b+h+",
+	19750,	"b++h--f-",
+	20250,	"b+e-l-c+",
+	20750,	"c++bi+e-",
+	21250,	"b+i+l+c+",
+	22000,	"b+e+d-g-",
+	22250,	"b+d-h+k-",
+	22750,	"b+d-e-g+",
+	23250,	"b+c+h+e-",
+	23500,	"b+g-c-g-",
+	23750,	"b+g-b+h-",
+	24250,	"c++g+m-",
+	24750,	"b+e+e+j-",
+	25000,	"b++dh+g+",
+	25250,	"b+e+d-g-",
+	25750,	"b+e+b+j+",
+	26250,	"b+h+c+e+",
+	26500,	"b+h+c+g+",
+	26750,	"b+d+e+g-",
+	27250,	"b+e+e+f+",
+	27500,	"c-i-c-d+",
+	27750,	"b+bd++j+",
+	28250,	"d-d-++i-",
+	28500,	"c+c-h-e-",
+	29000,	"b+g-d-f+",
+	29500,	"c+h+++e-",
+	29750,	"b+g+f-c+",
+	30250,	"b+f-g-c+",
+	33500,	"c-f-d-n+",
+	33750,	"b+d-b+j-",
+	34250,	"c+e+++i+",
+	35250,	"e+b+d+k+",
+	35500,	"c+e+d-g-",
+	35750,	"c+i-++e+",
+	36250,	"b+bh-d+e+",
+	36500,	"c+c-h-e-",
+	36750,	"d+e--i+",
+	37250,	"b+g+g+b+",
+	37500,	"b+h-b+f+",
+	37750,	"c+be++j-",
+	38500,	"b+e+b+i+",
+	38750,	"d+i-b+d+",
+	39250,	"b+g-l-+d+",
+	39500,	"b+g-c+g-",
+	39750,	"b+bh-c+f-",
+	40250,	"b+bf+d+g-",
+	40500,	"b+g-c+g+",
+	40750,	"c+b+i-e+",
+	41250,	"d++bf+h+",
+	41500,	"b+j+c+d-",
+	41750,	"c+f+b+h-",
+	42500,	"c+h++g+",
+	42750,	"b+g+d-f-",
+	43250,	"b+l-e+d-",
+	43750,	"c+bd+h+f-",
+	44000,	"b+f+g-d-",
+	44250,	"b+d-g--f+",
+	44500,	"c+e+c+h+",
+	44750,	"b+e+d-h-",
+	45250,	"b++g+j-g+",
+	45500,	"c+d+e-g+",
+	45750,	"b+d-h-e-",
+	46250,	"c+bd++j+",
+	46500,	"b+d-c-j-",
+	46750,	"e-e-b+g-",
+	47000,	"b+c+d-j-",
+	47250,	"b+e+e-g-",
+	47500,	"b+g-c-h-",
+	47750,	"b+f-c+h-",
+	48250,	"d--h+n-",
+	48500,	"b+c-g+m-",
+	48750,	"b+e+e-g+",
+	49500,	"c-f+e+j-",
+	49750,	"c+c+g++f-",
+	50000,	"b+e+e+k+",
+	50250,	"b++i++g+",
+	50500,	"c+g+f-i+",
+	50750,	"b+e+d+k-",
+	51500,	"b+i+c-f+",
+	51750,	"b+bd+g-e-",
+	52250,	"b+d+g-j+",
+	52500,	"c+c+f+g+",
+	52750,	"b+c+e+i+",
+	53000,	"b+i+c+g+",
+	53500,	"c+g+g-n+",
+	53750,	"b+j+d-c+",
+	54250,	"b+d-g-j-",
+	54500,	"c-f+e+f+",
+	54750,	"b+f-+c+g+",
+	55000,	"b+g-d-g-",
+	55250,	"b+e+e+g+",
+	55500,	"b+cd++j+",
+	55750,	"b+bh-d-f-",
+	56250,	"c+d-b+j-",
+	56500,	"c+d+c+i+",
+	56750,	"b+e+d++h-",
+	57000,	"b+d+g-f+",
+	57250,	"b+f-m+d-",
+	57750,	"b+i+c+e-",
+	58000,	"b+e+d+h+",
+	58250,	"c+b+g+g+",
+	58750,	"d-e-j--e+",
+	59000,	"d-i-+e+",
+	59250,	"e--h-m+",
+	59500,	"c+c-h+f-",
+	59750,	"b+bh-e+i-",
+	60250,	"b+bh-e-e-",
+	60500,	"c+c-g-g-",
+	60750,	"b+e-l-e-",
+	61250,	"b+g-g-c+",
+	61750,	"b+g-c+g+",
+	62250,	"f--+c-i-",
+	62750,	"e+f--+g+",
+	64750,	"b+f+d+p-",
+};
+int	hintabsize	= nelem(hintab);
diff --git a/src/cmd/5c/peep.c b/src/cmd/5c/peep.c
new file mode 100644
index 0000000000..4959d414d4
--- /dev/null
+++ b/src/cmd/5c/peep.c
@@ -0,0 +1,1471 @@
+// Inferno utils/5c/peep.c
+// http://code.google.com/p/inferno-os/source/browse/utils/5c/peep.c
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+
+#include "gc.h"
+
+int xtramodes(Reg*, Adr*);
+
+void
+peep(void)
+{
+	Reg *r, *r1, *r2;
+	Prog *p, *p1;
+	int t;
+/*
+ * complete R structure
+ */
+	t = 0;
+	for(r=firstr; r!=R; r=r1) {
+		r1 = r->link;
+		if(r1 == R)
+			break;
+		p = r->prog->link;
+		while(p != r1->prog)
+		switch(p->as) {
+		default:
+			r2 = rega();
+			r->link = r2;
+			r2->link = r1;
+
+			r2->prog = p;
+			r2->p1 = r;
+			r->s1 = r2;
+			r2->s1 = r1;
+			r1->p1 = r2;
+
+			r = r2;
+			t++;
+
+		case ADATA:
+		case AGLOBL:
+		case ANAME:
+		case ASIGNAME:
+			p = p->link;
+		}
+	}
+
+loop1:
+	t = 0;
+	for(r=firstr; r!=R; r=r->link) {
+		p = r->prog;
+		if(p->as == ASLL || p->as == ASRL || p->as == ASRA) {
+			/*
+			 * elide shift into D_SHIFT operand of subsequent instruction
+			 */
+			if(shiftprop(r)) {
+				excise(r);
+				t++;
+			}
+		}
+		if(p->as == AMOVW || p->as == AMOVF || p->as == AMOVD)
+		if(regtyp(&p->to)) {
+			if(p->from.type == D_CONST)
+				constprop(&p->from, &p->to, r->s1);
+			else if(regtyp(&p->from))
+			if(p->from.type == p->to.type) {
+				if(copyprop(r)) {
+					excise(r);
+					t++;
+				} else
+				if(subprop(r) && copyprop(r)) {
+					excise(r);
+					t++;
+				}
+			}
+		}
+	}
+	if(t)
+		goto loop1;
+	/*
+	 * look for MOVB x,R; MOVB R,R
+	 */
+	for(r=firstr; r!=R; r=r->link) {
+		p = r->prog;
+		switch(p->as) {
+		default:
+			continue;
+		case AEOR:
+			/*
+			 * EOR -1,x,y => MVN x,y
+			 */
+			if(p->from.type == D_CONST && p->from.offset == -1) {
+				p->as = AMVN;
+				p->from.type = D_REG;
+				if(p->reg != NREG)
+					p->from.reg = p->reg;
+				else
+					p->from.reg = p->to.reg;
+				p->reg = NREG;
+			}
+			continue;
+		case AMOVH:
+		case AMOVHU:
+		case AMOVB:
+		case AMOVBU:
+			if(p->to.type != D_REG)
+				continue;
+			break;
+		}
+		r1 = r->link;
+		if(r1 == R)
+			continue;
+		p1 = r1->prog;
+		if(p1->as != p->as)
+			continue;
+		if(p1->from.type != D_REG || p1->from.reg != p->to.reg)
+			continue;
+		if(p1->to.type != D_REG || p1->to.reg != p->to.reg)
+			continue;
+		excise(r1);
+	}
+
+	for(r=firstr; r!=R; r=r->link) {
+		p = r->prog;
+		switch(p->as) {
+		case AMOVW:
+		case AMOVB:
+		case AMOVBU:
+			if(p->from.type == D_OREG && p->from.offset == 0)
+				xtramodes(r, &p->from);
+			else if(p->to.type == D_OREG && p->to.offset == 0)
+				xtramodes(r, &p->to);
+			else
+				continue;
+			break;
+		case ACMP:
+			/*
+			 * elide CMP $0,x if calculation of x can set condition codes
+			 */
+			if(p->from.type != D_CONST || p->from.offset != 0)
+				continue;
+			r2 = r->s1;
+			if(r2 == R)
+				continue;
+			t = r2->prog->as;
+			switch(t) {
+			default:
+				continue;
+			case ABEQ:
+			case ABNE:
+			case ABMI:
+			case ABPL:
+				break;
+			case ABGE:
+				t = ABPL;
+				break;
+			case ABLT:
+				t = ABMI;
+				break;
+			case ABHI:
+				t = ABNE;
+				break;
+			case ABLS:
+				t = ABEQ;
+				break;
+			}
+			r1 = r;
+			do
+				r1 = uniqp(r1);
+			while (r1 != R && r1->prog->as == ANOP);
+			if(r1 == R)
+				continue;
+			p1 = r1->prog;
+			if(p1->to.type != D_REG)
+				continue;
+			if(p1->to.reg != p->reg)
+			if(!(p1->as == AMOVW && p1->from.type == D_REG && p1->from.reg == p->reg))
+				continue;
+			switch(p1->as) {
+			default:
+				continue;
+			case AMOVW:
+				if(p1->from.type != D_REG)
+					continue;
+			case AAND:
+			case AEOR:
+			case AORR:
+			case ABIC:
+			case AMVN:
+			case ASUB:
+			case ARSB:
+			case AADD:
+			case AADC:
+			case ASBC:
+			case ARSC:
+				break;
+			}
+			p1->scond |= C_SBIT;
+			r2->prog->as = t;
+			excise(r);
+			continue;
+		}
+	}
+
+	predicate();
+}
+
+void
+excise(Reg *r)
+{
+	Prog *p;
+
+	p = r->prog;
+	p->as = ANOP;
+	p->scond = zprog.scond;
+	p->from = zprog.from;
+	p->to = zprog.to;
+	p->reg = zprog.reg; /**/
+}
+
+Reg*
+uniqp(Reg *r)
+{
+	Reg *r1;
+
+	r1 = r->p1;
+	if(r1 == R) {
+		r1 = r->p2;
+		if(r1 == R || r1->p2link != R)
+			return R;
+	} else
+		if(r->p2 != R)
+			return R;
+	return r1;
+}
+
+Reg*
+uniqs(Reg *r)
+{
+	Reg *r1;
+
+	r1 = r->s1;
+	if(r1 == R) {
+		r1 = r->s2;
+		if(r1 == R)
+			return R;
+	} else
+		if(r->s2 != R)
+			return R;
+	return r1;
+}
+
+int
+regtyp(Adr *a)
+{
+
+	if(a->type == D_REG)
+		return 1;
+	if(a->type == D_FREG)
+		return 1;
+	return 0;
+}
+
+/*
+ * the idea is to substitute
+ * one register for another
+ * from one MOV to another
+ *	MOV	a, R0
+ *	ADD	b, R0	/ no use of R1
+ *	MOV	R0, R1
+ * would be converted to
+ *	MOV	a, R1
+ *	ADD	b, R1
+ *	MOV	R1, R0
+ * hopefully, then the former or latter MOV
+ * will be eliminated by copy propagation.
+ */
+int
+subprop(Reg *r0)
+{
+	Prog *p;
+	Adr *v1, *v2;
+	Reg *r;
+	int t;
+
+	p = r0->prog;
+	v1 = &p->from;
+	if(!regtyp(v1))
+		return 0;
+	v2 = &p->to;
+	if(!regtyp(v2))
+		return 0;
+	for(r=uniqp(r0); r!=R; r=uniqp(r)) {
+		if(uniqs(r) == R)
+			break;
+		p = r->prog;
+		switch(p->as) {
+		case ABL:
+			return 0;
+
+		case ACMP:
+		case ACMN:
+		case AADD:
+		case ASUB:
+		case ARSB:
+		case ASLL:
+		case ASRL:
+		case ASRA:
+		case AORR:
+		case AAND:
+		case AEOR:
+		case AMUL:
+		case ADIV:
+		case ADIVU:
+
+		case ACMPF:
+		case ACMPD:
+		case AADDD:
+		case AADDF:
+		case ASUBD:
+		case ASUBF:
+		case AMULD:
+		case AMULF:
+		case ADIVD:
+		case ADIVF:
+			if(p->to.type == v1->type)
+			if(p->to.reg == v1->reg) {
+				if(p->reg == NREG)
+					p->reg = p->to.reg;
+				goto gotit;
+			}
+			break;
+
+		case AMOVF:
+		case AMOVD:
+		case AMOVW:
+			if(p->to.type == v1->type)
+			if(p->to.reg == v1->reg)
+				goto gotit;
+			break;
+
+		case AMOVM:
+			t = 1<<v2->reg;
+			if((p->from.type == D_CONST && (p->from.offset&t)) ||
+			   (p->to.type == D_CONST && (p->to.offset&t)))
+				return 0;
+			break;
+		}
+		if(copyau(&p->from, v2) ||
+		   copyau1(p, v2) ||
+		   copyau(&p->to, v2))
+			break;
+		if(copysub(&p->from, v1, v2, 0) ||
+		   copysub1(p, v1, v2, 0) ||
+		   copysub(&p->to, v1, v2, 0))
+			break;
+	}
+	return 0;
+
+gotit:
+	copysub(&p->to, v1, v2, 1);
+	if(debug['P']) {
+		print("gotit: %D->%D\n%P", v1, v2, r->prog);
+		if(p->from.type == v2->type)
+			print(" excise");
+		print("\n");
+	}
+	for(r=uniqs(r); r!=r0; r=uniqs(r)) {
+		p = r->prog;
+		copysub(&p->from, v1, v2, 1);
+		copysub1(p, v1, v2, 1);
+		copysub(&p->to, v1, v2, 1);
+		if(debug['P'])
+			print("%P\n", r->prog);
+	}
+	t = v1->reg;
+	v1->reg = v2->reg;
+	v2->reg = t;
+	if(debug['P'])
+		print("%P last\n", r->prog);
+	return 1;
+}
+
+/*
+ * The idea is to remove redundant copies.
+ *	v1->v2	F=0
+ *	(use v2	s/v2/v1/)*
+ *	set v1	F=1
+ *	use v2	return fail
+ *	-----------------
+ *	v1->v2	F=0
+ *	(use v2	s/v2/v1/)*
+ *	set v1	F=1
+ *	set v2	return success
+ */
+int
+copyprop(Reg *r0)
+{
+	Prog *p;
+	Adr *v1, *v2;
+	Reg *r;
+
+	p = r0->prog;
+	v1 = &p->from;
+	v2 = &p->to;
+	if(copyas(v1, v2))
+		return 1;
+	for(r=firstr; r!=R; r=r->link)
+		r->active = 0;
+	return copy1(v1, v2, r0->s1, 0);
+}
+
+int
+copy1(Adr *v1, Adr *v2, Reg *r, int f)
+{
+	int t;
+	Prog *p;
+
+	if(r->active) {
+		if(debug['P'])
+			print("act set; return 1\n");
+		return 1;
+	}
+	r->active = 1;
+	if(debug['P'])
+		print("copy %D->%D f=%d\n", v1, v2, f);
+	for(; r != R; r = r->s1) {
+		p = r->prog;
+		if(debug['P'])
+			print("%P", p);
+		if(!f && uniqp(r) == R) {
+			f = 1;
+			if(debug['P'])
+				print("; merge; f=%d", f);
+		}
+		t = copyu(p, v2, A);
+		switch(t) {
+		case 2:	/* rar, cant split */
+			if(debug['P'])
+				print("; %Drar; return 0\n", v2);
+			return 0;
+
+		case 3:	/* set */
+			if(debug['P'])
+				print("; %Dset; return 1\n", v2);
+			return 1;
+
+		case 1:	/* used, substitute */
+		case 4:	/* use and set */
+			if(f) {
+				if(!debug['P'])
+					return 0;
+				if(t == 4)
+					print("; %Dused+set and f=%d; return 0\n", v2, f);
+				else
+					print("; %Dused and f=%d; return 0\n", v2, f);
+				return 0;
+			}
+			if(copyu(p, v2, v1)) {
+				if(debug['P'])
+					print("; sub fail; return 0\n");
+				return 0;
+			}
+			if(debug['P'])
+				print("; sub%D/%D", v2, v1);
+			if(t == 4) {
+				if(debug['P'])
+					print("; %Dused+set; return 1\n", v2);
+				return 1;
+			}
+			break;
+		}
+		if(!f) {
+			t = copyu(p, v1, A);
+			if(!f && (t == 2 || t == 3 || t == 4)) {
+				f = 1;
+				if(debug['P'])
+					print("; %Dset and !f; f=%d", v1, f);
+			}
+		}
+		if(debug['P'])
+			print("\n");
+		if(r->s2)
+			if(!copy1(v1, v2, r->s2, f))
+				return 0;
+	}
+	return 1;
+}
+
+/*
+ * The idea is to remove redundant constants.
+ *	$c1->v1
+ *	($c1->v2 s/$c1/v1)*
+ *	set v1  return
+ * The v1->v2 should be eliminated by copy propagation.
+ */
+void
+constprop(Adr *c1, Adr *v1, Reg *r)
+{
+	Prog *p;
+
+	if(debug['C'])
+		print("constprop %D->%D\n", c1, v1);
+	for(; r != R; r = r->s1) {
+		p = r->prog;
+		if(debug['C'])
+			print("%P", p);
+		if(uniqp(r) == R) {
+			if(debug['C'])
+				print("; merge; return\n");
+			return;
+		}
+		if(p->as == AMOVW && copyas(&p->from, c1)) {
+				if(debug['C'])
+					print("; sub%D/%D", &p->from, v1);
+				p->from = *v1;
+		} else if(copyu(p, v1, A) > 1) {
+			if(debug['C'])
+				print("; %Dset; return\n", v1);
+			return;
+		}
+		if(debug['C'])
+			print("\n");
+		if(r->s2)
+			constprop(c1, v1, r->s2);
+	}
+}
+
+/*
+ * ASLL x,y,w
+ * .. (not use w, not set x y w)
+ * AXXX w,a,b (a != w)
+ * .. (not use w)
+ * (set w)
+ * ----------- changed to
+ * ..
+ * AXXX (x<<y),a,b
+ * ..
+ */
+#define FAIL(msg) { if(debug['H']) print("\t%s; FAILURE\n", msg); return 0; }
+int
+shiftprop(Reg *r)
+{
+	Reg *r1;
+	Prog *p, *p1, *p2;
+	int n, o;
+	Adr a;
+
+	p = r->prog;
+	if(p->to.type != D_REG)
+		FAIL("BOTCH: result not reg");
+	n = p->to.reg;
+	a = zprog.from;
+	if(p->reg != NREG && p->reg != p->to.reg) {
+		a.type = D_REG;
+		a.reg = p->reg;
+	}
+	if(debug['H'])
+		print("shiftprop\n%P", p);
+	r1 = r;
+	for(;;) {
+		/* find first use of shift result; abort if shift operands or result are changed */
+		r1 = uniqs(r1);
+		if(r1 == R)
+			FAIL("branch");
+		if(uniqp(r1) == R)
+			FAIL("merge");
+		p1 = r1->prog;
+		if(debug['H'])
+			print("\n%P", p1);
+		switch(copyu(p1, &p->to, A)) {
+		case 0:	/* not used or set */
+			if((p->from.type == D_REG && copyu(p1, &p->from, A) > 1) ||
+			   (a.type == D_REG && copyu(p1, &a, A) > 1))
+				FAIL("args modified");
+			continue;
+		case 3:	/* set, not used */
+			FAIL("BOTCH: noref");
+		}
+		break;
+	}
+	/* check whether substitution can be done */
+	switch(p1->as) {
+	default:
+		FAIL("non-dpi");
+	case AAND:
+	case AEOR:
+	case AADD:
+	case AADC:
+	case AORR:
+	case ASUB:
+	case ARSB:
+	case ASBC:
+	case ARSC:
+		if(p1->reg == n || (p1->reg == NREG && p1->to.type == D_REG && p1->to.reg == n)) {
+			if(p1->from.type != D_REG)
+				FAIL("can't swap");
+			p1->reg = p1->from.reg;
+			p1->from.reg = n;
+			switch(p1->as) {
+			case ASUB:
+				p1->as = ARSB;
+				break;
+			case ARSB:
+				p1->as = ASUB;
+				break;
+			case ASBC:
+				p1->as = ARSC;
+				break;
+			case ARSC:
+				p1->as = ASBC;
+				break;
+			}
+			if(debug['H'])
+				print("\t=>%P", p1);
+		}
+	case ABIC:
+	case ACMP:
+	case ACMN:
+		if(p1->reg == n)
+			FAIL("can't swap");
+		if(p1->reg == NREG && p1->to.reg == n)
+			FAIL("shift result used twice");
+	case AMVN:
+		if(p1->from.type == D_SHIFT)
+			FAIL("shift result used in shift");
+		if(p1->from.type != D_REG || p1->from.reg != n)
+			FAIL("BOTCH: where is it used?");
+		break;
+	}
+	/* check whether shift result is used subsequently */
+	p2 = p1;
+	if(p1->to.reg != n)
+	for (;;) {
+		r1 = uniqs(r1);
+		if(r1 == R)
+			FAIL("inconclusive");
+		p1 = r1->prog;
+		if(debug['H'])
+			print("\n%P", p1);
+		switch(copyu(p1, &p->to, A)) {
+		case 0:	/* not used or set */
+			continue;
+		case 3: /* set, not used */
+			break;
+		default:/* used */
+			FAIL("reused");
+		}
+		break;
+	}
+	/* make the substitution */
+	p2->from.type = D_SHIFT;
+	p2->from.reg = NREG;
+	o = p->reg;
+	if(o == NREG)
+		o = p->to.reg;
+	switch(p->from.type){
+	case D_CONST:
+		o |= (p->from.offset&0x1f)<<7;
+		break;
+	case D_REG:
+		o |= (1<<4) | (p->from.reg<<8);
+		break;
+	}
+	switch(p->as){
+	case ASLL:
+		o |= 0<<5;
+		break;
+	case ASRL:
+		o |= 1<<5;
+		break;
+	case ASRA:
+		o |= 2<<5;
+		break;
+	}
+	p2->from.offset = o;
+	if(debug['H'])
+		print("\t=>%P\tSUCCEED\n", p2);
+	return 1;
+}
+
+Reg*
+findpre(Reg *r, Adr *v)
+{
+	Reg *r1;
+
+	for(r1=uniqp(r); r1!=R; r=r1,r1=uniqp(r)) {
+		if(uniqs(r1) != r)
+			return R;
+		switch(copyu(r1->prog, v, A)) {
+		case 1: /* used */
+		case 2: /* read-alter-rewrite */
+			return R;
+		case 3: /* set */
+		case 4: /* set and used */
+			return r1;
+		}
+	}
+	return R;
+}
+
+Reg*
+findinc(Reg *r, Reg *r2, Adr *v)
+{
+	Reg *r1;
+	Prog *p;
+
+
+	for(r1=uniqs(r); r1!=R && r1!=r2; r=r1,r1=uniqs(r)) {
+		if(uniqp(r1) != r)
+			return R;
+		switch(copyu(r1->prog, v, A)) {
+		case 0: /* not touched */
+			continue;
+		case 4: /* set and used */
+			p = r1->prog;
+			if(p->as == AADD)
+			if(p->from.type == D_CONST)
+			if(p->from.offset > -4096 && p->from.offset < 4096)
+				return r1;
+		default:
+			return R;
+		}
+	}
+	return R;
+}
+
+int
+nochange(Reg *r, Reg *r2, Prog *p)
+{
+	Adr a[3];
+	int i, n;
+
+	if(r == r2)
+		return 1;
+	n = 0;
+	if(p->reg != NREG && p->reg != p->to.reg) {
+		a[n].type = D_REG;
+		a[n++].reg = p->reg;
+	}
+	switch(p->from.type) {
+	case D_SHIFT:
+		a[n].type = D_REG;
+		a[n++].reg = p->from.offset&0xf;
+	case D_REG:
+		a[n].type = D_REG;
+		a[n++].reg = p->from.reg;
+	}
+	if(n == 0)
+		return 1;
+	for(; r!=R && r!=r2; r=uniqs(r)) {
+		p = r->prog;
+		for(i=0; i<n; i++)
+			if(copyu(p, &a[i], A) > 1)
+				return 0;
+	}
+	return 1;
+}
+
+int
+findu1(Reg *r, Adr *v)
+{
+	for(; r != R; r = r->s1) {
+		if(r->active)
+			return 0;
+		r->active = 1;
+		switch(copyu(r->prog, v, A)) {
+		case 1: /* used */
+		case 2: /* read-alter-rewrite */
+		case 4: /* set and used */
+			return 1;
+		case 3: /* set */
+			return 0;
+		}
+		if(r->s2)
+			if (findu1(r->s2, v))
+				return 1;
+	}
+	return 0;
+}
+
+int
+finduse(Reg *r, Adr *v)
+{
+	Reg *r1;
+
+	for(r1=firstr; r1!=R; r1=r1->link)
+		r1->active = 0;
+	return findu1(r, v);
+}
+
+int
+xtramodes(Reg *r, Adr *a)
+{
+	Reg *r1, *r2, *r3;
+	Prog *p, *p1;
+	Adr v;
+
+	p = r->prog;
+	if(debug['h'] && p->as == AMOVB && p->from.type == D_OREG)	/* byte load */
+		return 0;
+	v = *a;
+	v.type = D_REG;
+	r1 = findpre(r, &v);
+	if(r1 != R) {
+		p1 = r1->prog;
+		if(p1->to.type == D_REG && p1->to.reg == v.reg)
+		switch(p1->as) {
+		case AADD:
+			if(p1->from.type == D_REG ||
+			   (p1->from.type == D_SHIFT && (p1->from.offset&(1<<4)) == 0 &&
+			    (p->as != AMOVB || (a == &p->from && (p1->from.offset&~0xf) == 0))) ||
+			   (p1->from.type == D_CONST &&
+			    p1->from.offset > -4096 && p1->from.offset < 4096))
+			if(nochange(uniqs(r1), r, p1)) {
+				if(a != &p->from || v.reg != p->to.reg)
+				if (finduse(r->s1, &v)) {
+					if(p1->reg == NREG || p1->reg == v.reg)
+						/* pre-indexing */
+						p->scond |= C_WBIT;
+					else return 0;
+				}
+				switch (p1->from.type) {
+				case D_REG:
+					/* register offset */
+					a->type = D_SHIFT;
+					a->offset = p1->from.reg;
+					break;
+				case D_SHIFT:
+					/* scaled register offset */
+					a->type = D_SHIFT;
+				case D_CONST:
+					/* immediate offset */
+					a->offset = p1->from.offset;
+					break;
+				}
+				if(p1->reg != NREG)
+					a->reg = p1->reg;
+				excise(r1);
+				return 1;
+			}
+			break;
+		case AMOVW:
+			if(p1->from.type == D_REG)
+			if((r2 = findinc(r1, r, &p1->from)) != R) {
+			for(r3=uniqs(r2); r3->prog->as==ANOP; r3=uniqs(r3))
+				;
+			if(r3 == r) {
+				/* post-indexing */
+				p1 = r2->prog;
+				a->reg = p1->to.reg;
+				a->offset = p1->from.offset;
+				p->scond |= C_PBIT;
+				if(!finduse(r, &r1->prog->to))
+					excise(r1);
+				excise(r2);
+				return 1;
+			}
+			}
+			break;
+		}
+	}
+	if(a != &p->from || a->reg != p->to.reg)
+	if((r1 = findinc(r, R, &v)) != R) {
+		/* post-indexing */
+		p1 = r1->prog;
+		a->offset = p1->from.offset;
+		p->scond |= C_PBIT;
+		excise(r1);
+		return 1;
+	}
+	return 0;
+}
+
+/*
+ * return
+ * 1 if v only used (and substitute),
+ * 2 if read-alter-rewrite
+ * 3 if set
+ * 4 if set and used
+ * 0 otherwise (not touched)
+ */
+int
+copyu(Prog *p, Adr *v, Adr *s)
+{
+
+	switch(p->as) {
+
+	default:
+		if(debug['P'])
+			print(" (?)");
+		return 2;
+
+	case AMOVM:
+		if(v->type != D_REG)
+			return 0;
+		if(p->from.type == D_CONST) {	/* read reglist, read/rar */
+			if(s != A) {
+				if(p->from.offset&(1<<v->reg))
+					return 1;
+				if(copysub(&p->to, v, s, 1))
+					return 1;
+				return 0;
+			}
+			if(copyau(&p->to, v)) {
+				if(p->scond&C_WBIT)
+					return 2;
+				return 1;
+			}
+			if(p->from.offset&(1<<v->reg))
+				return 1;
+		} else {			/* read/rar, write reglist */
+			if(s != A) {
+				if(p->to.offset&(1<<v->reg))
+					return 1;
+				if(copysub(&p->from, v, s, 1))
+					return 1;
+				return 0;
+			}
+			if(copyau(&p->from, v)) {
+				if(p->scond&C_WBIT)
+					return 2;
+				if(p->to.offset&(1<<v->reg))
+					return 4;
+				return 1;
+			}
+			if(p->to.offset&(1<<v->reg))
+				return 3;
+		}
+		return 0;
+
+	case ANOP:	/* read, write */
+	case AMOVW:
+	case AMOVF:
+	case AMOVD:
+	case AMOVH:
+	case AMOVHU:
+	case AMOVB:
+	case AMOVBU:
+	case AMOVDW:
+	case AMOVWD:
+	case AMOVFD:
+	case AMOVDF:
+		if(p->scond&(C_WBIT|C_PBIT))
+		if(v->type == D_REG) {
+			if(p->from.type == D_OREG || p->from.type == D_SHIFT) {
+				if(p->from.reg == v->reg)
+					return 2;
+			} else {
+		  		if(p->to.reg == v->reg)
+				return 2;
+			}
+		}
+		if(s != A) {
+			if(copysub(&p->from, v, s, 1))
+				return 1;
+			if(!copyas(&p->to, v))
+				if(copysub(&p->to, v, s, 1))
+					return 1;
+			return 0;
+		}
+		if(copyas(&p->to, v)) {
+			if(copyau(&p->from, v))
+				return 4;
+			return 3;
+		}
+		if(copyau(&p->from, v))
+			return 1;
+		if(copyau(&p->to, v))
+			return 1;
+		return 0;
+
+
+	case AADD:	/* read, read, write */
+	case ASUB:
+	case ARSB:
+	case ASLL:
+	case ASRL:
+	case ASRA:
+	case AORR:
+	case AAND:
+	case AEOR:
+	case AMUL:
+	case ADIV:
+	case ADIVU:
+	case AADDF:
+	case AADDD:
+	case ASUBF:
+	case ASUBD:
+	case AMULF:
+	case AMULD:
+	case ADIVF:
+	case ADIVD:
+
+	case ACMPF:
+	case ACMPD:
+	case ACMP:
+	case ACMN:
+	case ACASE:
+		if(s != A) {
+			if(copysub(&p->from, v, s, 1))
+				return 1;
+			if(copysub1(p, v, s, 1))
+				return 1;
+			if(!copyas(&p->to, v))
+				if(copysub(&p->to, v, s, 1))
+					return 1;
+			return 0;
+		}
+		if(copyas(&p->to, v)) {
+			if(p->reg == NREG)
+				p->reg = p->to.reg;
+			if(copyau(&p->from, v))
+				return 4;
+			if(copyau1(p, v))
+				return 4;
+			return 3;
+		}
+		if(copyau(&p->from, v))
+			return 1;
+		if(copyau1(p, v))
+			return 1;
+		if(copyau(&p->to, v))
+			return 1;
+		return 0;
+
+	case ABEQ:	/* read, read */
+	case ABNE:
+	case ABCS:
+	case ABHS:
+	case ABCC:
+	case ABLO:
+	case ABMI:
+	case ABPL:
+	case ABVS:
+	case ABVC:
+	case ABHI:
+	case ABLS:
+	case ABGE:
+	case ABLT:
+	case ABGT:
+	case ABLE:
+		if(s != A) {
+			if(copysub(&p->from, v, s, 1))
+				return 1;
+			return copysub1(p, v, s, 1);
+		}
+		if(copyau(&p->from, v))
+			return 1;
+		if(copyau1(p, v))
+			return 1;
+		return 0;
+
+	case AB:	/* funny */
+		if(s != A) {
+			if(copysub(&p->to, v, s, 1))
+				return 1;
+			return 0;
+		}
+		if(copyau(&p->to, v))
+			return 1;
+		return 0;
+
+	case ARET:	/* funny */
+		if(v->type == D_REG)
+		if(v->reg == REGRET)
+			return 2;
+		if(v->type == D_FREG)
+		if(v->reg == FREGRET)
+			return 2;
+
+	case ABL:	/* funny */
+		if(v->type == D_REG) {
+			if(v->reg <= REGEXT && v->reg > exregoffset)
+				return 2;
+			if(v->reg == REGARG)
+				return 2;
+		}
+		if(v->type == D_FREG)
+			if(v->reg <= FREGEXT && v->reg > exfregoffset)
+				return 2;
+
+		if(s != A) {
+			if(copysub(&p->to, v, s, 1))
+				return 1;
+			return 0;
+		}
+		if(copyau(&p->to, v))
+			return 4;
+		return 3;
+
+	case ATEXT:	/* funny */
+		if(v->type == D_REG)
+			if(v->reg == REGARG)
+				return 3;
+		return 0;
+	}
+	return 0;
+}
+
+int
+a2type(Prog *p)
+{
+
+	switch(p->as) {
+
+	case ACMP:
+	case ACMN:
+
+	case AADD:
+	case ASUB:
+	case ARSB:
+	case ASLL:
+	case ASRL:
+	case ASRA:
+	case AORR:
+	case AAND:
+	case AEOR:
+	case AMUL:
+	case ADIV:
+	case ADIVU:
+		return D_REG;
+
+	case ACMPF:
+	case ACMPD:
+
+	case AADDF:
+	case AADDD:
+	case ASUBF:
+	case ASUBD:
+	case AMULF:
+	case AMULD:
+	case ADIVF:
+	case ADIVD:
+		return D_FREG;
+	}
+	return D_NONE;
+}
+
+/*
+ * direct reference,
+ * could be set/use depending on
+ * semantics
+ */
+int
+copyas(Adr *a, Adr *v)
+{
+
+	if(regtyp(v)) {
+		if(a->type == v->type)
+		if(a->reg == v->reg)
+			return 1;
+	} else if(v->type == D_CONST) {		/* for constprop */
+		if(a->type == v->type)
+		if(a->name == v->name)
+		if(a->sym == v->sym)
+		if(a->reg == v->reg)
+		if(a->offset == v->offset)
+			return 1;
+	}
+	return 0;
+}
+
+/*
+ * either direct or indirect
+ */
+int
+copyau(Adr *a, Adr *v)
+{
+
+	if(copyas(a, v))
+		return 1;
+	if(v->type == D_REG) {
+		if(a->type == D_OREG) {
+			if(v->reg == a->reg)
+				return 1;
+		} else if(a->type == D_SHIFT) {
+			if((a->offset&0xf) == v->reg)
+				return 1;
+			if((a->offset&(1<<4)) && (a->offset>>8) == v->reg)
+				return 1;
+		}
+	}
+	return 0;
+}
+
+int
+copyau1(Prog *p, Adr *v)
+{
+
+	if(regtyp(v)) {
+		if(a2type(p) == v->type)
+		if(p->reg == v->reg) {
+			if(a2type(p) != v->type)
+				print("botch a2type %P\n", p);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+/*
+ * substitute s for v in a
+ * return failure to substitute
+ */
+int
+copysub(Adr *a, Adr *v, Adr *s, int f)
+{
+
+	if(f)
+	if(copyau(a, v)) {
+		if(a->type == D_SHIFT) {
+			if((a->offset&0xf) == v->reg)
+				a->offset = (a->offset&~0xf)|s->reg;
+			if((a->offset&(1<<4)) && (a->offset>>8) == v->reg)
+				a->offset = (a->offset&~(0xf<<8))|(s->reg<<8);
+		} else
+			a->reg = s->reg;
+	}
+	return 0;
+}
+
+int
+copysub1(Prog *p1, Adr *v, Adr *s, int f)
+{
+
+	if(f)
+	if(copyau1(p1, v))
+		p1->reg = s->reg;
+	return 0;
+}
+
+struct {
+	int opcode;
+	int notopcode;
+	int scond;
+	int notscond;
+} predinfo[]  = {
+	{ ABEQ,	ABNE,	0x0,	0x1, },
+	{ ABNE,	ABEQ,	0x1,	0x0, },
+	{ ABCS,	ABCC,	0x2,	0x3, },
+	{ ABHS,	ABLO,	0x2,	0x3, },
+	{ ABCC,	ABCS,	0x3,	0x2, },
+	{ ABLO,	ABHS,	0x3,	0x2, },
+	{ ABMI,	ABPL,	0x4,	0x5, },
+	{ ABPL,	ABMI,	0x5,	0x4, },
+	{ ABVS,	ABVC,	0x6,	0x7, },
+	{ ABVC,	ABVS,	0x7,	0x6, },
+	{ ABHI,	ABLS,	0x8,	0x9, },
+	{ ABLS,	ABHI,	0x9,	0x8, },
+	{ ABGE,	ABLT,	0xA,	0xB, },
+	{ ABLT,	ABGE,	0xB,	0xA, },
+	{ ABGT,	ABLE,	0xC,	0xD, },
+	{ ABLE,	ABGT,	0xD,	0xC, },
+};
+
+typedef struct {
+	Reg *start;
+	Reg *last;
+	Reg *end;
+	int len;
+} Joininfo;
+
+enum {
+	Join,
+	Split,
+	End,
+	Branch,
+	Setcond,
+	Toolong
+};
+
+enum {
+	Falsecond,
+	Truecond,
+	Delbranch,
+	Keepbranch
+};
+
+int
+isbranch(Prog *p)
+{
+	return (ABEQ <= p->as) && (p->as <= ABLE);
+}
+
+int
+predicable(Prog *p)
+{
+	if (isbranch(p)
+		|| p->as == ANOP
+		|| p->as == AXXX
+		|| p->as == ADATA
+		|| p->as == AGLOBL
+		|| p->as == AGOK
+		|| p->as == AHISTORY
+		|| p->as == ANAME
+		|| p->as == ASIGNAME
+		|| p->as == ATEXT
+		|| p->as == AWORD
+		|| p->as == ADYNT
+		|| p->as == AINIT
+		|| p->as == ABCASE
+		|| p->as == ACASE)
+		return 0;
+	return 1;
+}
+
+/*
+ * Depends on an analysis of the encodings performed by 5l.
+ * These seem to be all of the opcodes that lead to the "S" bit
+ * being set in the instruction encodings.
+ *
+ * C_SBIT may also have been set explicitly in p->scond.
+ */
+int
+modifiescpsr(Prog *p)
+{
+	return (p->scond&C_SBIT)
+		|| p->as == ATST
+		|| p->as == ATEQ
+		|| p->as == ACMN
+		|| p->as == ACMP
+		|| p->as == AMULU
+		|| p->as == ADIVU
+		|| p->as == AMUL
+		|| p->as == ADIV
+		|| p->as == AMOD
+		|| p->as == AMODU
+		|| p->as == ABL;
+}
+
+/*
+ * Find the maximal chain of instructions starting with r which could
+ * be executed conditionally
+ */
+int
+joinsplit(Reg *r, Joininfo *j)
+{
+	j->start = r;
+	j->last = r;
+	j->len = 0;
+	do {
+		if (r->p2 && (r->p1 || r->p2->p2link)) {
+			j->end = r;
+			return Join;
+		}
+		if (r->s1 && r->s2) {
+			j->end = r;
+			return Split;
+		}
+		j->last = r;
+		if (r->prog->as != ANOP)
+			j->len++;
+		if (!r->s1 && !r->s2) {
+			j->end = r->link;
+			return End;
+		}
+		if (r->s2) {
+			j->end = r->s2;
+			return Branch;
+		}
+		if (modifiescpsr(r->prog)) {
+			j->end = r->s1;
+			return Setcond;
+		}
+		r = r->s1;
+	} while (j->len < 4);
+	j->end = r;
+	return Toolong;
+}
+
+Reg *
+successor(Reg *r)
+{
+	if (r->s1)
+		return r->s1;
+	else
+		return r->s2;
+}
+
+void
+applypred(Reg *rstart, Joininfo *j, int cond, int branch)
+{
+	int pred;
+	Reg *r;
+
+	if(j->len == 0)
+		return;
+	if (cond == Truecond)
+		pred = predinfo[rstart->prog->as - ABEQ].scond;
+	else
+		pred = predinfo[rstart->prog->as - ABEQ].notscond;
+
+	for (r = j->start; ; r = successor(r)) {
+		if (r->prog->as == AB) {
+			if (r != j->last || branch == Delbranch)
+				excise(r);
+			else {
+			  if (cond == Truecond)
+				r->prog->as = predinfo[rstart->prog->as - ABEQ].opcode;
+			  else
+				r->prog->as = predinfo[rstart->prog->as - ABEQ].notopcode;
+			}
+		}
+		else if (predicable(r->prog))
+			r->prog->scond = (r->prog->scond&~C_SCOND)|pred;
+		if (r->s1 != r->link) {
+			r->s1 = r->link;
+			r->link->p1 = r;
+		}
+		if (r == j->last)
+			break;
+	}
+}
+
+void
+predicate(void)
+{
+	Reg *r;
+	int t1, t2;
+	Joininfo j1, j2;
+
+	for(r=firstr; r!=R; r=r->link) {
+		if (isbranch(r->prog)) {
+			t1 = joinsplit(r->s1, &j1);
+			t2 = joinsplit(r->s2, &j2);
+			if(j1.last->link != j2.start)
+				continue;
+			if(j1.end == j2.end)
+			if((t1 == Branch && (t2 == Join || t2 == Setcond)) ||
+			   (t2 == Join && (t1 == Join || t1 == Setcond))) {
+				applypred(r, &j1, Falsecond, Delbranch);
+				applypred(r, &j2, Truecond, Delbranch);
+				excise(r);
+				continue;
+			}
+			if(t1 == End || t1 == Branch) {
+				applypred(r, &j1, Falsecond, Keepbranch);
+				excise(r);
+				continue;
+			}
+		}
+	}
+}
diff --git a/src/cmd/5c/reg.c b/src/cmd/5c/reg.c
new file mode 100644
index 0000000000..eb8341d831
--- /dev/null
+++ b/src/cmd/5c/reg.c
@@ -0,0 +1,1187 @@
+// Inferno utils/5c/reg.c
+// http://code.google.com/p/inferno-os/source/browse/utils/5c/reg.c
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#include "gc.h"
+
+void	addsplits(void);
+
+Reg*
+rega(void)
+{
+	Reg *r;
+
+	r = freer;
+	if(r == R) {
+		r = alloc(sizeof(*r));
+	} else
+		freer = r->link;
+
+	*r = zreg;
+	return r;
+}
+
+int
+rcmp(const void *a1, const void *a2)
+{
+	Rgn *p1, *p2;
+	int c1, c2;
+
+	p1 = (Rgn*)a1;
+	p2 = (Rgn*)a2;
+	c1 = p2->cost;
+	c2 = p1->cost;
+	if(c1 -= c2)
+		return c1;
+	return p2->varno - p1->varno;
+}
+
+void
+regopt(Prog *p)
+{
+	Reg *r, *r1, *r2;
+	Prog *p1;
+	int i, z;
+	long initpc, val, npc;
+	ulong vreg;
+	Bits bit;
+	struct
+	{
+		long	m;
+		long	c;
+		Reg*	p;
+	} log5[6], *lp;
+
+	firstr = R;
+	lastr = R;
+	nvar = 0;
+	regbits = 0;
+	for(z=0; z<BITS; z++) {
+		externs.b[z] = 0;
+		params.b[z] = 0;
+		consts.b[z] = 0;
+		addrs.b[z] = 0;
+	}
+
+	/*
+	 * pass 1
+	 * build aux data structure
+	 * allocate pcs
+	 * find use and set of variables
+	 */
+	val = 5L * 5L * 5L * 5L * 5L;
+	lp = log5;
+	for(i=0; i<5; i++) {
+		lp->m = val;
+		lp->c = 0;
+		lp->p = R;
+		val /= 5L;
+		lp++;
+	}
+	val = 0;
+	for(; p != P; p = p->link) {
+		switch(p->as) {
+		case ADATA:
+		case AGLOBL:
+		case ANAME:
+		case ASIGNAME:
+			continue;
+		}
+		r = rega();
+		if(firstr == R) {
+			firstr = r;
+			lastr = r;
+		} else {
+			lastr->link = r;
+			r->p1 = lastr;
+			lastr->s1 = r;
+			lastr = r;
+		}
+		r->prog = p;
+		r->pc = val;
+		val++;
+
+		lp = log5;
+		for(i=0; i<5; i++) {
+			lp->c--;
+			if(lp->c <= 0) {
+				lp->c = lp->m;
+				if(lp->p != R)
+					lp->p->log5 = r;
+				lp->p = r;
+				(lp+1)->c = 0;
+				break;
+			}
+			lp++;
+		}
+
+		r1 = r->p1;
+		if(r1 != R)
+		switch(r1->prog->as) {
+		case ARET:
+		case AB:
+		case ARFE:
+			r->p1 = R;
+			r1->s1 = R;
+		}
+
+		/*
+		 * left side always read
+		 */
+		bit = mkvar(&p->from, p->as==AMOVW);
+		for(z=0; z<BITS; z++)
+			r->use1.b[z] |= bit.b[z];
+
+		/*
+		 * right side depends on opcode
+		 */
+		bit = mkvar(&p->to, 0);
+		if(bany(&bit))
+		switch(p->as) {
+		default:
+			diag(Z, "reg: unknown asop: %A", p->as);
+			break;
+
+		/*
+		 * right side write
+		 */
+		case ANOP:
+		case AMOVB:
+		case AMOVBU:
+		case AMOVH:
+		case AMOVHU:
+		case AMOVW:
+		case AMOVF:
+		case AMOVD:
+			for(z=0; z<BITS; z++)
+				r->set.b[z] |= bit.b[z];
+			break;
+
+		/*
+		 * funny
+		 */
+		case ABL:
+			for(z=0; z<BITS; z++)
+				addrs.b[z] |= bit.b[z];
+			break;
+		}
+
+		if(p->as == AMOVM) {
+			if(p->from.type == D_CONST)
+				z = p->from.offset;
+			else
+				z = p->to.offset;
+			for(i=0; z; i++) {
+				if(z&1)
+					regbits |= RtoB(i);
+				z >>= 1;
+			}
+		}
+	}
+	if(firstr == R)
+		return;
+	initpc = pc - val;
+	npc = val;
+
+	/*
+	 * pass 2
+	 * turn branch references to pointers
+	 * build back pointers
+	 */
+	for(r = firstr; r != R; r = r->link) {
+		p = r->prog;
+		if(p->to.type == D_BRANCH) {
+			val = p->to.offset - initpc;
+			r1 = firstr;
+			while(r1 != R) {
+				r2 = r1->log5;
+				if(r2 != R && val >= r2->pc) {
+					r1 = r2;
+					continue;
+				}
+				if(r1->pc == val)
+					break;
+				r1 = r1->link;
+			}
+			if(r1 == R) {
+				nearln = p->lineno;
+				diag(Z, "ref not found\n%P", p);
+				continue;
+			}
+			if(r1 == r) {
+				nearln = p->lineno;
+				diag(Z, "ref to self\n%P", p);
+				continue;
+			}
+			r->s2 = r1;
+			r->p2link = r1->p2;
+			r1->p2 = r;
+		}
+	}
+	if(debug['R']) {
+		p = firstr->prog;
+		print("\n%L %D\n", p->lineno, &p->from);
+	}
+
+	/*
+	 * pass 2.5
+	 * find looping structure
+	 */
+	for(r = firstr; r != R; r = r->link)
+		r->active = 0;
+	change = 0;
+	loopit(firstr, npc);
+
+	/*
+	 * pass 3
+	 * iterate propagating usage
+	 * 	back until flow graph is complete
+	 */
+loop1:
+	change = 0;
+	for(r = firstr; r != R; r = r->link)
+		r->active = 0;
+	for(r = firstr; r != R; r = r->link)
+		if(r->prog->as == ARET)
+			prop(r, zbits, zbits);
+loop11:
+	/* pick up unreachable code */
+	i = 0;
+	for(r = firstr; r != R; r = r1) {
+		r1 = r->link;
+		if(r1 && r1->active && !r->active) {
+			prop(r, zbits, zbits);
+			i = 1;
+		}
+	}
+	if(i)
+		goto loop11;
+	if(change)
+		goto loop1;
+
+
+	/*
+	 * pass 4
+	 * iterate propagating register/variable synchrony
+	 * 	forward until graph is complete
+	 */
+loop2:
+	change = 0;
+	for(r = firstr; r != R; r = r->link)
+		r->active = 0;
+	synch(firstr, zbits);
+	if(change)
+		goto loop2;
+
+	addsplits();
+
+	if(debug['R'] && debug['v']) {
+		print("\nprop structure:\n");
+		for(r = firstr; r != R; r = r->link) {
+			print("%ld:%P", r->loop, r->prog);
+			for(z=0; z<BITS; z++)
+				bit.b[z] = r->set.b[z] |
+					r->refahead.b[z] | r->calahead.b[z] |
+					r->refbehind.b[z] | r->calbehind.b[z] |
+					r->use1.b[z] | r->use2.b[z];
+			if(bany(&bit)) {
+				print("\t");
+				if(bany(&r->use1))
+					print(" u1=%B", r->use1);
+				if(bany(&r->use2))
+					print(" u2=%B", r->use2);
+				if(bany(&r->set))
+					print(" st=%B", r->set);
+				if(bany(&r->refahead))
+					print(" ra=%B", r->refahead);
+				if(bany(&r->calahead))
+					print(" ca=%B", r->calahead);
+				if(bany(&r->refbehind))
+					print(" rb=%B", r->refbehind);
+				if(bany(&r->calbehind))
+					print(" cb=%B", r->calbehind);
+			}
+			print("\n");
+		}
+	}
+
+	/*
+	 * pass 5
+	 * isolate regions
+	 * calculate costs (paint1)
+	 */
+	r = firstr;
+	if(r) {
+		for(z=0; z<BITS; z++)
+			bit.b[z] = (r->refahead.b[z] | r->calahead.b[z]) &
+			  ~(externs.b[z] | params.b[z] | addrs.b[z] | consts.b[z]);
+		if(bany(&bit)) {
+			nearln = r->prog->lineno;
+			warn(Z, "used and not set: %B", bit);
+			if(debug['R'] && !debug['w'])
+				print("used and not set: %B\n", bit);
+		}
+	}
+
+	for(r = firstr; r != R; r = r->link)
+		r->act = zbits;
+	rgp = region;
+	nregion = 0;
+	for(r = firstr; r != R; r = r->link) {
+		for(z=0; z<BITS; z++)
+			bit.b[z] = r->set.b[z] &
+			  ~(r->refahead.b[z] | r->calahead.b[z] | addrs.b[z]);
+		if(bany(&bit)) {
+			nearln = r->prog->lineno;
+			warn(Z, "set and not used: %B", bit);
+			if(debug['R'])
+				print("set and not used: %B\n", bit);
+			excise(r);
+		}
+		for(z=0; z<BITS; z++)
+			bit.b[z] = LOAD(r) & ~(r->act.b[z] | addrs.b[z]);
+		while(bany(&bit)) {
+			i = bnum(bit);
+			rgp->enter = r;
+			rgp->varno = i;
+			change = 0;
+			if(debug['R'] && debug['v'])
+				print("\n");
+			paint1(r, i);
+			bit.b[i/32] &= ~(1L<<(i%32));
+			if(change <= 0) {
+				if(debug['R'])
+					print("%L $%d: %B\n",
+						r->prog->lineno, change, blsh(i));
+				continue;
+			}
+			rgp->cost = change;
+			nregion++;
+			if(nregion >= NRGN) {
+				warn(Z, "too many regions");
+				goto brk;
+			}
+			rgp++;
+		}
+	}
+brk:
+	qsort(region, nregion, sizeof(region[0]), rcmp);
+
+	/*
+	 * pass 6
+	 * determine used registers (paint2)
+	 * replace code (paint3)
+	 */
+	rgp = region;
+	for(i=0; i<nregion; i++) {
+		bit = blsh(rgp->varno);
+		vreg = paint2(rgp->enter, rgp->varno);
+		vreg = allreg(vreg, rgp);
+		if(debug['R']) {
+			if(rgp->regno >= NREG)
+				print("%L $%d F%d: %B\n",
+					rgp->enter->prog->lineno,
+					rgp->cost,
+					rgp->regno-NREG,
+					bit);
+			else
+				print("%L $%d R%d: %B\n",
+					rgp->enter->prog->lineno,
+					rgp->cost,
+					rgp->regno,
+					bit);
+		}
+		if(rgp->regno != 0)
+			paint3(rgp->enter, rgp->varno, vreg, rgp->regno);
+		rgp++;
+	}
+	/*
+	 * pass 7
+	 * peep-hole on basic block
+	 */
+	if(!debug['R'] || debug['P'])
+		peep();
+
+	/*
+	 * pass 8
+	 * recalculate pc
+	 */
+	val = initpc;
+	for(r = firstr; r != R; r = r1) {
+		r->pc = val;
+		p = r->prog;
+		p1 = P;
+		r1 = r->link;
+		if(r1 != R)
+			p1 = r1->prog;
+		for(; p != p1; p = p->link) {
+			switch(p->as) {
+			default:
+				val++;
+				break;
+
+			case ANOP:
+			case ADATA:
+			case AGLOBL:
+			case ANAME:
+			case ASIGNAME:
+				break;
+			}
+		}
+	}
+	pc = val;
+
+	/*
+	 * fix up branches
+	 */
+	if(debug['R'])
+		if(bany(&addrs))
+			print("addrs: %B\n", addrs);
+
+	r1 = 0; /* set */
+	for(r = firstr; r != R; r = r->link) {
+		p = r->prog;
+		if(p->to.type == D_BRANCH)
+			p->to.offset = r->s2->pc;
+		r1 = r;
+	}
+
+	/*
+	 * last pass
+	 * eliminate nops
+	 * free aux structures
+	 */
+	for(p = firstr->prog; p != P; p = p->link){
+		while(p->link && p->link->as == ANOP)
+			p->link = p->link->link;
+	}
+	if(r1 != R) {
+		r1->link = freer;
+		freer = firstr;
+	}
+}
+
+void
+addsplits(void)
+{
+	Reg *r, *r1;
+	int z, i;
+	Bits bit;
+
+	for(r = firstr; r != R; r = r->link) {
+		if(r->loop > 1)
+			continue;
+		if(r->prog->as == ABL)
+			continue;
+		for(r1 = r->p2; r1 != R; r1 = r1->p2link) {
+			if(r1->loop <= 1)
+				continue;
+			for(z=0; z<BITS; z++)
+				bit.b[z] = r1->calbehind.b[z] &
+					(r->refahead.b[z] | r->use1.b[z] | r->use2.b[z]) &
+					~(r->calahead.b[z] & addrs.b[z]);
+			while(bany(&bit)) {
+				i = bnum(bit);
+				bit.b[i/32] &= ~(1L << (i%32));
+			}
+		}
+	}
+}
+
+/*
+ * add mov b,rn
+ * just after r
+ */
+void
+addmove(Reg *r, int bn, int rn, int f)
+{
+	Prog *p, *p1;
+	Adr *a;
+	Var *v;
+
+	p1 = alloc(sizeof(*p1));
+	*p1 = zprog;
+	p = r->prog;
+
+	p1->link = p->link;
+	p->link = p1;
+	p1->lineno = p->lineno;
+
+	v = var + bn;
+
+	a = &p1->to;
+	a->sym = v->sym;
+	a->name = v->name;
+	a->offset = v->offset;
+	a->etype = v->etype;
+	a->type = D_OREG;
+	if(a->etype == TARRAY || a->sym == S)
+		a->type = D_CONST;
+
+	p1->as = AMOVW;
+	if(v->etype == TCHAR || v->etype == TUCHAR)
+		p1->as = AMOVB;
+	if(v->etype == TSHORT || v->etype == TUSHORT)
+		p1->as = AMOVH;
+	if(v->etype == TFLOAT)
+		p1->as = AMOVF;
+	if(v->etype == TDOUBLE)
+		p1->as = AMOVD;
+
+	p1->from.type = D_REG;
+	p1->from.reg = rn;
+	if(rn >= NREG) {
+		p1->from.type = D_FREG;
+		p1->from.reg = rn-NREG;
+	}
+	if(!f) {
+		p1->from = *a;
+		*a = zprog.from;
+		a->type = D_REG;
+		a->reg = rn;
+		if(rn >= NREG) {
+			a->type = D_FREG;
+			a->reg = rn-NREG;
+		}
+		if(v->etype == TUCHAR)
+			p1->as = AMOVBU;
+		if(v->etype == TUSHORT)
+			p1->as = AMOVHU;
+	}
+	if(debug['R'])
+		print("%P\t.a%P\n", p, p1);
+}
+
+Bits
+mkvar(Adr *a, int docon)
+{
+	Var *v;
+	int i, t, n, et, z;
+	long o;
+	Bits bit;
+	Sym *s;
+
+	t = a->type;
+	if(t == D_REG && a->reg != NREG)
+		regbits |= RtoB(a->reg);
+	if(t == D_FREG && a->reg != NREG)
+		regbits |= FtoB(a->reg);
+	s = a->sym;
+	o = a->offset;
+	et = a->etype;
+	if(s == S) {
+		if(t != D_CONST || !docon || a->reg != NREG)
+			goto none;
+		et = TLONG;
+	}
+	if(t == D_CONST) {
+		if(s == S && sval(o))
+			goto none;
+	}
+
+	n = a->name;
+	v = var;
+	for(i=0; i<nvar; i++) {
+		if(s == v->sym)
+		if(n == v->name)
+		if(o == v->offset)
+			goto out;
+		v++;
+	}
+	if(s)
+		if(s->name[0] == '.')
+			goto none;
+	if(nvar >= NVAR) {
+		if(debug['w'] > 1 && s)
+			warn(Z, "variable not optimized: %s", s->name);
+		goto none;
+	}
+	i = nvar;
+	nvar++;
+	v = &var[i];
+	v->sym = s;
+	v->offset = o;
+	v->etype = et;
+	v->name = n;
+	if(debug['R'])
+		print("bit=%2d et=%2d %D\n", i, et, a);
+out:
+	bit = blsh(i);
+	if(n == D_EXTERN || n == D_STATIC)
+		for(z=0; z<BITS; z++)
+			externs.b[z] |= bit.b[z];
+	if(n == D_PARAM)
+		for(z=0; z<BITS; z++)
+			params.b[z] |= bit.b[z];
+	if(v->etype != et || !typechlpfd[et])	/* funny punning */
+		for(z=0; z<BITS; z++)
+			addrs.b[z] |= bit.b[z];
+	if(t == D_CONST) {
+		if(s == S) {
+			for(z=0; z<BITS; z++)
+				consts.b[z] |= bit.b[z];
+			return bit;
+		}
+		if(et != TARRAY)
+			for(z=0; z<BITS; z++)
+				addrs.b[z] |= bit.b[z];
+		for(z=0; z<BITS; z++)
+			params.b[z] |= bit.b[z];
+		return bit;
+	}
+	if(t == D_OREG)
+		return bit;
+
+none:
+	return zbits;
+}
+
+void
+prop(Reg *r, Bits ref, Bits cal)
+{
+	Reg *r1, *r2;
+	int z;
+
+	for(r1 = r; r1 != R; r1 = r1->p1) {
+		for(z=0; z<BITS; z++) {
+			ref.b[z] |= r1->refahead.b[z];
+			if(ref.b[z] != r1->refahead.b[z]) {
+				r1->refahead.b[z] = ref.b[z];
+				change++;
+			}
+			cal.b[z] |= r1->calahead.b[z];
+			if(cal.b[z] != r1->calahead.b[z]) {
+				r1->calahead.b[z] = cal.b[z];
+				change++;
+			}
+		}
+		switch(r1->prog->as) {
+		case ABL:
+			for(z=0; z<BITS; z++) {
+				cal.b[z] |= ref.b[z] | externs.b[z];
+				ref.b[z] = 0;
+			}
+			break;
+
+		case ATEXT:
+			for(z=0; z<BITS; z++) {
+				cal.b[z] = 0;
+				ref.b[z] = 0;
+			}
+			break;
+
+		case ARET:
+			for(z=0; z<BITS; z++) {
+				cal.b[z] = externs.b[z];
+				ref.b[z] = 0;
+			}
+		}
+		for(z=0; z<BITS; z++) {
+			ref.b[z] = (ref.b[z] & ~r1->set.b[z]) |
+				r1->use1.b[z] | r1->use2.b[z];
+			cal.b[z] &= ~(r1->set.b[z] | r1->use1.b[z] | r1->use2.b[z]);
+			r1->refbehind.b[z] = ref.b[z];
+			r1->calbehind.b[z] = cal.b[z];
+		}
+		if(r1->active)
+			break;
+		r1->active = 1;
+	}
+	for(; r != r1; r = r->p1)
+		for(r2 = r->p2; r2 != R; r2 = r2->p2link)
+			prop(r2, r->refbehind, r->calbehind);
+}
+
+/*
+ * find looping structure
+ *
+ * 1) find reverse postordering
+ * 2) find approximate dominators,
+ *	the actual dominators if the flow graph is reducible
+ *	otherwise, dominators plus some other non-dominators.
+ *	See Matthew S. Hecht and Jeffrey D. Ullman,
+ *	"Analysis of a Simple Algorithm for Global Data Flow Problems",
+ *	Conf.  Record of ACM Symp. on Principles of Prog. Langs, Boston, Massachusetts,
+ *	Oct. 1-3, 1973, pp.  207-217.
+ * 3) find all nodes with a predecessor dominated by the current node.
+ *	such a node is a loop head.
+ *	recursively, all preds with a greater rpo number are in the loop
+ */
+long
+postorder(Reg *r, Reg **rpo2r, long n)
+{
+	Reg *r1;
+
+	r->rpo = 1;
+	r1 = r->s1;
+	if(r1 && !r1->rpo)
+		n = postorder(r1, rpo2r, n);
+	r1 = r->s2;
+	if(r1 && !r1->rpo)
+		n = postorder(r1, rpo2r, n);
+	rpo2r[n] = r;
+	n++;
+	return n;
+}
+
+long
+rpolca(long *idom, long rpo1, long rpo2)
+{
+	long t;
+
+	if(rpo1 == -1)
+		return rpo2;
+	while(rpo1 != rpo2){
+		if(rpo1 > rpo2){
+			t = rpo2;
+			rpo2 = rpo1;
+			rpo1 = t;
+		}
+		while(rpo1 < rpo2){
+			t = idom[rpo2];
+			if(t >= rpo2)
+				fatal(Z, "bad idom");
+			rpo2 = t;
+		}
+	}
+	return rpo1;
+}
+
+int
+doms(long *idom, long r, long s)
+{
+	while(s > r)
+		s = idom[s];
+	return s == r;
+}
+
+int
+loophead(long *idom, Reg *r)
+{
+	long src;
+
+	src = r->rpo;
+	if(r->p1 != R && doms(idom, src, r->p1->rpo))
+		return 1;
+	for(r = r->p2; r != R; r = r->p2link)
+		if(doms(idom, src, r->rpo))
+			return 1;
+	return 0;
+}
+
+void
+loopmark(Reg **rpo2r, long head, Reg *r)
+{
+	if(r->rpo < head || r->active == head)
+		return;
+	r->active = head;
+	r->loop += LOOP;
+	if(r->p1 != R)
+		loopmark(rpo2r, head, r->p1);
+	for(r = r->p2; r != R; r = r->p2link)
+		loopmark(rpo2r, head, r);
+}
+
+void
+loopit(Reg *r, long nr)
+{
+	Reg *r1;
+	long i, d, me;
+
+	if(nr > maxnr) {
+		rpo2r = alloc(nr * sizeof(Reg*));
+		idom = alloc(nr * sizeof(long));
+		maxnr = nr;
+	}
+	d = postorder(r, rpo2r, 0);
+	if(d > nr)
+		fatal(Z, "too many reg nodes");
+	nr = d;
+	for(i = 0; i < nr / 2; i++){
+		r1 = rpo2r[i];
+		rpo2r[i] = rpo2r[nr - 1 - i];
+		rpo2r[nr - 1 - i] = r1;
+	}
+	for(i = 0; i < nr; i++)
+		rpo2r[i]->rpo = i;
+
+	idom[0] = 0;
+	for(i = 0; i < nr; i++){
+		r1 = rpo2r[i];
+		me = r1->rpo;
+		d = -1;
+		if(r1->p1 != R && r1->p1->rpo < me)
+			d = r1->p1->rpo;
+		for(r1 = r1->p2; r1 != nil; r1 = r1->p2link)
+			if(r1->rpo < me)
+				d = rpolca(idom, d, r1->rpo);
+		idom[i] = d;
+	}
+
+	for(i = 0; i < nr; i++){
+		r1 = rpo2r[i];
+		r1->loop++;
+		if(r1->p2 != R && loophead(idom, r1))
+			loopmark(rpo2r, i, r1);
+	}
+}
+
+void
+synch(Reg *r, Bits dif)
+{
+	Reg *r1;
+	int z;
+
+	for(r1 = r; r1 != R; r1 = r1->s1) {
+		for(z=0; z<BITS; z++) {
+			dif.b[z] = (dif.b[z] &
+				~(~r1->refbehind.b[z] & r1->refahead.b[z])) |
+					r1->set.b[z] | r1->regdiff.b[z];
+			if(dif.b[z] != r1->regdiff.b[z]) {
+				r1->regdiff.b[z] = dif.b[z];
+				change++;
+			}
+		}
+		if(r1->active)
+			break;
+		r1->active = 1;
+		for(z=0; z<BITS; z++)
+			dif.b[z] &= ~(~r1->calbehind.b[z] & r1->calahead.b[z]);
+		if(r1->s2 != R)
+			synch(r1->s2, dif);
+	}
+}
+
+ulong
+allreg(ulong b, Rgn *r)
+{
+	Var *v;
+	int i;
+
+	v = var + r->varno;
+	r->regno = 0;
+	switch(v->etype) {
+
+	default:
+		diag(Z, "unknown etype %d/%d", bitno(b), v->etype);
+		break;
+
+	case TCHAR:
+	case TUCHAR:
+	case TSHORT:
+	case TUSHORT:
+	case TINT:
+	case TUINT:
+	case TLONG:
+	case TULONG:
+	case TIND:
+	case TARRAY:
+		i = BtoR(~b);
+		if(i && r->cost >= 0) {
+			r->regno = i;
+			return RtoB(i);
+		}
+		break;
+
+	case TVLONG:
+	case TDOUBLE:
+	case TFLOAT:
+		i = BtoF(~b);
+		if(i && r->cost >= 0) {
+			r->regno = i+NREG;
+			return FtoB(i);
+		}
+		break;
+	}
+	return 0;
+}
+
+void
+paint1(Reg *r, int bn)
+{
+	Reg *r1;
+	Prog *p;
+	int z;
+	ulong bb;
+
+	z = bn/32;
+	bb = 1L<<(bn%32);
+	if(r->act.b[z] & bb)
+		return;
+	for(;;) {
+		if(!(r->refbehind.b[z] & bb))
+			break;
+		r1 = r->p1;
+		if(r1 == R)
+			break;
+		if(!(r1->refahead.b[z] & bb))
+			break;
+		if(r1->act.b[z] & bb)
+			break;
+		r = r1;
+	}
+
+	if(LOAD(r) & ~(r->set.b[z] & ~(r->use1.b[z]|r->use2.b[z])) & bb) {
+		change -= CLOAD * r->loop;
+		if(debug['R'] && debug['v'])
+			print("%ld%P\tld %B $%d\n", r->loop,
+				r->prog, blsh(bn), change);
+	}
+	for(;;) {
+		r->act.b[z] |= bb;
+		p = r->prog;
+
+		if(r->use1.b[z] & bb) {
+			change += CREF * r->loop;
+			if(debug['R'] && debug['v'])
+				print("%ld%P\tu1 %B $%d\n", r->loop,
+					p, blsh(bn), change);
+		}
+
+		if((r->use2.b[z]|r->set.b[z]) & bb) {
+			change += CREF * r->loop;
+			if(debug['R'] && debug['v'])
+				print("%ld%P\tu2 %B $%d\n", r->loop,
+					p, blsh(bn), change);
+		}
+
+		if(STORE(r) & r->regdiff.b[z] & bb) {
+			change -= CLOAD * r->loop;
+			if(debug['R'] && debug['v'])
+				print("%ld%P\tst %B $%d\n", r->loop,
+					p, blsh(bn), change);
+		}
+
+		if(r->refbehind.b[z] & bb)
+			for(r1 = r->p2; r1 != R; r1 = r1->p2link)
+				if(r1->refahead.b[z] & bb)
+					paint1(r1, bn);
+
+		if(!(r->refahead.b[z] & bb))
+			break;
+		r1 = r->s2;
+		if(r1 != R)
+			if(r1->refbehind.b[z] & bb)
+				paint1(r1, bn);
+		r = r->s1;
+		if(r == R)
+			break;
+		if(r->act.b[z] & bb)
+			break;
+		if(!(r->refbehind.b[z] & bb))
+			break;
+	}
+}
+
+ulong
+paint2(Reg *r, int bn)
+{
+	Reg *r1;
+	int z;
+	ulong bb, vreg;
+
+	z = bn/32;
+	bb = 1L << (bn%32);
+	vreg = regbits;
+	if(!(r->act.b[z] & bb))
+		return vreg;
+	for(;;) {
+		if(!(r->refbehind.b[z] & bb))
+			break;
+		r1 = r->p1;
+		if(r1 == R)
+			break;
+		if(!(r1->refahead.b[z] & bb))
+			break;
+		if(!(r1->act.b[z] & bb))
+			break;
+		r = r1;
+	}
+	for(;;) {
+		r->act.b[z] &= ~bb;
+
+		vreg |= r->regu;
+
+		if(r->refbehind.b[z] & bb)
+			for(r1 = r->p2; r1 != R; r1 = r1->p2link)
+				if(r1->refahead.b[z] & bb)
+					vreg |= paint2(r1, bn);
+
+		if(!(r->refahead.b[z] & bb))
+			break;
+		r1 = r->s2;
+		if(r1 != R)
+			if(r1->refbehind.b[z] & bb)
+				vreg |= paint2(r1, bn);
+		r = r->s1;
+		if(r == R)
+			break;
+		if(!(r->act.b[z] & bb))
+			break;
+		if(!(r->refbehind.b[z] & bb))
+			break;
+	}
+	return vreg;
+}
+
+void
+paint3(Reg *r, int bn, long rb, int rn)
+{
+	Reg *r1;
+	Prog *p;
+	int z;
+	ulong bb;
+
+	z = bn/32;
+	bb = 1L << (bn%32);
+	if(r->act.b[z] & bb)
+		return;
+	for(;;) {
+		if(!(r->refbehind.b[z] & bb))
+			break;
+		r1 = r->p1;
+		if(r1 == R)
+			break;
+		if(!(r1->refahead.b[z] & bb))
+			break;
+		if(r1->act.b[z] & bb)
+			break;
+		r = r1;
+	}
+
+	if(LOAD(r) & ~(r->set.b[z] & ~(r->use1.b[z]|r->use2.b[z])) & bb)
+		addmove(r, bn, rn, 0);
+	for(;;) {
+		r->act.b[z] |= bb;
+		p = r->prog;
+
+		if(r->use1.b[z] & bb) {
+			if(debug['R'])
+				print("%P", p);
+			addreg(&p->from, rn);
+			if(debug['R'])
+				print("\t.c%P\n", p);
+		}
+		if((r->use2.b[z]|r->set.b[z]) & bb) {
+			if(debug['R'])
+				print("%P", p);
+			addreg(&p->to, rn);
+			if(debug['R'])
+				print("\t.c%P\n", p);
+		}
+
+		if(STORE(r) & r->regdiff.b[z] & bb)
+			addmove(r, bn, rn, 1);
+		r->regu |= rb;
+
+		if(r->refbehind.b[z] & bb)
+			for(r1 = r->p2; r1 != R; r1 = r1->p2link)
+				if(r1->refahead.b[z] & bb)
+					paint3(r1, bn, rb, rn);
+
+		if(!(r->refahead.b[z] & bb))
+			break;
+		r1 = r->s2;
+		if(r1 != R)
+			if(r1->refbehind.b[z] & bb)
+				paint3(r1, bn, rb, rn);
+		r = r->s1;
+		if(r == R)
+			break;
+		if(r->act.b[z] & bb)
+			break;
+		if(!(r->refbehind.b[z] & bb))
+			break;
+	}
+}
+
+void
+addreg(Adr *a, int rn)
+{
+
+	a->sym = 0;
+	a->name = D_NONE;
+	a->type = D_REG;
+	a->reg = rn;
+	if(rn >= NREG) {
+		a->type = D_FREG;
+		a->reg = rn-NREG;
+	}
+}
+
+/*
+ *	bit	reg
+ *	0	R0
+ *	1	R1
+ *	...	...
+ *	10	R10
+ */
+long
+RtoB(int r)
+{
+
+	if(r < 2 || r >= REGTMP)
+		return 0;
+	return 1L << r;
+}
+
+int
+BtoR(long b)
+{
+	b &= 0x07fcL;
+	if(b == 0)
+		return 0;
+	return bitno(b);
+}
+
+/*
+ *	bit	reg
+ *	18	F2
+ *	19	F3
+ *	...	...
+ *	23	F7
+ */
+long
+FtoB(int f)
+{
+
+	if(f < 2 || f > NFREG-1)
+		return 0;
+	return 1L << (f + 16);
+}
+
+int
+BtoF(long b)
+{
+
+	b &= 0xfc0000L;
+	if(b == 0)
+		return 0;
+	return bitno(b) - 16;
+}
diff --git a/src/cmd/5c/sgen.c b/src/cmd/5c/sgen.c
new file mode 100644
index 0000000000..3b7c8ee809
--- /dev/null
+++ b/src/cmd/5c/sgen.c
@@ -0,0 +1,643 @@
+// Inferno utils/5c/sgen.c
+// http://code.google.com/p/inferno-os/source/browse/utils/5c/sgen.c
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#include "gc.h"
+
+void
+codgen(Node *n, Node *nn)
+{
+	Prog *sp;
+	Node *n1, nod, nod1;
+
+	cursafe = 0;
+	curarg = 0;
+	maxargsafe = 0;
+
+	/*
+	 * isolate name
+	 */
+	for(n1 = nn;; n1 = n1->left) {
+		if(n1 == Z) {
+			diag(nn, "cant find function name");
+			return;
+		}
+		if(n1->op == ONAME)
+			break;
+	}
+	nearln = nn->lineno;
+	gpseudo(ATEXT, n1->sym, nodconst(stkoff));
+	sp = p;
+
+	/*
+	 * isolate first argument
+	 */
+	if(REGARG >= 0) {
+		if(typesuv[thisfn->link->etype]) {
+			nod1 = *nodret->left;
+			nodreg(&nod, &nod1, REGARG);
+			gopcode(OAS, &nod, Z, &nod1);
+		} else
+		if(firstarg && typechlp[firstargtype->etype]) {
+			nod1 = *nodret->left;
+			nod1.sym = firstarg;
+			nod1.type = firstargtype;
+			nod1.xoffset = align(0, firstargtype, Aarg1);
+			nod1.etype = firstargtype->etype;
+			nodreg(&nod, &nod1, REGARG);
+			gopcode(OAS, &nod, Z, &nod1);
+		}
+	}
+
+	retok = 0;
+	gen(n);
+	if(!retok)
+		if(thisfn->link->etype != TVOID)
+			warn(Z, "no return at end of function: %s", n1->sym->name);
+	noretval(3);
+	gbranch(ORETURN);
+
+	if(!debug['N'] || debug['R'] || debug['P'])
+		regopt(sp);
+
+	sp->to.offset += maxargsafe;
+}
+
+void
+supgen(Node *n)
+{
+	long spc;
+	Prog *sp;
+
+	if(n == Z)
+		return;
+	suppress++;
+	spc = pc;
+	sp = lastp;
+	gen(n);
+	lastp = sp;
+	pc = spc;
+	sp->link = nil;
+	suppress--;
+}
+
+void
+gen(Node *n)
+{
+	Node *l, nod;
+	Prog *sp, *spc, *spb;
+	Case *cn;
+	long sbc, scc;
+	int o, f;
+
+loop:
+	if(n == Z)
+		return;
+	nearln = n->lineno;
+	o = n->op;
+	if(debug['G'])
+		if(o != OLIST)
+			print("%L %O\n", nearln, o);
+
+	retok = 0;
+	switch(o) {
+
+	default:
+		complex(n);
+		cgen(n, Z, 0);
+		break;
+
+	case OLIST:
+		gen(n->left);
+
+	rloop:
+		n = n->right;
+		goto loop;
+
+	case ORETURN:
+		retok = 1;
+		complex(n);
+		if(n->type == T)
+			break;
+		l = n->left;
+		if(l == Z) {
+			noretval(3);
+			gbranch(ORETURN);
+			break;
+		}
+		if(typesuv[n->type->etype]) {
+			sugen(l, nodret, n->type->width);
+			noretval(3);
+			gbranch(ORETURN);
+			break;
+		}
+		regret(&nod, n);
+		cgen(l, &nod, 0);
+		regfree(&nod);
+		if(typefd[n->type->etype])
+			noretval(1);
+		else
+			noretval(2);
+		gbranch(ORETURN);
+		break;
+
+	case OLABEL:
+		l = n->left;
+		if(l) {
+			l->pc = pc;
+			if(l->label)
+				patch(l->label, pc);
+		}
+		gbranch(OGOTO);	/* prevent self reference in reg */
+		patch(p, pc);
+		goto rloop;
+
+	case OGOTO:
+		retok = 1;
+		n = n->left;
+		if(n == Z)
+			return;
+		if(n->complex == 0) {
+			diag(Z, "label undefined: %s", n->sym->name);
+			return;
+		}
+		if(suppress)
+			return;
+		gbranch(OGOTO);
+		if(n->pc) {
+			patch(p, n->pc);
+			return;
+		}
+		if(n->label)
+			patch(n->label, pc-1);
+		n->label = p;
+		return;
+
+	case OCASE:
+		l = n->left;
+		if(cases == C)
+			diag(n, "case/default outside a switch");
+		if(l == Z) {
+			cas();
+			cases->val = 0;
+			cases->def = 1;
+			cases->label = pc;
+			goto rloop;
+		}
+		complex(l);
+		if(l->type == T)
+			goto rloop;
+		if(l->op == OCONST)
+		if(typechl[l->type->etype]) {
+			cas();
+			cases->val = l->vconst;
+			cases->def = 0;
+			cases->label = pc;
+			goto rloop;
+		}
+		diag(n, "case expression must be integer constant");
+		goto rloop;
+
+	case OSWITCH:
+		l = n->left;
+		complex(l);
+		if(l->type == T)
+			break;
+		if(!typechl[l->type->etype]) {
+			diag(n, "switch expression must be integer");
+			break;
+		}
+
+		gbranch(OGOTO);		/* entry */
+		sp = p;
+
+		cn = cases;
+		cases = C;
+		cas();
+
+		sbc = breakpc;
+		breakpc = pc;
+		gbranch(OGOTO);
+		spb = p;
+
+		gen(n->right);
+		gbranch(OGOTO);
+		patch(p, breakpc);
+
+		patch(sp, pc);
+		regalloc(&nod, l, Z);
+		nod.type = types[TLONG];
+		cgen(l, &nod, 0);
+		doswit(&nod);
+		regfree(&nod);
+		patch(spb, pc);
+
+		cases = cn;
+		breakpc = sbc;
+		break;
+
+	case OWHILE:
+	case ODWHILE:
+		l = n->left;
+		gbranch(OGOTO);		/* entry */
+		sp = p;
+
+		scc = continpc;
+		continpc = pc;
+		gbranch(OGOTO);
+		spc = p;
+
+		sbc = breakpc;
+		breakpc = pc;
+		gbranch(OGOTO);
+		spb = p;
+
+		patch(spc, pc);
+		if(n->op == OWHILE)
+			patch(sp, pc);
+		bcomplex(l, Z);		/* test */
+		patch(p, breakpc);
+
+		if(n->op == ODWHILE)
+			patch(sp, pc);
+		gen(n->right);		/* body */
+		gbranch(OGOTO);
+		patch(p, continpc);
+
+		patch(spb, pc);
+		continpc = scc;
+		breakpc = sbc;
+		break;
+
+	case OFOR:
+		l = n->left;
+		gen(l->right->left);	/* init */
+		gbranch(OGOTO);		/* entry */
+		sp = p;
+
+		scc = continpc;
+		continpc = pc;
+		gbranch(OGOTO);
+		spc = p;
+
+		sbc = breakpc;
+		breakpc = pc;
+		gbranch(OGOTO);
+		spb = p;
+
+		patch(spc, pc);
+		gen(l->right->right);	/* inc */
+		patch(sp, pc);	
+		if(l->left != Z) {	/* test */
+			bcomplex(l->left, Z);
+			patch(p, breakpc);
+		}
+		gen(n->right);		/* body */
+		gbranch(OGOTO);
+		patch(p, continpc);
+
+		patch(spb, pc);
+		continpc = scc;
+		breakpc = sbc;
+		break;
+
+	case OCONTINUE:
+		if(continpc < 0) {
+			diag(n, "continue not in a loop");
+			break;
+		}
+		gbranch(OGOTO);
+		patch(p, continpc);
+		break;
+
+	case OBREAK:
+		if(breakpc < 0) {
+			diag(n, "break not in a loop");
+			break;
+		}
+		gbranch(OGOTO);
+		patch(p, breakpc);
+		break;
+
+	case OIF:
+		l = n->left;
+		if(bcomplex(l, n->right)) {
+			if(typefd[l->type->etype])
+				f = !l->fconst;
+			else
+				f = !l->vconst;
+			if(debug['c'])
+				print("%L const if %s\n", nearln, f ? "false" : "true");
+			if(f) {
+				supgen(n->right->left);
+				gen(n->right->right);
+			}
+			else {
+				gen(n->right->left);
+				supgen(n->right->right);
+			}
+		}
+		else {
+			sp = p;
+			if(n->right->left != Z)
+				gen(n->right->left);
+			if(n->right->right != Z) {
+				gbranch(OGOTO);
+				patch(sp, pc);
+				sp = p;
+				gen(n->right->right);
+			}
+			patch(sp, pc);
+		}
+		break;
+
+	case OSET:
+	case OUSED:
+		usedset(n->left, o);
+		break;
+	}
+}
+
+void
+usedset(Node *n, int o)
+{
+	if(n->op == OLIST) {
+		usedset(n->left, o);
+		usedset(n->right, o);
+		return;
+	}
+	complex(n);
+	switch(n->op) {
+	case OADDR:	/* volatile */
+		gins(ANOP, n, Z);
+		break;
+	case ONAME:
+		if(o == OSET)
+			gins(ANOP, Z, n);
+		else
+			gins(ANOP, n, Z);
+		break;
+	}
+}
+
+void
+noretval(int n)
+{
+
+	if(n & 1) {
+		gins(ANOP, Z, Z);
+		p->to.type = D_REG;
+		p->to.reg = REGRET;
+	}
+	if(n & 2) {
+		gins(ANOP, Z, Z);
+		p->to.type = D_FREG;
+		p->to.reg = FREGRET;
+	}
+}
+
+/*
+ *	calculate addressability as follows
+ *		CONST ==> 20		$value
+ *		NAME ==> 10		name
+ *		REGISTER ==> 11		register
+ *		INDREG ==> 12		*[(reg)+offset]
+ *		&10 ==> 2		$name
+ *		ADD(2, 20) ==> 2	$name+offset
+ *		ADD(3, 20) ==> 3	$(reg)+offset
+ *		&12 ==> 3		$(reg)+offset
+ *		*11 ==> 11		??
+ *		*2 ==> 10		name
+ *		*3 ==> 12		*(reg)+offset
+ *	calculate complexity (number of registers)
+ */
+void
+xcom(Node *n)
+{
+	Node *l, *r;
+	int t;
+
+	if(n == Z)
+		return;
+	l = n->left;
+	r = n->right;
+	n->addable = 0;
+	n->complex = 0;
+	switch(n->op) {
+	case OCONST:
+		n->addable = 20;
+		return;
+
+	case OREGISTER:
+		n->addable = 11;
+		return;
+
+	case OINDREG:
+		n->addable = 12;
+		return;
+
+	case ONAME:
+		n->addable = 10;
+		return;
+
+	case OADDR:
+		xcom(l);
+		if(l->addable == 10)
+			n->addable = 2;
+		if(l->addable == 12)
+			n->addable = 3;
+		break;
+
+	case OIND:
+		xcom(l);
+		if(l->addable == 11)
+			n->addable = 12;
+		if(l->addable == 3)
+			n->addable = 12;
+		if(l->addable == 2)
+			n->addable = 10;
+		break;
+
+	case OADD:
+		xcom(l);
+		xcom(r);
+		if(l->addable == 20) {
+			if(r->addable == 2)
+				n->addable = 2;
+			if(r->addable == 3)
+				n->addable = 3;
+		}
+		if(r->addable == 20) {
+			if(l->addable == 2)
+				n->addable = 2;
+			if(l->addable == 3)
+				n->addable = 3;
+		}
+		break;
+
+	case OASLMUL:
+	case OASMUL:
+		xcom(l);
+		xcom(r);
+		t = vlog(r);
+		if(t >= 0) {
+			n->op = OASASHL;
+			r->vconst = t;
+			r->type = types[TINT];
+		}
+		break;
+
+	case OMUL:
+	case OLMUL:
+		xcom(l);
+		xcom(r);
+		t = vlog(r);
+		if(t >= 0) {
+			n->op = OASHL;
+			r->vconst = t;
+			r->type = types[TINT];
+		}
+		t = vlog(l);
+		if(t >= 0) {
+			n->op = OASHL;
+			n->left = r;
+			n->right = l;
+			r = l;
+			l = n->left;
+			r->vconst = t;
+			r->type = types[TINT];
+		}
+		break;
+
+	case OASLDIV:
+		xcom(l);
+		xcom(r);
+		t = vlog(r);
+		if(t >= 0) {
+			n->op = OASLSHR;
+			r->vconst = t;
+			r->type = types[TINT];
+		}
+		break;
+
+	case OLDIV:
+		xcom(l);
+		xcom(r);
+		t = vlog(r);
+		if(t >= 0) {
+			n->op = OLSHR;
+			r->vconst = t;
+			r->type = types[TINT];
+		}
+		break;
+
+	case OASLMOD:
+		xcom(l);
+		xcom(r);
+		t = vlog(r);
+		if(t >= 0) {
+			n->op = OASAND;
+			r->vconst--;
+		}
+		break;
+
+	case OLMOD:
+		xcom(l);
+		xcom(r);
+		t = vlog(r);
+		if(t >= 0) {
+			n->op = OAND;
+			r->vconst--;
+		}
+		break;
+
+	default:
+		if(l != Z)
+			xcom(l);
+		if(r != Z)
+			xcom(r);
+		break;
+	}
+	if(n->addable >= 10)
+		return;
+
+	if(l != Z)
+		n->complex = l->complex;
+	if(r != Z) {
+		if(r->complex == n->complex)
+			n->complex = r->complex+1;
+		else
+		if(r->complex > n->complex)
+			n->complex = r->complex;
+	}
+	if(n->complex == 0)
+		n->complex++;
+
+	if(com64(n))
+		return;
+
+	switch(n->op) {
+	case OFUNC:
+		n->complex = FNX;
+		break;
+
+	case OADD:
+	case OXOR:
+	case OAND:
+	case OOR:
+	case OEQ:
+	case ONE:
+		/*
+		 * immediate operators, make const on right
+		 */
+		if(l->op == OCONST) {
+			n->left = r;
+			n->right = l;
+		}
+		break;
+	}
+}
+
+int
+bcomplex(Node *n, Node *c)
+{
+
+	complex(n);
+	if(n->type != T)
+	if(tcompat(n, T, n->type, tnot))
+		n->type = T;
+	if(n->type != T) {
+		if(c != Z && n->op == OCONST && deadheads(c))
+			return 1;
+		bool64(n);
+		boolgen(n, 1, Z);
+	} else
+		gbranch(OGOTO);
+	return 0;
+}
diff --git a/src/cmd/5c/swt.c b/src/cmd/5c/swt.c
new file mode 100644
index 0000000000..f874a9cd6c
--- /dev/null
+++ b/src/cmd/5c/swt.c
@@ -0,0 +1,787 @@
+// Inferno utils/5c/swt.c
+// http://code.google.com/p/inferno-os/source/browse/utils/5c/swt.c
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#include "gc.h"
+
+int
+swcmp(const void *a1, const void *a2)
+{
+	C1 *p1, *p2;
+
+	p1 = (C1*)a1;
+	p2 = (C1*)a2;
+	if(p1->val < p2->val)
+		return -1;
+	return  p1->val > p2->val;
+}
+
+void
+doswit(Node *n)
+{
+	Case *c;
+	C1 *q, *iq;
+	long def, nc, i;
+	Node tn;
+
+	def = 0;
+	nc = 0;
+	for(c = cases; c->link != C; c = c->link) {
+		if(c->def) {
+			if(def)
+				diag(n, "more than one default in switch");
+			def = c->label;
+			continue;
+		}
+		nc++;
+	}
+
+	iq = alloc(nc*sizeof(C1));
+	q = iq;
+	for(c = cases; c->link != C; c = c->link) {
+		if(c->def)
+			continue;
+		q->label = c->label;
+		q->val = c->val;
+		q++;
+	}
+	qsort(iq, nc, sizeof(C1), swcmp);
+	if(debug['W'])
+		for(i=0; i<nc; i++)
+			print("case %2ld: = %.8lux\n", i, iq[i].val);
+	if(def == 0)
+		def = breakpc;
+	for(i=0; i<nc-1; i++)
+		if(iq[i].val == iq[i+1].val)
+			diag(n, "duplicate cases in switch %ld", iq[i].val);
+	regalloc(&tn, &regnode, Z);
+	swit1(iq, nc, def, n, &tn);
+	regfree(&tn);
+}
+
+void
+swit1(C1 *q, int nc, long def, Node *n, Node *tn)
+{
+	C1 *r;
+	int i;
+	long v;
+	Prog *sp;
+
+	if(nc >= 3) {
+		i = (q+nc-1)->val - (q+0)->val;
+		if(i > 0 && i < nc*2)
+			goto direct;
+	}
+	if(nc < 5) {
+		for(i=0; i<nc; i++) {
+			if(debug['W'])
+				print("case = %.8lux\n", q->val);
+			gopcode(OEQ, nodconst(q->val), n, Z);
+			patch(p, q->label);
+			q++;
+		}
+		gbranch(OGOTO);
+		patch(p, def);
+		return;
+	}
+
+	i = nc / 2;
+	r = q+i;
+	if(debug['W'])
+		print("case > %.8lux\n", r->val);
+	gopcode(OGT, nodconst(r->val), n, Z);
+	sp = p;
+	gopcode(OEQ, nodconst(r->val), n, Z);	/* just gen the B.EQ */
+	patch(p, r->label);
+	swit1(q, i, def, n, tn);
+
+	if(debug['W'])
+		print("case < %.8lux\n", r->val);
+	patch(sp, pc);
+	swit1(r+1, nc-i-1, def, n, tn);
+	return;
+
+direct:
+	v = q->val;
+	if(v != 0)
+		gopcode(OSUB, nodconst(v), Z, n);
+	gopcode(OCASE, nodconst((q+nc-1)->val - v), n, Z);
+	patch(p, def);
+	for(i=0; i<nc; i++) {
+		if(debug['W'])
+			print("case = %.8lux\n", q->val);
+		while(q->val != v) {
+			nextpc();
+			p->as = ABCASE;
+			patch(p, def);
+			v++;
+		}
+		nextpc();
+		p->as = ABCASE;
+		patch(p, q->label);
+		q++;
+		v++;
+	}
+	gbranch(OGOTO);		/* so that regopt() won't be confused */
+	patch(p, def);
+}
+
+void
+cas(void)
+{
+	Case *c;
+
+	c = alloc(sizeof(*c));
+	c->link = cases;
+	cases = c;
+}
+
+void
+bitload(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
+{
+	int sh;
+	long v;
+	Node *l;
+
+	/*
+	 * n1 gets adjusted/masked value
+	 * n2 gets address of cell
+	 * n3 gets contents of cell
+	 */
+	l = b->left;
+	if(n2 != Z) {
+		regalloc(n1, l, nn);
+		reglcgen(n2, l, Z);
+		regalloc(n3, l, Z);
+		gopcode(OAS, n2, Z, n3);
+		gopcode(OAS, n3, Z, n1);
+	} else {
+		regalloc(n1, l, nn);
+		cgen(l, n1, 0);
+	}
+	if(b->type->shift == 0 && typeu[b->type->etype]) {
+		v = ~0 + (1L << b->type->nbits);
+		gopcode(OAND, nodconst(v), Z, n1);
+	} else {
+		sh = 32 - b->type->shift - b->type->nbits;
+		if(sh > 0)
+			gopcode(OASHL, nodconst(sh), Z, n1);
+		sh += b->type->shift;
+		if(sh > 0)
+			if(typeu[b->type->etype])
+				gopcode(OLSHR, nodconst(sh), Z, n1);
+			else
+				gopcode(OASHR, nodconst(sh), Z, n1);
+	}
+}
+
+void
+bitstore(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
+{
+	long v;
+	Node nod, *l;
+	int sh;
+
+	/*
+	 * n1 has adjusted/masked value
+	 * n2 has address of cell
+	 * n3 has contents of cell
+	 */
+	l = b->left;
+	regalloc(&nod, l, Z);
+	v = ~0 + (1L << b->type->nbits);
+	gopcode(OAND, nodconst(v), Z, n1);
+	gopcode(OAS, n1, Z, &nod);
+	if(nn != Z)
+		gopcode(OAS, n1, Z, nn);
+	sh = b->type->shift;
+	if(sh > 0)
+		gopcode(OASHL, nodconst(sh), Z, &nod);
+	v <<= sh;
+	gopcode(OAND, nodconst(~v), Z, n3);
+	gopcode(OOR, n3, Z, &nod);
+	gopcode(OAS, &nod, Z, n2);
+
+	regfree(&nod);
+	regfree(n1);
+	regfree(n2);
+	regfree(n3);
+}
+
+long
+outstring(char *s, long n)
+{
+	long r;
+
+	if(suppress)
+		return nstring;
+	r = nstring;
+	while(n) {
+		string[mnstring] = *s++;
+		mnstring++;
+		nstring++;
+		if(mnstring >= NSNAME) {
+			gpseudo(ADATA, symstring, nodconst(0L));
+			p->from.offset += nstring - NSNAME;
+			p->reg = NSNAME;
+			p->to.type = D_SCONST;
+			memmove(p->to.sval, string, NSNAME);
+			mnstring = 0;
+		}
+		n--;
+	}
+	return r;
+}
+
+long
+outlstring(ushort *s, long n)
+{
+	char buf[2];
+	int c;
+	long r;
+
+	if(suppress)
+		return nstring;
+	while(nstring & 1)
+		outstring("", 1);
+	r = nstring;
+	while(n > 0) {
+		c = *s++;
+		if(align(0, types[TCHAR], Aarg1)) {
+			buf[0] = c>>8;
+			buf[1] = c;
+		} else {
+			buf[0] = c;
+			buf[1] = c>>8;
+		}
+		outstring(buf, 2);
+		n -= sizeof(ushort);
+	}
+	return r;
+}
+
+int
+mulcon(Node *n, Node *nn)
+{
+	Node *l, *r, nod1, nod2;
+	Multab *m;
+	long v, vs;
+	int o;
+	char code[sizeof(m->code)+2], *p;
+
+	if(typefd[n->type->etype])
+		return 0;
+	l = n->left;
+	r = n->right;
+	if(l->op == OCONST) {
+		l = r;
+		r = n->left;
+	}
+	if(r->op != OCONST)
+		return 0;
+	v = convvtox(r->vconst, n->type->etype);
+	if(v != r->vconst) {
+		if(debug['M'])
+			print("%L multiply conv: %lld\n", n->lineno, r->vconst);
+		return 0;
+	}
+	m = mulcon0(v);
+	if(!m) {
+		if(debug['M'])
+			print("%L multiply table: %lld\n", n->lineno, r->vconst);
+		return 0;
+	}
+	if(debug['M'] && debug['v'])
+		print("%L multiply: %ld\n", n->lineno, v);
+
+	memmove(code, m->code, sizeof(m->code));
+	code[sizeof(m->code)] = 0;
+
+	p = code;
+	if(p[1] == 'i')
+		p += 2;
+	regalloc(&nod1, n, nn);
+	cgen(l, &nod1, 0);
+	vs = v;
+	regalloc(&nod2, n, Z);
+
+loop:
+	switch(*p) {
+	case 0:
+		regfree(&nod2);
+		if(vs < 0) {
+			gopcode(OAS, &nod1, Z, &nod1);
+			gopcode(OSUB, &nod1, nodconst(0), nn);
+		} else 
+			gopcode(OAS, &nod1, Z, nn);
+		regfree(&nod1);
+		return 1;
+	case '+':
+		o = OADD;
+		goto addsub;
+	case '-':
+		o = OSUB;
+	addsub:	/* number is r,n,l */
+		v = p[1] - '0';
+		r = &nod1;
+		if(v&4)
+			r = &nod2;
+		n = &nod1;
+		if(v&2)
+			n = &nod2;
+		l = &nod1;
+		if(v&1)
+			l = &nod2;
+		gopcode(o, l, n, r);
+		break;
+	default: /* op is shiftcount, number is r,l */
+		v = p[1] - '0';
+		r = &nod1;
+		if(v&2)
+			r = &nod2;
+		l = &nod1;
+		if(v&1)
+			l = &nod2;
+		v = *p - 'a';
+		if(v < 0 || v >= 32) {
+			diag(n, "mulcon unknown op: %c%c", p[0], p[1]);
+			break;
+		}
+		gopcode(OASHL, nodconst(v), l, r);
+		break;
+	}
+	p += 2;
+	goto loop;
+}
+
+void
+nullwarn(Node *l, Node *r)
+{
+	warn(Z, "result of operation not used");
+	if(l != Z)
+		cgen(l, Z, 0);
+	if(r != Z)
+		cgen(r, Z, 0);
+}
+
+void
+sextern(Sym *s, Node *a, long o, long w)
+{
+	long e, lw;
+
+	for(e=0; e<w; e+=NSNAME) {
+		lw = NSNAME;
+		if(w-e < lw)
+			lw = w-e;
+		gpseudo(ADATA, s, nodconst(0));
+		p->from.offset += o+e;
+		p->reg = lw;
+		p->to.type = D_SCONST;
+		memmove(p->to.sval, a->cstring+e, lw);
+	}
+}
+
+void
+gextern(Sym *s, Node *a, long o, long w)
+{
+
+	if(a->op == OCONST && typev[a->type->etype]) {
+		if(1 || align(0, types[TCHAR], Aarg1))	/* isbigendian */
+			gpseudo(ADATA, s, nod32const(a->vconst>>32));
+		else
+			gpseudo(ADATA, s, nod32const(a->vconst));
+		p->from.offset += o;
+		p->reg = 4;
+		if(1 || align(0, types[TCHAR], Aarg1))	/* isbigendian */
+			gpseudo(ADATA, s, nod32const(a->vconst));
+		else
+			gpseudo(ADATA, s, nod32const(a->vconst>>32));
+		p->from.offset += o + 4;
+		p->reg = 4;
+		return;
+	}
+	gpseudo(ADATA, s, a);
+	p->from.offset += o;
+	p->reg = w;
+	if(p->to.type == D_OREG)
+		p->to.type = D_CONST;
+}
+
+void	zname(Biobuf*, Sym*, int);
+char*	zaddr(char*, Adr*, int);
+void	zwrite(Biobuf*, Prog*, int, int);
+void	outhist(Biobuf*);
+
+void
+zwrite(Biobuf *b, Prog *p, int sf, int st)
+{
+	char bf[100], *bp;
+
+	bf[0] = p->as;
+	bf[1] = p->scond;
+	bf[2] = p->reg;
+	bf[3] = p->lineno;
+	bf[4] = p->lineno>>8;
+	bf[5] = p->lineno>>16;
+	bf[6] = p->lineno>>24;
+	bp = zaddr(bf+7, &p->from, sf);
+	bp = zaddr(bp, &p->to, st);
+	Bwrite(b, bf, bp-bf);
+}
+
+void
+outcode(void)
+{
+	struct { Sym *sym; short type; } h[NSYM];
+	Prog *p;
+	Sym *s;
+	int sf, st, t, sym;
+
+	if(debug['S']) {
+		for(p = firstp; p != P; p = p->link)
+			if(p->as != ADATA && p->as != AGLOBL)
+				pc--;
+		for(p = firstp; p != P; p = p->link) {
+			print("%P\n", p);
+			if(p->as != ADATA && p->as != AGLOBL)
+				pc++;
+		}
+	}
+	outhist(&outbuf);
+	for(sym=0; sym<NSYM; sym++) {
+		h[sym].sym = S;
+		h[sym].type = 0;
+	}
+	sym = 1;
+	for(p = firstp; p != P; p = p->link) {
+	jackpot:
+		sf = 0;
+		s = p->from.sym;
+		while(s != S) {
+			sf = s->sym;
+			if(sf < 0 || sf >= NSYM)
+				sf = 0;
+			t = p->from.name;
+			if(h[sf].type == t)
+			if(h[sf].sym == s)
+				break;
+			s->sym = sym;
+			zname(&outbuf, s, t);
+			h[sym].sym = s;
+			h[sym].type = t;
+			sf = sym;
+			sym++;
+			if(sym >= NSYM)
+				sym = 1;
+			break;
+		}
+		st = 0;
+		s = p->to.sym;
+		while(s != S) {
+			st = s->sym;
+			if(st < 0 || st >= NSYM)
+				st = 0;
+			t = p->to.name;
+			if(h[st].type == t)
+			if(h[st].sym == s)
+				break;
+			s->sym = sym;
+			zname(&outbuf, s, t);
+			h[sym].sym = s;
+			h[sym].type = t;
+			st = sym;
+			sym++;
+			if(sym >= NSYM)
+				sym = 1;
+			if(st == sf)
+				goto jackpot;
+			break;
+		}
+		zwrite(&outbuf, p, sf, st);
+	}
+	firstp = P;
+	lastp = P;
+}
+
+void
+outhist(Biobuf *b)
+{
+	Hist *h;
+	char *p, *q, *op, c;
+	Prog pg;
+	int n;
+
+	pg = zprog;
+	pg.as = AHISTORY;
+	c = pathchar();
+	for(h = hist; h != H; h = h->link) {
+		p = h->name;
+		op = 0;
+		/* on windows skip drive specifier in pathname */
+		if(systemtype(Windows) && p && p[1] == ':'){
+			p += 2;
+			c = *p;
+		}
+		if(p && p[0] != c && h->offset == 0 && pathname){
+			/* on windows skip drive specifier in pathname */
+			if(systemtype(Windows) && pathname[1] == ':') {
+				op = p;
+				p = pathname+2;
+				c = *p;
+			} else if(pathname[0] == c){
+				op = p;
+				p = pathname;
+			}
+		}
+		while(p) {
+			q = utfrune(p, c);
+			if(q) {
+				n = q-p;
+				if(n == 0){
+					n = 1;	/* leading "/" */
+					*p = '/';	/* don't emit "\" on windows */
+				}
+				q++;
+			} else {
+				n = strlen(p);
+				q = 0;
+			}
+			if(n) {
+				Bputc(b, ANAME);
+				Bputc(b, D_FILE);
+				Bputc(b, 1);
+				Bputc(b, '<');
+				Bwrite(b, p, n);
+				Bputc(b, 0);
+			}
+			p = q;
+			if(p == 0 && op) {
+				p = op;
+				op = 0;
+			}
+		}
+		pg.lineno = h->line;
+		pg.to.type = zprog.to.type;
+		pg.to.offset = h->offset;
+		if(h->offset)
+			pg.to.type = D_CONST;
+
+		zwrite(b, &pg, 0, 0);
+	}
+}
+
+void
+zname(Biobuf *b, Sym *s, int t)
+{
+	char *n, bf[7];
+	ulong sig;
+
+	n = s->name;
+	if(debug['T'] && t == D_EXTERN && s->sig != SIGDONE && s->type != types[TENUM] && s != symrathole){
+		sig = sign(s);
+		bf[0] = ASIGNAME;
+		bf[1] = sig;
+		bf[2] = sig>>8;
+		bf[3] = sig>>16;
+		bf[4] = sig>>24;
+		bf[5] = t;
+		bf[6] = s->sym;
+		Bwrite(b, bf, 7);
+		s->sig = SIGDONE;
+	}
+	else{
+		bf[0] = ANAME;
+		bf[1] = t;	/* type */
+		bf[2] = s->sym;	/* sym */
+		Bwrite(b, bf, 3);
+	}
+	Bwrite(b, n, strlen(n)+1);
+}
+
+char*
+zaddr(char *bp, Adr *a, int s)
+{
+	long l;
+	Ieee e;
+
+	bp[0] = a->type;
+	bp[1] = a->reg;
+	bp[2] = s;
+	bp[3] = a->name;
+	bp += 4;
+	switch(a->type) {
+	default:
+		diag(Z, "unknown type %d in zaddr", a->type);
+
+	case D_NONE:
+	case D_REG:
+	case D_FREG:
+	case D_PSR:
+		break;
+
+	case D_OREG:
+	case D_CONST:
+	case D_BRANCH:
+	case D_SHIFT:
+		l = a->offset;
+		bp[0] = l;
+		bp[1] = l>>8;
+		bp[2] = l>>16;
+		bp[3] = l>>24;
+		bp += 4;
+		break;
+
+	case D_SCONST:
+		memmove(bp, a->sval, NSNAME);
+		bp += NSNAME;
+		break;
+
+	case D_FCONST:
+		ieeedtod(&e, a->dval);
+		l = e.l;
+		bp[0] = l;
+		bp[1] = l>>8;
+		bp[2] = l>>16;
+		bp[3] = l>>24;
+		bp += 4;
+		l = e.h;
+		bp[0] = l;
+		bp[1] = l>>8;
+		bp[2] = l>>16;
+		bp[3] = l>>24;
+		bp += 4;
+		break;
+	}
+	return bp;
+}
+
+void
+ieeedtod(Ieee *ieee, double native)
+{
+	double fr, ho, f;
+	int exp;
+
+	if(native < 0) {
+		ieeedtod(ieee, -native);
+		ieee->h |= 0x80000000L;
+		return;
+	}
+	if(native == 0) {
+		ieee->l = 0;
+		ieee->h = 0;
+		return;
+	}
+	fr = frexp(native, &exp);
+	f = 2097152L;		/* shouldnt use fp constants here */
+	fr = modf(fr*f, &ho);
+	ieee->h = ho;
+	ieee->h &= 0xfffffL;
+	ieee->h |= (exp+1022L) << 20;
+	f = 65536L;
+	fr = modf(fr*f, &ho);
+	ieee->l = ho;
+	ieee->l <<= 16;
+	ieee->l |= (long)(fr*f);
+}
+
+long
+align(long i, Type *t, int op)
+{
+	long o;
+	Type *v;
+	int w;
+
+	o = i;
+	w = 1;
+	switch(op) {
+	default:
+		diag(Z, "unknown align opcode %d", op);
+		break;
+
+	case Asu2:	/* padding at end of a struct */
+		w = SZ_LONG;
+		if(packflg)
+			w = packflg;
+		break;
+
+	case Ael1:	/* initial allign of struct element */
+		for(v=t; v->etype==TARRAY; v=v->link)
+			;
+		w = ewidth[v->etype];
+		if(w <= 0 || w >= SZ_LONG)
+			w = SZ_LONG;
+		if(packflg)
+			w = packflg;
+		break;
+
+	case Ael2:	/* width of a struct element */
+		o += t->width;
+		break;
+
+	case Aarg0:	/* initial passbyptr argument in arg list */
+		if(typesuv[t->etype]) {
+			o = align(o, types[TIND], Aarg1);
+			o = align(o, types[TIND], Aarg2);
+		}
+		break;
+
+	case Aarg1:	/* initial allign of parameter */
+		w = ewidth[t->etype];
+		if(w <= 0 || w >= SZ_LONG) {
+			w = SZ_LONG;
+			break;
+		}
+		w = 1;		/* little endian no adjustment */
+		break;
+
+	case Aarg2:	/* width of a parameter */
+		o += t->width;
+		w = SZ_LONG;
+		break;
+
+	case Aaut3:	/* total allign of automatic */
+		o = align(o, t, Ael2);
+		o = align(o, t, Ael1);
+		w = SZ_LONG;	/* because of a pun in cc/dcl.c:contig() */
+		break;
+	}
+	o = round(o, w);
+	if(debug['A'])
+		print("align %s %ld %T = %ld\n", bnames[op], i, t, o);
+	return o;
+}
+
+long
+maxround(long max, long v)
+{
+	v = round(v, SZ_LONG);
+	if(v > max)
+		return v;
+	return max;
+}
diff --git a/src/cmd/5c/txt.c b/src/cmd/5c/txt.c
new file mode 100644
index 0000000000..319f65627b
--- /dev/null
+++ b/src/cmd/5c/txt.c
@@ -0,0 +1,1280 @@
+// Inferno utils/5c/txt.c
+// http://code.google.com/p/inferno-os/source/browse/utils/5c/txt.c
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#include "gc.h"
+
+void
+ginit(void)
+{
+	Type *t;
+
+	thechar = '5';
+	thestring = "arm";
+	exregoffset = REGEXT;
+	exfregoffset = FREGEXT;
+	listinit();
+	nstring = 0;
+	mnstring = 0;
+	nrathole = 0;
+	pc = 0;
+	breakpc = -1;
+	continpc = -1;
+	cases = C;
+	firstp = P;
+	lastp = P;
+	tfield = types[TLONG];
+
+	zprog.link = P;
+	zprog.as = AGOK;
+	zprog.reg = NREG;
+	zprog.from.type = D_NONE;
+	zprog.from.name = D_NONE;
+	zprog.from.reg = NREG;
+	zprog.to = zprog.from;
+	zprog.scond = 0xE;  
+
+	regnode.op = OREGISTER;
+	regnode.class = CEXREG;
+	regnode.reg = REGTMP;
+	regnode.complex = 0;
+	regnode.addable = 11;
+	regnode.type = types[TLONG];
+
+	constnode.op = OCONST;
+	constnode.class = CXXX;
+	constnode.complex = 0;
+	constnode.addable = 20;
+	constnode.type = types[TLONG];
+
+	fconstnode.op = OCONST;
+	fconstnode.class = CXXX;
+	fconstnode.complex = 0;
+	fconstnode.addable = 20;
+	fconstnode.type = types[TDOUBLE];
+
+	nodsafe = new(ONAME, Z, Z);
+	nodsafe->sym = slookup(".safe");
+	nodsafe->type = types[TINT];
+	nodsafe->etype = types[TINT]->etype;
+	nodsafe->class = CAUTO;
+	complex(nodsafe);
+
+	t = typ(TARRAY, types[TCHAR]);
+	symrathole = slookup(".rathole");
+	symrathole->class = CGLOBL;
+	symrathole->type = t;
+
+	nodrat = new(ONAME, Z, Z);
+	nodrat->sym = symrathole;
+	nodrat->type = types[TIND];
+	nodrat->etype = TVOID;
+	nodrat->class = CGLOBL;
+	complex(nodrat);
+	nodrat->type = t;
+
+	nodret = new(ONAME, Z, Z);
+	nodret->sym = slookup(".ret");
+	nodret->type = types[TIND];
+	nodret->etype = TIND;
+	nodret->class = CPARAM;
+	nodret = new(OIND, nodret, Z);
+	complex(nodret);
+
+	com64init();
+
+	memset(reg, 0, sizeof(reg));
+}
+
+void
+gclean(void)
+{
+	int i;
+	Sym *s;
+
+	for(i=0; i<NREG; i++)
+		if(reg[i])
+			diag(Z, "reg %d left allocated", i);
+	for(i=NREG; i<NREG+NFREG; i++)
+		if(reg[i])
+			diag(Z, "freg %d left allocated", i-NREG);
+	while(mnstring)
+		outstring("", 1L);
+	symstring->type->width = nstring;
+	symrathole->type->width = nrathole;
+	for(i=0; i<NHASH; i++)
+	for(s = hash[i]; s != S; s = s->link) {
+		if(s->type == T)
+			continue;
+		if(s->type->width == 0)
+			continue;
+		if(s->class != CGLOBL && s->class != CSTATIC)
+			continue;
+		if(s->type == types[TENUM])
+			continue;
+		gpseudo(AGLOBL, s, nodconst(s->type->width));
+	}
+	nextpc();
+	p->as = AEND;
+	outcode();
+}
+
+void
+nextpc(void)
+{
+
+	p = alloc(sizeof(*p));
+	*p = zprog;
+	p->lineno = nearln;
+	pc++;
+	if(firstp == P) {
+		firstp = p;
+		lastp = p;
+		return;
+	}
+	lastp->link = p;
+	lastp = p;
+}
+
+void
+gargs(Node *n, Node *tn1, Node *tn2)
+{
+	long regs;
+	Node fnxargs[20], *fnxp;
+
+	regs = cursafe;
+
+	fnxp = fnxargs;
+	garg1(n, tn1, tn2, 0, &fnxp);	/* compile fns to temps */
+
+	curarg = 0;
+	fnxp = fnxargs;
+	garg1(n, tn1, tn2, 1, &fnxp);	/* compile normal args and temps */
+
+	cursafe = regs;
+}
+
+void
+garg1(Node *n, Node *tn1, Node *tn2, int f, Node **fnxp)
+{
+	Node nod;
+
+	if(n == Z)
+		return;
+	if(n->op == OLIST) {
+		garg1(n->left, tn1, tn2, f, fnxp);
+		garg1(n->right, tn1, tn2, f, fnxp);
+		return;
+	}
+	if(f == 0) {
+		if(n->complex >= FNX) {
+			regsalloc(*fnxp, n);
+			nod = znode;
+			nod.op = OAS;
+			nod.left = *fnxp;
+			nod.right = n;
+			nod.type = n->type;
+			cgen(&nod, Z, 0);
+			(*fnxp)++;
+		}
+		return;
+	}
+	if(typesuv[n->type->etype]) {
+		regaalloc(tn2, n);
+		if(n->complex >= FNX) {
+			sugen(*fnxp, tn2, n->type->width);
+			(*fnxp)++;
+		} else
+			sugen(n, tn2, n->type->width);
+		return;
+	}
+	if(REGARG >= 0 && curarg == 0 && typechlp[n->type->etype]) {
+		regaalloc1(tn1, n);
+		if(n->complex >= FNX) {
+			cgen(*fnxp, tn1, 0);
+			(*fnxp)++;
+		} else
+			cgen(n, tn1, 0);
+		return;
+	}
+	regalloc(tn1, n, Z);
+	if(n->complex >= FNX) {
+		cgen(*fnxp, tn1, 0);
+		(*fnxp)++;
+	} else
+		cgen(n, tn1, 0);
+	regaalloc(tn2, n);
+	gopcode(OAS, tn1, Z, tn2);
+	regfree(tn1);
+}
+
+Node*
+nodconst(long v)
+{
+	constnode.vconst = v;
+	return &constnode;
+}
+
+Node*
+nod32const(vlong v)
+{
+	constnode.vconst = v & MASK(32);
+	return &constnode;
+}
+
+Node*
+nodfconst(double d)
+{
+	fconstnode.fconst = d;
+	return &fconstnode;
+}
+
+void
+nodreg(Node *n, Node *nn, int reg)
+{
+	*n = regnode;
+	n->reg = reg;
+	n->type = nn->type;
+	n->lineno = nn->lineno;
+}
+
+void
+regret(Node *n, Node *nn)
+{
+	int r;
+
+	r = REGRET;
+	if(typefd[nn->type->etype])
+		r = FREGRET+NREG;
+	nodreg(n, nn, r);
+	reg[r]++;
+}
+
+int
+tmpreg(void)
+{
+	int i;
+
+	for(i=REGRET+1; i<NREG; i++)
+		if(reg[i] == 0)
+			return i;
+	diag(Z, "out of fixed registers");
+	return 0;
+}
+
+void
+regalloc(Node *n, Node *tn, Node *o)
+{
+	int i, j;
+	static int lasti;
+
+	switch(tn->type->etype) {
+	case TCHAR:
+	case TUCHAR:
+	case TSHORT:
+	case TUSHORT:
+	case TINT:
+	case TUINT:
+	case TLONG:
+	case TULONG:
+	case TIND:
+		if(o != Z && o->op == OREGISTER) {
+			i = o->reg;
+			if(i >= 0 && i < NREG)
+				goto out;
+		}
+		j = lasti + REGRET+1;
+		for(i=REGRET+1; i<NREG; i++) {
+			if(j >= NREG)
+				j = REGRET+1;
+			if(reg[j] == 0) {
+				i = j;
+				goto out;
+			}
+			j++;
+		}
+		diag(tn, "out of fixed registers");
+		goto err;
+
+	case TFLOAT:
+	case TDOUBLE:
+	case TVLONG:
+		if(o != Z && o->op == OREGISTER) {
+			i = o->reg;
+			if(i >= NREG && i < NREG+NFREG)
+				goto out;
+		}
+		j = 0*2 + NREG;
+		for(i=NREG; i<NREG+NFREG; i++) {
+			if(j >= NREG+NFREG)
+				j = NREG;
+			if(reg[j] == 0) {
+				i = j;
+				goto out;
+			}
+			j++;
+		}
+		diag(tn, "out of float registers");
+		goto err;
+	}
+	diag(tn, "unknown type in regalloc: %T", tn->type);
+err:
+	nodreg(n, tn, 0);
+	return;
+out:
+	reg[i]++;
+/* 	lasti++;	*** StrongARM does register forwarding */	
+	if(lasti >= 5)
+		lasti = 0;
+	nodreg(n, tn, i);
+}
+
+void
+regialloc(Node *n, Node *tn, Node *o)
+{
+	Node nod;
+
+	nod = *tn;
+	nod.type = types[TIND];
+	regalloc(n, &nod, o);
+}
+
+void
+regfree(Node *n)
+{
+	int i;
+
+	i = 0;
+	if(n->op != OREGISTER && n->op != OINDREG)
+		goto err;
+	i = n->reg;
+	if(i < 0 || i >= sizeof(reg))
+		goto err;
+	if(reg[i] <= 0)
+		goto err;
+	reg[i]--;
+	return;
+err:
+	diag(n, "error in regfree: %d", i);
+}
+
+void
+regsalloc(Node *n, Node *nn)
+{
+	cursafe = align(cursafe, nn->type, Aaut3);
+	maxargsafe = maxround(maxargsafe, cursafe+curarg);
+	*n = *nodsafe;
+	n->xoffset = -(stkoff + cursafe);
+	n->type = nn->type;
+	n->etype = nn->type->etype;
+	n->lineno = nn->lineno;
+}
+
+void
+regaalloc1(Node *n, Node *nn)
+{
+	nodreg(n, nn, REGARG);
+	reg[REGARG]++;
+	curarg = align(curarg, nn->type, Aarg1);
+	curarg = align(curarg, nn->type, Aarg2);
+	maxargsafe = maxround(maxargsafe, cursafe+curarg);
+}
+
+void
+regaalloc(Node *n, Node *nn)
+{
+	curarg = align(curarg, nn->type, Aarg1);
+	*n = *nn;
+	n->op = OINDREG;
+	n->reg = REGSP;
+	n->xoffset = curarg + SZ_LONG;
+	n->complex = 0;
+	n->addable = 20;
+	curarg = align(curarg, nn->type, Aarg2);
+	maxargsafe = maxround(maxargsafe, cursafe+curarg);
+}
+
+void
+regind(Node *n, Node *nn)
+{
+
+	if(n->op != OREGISTER) {
+		diag(n, "regind not OREGISTER");
+		return;
+	}
+	n->op = OINDREG;
+	n->type = nn->type;
+}
+
+void
+raddr(Node *n, Prog *p)
+{
+	Adr a;
+
+	naddr(n, &a);
+	if(R0ISZERO && a.type == D_CONST && a.offset == 0) {
+		a.type = D_REG;
+		a.reg = 0;
+	}
+	if(a.type != D_REG && a.type != D_FREG) {
+		if(n)
+			diag(n, "bad in raddr: %O", n->op);
+		else
+			diag(n, "bad in raddr: <null>");
+		p->reg = NREG;
+	} else
+		p->reg = a.reg;
+}
+
+void
+naddr(Node *n, Adr *a)
+{
+	long v;
+
+	a->type = D_NONE;
+	if(n == Z)
+		return;
+	switch(n->op) {
+	default:
+	bad:
+		diag(n, "bad in naddr: %O", n->op);
+		break;
+
+	case OREGISTER:
+		a->type = D_REG;
+		a->sym = S;
+		a->reg = n->reg;
+		if(a->reg >= NREG) {
+			a->type = D_FREG;
+			a->reg -= NREG;
+		}
+		break;
+
+	case OIND:
+		naddr(n->left, a);
+		if(a->type == D_REG) {
+			a->type = D_OREG;
+			break;
+		}
+		if(a->type == D_CONST) {
+			a->type = D_OREG;
+			break;
+		}
+		goto bad;
+
+	case OINDREG:
+		a->type = D_OREG;
+		a->sym = S;
+		a->offset = n->xoffset;
+		a->reg = n->reg;
+		break;
+
+	case ONAME:
+		a->etype = n->etype;
+		a->type = D_OREG;
+		a->name = D_STATIC;
+		a->sym = n->sym;
+		a->offset = n->xoffset;
+		if(n->class == CSTATIC)
+			break;
+		if(n->class == CEXTERN || n->class == CGLOBL) {
+			a->name = D_EXTERN;
+			break;
+		}
+		if(n->class == CAUTO) {
+			a->name = D_AUTO;
+			break;
+		}
+		if(n->class == CPARAM) {
+			a->name = D_PARAM;
+			break;
+		}
+		goto bad;
+
+	case OCONST:
+		a->sym = S;
+		a->reg = NREG;
+		if(typefd[n->type->etype]) {
+			a->type = D_FCONST;
+			a->dval = n->fconst;
+		} else {
+			a->type = D_CONST;
+			a->offset = n->vconst;
+		}
+		break;
+
+	case OADDR:
+		naddr(n->left, a);
+		if(a->type == D_OREG) {
+			a->type = D_CONST;
+			break;
+		}
+		goto bad;
+
+	case OADD:
+		if(n->left->op == OCONST) {
+			naddr(n->left, a);
+			v = a->offset;
+			naddr(n->right, a);
+		} else {
+			naddr(n->right, a);
+			v = a->offset;
+			naddr(n->left, a);
+		}
+		a->offset += v;
+		break;
+
+	}
+}
+
+void
+fop(int as, int f1, int f2, Node *t)
+{
+	Node nod1, nod2, nod3;
+
+	nodreg(&nod1, t, NREG+f1);
+	nodreg(&nod2, t, NREG+f2);
+	regalloc(&nod3, t, t);
+	gopcode(as, &nod1, &nod2, &nod3);
+	gmove(&nod3, t);
+	regfree(&nod3);
+}
+
+void
+gmovm(Node *f, Node *t, int w)
+{
+	gins(AMOVM, f, t);
+	p->scond |= C_UBIT;
+	if(w)
+		p->scond |= C_WBIT;
+}
+
+void
+gmove(Node *f, Node *t)
+{
+	int ft, tt, a;
+	Node nod;
+
+	ft = f->type->etype;
+	tt = t->type->etype;
+
+	if(ft == TDOUBLE && f->op == OCONST) {
+	}
+	if(ft == TFLOAT && f->op == OCONST) {
+	}
+
+	/*
+	 * a load --
+	 * put it into a register then
+	 * worry what to do with it.
+	 */
+	if(f->op == ONAME || f->op == OINDREG || f->op == OIND) {
+		switch(ft) {
+		default:
+			a = AMOVW;
+			break;
+		case TFLOAT:
+			a = AMOVF;
+			break;
+		case TDOUBLE:
+			a = AMOVD;
+			break;
+		case TCHAR:
+			a = AMOVB;
+			break;
+		case TUCHAR:
+			a = AMOVBU;
+			break;
+		case TSHORT:
+			a = AMOVH;
+			break;
+		case TUSHORT:
+			a = AMOVHU;
+			break;
+		}
+		if(typechlp[ft] && typeilp[tt])
+			regalloc(&nod, t, t);
+		else
+			regalloc(&nod, f, t);
+		gins(a, f, &nod);
+		gmove(&nod, t);
+		regfree(&nod);
+		return;
+	}
+
+	/*
+	 * a store --
+	 * put it into a register then
+	 * store it.
+	 */
+	if(t->op == ONAME || t->op == OINDREG || t->op == OIND) {
+		switch(tt) {
+		default:
+			a = AMOVW;
+			break;
+		case TUCHAR:
+			a = AMOVBU;
+			break;
+		case TCHAR:
+			a = AMOVB;
+			break;
+		case TUSHORT:
+			a = AMOVHU;
+			break;
+		case TSHORT:
+			a = AMOVH;
+			break;
+		case TFLOAT:
+			a = AMOVF;
+			break;
+		case TVLONG:
+		case TDOUBLE:
+			a = AMOVD;
+			break;
+		}
+		if(ft == tt)
+			regalloc(&nod, t, f);
+		else
+			regalloc(&nod, t, Z);
+		gmove(f, &nod);
+		gins(a, &nod, t);
+		regfree(&nod);
+		return;
+	}
+
+	/*
+	 * type x type cross table
+	 */
+	a = AGOK;
+	switch(ft) {
+	case TDOUBLE:
+	case TVLONG:
+	case TFLOAT:
+		switch(tt) {
+		case TDOUBLE:
+		case TVLONG:
+			a = AMOVD;
+			if(ft == TFLOAT)
+				a = AMOVFD;
+			break;
+		case TFLOAT:
+			a = AMOVDF;
+			if(ft == TFLOAT)
+				a = AMOVF;
+			break;
+		case TINT:
+		case TUINT:
+		case TLONG:
+		case TULONG:
+		case TIND:
+			a = AMOVDW;
+			if(ft == TFLOAT)
+				a = AMOVFW;
+			break;
+		case TSHORT:
+		case TUSHORT:
+		case TCHAR:
+		case TUCHAR:
+			a = AMOVDW;
+			if(ft == TFLOAT)
+				a = AMOVFW;
+			break;
+		}
+		break;
+	case TUINT:
+	case TINT:
+	case TULONG:
+	case TLONG:
+	case TIND:
+		switch(tt) {
+		case TDOUBLE:
+		case TVLONG:
+			gins(AMOVWD, f, t);
+			if(ft == TULONG) {
+			}
+			return;
+		case TFLOAT:
+			gins(AMOVWF, f, t);
+			if(ft == TULONG) {
+			}
+			return;
+		case TINT:
+		case TUINT:
+		case TLONG:
+		case TULONG:
+		case TIND:
+		case TSHORT:
+		case TUSHORT:
+		case TCHAR:
+		case TUCHAR:
+			a = AMOVW;
+			break;
+		}
+		break;
+	case TSHORT:
+		switch(tt) {
+		case TDOUBLE:
+		case TVLONG:
+			regalloc(&nod, f, Z);
+			gins(AMOVH, f, &nod);
+			gins(AMOVWD, &nod, t);
+			regfree(&nod);
+			return;
+		case TFLOAT:
+			regalloc(&nod, f, Z);
+			gins(AMOVH, f, &nod);
+			gins(AMOVWF, &nod, t);
+			regfree(&nod);
+			return;
+		case TUINT:
+		case TINT:
+		case TULONG:
+		case TLONG:
+		case TIND:
+			a = AMOVH;
+			break;
+		case TSHORT:
+		case TUSHORT:
+		case TCHAR:
+		case TUCHAR:
+			a = AMOVW;
+			break;
+		}
+		break;
+	case TUSHORT:
+		switch(tt) {
+		case TDOUBLE:
+		case TVLONG:
+			regalloc(&nod, f, Z);
+			gins(AMOVHU, f, &nod);
+			gins(AMOVWD, &nod, t);
+			regfree(&nod);
+			return;
+		case TFLOAT:
+			regalloc(&nod, f, Z);
+			gins(AMOVHU, f, &nod);
+			gins(AMOVWF, &nod, t);
+			regfree(&nod);
+			return;
+		case TINT:
+		case TUINT:
+		case TLONG:
+		case TULONG:
+		case TIND:
+			a = AMOVHU;
+			break;
+		case TSHORT:
+		case TUSHORT:
+		case TCHAR:
+		case TUCHAR:
+			a = AMOVW;
+			break;
+		}
+		break;
+	case TCHAR:
+		switch(tt) {
+		case TDOUBLE:
+		case TVLONG:
+			regalloc(&nod, f, Z);
+			gins(AMOVB, f, &nod);
+			gins(AMOVWD, &nod, t);
+			regfree(&nod);
+			return;
+		case TFLOAT:
+			regalloc(&nod, f, Z);
+			gins(AMOVB, f, &nod);
+			gins(AMOVWF, &nod, t);
+			regfree(&nod);
+			return;
+		case TINT:
+		case TUINT:
+		case TLONG:
+		case TULONG:
+		case TIND:
+		case TSHORT:
+		case TUSHORT:
+			a = AMOVB;
+			break;
+		case TCHAR:
+		case TUCHAR:
+			a = AMOVW;
+			break;
+		}
+		break;
+	case TUCHAR:
+		switch(tt) {
+		case TDOUBLE:
+		case TVLONG:
+			regalloc(&nod, f, Z);
+			gins(AMOVBU, f, &nod);
+			gins(AMOVWD, &nod, t);
+			regfree(&nod);
+			return;
+		case TFLOAT:
+			regalloc(&nod, f, Z);
+			gins(AMOVBU, f, &nod);
+			gins(AMOVWF, &nod, t);
+			regfree(&nod);
+			return;
+		case TINT:
+		case TUINT:
+		case TLONG:
+		case TULONG:
+		case TIND:
+		case TSHORT:
+		case TUSHORT:
+			a = AMOVBU;
+			break;
+		case TCHAR:
+		case TUCHAR:
+			a = AMOVW;
+			break;
+		}
+		break;
+	}
+	if(a == AGOK)
+		diag(Z, "bad opcode in gmove %T -> %T", f->type, t->type);
+	if(a == AMOVW || a == AMOVF || a == AMOVD)
+	if(samaddr(f, t))
+		return;
+	gins(a, f, t);
+}
+
+void
+gmover(Node *f, Node *t)
+{
+	int ft, tt, a;
+
+	ft = f->type->etype;
+	tt = t->type->etype;
+	a = AGOK;
+	if(typechlp[ft] && typechlp[tt] && ewidth[ft] >= ewidth[tt]){
+		switch(tt){
+		case TSHORT:
+			a = AMOVH;
+			break;
+		case TUSHORT:
+			a = AMOVHU;
+			break;
+		case TCHAR:
+			a = AMOVB;
+			break;
+		case TUCHAR:
+			a = AMOVBU;
+			break;
+		}
+	}
+	if(a == AGOK)
+		gmove(f, t);
+	else
+		gins(a, f, t);
+}
+
+void
+gins(int a, Node *f, Node *t)
+{
+
+	nextpc();
+	p->as = a;
+	if(f != Z)
+		naddr(f, &p->from);
+	if(t != Z)
+		naddr(t, &p->to);
+	if(debug['g'])
+		print("%P\n", p);
+}
+
+void
+gopcode(int o, Node *f1, Node *f2, Node *t)
+{
+	int a, et;
+	Adr ta;
+
+	et = TLONG;
+	if(f1 != Z && f1->type != T)
+		et = f1->type->etype;
+	a = AGOK;
+	switch(o) {
+	case OAS:
+		gmove(f1, t);
+		return;
+
+	case OASADD:
+	case OADD:
+		a = AADD;
+		if(et == TFLOAT)
+			a = AADDF;
+		else
+		if(et == TDOUBLE || et == TVLONG)
+			a = AADDD;
+		break;
+
+	case OASSUB:
+	case OSUB:
+		if(f2 && f2->op == OCONST) {
+			Node *t = f1;
+			f1 = f2;
+			f2 = t;
+			a = ARSB;
+		} else
+			a = ASUB;
+		if(et == TFLOAT)
+			a = ASUBF;
+		else
+		if(et == TDOUBLE || et == TVLONG)
+			a = ASUBD;
+		break;
+
+	case OASOR:
+	case OOR:
+		a = AORR;
+		break;
+
+	case OASAND:
+	case OAND:
+		a = AAND;
+		break;
+
+	case OASXOR:
+	case OXOR:
+		a = AEOR;
+		break;
+
+	case OASLSHR:
+	case OLSHR:
+		a = ASRL;
+		break;
+
+	case OASASHR:
+	case OASHR:
+		a = ASRA;
+		break;
+
+	case OASASHL:
+	case OASHL:
+		a = ASLL;
+		break;
+
+	case OFUNC:
+		a = ABL;
+		break;
+
+	case OASMUL:
+	case OMUL:
+		a = AMUL;
+		if(et == TFLOAT)
+			a = AMULF;
+		else
+		if(et == TDOUBLE || et == TVLONG)
+			a = AMULD;
+		break;
+
+	case OASDIV:
+	case ODIV:
+		a = ADIV;
+		if(et == TFLOAT)
+			a = ADIVF;
+		else
+		if(et == TDOUBLE || et == TVLONG)
+			a = ADIVD;
+		break;
+
+	case OASMOD:
+	case OMOD:
+		a = AMOD;
+		break;
+
+	case OASLMUL:
+	case OLMUL:
+		a = AMULU;
+		break;
+
+	case OASLMOD:
+	case OLMOD:
+		a = AMODU;
+		break;
+
+	case OASLDIV:
+	case OLDIV:
+		a = ADIVU;
+		break;
+
+	case OCASE:
+	case OEQ:
+	case ONE:
+	case OLT:
+	case OLE:
+	case OGE:
+	case OGT:
+	case OLO:
+	case OLS:
+	case OHS:
+	case OHI:
+		a = ACMP;
+		if(et == TFLOAT)
+			a = ACMPF;
+		else
+		if(et == TDOUBLE || et == TVLONG)
+			a = ACMPD;
+		nextpc();
+		p->as = a;
+		naddr(f1, &p->from);
+		if(a == ACMP && f1->op == OCONST && p->from.offset < 0) {
+			p->as = ACMN;
+			p->from.offset = -p->from.offset;
+		}
+		raddr(f2, p);
+		switch(o) {
+		case OEQ:
+			a = ABEQ;
+			break;
+		case ONE:
+			a = ABNE;
+			break;
+		case OLT:
+			a = ABLT;
+			break;
+		case OLE:
+			a = ABLE;
+			break;
+		case OGE:
+			a = ABGE;
+			break;
+		case OGT:
+			a = ABGT;
+			break;
+		case OLO:
+			a = ABLO;
+			break;
+		case OLS:
+			a = ABLS;
+			break;
+		case OHS:
+			a = ABHS;
+			break;
+		case OHI:
+			a = ABHI;
+			break;
+		case OCASE:
+			nextpc();
+			p->as = ACASE;
+			p->scond = 0x9;
+			naddr(f2, &p->from);
+			a = ABHI;
+			break;
+		}
+		f1 = Z;
+		f2 = Z;
+		break;
+	}
+	if(a == AGOK)
+		diag(Z, "bad in gopcode %O", o);
+	nextpc();
+	p->as = a;
+	if(f1 != Z)
+		naddr(f1, &p->from);
+	if(f2 != Z) {
+		naddr(f2, &ta);
+		p->reg = ta.reg;
+	}
+	if(t != Z)
+		naddr(t, &p->to);
+	if(debug['g'])
+		print("%P\n", p);
+}
+
+int
+samaddr(Node *f, Node *t)
+{
+
+	if(f->op != t->op)
+		return 0;
+	switch(f->op) {
+
+	case OREGISTER:
+		if(f->reg != t->reg)
+			break;
+		return 1;
+	}
+	return 0;
+}
+
+void
+gbranch(int o)
+{
+	int a;
+
+	a = AGOK;
+	switch(o) {
+	case ORETURN:
+		a = ARET;
+		break;
+	case OGOTO:
+		a = AB;
+		break;
+	}
+	nextpc();
+	if(a == AGOK) {
+		diag(Z, "bad in gbranch %O",  o);
+		nextpc();
+	}
+	p->as = a;
+}
+
+void
+patch(Prog *op, long pc)
+{
+
+	op->to.offset = pc;
+	op->to.type = D_BRANCH;
+}
+
+void
+gpseudo(int a, Sym *s, Node *n)
+{
+
+	nextpc();
+	p->as = a;
+	p->from.type = D_OREG;
+	p->from.sym = s;
+	p->from.name = D_EXTERN;
+	if(a == ATEXT)
+		p->reg = (profileflg ? 0 : NOPROF);
+	if(s->class == CSTATIC)
+		p->from.name = D_STATIC;
+	naddr(n, &p->to);
+	if(a == ADATA || a == AGLOBL)
+		pc--;
+}
+
+int
+sconst(Node *n)
+{
+	vlong vv;
+
+	if(n->op == OCONST) {
+		if(!typefd[n->type->etype]) {
+			vv = n->vconst;
+			if(vv >= (vlong)(-32766) && vv < (vlong)32766)
+				return 1;
+			/*
+			 * should be specialised for constant values which will
+			 * fit in different instructionsl; for now, let 5l
+			 * sort it out
+			 */
+			return 1;
+		}
+	}
+	return 0;
+}
+
+int
+sval(long v)
+{
+	int i;
+
+	for(i=0; i<16; i++) {
+		if((v & ~0xff) == 0)
+			return 1;
+		if((~v & ~0xff) == 0)
+			return 1;
+		v = (v<<2) | ((ulong)v>>30);
+	}
+	return 0;
+}
+
+long
+exreg(Type *t)
+{
+	long o;
+
+	if(typechlp[t->etype]) {
+		if(exregoffset <= REGEXT-4)
+			return 0;
+		o = exregoffset;
+		exregoffset--;
+		return o;
+	}
+	if(typefd[t->etype]) {
+		if(exfregoffset <= NFREG-1)
+			return 0;
+		o = exfregoffset + NREG;
+		exfregoffset--;
+		return o;
+	}
+	return 0;
+}
+
+schar	ewidth[NTYPE] =
+{
+	-1,		/* [TXXX] */
+	SZ_CHAR,	/* [TCHAR] */
+	SZ_CHAR,	/* [TUCHAR] */
+	SZ_SHORT,	/* [TSHORT] */
+	SZ_SHORT,	/* [TUSHORT] */
+	SZ_INT,		/* [TINT] */
+	SZ_INT,		/* [TUINT] */
+	SZ_LONG,	/* [TLONG] */
+	SZ_LONG,	/* [TULONG] */
+	SZ_VLONG,	/* [TVLONG] */
+	SZ_VLONG,	/* [TUVLONG] */
+	SZ_FLOAT,	/* [TFLOAT] */
+	SZ_DOUBLE,	/* [TDOUBLE] */
+	SZ_IND,		/* [TIND] */
+	0,		/* [TFUNC] */
+	-1,		/* [TARRAY] */
+	0,		/* [TVOID] */
+	-1,		/* [TSTRUCT] */
+	-1,		/* [TUNION] */
+	SZ_INT,		/* [TENUM] */
+};
+
+long	ncast[NTYPE] =
+{
+	0,				/* [TXXX] */
+	BCHAR|BUCHAR,			/* [TCHAR] */
+	BCHAR|BUCHAR,			/* [TUCHAR] */
+	BSHORT|BUSHORT,			/* [TSHORT] */
+	BSHORT|BUSHORT,			/* [TUSHORT] */
+	BINT|BUINT|BLONG|BULONG|BIND,	/* [TINT] */
+	BINT|BUINT|BLONG|BULONG|BIND,	/* [TUINT] */
+	BINT|BUINT|BLONG|BULONG|BIND,	/* [TLONG] */
+	BINT|BUINT|BLONG|BULONG|BIND,	/* [TULONG] */
+	BVLONG|BUVLONG,			/* [TVLONG] */
+	BVLONG|BUVLONG,			/* [TUVLONG] */
+	BFLOAT,				/* [TFLOAT] */
+	BDOUBLE,			/* [TDOUBLE] */
+	BLONG|BULONG|BIND,		/* [TIND] */
+	0,				/* [TFUNC] */
+	0,				/* [TARRAY] */
+	0,				/* [TVOID] */
+	BSTRUCT,			/* [TSTRUCT] */
+	BUNION,				/* [TUNION] */
+	0,				/* [TENUM] */
+};
diff --git a/src/cmd/5l/asm.c b/src/cmd/5l/asm.c
new file mode 100644
index 0000000000..e5392870a9
--- /dev/null
+++ b/src/cmd/5l/asm.c
@@ -0,0 +1,1831 @@
+// Inferno utils/5l/asm.c
+// http://code.google.com/p/inferno-os/source/browse/utils/5l/asm.c
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#include	"l.h"
+
+long	OFFSET;
+
+static Prog *PP;
+
+long
+entryvalue(void)
+{
+	char *a;
+	Sym *s;
+
+	a = INITENTRY;
+	if(*a >= '0' && *a <= '9')
+		return atolwhex(a);
+	s = lookup(a, 0);
+	if(s->type == 0)
+		return INITTEXT;
+	switch(s->type) {
+	case STEXT:
+	case SLEAF:
+		break;
+	case SDATA:
+		if(dlm)
+			return s->value+INITDAT;
+	default:
+		diag("entry not text: %s", s->name);
+	}
+	return s->value;
+}
+
+void
+asmb(void)
+{
+	Prog *p;
+	long t, etext;
+	Optab *o;
+
+	if(debug['v'])
+		Bprint(&bso, "%5.2f asm\n", cputime());
+	Bflush(&bso);
+	OFFSET = HEADR;
+	seek(cout, OFFSET, 0);
+	pc = INITTEXT;
+	for(p = firstp; p != P; p = p->link) {
+		setarch(p);
+		if(p->as == ATEXT) {
+			curtext = p;
+			autosize = p->to.offset + 4;
+		}
+		if(p->pc != pc) {
+			diag("phase error %lux sb %lux",
+				p->pc, pc);
+			if(!debug['a'])
+				prasm(curp);
+			pc = p->pc;
+		}
+		curp = p;
+		o = oplook(p);	/* could probably avoid this call */
+		if(thumb)
+			thumbasmout(p, o);
+		else
+			asmout(p, o);
+		pc += o->size;
+	}
+	while(pc-INITTEXT < textsize) {
+		cput(0);
+		pc++;
+	}
+
+	if(debug['a'])
+		Bprint(&bso, "\n");
+	Bflush(&bso);
+	cflush();
+
+	/* output strings in text segment */
+	etext = INITTEXT + textsize;
+	for(t = pc; t < etext; t += sizeof(buf)-100) {
+		if(etext-t > sizeof(buf)-100)
+			datblk(t, sizeof(buf)-100, 1);
+		else
+			datblk(t, etext-t, 1);
+	}
+
+	curtext = P;
+	switch(HEADTYPE) {
+	case 0:
+	case 1:
+	case 2:
+	case 5:
+		OFFSET = HEADR+textsize;
+		seek(cout, OFFSET, 0);
+		break;
+	case 3:
+		OFFSET = rnd(HEADR+textsize, 4096);
+		seek(cout, OFFSET, 0);
+		break;
+	}
+	if(dlm){
+		char buf[8];
+
+		write(cout, buf, INITDAT-textsize);
+		textsize = INITDAT;
+	}
+	for(t = 0; t < datsize; t += sizeof(buf)-100) {
+		if(datsize-t > sizeof(buf)-100)
+			datblk(t, sizeof(buf)-100, 0);
+		else
+			datblk(t, datsize-t, 0);
+	}
+	cflush();
+
+	symsize = 0;
+	lcsize = 0;
+	if(!debug['s']) {
+		if(debug['v'])
+			Bprint(&bso, "%5.2f sym\n", cputime());
+		Bflush(&bso);
+		switch(HEADTYPE) {
+		case 0:
+		case 1:
+		case 4:
+		case 5:
+			debug['s'] = 1;
+			break;
+		case 2:
+			OFFSET = HEADR+textsize+datsize;
+			seek(cout, OFFSET, 0);
+			break;
+		case 3:
+			OFFSET += rnd(datsize, 4096);
+			seek(cout, OFFSET, 0);
+			break;
+		}
+		if(!debug['s'])
+			asmsym();
+		if(debug['v'])
+			Bprint(&bso, "%5.2f pc\n", cputime());
+		Bflush(&bso);
+		if(!debug['s'])
+			asmlc();
+		if(!debug['s'])
+			asmthumbmap();
+		if(dlm)
+			asmdyn();
+		cflush();
+	}
+	else if(dlm){
+		seek(cout, HEADR+textsize+datsize, 0);
+		asmdyn();
+		cflush();
+	}
+
+	curtext = P;
+	if(debug['v'])
+		Bprint(&bso, "%5.2f header\n", cputime());
+	Bflush(&bso);
+	OFFSET = 0;
+	seek(cout, OFFSET, 0);
+	switch(HEADTYPE) {
+	case 0:	/* no header */
+		break;
+	case 1:	/* aif for risc os */
+		lputl(0xe1a00000);		/* NOP - decompress code */
+		lputl(0xe1a00000);		/* NOP - relocation code */
+		lputl(0xeb000000 + 12);		/* BL - zero init code */
+		lputl(0xeb000000 +
+			(entryvalue()
+			 - INITTEXT
+			 + HEADR
+			 - 12
+			 - 8) / 4);		/* BL - entry code */
+
+		lputl(0xef000011);		/* SWI - exit code */
+		lputl(textsize+HEADR);		/* text size */
+		lputl(datsize);			/* data size */
+		lputl(0);			/* sym size */
+
+		lputl(bsssize);			/* bss size */
+		lputl(0);			/* sym type */
+		lputl(INITTEXT-HEADR);		/* text addr */
+		lputl(0);			/* workspace - ignored */
+
+		lputl(32);			/* addr mode / data addr flag */
+		lputl(0);			/* data addr */
+		for(t=0; t<2; t++)
+			lputl(0);		/* reserved */
+
+		for(t=0; t<15; t++)
+			lputl(0xe1a00000);	/* NOP - zero init code */
+		lputl(0xe1a0f00e);		/* B (R14) - zero init return */
+		break;
+	case 2:	/* plan 9 */
+		if(dlm)
+			lput(0x80000000|0x647);	/* magic */
+		else
+			lput(0x647);			/* magic */
+		lput(textsize);			/* sizes */
+		lput(datsize);
+		lput(bsssize);
+		lput(symsize);			/* nsyms */
+		lput(entryvalue());		/* va of entry */
+		lput(0L);
+		lput(lcsize);
+		break;
+	case 3:	/* boot for NetBSD */
+		lput((143<<16)|0413);		/* magic */
+		lputl(rnd(HEADR+textsize, 4096));
+		lputl(rnd(datsize, 4096));
+		lputl(bsssize);
+		lputl(symsize);			/* nsyms */
+		lputl(entryvalue());		/* va of entry */
+		lputl(0L);
+		lputl(0L);
+		break;
+	case 4: /* boot for IXP1200 */
+		break;
+	case 5: /* boot for ipaq */
+		lputl(0xe3300000);		/* nop */
+		lputl(0xe3300000);		/* nop */
+		lputl(0xe3300000);		/* nop */
+		lputl(0xe3300000);		/* nop */
+		break;
+	}
+	cflush();
+	if(debug['c']){
+		print("textsize=%ld\n", textsize);
+		print("datsize=%ld\n", datsize);
+		print("bsssize=%ld\n", bsssize);
+		print("symsize=%ld\n", symsize);
+		print("lcsize=%ld\n", lcsize);
+		print("total=%ld\n", textsize+datsize+bsssize+symsize+lcsize);
+	}
+}
+
+void
+strnput(char *s, int n)
+{
+	for(; *s; s++){
+		cput(*s);
+		n--;
+	}
+	for(; n > 0; n--)
+		cput(0);
+}
+
+void
+cput(int c)
+{
+	cbp[0] = c;
+	cbp++;
+	cbc--;
+	if(cbc <= 0)
+		cflush();
+}
+
+/*
+void
+cput(long c)
+{
+	*cbp++ = c;
+	if(--cbc <= 0)
+		cflush();
+}
+*/
+
+void
+wput(long l)
+{
+
+	cbp[0] = l>>8;
+	cbp[1] = l;
+	cbp += 2;
+	cbc -= 2;
+	if(cbc <= 0)
+		cflush();
+}
+
+void
+hput(long l)
+{
+
+	cbp[0] = l>>8;
+	cbp[1] = l;
+	cbp += 2;
+	cbc -= 2;
+	if(cbc <= 0)
+		cflush();
+}
+
+void
+lput(long l)
+{
+
+	cbp[0] = l>>24;
+	cbp[1] = l>>16;
+	cbp[2] = l>>8;
+	cbp[3] = l;
+	cbp += 4;
+	cbc -= 4;
+	if(cbc <= 0)
+		cflush();
+}
+
+void
+lputl(long l)
+{
+
+	cbp[3] = l>>24;
+	cbp[2] = l>>16;
+	cbp[1] = l>>8;
+	cbp[0] = l;
+	cbp += 4;
+	cbc -= 4;
+	if(cbc <= 0)
+		cflush();
+}
+
+void
+cflush(void)
+{
+	int n;
+
+	/* no bug if cbc < 0 since obuf(cbuf) followed by ibuf in buf! */
+	n = sizeof(buf.cbuf) - cbc;
+	if(n)
+		write(cout, buf.cbuf, n);
+	cbp = buf.cbuf;
+	cbc = sizeof(buf.cbuf);
+}
+
+void
+nopstat(char *f, Count *c)
+{
+	if(c->outof)
+	Bprint(&bso, "%s delay %ld/%ld (%.2f)\n", f,
+		c->outof - c->count, c->outof,
+		(double)(c->outof - c->count)/c->outof);
+}
+
+void
+asmsym(void)
+{
+	Prog *p;
+	Auto *a;
+	Sym *s;
+	int h;
+
+	s = lookup("etext", 0);
+	if(s->type == STEXT)
+		putsymb(s->name, 'T', s->value, s->version);
+
+	for(h=0; h<NHASH; h++)
+		for(s=hash[h]; s!=S; s=s->link)
+			switch(s->type) {
+			case SCONST:
+				putsymb(s->name, 'D', s->value, s->version);
+				continue;
+
+			case SDATA:
+				putsymb(s->name, 'D', s->value+INITDAT, s->version);
+				continue;
+
+			case SBSS:
+				putsymb(s->name, 'B', s->value+INITDAT, s->version);
+				continue;
+
+			case SSTRING:
+				putsymb(s->name, 'T', s->value, s->version);
+				continue;
+
+			case SFILE:
+				putsymb(s->name, 'f', s->value, s->version);
+				continue;
+			}
+
+	for(p=textp; p!=P; p=p->cond) {
+		s = p->from.sym;
+		if(s->type != STEXT && s->type != SLEAF)
+			continue;
+
+		/* filenames first */
+		for(a=p->to.autom; a; a=a->link)
+			if(a->type == D_FILE)
+				putsymb(a->asym->name, 'z', a->aoffset, 0);
+			else
+			if(a->type == D_FILE1)
+				putsymb(a->asym->name, 'Z', a->aoffset, 0);
+
+		if(s->type == STEXT)
+			putsymb(s->name, 'T', s->value, s->version);
+		else
+			putsymb(s->name, 'L', s->value, s->version);
+
+		/* frame, auto and param after */
+		putsymb(".frame", 'm', p->to.offset+4, 0);
+		for(a=p->to.autom; a; a=a->link)
+			if(a->type == D_AUTO)
+				putsymb(a->asym->name, 'a', -a->aoffset, 0);
+			else
+			if(a->type == D_PARAM)
+				putsymb(a->asym->name, 'p', a->aoffset, 0);
+	}
+	if(debug['v'] || debug['n'])
+		Bprint(&bso, "symsize = %lud\n", symsize);
+	Bflush(&bso);
+}
+
+void
+putsymb(char *s, int t, long v, int ver)
+{
+	int i, f;
+
+	if(t == 'f')
+		s++;
+	lput(v);
+	if(ver)
+		t += 'a' - 'A';
+	cput(t+0x80);			/* 0x80 is variable length */
+
+	if(t == 'Z' || t == 'z') {
+		cput(s[0]);
+		for(i=1; s[i] != 0 || s[i+1] != 0; i += 2) {
+			cput(s[i]);
+			cput(s[i+1]);
+		}
+		cput(0);
+		cput(0);
+		i++;
+	}
+	else {
+		for(i=0; s[i]; i++)
+			cput(s[i]);
+		cput(0);
+	}
+	symsize += 4 + 1 + i + 1;
+
+	if(debug['n']) {
+		if(t == 'z' || t == 'Z') {
+			Bprint(&bso, "%c %.8lux ", t, v);
+			for(i=1; s[i] != 0 || s[i+1] != 0; i+=2) {
+				f = ((s[i]&0xff) << 8) | (s[i+1]&0xff);
+				Bprint(&bso, "/%x", f);
+			}
+			Bprint(&bso, "\n");
+			return;
+		}
+		if(ver)
+			Bprint(&bso, "%c %.8lux %s<%d>\n", t, v, s, ver);
+		else
+			Bprint(&bso, "%c %.8lux %s\n", t, v, s);
+	}
+}
+
+#define	MINLC	4
+void
+asmlc(void)
+{
+	long oldpc, oldlc;
+	Prog *p;
+	long v, s;
+
+	oldpc = INITTEXT;
+	oldlc = 0;
+	for(p = firstp; p != P; p = p->link) {
+		setarch(p);
+		if(p->line == oldlc || p->as == ATEXT || p->as == ANOP) {
+			if(p->as == ATEXT)
+				curtext = p;
+			if(debug['L'])
+				Bprint(&bso, "%6lux %P\n",
+					p->pc, p);
+			continue;
+		}
+		if(debug['L'])
+			Bprint(&bso, "\t\t%6ld", lcsize);
+		v = (p->pc - oldpc) / MINLC;
+		while(v) {
+			s = 127;
+			if(v < 127)
+				s = v;
+			cput(s+128);	/* 129-255 +pc */
+			if(debug['L'])
+				Bprint(&bso, " pc+%ld*%d(%ld)", s, MINLC, s+128);
+			v -= s;
+			lcsize++;
+		}
+		s = p->line - oldlc;
+		oldlc = p->line;
+		oldpc = p->pc + MINLC;
+		if(s > 64 || s < -64) {
+			cput(0);	/* 0 vv +lc */
+			cput(s>>24);
+			cput(s>>16);
+			cput(s>>8);
+			cput(s);
+			if(debug['L']) {
+				if(s > 0)
+					Bprint(&bso, " lc+%ld(%d,%ld)\n",
+						s, 0, s);
+				else
+					Bprint(&bso, " lc%ld(%d,%ld)\n",
+						s, 0, s);
+				Bprint(&bso, "%6lux %P\n",
+					p->pc, p);
+			}
+			lcsize += 5;
+			continue;
+		}
+		if(s > 0) {
+			cput(0+s);	/* 1-64 +lc */
+			if(debug['L']) {
+				Bprint(&bso, " lc+%ld(%ld)\n", s, 0+s);
+				Bprint(&bso, "%6lux %P\n",
+					p->pc, p);
+			}
+		} else {
+			cput(64-s);	/* 65-128 -lc */
+			if(debug['L']) {
+				Bprint(&bso, " lc%ld(%ld)\n", s, 64-s);
+				Bprint(&bso, "%6lux %P\n",
+					p->pc, p);
+			}
+		}
+		lcsize++;
+	}
+	while(lcsize & 1) {
+		s = 129;
+		cput(s);
+		lcsize++;
+	}
+	if(debug['v'] || debug['L'])
+		Bprint(&bso, "lcsize = %ld\n", lcsize);
+	Bflush(&bso);
+}
+
+static void
+outt(long f, long l)
+{
+	if(debug['L'])
+		Bprint(&bso, "tmap: %lux-%lux\n", f, l);
+	lput(f);
+	lput(l);
+}
+
+void
+asmthumbmap(void)
+{
+	long pc, lastt;
+	Prog *p;
+
+	if(!seenthumb)
+		return;
+	pc = 0;
+	lastt = -1;
+	for(p = firstp; p != P; p = p->link){
+		pc = p->pc - INITTEXT;
+		if(p->as == ATEXT){
+			setarch(p);
+			if(thumb){
+				if(p->from.sym->foreign){	// 8 bytes of ARM first
+					if(lastt >= 0){
+						outt(lastt, pc-1);
+						lastt = -1;
+					}
+					pc += 8;
+				}
+				if(lastt < 0)
+					lastt = pc;
+			}
+			else{
+				if(p->from.sym->foreign){	// 4 bytes of THUMB first
+					if(lastt < 0)
+						lastt = pc;
+					pc += 4;
+				}
+				if(lastt >= 0){
+					outt(lastt, pc-1);
+					lastt = -1;
+				}
+			}
+		}
+	}
+	if(lastt >= 0)
+		outt(lastt, pc+1);
+}
+
+void
+datblk(long s, long n, int str)
+{
+	Sym *v;
+	Prog *p;
+	char *cast;
+	long a, l, fl, j, d;
+	int i, c;
+
+	memset(buf.dbuf, 0, n+100);
+	for(p = datap; p != P; p = p->link) {
+		if(str != (p->from.sym->type == SSTRING))
+			continue;
+		curp = p;
+		a = p->from.sym->value + p->from.offset;
+		l = a - s;
+		c = p->reg;
+		i = 0;
+		if(l < 0) {
+			if(l+c <= 0)
+				continue;
+			while(l < 0) {
+				l++;
+				i++;
+			}
+		}
+		if(l >= n)
+			continue;
+		if(p->as != AINIT && p->as != ADYNT) {
+			for(j=l+(c-i)-1; j>=l; j--)
+				if(buf.dbuf[j]) {
+					print("%P\n", p);
+					diag("multiple initialization");
+					break;
+				}
+		}
+		switch(p->to.type) {
+		default:
+			diag("unknown mode in initialization%P", p);
+			break;
+
+		case D_FCONST:
+			switch(c) {
+			default:
+			case 4:
+				fl = ieeedtof(p->to.ieee);
+				cast = (char*)&fl;
+				for(; i<c; i++) {
+					buf.dbuf[l] = cast[fnuxi4[i]];
+					l++;
+				}
+				break;
+			case 8:
+				cast = (char*)p->to.ieee;
+				for(; i<c; i++) {
+					buf.dbuf[l] = cast[fnuxi8[i]];
+					l++;
+				}
+				break;
+			}
+			break;
+
+		case D_SCONST:
+			for(; i<c; i++) {
+				buf.dbuf[l] = p->to.sval[i];
+				l++;
+			}
+			break;
+
+		case D_CONST:
+			d = p->to.offset;
+			v = p->to.sym;
+			if(v) {
+				switch(v->type) {
+				case SUNDEF:
+					ckoff(v, d);
+					d += v->value;
+					break;
+				case STEXT:
+				case SLEAF:
+					d += v->value;
+#ifdef CALLEEBX
+					d += fnpinc(v);
+#else
+					if(v->thumb)
+						d++;		// T bit
+#endif
+					break;
+				case SSTRING:
+					d += v->value;
+					break;
+				case SDATA:
+				case SBSS:
+					d += v->value + INITDAT;
+					break;
+				}
+				if(dlm)
+					dynreloc(v, a+INITDAT, 1);
+			}
+			cast = (char*)&d;
+			switch(c) {
+			default:
+				diag("bad nuxi %d %d%P", c, i, curp);
+				break;
+			case 1:
+				for(; i<c; i++) {
+					buf.dbuf[l] = cast[inuxi1[i]];
+					l++;
+				}
+				break;
+			case 2:
+				for(; i<c; i++) {
+					buf.dbuf[l] = cast[inuxi2[i]];
+					l++;
+				}
+				break;
+			case 4:
+				for(; i<c; i++) {
+					buf.dbuf[l] = cast[inuxi4[i]];
+					l++;
+				}
+				break;
+			}
+			break;
+		}
+	}
+	write(cout, buf.dbuf, n);
+}
+
+void
+asmout(Prog *p, Optab *o)
+{
+	long o1, o2, o3, o4, o5, o6, v;
+	int r, rf, rt, rt2;
+	Sym *s;
+
+PP = p;
+	o1 = 0;
+	o2 = 0;
+	o3 = 0;
+	o4 = 0;
+	o5 = 0;
+	o6 = 0;
+	armsize += o->size;
+if(debug['P']) print("%ulx: %P	type %d\n", (ulong)(p->pc), p, o->type);
+	switch(o->type) {
+	default:
+		diag("unknown asm %d", o->type);
+		prasm(p);
+		break;
+
+	case 0:		/* pseudo ops */
+if(debug['G']) print("%ulx: %s: arm %d %d %d %d\n", (ulong)(p->pc), p->from.sym->name, p->from.sym->thumb, p->from.sym->foreign, p->from.sym->fnptr, p->from.sym->used);
+		break;
+
+	case 1:		/* op R,[R],R */
+		o1 = oprrr(p->as, p->scond);
+		rf = p->from.reg;
+		rt = p->to.reg;
+		r = p->reg;
+		if(p->to.type == D_NONE)
+			rt = 0;
+		if(p->as == AMOVW || p->as == AMVN)
+			r = 0;
+		else if(r == NREG)
+			r = rt;
+		o1 |= rf | (r<<16) | (rt<<12);
+		break;
+
+	case 2:		/* movbu $I,[R],R */
+		aclass(&p->from);
+		o1 = oprrr(p->as, p->scond);
+		o1 |= immrot(instoffset);
+		rt = p->to.reg;
+		r = p->reg;
+		if(p->to.type == D_NONE)
+			rt = 0;
+		if(p->as == AMOVW || p->as == AMVN)
+			r = 0;
+		else if(r == NREG)
+			r = rt;
+		o1 |= (r<<16) | (rt<<12);
+		break;
+
+	case 3:		/* add R<<[IR],[R],R */
+	mov:
+		aclass(&p->from);
+		o1 = oprrr(p->as, p->scond);
+		o1 |= p->from.offset;
+		rt = p->to.reg;
+		r = p->reg;
+		if(p->to.type == D_NONE)
+			rt = 0;
+		if(p->as == AMOVW || p->as == AMVN)
+			r = 0;
+		else if(r == NREG)
+			r = rt;
+		o1 |= (r<<16) | (rt<<12);
+		break;
+
+	case 4:		/* add $I,[R],R */
+		aclass(&p->from);
+		o1 = oprrr(AADD, p->scond);
+		o1 |= immrot(instoffset);
+		r = p->from.reg;
+		if(r == NREG)
+			r = o->param;
+		o1 |= r << 16;
+		o1 |= p->to.reg << 12;
+		break;
+
+	case 5:		/* bra s */
+		v = -8;
+		if(p->cond == UP) {
+			s = p->to.sym;
+			if(s->type != SUNDEF)
+				diag("bad branch sym type");
+			v = (ulong)s->value >> (Roffset-2);
+			dynreloc(s, p->pc, 0);
+		}
+		else if(p->cond != P)
+			v = (p->cond->pc - pc) - 8;
+#ifdef CALLEEBX
+		if(p->as == ABL)
+			v += fninc(p->to.sym);
+#endif
+		o1 = opbra(p->as, p->scond);
+		o1 |= (v >> 2) & 0xffffff;
+		break;
+
+	case 6:		/* b ,O(R) -> add $O,R,PC */
+		aclass(&p->to);
+		o1 = oprrr(AADD, p->scond);
+		o1 |= immrot(instoffset);
+		o1 |= p->to.reg << 16;
+		o1 |= REGPC << 12;
+		break;
+
+	case 7:		/* bl ,O(R) -> mov PC,link; add $O,R,PC */
+		aclass(&p->to);
+		o1 = oprrr(AADD, p->scond);
+		o1 |= immrot(0);
+		o1 |= REGPC << 16;
+		o1 |= REGLINK << 12;
+
+		o2 = oprrr(AADD, p->scond);
+		o2 |= immrot(instoffset);
+		o2 |= p->to.reg << 16;
+		o2 |= REGPC << 12;
+		break;
+
+	case 8:		/* sll $c,[R],R -> mov (R<<$c),R */
+		aclass(&p->from);
+		o1 = oprrr(p->as, p->scond);
+		r = p->reg;
+		if(r == NREG)
+			r = p->to.reg;
+		o1 |= r;
+		o1 |= (instoffset&31) << 7;
+		o1 |= p->to.reg << 12;
+		break;
+
+	case 9:		/* sll R,[R],R -> mov (R<<R),R */
+		o1 = oprrr(p->as, p->scond);
+		r = p->reg;
+		if(r == NREG)
+			r = p->to.reg;
+		o1 |= r;
+		o1 |= (p->from.reg << 8) | (1<<4);
+		o1 |= p->to.reg << 12;
+		break;
+
+	case 10:	/* swi [$con] */
+		o1 = oprrr(p->as, p->scond);
+		if(p->to.type != D_NONE) {
+			aclass(&p->to);
+			o1 |= instoffset & 0xffffff;
+		}
+		break;
+
+	case 11:	/* word */
+		switch(aclass(&p->to)) {
+		case C_LCON:
+			if(!dlm)
+				break;
+			if(p->to.name != D_EXTERN && p->to.name != D_STATIC)
+				break;
+		case C_ADDR:
+			if(p->to.sym->type == SUNDEF)
+				ckoff(p->to.sym, p->to.offset);
+			dynreloc(p->to.sym, p->pc, 1);
+		}
+		o1 = instoffset;
+		break;
+
+	case 12:	/* movw $lcon, reg */
+		o1 = omvl(p, &p->from, p->to.reg);
+		break;
+
+	case 13:	/* op $lcon, [R], R */
+		o1 = omvl(p, &p->from, REGTMP);
+		if(!o1)
+			break;
+		o2 = oprrr(p->as, p->scond);
+		o2 |= REGTMP;
+		r = p->reg;
+		if(p->as == AMOVW || p->as == AMVN)
+			r = 0;
+		else if(r == NREG)
+			r = p->to.reg;
+		o2 |= r << 16;
+		if(p->to.type != D_NONE)
+			o2 |= p->to.reg << 12;
+		break;
+
+	case 14:	/* movb/movbu/movh/movhu R,R */
+		o1 = oprrr(ASLL, p->scond);
+
+		if(p->as == AMOVBU || p->as == AMOVHU)
+			o2 = oprrr(ASRL, p->scond);
+		else
+			o2 = oprrr(ASRA, p->scond);
+
+		r = p->to.reg;
+		o1 |= (p->from.reg)|(r<<12);
+		o2 |= (r)|(r<<12);
+		if(p->as == AMOVB || p->as == AMOVBU) {
+			o1 |= (24<<7);
+			o2 |= (24<<7);
+		} else {
+			o1 |= (16<<7);
+			o2 |= (16<<7);
+		}
+		break;
+
+	case 15:	/* mul r,[r,]r */
+		o1 = oprrr(p->as, p->scond);
+		rf = p->from.reg;
+		rt = p->to.reg;
+		r = p->reg;
+		if(r == NREG)
+			r = rt;
+		if(rt == r) {
+			r = rf;
+			rf = rt;
+		}
+		if(0)
+		if(rt == r || rf == REGPC || r == REGPC || rt == REGPC) {
+			diag("bad registers in MUL");
+			prasm(p);
+		}
+		o1 |= (rf<<8) | r | (rt<<16);
+		break;
+
+
+	case 16:	/* div r,[r,]r */
+		o1 = 0xf << 28;
+		o2 = 0;
+		break;
+
+	case 17:
+		o1 = oprrr(p->as, p->scond);
+		rf = p->from.reg;
+		rt = p->to.reg;
+		rt2 = p->to.offset;
+		r = p->reg;
+		o1 |= (rf<<8) | r | (rt<<16) | (rt2<<12);
+		break;
+
+	case 20:	/* mov/movb/movbu R,O(R) */
+		aclass(&p->to);
+		r = p->to.reg;
+		if(r == NREG)
+			r = o->param;
+		o1 = osr(p->as, p->from.reg, instoffset, r, p->scond);
+		break;
+
+	case 21:	/* mov/movbu O(R),R -> lr */
+		aclass(&p->from);
+		r = p->from.reg;
+		if(r == NREG)
+			r = o->param;
+		o1 = olr(instoffset, r, p->to.reg, p->scond);
+		if(p->as != AMOVW)
+			o1 |= 1<<22;
+		break;
+
+	case 22:	/* movb/movh/movhu O(R),R -> lr,shl,shr */
+		aclass(&p->from);
+		r = p->from.reg;
+		if(r == NREG)
+			r = o->param;
+		o1 = olr(instoffset, r, p->to.reg, p->scond);
+
+		o2 = oprrr(ASLL, p->scond);
+		o3 = oprrr(ASRA, p->scond);
+		r = p->to.reg;
+		if(p->as == AMOVB) {
+			o2 |= (24<<7)|(r)|(r<<12);
+			o3 |= (24<<7)|(r)|(r<<12);
+		} else {
+			o2 |= (16<<7)|(r)|(r<<12);
+			if(p->as == AMOVHU)
+				o3 = oprrr(ASRL, p->scond);
+			o3 |= (16<<7)|(r)|(r<<12);
+		}
+		break;
+
+	case 23:	/* movh/movhu R,O(R) -> sb,sb */
+		aclass(&p->to);
+		r = p->to.reg;
+		if(r == NREG)
+			r = o->param;
+		o1 = osr(AMOVH, p->from.reg, instoffset, r, p->scond);
+
+		o2 = oprrr(ASRL, p->scond);
+		o2 |= (8<<7)|(p->from.reg)|(REGTMP<<12);
+
+		o3 = osr(AMOVH, REGTMP, instoffset+1, r, p->scond);
+		break;
+
+	case 30:	/* mov/movb/movbu R,L(R) */
+		o1 = omvl(p, &p->to, REGTMP);
+		if(!o1)
+			break;
+		r = p->to.reg;
+		if(r == NREG)
+			r = o->param;
+		o2 = osrr(p->from.reg, REGTMP,r, p->scond);
+		if(p->as != AMOVW)
+			o2 |= 1<<22;
+		break;
+
+	case 31:	/* mov/movbu L(R),R -> lr[b] */
+	case 32:	/* movh/movb L(R),R -> lr[b] */
+		o1 = omvl(p, &p->from, REGTMP);
+		if(!o1)
+			break;
+		r = p->from.reg;
+		if(r == NREG)
+			r = o->param;
+		o2 = olrr(REGTMP,r, p->to.reg, p->scond);
+		if(p->as == AMOVBU || p->as == AMOVB)
+			o2 |= 1<<22;
+		if(o->type == 31)
+			break;
+
+		o3 = oprrr(ASLL, p->scond);
+
+		if(p->as == AMOVBU || p->as == AMOVHU)
+			o4 = oprrr(ASRL, p->scond);
+		else
+			o4 = oprrr(ASRA, p->scond);
+
+		r = p->to.reg;
+		o3 |= (r)|(r<<12);
+		o4 |= (r)|(r<<12);
+		if(p->as == AMOVB || p->as == AMOVBU) {
+			o3 |= (24<<7);
+			o4 |= (24<<7);
+		} else {
+			o3 |= (16<<7);
+			o4 |= (16<<7);
+		}
+		break;
+
+	case 33:	/* movh/movhu R,L(R) -> sb, sb */
+		o1 = omvl(p, &p->to, REGTMP);
+		if(!o1)
+			break;
+		r = p->to.reg;
+		if(r == NREG)
+			r = o->param;
+		o2 = osrr(p->from.reg, REGTMP, r, p->scond);
+		o2 |= (1<<22) ;
+
+		o3 = oprrr(ASRL, p->scond);
+		o3 |= (8<<7)|(p->from.reg)|(p->from.reg<<12);
+		o3 |= (1<<6);	/* ROR 8 */
+
+		o4 = oprrr(AADD, p->scond);
+		o4 |= (REGTMP << 12) | (REGTMP << 16);
+		o4 |= immrot(1);
+
+		o5 = osrr(p->from.reg, REGTMP,r,p->scond);
+		o5 |= (1<<22);
+
+		o6 = oprrr(ASRL, p->scond);
+		o6 |= (24<<7)|(p->from.reg)|(p->from.reg<<12);
+		o6 |= (1<<6);	/* ROL 8 */
+
+		break;
+		
+	case 34:	/* mov $lacon,R */
+		o1 = omvl(p, &p->from, REGTMP);
+		if(!o1)
+			break;
+
+		o2 = oprrr(AADD, p->scond);
+		o2 |= REGTMP;
+		r = p->from.reg;
+		if(r == NREG)
+			r = o->param;
+		o2 |= r << 16;
+		if(p->to.type != D_NONE)
+			o2 |= p->to.reg << 12;
+		break;
+
+	case 35:	/* mov PSR,R */
+		o1 = (2<<23) | (0xf<<16) | (0<<0);
+		o1 |= (p->scond & C_SCOND) << 28;
+		o1 |= (p->from.reg & 1) << 22;
+		o1 |= p->to.reg << 12;
+		break;
+
+	case 36:	/* mov R,PSR */
+		o1 = (2<<23) | (0x29f<<12) | (0<<4);
+		if(p->scond & C_FBIT)
+			o1 ^= 0x010 << 12;
+		o1 |= (p->scond & C_SCOND) << 28;
+		o1 |= (p->to.reg & 1) << 22;
+		o1 |= p->from.reg << 0;
+		break;
+
+	case 37:	/* mov $con,PSR */
+		aclass(&p->from);
+		o1 = (2<<23) | (0x29f<<12) | (0<<4);
+		if(p->scond & C_FBIT)
+			o1 ^= 0x010 << 12;
+		o1 |= (p->scond & C_SCOND) << 28;
+		o1 |= immrot(instoffset);
+		o1 |= (p->to.reg & 1) << 22;
+		o1 |= p->from.reg << 0;
+		break;
+
+	case 38:	/* movm $con,oreg -> stm */
+		o1 = (0x4 << 25);
+		o1 |= p->from.offset & 0xffff;
+		o1 |= p->to.reg << 16;
+		aclass(&p->to);
+		goto movm;
+
+	case 39:	/* movm oreg,$con -> ldm */
+		o1 = (0x4 << 25) | (1 << 20);
+		o1 |= p->to.offset & 0xffff;
+		o1 |= p->from.reg << 16;
+		aclass(&p->from);
+	movm:
+		if(instoffset != 0)
+			diag("offset must be zero in MOVM");
+		o1 |= (p->scond & C_SCOND) << 28;
+		if(p->scond & C_PBIT)
+			o1 |= 1 << 24;
+		if(p->scond & C_UBIT)
+			o1 |= 1 << 23;
+		if(p->scond & C_SBIT)
+			o1 |= 1 << 22;
+		if(p->scond & C_WBIT)
+			o1 |= 1 << 21;
+		break;
+
+	case 40:	/* swp oreg,reg,reg */
+		aclass(&p->from);
+		if(instoffset != 0)
+			diag("offset must be zero in SWP");
+		o1 = (0x2<<23) | (0x9<<4);
+		if(p->as != ASWPW)
+			o1 |= 1 << 22;
+		o1 |= p->from.reg << 16;
+		o1 |= p->reg << 0;
+		o1 |= p->to.reg << 12;
+		o1 |= (p->scond & C_SCOND) << 28;
+		break;
+
+	case 41:	/* rfe -> movm.s.w.u 0(r13),[r15] */
+		o1 = 0xe8fd8000;
+		break;
+
+	case 50:	/* floating point store */
+		v = regoff(&p->to);
+		r = p->to.reg;
+		if(r == NREG)
+			r = o->param;
+		o1 = ofsr(p->as, p->from.reg, v, r, p->scond, p);
+		break;
+
+	case 51:	/* floating point load */
+		v = regoff(&p->from);
+		r = p->from.reg;
+		if(r == NREG)
+			r = o->param;
+		o1 = ofsr(p->as, p->to.reg, v, r, p->scond, p) | (1<<20);
+		break;
+
+	case 52:	/* floating point store, long offset UGLY */
+		o1 = omvl(p, &p->to, REGTMP);
+		if(!o1)
+			break;
+		r = p->to.reg;
+		if(r == NREG)
+			r = o->param;
+		o2 = oprrr(AADD, p->scond) | (REGTMP << 12) | (REGTMP << 16) | r;
+		o3 = ofsr(p->as, p->from.reg, 0, REGTMP, p->scond, p);
+		break;
+
+	case 53:	/* floating point load, long offset UGLY */
+		o1 = omvl(p, &p->from, REGTMP);
+		if(!o1)
+			break;
+		r = p->from.reg;
+		if(r == NREG)
+			r = o->param;
+		o2 = oprrr(AADD, p->scond) | (REGTMP << 12) | (REGTMP << 16) | r;
+		o3 = ofsr(p->as, p->to.reg, 0, REGTMP, p->scond, p) | (1<<20);
+		break;
+
+	case 54:	/* floating point arith */
+		o1 = oprrr(p->as, p->scond);
+		if(p->from.type == D_FCONST) {
+			rf = chipfloat(p->from.ieee);
+			if(rf < 0){
+				diag("invalid floating-point immediate\n%P", p);
+				rf = 0;
+			}
+			rf |= (1<<3);
+		} else
+			rf = p->from.reg;
+		rt = p->to.reg;
+		r = p->reg;
+		if(p->to.type == D_NONE)
+			rt = 0;	/* CMP[FD] */
+		else if(o1 & (1<<15))
+			r = 0;	/* monadic */
+		else if(r == NREG)
+			r = rt;
+		o1 |= rf | (r<<16) | (rt<<12);
+		break;
+
+	case 55:	/* floating point fix and float */
+		o1 = oprrr(p->as, p->scond);
+		rf = p->from.reg;
+		rt = p->to.reg;
+		if(p->to.type == D_NONE){
+			rt = 0;
+			diag("to.type==D_NONE (asm/fp)");
+		}
+		if(p->from.type == D_REG)
+			o1 |= (rf<<12) | (rt<<16);
+		else
+			o1 |= rf | (rt<<12);
+		break;
+
+	case 56:	/* move to FP[CS]R */
+		o1 = ((p->scond & C_SCOND) << 28) | (0xe << 24) | (1<<8) | (1<<4);
+		o1 |= ((p->to.reg+1)<<21) | (p->from.reg << 12);
+		break;
+
+	case 57:	/* move from FP[CS]R */
+		o1 = ((p->scond & C_SCOND) << 28) | (0xe << 24) | (1<<8) | (1<<4);
+		o1 |= ((p->from.reg+1)<<21) | (p->to.reg<<12) | (1<<20);
+		break;
+	case 58:	/* movbu R,R */
+		o1 = oprrr(AAND, p->scond);
+		o1 |= immrot(0xff);
+		rt = p->to.reg;
+		r = p->from.reg;
+		if(p->to.type == D_NONE)
+			rt = 0;
+		if(r == NREG)
+			r = rt;
+		o1 |= (r<<16) | (rt<<12);
+		break;
+
+	case 59:	/* movw/bu R<<I(R),R -> ldr indexed */
+		if(p->from.reg == NREG) {
+			if(p->as != AMOVW)
+				diag("byte MOV from shifter operand");
+			goto mov;
+		}
+		if(p->from.offset&(1<<4))
+			diag("bad shift in LDR");
+		o1 = olrr(p->from.offset, p->from.reg, p->to.reg, p->scond);
+		if(p->as == AMOVBU)
+			o1 |= 1<<22;
+		break;
+
+	case 60:	/* movb R(R),R -> ldrsb indexed */
+		if(p->from.reg == NREG) {
+			diag("byte MOV from shifter operand");
+			goto mov;
+		}
+		if(p->from.offset&(~0xf))
+			diag("bad shift in LDRSB");
+		o1 = olhrr(p->from.offset, p->from.reg, p->to.reg, p->scond);
+		o1 ^= (1<<5)|(1<<6);
+		break;
+
+	case 61:	/* movw/b/bu R,R<<[IR](R) -> str indexed */
+		if(p->to.reg == NREG)
+			diag("MOV to shifter operand");
+		o1 = osrr(p->from.reg, p->to.offset, p->to.reg, p->scond);
+		if(p->as == AMOVB || p->as == AMOVBU)
+			o1 |= 1<<22;
+		break;
+
+	case 62:	/* case R -> movw	R<<2(PC),PC */
+		o1 = olrr(p->from.reg, REGPC, REGPC, p->scond);
+		o1 |= 2<<7;
+		break;
+
+	case 63:	/* bcase */
+		if(p->cond != P) {
+			o1 = p->cond->pc;
+			if(dlm)
+				dynreloc(S, p->pc, 1);
+		}
+		break;
+
+	/* reloc ops */
+	case 64:	/* mov/movb/movbu R,addr */
+		o1 = omvl(p, &p->to, REGTMP);
+		if(!o1)
+			break;
+		o2 = osr(p->as, p->from.reg, 0, REGTMP, p->scond);
+		break;
+
+	case 65:	/* mov/movbu addr,R */
+	case 66:	/* movh/movhu/movb addr,R */
+		o1 = omvl(p, &p->from, REGTMP);
+		if(!o1)
+			break;
+		o2 = olr(0, REGTMP, p->to.reg, p->scond);
+		if(p->as == AMOVBU || p->as == AMOVB)
+			o2 |= 1<<22;
+		if(o->type == 65)
+			break;
+
+		o3 = oprrr(ASLL, p->scond);
+
+		if(p->as == AMOVBU || p->as == AMOVHU)
+			o4 = oprrr(ASRL, p->scond);
+		else
+			o4 = oprrr(ASRA, p->scond);
+
+		r = p->to.reg;
+		o3 |= (r)|(r<<12);
+		o4 |= (r)|(r<<12);
+		if(p->as == AMOVB || p->as == AMOVBU) {
+			o3 |= (24<<7);
+			o4 |= (24<<7);
+		} else {
+			o3 |= (16<<7);
+			o4 |= (16<<7);
+		}
+		break;
+
+	case 67:	/* movh/movhu R,addr -> sb, sb */
+		o1 = omvl(p, &p->to, REGTMP);
+		if(!o1)
+			break;
+		o2 = osr(p->as, p->from.reg, 0, REGTMP, p->scond);
+
+		o3 = oprrr(ASRL, p->scond);
+		o3 |= (8<<7)|(p->from.reg)|(p->from.reg<<12);
+		o3 |= (1<<6);	/* ROR 8 */
+
+		o4 = oprrr(AADD, p->scond);
+		o4 |= (REGTMP << 12) | (REGTMP << 16);
+		o4 |= immrot(1);
+
+		o5 = osr(p->as, p->from.reg, 0, REGTMP, p->scond);
+
+		o6 = oprrr(ASRL, p->scond);
+		o6 |= (24<<7)|(p->from.reg)|(p->from.reg<<12);
+		o6 |= (1<<6);	/* ROL 8 */
+		break;
+
+	case 68:	/* floating point store -> ADDR */
+		o1 = omvl(p, &p->to, REGTMP);
+		if(!o1)
+			break;
+		o2 = ofsr(p->as, p->from.reg, 0, REGTMP, p->scond, p);
+		break;
+
+	case 69:	/* floating point load <- ADDR */
+		o1 = omvl(p, &p->from, REGTMP);
+		if(!o1)
+			break;
+		o2 = ofsr(p->as, p->to.reg, 0, REGTMP, p->scond, p) | (1<<20);
+		break;
+
+	/* ArmV4 ops: */
+	case 70:	/* movh/movhu R,O(R) -> strh */
+		aclass(&p->to);
+		r = p->to.reg;
+		if(r == NREG)
+			r = o->param;
+		o1 = oshr(p->from.reg, instoffset, r, p->scond);
+		break;	
+	case 71:	/* movb/movh/movhu O(R),R -> ldrsb/ldrsh/ldrh */
+		aclass(&p->from);
+		r = p->from.reg;
+		if(r == NREG)
+			r = o->param;
+		o1 = olhr(instoffset, r, p->to.reg, p->scond);
+		if(p->as == AMOVB)
+			o1 ^= (1<<5)|(1<<6);
+		else if(p->as == AMOVH)
+			o1 ^= (1<<6);
+		break;
+	case 72:	/* movh/movhu R,L(R) -> strh */
+		o1 = omvl(p, &p->to, REGTMP);
+		if(!o1)
+			break;
+		r = p->to.reg;
+		if(r == NREG)
+			r = o->param;
+		o2 = oshrr(p->from.reg, REGTMP,r, p->scond);
+		break;	
+	case 73:	/* movb/movh/movhu L(R),R -> ldrsb/ldrsh/ldrh */
+		o1 = omvl(p, &p->from, REGTMP);
+		if(!o1)
+			break;
+		r = p->from.reg;
+		if(r == NREG)
+			r = o->param;
+		o2 = olhrr(REGTMP, r, p->to.reg, p->scond);
+		if(p->as == AMOVB)
+			o2 ^= (1<<5)|(1<<6);
+		else if(p->as == AMOVH)
+			o2 ^= (1<<6);
+		break;
+	case 74:	/* bx $I */
+#ifdef CALLEEBX
+		diag("bx $i case (arm)");
+#endif
+		if(!seenthumb)
+			diag("ABX $I and seenthumb==0");
+		v = p->cond->pc;
+		if(p->to.sym->thumb)
+			v |= 1;	// T bit
+		o1 = olr(8, REGPC, REGTMP, p->scond&C_SCOND);	// mov 8(PC), Rtmp
+		o2 = 	oprrr(AADD, p->scond) | immrot(8) | (REGPC<<16) | (REGLINK<<12);	// add 8,PC, LR
+		o3 = ((p->scond&C_SCOND)<<28) | (0x12fff<<8) | (1<<4) | REGTMP;		// bx Rtmp
+		o4 = opbra(AB, 14);	// B over o6
+		o5 = v;
+		break;
+	case 75:	/* bx O(R) */
+		aclass(&p->to);
+		if(instoffset != 0)
+			diag("non-zero offset in ABX");
+/*
+		o1 = 	oprrr(AADD, p->scond) | immrot(0) | (REGPC<<16) | (REGLINK<<12);	// mov PC, LR
+		o2 = ((p->scond&C_SCOND)<<28) | (0x12fff<<8) | (1<<4) | p->to.reg;		// BX R
+*/
+		// p->to.reg may be REGLINK
+		o1 = oprrr(AADD, p->scond);
+		o1 |= immrot(instoffset);
+		o1 |= p->to.reg << 16;
+		o1 |= REGTMP << 12;
+		o2 = 	oprrr(AADD, p->scond) | immrot(0) | (REGPC<<16) | (REGLINK<<12);	// mov PC, LR
+		o3 = ((p->scond&C_SCOND)<<28) | (0x12fff<<8) | (1<<4) | REGTMP;		// BX Rtmp
+		break;
+	case 76:	/* bx O(R) when returning from fn*/
+		if(!seenthumb)
+			diag("ABXRET and seenthumb==0");
+		aclass(&p->to);
+// print("ARM BXRET %d(R%d)\n", instoffset, p->to.reg);
+		if(instoffset != 0)
+			diag("non-zero offset in ABXRET");
+		// o1 = olr(instoffset, p->to.reg, REGTMP, p->scond);	// mov O(R), Rtmp
+		o1 = ((p->scond&C_SCOND)<<28) | (0x12fff<<8) | (1<<4) | p->to.reg;		// BX R
+		break;
+	}
+
+	v = p->pc;
+	switch(o->size) {
+	default:
+		if(debug['a'])
+			Bprint(&bso, " %.8lux:\t\t%P\n", v, p);
+		break;
+	case 4:
+		if(debug['a'])
+			Bprint(&bso, " %.8lux: %.8lux\t%P\n", v, o1, p);
+		lputl(o1);
+		break;
+	case 8:
+		if(debug['a'])
+			Bprint(&bso, " %.8lux: %.8lux %.8lux%P\n", v, o1, o2, p);
+		lputl(o1);
+		lputl(o2);
+		break;
+	case 12:
+		if(debug['a'])
+			Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux%P\n", v, o1, o2, o3, p);
+		lputl(o1);
+		lputl(o2);
+		lputl(o3);
+		break;
+	case 16:
+		if(debug['a'])
+			Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux%P\n",
+				v, o1, o2, o3, o4, p);
+		lputl(o1);
+		lputl(o2);
+		lputl(o3);
+		lputl(o4);
+		break;
+	case 20:
+		if(debug['a'])
+			Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux %.8lux%P\n",
+				v, o1, o2, o3, o4, o5, p);
+		lputl(o1);
+		lputl(o2);
+		lputl(o3);
+		lputl(o4);
+		lputl(o5);
+		break;
+	case 24:
+		if(debug['a'])
+			Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux %.8lux %.8lux%P\n",
+				v, o1, o2, o3, o4, o5, o6, p);
+		lputl(o1);
+		lputl(o2);
+		lputl(o3);
+		lputl(o4);
+		lputl(o5);
+		lputl(o6);
+		break;
+	}
+}
+
+long
+oprrr(int a, int sc)
+{
+	long o;
+
+	o = (sc & C_SCOND) << 28;
+	if(sc & C_SBIT)
+		o |= 1 << 20;
+	if(sc & (C_PBIT|C_WBIT))
+		diag(".P/.W on dp instruction");
+	switch(a) {
+	case AMULU:
+	case AMUL:	return o | (0x0<<21) | (0x9<<4);
+	case AMULA:	return o | (0x1<<21) | (0x9<<4);
+	case AMULLU:	return o | (0x4<<21) | (0x9<<4);
+	case AMULL:	return o | (0x6<<21) | (0x9<<4);
+	case AMULALU:	return o | (0x5<<21) | (0x9<<4);
+	case AMULAL:	return o | (0x7<<21) | (0x9<<4);
+	case AAND:	return o | (0x0<<21);
+	case AEOR:	return o | (0x1<<21);
+	case ASUB:	return o | (0x2<<21);
+	case ARSB:	return o | (0x3<<21);
+	case AADD:	return o | (0x4<<21);
+	case AADC:	return o | (0x5<<21);
+	case ASBC:	return o | (0x6<<21);
+	case ARSC:	return o | (0x7<<21);
+	case ATST:	return o | (0x8<<21) | (1<<20);
+	case ATEQ:	return o | (0x9<<21) | (1<<20);
+	case ACMP:	return o | (0xa<<21) | (1<<20);
+	case ACMN:	return o | (0xb<<21) | (1<<20);
+	case AORR:	return o | (0xc<<21);
+	case AMOVW:	return o | (0xd<<21);
+	case ABIC:	return o | (0xe<<21);
+	case AMVN:	return o | (0xf<<21);
+	case ASLL:	return o | (0xd<<21) | (0<<5);
+	case ASRL:	return o | (0xd<<21) | (1<<5);
+	case ASRA:	return o | (0xd<<21) | (2<<5);
+	case ASWI:	return o | (0xf<<24);
+
+	case AADDD:	return o | (0xe<<24) | (0x0<<20) | (1<<8) | (1<<7);
+	case AADDF:	return o | (0xe<<24) | (0x0<<20) | (1<<8);
+	case AMULD:	return o | (0xe<<24) | (0x1<<20) | (1<<8) | (1<<7);
+	case AMULF:	return o | (0xe<<24) | (0x1<<20) | (1<<8);
+	case ASUBD:	return o | (0xe<<24) | (0x2<<20) | (1<<8) | (1<<7);
+	case ASUBF:	return o | (0xe<<24) | (0x2<<20) | (1<<8);
+	case ADIVD:	return o | (0xe<<24) | (0x4<<20) | (1<<8) | (1<<7);
+	case ADIVF:	return o | (0xe<<24) | (0x4<<20) | (1<<8);
+	case ACMPD:
+	case ACMPF:	return o | (0xe<<24) | (0x9<<20) | (0xF<<12) | (1<<8) | (1<<4);	/* arguably, ACMPF should expand to RNDF, CMPD */
+
+	case AMOVF:
+	case AMOVDF:	return o | (0xe<<24) | (0x0<<20) | (1<<15) | (1<<8);
+	case AMOVD:
+	case AMOVFD:	return o | (0xe<<24) | (0x0<<20) | (1<<15) | (1<<8) | (1<<7);
+
+	case AMOVWF:	return o | (0xe<<24) | (0<<20) | (1<<8) | (1<<4);
+	case AMOVWD:	return o | (0xe<<24) | (0<<20) | (1<<8) | (1<<4) | (1<<7);
+	case AMOVFW:	return o | (0xe<<24) | (1<<20) | (1<<8) | (1<<4);
+	case AMOVDW:	return o | (0xe<<24) | (1<<20) | (1<<8) | (1<<4) | (1<<7);
+	}
+	diag("bad rrr %d", a);
+	prasm(curp);
+	return 0;
+}
+
+long
+opbra(int a, int sc)
+{
+
+	if(sc & (C_SBIT|C_PBIT|C_WBIT))
+		diag(".S/.P/.W on bra instruction");
+	sc &= C_SCOND;
+	if(a == ABL)
+		return (sc<<28)|(0x5<<25)|(0x1<<24);
+	if(sc != 0xe)
+		diag(".COND on bcond instruction");
+	switch(a) {
+	case ABEQ:	return (0x0<<28)|(0x5<<25);
+	case ABNE:	return (0x1<<28)|(0x5<<25);
+	case ABCS:	return (0x2<<28)|(0x5<<25);
+	case ABHS:	return (0x2<<28)|(0x5<<25);
+	case ABCC:	return (0x3<<28)|(0x5<<25);
+	case ABLO:	return (0x3<<28)|(0x5<<25);
+	case ABMI:	return (0x4<<28)|(0x5<<25);
+	case ABPL:	return (0x5<<28)|(0x5<<25);
+	case ABVS:	return (0x6<<28)|(0x5<<25);
+	case ABVC:	return (0x7<<28)|(0x5<<25);
+	case ABHI:	return (0x8<<28)|(0x5<<25);
+	case ABLS:	return (0x9<<28)|(0x5<<25);
+	case ABGE:	return (0xa<<28)|(0x5<<25);
+	case ABLT:	return (0xb<<28)|(0x5<<25);
+	case ABGT:	return (0xc<<28)|(0x5<<25);
+	case ABLE:	return (0xd<<28)|(0x5<<25);
+	case AB:	return (0xe<<28)|(0x5<<25);
+	}
+	diag("bad bra %A", a);
+	prasm(curp);
+	return 0;
+}
+
+long
+olr(long v, int b, int r, int sc)
+{
+	long o;
+
+	if(sc & C_SBIT)
+		diag(".S on LDR/STR instruction");
+	o = (sc & C_SCOND) << 28;
+	if(!(sc & C_PBIT))
+		o |= 1 << 24;
+	if(!(sc & C_UBIT))
+		o |= 1 << 23;
+	if(sc & C_WBIT)
+		o |= 1 << 21;
+	o |= (0x1<<26) | (1<<20);
+	if(v < 0) {
+		v = -v;
+		o ^= 1 << 23;
+	}
+	if(v >= (1<<12))
+		diag("literal span too large: %d (R%d)\n%P", v, b, PP);
+	o |= v;
+	o |= b << 16;
+	o |= r << 12;
+	return o;
+}
+
+long
+olhr(long v, int b, int r, int sc)
+{
+	long o;
+
+	if(sc & C_SBIT)
+		diag(".S on LDRH/STRH instruction");
+	o = (sc & C_SCOND) << 28;
+	if(!(sc & C_PBIT))
+		o |= 1 << 24;
+	if(sc & C_WBIT)
+		o |= 1 << 21;
+	o |= (1<<23) | (1<<20)|(0xb<<4);
+	if(v < 0) {
+		v = -v;
+		o ^= 1 << 23;
+	}
+	if(v >= (1<<8))
+		diag("literal span too large: %d (R%d)\n%P", v, b, PP);
+	o |= (v&0xf)|((v>>4)<<8)|(1<<22);
+	o |= b << 16;
+	o |= r << 12;
+	return o;
+}
+
+long
+osr(int a, int r, long v, int b, int sc)
+{
+	long o;
+
+	o = olr(v, b, r, sc) ^ (1<<20);
+	if(a != AMOVW)
+		o |= 1<<22;
+	return o;
+}
+
+long
+oshr(int r, long v, int b, int sc)
+{
+	long o;
+
+	o = olhr(v, b, r, sc) ^ (1<<20);
+	return o;
+}
+	
+
+long
+osrr(int r, int i, int b, int sc)
+{
+
+	return olr(i, b, r, sc) ^ ((1<<25) | (1<<20));
+}
+
+long
+oshrr(int r, int i, int b, int sc)
+{
+	return olhr(i, b, r, sc) ^ ((1<<22) | (1<<20));
+}
+
+long
+olrr(int i, int b, int r, int sc)
+{
+
+	return olr(i, b, r, sc) ^ (1<<25);
+}
+
+long
+olhrr(int i, int b, int r, int sc)
+{
+	return olhr(i, b, r, sc) ^ (1<<22);
+}
+
+long
+ofsr(int a, int r, long v, int b, int sc, Prog *p)
+{
+	long o;
+
+	if(sc & C_SBIT)
+		diag(".S on FLDR/FSTR instruction");
+	o = (sc & C_SCOND) << 28;
+	if(!(sc & C_PBIT))
+		o |= 1 << 24;
+	if(sc & C_WBIT)
+		o |= 1 << 21;
+	o |= (6<<25) | (1<<24) | (1<<23);
+	if(v < 0) {
+		v = -v;
+		o ^= 1 << 23;
+	}
+	if(v & 3)
+		diag("odd offset for floating point op: %d\n%P", v, p);
+	else if(v >= (1<<10))
+		diag("literal span too large: %d\n%P", v, p);
+	o |= (v>>2) & 0xFF;
+	o |= b << 16;
+	o |= r << 12;
+	o |= 1 << 8;
+
+	switch(a) {
+	default:
+		diag("bad fst %A", a);
+	case AMOVD:
+		o |= 1<<15;
+	case AMOVF:
+		break;
+	}
+	return o;
+}
+
+long
+omvl(Prog *p, Adr *a, int dr)
+{	
+	long v, o1;
+	if(!p->cond) {
+		aclass(a);
+		v = immrot(~instoffset);
+		if(v == 0) {
+			diag("missing literal");
+			prasm(p);
+			return 0;
+		}
+		o1 = oprrr(AMVN, p->scond&C_SCOND);
+		o1 |= v;
+		o1 |= dr << 12;
+	} else {
+		v = p->cond->pc - p->pc - 8;
+		o1 = olr(v, REGPC, dr, p->scond&C_SCOND);
+	}
+	return o1;
+}
+
+static Ieee chipfloats[] = {
+	{0x00000000, 0x00000000}, /* 0 */
+	{0x00000000, 0x3ff00000}, /* 1 */
+	{0x00000000, 0x40000000}, /* 2 */
+	{0x00000000, 0x40080000}, /* 3 */
+	{0x00000000, 0x40100000}, /* 4 */
+	{0x00000000, 0x40140000}, /* 5 */
+	{0x00000000, 0x3fe00000}, /* .5 */
+	{0x00000000, 0x40240000}, /* 10 */
+};
+
+int
+chipfloat(Ieee *e)
+{
+	Ieee *p;
+	int n;
+
+	for(n = sizeof(chipfloats)/sizeof(chipfloats[0]); --n >= 0;){
+		p = &chipfloats[n];
+		if(p->l == e->l && p->h == e->h)
+			return n;
+	}
+	return -1;
+}
diff --git a/src/cmd/5l/l.h b/src/cmd/5l/l.h
new file mode 100644
index 0000000000..9e62a176ed
--- /dev/null
+++ b/src/cmd/5l/l.h
@@ -0,0 +1,474 @@
+// Inferno utils/5l/l.h
+// http://code.google.com/p/inferno-os/source/browse/utils/5l/l.h
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#include	<lib9.h>
+#include	<bio.h>
+#include	"../5c/5.out.h"
+
+#ifndef	EXTERN
+#define	EXTERN	extern
+#endif
+
+/* do not undefine this - code will be removed eventually */
+#define	CALLEEBX
+
+typedef	struct	Adr	Adr;
+typedef	struct	Sym	Sym;
+typedef	struct	Autom	Auto;
+typedef	struct	Prog	Prog;
+typedef	struct	Optab	Optab;
+typedef	struct	Oprang	Oprang;
+typedef	uchar	Opcross[32][2][32];
+typedef	struct	Count	Count;
+typedef	struct	Use	Use;
+
+#define	P		((Prog*)0)
+#define	S		((Sym*)0)
+#define	U		((Use*)0)
+#define	TNAME		(curtext&&curtext->from.sym?curtext->from.sym->name:noname)
+
+struct	Adr
+{
+	union
+	{
+		long	u0offset;
+		char*	u0sval;
+		Ieee*	u0ieee;
+	} u0;
+	union
+	{
+		Auto*	u1autom;
+		Sym*	u1sym;
+	} u1;
+	char	type;
+	char	reg;
+	char	name;
+	char	class;
+};
+
+#define	offset	u0.u0offset
+#define	sval	u0.u0sval
+#define	ieee	u0.u0ieee
+
+#define	autom	u1.u1autom
+#define	sym	u1.u1sym
+
+struct	Prog
+{
+	Adr	from;
+	Adr	to;
+	union
+	{
+		long	u0regused;
+		Prog*	u0forwd;
+	} u0;
+	Prog*	cond;
+	Prog*	link;
+	long	pc;
+	long	line;
+	uchar	mark;
+	uchar	optab;
+	uchar	as;
+	uchar	scond;
+	uchar	reg;
+	uchar	align;
+};
+#define	regused	u0.u0regused
+#define	forwd	u0.u0forwd
+
+struct	Sym
+{
+	char	*name;
+	short	type;
+	short	version;
+	short	become;
+	short	frame;
+	uchar	subtype;
+	ushort	file;
+	long	value;
+	long	sig;
+	uchar	used;
+	uchar	thumb;	// thumb code
+	uchar	foreign;	// called by arm if thumb, by thumb if arm
+	uchar	fnptr;	// used as fn ptr
+	Use*		use;
+	Sym*	link;
+};
+
+#define SIGNINTERN	(1729*325*1729)
+
+struct	Autom
+{
+	Sym*	asym;
+	Auto*	link;
+	long	aoffset;
+	short	type;
+};
+struct	Optab
+{
+	char	as;
+	char	a1;
+	char	a2;
+	char	a3;
+	char	type;
+	char	size;
+	char	param;
+	char	flag;
+};
+struct	Oprang
+{
+	Optab*	start;
+	Optab*	stop;
+};
+struct	Count
+{
+	long	count;
+	long	outof;
+};
+struct	Use
+{
+	Prog*	p;	/* use */
+	Prog*	ct;	/* curtext */
+	Use*		link;
+};
+
+enum
+{
+	STEXT		= 1,
+	SDATA,
+	SBSS,
+	SDATA1,
+	SXREF,
+	SLEAF,
+	SFILE,
+	SCONST,
+	SSTRING,
+	SUNDEF,
+	SREMOVED,
+
+	SIMPORT,
+	SEXPORT,
+
+	LFROM		= 1<<0,
+	LTO		= 1<<1,
+	LPOOL		= 1<<2,
+	V4		= 1<<3,	/* arm v4 arch */
+
+	C_NONE		= 0,
+	C_REG,
+	C_REGREG,
+	C_SHIFT,
+	C_FREG,
+	C_PSR,
+	C_FCR,
+
+	C_RCON,		/* 0xff rotated */
+	C_NCON,		/* ~RCON */
+	C_SCON,		/* 0xffff */
+	C_BCON,		/* thumb */
+	C_LCON,
+	C_FCON,
+	C_GCON,		/* thumb */
+
+	C_RACON,
+	C_SACON,	/* thumb */
+	C_LACON,
+	C_GACON,	/* thumb */
+
+	C_RECON,
+	C_LECON,
+
+	C_SBRA,
+	C_LBRA,
+	C_GBRA,		/* thumb */
+
+	C_HAUTO,	/* halfword insn offset (-0xff to 0xff) */
+	C_FAUTO,	/* float insn offset (0 to 0x3fc, word aligned) */
+	C_HFAUTO,	/* both H and F */
+	C_SAUTO,	/* -0xfff to 0xfff */
+	C_LAUTO,
+
+	C_HEXT,
+	C_FEXT,
+	C_HFEXT,
+	C_SEXT,
+	C_LEXT,
+
+	C_HOREG,
+	C_FOREG,
+	C_HFOREG,
+	C_SOREG,
+	C_ROREG,
+	C_SROREG,	/* both S and R */
+	C_LOREG,
+	C_GOREG,		/* thumb */
+
+	C_PC,
+	C_SP,
+	C_HREG,
+	C_OFFPC,		/* thumb */
+
+	C_ADDR,		/* relocatable address */
+
+	C_GOK,
+
+/* mark flags */
+	FOLL		= 1<<0,
+	LABEL		= 1<<1,
+	LEAF		= 1<<2,
+
+	BIG		= (1<<12)-4,
+	STRINGSZ	= 200,
+	NHASH		= 10007,
+	NHUNK		= 100000,
+	MINSIZ		= 64,
+	NENT		= 100,
+	MAXIO		= 8192,
+	MAXHIST		= 20,	/* limit of path elements for history symbols */
+
+	Roffset	= 22,		/* no. bits for offset in relocation address */
+	Rindex	= 10,		/* no. bits for index in relocation address */
+};
+
+EXTERN union
+{
+	struct
+	{
+		uchar	obuf[MAXIO];			/* output buffer */
+		uchar	ibuf[MAXIO];			/* input buffer */
+	} u;
+	char	dbuf[1];
+} buf;
+
+#define	cbuf	u.obuf
+#define	xbuf	u.ibuf
+
+#define	setarch(p)		if((p)->as==ATEXT) thumb=(p)->reg&ALLTHUMBS
+#define	setthumb(p)	if((p)->as==ATEXT) seenthumb|=(p)->reg&ALLTHUMBS
+
+#ifndef COFFCVT
+
+EXTERN	long	HEADR;			/* length of header */
+EXTERN	int	HEADTYPE;		/* type of header */
+EXTERN	long	INITDAT;		/* data location */
+EXTERN	long	INITRND;		/* data round above text location */
+EXTERN	long	INITTEXT;		/* text location */
+EXTERN	char*	INITENTRY;		/* entry point */
+EXTERN	long	autosize;
+EXTERN	Biobuf	bso;
+EXTERN	long	bsssize;
+EXTERN	int	cbc;
+EXTERN	uchar*	cbp;
+EXTERN	int	cout;
+EXTERN	Auto*	curauto;
+EXTERN	Auto*	curhist;
+EXTERN	Prog*	curp;
+EXTERN	Prog*	curtext;
+EXTERN	Prog*	datap;
+EXTERN	long	datsize;
+EXTERN	char	debug[128];
+EXTERN	Prog*	etextp;
+EXTERN	Prog*	firstp;
+EXTERN	char	fnuxi4[4];
+EXTERN	char	fnuxi8[8];
+EXTERN	char*	noname;
+EXTERN	Sym*	hash[NHASH];
+EXTERN	Sym*	histfrog[MAXHIST];
+EXTERN	int	histfrogp;
+EXTERN	int	histgen;
+EXTERN	char*	library[50];
+EXTERN	char*	libraryobj[50];
+EXTERN	int	libraryp;
+EXTERN	int	xrefresolv;
+EXTERN	char*	hunk;
+EXTERN	char	inuxi1[1];
+EXTERN	char	inuxi2[2];
+EXTERN	char	inuxi4[4];
+EXTERN	Prog*	lastp;
+EXTERN	long	lcsize;
+EXTERN	char	literal[32];
+EXTERN	int	nerrors;
+EXTERN	long	nhunk;
+EXTERN	long	instoffset;
+EXTERN	Opcross	opcross[8];
+EXTERN	Oprang	oprange[ALAST];
+EXTERN	Oprang	thumboprange[ALAST];
+EXTERN	char*	outfile;
+EXTERN	long	pc;
+EXTERN	uchar	repop[ALAST];
+EXTERN	long	symsize;
+EXTERN	Prog*	textp;
+EXTERN	long	textsize;
+EXTERN	long	thunk;
+EXTERN	int	version;
+EXTERN	char	xcmp[C_GOK+1][C_GOK+1];
+EXTERN	Prog	zprg;
+EXTERN	int	dtype;
+EXTERN	int	armv4;
+EXTERN	int	thumb;
+EXTERN	int	seenthumb;
+EXTERN	int	armsize;
+
+EXTERN	int	doexp, dlm;
+EXTERN	int	imports, nimports;
+EXTERN	int	exports, nexports;
+EXTERN	char*	EXPTAB;
+EXTERN	Prog	undefp;
+
+#define	UP	(&undefp)
+
+extern	char*	anames[];
+extern	Optab	optab[];
+extern	Optab	thumboptab[];
+
+void	addpool(Prog*, Adr*);
+EXTERN	Prog*	blitrl;
+EXTERN	Prog*	elitrl;
+
+void	initdiv(void);
+EXTERN	Prog*	prog_div;
+EXTERN	Prog*	prog_divu;
+EXTERN	Prog*	prog_mod;
+EXTERN	Prog*	prog_modu;
+
+#pragma	varargck	type	"A"	int
+#pragma	varargck	type	"C"	int
+#pragma	varargck	type	"D"	Adr*
+#pragma	varargck	type	"N"	Adr*
+#pragma	varargck	type	"P"	Prog*
+#pragma	varargck	type	"S"	char*
+
+int	Aconv(Fmt*);
+int	Cconv(Fmt*);
+int	Dconv(Fmt*);
+int	Nconv(Fmt*);
+int	Pconv(Fmt*);
+int	Sconv(Fmt*);
+int	aclass(Adr*);
+int	thumbaclass(Adr*, Prog*);
+void	addhist(long, int);
+void	append(Prog*, Prog*);
+void	asmb(void);
+void	asmdyn(void);
+void	asmlc(void);
+void	asmthumbmap(void);
+void	asmout(Prog*, Optab*);
+void	thumbasmout(Prog*, Optab*);
+void	asmsym(void);
+long	atolwhex(char*);
+Prog*	brloop(Prog*);
+void	buildop(void);
+void	thumbbuildop(void);
+void	buildrep(int, int);
+void	cflush(void);
+void	ckoff(Sym*, long);
+int	chipfloat(Ieee*);
+int	cmp(int, int);
+int	compound(Prog*);
+double	cputime(void);
+void	datblk(long, long, int);
+void	diag(char*, ...);
+void	divsig(void);
+void	dodata(void);
+void	doprof1(void);
+void	doprof2(void);
+void	dynreloc(Sym*, long, int);
+long	entryvalue(void);
+void	errorexit(void);
+void	exchange(Prog*);
+void	export(void);
+int	find1(long, int);
+void	follow(void);
+void	gethunk(void);
+void	histtoauto(void);
+void	hputl(int);
+double	ieeedtod(Ieee*);
+long	ieeedtof(Ieee*);
+void	import(void);
+int	isnop(Prog*);
+void	ldobj(int, long, char*);
+void	loadlib(void);
+void	listinit(void);
+Sym*	lookup(char*, int);
+void	cput(int);
+void	hput(long);
+void	lput(long);
+void	lputl(long);
+void	mkfwd(void);
+void*	mysbrk(ulong);
+void	names(void);
+void	nocache(Prog*);
+void	nuxiinit(void);
+void	objfile(char*);
+int	ocmp(const void*, const void*);
+long	opirr(int);
+Optab*	oplook(Prog*);
+long	oprrr(int, int);
+long	olr(long, int, int, int);
+long	olhr(long, int, int, int);
+long	olrr(int, int, int, int);
+long	olhrr(int, int, int, int);
+long	osr(int, int, long, int, int);
+long	oshr(int, long, int, int);
+long	ofsr(int, int, long, int, int, Prog*);
+long	osrr(int, int, int, int);
+long	oshrr(int, int, int, int);
+long	omvl(Prog*, Adr*, int);
+void	patch(void);
+void	prasm(Prog*);
+void	prepend(Prog*, Prog*);
+Prog*	prg(void);
+int	pseudo(Prog*);
+void	putsymb(char*, int, long, int);
+void	readundefs(char*, int);
+long	regoff(Adr*);
+int	relinv(int);
+long	rnd(long, long);
+void	span(void);
+void	strnput(char*, int);
+void	undef(void);
+void	undefsym(Sym*);
+void	wput(long);
+void	xdefine(char*, int, long);
+void	xfol(Prog*);
+void	zerosig(char*);
+void	noops(void);
+long	immrot(ulong);
+long	immaddr(long);
+long	opbra(int, int);
+int	brextra(Prog*);
+int	isbranch(Prog*);
+int	fnpinc(Sym *);
+int	fninc(Sym *);
+void	thumbcount(void);
+void reachable(void);
+void fnptrs(void);
+
+#endif
diff --git a/src/cmd/5l/list.c b/src/cmd/5l/list.c
new file mode 100644
index 0000000000..29286ad529
--- /dev/null
+++ b/src/cmd/5l/list.c
@@ -0,0 +1,390 @@
+// Inferno utils/5l/list.h
+// http://code.google.com/p/inferno-os/source/browse/utils/5l/list.c
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#include "l.h"
+
+void
+listinit(void)
+{
+
+	fmtinstall('A', Aconv);
+	fmtinstall('C', Cconv);
+	fmtinstall('D', Dconv);
+	fmtinstall('P', Pconv);
+	fmtinstall('S', Sconv);
+	fmtinstall('N', Nconv);
+}
+
+void
+prasm(Prog *p)
+{
+	print("%P\n", p);
+}
+
+int
+Pconv(Fmt *fp)
+{
+	char str[STRINGSZ], *s;
+	Prog *p;
+	int a;
+
+	p = va_arg(fp->args, Prog*);
+	curp = p;
+	a = p->as;
+	switch(a) {
+	default:
+		s = str;
+		s += sprint(s, "(%ld)", p->line);
+		if(p->reg == NREG)
+			sprint(s, "	%A%C	%D,%D",
+				a, p->scond, &p->from, &p->to);
+		else
+		if(p->from.type != D_FREG)
+			sprint(s, "	%A%C	%D,R%d,%D",
+				a, p->scond, &p->from, p->reg, &p->to);
+		else
+			sprint(s, "	%A%C	%D,F%d,%D",
+				a, p->scond, &p->from, p->reg, &p->to);
+		break;
+
+	case ASWPW:
+	case ASWPBU:
+		sprint(str, "(%ld)	%A%C	R%d,%D,%D",
+			p->line, a, p->scond, p->reg, &p->from, &p->to);
+		break;
+
+	case ADATA:
+	case AINIT:
+	case ADYNT:
+		sprint(str, "(%ld)	%A%C	%D/%d,%D",
+			p->line, a, p->scond, &p->from, p->reg, &p->to);
+		break;
+
+	case AWORD:
+		sprint(str, "WORD %ld", p->to.offset);
+		break;
+
+	case ADWORD:
+		sprint(str, "DWORD %ld %ld", p->from.offset, p->to.offset);
+		break;
+	}
+	return fmtstrcpy(fp, str);
+}
+
+int
+Aconv(Fmt *fp)
+{
+	char *s;
+	int a;
+
+	a = va_arg(fp->args, int);
+	s = "???";
+	if(a >= AXXX && a < ALAST)
+		s = anames[a];
+	return fmtstrcpy(fp, s);
+}
+
+char*	strcond[16] =
+{
+	".EQ",
+	".NE",
+	".HS",
+	".LO",
+	".MI",
+	".PL",
+	".VS",
+	".VC",
+	".HI",
+	".LS",
+	".GE",
+	".LT",
+	".GT",
+	".LE",
+	"",
+	".NV"
+};
+
+int
+Cconv(Fmt *fp)
+{
+	char s[20];
+	int c;
+
+	c = va_arg(fp->args, int);
+	strcpy(s, strcond[c & C_SCOND]);
+	if(c & C_SBIT)
+		strcat(s, ".S");
+	if(c & C_PBIT)
+		strcat(s, ".P");
+	if(c & C_WBIT)
+		strcat(s, ".W");
+	if(c & C_UBIT)		/* ambiguous with FBIT */
+		strcat(s, ".U");
+	return fmtstrcpy(fp, s);
+}
+
+int
+Dconv(Fmt *fp)
+{
+	char str[STRINGSZ];
+	char *op;
+	Adr *a;
+	long v;
+
+	a = va_arg(fp->args, Adr*);
+	switch(a->type) {
+
+	default:
+		sprint(str, "GOK-type(%d)", a->type);
+		break;
+
+	case D_NONE:
+		str[0] = 0;
+		if(a->name != D_NONE || a->reg != NREG || a->sym != S)
+			sprint(str, "%N(R%d)(NONE)", a, a->reg);
+		break;
+
+	case D_CONST:
+		if(a->reg == NREG)
+			sprint(str, "$%N", a);
+		else
+			sprint(str, "$%N(R%d)", a, a->reg);
+		break;
+
+	case D_SHIFT:
+		v = a->offset;
+		op = "<<>>->@>" + (((v>>5) & 3) << 1);
+		if(v & (1<<4))
+			sprint(str, "R%ld%c%cR%ld", v&15, op[0], op[1], (v>>8)&15);
+		else
+			sprint(str, "R%ld%c%c%ld", v&15, op[0], op[1], (v>>7)&31);
+		if(a->reg != NREG)
+			sprint(str+strlen(str), "(R%d)", a->reg);
+		break;
+
+	case D_OCONST:
+		sprint(str, "$*$%N", a);
+		if(a->reg != NREG)
+			sprint(str, "%N(R%d)(CONST)", a, a->reg);
+		break;
+
+	case D_OREG:
+		if(a->reg != NREG)
+			sprint(str, "%N(R%d)", a, a->reg);
+		else
+			sprint(str, "%N", a);
+		break;
+
+	case D_REG:
+		sprint(str, "R%d", a->reg);
+		if(a->name != D_NONE || a->sym != S)
+			sprint(str, "%N(R%d)(REG)", a, a->reg);
+		break;
+
+	case D_REGREG:
+		sprint(str, "(R%d,R%d)", a->reg, (int)a->offset);
+		if(a->name != D_NONE || a->sym != S)
+			sprint(str, "%N(R%d)(REG)", a, a->reg);
+		break;
+
+	case D_FREG:
+		sprint(str, "F%d", a->reg);
+		if(a->name != D_NONE || a->sym != S)
+			sprint(str, "%N(R%d)(REG)", a, a->reg);
+		break;
+
+	case D_PSR:
+		switch(a->reg) {
+		case 0:
+			sprint(str, "CPSR");
+			break;
+		case 1:
+			sprint(str, "SPSR");
+			break;
+		default:
+			sprint(str, "PSR%d", a->reg);
+			break;
+		}
+		if(a->name != D_NONE || a->sym != S)
+			sprint(str, "%N(PSR%d)(REG)", a, a->reg);
+		break;
+
+	case D_FPCR:
+		switch(a->reg){
+		case 0:
+			sprint(str, "FPSR");
+			break;
+		case 1:
+			sprint(str, "FPCR");
+			break;
+		default:
+			sprint(str, "FCR%d", a->reg);
+			break;
+		}
+		if(a->name != D_NONE || a->sym != S)
+			sprint(str, "%N(FCR%d)(REG)", a, a->reg);
+
+		break;
+
+	case D_BRANCH:	/* botch */
+		if(curp->cond != P) {
+			v = curp->cond->pc;
+			if(a->sym != S)
+				sprint(str, "%s+%.5lux(BRANCH)", a->sym->name, v);
+			else
+				sprint(str, "%.5lux(BRANCH)", v);
+		} else
+			if(a->sym != S)
+				sprint(str, "%s+%ld(APC)", a->sym->name, a->offset);
+			else
+				sprint(str, "%ld(APC)", a->offset);
+		break;
+
+	case D_FCONST:
+		sprint(str, "$%e", ieeedtod(a->ieee));
+		break;
+
+	case D_SCONST:
+		sprint(str, "$\"%S\"", a->sval);
+		break;
+	}
+	return fmtstrcpy(fp, str);
+}
+
+int
+Nconv(Fmt *fp)
+{
+	char str[STRINGSZ];
+	Adr *a;
+	Sym *s;
+
+	a = va_arg(fp->args, Adr*);
+	s = a->sym;
+	switch(a->name) {
+	default:
+		sprint(str, "GOK-name(%d)", a->name);
+		break;
+
+	case D_NONE:
+		sprint(str, "%ld", a->offset);
+		break;
+
+	case D_EXTERN:
+		if(s == S)
+			sprint(str, "%ld(SB)", a->offset);
+		else
+			sprint(str, "%s+%ld(SB)", s->name, a->offset);
+		break;
+
+	case D_STATIC:
+		if(s == S)
+			sprint(str, "<>+%ld(SB)", a->offset);
+		else
+			sprint(str, "%s<>+%ld(SB)", s->name, a->offset);
+		break;
+
+	case D_AUTO:
+		if(s == S)
+			sprint(str, "%ld(SP)", a->offset);
+		else
+			sprint(str, "%s-%ld(SP)", s->name, -a->offset);
+		break;
+
+	case D_PARAM:
+		if(s == S)
+			sprint(str, "%ld(FP)", a->offset);
+		else
+			sprint(str, "%s+%ld(FP)", s->name, a->offset);
+		break;
+	}
+	return fmtstrcpy(fp, str);
+}
+
+int
+Sconv(Fmt *fp)
+{
+	int i, c;
+	char str[STRINGSZ], *p, *a;
+
+	a = va_arg(fp->args, char*);
+	p = str;
+	for(i=0; i<sizeof(long); i++) {
+		c = a[i] & 0xff;
+		if(c >= 'a' && c <= 'z' ||
+		   c >= 'A' && c <= 'Z' ||
+		   c >= '0' && c <= '9' ||
+		   c == ' ' || c == '%') {
+			*p++ = c;
+			continue;
+		}
+		*p++ = '\\';
+		switch(c) {
+		case 0:
+			*p++ = 'z';
+			continue;
+		case '\\':
+		case '"':
+			*p++ = c;
+			continue;
+		case '\n':
+			*p++ = 'n';
+			continue;
+		case '\t':
+			*p++ = 't';
+			continue;
+		}
+		*p++ = (c>>6) + '0';
+		*p++ = ((c>>3) & 7) + '0';
+		*p++ = (c & 7) + '0';
+	}
+	*p = 0;
+	return fmtstrcpy(fp, str);
+}
+
+void
+diag(char *fmt, ...)
+{
+	char buf[STRINGSZ], *tn;
+	va_list arg;
+
+	tn = "??none??";
+	if(curtext != P && curtext->from.sym != S)
+		tn = curtext->from.sym->name;
+	va_start(arg, fmt);
+	vseprint(buf, buf+sizeof(buf), fmt, arg);
+	va_end(arg);
+	print("%s: %s\n", tn, buf);
+
+	nerrors++;
+	if(nerrors > 10) {
+		print("too many errors\n");
+		errorexit();
+	}
+}
diff --git a/src/cmd/5l/noop.c b/src/cmd/5l/noop.c
new file mode 100644
index 0000000000..00857a46c1
--- /dev/null
+++ b/src/cmd/5l/noop.c
@@ -0,0 +1,924 @@
+// Inferno utils/5l/noop.c
+// http://code.google.com/p/inferno-os/source/browse/utils/5l/noop.c
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#include	"l.h"
+
+static	Sym*	sym_div;
+static	Sym*	sym_divu;
+static	Sym*	sym_mod;
+static	Sym*	sym_modu;
+
+static void setdiv(int);
+
+static Prog *
+movrr(Prog *q, int rs, int rd, Prog *p)
+{
+	if(q == nil)
+		q = prg();
+	q->as = AMOVW;
+	q->line = p->line;
+	q->from.type = D_REG;
+	q->from.reg = rs;
+	q->to.type = D_REG;
+	q->to.reg = rd;
+	q->link = p->link;
+	return q;
+}
+
+static Prog *
+fnret(Prog *q, int rs, int foreign, Prog *p)
+{
+	q = movrr(q, rs, REGPC, p);
+	if(foreign){	// BX rs
+		q->as = ABXRET;
+		q->from.type = D_NONE;
+		q->from.reg = NREG;
+		q->to.reg = rs;
+	}
+	return q;
+}
+
+static Prog *
+aword(long w, Prog *p)
+{
+	Prog *q;
+
+	q = prg();
+	q->as = AWORD;
+	q->line = p->line;
+	q->from.type = D_NONE;
+	q->reg = NREG;
+	q->to.type = D_CONST;
+	q->to.offset = w;
+	q->link = p->link;
+	p->link = q;
+	return q;
+}
+
+static Prog *
+adword(long w1, long w2, Prog *p)
+{
+	Prog *q;
+
+	q = prg();
+	q->as = ADWORD;
+	q->line = p->line;
+	q->from.type = D_CONST;
+	q->from.offset = w1;
+	q->reg = NREG;
+	q->to.type = D_CONST;
+	q->to.offset = w2;
+	q->link = p->link;
+	p->link = q;
+	return q;
+}
+
+void
+noops(void)
+{
+	Prog *p, *q, *q1, *q2;
+	int o, curframe, curbecome, maxbecome, foreign;
+
+	/*
+	 * find leaf subroutines
+	 * become sizes
+	 * frame sizes
+	 * strip NOPs
+	 * expand RET
+	 * expand BECOME pseudo
+	 */
+
+	if(debug['v'])
+		Bprint(&bso, "%5.2f noops\n", cputime());
+	Bflush(&bso);
+
+	curframe = 0;
+	curbecome = 0;
+	maxbecome = 0;
+	curtext = 0;
+
+	q = P;
+	for(p = firstp; p != P; p = p->link) {
+		setarch(p);
+
+		/* find out how much arg space is used in this TEXT */
+		if(p->to.type == D_OREG && p->to.reg == REGSP)
+			if(p->to.offset > curframe)
+				curframe = p->to.offset;
+
+		switch(p->as) {
+		case ATEXT:
+			if(curtext && curtext->from.sym) {
+				curtext->from.sym->frame = curframe;
+				curtext->from.sym->become = curbecome;
+				if(curbecome > maxbecome)
+					maxbecome = curbecome;
+			}
+			curframe = 0;
+			curbecome = 0;
+
+			p->mark |= LEAF;
+			curtext = p;
+			break;
+
+		case ARET:
+			/* special form of RET is BECOME */
+			if(p->from.type == D_CONST)
+				if(p->from.offset > curbecome)
+					curbecome = p->from.offset;
+			break;
+
+		case ADIV:
+		case ADIVU:
+		case AMOD:
+		case AMODU:
+			q = p;
+			if(prog_div == P)
+				initdiv();
+			if(curtext != P)
+				curtext->mark &= ~LEAF;
+			setdiv(p->as);
+			continue;
+
+		case ANOP:
+			q1 = p->link;
+			q->link = q1;		/* q is non-nop */
+			q1->mark |= p->mark;
+			continue;
+
+		case ABL:
+		case ABX:
+			if(curtext != P)
+				curtext->mark &= ~LEAF;
+
+		case ABCASE:
+		case AB:
+
+		case ABEQ:
+		case ABNE:
+		case ABCS:
+		case ABHS:
+		case ABCC:
+		case ABLO:
+		case ABMI:
+		case ABPL:
+		case ABVS:
+		case ABVC:
+		case ABHI:
+		case ABLS:
+		case ABGE:
+		case ABLT:
+		case ABGT:
+		case ABLE:
+
+			q1 = p->cond;
+			if(q1 != P) {
+				while(q1->as == ANOP) {
+					q1 = q1->link;
+					p->cond = q1;
+				}
+			}
+			break;
+		}
+		q = p;
+	}
+
+	if(curtext && curtext->from.sym) {
+		curtext->from.sym->frame = curframe;
+		curtext->from.sym->become = curbecome;
+		if(curbecome > maxbecome)
+			maxbecome = curbecome;
+	}
+
+	if(debug['b'])
+		print("max become = %d\n", maxbecome);
+	xdefine("ALEFbecome", STEXT, maxbecome);
+
+	curtext = 0;
+	for(p = firstp; p != P; p = p->link) {
+		setarch(p);
+		switch(p->as) {
+		case ATEXT:
+			curtext = p;
+			break;
+		case ABL:
+		// case ABX:
+			if(curtext != P && curtext->from.sym != S && curtext->to.offset >= 0) {
+				o = maxbecome - curtext->from.sym->frame;
+				if(o <= 0)
+					break;
+				/* calling a become or calling a variable */
+				if(p->to.sym == S || p->to.sym->become) {
+					curtext->to.offset += o;
+					if(debug['b']) {
+						curp = p;
+						print("%D calling %D increase %d\n",
+							&curtext->from, &p->to, o);
+					}
+				}
+			}
+			break;
+		}
+	}
+
+	for(p = firstp; p != P; p = p->link) {
+		setarch(p);
+		o = p->as;
+		switch(o) {
+		case ATEXT:
+			curtext = p;
+			autosize = p->to.offset + 4;
+			if(autosize <= 4)
+			if(curtext->mark & LEAF) {
+				p->to.offset = -4;
+				autosize = 0;
+			}
+
+			if(!autosize && !(curtext->mark & LEAF)) {
+				if(debug['v'])
+					Bprint(&bso, "save suppressed in: %s\n",
+						curtext->from.sym->name);
+				Bflush(&bso);
+				curtext->mark |= LEAF;
+			}
+#ifdef CALLEEBX
+			if(p->from.sym->foreign){
+				if(thumb)
+					// don't allow literal pool to seperate these
+					p = adword(0xe28f7001, 0xe12fff17, p); // arm add 1, pc, r7 and bx r7
+					// p = aword(0xe12fff17, aword(0xe28f7001, p)); // arm add 1, pc, r7 and bx r7
+				else
+					p = aword(0x4778, p);	// thumb bx pc and 2 bytes padding
+			}
+#endif
+			if(curtext->mark & LEAF) {
+				if(curtext->from.sym)
+					curtext->from.sym->type = SLEAF;
+#ifdef optimise_time
+				if(autosize) {
+					q = prg();
+					q->as = ASUB;
+					q->line = p->line;
+					q->from.type = D_CONST;
+					q->from.offset = autosize;
+					q->to.type = D_REG;
+					q->to.reg = REGSP;
+
+					q->link = p->link;
+					p->link = q;
+				}
+				break;
+#else
+				if(!autosize)
+					break;
+#endif
+			}
+
+			if(thumb){
+				if(!(curtext->mark & LEAF)){
+					q = movrr(nil, REGLINK, REGTMPT-1, p);
+					p->link = q;
+					q1 = prg();
+					q1->as = AMOVW;
+					q1->line = p->line;
+					q1->from.type = D_REG;
+					q1->from.reg = REGTMPT-1;
+					q1->to.type = D_OREG;
+					q1->to.name = D_NONE;
+					q1->to.reg = REGSP;
+					q1->to.offset = 0;
+					q1->link = q->link;
+					q->link = q1;
+				}
+				if(autosize){
+					q2 = prg();
+					q2->as = ASUB;
+					q2->line = p->line;
+					q2->from.type = D_CONST;
+					q2->from.offset = autosize;
+					q2->to.type = D_REG;
+					q2->to.reg = REGSP;
+					q2->link = p->link;
+					p->link = q2;
+				}
+				break;
+			}
+
+			q1 = prg();
+			q1->as = AMOVW;
+			q1->scond |= C_WBIT;
+			q1->line = p->line;
+			q1->from.type = D_REG;
+			q1->from.reg = REGLINK;
+			q1->to.type = D_OREG;
+			q1->to.offset = -autosize;
+			q1->to.reg = REGSP;
+			q1->link = p->link;
+			p->link = q1;
+			break;
+
+		case ARET:
+			nocache(p);
+			foreign = seenthumb && curtext->from.sym != S && (curtext->from.sym->foreign || curtext->from.sym->fnptr);
+// print("%s %d %d\n", curtext->from.sym->name, curtext->from.sym->foreign, curtext->from.sym->fnptr);
+			if(p->from.type == D_CONST)
+				goto become;
+			if(curtext->mark & LEAF) {
+				if(!autosize) {
+					if(thumb){
+						p = fnret(p, REGLINK, foreign, p);
+						break;
+					}
+// if(foreign) print("ABXRET 1 %s\n", curtext->from.sym->name);
+					p->as = foreign ? ABXRET : AB;
+					p->from = zprg.from;
+					p->to.type = D_OREG;
+					p->to.offset = 0;
+					p->to.reg = REGLINK;
+					break;
+				}
+
+#ifdef optimise_time
+				p->as = AADD;
+				p->from.type = D_CONST;
+				p->from.offset = autosize;
+				p->to.type = D_REG;
+				p->to.reg = REGSP;
+				if(thumb){
+					p->link = fnret(nil, REGLINK, foreign, p);
+					break;
+				}
+				q = prg();
+// if(foreign) print("ABXRET 2 %s\n", curtext->from.sym->name);
+				q->as = foreign ? ABXRET : AB;
+				q->scond = p->scond;
+				q->line = p->line;
+				q->to.type = D_OREG;
+				q->to.offset = 0;
+				q->to.reg = REGLINK;
+
+				q->link = p->link;
+				p->link = q;
+
+				break;
+#endif
+			}
+			if(thumb){
+				if(curtext->mark & LEAF){
+					if(autosize){
+						p->as = AADD;
+						p->from.type = D_CONST;
+						p->from.offset = autosize;
+						p->to.type = D_REG;
+						p->to.reg = REGSP;
+						q = nil;
+					}
+					else
+						q = p;
+					q = fnret(q, REGLINK, foreign, p);
+					if(q != p)
+						p->link = q;
+				}
+				else{
+					p->as = AMOVW;
+					p->from.type = D_OREG;
+					p->from.name = D_NONE;
+					p->from.reg = REGSP;
+					p->from.offset = 0;
+					p->to.type = D_REG;
+					p->to.reg = REGTMPT-1;
+					if(autosize){
+						q = prg();
+						q->as = AADD;
+						q->from.type = D_CONST;
+						q->from.offset = autosize;
+						q->to.type = D_REG;
+						q->to.reg = REGSP;
+						q->link = p->link;
+						p->link = 	q;
+					}
+					else
+						q = p;
+					q1 = fnret(nil, REGTMPT-1, foreign, p);
+					q1->link = q->link;
+					q->link = q1;
+				}
+				break;
+			}
+			if(foreign) {
+// if(foreign) print("ABXRET 3 %s\n", curtext->from.sym->name);
+#define	R	1
+				p->as = AMOVW;
+				p->from.type = D_OREG;
+				p->from.name = D_NONE;
+				p->from.reg = REGSP;
+				p->from.offset = 0;
+				p->to.type = D_REG;
+				p->to.reg = R;
+				q = prg();
+				q->as = AADD;
+				q->scond = p->scond;
+				q->line = p->line;
+				q->from.type = D_CONST;
+				q->from.offset = autosize;
+				q->to.type = D_REG;
+				q->to.reg = REGSP;
+				q->link = p->link;
+				p->link = q;
+				q1 = prg();
+				q1->as = ABXRET;
+				q1->scond = p->scond;
+				q1->line = p->line;
+				q1->to.type = D_OREG;
+				q1->to.offset = 0;
+				q1->to.reg = R;
+				q1->link = q->link;
+				q->link = q1;
+#undef	R
+			}
+			else {
+				p->as = AMOVW;
+				p->scond |= C_PBIT;
+				p->from.type = D_OREG;
+				p->from.offset = autosize;
+				p->from.reg = REGSP;
+				p->to.type = D_REG;
+				p->to.reg = REGPC;
+			}
+			break;
+
+		become:
+			if(foreign){
+				diag("foreign become - help");
+				break;
+			}
+			if(thumb){
+				diag("thumb become - help");
+				break;
+			}
+			print("arm become\n");
+			if(curtext->mark & LEAF) {
+
+				if(!autosize) {
+					p->as = AB;
+					p->from = zprg.from;
+					break;
+				}
+
+#ifdef optimise_time
+				q = prg();
+				q->scond = p->scond;
+				q->line = p->line;
+				q->as = AB;
+				q->from = zprg.from;
+				q->to = p->to;
+				q->cond = p->cond;
+				q->link = p->link;
+				p->link = q;
+
+				p->as = AADD;
+				p->from = zprg.from;
+				p->from.type = D_CONST;
+				p->from.offset = autosize;
+				p->to = zprg.to;
+				p->to.type = D_REG;
+				p->to.reg = REGSP;
+
+				break;
+#endif
+			}
+			q = prg();
+			q->scond = p->scond;
+			q->line = p->line;
+			q->as = AB;
+			q->from = zprg.from;
+			q->to = p->to;
+			q->cond = p->cond;
+			q->link = p->link;
+			p->link = q;
+			if(thumb){
+				q1 = prg();
+				q1->line = p->line;
+				q1->as = AADD;
+				q1->from.type = D_CONST;
+				q1->from.offset = autosize;
+				q1->to.type = D_REG;
+				q1->to.reg = REGSP;
+				p->as = AMOVW;
+				p->line = p->line;
+				p->from.type = D_OREG;
+				p->from.name = D_NONE;
+				p->from.reg = REGSP;
+				p->from.offset = 0;
+				p->to.type = D_REG;
+				p->to.reg = REGTMPT-1;
+				q1->link = q;
+				p->link = q1;
+				q2 = movrr(nil, REGTMPT-1, REGLINK, p);
+				q2->link = q;
+				q1->link = q2;
+				break;
+			}
+			p->as = AMOVW;
+			p->scond |= C_PBIT;
+			p->from = zprg.from;
+			p->from.type = D_OREG;
+			p->from.offset = autosize;
+			p->from.reg = REGSP;
+			p->to = zprg.to;
+			p->to.type = D_REG;
+			p->to.reg = REGLINK;
+
+			break;
+
+		case ADIV:
+		case ADIVU:
+		case AMOD:
+		case AMODU:
+			if(debug['M'])
+				break;
+			if(p->from.type != D_REG)
+				break;
+			if(p->to.type != D_REG)
+				break;
+			q1 = p;
+
+			/* MOV a,4(SP) */
+			q = prg();
+			q->link = p->link;
+			p->link = q;
+			p = q;
+
+			p->as = AMOVW;
+			p->line = q1->line;
+			p->from.type = D_REG;
+			p->from.reg = q1->from.reg;
+			p->to.type = D_OREG;
+			p->to.reg = REGSP;
+			p->to.offset = 4;
+
+			/* MOV b,REGTMP */
+			q = prg();
+			q->link = p->link;
+			p->link = q;
+			p = q;
+
+			p->as = AMOVW;
+			p->line = q1->line;
+			p->from.type = D_REG;
+			p->from.reg = q1->reg;
+			if(q1->reg == NREG)
+				p->from.reg = q1->to.reg;
+			p->to.type = D_REG;
+			p->to.reg = prog_div != UP && prog_div->from.sym->thumb ? REGTMPT : REGTMP;
+			p->to.offset = 0;
+
+			/* CALL appropriate */
+			q = prg();
+			q->link = p->link;
+			p->link = q;
+			p = q;
+
+#ifdef CALLEEBX
+			p->as = ABL;
+#else
+			if(prog_div != UP && prog_div->from.sym->thumb)
+				p->as = thumb ? ABL : ABX;
+			else
+				p->as = thumb ? ABX : ABL;
+#endif
+			p->line = q1->line;
+			p->to.type = D_BRANCH;
+			p->cond = p;
+			switch(o) {
+			case ADIV:
+				p->cond = prog_div;
+				p->to.sym = sym_div;
+				break;
+			case ADIVU:
+				p->cond = prog_divu;
+				p->to.sym = sym_divu;
+				break;
+			case AMOD:
+				p->cond = prog_mod;
+				p->to.sym = sym_mod;
+				break;
+			case AMODU:
+				p->cond = prog_modu;
+				p->to.sym = sym_modu;
+				break;
+			}
+
+			/* MOV REGTMP, b */
+			q = prg();
+			q->link = p->link;
+			p->link = q;
+			p = q;
+
+			p->as = AMOVW;
+			p->line = q1->line;
+			p->from.type = D_REG;
+			p->from.reg = prog_div != UP && prog_div->from.sym->thumb ? REGTMPT : REGTMP;
+			p->from.offset = 0;
+			p->to.type = D_REG;
+			p->to.reg = q1->to.reg;
+
+			/* ADD $8,SP */
+			q = prg();
+			q->link = p->link;
+			p->link = q;
+			p = q;
+
+			p->as = AADD;
+			p->from.type = D_CONST;
+			p->from.reg = NREG;
+			p->from.offset = 8;
+			p->reg = NREG;
+			p->to.type = D_REG;
+			p->to.reg = REGSP;
+
+			/* SUB $8,SP */
+			q1->as = ASUB;
+			q1->from.type = D_CONST;
+			q1->from.offset = 8;
+			q1->from.reg = NREG;
+			q1->reg = NREG;
+			q1->to.type = D_REG;
+			q1->to.reg = REGSP;
+
+			break;
+		case AMOVW:
+			if(thumb){
+				Adr *a = &p->from;
+
+				if(a->type == D_CONST && ((a->name == D_NONE && a->reg == REGSP) || a->name == D_AUTO || a->name == D_PARAM) && (a->offset & 3))
+					diag("SP offset not multiple of 4");
+			}
+			break;
+		case AMOVB:
+		case AMOVBU:
+		case AMOVH:
+		case AMOVHU:
+			if(thumb){
+				if(p->from.type == D_OREG && (p->from.name == D_AUTO || p->from.name == D_PARAM || (p->from.name == D_CONST && p->from.reg == REGSP))){
+					q = prg();
+					*q = *p;
+					if(p->from.name == D_AUTO)
+						q->from.offset += autosize;
+					else if(p->from.name == D_PARAM)
+						q->from.offset += autosize+4;
+					q->from.name = D_NONE;
+					q->from.reg = REGTMPT;
+					p = movrr(p, REGSP, REGTMPT, p);
+					q->link = p->link;
+					p->link = q;
+				}
+				if(p->to.type == D_OREG && (p->to.name == D_AUTO || p->to.name == D_PARAM || (p->to.name == D_CONST && p->to.reg == REGSP))){
+					q = prg();
+					*q = *p;
+					if(p->to.name == D_AUTO)
+						q->to.offset += autosize;
+					else if(p->to.name == D_PARAM)
+						q->to.offset += autosize+4;
+					q->to.name = D_NONE;
+					q->to.reg = REGTMPT;
+					p = movrr(p, REGSP, REGTMPT, p);
+					q->link = p->link;
+					p->link = q;
+					if(q->to.offset < 0 || q->to.offset > 255){	// complicated
+						p->to.reg = REGTMPT+1;			// mov sp, r8
+						q1 = prg();
+						q1->line = p->line;
+						q1->as = AMOVW;
+						q1->from.type = D_CONST;
+						q1->from.offset = q->to.offset;
+						q1->to.type = D_REG;
+						q1->to.reg = REGTMPT;			// mov $o, r7
+						p->link = q1;
+						q1->link = q;
+						q1 = prg();
+						q1->line = p->line;
+						q1->as = AADD;
+						q1->from.type = D_REG;
+						q1->from.reg = REGTMPT+1;
+						q1->to.type = D_REG;
+						q1->to.reg = REGTMPT;			// add r8, r7
+						p->link->link = q1;
+						q1->link = q;
+						q->to.offset = 0;				// mov* r, 0(r7)
+						/* phew */
+					}
+				}
+			}
+			break;
+		case AMOVM:
+			if(thumb){
+				if(p->from.type == D_OREG){
+					if(p->from.offset == 0)
+						p->from.type = D_REG;
+					else
+						diag("non-zero AMOVM offset");
+				}
+				else if(p->to.type == D_OREG){
+					if(p->to.offset == 0)
+						p->to.type = D_REG;
+					else
+						diag("non-zero AMOVM offset");
+				}
+			}
+			break;
+		case AB:
+			if(thumb && p->to.type == D_OREG){
+				if(p->to.offset == 0){
+					p->as = AMOVW;
+					p->from.type = D_REG;
+					p->from.reg = p->to.reg;
+					p->to.type = D_REG;
+					p->to.reg = REGPC;
+				}
+				else{
+					p->as = AADD;
+					p->from.type = D_CONST;
+					p->from.offset = p->to.offset;
+					p->reg = p->to.reg;
+					p->to.type = D_REG;
+					p->to.reg = REGTMPT-1;
+					q = prg();
+					q->as = AMOVW;
+					q->line = p->line;
+					q->from.type = D_REG;
+					q->from.reg = REGTMPT-1;
+					q->to.type = D_REG;
+					q->to.reg = REGPC;
+					q->link = p->link;
+					p->link = q;
+				}
+			}
+			if(seenthumb && !thumb && p->to.type == D_OREG && p->to.reg == REGLINK){	
+				// print("warn %s:	b	(R%d)	assuming a return\n", curtext->from.sym->name, p->to.reg);
+				p->as = ABXRET;
+			}
+			break;
+		case ABL:
+		case ABX:
+			if(thumb && p->to.type == D_OREG){
+				if(p->to.offset == 0){
+					p->as = o;
+					p->from.type = D_NONE;
+					p->to.type = D_REG;
+				}
+				else{
+					p->as = AADD;
+					p->from.type = D_CONST;
+					p->from.offset = p->to.offset;
+					p->reg = p->to.reg;
+					p->to.type = D_REG;
+					p->to.reg = REGTMPT-1;
+					q = prg();
+					q->as = o;
+					q->line = p->line;
+					q->from.type = D_NONE;
+					q->to.type = D_REG;
+					q->to.reg = REGTMPT-1;
+					q->link = p->link;
+					p->link = q;
+				}
+			}
+			break;
+		}
+	}
+}
+
+static void
+sigdiv(char *n)
+{
+	Sym *s;
+
+	s = lookup(n, 0);
+	if(s->type == STEXT){
+		if(s->sig == 0)
+			s->sig = SIGNINTERN;
+	}
+	else if(s->type == 0 || s->type == SXREF)
+		s->type = SUNDEF;
+}
+
+void
+divsig(void)
+{
+	sigdiv("_div");
+	sigdiv("_divu");
+	sigdiv("_mod");
+	sigdiv("_modu");
+}
+
+static void
+sdiv(Sym *s)
+{
+	if(s->type == 0 || s->type == SXREF){
+		/* undefsym(s); */
+		s->type = SXREF;
+		if(s->sig == 0)
+			s->sig = SIGNINTERN;
+		s->subtype = SIMPORT;
+	}
+	else if(s->type != STEXT)
+		diag("undefined: %s", s->name);
+}
+
+void
+initdiv(void)
+{
+	Sym *s2, *s3, *s4, *s5;
+	Prog *p;
+
+	if(prog_div != P)
+		return;
+	sym_div = s2 = lookup("_div", 0);
+	sym_divu = s3 = lookup("_divu", 0);
+	sym_mod = s4 = lookup("_mod", 0);
+	sym_modu = s5 = lookup("_modu", 0);
+	if(dlm) {
+		sdiv(s2); if(s2->type == SXREF) prog_div = UP;
+		sdiv(s3); if(s3->type == SXREF) prog_divu = UP;
+		sdiv(s4); if(s4->type == SXREF) prog_mod = UP;
+		sdiv(s5); if(s5->type == SXREF) prog_modu = UP;
+	}
+	for(p = firstp; p != P; p = p->link)
+		if(p->as == ATEXT) {
+			if(p->from.sym == s2)
+				prog_div = p;
+			if(p->from.sym == s3)
+				prog_divu = p;
+			if(p->from.sym == s4)
+				prog_mod = p;
+			if(p->from.sym == s5)
+				prog_modu = p;
+		}
+	if(prog_div == P) {
+		diag("undefined: %s", s2->name);
+		prog_div = curtext;
+	}
+	if(prog_divu == P) {
+		diag("undefined: %s", s3->name);
+		prog_divu = curtext;
+	}
+	if(prog_mod == P) {
+		diag("undefined: %s", s4->name);
+		prog_mod = curtext;
+	}
+	if(prog_modu == P) {
+		diag("undefined: %s", s5->name);
+		prog_modu = curtext;
+	}
+}
+
+static void
+setdiv(int as)
+{
+	Prog *p = nil;
+
+	switch(as){
+	case ADIV: p = prog_div; break;
+	case ADIVU: p = prog_divu; break;
+	case AMOD: p = prog_mod; break;
+	case AMODU: p = prog_modu; break;
+	}
+	if(p != UP && thumb != p->from.sym->thumb)
+		p->from.sym->foreign = 1;
+}
+
+void
+nocache(Prog *p)
+{
+	p->optab = 0;
+	p->from.class = 0;
+	p->to.class = 0;
+}
diff --git a/src/cmd/5l/obj.c b/src/cmd/5l/obj.c
new file mode 100644
index 0000000000..5c28b70087
--- /dev/null
+++ b/src/cmd/5l/obj.c
@@ -0,0 +1,1588 @@
+// Inferno utils/5l/obj.c
+// http://code.google.com/p/inferno-os/source/browse/utils/5l/obj.c
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#define	EXTERN
+#include	"l.h"
+#include	<ar.h>
+
+#ifndef	DEFAULT
+#define	DEFAULT	'9'
+#endif
+
+char	*noname		= "<none>";
+char	symname[]	= SYMDEF;
+char	thechar		= '5';
+char	*thestring 	= "arm";
+
+/*
+ *	-H1 -T0x10005000 -R4		is aif for risc os
+ *	-H2 -T4128 -R4096		is plan9 format
+ *	-H3 -T0xF0000020 -R4		is NetBSD format
+ *	-H4				is IXP1200 (raw)
+ *	-H5 -T0xC0008010 -R1024		is ipaq
+ */
+
+static int
+isobjfile(char *f)
+{
+	int n, v;
+	Biobuf *b;
+	char buf1[5], buf2[SARMAG];
+
+	b = Bopen(f, OREAD);
+	if(b == nil)
+		return 0;
+	n = Bread(b, buf1, 5);
+	if(n == 5 && (buf1[2] == 1 && buf1[3] == '<' || buf1[3] == 1 && buf1[4] == '<'))
+		v = 1;	/* good enough for our purposes */
+	else{
+		Bseek(b, 0, 0);
+		n = Bread(b, buf2, SARMAG);
+		v = n == SARMAG && strncmp(buf2, ARMAG, SARMAG) == 0;
+	}
+	Bterm(b);
+	return v;
+}
+
+void
+main(int argc, char *argv[])
+{
+	int c;
+	char *a;
+
+	Binit(&bso, 1, OWRITE);
+	srand(time(0));
+	cout = -1;
+	listinit();
+	outfile = 0;
+	nerrors = 0;
+	curtext = P;
+	HEADTYPE = -1;
+	INITTEXT = -1;
+	INITDAT = -1;
+	INITRND = -1;
+	INITENTRY = 0;
+
+	ARGBEGIN {
+	default:
+		c = ARGC();
+		if(c >= 0 && c < sizeof(debug))
+			debug[c]++;
+		break;
+	case 'o':
+		outfile = ARGF();
+		break;
+	case 'E':
+		a = ARGF();
+		if(a)
+			INITENTRY = a;
+		break;
+	case 'T':
+		a = ARGF();
+		if(a)
+			INITTEXT = atolwhex(a);
+		break;
+	case 'D':
+		a = ARGF();
+		if(a)
+			INITDAT = atolwhex(a);
+		break;
+	case 'R':
+		a = ARGF();
+		if(a)
+			INITRND = atolwhex(a);
+		break;
+	case 'H':
+		a = ARGF();
+		if(a)
+			HEADTYPE = atolwhex(a);
+		/* do something about setting INITTEXT */
+		break;
+	case 'x':	/* produce export table */
+		doexp = 1;
+		if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
+			readundefs(ARGF(), SEXPORT);
+		break;
+	case 'u':	/* produce dynamically loadable module */
+		dlm = 1;
+		debug['l']++;
+		if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
+			readundefs(ARGF(), SIMPORT);
+		break;
+	} ARGEND
+
+	USED(argc);
+
+	if(*argv == 0) {
+		diag("usage: 5l [-options] objects");
+		errorexit();
+	}
+	if(!debug['9'] && !debug['U'] && !debug['B'])
+		debug[DEFAULT] = 1;
+	if(HEADTYPE == -1) {
+		if(debug['U'])
+			HEADTYPE = 0;
+		if(debug['B'])
+			HEADTYPE = 1;
+		if(debug['9'])
+			HEADTYPE = 2;
+	}
+	switch(HEADTYPE) {
+	default:
+		diag("unknown -H option");
+		errorexit();
+	case 0:	/* no header */
+		HEADR = 0L;
+		if(INITTEXT == -1)
+			INITTEXT = 0;
+		if(INITDAT == -1)
+			INITDAT = 0;
+		if(INITRND == -1)
+			INITRND = 4;
+		break;
+	case 1:	/* aif for risc os */
+		HEADR = 128L;
+		if(INITTEXT == -1)
+			INITTEXT = 0x10005000 + HEADR;
+		if(INITDAT == -1)
+			INITDAT = 0;
+		if(INITRND == -1)
+			INITRND = 4;
+		break;
+	case 2:	/* plan 9 */
+		HEADR = 32L;
+		if(INITTEXT == -1)
+			INITTEXT = 4128;
+		if(INITDAT == -1)
+			INITDAT = 0;
+		if(INITRND == -1)
+			INITRND = 4096;
+		break;
+	case 3:	/* boot for NetBSD */
+		HEADR = 32L;
+		if(INITTEXT == -1)
+			INITTEXT = 0xF0000020L;
+		if(INITDAT == -1)
+			INITDAT = 0;
+		if(INITRND == -1)
+			INITRND = 4096;
+		break;
+	case 4: /* boot for IXP1200 */
+		HEADR = 0L;
+		if(INITTEXT == -1)
+			INITTEXT = 0x0;
+		if(INITDAT == -1)
+			INITDAT = 0;
+		if(INITRND == -1)
+			INITRND = 4;
+		break;
+	case 5: /* boot for ipaq */
+		HEADR = 16L;
+		if(INITTEXT == -1)
+			INITTEXT = 0xC0008010;
+		if(INITDAT == -1)
+			INITDAT = 0;
+		if(INITRND == -1)
+			INITRND = 1024;
+		break;
+	}
+	if(INITDAT != 0 && INITRND != 0)
+		print("warning: -D0x%lux is ignored because of -R0x%lux\n",
+			INITDAT, INITRND);
+	if(debug['v'])
+		Bprint(&bso, "HEADER = -H0x%d -T0x%lux -D0x%lux -R0x%lux\n",
+			HEADTYPE, INITTEXT, INITDAT, INITRND);
+	Bflush(&bso);
+	zprg.as = AGOK;
+	zprg.scond = 14;
+	zprg.reg = NREG;
+	zprg.from.name = D_NONE;
+	zprg.from.type = D_NONE;
+	zprg.from.reg = NREG;
+	zprg.to = zprg.from;
+	buildop();
+	thumbbuildop();	// could build on demand
+	histgen = 0;
+	textp = P;
+	datap = P;
+	pc = 0;
+	dtype = 4;
+	if(outfile == 0)
+		outfile = "5.out";
+	cout = create(outfile, 1, 0775);
+	if(cout < 0) {
+		diag("%s: cannot create", outfile);
+		errorexit();
+	}
+	nuxiinit();
+
+	version = 0;
+	cbp = buf.cbuf;
+	cbc = sizeof(buf.cbuf);
+	firstp = prg();
+	lastp = firstp;
+
+	if(INITENTRY == 0) {
+		INITENTRY = "_main";
+		if(debug['p'])
+			INITENTRY = "_mainp";
+		if(!debug['l'])
+			lookup(INITENTRY, 0)->type = SXREF;
+	} else
+		lookup(INITENTRY, 0)->type = SXREF;
+
+	while(*argv)
+		objfile(*argv++);
+	if(!debug['l'])
+		loadlib();
+	firstp = firstp->link;
+	if(firstp == P)
+		goto out;
+	if(doexp || dlm){
+		EXPTAB = "_exporttab";
+		zerosig(EXPTAB);
+		zerosig("etext");
+		zerosig("edata");
+		zerosig("end");
+		if(dlm){
+			initdiv();
+			import();
+			HEADTYPE = 2;
+			INITTEXT = INITDAT = 0;
+			INITRND = 8;
+			INITENTRY = EXPTAB;
+		}
+		else
+			divsig();
+		export();
+	}
+	patch();
+	if(debug['p'])
+		if(debug['1'])
+			doprof1();
+		else
+			doprof2();
+	if(debug['u'])
+		reachable();
+	dodata();
+	if(seenthumb && debug['f'])
+		fnptrs();
+	follow();
+	if(firstp == P)
+		goto out;
+	noops();
+	span();
+	asmb();
+	undef();
+
+out:
+	if(debug['c']){
+		thumbcount();
+		print("ARM size = %d\n", armsize);
+	}
+	if(debug['v']) {
+		Bprint(&bso, "%5.2f cpu time\n", cputime());
+		Bprint(&bso, "%ld memory used\n", thunk);
+		Bprint(&bso, "%d sizeof adr\n", sizeof(Adr));
+		Bprint(&bso, "%d sizeof prog\n", sizeof(Prog));
+	}
+	Bflush(&bso);
+	errorexit();
+}
+
+void
+loadlib(void)
+{
+	int i;
+	long h;
+	Sym *s;
+
+loop:
+	xrefresolv = 0;
+	for(i=0; i<libraryp; i++) {
+		if(debug['v'])
+			Bprint(&bso, "%5.2f autolib: %s (from %s)\n", cputime(), library[i], libraryobj[i]);
+		objfile(library[i]);
+	}
+	if(xrefresolv)
+	for(h=0; h<nelem(hash); h++)
+	for(s = hash[h]; s != S; s = s->link)
+		if(s->type == SXREF)
+			goto loop;
+}
+
+void
+errorexit(void)
+{
+
+	Bflush(&bso);
+	if(nerrors) {
+		if(cout >= 0)
+			remove(outfile);
+		exits("error");
+	}
+	exits(0);
+}
+
+void
+objfile(char *file)
+{
+	long off, esym, cnt, l;
+	int f, work;
+	Sym *s;
+	char magbuf[SARMAG];
+	char name[100], pname[150];
+	struct ar_hdr arhdr;
+	char *e, *start, *stop;
+
+	if(file[0] == '-' && file[1] == 'l') {
+		if(debug['9'])
+			sprint(name, "/%s/lib/lib", thestring);
+		else
+			sprint(name, "/usr/%clib/lib", thechar);
+		strcat(name, file+2);
+		strcat(name, ".a");
+		file = name;
+	}
+	if(debug['v'])
+		Bprint(&bso, "%5.2f ldobj: %s\n", cputime(), file);
+	Bflush(&bso);
+	f = open(file, 0);
+	if(f < 0) {
+		diag("cannot open file: %s", file);
+		errorexit();
+	}
+	l = read(f, magbuf, SARMAG);
+	if(l != SARMAG || strncmp(magbuf, ARMAG, SARMAG)){
+		/* load it as a regular file */
+		l = seek(f, 0L, 2);
+		seek(f, 0L, 0);
+		ldobj(f, l, file);
+		close(f);
+		return;
+	}
+
+	if(debug['v'])
+		Bprint(&bso, "%5.2f ldlib: %s\n", cputime(), file);
+	l = read(f, &arhdr, SAR_HDR);
+	if(l != SAR_HDR) {
+		diag("%s: short read on archive file symbol header", file);
+		goto out;
+	}
+	if(strncmp(arhdr.name, symname, strlen(symname))) {
+		diag("%s: first entry not symbol header", file);
+		goto out;
+	}
+
+	esym = SARMAG + SAR_HDR + atolwhex(arhdr.size);
+	off = SARMAG + SAR_HDR;
+
+	/*
+	 * just bang the whole symbol file into memory
+	 */
+	seek(f, off, 0);
+	cnt = esym - off;
+	start = malloc(cnt + 10);
+	cnt = read(f, start, cnt);
+	if(cnt <= 0){
+		close(f);
+		return;
+	}
+	stop = &start[cnt];
+	memset(stop, 0, 10);
+
+	work = 1;
+	while(work){
+		if(debug['v'])
+			Bprint(&bso, "%5.2f library pass: %s\n", cputime(), file);
+		Bflush(&bso);
+		work = 0;
+		for(e = start; e < stop; e = strchr(e+5, 0) + 1) {
+			s = lookup(e+5, 0);
+			if(s->type != SXREF)
+				continue;
+			sprint(pname, "%s(%s)", file, s->name);
+			if(debug['v'])
+				Bprint(&bso, "%5.2f library: %s\n", cputime(), pname);
+			Bflush(&bso);
+			l = e[1] & 0xff;
+			l |= (e[2] & 0xff) << 8;
+			l |= (e[3] & 0xff) << 16;
+			l |= (e[4] & 0xff) << 24;
+			seek(f, l, 0);
+			l = read(f, &arhdr, SAR_HDR);
+			if(l != SAR_HDR)
+				goto bad;
+			if(strncmp(arhdr.fmag, ARFMAG, sizeof(arhdr.fmag)))
+				goto bad;
+			l = atolwhex(arhdr.size);
+			ldobj(f, l, pname);
+			if(s->type == SXREF) {
+				diag("%s: failed to load: %s", file, s->name);
+				errorexit();
+			}
+			work = 1;
+			xrefresolv = 1;
+		}
+	}
+	return;
+
+bad:
+	diag("%s: bad or out of date archive", file);
+out:
+	close(f);
+}
+
+int
+zaddr(uchar *p, Adr *a, Sym *h[])
+{
+	int i, c;
+	long l;
+	Sym *s;
+	Auto *u;
+
+	c = p[2];
+	if(c < 0 || c > NSYM){
+		print("sym out of range: %d\n", c);
+		p[0] = ALAST+1;
+		return 0;
+	}
+	a->type = p[0];
+	a->reg = p[1];
+	a->sym = h[c];
+	a->name = p[3];
+	c = 4;
+
+	if(a->reg < 0 || a->reg > NREG) {
+		print("register out of range %d\n", a->reg);
+		p[0] = ALAST+1;
+		return 0;	/*  force real diagnostic */
+	}
+
+	if(a->type == D_CONST || a->type == D_OCONST) {
+		if(a->name == D_EXTERN || a->name == D_STATIC) {
+			s = a->sym;
+			if(s != S && (s->type == STEXT || s->type == SLEAF || s->type == SCONST || s->type == SXREF)) {
+				if(0 && !s->fnptr && s->name[0] != '.')
+					print("%s used as function pointer\n", s->name);
+				s->fnptr = 1;	// over the top cos of SXREF
+			}
+		}
+	}
+
+	switch(a->type) {
+	default:
+		print("unknown type %d\n", a->type);
+		p[0] = ALAST+1;
+		return 0;	/*  force real diagnostic */
+
+	case D_NONE:
+	case D_REG:
+	case D_FREG:
+	case D_PSR:
+	case D_FPCR:
+		break;
+
+	case D_REGREG:
+		a->offset = p[4];
+		c++;
+		break;
+
+	case D_BRANCH:
+	case D_OREG:
+	case D_CONST:
+	case D_OCONST:
+	case D_SHIFT:
+		a->offset = p[4] | (p[5]<<8) |
+			(p[6]<<16) | (p[7]<<24);
+		c += 4;
+		break;
+
+	case D_SCONST:
+		while(nhunk < NSNAME)
+			gethunk();
+		a->sval = (char*)hunk;
+		nhunk -= NSNAME;
+		hunk += NSNAME;
+
+		memmove(a->sval, p+4, NSNAME);
+		c += NSNAME;
+		break;
+
+	case D_FCONST:
+		while(nhunk < sizeof(Ieee))
+			gethunk();
+		a->ieee = (Ieee*)hunk;
+		nhunk -= NSNAME;
+		hunk += NSNAME;
+
+		a->ieee->l = p[4] | (p[5]<<8) |
+			(p[6]<<16) | (p[7]<<24);
+		a->ieee->h = p[8] | (p[9]<<8) |
+			(p[10]<<16) | (p[11]<<24);
+		c += 8;
+		break;
+	}
+	s = a->sym;
+	if(s == S)
+		return c;
+	i = a->name;
+	if(i != D_AUTO && i != D_PARAM)
+		return c;
+
+	l = a->offset;
+	for(u=curauto; u; u=u->link)
+		if(u->asym == s)
+		if(u->type == i) {
+			if(u->aoffset > l)
+				u->aoffset = l;
+			return c;
+		}
+
+	while(nhunk < sizeof(Auto))
+		gethunk();
+	u = (Auto*)hunk;
+	nhunk -= sizeof(Auto);
+	hunk += sizeof(Auto);
+
+	u->link = curauto;
+	curauto = u;
+	u->asym = s;
+	u->aoffset = l;
+	u->type = i;
+	return c;
+}
+
+void
+addlib(char *obj)
+{
+	char name[1024], comp[256], *p;
+	int i;
+
+	if(histfrogp <= 0)
+		return;
+
+	if(histfrog[0]->name[1] == '/') {
+		sprint(name, "");
+		i = 1;
+	} else
+	if(histfrog[0]->name[1] == '.') {
+		sprint(name, ".");
+		i = 0;
+	} else {
+		if(debug['9'])
+			sprint(name, "/%s/lib", thestring);
+		else
+			sprint(name, "/usr/%clib", thechar);
+		i = 0;
+	}
+
+	for(; i<histfrogp; i++) {
+		snprint(comp, sizeof comp, histfrog[i]->name+1);
+		for(;;) {
+			p = strstr(comp, "$O");
+			if(p == 0)
+				break;
+			memmove(p+1, p+2, strlen(p+2)+1);
+			p[0] = thechar;
+		}
+		for(;;) {
+			p = strstr(comp, "$M");
+			if(p == 0)
+				break;
+			if(strlen(comp)+strlen(thestring)-2+1 >= sizeof comp) {
+				diag("library component too long");
+				return;
+			}
+			memmove(p+strlen(thestring), p+2, strlen(p+2)+1);
+			memmove(p, thestring, strlen(thestring));
+		}
+		if(strlen(name) + strlen(comp) + 3 >= sizeof(name)) {
+			diag("library component too long");
+			return;
+		}
+		strcat(name, "/");
+		strcat(name, comp);
+	}
+	for(i=0; i<libraryp; i++)
+		if(strcmp(name, library[i]) == 0)
+			return;
+	if(libraryp == nelem(library)){
+		diag("too many autolibs; skipping %s", name);
+		return;
+	}
+
+	p = malloc(strlen(name) + 1);
+	strcpy(p, name);
+	library[libraryp] = p;
+	p = malloc(strlen(obj) + 1);
+	strcpy(p, obj);
+	libraryobj[libraryp] = p;
+	libraryp++;
+}
+
+void
+addhist(long line, int type)
+{
+	Auto *u;
+	Sym *s;
+	int i, j, k;
+
+	u = malloc(sizeof(Auto));
+	s = malloc(sizeof(Sym));
+	s->name = malloc(2*(histfrogp+1) + 1);
+
+	u->asym = s;
+	u->type = type;
+	u->aoffset = line;
+	u->link = curhist;
+	curhist = u;
+
+	j = 1;
+	for(i=0; i<histfrogp; i++) {
+		k = histfrog[i]->value;
+		s->name[j+0] = k>>8;
+		s->name[j+1] = k;
+		j += 2;
+	}
+}
+
+void
+histtoauto(void)
+{
+	Auto *l;
+
+	while(l = curhist) {
+		curhist = l->link;
+		l->link = curauto;
+		curauto = l;
+	}
+}
+
+void
+collapsefrog(Sym *s)
+{
+	int i;
+
+	/*
+	 * bad encoding of path components only allows
+	 * MAXHIST components. if there is an overflow,
+	 * first try to collapse xxx/..
+	 */
+	for(i=1; i<histfrogp; i++)
+		if(strcmp(histfrog[i]->name+1, "..") == 0) {
+			memmove(histfrog+i-1, histfrog+i+1,
+				(histfrogp-i-1)*sizeof(histfrog[0]));
+			histfrogp--;
+			goto out;
+		}
+
+	/*
+	 * next try to collapse .
+	 */
+	for(i=0; i<histfrogp; i++)
+		if(strcmp(histfrog[i]->name+1, ".") == 0) {
+			memmove(histfrog+i, histfrog+i+1,
+				(histfrogp-i-1)*sizeof(histfrog[0]));
+			goto out;
+		}
+
+	/*
+	 * last chance, just truncate from front
+	 */
+	memmove(histfrog+0, histfrog+1,
+		(histfrogp-1)*sizeof(histfrog[0]));
+
+out:
+	histfrog[histfrogp-1] = s;
+}
+
+void
+nopout(Prog *p)
+{
+	p->as = ANOP;
+	p->from.type = D_NONE;
+	p->to.type = D_NONE;
+}
+
+uchar*
+readsome(int f, uchar *buf, uchar *good, uchar *stop, int max)
+{
+	int n;
+
+	n = stop - good;
+	memmove(buf, good, stop - good);
+	stop = buf + n;
+	n = MAXIO - n;
+	if(n > max)
+		n = max;
+	n = read(f, stop, n);
+	if(n <= 0)
+		return 0;
+	return stop + n;
+}
+
+static void puntfp(Prog *);
+
+void
+ldobj(int f, long c, char *pn)
+{
+	long ipc;
+	Prog *p, *t;
+	uchar *bloc, *bsize, *stop;
+	Sym *h[NSYM], *s, *di;
+	int v, o, r, skip;
+	ulong sig;
+	static int files;
+	static char **filen;
+	char **nfilen;
+
+	if((files&15) == 0){
+		nfilen = malloc((files+16)*sizeof(char*));
+		memmove(nfilen, filen, files*sizeof(char*));
+		free(filen);
+		filen = nfilen;
+	}
+	filen[files++] = strdup(pn);
+
+	bsize = buf.xbuf;
+	bloc = buf.xbuf;
+	di = S;
+
+newloop:
+	memset(h, 0, sizeof(h));
+	version++;
+	histfrogp = 0;
+	ipc = pc;
+	skip = 0;
+
+loop:
+	if(c <= 0)
+		goto eof;
+	r = bsize - bloc;
+	if(r < 100 && r < c) {		/* enough for largest prog */
+		bsize = readsome(f, buf.xbuf, bloc, bsize, c);
+		if(bsize == 0)
+			goto eof;
+		bloc = buf.xbuf;
+		goto loop;
+	}
+	o = bloc[0];		/* as */
+	if(o <= AXXX || o >= ALAST) {
+		diag("%s: line %ld: opcode out of range %d", pn, pc-ipc, o);
+		print("	probably not a .5 file\n");
+		errorexit();
+	}
+	if(o == ANAME || o == ASIGNAME) {
+		sig = 0;
+		if(o == ASIGNAME){
+			sig = bloc[1] | (bloc[2]<<8) | (bloc[3]<<16) | (bloc[4]<<24);
+			bloc += 4;
+			c -= 4;
+		}
+		stop = memchr(&bloc[3], 0, bsize-&bloc[3]);
+		if(stop == 0){
+			bsize = readsome(f, buf.xbuf, bloc, bsize, c);
+			if(bsize == 0)
+				goto eof;
+			bloc = buf.xbuf;
+			stop = memchr(&bloc[3], 0, bsize-&bloc[3]);
+			if(stop == 0){
+				fprint(2, "%s: name too long\n", pn);
+				errorexit();
+			}
+		}
+		v = bloc[1];	/* type */
+		o = bloc[2];	/* sym */
+		bloc += 3;
+		c -= 3;
+
+		r = 0;
+		if(v == D_STATIC)
+			r = version;
+		s = lookup((char*)bloc, r);
+		c -= &stop[1] - bloc;
+		bloc = stop + 1;
+
+		if(sig != 0){
+			if(s->sig != 0 && s->sig != sig)
+				diag("incompatible type signatures %lux(%s) and %lux(%s) for %s", s->sig, filen[s->file], sig, pn, s->name);
+			s->sig = sig;
+			s->file = files-1;
+		}
+
+		if(debug['W'])
+			print("	ANAME	%s\n", s->name);
+		h[o] = s;
+		if((v == D_EXTERN || v == D_STATIC) && s->type == 0)
+			s->type = SXREF;
+		if(v == D_FILE) {
+			if(s->type != SFILE) {
+				histgen++;
+				s->type = SFILE;
+				s->value = histgen;
+			}
+			if(histfrogp < MAXHIST) {
+				histfrog[histfrogp] = s;
+				histfrogp++;
+			} else
+				collapsefrog(s);
+		}
+		goto loop;
+	}
+
+	if(nhunk < sizeof(Prog))
+		gethunk();
+	p = (Prog*)hunk;
+	nhunk -= sizeof(Prog);
+	hunk += sizeof(Prog);
+
+	p->as = o;
+	p->scond = bloc[1];
+	p->reg = bloc[2];
+	p->line = bloc[3] | (bloc[4]<<8) | (bloc[5]<<16) | (bloc[6]<<24);
+
+	r = zaddr(bloc+7, &p->from, h) + 7;
+	r += zaddr(bloc+r, &p->to, h);
+	bloc += r;
+	c -= r;
+
+	if(p->reg < 0 || p->reg > NREG)
+		diag("register out of range %d", p->reg);
+
+	p->link = P;
+	p->cond = P;
+
+	if(debug['W'])
+		print("%P\n", p);
+
+	switch(o) {
+	case AHISTORY:
+		if(p->to.offset == -1) {
+			addlib(pn);
+			histfrogp = 0;
+			goto loop;
+		}
+		addhist(p->line, D_FILE);		/* 'z' */
+		if(p->to.offset)
+			addhist(p->to.offset, D_FILE1);	/* 'Z' */
+		histfrogp = 0;
+		goto loop;
+
+	case AEND:
+		histtoauto();
+		if(curtext != P)
+			curtext->to.autom = curauto;
+		curauto = 0;
+		curtext = P;
+		if(c)
+			goto newloop;
+		return;
+
+	case AGLOBL:
+		s = p->from.sym;
+		if(s == S) {
+			diag("GLOBL must have a name\n%P", p);
+			errorexit();
+		}
+		if(s->type == 0 || s->type == SXREF) {
+			s->type = SBSS;
+			s->value = 0;
+		}
+		if(s->type != SBSS) {
+			diag("redefinition: %s\n%P", s->name, p);
+			s->type = SBSS;
+			s->value = 0;
+		}
+		if(p->to.offset > s->value)
+			s->value = p->to.offset;
+		break;
+
+	case ADYNT:
+		if(p->to.sym == S) {
+			diag("DYNT without a sym\n%P", p);
+			break;
+		}
+		di = p->to.sym;
+		p->reg = 4;
+		if(di->type == SXREF) {
+			if(debug['z'])
+				Bprint(&bso, "%P set to %d\n", p, dtype);
+			di->type = SCONST;
+			di->value = dtype;
+			dtype += 4;
+		}
+		if(p->from.sym == S)
+			break;
+
+		p->from.offset = di->value;
+		p->from.sym->type = SDATA;
+		if(curtext == P) {
+			diag("DYNT not in text: %P", p);
+			break;
+		}
+		p->to.sym = curtext->from.sym;
+		p->to.type = D_CONST;
+		p->link = datap;
+		datap = p;
+		break;
+
+	case AINIT:
+		if(p->from.sym == S) {
+			diag("INIT without a sym\n%P", p);
+			break;
+		}
+		if(di == S) {
+			diag("INIT without previous DYNT\n%P", p);
+			break;
+		}
+		p->from.offset = di->value;
+		p->from.sym->type = SDATA;
+		p->link = datap;
+		datap = p;
+		break;
+	
+	case ADATA:
+		if(p->from.sym == S) {
+			diag("DATA without a sym\n%P", p);
+			break;
+		}
+		p->link = datap;
+		datap = p;
+		break;
+
+	case AGOK:
+		diag("unknown opcode\n%P", p);
+		p->pc = pc;
+		pc++;
+		break;
+
+	case ATEXT:
+		setarch(p);
+		setthumb(p);
+		p->align = 4;
+		if(curtext != P) {
+			histtoauto();
+			curtext->to.autom = curauto;
+			curauto = 0;
+		}
+		skip = 0;
+		curtext = p;
+		autosize = (p->to.offset+3L) & ~3L;
+		p->to.offset = autosize;
+		autosize += 4;
+		s = p->from.sym;
+		if(s == S) {
+			diag("TEXT must have a name\n%P", p);
+			errorexit();
+		}
+		if(s->type != 0 && s->type != SXREF) {
+			if(p->reg & DUPOK) {
+				skip = 1;
+				goto casedef;
+			}
+			diag("redefinition: %s\n%P", s->name, p);
+		}
+		s->type = STEXT;
+		s->value = pc;
+		s->thumb = thumb;
+		lastp->link = p;
+		lastp = p;
+		p->pc = pc;
+		pc++;
+		if(textp == P) {
+			textp = p;
+			etextp = p;
+			goto loop;
+		}
+		etextp->cond = p;
+		etextp = p;
+		break;
+
+	case ASUB:
+		if(p->from.type == D_CONST)
+		if(p->from.name == D_NONE)
+		if(p->from.offset < 0) {
+			p->from.offset = -p->from.offset;
+			p->as = AADD;
+		}
+		goto casedef;
+
+	case AADD:
+		if(p->from.type == D_CONST)
+		if(p->from.name == D_NONE)
+		if(p->from.offset < 0) {
+			p->from.offset = -p->from.offset;
+			p->as = ASUB;
+		}
+		goto casedef;
+
+	case AMOVWD:
+	case AMOVWF:
+	case AMOVDW:
+	case AMOVFW:
+	case AMOVFD:
+	case AMOVDF:
+	// case AMOVF:
+	// case AMOVD:
+	case ACMPF:
+	case ACMPD:
+	case AADDF:
+	case AADDD:
+	case ASUBF:
+	case ASUBD:
+	case AMULF:
+	case AMULD:
+	case ADIVF:
+	case ADIVD:
+		if(thumb)
+			puntfp(p);
+		goto casedef;
+
+	case AMOVF:
+		if(thumb)
+			puntfp(p);
+		if(skip)
+			goto casedef;
+
+		if(p->from.type == D_FCONST && chipfloat(p->from.ieee) < 0) {
+			/* size sb 9 max */
+			sprint(literal, "$%lux", ieeedtof(p->from.ieee));
+			s = lookup(literal, 0);
+			if(s->type == 0) {
+				s->type = SBSS;
+				s->value = 4;
+				t = prg();
+				t->as = ADATA;
+				t->line = p->line;
+				t->from.type = D_OREG;
+				t->from.sym = s;
+				t->from.name = D_EXTERN;
+				t->reg = 4;
+				t->to = p->from;
+				t->link = datap;
+				datap = t;
+			}
+			p->from.type = D_OREG;
+			p->from.sym = s;
+			p->from.name = D_EXTERN;
+			p->from.offset = 0;
+		}
+		goto casedef;
+
+	case AMOVD:
+		if(thumb)
+			puntfp(p);
+		if(skip)
+			goto casedef;
+
+		if(p->from.type == D_FCONST && chipfloat(p->from.ieee) < 0) {
+			/* size sb 18 max */
+			sprint(literal, "$%lux.%lux",
+				p->from.ieee->l, p->from.ieee->h);
+			s = lookup(literal, 0);
+			if(s->type == 0) {
+				s->type = SBSS;
+				s->value = 8;
+				t = prg();
+				t->as = ADATA;
+				t->line = p->line;
+				t->from.type = D_OREG;
+				t->from.sym = s;
+				t->from.name = D_EXTERN;
+				t->reg = 8;
+				t->to = p->from;
+				t->link = datap;
+				datap = t;
+			}
+			p->from.type = D_OREG;
+			p->from.sym = s;
+			p->from.name = D_EXTERN;
+			p->from.offset = 0;
+		}
+		goto casedef;
+
+	default:
+	casedef:
+		if(skip)
+			nopout(p);
+
+		if(p->to.type == D_BRANCH)
+			p->to.offset += ipc;
+		lastp->link = p;
+		lastp = p;
+		p->pc = pc;
+		pc++;
+		break;
+	}
+	goto loop;
+
+eof:
+	diag("truncated object file: %s", pn);
+}
+
+Sym*
+lookup(char *symb, int v)
+{
+	Sym *s;
+	char *p;
+	long h;
+	int c, l;
+
+	h = v;
+	for(p=symb; c = *p; p++)
+		h = h+h+h + c;
+	l = (p - symb) + 1;
+	if(h < 0)
+		h = ~h;
+	h %= NHASH;
+	for(s = hash[h]; s != S; s = s->link)
+		if(s->version == v)
+		if(memcmp(s->name, symb, l) == 0)
+			return s;
+
+	while(nhunk < sizeof(Sym))
+		gethunk();
+	s = (Sym*)hunk;
+	nhunk -= sizeof(Sym);
+	hunk += sizeof(Sym);
+
+	s->name = malloc(l);
+	memmove(s->name, symb, l);
+
+	s->link = hash[h];
+	s->type = 0;
+	s->version = v;
+	s->value = 0;
+	s->sig = 0;
+	s->used = s->thumb = s->foreign = s->fnptr = 0;
+	s->use = nil;
+	hash[h] = s;
+	return s;
+}
+
+Prog*
+prg(void)
+{
+	Prog *p;
+
+	while(nhunk < sizeof(Prog))
+		gethunk();
+	p = (Prog*)hunk;
+	nhunk -= sizeof(Prog);
+	hunk += sizeof(Prog);
+
+	*p = zprg;
+	return p;
+}
+
+void
+gethunk(void)
+{
+	char *h;
+	long nh;
+
+	nh = NHUNK;
+	if(thunk >= 5L*NHUNK) {
+		nh = 5L*NHUNK;
+		if(thunk >= 25L*NHUNK)
+			nh = 25L*NHUNK;
+	}
+	h = mysbrk(nh);
+	if(h == (char*)-1) {
+		diag("out of memory");
+		errorexit();
+	}
+	hunk = h;
+	nhunk = nh;
+	thunk += nh;
+}
+
+void
+doprof1(void)
+{
+	Sym *s;
+	long n;
+	Prog *p, *q;
+
+	if(debug['v'])
+		Bprint(&bso, "%5.2f profile 1\n", cputime());
+	Bflush(&bso);
+	s = lookup("__mcount", 0);
+	n = 1;
+	for(p = firstp->link; p != P; p = p->link) {
+		setarch(p);
+		if(p->as == ATEXT) {
+			q = prg();
+			q->line = p->line;
+			q->link = datap;
+			datap = q;
+			q->as = ADATA;
+			q->from.type = D_OREG;
+			q->from.name = D_EXTERN;
+			q->from.offset = n*4;
+			q->from.sym = s;
+			q->reg = 4;
+			q->to = p->from;
+			q->to.type = D_CONST;
+
+			q = prg();
+			q->line = p->line;
+			q->pc = p->pc;
+			q->link = p->link;
+			p->link = q;
+			p = q;
+			p->as = AMOVW;
+			p->from.type = D_OREG;
+			p->from.name = D_EXTERN;
+			p->from.sym = s;
+			p->from.offset = n*4 + 4;
+			p->to.type = D_REG;
+			p->to.reg = thumb ? REGTMPT : REGTMP;
+
+			q = prg();
+			q->line = p->line;
+			q->pc = p->pc;
+			q->link = p->link;
+			p->link = q;
+			p = q;
+			p->as = AADD;
+			p->from.type = D_CONST;
+			p->from.offset = 1;
+			p->to.type = D_REG;
+			p->to.reg = thumb ? REGTMPT : REGTMP;
+
+			q = prg();
+			q->line = p->line;
+			q->pc = p->pc;
+			q->link = p->link;
+			p->link = q;
+			p = q;
+			p->as = AMOVW;
+			p->from.type = D_REG;
+			p->from.reg = thumb ? REGTMPT : REGTMP;
+			p->to.type = D_OREG;
+			p->to.name = D_EXTERN;
+			p->to.sym = s;
+			p->to.offset = n*4 + 4;
+
+			n += 2;
+			continue;
+		}
+	}
+	q = prg();
+	q->line = 0;
+	q->link = datap;
+	datap = q;
+
+	q->as = ADATA;
+	q->from.type = D_OREG;
+	q->from.name = D_EXTERN;
+	q->from.sym = s;
+	q->reg = 4;
+	q->to.type = D_CONST;
+	q->to.offset = n;
+
+	s->type = SBSS;
+	s->value = n*4;
+}
+
+void
+doprof2(void)
+{
+	Sym *s2, *s4;
+	Prog *p, *q, *ps2, *ps4;
+
+	if(debug['v'])
+		Bprint(&bso, "%5.2f profile 2\n", cputime());
+	Bflush(&bso);
+	s2 = lookup("_profin", 0);
+	s4 = lookup("_profout", 0);
+	if(s2->type != STEXT || s4->type != STEXT) {
+		diag("_profin/_profout not defined");
+		return;
+	}
+	ps2 = P;
+	ps4 = P;
+	for(p = firstp; p != P; p = p->link) {
+		setarch(p);
+		if(p->as == ATEXT) {
+			if(p->from.sym == s2) {
+				ps2 = p;
+				p->reg = 1;
+			}
+			if(p->from.sym == s4) {
+				ps4 = p;
+				p->reg = 1;
+			}
+		}
+	}
+	for(p = firstp; p != P; p = p->link) {
+		setarch(p);
+		if(p->as == ATEXT) {
+			if(p->reg & NOPROF) {
+				for(;;) {
+					q = p->link;
+					if(q == P)
+						break;
+					if(q->as == ATEXT)
+						break;
+					p = q;
+				}
+				continue;
+			}
+
+			/*
+			 * BL	profin, R2
+			 */
+			q = prg();
+			q->line = p->line;
+			q->pc = p->pc;
+			q->link = p->link;
+			p->link = q;
+			p = q;
+			p->as = ABL;
+			p->to.type = D_BRANCH;
+			p->cond = ps2;
+			p->to.sym = s2;
+
+			continue;
+		}
+		if(p->as == ARET) {
+			/*
+			 * RET
+			 */
+			q = prg();
+			q->as = ARET;
+			q->from = p->from;
+			q->to = p->to;
+			q->link = p->link;
+			p->link = q;
+
+			/*
+			 * BL	profout
+			 */
+			p->as = ABL;
+			p->from = zprg.from;
+			p->to = zprg.to;
+			p->to.type = D_BRANCH;
+			p->cond = ps4;
+			p->to.sym = s4;
+
+			p = q;
+
+			continue;
+		}
+	}
+}
+
+void
+nuxiinit(void)
+{
+
+	int i, c;
+
+	for(i=0; i<4; i++) {
+		c = find1(0x04030201L, i+1);
+		if(i < 2)
+			inuxi2[i] = c;
+		if(i < 1)
+			inuxi1[i] = c;
+		inuxi4[i] = c;
+		fnuxi4[i] = c;
+		if(debug['d']){
+			fnuxi8[i] = c;
+			fnuxi8[i+4] = c+4;
+		}
+		else{
+			fnuxi8[i] = c+4;		/* ms word first, then ls, even in little endian mode */
+			fnuxi8[i+4] = c;
+		}
+	}
+	if(debug['v']) {
+		Bprint(&bso, "inuxi = ");
+		for(i=0; i<1; i++)
+			Bprint(&bso, "%d", inuxi1[i]);
+		Bprint(&bso, " ");
+		for(i=0; i<2; i++)
+			Bprint(&bso, "%d", inuxi2[i]);
+		Bprint(&bso, " ");
+		for(i=0; i<4; i++)
+			Bprint(&bso, "%d", inuxi4[i]);
+		Bprint(&bso, "\nfnuxi = ");
+		for(i=0; i<4; i++)
+			Bprint(&bso, "%d", fnuxi4[i]);
+		Bprint(&bso, " ");
+		for(i=0; i<8; i++)
+			Bprint(&bso, "%d", fnuxi8[i]);
+		Bprint(&bso, "\n");
+	}
+	Bflush(&bso);
+}
+
+int
+find1(long l, int c)
+{
+	char *p;
+	int i;
+
+	p = (char*)&l;
+	for(i=0; i<4; i++)
+		if(*p++ == c)
+			return i;
+	return 0;
+}
+
+long
+ieeedtof(Ieee *ieeep)
+{
+	int exp;
+	long v;
+
+	if(ieeep->h == 0)
+		return 0;
+	exp = (ieeep->h>>20) & ((1L<<11)-1L);
+	exp -= (1L<<10) - 2L;
+	v = (ieeep->h & 0xfffffL) << 3;
+	v |= (ieeep->l >> 29) & 0x7L;
+	if((ieeep->l >> 28) & 1) {
+		v++;
+		if(v & 0x800000L) {
+			v = (v & 0x7fffffL) >> 1;
+			exp++;
+		}
+	}
+	if(exp <= -126 || exp >= 130)
+		diag("double fp to single fp overflow");
+	v |= ((exp + 126) & 0xffL) << 23;
+	v |= ieeep->h & 0x80000000L;
+	return v;
+}
+
+double
+ieeedtod(Ieee *ieeep)
+{
+	Ieee e;
+	double fr;
+	int exp;
+
+	if(ieeep->h & (1L<<31)) {
+		e.h = ieeep->h & ~(1L<<31);
+		e.l = ieeep->l;
+		return -ieeedtod(&e);
+	}
+	if(ieeep->l == 0 && ieeep->h == 0)
+		return 0;
+	fr = ieeep->l & ((1L<<16)-1L);
+	fr /= 1L<<16;
+	fr += (ieeep->l>>16) & ((1L<<16)-1L);
+	fr /= 1L<<16;
+	fr += (ieeep->h & (1L<<20)-1L) | (1L<<20);
+	fr /= 1L<<21;
+	exp = (ieeep->h>>20) & ((1L<<11)-1L);
+	exp -= (1L<<10) - 2L;
+	return ldexp(fr, exp);
+}
+
+static void
+puntfp(Prog *p)
+{
+	USED(p);
+	/* floating point - punt for now */
+	curtext->reg = NREG;	/* ARM */
+	curtext->from.sym->thumb = 0;
+	thumb = 0;
+	// print("%s: generating ARM code (contains floating point ops %d)\n", curtext->from.sym->name, p->line);
+}
+
+void
+undefsym(Sym *s)
+{
+	int n;
+
+	n = imports;
+	if(s->value != 0)
+		diag("value != 0 on SXREF");
+	if(n >= 1<<Rindex)
+		diag("import index %d out of range", n);
+	s->value = n<<Roffset;
+	s->type = SUNDEF;
+	imports++;
+}
+
+void
+zerosig(char *sp)
+{
+	Sym *s;
+
+	s = lookup(sp, 0);
+	s->sig = 0;
+}
+
+void
+readundefs(char *f, int t)
+{
+	int i, n;
+	Sym *s;
+	Biobuf *b;
+	char *l, buf[256], *fields[64];
+
+	if(f == nil)
+		return;
+	b = Bopen(f, OREAD);
+	if(b == nil){
+		diag("could not open %s: %r", f);
+		errorexit();
+	}
+	while((l = Brdline(b, '\n')) != nil){
+		n = Blinelen(b);
+		if(n >= sizeof(buf)){
+			diag("%s: line too long", f);
+			errorexit();
+		}
+		memmove(buf, l, n);
+		buf[n-1] = '\0';
+		n = getfields(buf, fields, nelem(fields), 1, " \t\r\n");
+		if(n == nelem(fields)){
+			diag("%s: bad format", f);
+			errorexit();
+		}
+		for(i = 0; i < n; i++){
+			s = lookup(fields[i], 0);
+			s->type = SXREF;
+			s->subtype = t;
+			if(t == SIMPORT)
+				nimports++;
+			else
+				nexports++;
+		}
+	}
+	Bterm(b);
+}
diff --git a/src/cmd/5l/optab.c b/src/cmd/5l/optab.c
new file mode 100644
index 0000000000..ff757ee669
--- /dev/null
+++ b/src/cmd/5l/optab.c
@@ -0,0 +1,283 @@
+// Inferno utils/5l/optab.c
+// http://code.google.com/p/inferno-os/source/browse/utils/5l/optab.c
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#include	"l.h"
+
+Optab	optab[] =
+{
+	{ ATEXT,	C_LEXT,	C_NONE,	C_LCON, 	 0, 0, 0 },
+	{ ATEXT,	C_LEXT,	C_REG,	C_LCON, 	 0, 0, 0 },
+	{ ATEXT,	C_ADDR,	C_NONE,	C_LCON, 	 0, 0, 0 },
+	{ ATEXT,	C_ADDR,	C_REG,	C_LCON, 	 0, 0, 0 },
+
+	{ AADD,		C_REG,	C_REG,	C_REG,		 1, 4, 0 },
+	{ AADD,		C_REG,	C_NONE,	C_REG,		 1, 4, 0 },
+	{ AMOVW,	C_REG,	C_NONE,	C_REG,		 1, 4, 0 },
+	{ AMVN,		C_REG,	C_NONE,	C_REG,		 1, 4, 0 },
+	{ ACMP,		C_REG,	C_REG,	C_NONE,		 1, 4, 0 },
+
+	{ AADD,		C_RCON,	C_REG,	C_REG,		 2, 4, 0 },
+	{ AADD,		C_RCON,	C_NONE,	C_REG,		 2, 4, 0 },
+	{ AMOVW,	C_RCON,	C_NONE,	C_REG,		 2, 4, 0 },
+	{ AMVN,		C_RCON,	C_NONE,	C_REG,		 2, 4, 0 },
+	{ ACMP,		C_RCON,	C_REG,	C_NONE,		 2, 4, 0 },
+
+	{ AADD,		C_SHIFT,C_REG,	C_REG,		 3, 4, 0 },
+	{ AADD,		C_SHIFT,C_NONE,	C_REG,		 3, 4, 0 },
+	{ AMVN,		C_SHIFT,C_NONE,	C_REG,		 3, 4, 0 },
+	{ ACMP,		C_SHIFT,C_REG,	C_NONE,		 3, 4, 0 },
+
+	{ AMOVW,	C_RECON,C_NONE,	C_REG,		 4, 4, REGSB },
+	{ AMOVW,	C_RACON,C_NONE,	C_REG,		 4, 4, REGSP },
+
+	{ AB,		C_NONE,	C_NONE,	C_SBRA,		 5, 4, 0,	LPOOL },
+	{ ABL,		C_NONE,	C_NONE,	C_SBRA,		 5, 4, 0 },
+	{ ABX,		C_NONE,	C_NONE,	C_SBRA,		 74, 20, 0 },
+	{ ABEQ,		C_NONE,	C_NONE,	C_SBRA,		 5, 4, 0 },
+
+	{ AB,		C_NONE,	C_NONE,	C_ROREG,	 6, 4, 0,	LPOOL },
+	{ ABL,		C_NONE,	C_NONE,	C_ROREG,	 7, 8, 0 },
+	{ ABX,		C_NONE,	C_NONE,	C_ROREG,	 75, 12, 0 },
+	{ ABXRET,		C_NONE,	C_NONE,	C_ROREG,	 76, 4, 0 },
+
+	{ ASLL,		C_RCON,	C_REG,	C_REG,		 8, 4, 0 },
+	{ ASLL,		C_RCON,	C_NONE,	C_REG,		 8, 4, 0 },
+
+	{ ASLL,		C_REG,	C_NONE,	C_REG,		 9, 4, 0 },
+	{ ASLL,		C_REG,	C_REG,	C_REG,		 9, 4, 0 },
+
+	{ ASWI,		C_NONE,	C_NONE,	C_NONE,		10, 4, 0 },
+	{ ASWI,		C_NONE,	C_NONE,	C_LOREG,	10, 4, 0 },
+
+	{ AWORD,	C_NONE,	C_NONE,	C_LCON,		11, 4, 0 },
+	{ AWORD,	C_NONE,	C_NONE,	C_GCON,		11, 4, 0 },
+	{ AWORD,	C_NONE,	C_NONE,	C_LEXT,		11, 4, 0 },
+	{ AWORD,	C_NONE,	C_NONE,	C_ADDR,		11, 4, 0 },
+
+	{ AMOVW,	C_NCON,	C_NONE,	C_REG,		12, 4, 0 },
+	{ AMOVW,	C_LCON,	C_NONE,	C_REG,		12, 4, 0,	LFROM },
+
+	{ AADD,		C_NCON,	C_REG,	C_REG,		13, 8, 0 },
+	{ AADD,		C_NCON,	C_NONE,	C_REG,		13, 8, 0 },
+	{ AMVN,		C_NCON,	C_NONE,	C_REG,		13, 8, 0 },
+	{ ACMP,		C_NCON,	C_REG,	C_NONE,		13, 8, 0 },
+	{ AADD,		C_LCON,	C_REG,	C_REG,		13, 8, 0,	LFROM },
+	{ AADD,		C_LCON,	C_NONE,	C_REG,		13, 8, 0,	LFROM },
+	{ AMVN,		C_LCON,	C_NONE,	C_REG,		13, 8, 0,	LFROM },
+	{ ACMP,		C_LCON,	C_REG,	C_NONE,		13, 8, 0,	LFROM },
+
+	{ AMOVB,	C_REG,	C_NONE,	C_REG,		14, 8, 0 },
+	{ AMOVBU,	C_REG,	C_NONE,	C_REG,		58, 4, 0 },
+	{ AMOVH,	C_REG,	C_NONE,	C_REG,		14, 8, 0 },
+	{ AMOVHU,	C_REG,	C_NONE,	C_REG,		14, 8, 0 },
+
+	{ AMUL,		C_REG,	C_REG,	C_REG,		15, 4, 0 },
+	{ AMUL,		C_REG,	C_NONE,	C_REG,		15, 4, 0 },
+
+	{ ADIV,		C_REG,	C_REG,	C_REG,		16, 4, 0 },
+	{ ADIV,		C_REG,	C_NONE,	C_REG,		16, 4, 0 },
+
+	{ AMULL,	C_REG,	C_REG,	C_REGREG,	17, 4, 0 },
+
+	{ AMOVW,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
+	{ AMOVW,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
+	{ AMOVW,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },
+	{ AMOVB,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
+	{ AMOVB,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
+	{ AMOVB,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },
+	{ AMOVBU,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
+	{ AMOVBU,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
+	{ AMOVBU,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },
+
+	{ AMOVW,	C_SEXT,	C_NONE,	C_REG,		21, 4, REGSB },
+	{ AMOVW,	C_SAUTO,C_NONE,	C_REG,		21, 4, REGSP },
+	{ AMOVW,	C_SOREG,C_NONE,	C_REG,		21, 4, 0 },
+	{ AMOVBU,	C_SEXT,	C_NONE,	C_REG,		21, 4, REGSB },
+	{ AMOVBU,	C_SAUTO,C_NONE,	C_REG,		21, 4, REGSP },
+	{ AMOVBU,	C_SOREG,C_NONE,	C_REG,		21, 4, 0 },
+
+	{ AMOVB,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
+	{ AMOVB,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
+	{ AMOVB,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },
+	{ AMOVH,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
+	{ AMOVH,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
+	{ AMOVH,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },
+	{ AMOVHU,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
+	{ AMOVHU,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
+	{ AMOVHU,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },
+
+	{ AMOVH,	C_REG,	C_NONE,	C_SEXT,		23, 12, REGSB },
+	{ AMOVH,	C_REG,	C_NONE,	C_SAUTO,	23, 12, REGSP },
+	{ AMOVH,	C_REG,	C_NONE,	C_SOREG,	23, 12, 0 },
+	{ AMOVHU,	C_REG,	C_NONE,	C_SEXT,		23, 12, REGSB },
+	{ AMOVHU,	C_REG,	C_NONE,	C_SAUTO,	23, 12, REGSP },
+	{ AMOVHU,	C_REG,	C_NONE,	C_SOREG,	23, 12, 0 },
+
+	{ AMOVW,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
+	{ AMOVW,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
+	{ AMOVW,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
+	{ AMOVW,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },
+	{ AMOVB,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
+	{ AMOVB,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
+	{ AMOVB,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
+	{ AMOVB,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },
+	{ AMOVBU,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
+	{ AMOVBU,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
+	{ AMOVBU,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
+	{ AMOVBU,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },
+
+	{ AMOVW,	C_LEXT,	C_NONE,	C_REG,		31, 8, REGSB,	LFROM },
+	{ AMOVW,	C_LAUTO,C_NONE,	C_REG,		31, 8, REGSP,	LFROM },
+	{ AMOVW,	C_LOREG,C_NONE,	C_REG,		31, 8, 0,	LFROM },
+	{ AMOVW,	C_ADDR,	C_NONE,	C_REG,		65, 8, 0,	LFROM },
+	{ AMOVBU,	C_LEXT,	C_NONE,	C_REG,		31, 8, REGSB,	LFROM },
+	{ AMOVBU,	C_LAUTO,C_NONE,	C_REG,		31, 8, REGSP,	LFROM },
+	{ AMOVBU,	C_LOREG,C_NONE,	C_REG,		31, 8, 0,	LFROM },
+	{ AMOVBU,	C_ADDR,	C_NONE,	C_REG,		65, 8, 0,	LFROM },
+
+	{ AMOVB,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
+	{ AMOVB,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
+	{ AMOVB,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },
+	{ AMOVB,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },
+	{ AMOVH,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
+	{ AMOVH,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
+	{ AMOVH,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },
+	{ AMOVH,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },
+	{ AMOVHU,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
+	{ AMOVHU,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
+	{ AMOVHU,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },
+	{ AMOVHU,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },
+
+	{ AMOVH,	C_REG,	C_NONE,	C_LEXT,		33, 24, REGSB,	LTO },
+	{ AMOVH,	C_REG,	C_NONE,	C_LAUTO,	33, 24, REGSP,	LTO },
+	{ AMOVH,	C_REG,	C_NONE,	C_LOREG,	33, 24, 0,	LTO },
+	{ AMOVH,	C_REG,	C_NONE,	C_ADDR,		67, 24, 0,	LTO },
+	{ AMOVHU,	C_REG,	C_NONE,	C_LEXT,		33, 24, REGSB,	LTO },
+	{ AMOVHU,	C_REG,	C_NONE,	C_LAUTO,	33, 24, REGSP,	LTO },
+	{ AMOVHU,	C_REG,	C_NONE,	C_LOREG,	33, 24, 0,	LTO },
+	{ AMOVHU,	C_REG,	C_NONE,	C_ADDR,		67, 24, 0,	LTO },
+
+	{ AMOVW,	C_LECON,C_NONE,	C_REG,		34, 8, REGSB,	LFROM },
+	{ AMOVW,	C_LACON,C_NONE,	C_REG,		34, 8, REGSP,	LFROM },
+
+	{ AMOVW,	C_PSR,	C_NONE,	C_REG,		35, 4, 0 },
+	{ AMOVW,	C_REG,	C_NONE,	C_PSR,		36, 4, 0 },
+	{ AMOVW,	C_RCON,	C_NONE,	C_PSR,		37, 4, 0 },
+
+	{ AMOVM,	C_LCON,	C_NONE,	C_SOREG,	38, 4, 0 },
+	{ AMOVM,	C_SOREG,C_NONE,	C_LCON,		39, 4, 0 },
+
+	{ ASWPW,	C_SOREG,C_REG,	C_REG,		40, 4, 0 },
+
+	{ ARFE,		C_NONE,	C_NONE,	C_NONE,		41, 4, 0 },
+
+	{ AMOVF,	C_FREG,	C_NONE,	C_FEXT,		50, 4, REGSB },
+	{ AMOVF,	C_FREG,	C_NONE,	C_FAUTO,	50, 4, REGSP },
+	{ AMOVF,	C_FREG,	C_NONE,	C_FOREG,	50, 4, 0 },
+
+	{ AMOVF,	C_FEXT,	C_NONE,	C_FREG,		51, 4, REGSB },
+	{ AMOVF,	C_FAUTO,C_NONE,	C_FREG,		51, 4, REGSP },
+	{ AMOVF,	C_FOREG,C_NONE,	C_FREG,		51, 4, 0 },
+
+	{ AMOVF,	C_FREG,	C_NONE,	C_LEXT,		52, 12, REGSB,	LTO },
+	{ AMOVF,	C_FREG,	C_NONE,	C_LAUTO,	52, 12, REGSP,	LTO },
+	{ AMOVF,	C_FREG,	C_NONE,	C_LOREG,	52, 12, 0,	LTO },
+
+	{ AMOVF,	C_LEXT,	C_NONE,	C_FREG,		53, 12, REGSB,	LFROM },
+	{ AMOVF,	C_LAUTO,C_NONE,	C_FREG,		53, 12, REGSP,	LFROM },
+	{ AMOVF,	C_LOREG,C_NONE,	C_FREG,		53, 12, 0,	LFROM },
+
+	{ AMOVF,	C_FREG,	C_NONE,	C_ADDR,		68, 8, 0,	LTO },
+	{ AMOVF,	C_ADDR,	C_NONE,	C_FREG,		69, 8, 0,	LFROM },
+
+	{ AADDF,	C_FREG,	C_NONE,	C_FREG,		54, 4, 0 },
+	{ AADDF,	C_FREG,	C_REG,	C_FREG,		54, 4, 0 },
+	{ AADDF,	C_FCON,	C_NONE,	C_FREG,		54, 4, 0 },
+	{ AADDF,	C_FCON,	C_REG,	C_FREG,		54, 4, 0 },
+	{ AMOVF,	C_FCON,	C_NONE,	C_FREG,		54, 4, 0 },
+	{ AMOVF,	C_FREG, C_NONE, C_FREG,		54, 4, 0 },
+
+	{ ACMPF,	C_FREG,	C_REG,	C_NONE,		54, 4, 0 },
+	{ ACMPF,	C_FCON,	C_REG,	C_NONE,		54, 4, 0 },
+
+	{ AMOVFW,	C_FREG,	C_NONE,	C_REG,		55, 4, 0 },
+	{ AMOVFW,	C_REG,	C_NONE,	C_FREG,		55, 4, 0 },
+
+	{ AMOVW,	C_REG,	C_NONE,	C_FCR,		56, 4, 0 },
+	{ AMOVW,	C_FCR,	C_NONE,	C_REG,		57, 4, 0 },
+
+	{ AMOVW,	C_SHIFT,C_NONE,	C_REG,		59, 4, 0 },
+	{ AMOVBU,	C_SHIFT,C_NONE,	C_REG,		59, 4, 0 },
+
+	{ AMOVB,	C_SHIFT,C_NONE,	C_REG,		60, 4, 0 },
+
+	{ AMOVW,	C_REG,	C_NONE,	C_SHIFT,	61, 4, 0 },
+	{ AMOVB,	C_REG,	C_NONE,	C_SHIFT,	61, 4, 0 },
+	{ AMOVBU,	C_REG,	C_NONE,	C_SHIFT,	61, 4, 0 },
+
+	{ ACASE,	C_REG,	C_NONE,	C_NONE,		62, 4, 0 },
+	{ ABCASE,	C_NONE, C_NONE, C_SBRA,		63, 4, 0 },
+
+	{ AMOVH,	C_REG,	C_NONE,	C_HEXT,		70, 4, REGSB,	V4 },
+	{ AMOVH,	C_REG,	C_NONE, C_HAUTO,	70, 4, REGSP,	V4 },
+	{ AMOVH,	C_REG,	C_NONE,	C_HOREG,	70, 4, 0,	V4 },
+	{ AMOVHU,	C_REG,	C_NONE,	C_HEXT,		70, 4, REGSB,	V4 },
+	{ AMOVHU,	C_REG,	C_NONE, C_HAUTO,	70, 4, REGSP,	V4 },
+	{ AMOVHU,	C_REG,	C_NONE,	C_HOREG,	70, 4, 0,	V4 },
+
+	{ AMOVB,	C_HEXT,	C_NONE, C_REG,		71, 4, REGSB,	V4 },
+	{ AMOVB,	C_HAUTO,C_NONE,	C_REG,		71, 4, REGSP,	V4 },
+	{ AMOVB,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,	V4 },
+	{ AMOVH,	C_HEXT,	C_NONE,	C_REG,		71, 4, REGSB,	V4 },
+	{ AMOVH,	C_HAUTO,C_NONE, C_REG,		71, 4, REGSP,	V4 },
+	{ AMOVH,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,	V4 },
+	{ AMOVHU,	C_HEXT,	C_NONE,	C_REG,		71, 4, REGSB,	V4 },
+	{ AMOVHU,	C_HAUTO,C_NONE, C_REG,		71, 4, REGSP,	V4 },
+	{ AMOVHU,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,	V4 },
+
+	{ AMOVH,	C_REG,	C_NONE,	C_LEXT,		72, 8, REGSB,	LTO|V4 },
+	{ AMOVH,	C_REG,	C_NONE, C_LAUTO,	72, 8, REGSP,	LTO|V4 },
+	{ AMOVH,	C_REG,	C_NONE,	C_LOREG,	72, 8, 0,	LTO|V4 },
+	{ AMOVHU,	C_REG,	C_NONE,	C_LEXT,		72, 8, REGSB,	LTO|V4 },
+	{ AMOVHU,	C_REG,	C_NONE, C_LAUTO,	72, 8, REGSP,	LTO|V4 },
+	{ AMOVHU,	C_REG,	C_NONE,	C_LOREG,	72, 8, 0,	LTO|V4 },
+
+	{ AMOVB,	C_LEXT,	C_NONE, C_REG,		73, 8, REGSB,	LFROM|V4 },
+	{ AMOVB,	C_LAUTO,C_NONE,	C_REG,		73, 8, REGSP,	LFROM|V4 },
+	{ AMOVB,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,	LFROM|V4 },
+	{ AMOVH,	C_LEXT,	C_NONE,	C_REG,		73, 8, REGSB,	LFROM|V4 },
+	{ AMOVH,	C_LAUTO,C_NONE, C_REG,		73, 8, REGSP,	LFROM|V4 },
+	{ AMOVH,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,	LFROM|V4 },
+	{ AMOVHU,	C_LEXT,	C_NONE,	C_REG,		73, 8, REGSB,	LFROM|V4 },
+	{ AMOVHU,	C_LAUTO,C_NONE, C_REG,		73, 8, REGSP,	LFROM|V4 },
+	{ AMOVHU,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,	LFROM|V4 },
+
+	{ AXXX,		C_NONE,	C_NONE,	C_NONE,		 0, 4, 0 },
+};
diff --git a/src/cmd/5l/pass.c b/src/cmd/5l/pass.c
new file mode 100644
index 0000000000..7d08e5c15c
--- /dev/null
+++ b/src/cmd/5l/pass.c
@@ -0,0 +1,972 @@
+// Inferno utils/5l/pass.c
+// http://code.google.com/p/inferno-os/source/browse/utils/5l/pass.c
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#include	"l.h"
+
+void
+dodata(void)
+{
+	int i, t;
+	Sym *s;
+	Prog *p;
+	long orig, v;
+
+	if(debug['v'])
+		Bprint(&bso, "%5.2f dodata\n", cputime());
+	Bflush(&bso);
+	for(p = datap; p != P; p = p->link) {
+		s = p->from.sym;
+		if(p->as == ADYNT || p->as == AINIT)
+			s->value = dtype;
+		if(s->type == SBSS)
+			s->type = SDATA;
+		if(s->type != SDATA)
+			diag("initialize non-data (%d): %s\n%P",
+				s->type, s->name, p);
+		v = p->from.offset + p->reg;
+		if(v > s->value)
+			diag("initialize bounds (%ld): %s\n%P",
+				s->value, s->name, p);
+		if((s->type == SBSS || s->type == SDATA) && (p->to.type == D_CONST || p->to.type == D_OCONST) && (p->to.name == D_EXTERN || p->to.name == D_STATIC)){
+			s = p->to.sym;
+			if(s != S && (s->type == STEXT || s->type == SLEAF || s->type == SCONST || s->type == SXREF))
+				s->fnptr = 1;
+		}
+	}
+
+	if(debug['t']) {
+		/*
+		 * pull out string constants
+		 */
+		for(p = datap; p != P; p = p->link) {
+			s = p->from.sym;
+			if(p->to.type == D_SCONST)
+				s->type = SSTRING;
+		}
+	}
+
+	/*
+	 * pass 1
+	 *	assign 'small' variables to data segment
+	 *	(rational is that data segment is more easily
+	 *	 addressed through offset on R12)
+	 */
+	orig = 0;
+	for(i=0; i<NHASH; i++)
+	for(s = hash[i]; s != S; s = s->link) {
+		t = s->type;
+		if(t != SDATA && t != SBSS)
+			continue;
+		v = s->value;
+		if(v == 0) {
+			diag("%s: no size", s->name);
+			v = 1;
+		}
+		while(v & 3)
+			v++;
+		s->value = v;
+		if(v > MINSIZ)
+			continue;
+		s->value = orig;
+		orig += v;
+		s->type = SDATA1;
+	}
+
+	/*
+	 * pass 2
+	 *	assign large 'data' variables to data segment
+	 */
+	for(i=0; i<NHASH; i++)
+	for(s = hash[i]; s != S; s = s->link) {
+		t = s->type;
+		if(t != SDATA) {
+			if(t == SDATA1)
+				s->type = SDATA;
+			continue;
+		}
+		v = s->value;
+		s->value = orig;
+		orig += v;
+	}
+
+	while(orig & 7)
+		orig++;
+	datsize = orig;
+
+	/*
+	 * pass 3
+	 *	everything else to bss segment
+	 */
+	for(i=0; i<NHASH; i++)
+	for(s = hash[i]; s != S; s = s->link) {
+		if(s->type != SBSS)
+			continue;
+		v = s->value;
+		s->value = orig;
+		orig += v;
+	}
+	while(orig & 7)
+		orig++;
+	bsssize = orig-datsize;
+
+	xdefine("setR12", SDATA, 0L+BIG);
+	xdefine("bdata", SDATA, 0L);
+	xdefine("edata", SDATA, datsize);
+	xdefine("end", SBSS, datsize+bsssize);
+	xdefine("etext", STEXT, 0L);
+}
+
+void
+undef(void)
+{
+	int i;
+	Sym *s;
+
+	for(i=0; i<NHASH; i++)
+	for(s = hash[i]; s != S; s = s->link)
+		if(s->type == SXREF)
+			diag("%s: not defined", s->name);
+}
+
+Prog*
+brchain(Prog *p)
+{
+	int i;
+
+	for(i=0; i<20; i++) {
+		if(p == P || p->as != AB)
+			return p;
+		p = p->cond;
+	}
+	return P;
+}
+
+int
+relinv(int a)
+{
+	switch(a) {
+	case ABEQ:	return ABNE;
+	case ABNE:	return ABEQ;
+	case ABCS:	return ABCC;
+	case ABHS:	return ABLO;
+	case ABCC:	return ABCS;
+	case ABLO:	return ABHS;
+	case ABMI:	return ABPL;
+	case ABPL:	return ABMI;
+	case ABVS:	return ABVC;
+	case ABVC:	return ABVS;
+	case ABHI:	return ABLS;
+	case ABLS:	return ABHI;
+	case ABGE:	return ABLT;
+	case ABLT:	return ABGE;
+	case ABGT:	return ABLE;
+	case ABLE:	return ABGT;
+	}
+	diag("unknown relation: %s", anames[a]);
+	return a;
+}
+
+void
+follow(void)
+{
+	if(debug['v'])
+		Bprint(&bso, "%5.2f follow\n", cputime());
+	Bflush(&bso);
+
+	firstp = prg();
+	lastp = firstp;
+	xfol(textp);
+
+	firstp = firstp->link;
+	lastp->link = P;
+}
+
+void
+xfol(Prog *p)
+{
+	Prog *q, *r;
+	int a, i;
+
+loop:
+	if(p == P)
+		return;
+	setarch(p);
+	a = p->as;
+	if(a == ATEXT)
+		curtext = p;
+	if(a == AB) {
+		q = p->cond;
+		if(q != P) {
+			p->mark |= FOLL;
+			p = q;
+			if(!(p->mark & FOLL))
+				goto loop;
+		}
+	}
+	if(p->mark & FOLL) {
+		for(i=0,q=p; i<4; i++,q=q->link) {
+			if(q == lastp)
+				break;
+			a = q->as;
+			if(a == ANOP) {
+				i--;
+				continue;
+			}
+			if(a == AB || (a == ARET && q->scond == 14) || a == ARFE)
+				goto copy;
+			if(!q->cond || (q->cond->mark&FOLL))
+				continue;
+			if(a != ABEQ && a != ABNE)
+				continue;
+		copy:
+			for(;;) {
+				r = prg();
+				*r = *p;
+				if(!(r->mark&FOLL))
+					print("cant happen 1\n");
+				r->mark |= FOLL;
+				if(p != q) {
+					p = p->link;
+					lastp->link = r;
+					lastp = r;
+					continue;
+				}
+				lastp->link = r;
+				lastp = r;
+				if(a == AB || (a == ARET && q->scond == 14) || a == ARFE)
+					return;
+				r->as = ABNE;
+				if(a == ABNE)
+					r->as = ABEQ;
+				r->cond = p->link;
+				r->link = p->cond;
+				if(!(r->link->mark&FOLL))
+					xfol(r->link);
+				if(!(r->cond->mark&FOLL))
+					print("cant happen 2\n");
+				return;
+			}
+		}
+		a = AB;
+		q = prg();
+		q->as = a;
+		q->line = p->line;
+		q->to.type = D_BRANCH;
+		q->to.offset = p->pc;
+		q->cond = p;
+		p = q;
+	}
+	p->mark |= FOLL;
+	lastp->link = p;
+	lastp = p;
+	if(a == AB || (a == ARET && p->scond == 14) || a == ARFE){
+		return;
+	}
+	if(p->cond != P)
+	if(a != ABL && a != ABX && p->link != P) {
+		q = brchain(p->link);
+		if(a != ATEXT && a != ABCASE)
+		if(q != P && (q->mark&FOLL)) {
+			p->as = relinv(a);
+			p->link = p->cond;
+			p->cond = q;
+		}
+		xfol(p->link);
+		q = brchain(p->cond);
+		if(q == P)
+			q = p->cond;
+		if(q->mark&FOLL) {
+			p->cond = q;
+			return;
+		}
+		p = q;
+		goto loop;
+	}
+	p = p->link;
+	goto loop;
+}
+
+void
+patch(void)
+{
+	long c, vexit;
+	Prog *p, *q;
+	Sym *s, *s1;
+	int a;
+
+	if(debug['v'])
+		Bprint(&bso, "%5.2f patch\n", cputime());
+	Bflush(&bso);
+	mkfwd();
+	s = lookup("exit", 0);
+	vexit = s->value;
+	for(p = firstp; p != P; p = p->link) {
+		setarch(p);
+		a = p->as;
+		if(a == ATEXT)
+			curtext = p;
+		if(seenthumb && a == ABL){
+			// if((s = p->to.sym) != S && (s1 = curtext->from.sym) != S)
+			//	print("%s calls %s\n", s1->name, s->name);
+			 if((s = p->to.sym) != S && (s1 = curtext->from.sym) != S && s->thumb != s1->thumb)
+				s->foreign = 1;
+		}
+		if((a == ABL || a == ABX || a == AB || a == ARET) &&
+		   p->to.type != D_BRANCH && p->to.sym != S) {
+			s = p->to.sym;
+			switch(s->type) {
+			default:
+				diag("undefined: %s\n%P", s->name, p);
+				s->type = STEXT;
+				s->value = vexit;
+				break;
+			case STEXT:
+				p->to.offset = s->value;
+				p->to.type = D_BRANCH;
+				break;
+			case SUNDEF:
+				if(p->as != ABL)
+					diag("help: SUNDEF in AB || ARET");
+				p->to.offset = 0;
+				p->to.type = D_BRANCH;
+				p->cond = UP;
+				break;
+			}
+		}
+		if(p->to.type != D_BRANCH || p->cond == UP)
+			continue;
+		c = p->to.offset;
+		for(q = firstp; q != P;) {
+			if(q->forwd != P)
+			if(c >= q->forwd->pc) {
+				q = q->forwd;
+				continue;
+			}
+			if(c == q->pc)
+				break;
+			q = q->link;
+		}
+		if(q == P) {
+			diag("branch out of range %ld\n%P", c, p);
+			p->to.type = D_NONE;
+		}
+		p->cond = q;
+	}
+
+	for(p = firstp; p != P; p = p->link) {
+		setarch(p);
+		a = p->as;
+		if(p->as == ATEXT)
+			curtext = p;
+		if(seenthumb && a == ABL) {
+#ifdef CALLEEBX
+			if(0)
+				{}
+#else
+			if((s = p->to.sym) != S && (s->foreign || s->fnptr))
+				p->as = ABX;
+#endif
+			else if(p->to.type == D_OREG)
+				p->as = ABX;
+		}
+		if(p->cond != P && p->cond != UP) {
+			p->cond = brloop(p->cond);
+			if(p->cond != P)
+			if(p->to.type == D_BRANCH)
+				p->to.offset = p->cond->pc;
+		}
+	}
+}
+
+#define	LOG	5
+void
+mkfwd(void)
+{
+	Prog *p;
+	long dwn[LOG], cnt[LOG], i;
+	Prog *lst[LOG];
+
+	for(i=0; i<LOG; i++) {
+		if(i == 0)
+			cnt[i] = 1; else
+			cnt[i] = LOG * cnt[i-1];
+		dwn[i] = 1;
+		lst[i] = P;
+	}
+	i = 0;
+	for(p = firstp; p != P; p = p->link) {
+		if(p->as == ATEXT)
+			curtext = p;
+		i--;
+		if(i < 0)
+			i = LOG-1;
+		p->forwd = P;
+		dwn[i]--;
+		if(dwn[i] <= 0) {
+			dwn[i] = cnt[i];
+			if(lst[i] != P)
+				lst[i]->forwd = p;
+			lst[i] = p;
+		}
+	}
+}
+
+Prog*
+brloop(Prog *p)
+{
+	Prog *q;
+	int c;
+
+	for(c=0; p!=P;) {
+		if(p->as != AB)
+			return p;
+		q = p->cond;
+		if(q <= p) {
+			c++;
+			if(q == p || c > 5000)
+				break;
+		}
+		p = q;
+	}
+	return P;
+}
+
+long
+atolwhex(char *s)
+{
+	long n;
+	int f;
+
+	n = 0;
+	f = 0;
+	while(*s == ' ' || *s == '\t')
+		s++;
+	if(*s == '-' || *s == '+') {
+		if(*s++ == '-')
+			f = 1;
+		while(*s == ' ' || *s == '\t')
+			s++;
+	}
+	if(s[0]=='0' && s[1]){
+		if(s[1]=='x' || s[1]=='X'){
+			s += 2;
+			for(;;){
+				if(*s >= '0' && *s <= '9')
+					n = n*16 + *s++ - '0';
+				else if(*s >= 'a' && *s <= 'f')
+					n = n*16 + *s++ - 'a' + 10;
+				else if(*s >= 'A' && *s <= 'F')
+					n = n*16 + *s++ - 'A' + 10;
+				else
+					break;
+			}
+		} else
+			while(*s >= '0' && *s <= '7')
+				n = n*8 + *s++ - '0';
+	} else
+		while(*s >= '0' && *s <= '9')
+			n = n*10 + *s++ - '0';
+	if(f)
+		n = -n;
+	return n;
+}
+
+long
+rnd(long v, long r)
+{
+	long c;
+
+	if(r <= 0)
+		return v;
+	v += r - 1;
+	c = v % r;
+	if(c < 0)
+		c += r;
+	v -= c;
+	return v;
+}
+
+#define Reachable(n)	if((s = lookup(n, 0)) != nil) s->used++
+
+static void
+rused(Adr *a)
+{
+	Sym *s = a->sym;
+
+	if(s == S)
+		return;
+	if(a->type == D_OREG || a->type == D_OCONST || a->type == D_CONST){
+		if(a->name == D_EXTERN || a->name == D_STATIC){
+			if(s->used == 0)
+				s->used = 1;
+		}
+	}
+	else if(a->type == D_BRANCH){
+		if(s->used == 0)
+			s->used = 1;
+	}
+}
+
+void
+reachable()
+{
+	Prog *p, *prev, *prevt, *nextt, *q;
+	Sym *s, *s0;
+	int i, todo;
+	char *a;
+
+	Reachable("_div");
+	Reachable("_divu");
+	Reachable("_mod");
+	Reachable("_modu");
+	a = INITENTRY;
+	if(*a >= '0' && *a <= '9')
+		return;
+	s = lookup(a, 0);
+	if(s == nil)
+		return;
+	if(s->type == 0){
+		s->used = 1;	// to stop asm complaining
+		for(p = firstp; p != P && p->as != ATEXT; p = p->link)
+			;
+		if(p == nil)
+			return;
+		s = p->from.sym;
+	}	
+	s->used = 1;
+	do{
+		todo = 0;
+		for(p = firstp; p != P; p = p->link){
+			if(p->as == ATEXT && (s0 = p->from.sym)->used == 1){
+				todo = 1;
+				for(q = p->link; q != P && q->as != ATEXT; q = q->link){
+					rused(&q->from);
+					rused(&q->to);
+				}
+				s0->used = 2;
+			}
+		}
+		for(p = datap; p != P; p = p->link){
+			if((s0 = p->from.sym)->used == 1){
+				todo = 1;
+				for(q = p; q != P; q = q->link){	// data can be scattered
+					if(q->from.sym == s0)
+						rused(&q->to);
+				}
+				s0->used = 2;
+			}
+		}
+	}while(todo);
+	prev = nil;
+	prevt = nextt = nil;
+	for(p = firstp; p != P; ){
+		if(p->as == ATEXT){
+			prevt = nextt;
+			nextt = p;
+		}
+		if(p->as == ATEXT && (s0 = p->from.sym)->used == 0){
+			s0->type = SREMOVED;
+			for(q = p->link; q != P && q->as != ATEXT; q = q->link)
+				;
+			if(q != p->cond)
+				diag("bad ptr in reachable()");
+			if(prev == nil)
+				firstp = q;
+			else
+				prev->link = q;
+			if(q == nil)
+				lastp = prev;
+			if(prevt == nil)
+				textp = q;
+			else
+				prevt->cond = q;
+			if(q == nil)
+				etextp = prevt;
+			nextt = prevt;
+			if(debug['V'])
+				print("%s unused\n", s0->name);
+			p = q;
+		}
+		else{
+			prev = p;
+			p = p->link;
+		}
+	}
+	prevt = nil;
+	for(p = datap; p != nil; ){
+		if((s0 = p->from.sym)->used == 0){
+			s0->type = SREMOVED;
+			prev = prevt;
+			for(q = p; q != nil; q = q->link){
+				if(q->from.sym == s0){
+					if(prev == nil)
+						datap = q->link;
+					else
+						prev->link = q->link;
+				}
+				else
+					prev = q;
+			}
+			if(debug['V'])
+				print("%s unused (data)\n", s0->name);
+			p = prevt->link;
+		}
+		else{
+			prevt = p;
+			p = p->link;
+		}
+	}
+	for(i=0; i<NHASH; i++){
+		for(s = hash[i]; s != S; s = s->link){
+			if(s->used == 0)
+				s->type = SREMOVED;
+		}
+	}
+}
+
+static void
+fused(Adr *a, Prog *p, Prog *ct)
+{
+	Sym *s = a->sym;
+	Use *u;
+
+	if(s == S)
+		return;
+	if(a->type == D_OREG || a->type == D_OCONST || a->type == D_CONST){
+		if(a->name == D_EXTERN || a->name == D_STATIC){
+			u = malloc(sizeof(Use));
+			u->p = p;
+			u->ct = ct;
+			u->link = s->use;
+			s->use = u;
+		}
+	}
+	else if(a->type == D_BRANCH){
+		u = malloc(sizeof(Use));
+		u->p = p;
+		u->ct = ct;
+		u->link = s->use;
+		s->use = u;
+	}
+}
+
+static int
+ckfpuse(Prog *p, Prog *ct, Sym *fp, Sym *r)
+{
+	int reg;
+
+	USED(fp);
+	USED(ct);
+	if(p->from.sym == r && p->as == AMOVW && (p->from.type == D_CONST || p->from.type == D_OREG) && p->reg == NREG && p->to.type == D_REG){
+		reg = p->to.reg;
+		for(p = p->link; p != P && p->as != ATEXT; p = p->link){
+			if((p->as == ABL || p->as == ABX) && p->to.type == D_OREG && p->to.reg == reg)
+				return 1;
+			if(!debug['F'] && (isbranch(p) || p->as == ARET)){
+				// print("%s: branch %P in %s\n", fp->name, p, ct->from.sym->name);
+				return 0;
+			}
+			if((p->from.type == D_REG || p->from.type == D_OREG) && p->from.reg == reg){
+				if(!debug['F'] && p->to.type != D_REG){
+					// print("%s: store %P in %s\n", fp->name, p, ct->from.sym->name);
+					return 0;
+				}
+				reg = p->to.reg;
+			}
+		}
+	}
+	// print("%s: no MOVW O(R), R\n", fp->name);
+	return debug['F'];
+}
+
+static void
+setfpuse(Prog *p, Sym *fp, Sym *r)
+{
+	int reg;
+
+	if(p->from.sym == r && p->as == AMOVW && (p->from.type == D_CONST || p->from.type == D_OREG) && p->reg == NREG && p->to.type == D_REG){
+		reg = p->to.reg;
+		for(p = p->link; p != P && p->as != ATEXT; p = p->link){
+			if((p->as == ABL || p->as == ABX) && p->to.type == D_OREG && p->to.reg == reg){
+				fp->fnptr = 0;
+				p->as = ABL;	// safe to do so
+// print("simplified %s call\n", fp->name);
+				break;
+			}
+			if(!debug['F'] && (isbranch(p) || p->as == ARET))
+				diag("bad setfpuse call");
+			if((p->from.type == D_REG || p->from.type == D_OREG) && p->from.reg == reg){
+				if(!debug['F'] && p->to.type != D_REG)
+					diag("bad setfpuse call");
+				reg = p->to.reg;
+			}
+		}
+	}
+}
+
+static int
+cksymuse(Sym *s, int t)
+{
+	Prog *p;
+
+	for(p = datap; p != P; p = p->link){
+		if(p->from.sym == s && p->to.sym != nil && strcmp(p->to.sym->name, ".string") != 0 && p->to.sym->thumb != t){
+			// print("%s %s %d %d ", p->from.sym->name, p->to.sym->name, p->to.sym->thumb, t);
+			return 0;
+		}
+	}
+	return 1;
+}
+
+/* check the use of s at the given point */
+static int
+ckuse(Sym *s, Sym *s0, Use *u)
+{
+	Sym *s1;
+
+	s1 = u->p->from.sym;
+// print("ckuse %s %s %s\n", s->name, s0->name, s1 ? s1->name : "nil");
+	if(u->ct == nil){	/* in data area */
+		if(s0 == s && !cksymuse(s1, s0->thumb)){
+			// print("%s: cksymuse fails\n", s0->name);
+			return 0;
+		}
+		for(u = s1->use; u != U; u = u->link)
+			if(!ckuse(s1, s0, u))
+				return 0;
+	}
+	else{		/* in text area */
+		if(u->ct->from.sym->thumb != s0->thumb){
+			// print("%s(%d): foreign call %s(%d)\n", s0->name, s0->thumb, u->ct->from.sym->name, u->ct->from.sym->thumb);
+			return 0;
+		}
+		return ckfpuse(u->p, u->ct, s0, s);
+	}
+	return 1;
+}
+		
+static void
+setuse(Sym *s, Sym *s0, Use *u)
+{
+	Sym *s1;
+
+	s1 = u->p->from.sym;
+	if(u->ct == nil){	/* in data area */
+		for(u = s1->use; u != U; u = u->link)
+			setuse(s1, s0, u);
+	}
+	else{		/* in text area */
+		setfpuse(u->p, s0, s);
+	}
+}
+		
+/* detect BX O(R) which can be done as BL O(R) */
+void
+fnptrs()
+{
+	int i;
+	Sym *s;
+	Prog *p;
+	Use *u;
+	
+	for(i=0; i<NHASH; i++){
+		for(s = hash[i]; s != S; s = s->link){
+			if(s->fnptr && (s->type == STEXT || s->type == SLEAF || s->type == SCONST)){
+				// print("%s : fnptr %d %d\n", s->name, s->thumb, s->foreign);
+			}
+		}
+	}	
+	/* record use of syms */
+	for(p = firstp; p != P; p = p->link){
+		if(p->as == ATEXT)
+			curtext = p;
+		else{
+			fused(&p->from, p, curtext);
+			fused(&p->to, p, curtext);
+		}
+	}
+	for(p = datap; p != P; p = p->link)
+		fused(&p->to, p, nil);
+
+	/* now look for fn ptrs */
+	for(i=0; i<NHASH; i++){
+		for(s = hash[i]; s != S; s = s->link){
+			if(s->fnptr && (s->type == STEXT || s->type == SLEAF || s->type == SCONST)){
+				for(u = s->use; u != U; u = u->link){
+					if(!ckuse(s, s, u))
+						break;
+				}
+				if(u == U){		// can simplify
+					for(u = s->use; u != U; u = u->link)
+						setuse(s, s, u);
+				}
+			}	
+		}
+	}
+
+	/*  now free Use structures */
+}
+
+void
+import(void)
+{
+	int i;
+	Sym *s;
+
+	for(i = 0; i < NHASH; i++)
+		for(s = hash[i]; s != S; s = s->link)
+			if(s->sig != 0 && s->type == SXREF && (nimports == 0 || s->subtype == SIMPORT)){
+				undefsym(s);
+				Bprint(&bso, "IMPORT: %s sig=%lux v=%ld\n", s->name, s->sig, s->value);
+			}
+}
+
+void
+ckoff(Sym *s, long v)
+{
+	if(v < 0 || v >= 1<<Roffset)
+		diag("relocation offset %ld for %s out of range", v, s->name);
+}
+
+static Prog*
+newdata(Sym *s, int o, int w, int t)
+{
+	Prog *p;
+
+	p = prg();
+	p->link = datap;
+	datap = p;
+	p->as = ADATA;
+	p->reg = w;
+	p->from.type = D_OREG;
+	p->from.name = t;
+	p->from.sym = s;
+	p->from.offset = o;
+	p->to.type = D_CONST;
+	p->to.name = D_NONE;
+	return p;
+}
+
+void
+export(void)
+{
+	int i, j, n, off, nb, sv, ne;
+	Sym *s, *et, *str, **esyms;
+	Prog *p;
+	char buf[NSNAME], *t;
+
+	n = 0;
+	for(i = 0; i < NHASH; i++)
+		for(s = hash[i]; s != S; s = s->link)
+			if(s->sig != 0 && s->type != SXREF && s->type != SUNDEF && (nexports == 0 || s->subtype == SEXPORT))
+				n++;
+	esyms = malloc(n*sizeof(Sym*));
+	ne = n;
+	n = 0;
+	for(i = 0; i < NHASH; i++)
+		for(s = hash[i]; s != S; s = s->link)
+			if(s->sig != 0 && s->type != SXREF && s->type != SUNDEF && (nexports == 0 || s->subtype == SEXPORT))
+				esyms[n++] = s;
+	for(i = 0; i < ne-1; i++)
+		for(j = i+1; j < ne; j++)
+			if(strcmp(esyms[i]->name, esyms[j]->name) > 0){
+				s = esyms[i];
+				esyms[i] = esyms[j];
+				esyms[j] = s;
+			}
+
+	nb = 0;
+	off = 0;
+	et = lookup(EXPTAB, 0);
+	if(et->type != 0 && et->type != SXREF)
+		diag("%s already defined", EXPTAB);
+	et->type = SDATA;
+	str = lookup(".string", 0);
+	if(str->type == 0)
+		str->type = SDATA;
+	sv = str->value;
+	for(i = 0; i < ne; i++){
+		s = esyms[i];
+		Bprint(&bso, "EXPORT: %s sig=%lux t=%d\n", s->name, s->sig, s->type);
+
+		/* signature */
+		p = newdata(et, off, sizeof(long), D_EXTERN);
+		off += sizeof(long);
+		p->to.offset = s->sig;
+
+		/* address */
+		p = newdata(et, off, sizeof(long), D_EXTERN);
+		off += sizeof(long);
+		p->to.name = D_EXTERN;
+		p->to.sym = s;
+
+		/* string */
+		t = s->name;
+		n = strlen(t)+1;
+		for(;;){
+			buf[nb++] = *t;
+			sv++;
+			if(nb >= NSNAME){
+				p = newdata(str, sv-NSNAME, NSNAME, D_STATIC);
+				p->to.type = D_SCONST;
+				p->to.sval = malloc(NSNAME);
+				memmove(p->to.sval, buf, NSNAME);
+				nb = 0;
+			}
+			if(*t++ == 0)
+				break;
+		}
+
+		/* name */
+		p = newdata(et, off, sizeof(long), D_EXTERN);
+		off += sizeof(long);
+		p->to.name = D_STATIC;
+		p->to.sym = str;
+		p->to.offset = sv-n;
+	}
+
+	if(nb > 0){
+		p = newdata(str, sv-nb, nb, D_STATIC);
+		p->to.type = D_SCONST;
+		p->to.sval = malloc(NSNAME);
+		memmove(p->to.sval, buf, nb);
+	}
+
+	for(i = 0; i < 3; i++){
+		newdata(et, off, sizeof(long), D_EXTERN);
+		off += sizeof(long);
+	}
+	et->value = off;
+	if(sv == 0)
+		sv = 1;
+	str->value = sv;
+	exports = ne;
+	free(esyms);
+}
diff --git a/src/cmd/5l/span.c b/src/cmd/5l/span.c
new file mode 100644
index 0000000000..f0b7b4f17c
--- /dev/null
+++ b/src/cmd/5l/span.c
@@ -0,0 +1,1292 @@
+// Inferno utils/5l/span.c
+// http://code.google.com/p/inferno-os/source/browse/utils/5l/span.c
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#include	"l.h"
+
+static struct {
+	ulong	start;
+	ulong	size;
+	ulong	extra;
+} pool;
+
+int	checkpool(Prog*, int);
+int 	flushpool(Prog*, int, int);
+
+int
+isbranch(Prog *p)
+{
+	int as = p->as;
+	return (as >= ABEQ && as <= ABLE) || as == AB || as == ABL || as == ABX;
+}
+
+static int
+ispad(Prog *p)
+{
+	if(p->as != AMOVW)
+		return 0;
+	if(p->from.type != D_REG || p->from.reg != REGSB)
+		return 0;
+	if(p->to.type != D_REG || p->to.reg != REGSB)
+		return 0;
+	return 1;
+}
+
+int
+fninc(Sym *s)
+{
+	if(thumb){
+		if(s->thumb){
+			if(s->foreign)
+				return 8;
+			else
+				return 0;
+		}
+		else{
+			if(s->foreign)
+				return 0;
+			else
+				diag("T A !foreign in fninc");
+		}
+	}
+	else{
+		if(s->thumb){
+			if(s->foreign)
+				return 0;
+			else
+				diag("A T !foreign in fninc");
+		}
+		else{
+			if(s->foreign)
+				return 4;
+			else
+				return 0;
+		}			
+	}
+	return 0;
+}
+
+int 
+fnpinc(Sym *s)
+{
+	if(!s->fnptr){	// a simplified case BX O(R) -> BL O(R)
+		if(!debug['f'])
+			diag("fnptr == 0 in fnpinc");
+		if(s->foreign)
+			diag("bad usage in fnpinc %s %d %d %d", s->name, s->used, s->foreign, s->thumb);
+		return 0;
+	}
+	/* 0, 1, 2, 3 squared */
+	if(s->thumb)
+		return s->foreign ? 9 : 1;
+	else
+		return s->foreign ? 4 : 0;
+}
+
+static Prog *
+pad(Prog *p, int pc)
+{
+	Prog *q;
+
+	q = prg();
+	q->as = AMOVW;
+	q->line = p->line;
+	q->from.type = D_REG;
+	q->from.reg = REGSB;
+	q->to.type = D_REG;
+	q->to.reg = REGSB;
+	q->pc = pc;
+	q->link = p->link;
+	return q;
+}
+
+static int
+scan(Prog *op, Prog *p, int c)
+{
+	Prog *q;
+
+	for(q = op->link; q != p; q = q->link){
+		q->pc = c;
+		c += oplook(q)->size;
+		nocache(q);
+	}
+	return c;
+}
+
+/* size of a case statement including jump table */
+static long
+casesz(Prog *p)
+{
+	int jt = 0;
+	long n = 0;
+	Optab *o;
+
+	for( ; p != P; p = p->link){
+		if(p->as == ABCASE)
+			jt = 1;
+		else if(jt)
+			break;
+		o = oplook(p);
+		n += o->size;
+	}
+	return n;
+}
+
+void
+span(void)
+{
+	Prog *p, *op;
+	Sym *setext, *s;
+	Optab *o;
+	int m, bflag, i;
+	long c, otxt, v;
+	int lastthumb = -1;
+
+	if(debug['v'])
+		Bprint(&bso, "%5.2f span\n", cputime());
+	Bflush(&bso);
+
+	bflag = 0;
+	c = INITTEXT;
+	op = nil;
+	otxt = c;
+	for(p = firstp; p != P; op = p, p = p->link) {
+		setarch(p);
+		p->pc = c;
+		o = oplook(p);
+		m = o->size;
+		// must check literal pool here in case p generates many instructions
+		if(blitrl){
+			if(thumb && isbranch(p))
+				pool.extra += brextra(p);
+			if(checkpool(op, p->as == ACASE ? casesz(p) : m))
+				c = p->pc = scan(op, p, c);
+		}
+		if(m == 0) {
+			if(p->as == ATEXT) {
+				if(blitrl && lastthumb != -1 && lastthumb != thumb){	// flush literal pool
+					if(flushpool(op, 0, 1))
+						c = p->pc = scan(op, p, c);
+				}
+				lastthumb = thumb;
+				curtext = p;
+				autosize = p->to.offset + 4;
+				if(p->from.sym != S)
+					p->from.sym->value = c;
+				/* need passes to resolve branches */
+				if(c-otxt >= 1L<<17)
+					bflag = 1;
+				otxt = c;
+				if(thumb && blitrl)
+					pool.extra += brextra(p);
+				continue;
+			}
+			diag("zero-width instruction\n%P", p);
+			continue;
+		}
+		switch(o->flag & (LFROM|LTO|LPOOL)) {
+		case LFROM:
+			addpool(p, &p->from);
+			break;
+		case LTO:
+			addpool(p, &p->to);
+			break;
+		case LPOOL:
+			if ((p->scond&C_SCOND) == 14)
+				flushpool(p, 0, 0);
+			break;
+		}
+		if(p->as==AMOVW && p->to.type==D_REG && p->to.reg==REGPC && (p->scond&C_SCOND) == 14)
+			flushpool(p, 0, 0);
+		c += m;
+		if(blitrl && p->link == P){
+			if(thumb && isbranch(p))
+				pool.extra += brextra(p);
+			checkpool(p, 0);
+		}
+	}
+
+	/*
+	 * if any procedure is large enough to
+	 * generate a large SBRA branch, then
+	 * generate extra passes putting branches
+	 * around jmps to fix. this is rare.
+	 */
+	while(bflag) {
+		if(debug['v'])
+			Bprint(&bso, "%5.2f span1\n", cputime());
+		bflag = 0;
+		c = INITTEXT;
+		for(p = firstp; p != P; p = p->link) {
+			setarch(p);
+			p->pc = c;
+			if(thumb && isbranch(p))
+				nocache(p);
+			o = oplook(p);
+/* very larg branches
+			if(o->type == 6 && p->cond) {
+				otxt = p->cond->pc - c;
+				if(otxt < 0)
+					otxt = -otxt;
+				if(otxt >= (1L<<17) - 10) {
+					q = prg();
+					q->link = p->link;
+					p->link = q;
+					q->as = AB;
+					q->to.type = D_BRANCH;
+					q->cond = p->cond;
+					p->cond = q;
+					q = prg();
+					q->link = p->link;
+					p->link = q;
+					q->as = AB;
+					q->to.type = D_BRANCH;
+					q->cond = q->link->link;
+					bflag = 1;
+				}
+			}
+ */
+			m = o->size;
+			if(m == 0) {
+				if(p->as == ATEXT) {
+					curtext = p;
+					autosize = p->to.offset + 4;
+					if(p->from.sym != S)
+						p->from.sym->value = c;
+					continue;
+				}
+				diag("zero-width instruction\n%P", p);
+				continue;
+			}
+			c += m;
+		}
+	}
+
+	if(seenthumb){		// branch resolution
+		int passes = 0;
+		int lastc = 0;
+		int again;
+		Prog *oop;
+
+	loop:
+		passes++;
+		if(passes > 100){
+			diag("span looping !");
+			errorexit();
+		}
+		c = INITTEXT;
+		oop = op = nil;
+		again = 0;
+		for(p = firstp; p != P; oop = op, op = p, p = p->link){
+			setarch(p);
+			if(p->pc != c)
+				again = 1;
+			p->pc = c;
+			if(thumb && isbranch(p))
+				nocache(p);
+			o = oplook(p);
+			m = o->size;
+			if(passes == 1 && thumb && isbranch(p)){	// start conservative so unneeded alignment is not added
+				if(p->as == ABL)
+					m = 4;
+				else
+					m = 2;
+				p->align = 0;
+			}	
+			if(p->align){
+				if((p->align == 4 && (c&3)) || (p->align == 2 && !(c&3))){
+					if(ispad(op)){
+						oop->link = p;
+						op = oop;
+						c -= 2;
+						p->pc = c;
+					}
+					else{
+						op->link = pad(op, c);
+						op = op->link;
+						c += 2;
+						p->pc = c;
+					}
+					again = 1;
+				}
+			}
+			if(m == 0) {
+				if(p->as == ATEXT) {
+					curtext = p;
+					autosize = p->to.offset + 4;
+					if(p->from.sym != S)
+						p->from.sym->value = c;
+					continue;
+				}
+			}
+			c += m;
+		}
+		if(c != lastc || again){
+			lastc = c;
+			goto loop;
+		}
+	}
+
+	if(0 && seenthumb){		// rm redundant padding - obsolete
+		int d;
+
+		op = nil;
+		d = 0;
+		for(p = firstp; p != P; op = p, p = p->link){
+			p->pc -= d;
+			if(p->as == ATEXT){
+				if(p->from.sym != S)
+					p->from.sym->value -= d;
+// if(p->from.sym != S) print("%s %ux %d %d %d\n", p->from.sym->name ? p->from.sym->name : "?", p->from.sym->value, p->from.sym->thumb, p->from.sym->foreign, p->from.sym->fnptr);
+			}
+			if(ispad(p) && p->link != P && ispad(p->link)){
+				op->link = p->link->link;
+				d += 4;
+				p = op;
+			}
+		}
+		// print("%d bytes removed (padding)\n", d);
+		c -= d;
+	}
+	
+	if(debug['t']) {
+		/* 
+		 * add strings to text segment
+		 */
+		c = rnd(c, 8);
+		for(i=0; i<NHASH; i++)
+		for(s = hash[i]; s != S; s = s->link) {
+			if(s->type != SSTRING)
+				continue;
+			v = s->value;
+			while(v & 3)
+				v++;
+			s->value = c;
+			c += v;
+		}
+	}
+			
+	c = rnd(c, 8);
+
+	setext = lookup("etext", 0);
+	if(setext != S) {
+		setext->value = c;
+		textsize = c - INITTEXT;
+	}
+	if(INITRND)
+		INITDAT = rnd(c, INITRND);
+	if(debug['v'])
+		Bprint(&bso, "tsize = %lux\n", textsize);
+	Bflush(&bso);
+}
+
+/*
+ * when the first reference to the literal pool threatens
+ * to go out of range of a 12-bit PC-relative offset,
+ * drop the pool now, and branch round it.
+ * this happens only in extended basic blocks that exceed 4k.
+ */
+int
+checkpool(Prog *p, int sz)
+{
+	if(thumb){
+		if(pool.size >= 0x3fc || (p->pc+sz+pool.extra+2+2)+(pool.size-4)-pool.start-4 >= 0x3fc)
+			return flushpool(p, 1, 0);
+		else if(p->link == P)
+			return flushpool(p, 2, 0);
+		return 0;
+	}
+	if(pool.size >= 0xffc || immaddr((p->pc+sz+4)+4+pool.size - pool.start+8) == 0)
+		return flushpool(p, 1, 0);
+	else if(p->link == P)
+		return flushpool(p, 2, 0);
+	return 0;
+}
+
+int
+flushpool(Prog *p, int skip, int force)
+{
+	Prog *q;
+
+	if(blitrl) {
+		if(skip){
+			if(0 && skip==1)print("note: flush literal pool at %lux: len=%lud ref=%lux\n", p->pc+4, pool.size, pool.start);
+			q = prg();
+			q->as = AB;
+			q->to.type = D_BRANCH;
+			q->cond = p->link;
+			q->link = blitrl;
+			blitrl = q;
+		}
+		else if(!force && (p->pc+pool.size-pool.start < (thumb ? 0x3fc+4-pool.extra : 2048)))
+			return 0;
+		elitrl->link = p->link;
+		p->link = blitrl;
+		blitrl = 0;	/* BUG: should refer back to values until out-of-range */
+		elitrl = 0;
+		pool.size = 0;
+		pool.start = 0;
+		pool.extra = 0;
+		return 1;
+	}
+	return 0;
+}
+
+void
+addpool(Prog *p, Adr *a)
+{
+	Prog *q, t;
+	int c;
+
+	if(thumb)
+		c = thumbaclass(a, p);
+	else
+		c = aclass(a);
+
+	t = zprg;
+	t.as = AWORD;
+
+	switch(c) {
+	default:
+		t.to = *a;
+		break;
+
+	case	C_SROREG:
+	case C_LOREG:
+	case C_ROREG:
+	case C_FOREG:
+	case C_SOREG:
+	case C_HOREG:
+	case C_GOREG:
+	case C_FAUTO:
+	case C_SAUTO:
+	case C_LAUTO:
+	case C_LACON:
+	case C_GACON:
+		t.to.type = D_CONST;
+		t.to.offset = instoffset;
+		break;
+	}
+
+	for(q = blitrl; q != P; q = q->link)	/* could hash on t.t0.offset */
+		if(memcmp(&q->to, &t.to, sizeof(t.to)) == 0) {
+			p->cond = q;
+			return;
+		}
+
+	q = prg();
+	*q = t;
+	q->pc = pool.size;
+
+	if(blitrl == P) {
+		blitrl = q;
+		pool.start = p->pc;
+		q->align = 4;
+	} else
+		elitrl->link = q;
+	elitrl = q;
+	pool.size += 4;
+
+	p->cond = q;
+}
+
+void
+xdefine(char *p, int t, long v)
+{
+	Sym *s;
+
+	s = lookup(p, 0);
+	if(s->type == 0 || s->type == SXREF) {
+		s->type = t;
+		s->value = v;
+	}
+}
+
+long
+regoff(Adr *a)
+{
+
+	instoffset = 0;
+	aclass(a);
+	return instoffset;
+}
+
+long
+immrot(ulong v)
+{
+	int i;
+
+	for(i=0; i<16; i++) {
+		if((v & ~0xff) == 0)
+			return (i<<8) | v | (1<<25);
+		v = (v<<2) | (v>>30);
+	}
+	return 0;
+}
+
+long
+immaddr(long v)
+{
+	if(v >= 0 && v <= 0xfff)
+		return (v & 0xfff) |
+			(1<<24) |	/* pre indexing */
+			(1<<23);	/* pre indexing, up */
+	if(v >= -0xfff && v < 0)
+		return (-v & 0xfff) |
+			(1<<24);	/* pre indexing */
+	return 0;
+}
+
+int
+immfloat(long v)
+{
+	return (v & 0xC03) == 0;	/* offset will fit in floating-point load/store */
+}
+
+int
+immhalf(long v)
+{
+	if(v >= 0 && v <= 0xff)
+		return v|
+			(1<<24)|	/* pre indexing */
+			(1<<23);	/* pre indexing, up */
+	if(v >= -0xff && v < 0)
+		return (-v & 0xff)|
+			(1<<24);	/* pre indexing */
+	return 0;
+}
+
+int
+aclass(Adr *a)
+{
+	Sym *s;
+	int t;
+
+	switch(a->type) {
+	case D_NONE:
+		return C_NONE;
+
+	case D_REG:
+		return C_REG;
+
+	case D_REGREG:
+		return C_REGREG;
+
+	case D_SHIFT:
+		return C_SHIFT;
+
+	case D_FREG:
+		return C_FREG;
+
+	case D_FPCR:
+		return C_FCR;
+
+	case D_OREG:
+		switch(a->name) {
+		case D_EXTERN:
+		case D_STATIC:
+			if(a->sym == 0 || a->sym->name == 0) {
+				print("null sym external\n");
+				print("%D\n", a);
+				return C_GOK;
+			}
+			s = a->sym;
+			t = s->type;
+			if(t == 0 || t == SXREF) {
+				diag("undefined external: %s in %s",
+					s->name, TNAME);
+				s->type = SDATA;
+			}
+			if(dlm) {
+				switch(t) {
+				default:
+					instoffset = s->value + a->offset + INITDAT;
+					break;
+				case SUNDEF:
+				case STEXT:
+				case SCONST:
+				case SLEAF:
+				case SSTRING:
+					instoffset = s->value + a->offset;
+					break;
+				}
+				return C_ADDR;
+			}
+			instoffset = s->value + a->offset - BIG;
+			t = immaddr(instoffset);
+			if(t) {
+				if(immhalf(instoffset))
+					return immfloat(t) ? C_HFEXT : C_HEXT;
+				if(immfloat(t))
+					return C_FEXT;
+				return C_SEXT;
+			}
+			return C_LEXT;
+		case D_AUTO:
+			instoffset = autosize + a->offset;
+			t = immaddr(instoffset);
+			if(t){
+				if(immhalf(instoffset))
+					return immfloat(t) ? C_HFAUTO : C_HAUTO;
+				if(immfloat(t))
+					return C_FAUTO;
+				return C_SAUTO;
+			}
+			return C_LAUTO;
+
+		case D_PARAM:
+			instoffset = autosize + a->offset + 4L;
+			t = immaddr(instoffset);
+			if(t){
+				if(immhalf(instoffset))
+					return immfloat(t) ? C_HFAUTO : C_HAUTO;
+				if(immfloat(t))
+					return C_FAUTO;
+				return C_SAUTO;
+			}
+			return C_LAUTO;
+		case D_NONE:
+			instoffset = a->offset;
+			t = immaddr(instoffset);
+			if(t) {
+				if(immhalf(instoffset))		 /* n.b. that it will also satisfy immrot */
+					return immfloat(t) ? C_HFOREG : C_HOREG;
+				if(immfloat(t))
+					return C_FOREG; /* n.b. that it will also satisfy immrot */
+				t = immrot(instoffset);
+				if(t)
+					return C_SROREG;
+				if(immhalf(instoffset))
+					return C_HOREG;
+				return C_SOREG;
+			}
+			t = immrot(instoffset);
+			if(t)
+				return C_ROREG;
+			return C_LOREG;
+		}
+		return C_GOK;
+
+	case D_PSR:
+		return C_PSR;
+
+	case D_OCONST:
+		switch(a->name) {
+		case D_EXTERN:
+		case D_STATIC:
+			s = a->sym;
+			t = s->type;
+			if(t == 0 || t == SXREF) {
+				diag("undefined external: %s in %s",
+					s->name, TNAME);
+				s->type = SDATA;
+			}
+			instoffset = s->value + a->offset + INITDAT;
+			if(s->type == STEXT || s->type == SLEAF || s->type == SUNDEF) {
+				instoffset = s->value + a->offset;
+#ifdef CALLEEBX
+				instoffset += fnpinc(s);
+#else
+				if(s->thumb)
+					instoffset++;	// T bit
+#endif
+				return C_LCON;
+			}
+			return C_LCON;
+		}
+		return C_GOK;
+
+	case D_FCONST:
+		return C_FCON;
+
+	case D_CONST:
+		switch(a->name) {
+
+		case D_NONE:
+			instoffset = a->offset;
+			if(a->reg != NREG)
+				goto aconsize;
+
+			t = immrot(instoffset);
+			if(t)
+				return C_RCON;
+			t = immrot(~instoffset);
+			if(t)
+				return C_NCON;
+			return C_LCON;
+
+		case D_EXTERN:
+		case D_STATIC:
+			s = a->sym;
+			if(s == S)
+				break;
+			t = s->type;
+			switch(t) {
+			case 0:
+			case SXREF:
+				diag("undefined external: %s in %s",
+					s->name, TNAME);
+				s->type = SDATA;
+				break;
+			case SUNDEF:
+			case STEXT:
+			case SSTRING:
+			case SCONST:
+			case SLEAF:
+				instoffset = s->value + a->offset;
+#ifdef CALLEEBX
+				instoffset += fnpinc(s);
+#else
+				if(s->thumb)
+					instoffset++;	// T bit
+#endif
+				return C_LCON;
+			}
+			if(!dlm) {
+				instoffset = s->value + a->offset - BIG;
+				t = immrot(instoffset);
+				if(t && instoffset != 0)
+					return C_RECON;
+			}
+			instoffset = s->value + a->offset + INITDAT;
+			return C_LCON;
+
+		case D_AUTO:
+			instoffset = autosize + a->offset;
+			goto aconsize;
+
+		case D_PARAM:
+			instoffset = autosize + a->offset + 4L;
+		aconsize:
+			t = immrot(instoffset);
+			if(t)
+				return C_RACON;
+			return C_LACON;
+		}
+		return C_GOK;
+
+	case D_BRANCH:
+		return C_SBRA;
+	}
+	return C_GOK;
+}
+
+Optab*
+oplook(Prog *p)
+{
+	int a1, a2, a3, r;
+	char *c1, *c3;
+	Optab *o, *e;
+	Optab *otab;
+	Oprang *orange;
+
+	if(thumb){
+		otab = thumboptab;
+		orange = thumboprange;
+	}
+	else{
+		otab = optab;
+		orange = oprange;
+	}
+	a1 = p->optab;
+	if(a1)
+		return otab+(a1-1);
+	a1 = p->from.class;
+	if(a1 == 0) {
+		if(thumb)
+			a1 = thumbaclass(&p->from, p) + 1;
+		else
+			a1 = aclass(&p->from) + 1;
+		p->from.class = a1;
+	}
+	a1--;
+	a3 = p->to.class;
+	if(a3 == 0) {
+		if(thumb)
+			a3 = thumbaclass(&p->to, p) + 1;
+		else
+			a3 = aclass(&p->to) + 1;
+		p->to.class = a3;
+	}
+	a3--;
+	a2 = C_NONE;
+	if(p->reg != NREG)
+		a2 = C_REG;
+	r = p->as;
+	o = orange[r].start;
+	if(o == 0) {
+		a1 = opcross[repop[r]][a1][a2][a3];
+		if(a1) {
+			p->optab = a1+1;
+			return otab+a1;
+		}
+		o = orange[r].stop; /* just generate an error */
+	}
+	if(0) {
+		print("oplook %A %d %d %d\n",
+			(int)p->as, a1, a2, a3);
+		print("		%d %d\n", p->from.type, p->to.type);
+	}
+	e = orange[r].stop;
+	c1 = xcmp[a1];
+	c3 = xcmp[a3];
+	for(; o<e; o++)
+		if(o->a2 == a2)
+		if(c1[o->a1])
+		if(c3[o->a3]) {
+			p->optab = (o-otab)+1;
+			return o;
+		}
+	diag("illegal combination %A %d %d %d",
+		p->as, a1, a2, a3);
+	prasm(p);
+	if(o == 0)
+		o = otab;
+	return o;
+}
+
+int
+cmp(int a, int b)
+{
+
+	if(a == b)
+		return 1;
+	switch(a) {
+	case C_LCON:
+		if(b == C_RCON || b == C_NCON)
+			return 1;
+		break;
+	case C_LACON:
+		if(b == C_RACON)
+			return 1;
+		break;
+	case C_LECON:
+		if(b == C_RECON)
+			return 1;
+		break;
+
+	case C_HFEXT:
+		return b == C_HEXT || b == C_FEXT;
+	case C_FEXT:
+	case C_HEXT:
+		return b == C_HFEXT;
+	case C_SEXT:
+		return cmp(C_HFEXT, b);
+	case C_LEXT:
+		return cmp(C_SEXT, b);
+
+	case C_HFAUTO:
+		return b == C_HAUTO || b == C_FAUTO;
+	case C_FAUTO:
+	case C_HAUTO:
+		return b == C_HFAUTO;
+	case C_SAUTO:
+		return cmp(C_HFAUTO, b);
+	case C_LAUTO:
+		return cmp(C_SAUTO, b);
+
+	case C_HFOREG:
+		return b == C_HOREG || b == C_FOREG;
+	case C_FOREG:
+	case C_HOREG:
+		return b == C_HFOREG;
+	case C_SROREG:
+		return cmp(C_SOREG, b) || cmp(C_ROREG, b);
+	case C_SOREG:
+	case C_ROREG:
+		return b == C_SROREG || cmp(C_HFOREG, b);
+	case C_LOREG:
+		return cmp(C_SROREG, b);
+
+	case C_LBRA:
+		if(b == C_SBRA)
+			return 1;
+		break;
+	case C_GBRA:
+		if(b == C_SBRA || b == C_LBRA)
+			return 1;
+
+	case C_HREG:
+		return cmp(C_SP, b) || cmp(C_PC, b);
+
+	}
+	return 0;
+}
+
+int
+ocmp(const void *a1, const void *a2)
+{
+	Optab *p1, *p2;
+	int n;
+
+	p1 = (Optab*)a1;
+	p2 = (Optab*)a2;
+	n = p1->as - p2->as;
+	if(n)
+		return n;
+	n = (p2->flag&V4) - (p1->flag&V4);	/* architecture version */
+	if(n)
+		return n;
+	n = p1->a1 - p2->a1;
+	if(n)
+		return n;
+	n = p1->a2 - p2->a2;
+	if(n)
+		return n;
+	n = p1->a3 - p2->a3;
+	if(n)
+		return n;
+	return 0;
+}
+
+void
+buildop(void)
+{
+	int i, n, r;
+
+	armv4 = !debug['h'];
+	for(i=0; i<C_GOK; i++)
+		for(n=0; n<C_GOK; n++)
+			xcmp[i][n] = cmp(n, i);
+	for(n=0; optab[n].as != AXXX; n++)
+		if((optab[n].flag & V4) && !armv4) {
+			optab[n].as = AXXX;
+			break;
+		}
+	qsort(optab, n, sizeof(optab[0]), ocmp);
+	for(i=0; i<n; i++) {
+		r = optab[i].as;
+		oprange[r].start = optab+i;
+		while(optab[i].as == r)
+			i++;
+		oprange[r].stop = optab+i;
+		i--;
+
+		switch(r)
+		{
+		default:
+			diag("unknown op in build: %A", r);
+			errorexit();
+		case AADD:
+			oprange[AAND] = oprange[r];
+			oprange[AEOR] = oprange[r];
+			oprange[ASUB] = oprange[r];
+			oprange[ARSB] = oprange[r];
+			oprange[AADC] = oprange[r];
+			oprange[ASBC] = oprange[r];
+			oprange[ARSC] = oprange[r];
+			oprange[AORR] = oprange[r];
+			oprange[ABIC] = oprange[r];
+			break;
+		case ACMP:
+			oprange[ATST] = oprange[r];
+			oprange[ATEQ] = oprange[r];
+			oprange[ACMN] = oprange[r];
+			break;
+		case AMVN:
+			break;
+		case ABEQ:
+			oprange[ABNE] = oprange[r];
+			oprange[ABCS] = oprange[r];
+			oprange[ABHS] = oprange[r];
+			oprange[ABCC] = oprange[r];
+			oprange[ABLO] = oprange[r];
+			oprange[ABMI] = oprange[r];
+			oprange[ABPL] = oprange[r];
+			oprange[ABVS] = oprange[r];
+			oprange[ABVC] = oprange[r];
+			oprange[ABHI] = oprange[r];
+			oprange[ABLS] = oprange[r];
+			oprange[ABGE] = oprange[r];
+			oprange[ABLT] = oprange[r];
+			oprange[ABGT] = oprange[r];
+			oprange[ABLE] = oprange[r];
+			break;
+		case ASLL:
+			oprange[ASRL] = oprange[r];
+			oprange[ASRA] = oprange[r];
+			break;
+		case AMUL:
+			oprange[AMULU] = oprange[r];
+			break;
+		case ADIV:
+			oprange[AMOD] = oprange[r];
+			oprange[AMODU] = oprange[r];
+			oprange[ADIVU] = oprange[r];
+			break;
+		case AMOVW:
+		case AMOVB:
+		case AMOVBU:
+		case AMOVH:
+		case AMOVHU:
+			break;
+		case ASWPW:
+			oprange[ASWPBU] = oprange[r];
+			break;
+		case AB:
+		case ABL:
+		case ABX:
+		case ABXRET:
+		case ASWI:
+		case AWORD:
+		case AMOVM:
+		case ARFE:
+		case ATEXT:
+		case ACASE:
+		case ABCASE:
+			break;
+		case AADDF:
+			oprange[AADDD] = oprange[r];
+			oprange[ASUBF] = oprange[r];
+			oprange[ASUBD] = oprange[r];
+			oprange[AMULF] = oprange[r];
+			oprange[AMULD] = oprange[r];
+			oprange[ADIVF] = oprange[r];
+			oprange[ADIVD] = oprange[r];
+			oprange[AMOVFD] = oprange[r];
+			oprange[AMOVDF] = oprange[r];
+			break;
+			
+		case ACMPF:
+			oprange[ACMPD] = oprange[r];
+			break;
+
+		case AMOVF:
+			oprange[AMOVD] = oprange[r];
+			break;
+
+		case AMOVFW:
+			oprange[AMOVWF] = oprange[r];
+			oprange[AMOVWD] = oprange[r];
+			oprange[AMOVDW] = oprange[r];
+			break;
+
+		case AMULL:
+			oprange[AMULA] = oprange[r];
+			oprange[AMULAL] = oprange[r];
+			oprange[AMULLU] = oprange[r];
+			oprange[AMULALU] = oprange[r];
+			break;
+		}
+	}
+}
+
+/*
+void
+buildrep(int x, int as)
+{
+	Opcross *p;
+	Optab *e, *s, *o;
+	int a1, a2, a3, n;
+
+	if(C_NONE != 0 || C_REG != 1 || C_GOK >= 32 || x >= nelem(opcross)) {
+		diag("assumptions fail in buildrep");
+		errorexit();
+	}
+	repop[as] = x;
+	p = (opcross + x);
+	s = oprange[as].start;
+	e = oprange[as].stop;
+	for(o=e-1; o>=s; o--) {
+		n = o-optab;
+		for(a2=0; a2<2; a2++) {
+			if(a2) {
+				if(o->a2 == C_NONE)
+					continue;
+			} else
+				if(o->a2 != C_NONE)
+					continue;
+			for(a1=0; a1<32; a1++) {
+				if(!xcmp[a1][o->a1])
+					continue;
+				for(a3=0; a3<32; a3++)
+					if(xcmp[a3][o->a3])
+						(*p)[a1][a2][a3] = n;
+			}
+		}
+	}
+	oprange[as].start = 0;
+}
+*/
+
+enum{
+	ABSD = 0,
+	ABSU = 1,
+	RELD = 2,
+	RELU = 3,
+};
+
+int modemap[4] = { 0, 1, -1, 2, };
+
+typedef struct Reloc Reloc;
+
+struct Reloc
+{
+	int n;
+	int t;
+	uchar *m;
+	ulong *a;
+};
+
+Reloc rels;
+
+static void
+grow(Reloc *r)
+{
+	int t;
+	uchar *m, *nm;
+	ulong *a, *na;
+
+	t = r->t;
+	r->t += 64;
+	m = r->m;
+	a = r->a;
+	r->m = nm = malloc(r->t*sizeof(uchar));
+	r->a = na = malloc(r->t*sizeof(ulong));
+	memmove(nm, m, t*sizeof(uchar));
+	memmove(na, a, t*sizeof(ulong));
+	free(m);
+	free(a);
+}
+
+void
+dynreloc(Sym *s, long v, int abs)
+{
+	int i, k, n;
+	uchar *m;
+	ulong *a;
+	Reloc *r;
+
+	if(v&3)
+		diag("bad relocation address");
+	v >>= 2;
+	if(s != S && s->type == SUNDEF)
+		k = abs ? ABSU : RELU;
+	else
+		k = abs ? ABSD : RELD;
+	/* Bprint(&bso, "R %s a=%ld(%lx) %d\n", s->name, a, a, k); */
+	k = modemap[k];
+	r = &rels;
+	n = r->n;
+	if(n >= r->t)
+		grow(r);
+	m = r->m;
+	a = r->a;
+	for(i = n; i > 0; i--){
+		if(v < a[i-1]){	/* happens occasionally for data */
+			m[i] = m[i-1];
+			a[i] = a[i-1];
+		}
+		else
+			break;
+	}
+	m[i] = k;
+	a[i] = v;
+	r->n++;
+}
+
+static int
+sput(char *s)
+{
+	char *p;
+
+	p = s;
+	while(*s)
+		cput(*s++);
+	cput(0);
+	return  s-p+1;
+}
+
+void
+asmdyn()
+{
+	int i, n, t, c;
+	Sym *s;
+	ulong la, ra, *a;
+	vlong off;
+	uchar *m;
+	Reloc *r;
+
+	cflush();
+	off = seek(cout, 0, 1);
+	lput(0);
+	t = 0;
+	lput(imports);
+	t += 4;
+	for(i = 0; i < NHASH; i++)
+		for(s = hash[i]; s != S; s = s->link)
+			if(s->type == SUNDEF){
+				lput(s->sig);
+				t += 4;
+				t += sput(s->name);
+			}
+	
+	la = 0;
+	r = &rels;
+	n = r->n;
+	m = r->m;
+	a = r->a;
+	lput(n);
+	t += 4;
+	for(i = 0; i < n; i++){
+		ra = *a-la;
+		if(*a < la)
+			diag("bad relocation order");
+		if(ra < 256)
+			c = 0;
+		else if(ra < 65536)
+			c = 1;
+		else
+			c = 2;
+		cput((c<<6)|*m++);
+		t++;
+		if(c == 0){
+			cput(ra);
+			t++;
+		}
+		else if(c == 1){
+			wput(ra);
+			t += 2;
+		}
+		else{
+			lput(ra);
+			t += 4;
+		}
+		la = *a++;
+	}
+
+	cflush();
+	seek(cout, off, 0);
+	lput(t);
+
+	if(debug['v']){
+		Bprint(&bso, "import table entries = %d\n", imports);
+		Bprint(&bso, "export table entries = %d\n", exports);
+	}
+}
diff --git a/src/cmd/5l/thumb.c b/src/cmd/5l/thumb.c
new file mode 100644
index 0000000000..e7ddbe5363
--- /dev/null
+++ b/src/cmd/5l/thumb.c
@@ -0,0 +1,1667 @@
+// Inferno utils/5l/thumb.c
+// http://code.google.com/p/inferno-os/source/browse/utils/5l/thumb.c
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#include "l.h"
+
+static long thumboprr(int);
+static long thumboprrr(int, int);
+static long thumbopirr(int , int);
+static long thumbopri(int);
+static long thumbophh(int);
+static long thumbopbra(int);
+static long thumbopmv(int, int);
+static void lowreg(Prog *, int);
+static void mult(Prog *, int, int);
+static void numr(Prog *, int, int, int);
+static void regis(Prog *, int, int, int);
+static void dis(int, int);
+
+// build a constant using neg, add and shift - only worth it if < 6 bytes */
+static int
+immbuildcon(int c, Prog *p)
+{
+	int n = 0;
+
+	USED(p);
+	if(c >= 0 && c <= 255)
+		return 0;			// mv
+	if(c >= -255 && c < 0)	// mv, neg
+		return 1;
+	if(c >= 256 && c <= 510)	// mv, add
+		return 1;
+	if(c < 0)
+		return 0;
+	while(!(c & 1)){
+		n++;
+		c >>= 1;
+	}
+	if(c >= 0 && c <= 255)	// mv, lsl
+		return 1;
+	return 0;
+}
+
+// positive 5 bit offset from register - O(R)
+// positive 8 bit offset from register - mov O, R then [R, R]
+// otherwise O goes in literal pool - mov O1(PC), R then [R, R]
+static int
+immoreg(int off, Prog *p)
+{
+	int v = 1;
+	int as = p->as;
+
+	if(off < 0)
+		return C_GOREG;
+	if(as == AMOVW)
+		v = 4;
+	else if(as == AMOVH || as == AMOVHU)
+		v = 2;
+	else if(as == AMOVB || as == AMOVBU)
+		v = 1;
+	else
+		diag("bad op in immoreg");
+	if(off/v <= 31)
+		return C_SOREG;
+	if(off <= 255)
+		return C_LOREG;
+	return C_GOREG;
+}
+
+// positive 8 bit - mov O, R then 0(R)
+// otherwise O goes in literal pool - mov O1(PC), R then 0(R)
+static int
+immacon(int off, Prog *p, int t1, int t2)
+{
+	USED(p);
+	if(off < 0)
+		return t2;
+	if(off <= 255)
+		return t1;
+	return t2;
+}
+
+// unsigned 8 bit in words
+static int
+immauto(int off, Prog *p)
+{
+	if(p->as != AMOVW)
+		diag("bad op in immauto");
+	mult(p, off, 4);
+	if(off >= 0 && off <= 1020)
+		return C_SAUTO;
+	return C_LAUTO;
+}
+
+static int
+immsmall(int off, Prog *p, int t1, int t2, int t3)
+{
+	USED(p);
+	if(off >= 0 && off <= 7)
+		return t1;
+	if(off >= 0 && off <= 255)
+		return t2;
+	return t3;
+}
+
+static int
+immcon(int off, Prog *p)
+{
+	int as = p->as;
+
+	if(as == ASLL || as == ASRL || as == ASRA)
+		return C_SCON;
+	if(p->to.type == D_REG && p->to.reg == REGSP){
+		if(as == AADD || as == ASUB){
+			if(off >= 0 && off <= 508)
+				return C_SCON;
+			if(as == ASUB){
+				p->as = AADD;
+				p->from.offset = -p->from.offset;
+			}
+			return C_LCON;
+		}
+		diag("unknown type in immcon");
+	}
+	if(as == AADD || as == ASUB){
+		if(p->reg != NREG)
+			return immsmall(off, p, C_SCON, C_LCON, C_GCON);
+		return immacon(off, p, C_SCON, C_LCON);
+	}
+	if(as == AMOVW && p->from.type == D_CONST && p->to.type == D_REG && immbuildcon(off, p))
+		return C_BCON;
+	if(as == ACMP && p->from.type == D_CONST && immbuildcon(off, p))
+		return C_BCON;
+	if(as == ACMP || as == AMOVW)
+		return immacon(off, p, C_SCON, C_LCON);
+	return C_LCON;
+}
+
+int
+thumbaclass(Adr *a, Prog *p)
+{
+	Sym *s;
+	int t;
+
+	switch(a->type) {
+	case D_NONE:
+		return C_NONE;
+	case D_REG:
+		if(a->reg == REGSP)
+			return C_SP;
+		if(a->reg == REGPC)
+			return C_PC;
+		if(a->reg >= 8)
+			return C_HREG;
+		return C_REG;
+	case D_SHIFT:
+		diag("D_SHIFT in thumbaclass");
+		return C_SHIFT;
+	case D_FREG:
+		diag("D_FREG in thumbaclass");
+		return C_FREG;
+	case D_FPCR:
+		diag("D_FPCR in thumbaclass");
+		return C_FCR;
+	case D_OREG:
+		switch(a->name) {
+		case D_EXTERN:
+		case D_STATIC:
+			if(a->sym == 0 || a->sym->name == 0) {
+				print("null sym external\n");
+				print("%D\n", a);
+				return C_GOK;
+			}
+			t = a->sym->type;
+			if(t == 0 || t == SXREF) {
+				diag("undefined external: %s in %s\n",
+					a->sym->name, TNAME);
+				a->sym->type = SDATA;
+			}
+			instoffset = a->sym->value + a->offset + INITDAT;
+			return C_LEXT;	/* INITDAT unknown at this stage */
+			// return immacon(instoffset, p, C_SEXT, C_LEXT);
+		case D_AUTO:
+			instoffset = autosize + a->offset;
+			return immauto(instoffset, p);
+		case D_PARAM:
+			instoffset = autosize + a->offset + 4L;
+// print("D_PARAM %s %d+%d+%d = %d\n", a->sym != S ? a->sym->name : "noname", autosize, a->offset, 4, autosize+a->offset+4);
+			return immauto(instoffset, p);
+		case D_NONE:
+			instoffset = a->offset;
+			if(a->reg == REGSP)
+				return immauto(instoffset, p);
+			else
+				return immoreg(instoffset, p);
+		}
+		return C_GOK;
+	case D_PSR:
+		diag("D_PSR in thumbaclass");
+		return C_PSR;
+	case D_OCONST:
+		switch(a->name) {
+		case D_EXTERN:
+		case D_STATIC:
+			s = a->sym;
+			t = s->type;
+			if(t == 0 || t == SXREF) {
+				diag("undefined external: %s in %s\n",
+					s->name, TNAME);
+				s->type = SDATA;
+			}
+			instoffset = s->value + a->offset + INITDAT;
+			if(s->type == STEXT || s->type == SLEAF){
+				instoffset = s->value + a->offset;
+#ifdef CALLEEBX
+				instoffset += fnpinc(s);
+#else
+				if(s->thumb)
+					instoffset++;	// T bit
+#endif
+				return C_LCON;
+			}
+			return C_LCON;	/* INITDAT unknown at this stage */
+			// return immcon(instoffset, p);
+		}
+		return C_GOK;
+	case D_FCONST:
+		diag("D_FCONST in thumaclass");
+		return C_FCON;
+	case D_CONST:
+		switch(a->name) {
+		case D_NONE:
+			instoffset = a->offset;
+			if(a->reg != NREG)
+				goto aconsize;
+			return immcon(instoffset, p);
+		case D_EXTERN:
+		case D_STATIC:
+			s = a->sym;
+			if(s == S)
+				break;
+			t = s->type;
+			switch(t) {
+			case 0:
+			case SXREF:
+				diag("undefined external: %s in %s\n",
+					s->name, TNAME);
+				s->type = SDATA;
+				break;
+			case SCONST:
+			case STEXT:
+			case SLEAF:
+				instoffset = s->value + a->offset;
+#ifdef CALLEEBX
+				instoffset += fnpinc(s);
+#else
+				if(s->thumb)
+					instoffset++;	// T bit
+#endif
+				return C_LCON;
+			}
+			instoffset = s->value + a->offset + INITDAT;
+			return C_LCON;	/* INITDAT unknown at this stage */
+			// return immcon(instoffset, p);
+		case D_AUTO:
+			instoffset = autosize + a->offset;
+			goto aconsize;
+		case D_PARAM:
+			instoffset = autosize + a->offset + 4L;
+		aconsize:
+			if(p->from.reg == REGSP || p->from.reg == NREG)
+				return instoffset >= 0 && instoffset < 1024 ? C_SACON : C_GACON;
+			else if(p->from.reg == p->to.reg)
+				return immacon(instoffset, p, C_SACON, C_GACON);
+			return immsmall(instoffset, p, C_SACON, C_LACON, C_GACON);
+		}
+		return C_GOK;
+	case D_BRANCH: {
+		int v, va;
+
+		p->align = 0;
+		v = -4;
+		va = 0;
+		if(p->cond != P){
+			v = (p->cond->pc - p->pc) - 4;
+			va = p->cond->pc;
+		}
+		instoffset = v;
+		if(p->as == AB){
+			if(v >= -2048 && v <= 2046)
+				return C_SBRA;
+			p->align = 4;
+			instoffset = va;
+			return C_LBRA;
+		}
+		if(p->as == ABL){
+#ifdef CALLEEBX
+			int e;
+
+			if((e = fninc(p->to.sym))) {
+				v += e;
+				va += e;
+				instoffset += e;
+			}		
+#endif
+			if(v >= -4194304 && v <= 4194302)
+				return C_SBRA;
+			p->align = 2;
+			instoffset = va;
+			return C_LBRA;
+		}
+		if(p->as == ABX){
+			v = va;
+			if(v >= 0 && v <= 255)
+				return C_SBRA;
+			p->align = 2;
+			instoffset = va;
+			return C_LBRA;
+		}
+		if(v >= -256 && v <= 254)
+			return C_SBRA;
+		if(v >= -(2048-2) && v <= (2046+2))
+			return C_LBRA;
+		p->align = 2;
+		instoffset = va;
+		return C_GBRA;
+	}
+	}
+	return C_GOK;
+}
+
+// as a1 a2 a3 type size param lit vers
+Optab thumboptab[] =
+{
+	{ ATEXT,		C_LEXT,		C_NONE,		C_LCON,		0,	0,	0 },
+	{ ATEXT,		C_LEXT,		C_REG,		C_LCON,		0,	0,	0 },
+	{ AMVN,		C_REG,		C_NONE,		C_REG,		1,	2,	0 },
+	{ ASRL,		C_REG,		C_NONE,		C_REG,		1,	2,	0 },
+	{ ACMP,		C_REG,		C_REG,		C_NONE,		1,	2,	0 },
+	{ ACMN,		C_REG,		C_REG,		C_NONE,		1,	2,	0 },
+	{ AADD,		C_REG,		C_REG,		C_REG,		2,	2,	0 },
+	{ AADD,		C_REG,		C_NONE,		C_REG,		2,	2,	0 },
+	{ AADD,		C_SCON,		C_REG,		C_REG,		3,	2,	0 },
+	{ AADD,		C_LCON,		C_REG,		C_REG,		49,	4,	0 },
+	{ AADD,		C_GCON,		C_REG,		C_REG,		36,	4,	0,	LFROM },
+	// { AADD,		C_LCON,		C_NONE,		C_REG,		3,	2,	0,	LFROM },
+	{ ASRL,		C_SCON,		C_REG,		C_REG,		4,	2,	0 },
+	{ ASRL,		C_SCON,		C_NONE,		C_REG,		4,	2,	0 },
+	{ AADD,		C_SCON,		C_NONE,		C_REG,		5,	2,	0 },
+	{ AADD,		C_LCON,		C_NONE,		C_REG,		37,	4,	0,	LFROM },
+	{ ACMP,		C_SCON,		C_REG,		C_NONE,		5,	2,	0 },
+	{ ACMP,		C_BCON,		C_REG,		C_NONE,		48,	6,	0 },
+	{ ACMP,		C_LCON,		C_REG,		C_NONE,		39,	4,	0,	LFROM },
+	{ AMOVW,		C_SCON,		C_NONE,		C_REG,		5,	2,	0 },
+	{ AMOVW,		C_BCON,		C_NONE,		C_REG,		47,	4,	0 },
+	{ AMOVW,		C_LCON,		C_NONE,		C_REG,		38,	2,	0,	LFROM },
+	// { AADD,		C_LCON,		C_PC,		C_REG,		6,	2,	0,	LFROM },
+	// { AADD,		C_LCON,		C_SP,		C_REG,		6,	2,	0,	LFROM },
+	{ AADD,		C_SCON,		C_NONE,		C_SP,		7,	2,	0 },
+	{ AADD,		C_LCON,		C_NONE,		C_SP,		40,	4,	0,	LFROM },
+	{ AADD,		C_REG,		C_NONE,		C_HREG,		8,	2,	0 },
+	{ AADD,		C_HREG,		C_NONE,		C_REG,		8,	2,	0 },
+	{ AADD,		C_HREG,		C_NONE,		C_HREG,		8,	2,	0 },
+	{ AMOVW,		C_REG,		C_NONE,		C_HREG,		8,	2,	0 },
+	{ AMOVW,		C_HREG,		C_NONE,		C_REG,		8,	2,	0 },
+	{ AMOVW,		C_HREG,		C_NONE,		C_HREG,		8,	2,	0 },
+	{ ACMP,		C_REG,		C_HREG,		C_NONE,		8,	2,	0 },
+	{ ACMP,		C_HREG,		C_REG,		C_NONE,		8,	2,	0 },
+	{ ACMP,		C_HREG,		C_HREG,		C_NONE,		8,	2,	0 },
+	{ AB,			C_NONE,		C_NONE,		C_SBRA,		9,	2,	0,	LPOOL },
+	{ ABEQ,		C_NONE,		C_NONE,		C_SBRA,		10,	2,	0 },
+	{ ABL,		C_NONE,		C_NONE,		C_SBRA,		11,	4,	0 },
+	{ ABX,		C_NONE,		C_NONE,		C_SBRA,		12,	10,	0 },
+	{ AB,			C_NONE,		C_NONE,		C_LBRA,		41,	8,	0,	LPOOL },
+	{ ABEQ,		C_NONE,		C_NONE,		C_LBRA,		46,	4,	0 },
+	{ ABL,		C_NONE,		C_NONE,		C_LBRA,		43,	14,	0 },
+	{ ABX,		C_NONE,		C_NONE,		C_LBRA,		44,	14,	0 },
+	{ ABEQ,		C_NONE,		C_NONE,		C_GBRA,		42,  10, 	0 },
+	// { AB,		C_NONE,		C_NONE,		C_SOREG,		13,	0,	0 },
+	// { ABL,		C_NONE,		C_NONE,		C_SOREG,		14,	0,	0 },
+	{ ABL,		C_NONE,		C_NONE,		C_REG,		51,	4,	0 },
+	{ ABX,		C_NONE,		C_NONE,		C_REG,		15,	8,	0 },
+	{ ABX,		C_NONE,		C_NONE,		C_HREG,		15,	8,	0 },
+	{ ABXRET,		C_NONE,		C_NONE,		C_REG,		45,	2,	0 },
+	{ ABXRET,		C_NONE,		C_NONE,		C_HREG,		45,	2,	0 },
+	{ ASWI,		C_NONE,		C_NONE,		C_LCON,		16,	2,	0 },
+	{ AWORD,		C_NONE,		C_NONE,		C_LCON,		17,	4,	0 },
+	{ AWORD,		C_NONE,		C_NONE,		C_GCON,		17,	4,	0 },
+	{ AWORD,		C_NONE,		C_NONE,		C_LEXT,		17,	4, 	0 },
+	{ ADWORD,	C_LCON,		C_NONE,		C_LCON,		50,	8,	0 },
+	{ AMOVW,		C_SAUTO,		C_NONE,		C_REG,		18,	2,	REGSP },
+	{ AMOVW,		C_LAUTO,		C_NONE,		C_REG,		33,	6,	0,	LFROM  },
+	// { AMOVW,		C_OFFPC,		C_NONE,		C_REG,		18,	2,	REGPC,	LFROM  },
+	{ AMOVW,		C_SEXT,		C_NONE,		C_REG,		30,	4,	0 },
+	{ AMOVW,		C_SOREG,		C_NONE,		C_REG,		19,	2,	0 },
+	{ AMOVHU,	C_SEXT,		C_NONE,		C_REG,		30,	4,	0 },
+	{ AMOVHU,	C_SOREG,		C_NONE,		C_REG,		19,	2,	0 },
+	{ AMOVBU,	C_SEXT,		C_NONE,		C_REG,		30,	4,	0 },
+	{ AMOVBU,	C_SOREG,		C_NONE,		C_REG,		19,	2,	0 },
+	{ AMOVW,		C_REG,		C_NONE,		C_SAUTO,		20,	2,	0 },
+	{ AMOVW,		C_REG,		C_NONE,		C_LAUTO,		34,	6,	0,	LTO },
+	{ AMOVW,		C_REG,		C_NONE,		C_SEXT,		31,	4,	0 },
+	{ AMOVW,		C_REG,		C_NONE,		C_SOREG,		21,	2,	0 },
+	{ AMOVH,		C_REG,		C_NONE,		C_SEXT,		31,	4,	0 },
+	{ AMOVH,		C_REG,		C_NONE,		C_SOREG,		21,	2,	0 },
+	{ AMOVB,		C_REG,		C_NONE,		C_SEXT,		31,	4,	0 },
+	{ AMOVB,		C_REG,		C_NONE,		C_SOREG,		21,	2,	0 },
+	{ AMOVHU,	C_REG,		C_NONE,		C_SEXT,		31,	4,	0 },
+	{ AMOVHU,	C_REG,		C_NONE,		C_SOREG,		21,	2,	0 },
+	{ AMOVBU,	C_REG,		C_NONE,		C_SEXT,		31,	4,	0 },
+	{ AMOVBU,	C_REG,		C_NONE,		C_SOREG,		21,	2,	0 },
+	{ AMOVW,		C_REG,		C_NONE,		C_REG,		22,	2,	0 },
+	{ AMOVB,		C_REG,		C_NONE,		C_REG,		23,	4,	0 },
+	{ AMOVH,		C_REG,		C_NONE,		C_REG,		23,	4,	0 },
+	{ AMOVBU,	C_REG,		C_NONE,		C_REG,		23,	4,	0 },
+	{ AMOVHU,	C_REG,		C_NONE,		C_REG,		23,	4,	0 },
+	{ AMOVH,		C_SEXT,		C_NONE,		C_REG,		32,	6,	0 },
+	{ AMOVH,		C_SOREG,		C_NONE,		C_REG,		24,	4,	0 },
+	{ AMOVB,		C_SEXT,		C_NONE,		C_REG,		32,	6,	0 },
+	{ AMOVB,		C_SOREG,		C_NONE,		C_REG,		24,	4,	0 },
+	{ AMOVW,		C_SACON,	C_NONE,		C_REG,		25,	2,	0 },
+	{ AMOVW,		C_LACON,	C_NONE,		C_REG,		35,	4,	0 },
+	{ AMOVW,		C_GACON,	C_NONE,		C_REG,		35,	4,	0,	LFROM },
+	{ AMOVM,		C_LCON,		C_NONE,		C_REG,		26,	2,	0 },
+	{ AMOVM,		C_REG,		C_NONE,		C_LCON,		27,	2,	0 },
+	{ AMOVW,		C_LOREG,		C_NONE,		C_REG,		28,	4,	0 },
+	{ AMOVH,		C_LOREG,		C_NONE,		C_REG,		28,	4,	0 },
+	{ AMOVB,		C_LOREG,		C_NONE,		C_REG,		28,	4,	0 },
+	{ AMOVHU,	C_LOREG,		C_NONE,		C_REG,		28,	4,	0 },
+	{ AMOVBU,	C_LOREG,		C_NONE,		C_REG,		28,	4,	0 },
+	{ AMOVW,		C_REG,		C_NONE,		C_LOREG,		29,	4,	0 },
+	{ AMOVH,		C_REG,		C_NONE,		C_LOREG,		29,	4,	0 },
+	{ AMOVB,		C_REG,		C_NONE,		C_LOREG,		29,	4,	0 },
+	{ AMOVHU,	C_REG,		C_NONE,		C_LOREG,		29,	4,	0 },
+	{ AMOVBU,	C_REG,		C_NONE,		C_LOREG,		29,	4,	0 },
+	{ AMOVW,		C_GOREG,		C_NONE,		C_REG,		28,	4,	0,	LFROM },
+	{ AMOVH,		C_GOREG,		C_NONE,		C_REG,		28,	4,	0,	LFROM },
+	{ AMOVB,		C_GOREG,		C_NONE,		C_REG,		28,	4,	0,	LFROM },
+	{ AMOVHU,	C_GOREG,		C_NONE,		C_REG,		28,	4,	0,	LFROM },
+	{ AMOVBU,	C_GOREG,		C_NONE,		C_REG,		28,	4,	0,	LFROM },
+	{ AMOVW,		C_REG,		C_NONE,		C_GOREG,		29,	4,	0,	LTO },
+	{ AMOVH,		C_REG,		C_NONE,		C_GOREG,		29,	4,	0,	LTO },
+	{ AMOVB,		C_REG,		C_NONE,		C_GOREG,		29,	4,	0,	LTO },
+	{ AMOVHU,	C_REG,		C_NONE,		C_GOREG,		29,	4,	0,	LTO },
+	{ AMOVBU,	C_REG,		C_NONE,		C_GOREG,		29,	4,	0,	LTO },
+	{ AMOVW,		C_LEXT,		C_NONE,		C_REG,		30,	4,	0,	LFROM },
+	{ AMOVH,		C_LEXT,		C_NONE,		C_REG,		32,	6,	0,	LFROM },
+	{ AMOVB,		C_LEXT,		C_NONE,		C_REG,		32,	6,	0,	LFROM },
+	{ AMOVHU,	C_LEXT,		C_NONE,		C_REG,		30,	4,	0,	LFROM },
+	{ AMOVBU,	C_LEXT,		C_NONE,		C_REG,		30,	4,	0,	LFROM },
+	{ AMOVW,		C_REG,		C_NONE,		C_LEXT,		31,	4,	0,	LTO },
+	{ AMOVH,		C_REG,		C_NONE,		C_LEXT,		31,	4,	0,	LTO },
+	{ AMOVB,		C_REG,		C_NONE,		C_LEXT,		31,	4,	0,	LTO },
+	{ AMOVHU,	C_REG,		C_NONE,		C_LEXT,		31,	4,	0,	LTO },
+	{ AMOVBU,	C_REG,		C_NONE,		C_LEXT,		31,	4,	0,	LTO },
+
+	{ AXXX,		C_NONE,		C_NONE,		C_NONE,		0,	2,	0 },
+};
+
+#define OPCNTSZ	52
+int opcount[OPCNTSZ];
+
+// is this too pessimistic ?
+int
+brextra(Prog *p)
+{
+	int c;
+
+	// +2 is for padding
+	if(p->as == ATEXT)
+		return 0-0+2;
+	if(!isbranch(p))
+		diag("bad op in brextra()");
+	c = thumbaclass(&p->to, p);
+	switch(p->as){
+		case AB:
+			if(c != C_SBRA)
+				return 0;
+			return 8-2+2;
+		case ABL:
+			if(c != C_SBRA)
+				return 0;
+			return 14-4+2;
+		case ABX:
+			if(c == C_REG || c == C_HREG)
+				return 0;
+#ifdef CALLEEBX
+			diag("ABX $I in brextra");
+#endif
+			if(c != C_SBRA)
+				return 0;
+			return 14-10+2;
+		default:
+			if(c == C_GBRA)
+				return 0;
+			if(c == C_LBRA)
+				return 10-4+2;
+			return 10-2+2;
+	}
+	return 0;
+}
+
+#define high(r)	((r)>=8)
+
+static long
+mv(Prog *p, int r, int off)
+{
+	int v, o;
+	if(p != nil && p->cond != nil){	// in literal pool
+		v = p->cond->pc - p->pc - 4;
+		if(p->cond->pc & 3)
+			diag("mv: bad literal pool alignment");
+		if(v & 3)
+			v += 2;	// ensure M(4) offset
+		mult(p, v, 4);
+		off = v/4;
+		numr(p, off, 0, 255);
+		o = 0x9<<11;
+	}
+	else{
+		numr(p, off, 0, 255);
+		o = 0x4<<11;
+	}
+	o |= (r<<8) | off;
+	return o;
+}
+
+static void
+mvcon(Prog *p, int r, int c, long *o1, long *o2)
+{
+	int op = 0, n = 0;
+
+	if(c >= 0 && c <= 255)
+		diag("bad c in mvcon");
+	if(c >= -255 && c < 0)	// mv, neg
+		c = -c;
+	else if(c >= 256 && c <= 510){	// mv, add
+		n = rand()%(511-c) + (c-255);
+		c -= n;
+		// n = c-255;
+		// c = 255;
+		op = AADD;
+	}
+	else{
+		if(c < 0)
+			diag("-ve in mvcon");
+		while(!(c & 1)){
+			n++;
+			c >>= 1;
+		}
+		if(c >= 0 && c <= 255)	// mv, lsl
+			op = ASLL;
+		else
+			diag("bad shift in mvcon");
+	}
+	*o1 = mv(p, r, c);
+	switch(op){
+		case 0:
+			*o2 = (1<<14) | (9<<6) | (r<<3) | r;
+			break;
+		case AADD:
+			*o2 = (6<<11) | (r<<8) | n;
+			break;
+		case ASLL:
+			*o2 = (n<<6) | (r<<3) | r;
+			break;
+	}
+}
+
+static long
+mvlh(int rs, int rd)
+{
+	int o = 0x46<<8;
+
+	if(high(rs)){
+		rs -= 8;
+		o |= 1<<6;
+	}
+	if(high(rd)){
+		rd -= 8;
+		o |= 1<<7;
+	}
+	o |= (rs<<3) | rd;
+	return o;
+}
+
+void
+thumbbuildop()
+{
+	int i, n, r;
+	Optab *optab = thumboptab;
+	Oprang *oprange = thumboprange;
+
+	for(n=0; optab[n].as != AXXX; n++)
+		;
+	qsort(optab, n, sizeof(optab[0]), ocmp);
+	for(i=0; i<n; i++) {
+		r = optab[i].as;
+		oprange[r].start = optab+i;
+		while(optab[i].as == r)
+			i++;
+		oprange[r].stop = optab+i;
+		i--;
+
+		switch(r)
+		{
+		default:
+			break;
+		case ABEQ:
+			oprange[ABNE] = oprange[r];
+			oprange[ABCS] = oprange[r];
+			oprange[ABHS] = oprange[r];
+			oprange[ABCC] = oprange[r];
+			oprange[ABLO] = oprange[r];
+			oprange[ABMI] = oprange[r];
+			oprange[ABPL] = oprange[r];
+			oprange[ABVS] = oprange[r];
+			oprange[ABVC] = oprange[r];
+			oprange[ABHI] = oprange[r];
+			oprange[ABLS] = oprange[r];
+			oprange[ABGE] = oprange[r];
+			oprange[ABLT] = oprange[r];
+			oprange[ABGT] = oprange[r];
+			oprange[ABLE] = oprange[r];
+			break;
+		case AMVN:
+			oprange[AADC] = oprange[r];
+			oprange[ASBC] = oprange[r];
+			oprange[AMUL] = oprange[r];
+			oprange[AAND] = oprange[r];
+			oprange[AEOR] = oprange[r];
+			oprange[AORR] = oprange[r];
+			oprange[ABIC] = oprange[r];
+			oprange[AMULU] = oprange[r];
+			break;
+		case ACMN:
+			oprange[ATST] = oprange[r];
+			break;
+		case ASRL:
+			oprange[ASRA] = oprange[r];
+			oprange[ASLL] = oprange[r];
+			break;
+		case AADD:
+			oprange[ASUB] = oprange[r];
+			break;
+		}
+	}
+}
+
+void
+thumbasmout(Prog *p, Optab *o)
+{
+	long o1, o2, o3, o4, o5, o6, o7, v;
+	int r, rf, rt;
+
+	rf = p->from.reg;
+	rt = p->to.reg;
+	r = p->reg;
+	o1 = o2 = o3 = o4 = o5 = o6 = o7 = 0;
+if(debug['P']) print("%ulx: %P	type %d %d\n", (ulong)(p->pc), p, o->type, p->align);
+	opcount[o->type] += o->size;
+	switch(o->type) {
+	default:
+		diag("unknown asm %d", o->type);
+		prasm(p);
+		break;
+	case 0:		/* pseudo ops */
+if(debug['G']) print("%ulx: %s: thumb\n", (ulong)(p->pc), p->from.sym->name);
+		break;
+	case 1:		/* op R, -, R or op R, R, - */
+		o1 = thumboprr(p->as);
+		if(rt == NREG)
+			rt = r;
+		lowreg(p, rf);
+		lowreg(p, rt);
+		o1 |= (0x10<<10) | (rf<<3) | rt;
+		break;
+	case 2:		/* add/sub R, R, R or add/sub R, -, R */
+		o1 = p->as == AADD ? 0x0<<9 : 0x1<<9;
+		if(r == NREG)
+			r = rt;
+		lowreg(p, rf);
+		lowreg(p, r);
+		lowreg(p, rt);
+		o1 |= (0x6<<10) | (rf<<6) | (r<<3) | rt;
+		break;
+	case 3:		/* add/sub $I, R, R or add/sub $I, -, R */
+		thumbaclass(&p->from, p);
+		o1 = p->as == AADD ? 0x0<<9 : 0x1<<9;
+		if(r == NREG)
+			r = rt;
+		numr(p, instoffset, 0, 7);
+		lowreg(p, r);
+		lowreg(p, rt);
+		o1 |= (0x7<<10) | (instoffset<<6) | (r<<3) | rt;
+		break;
+	case 4:		/* shift $I, R, R or shift $I, -, R */
+		thumbaclass(&p->from, p);
+		if(instoffset < 0)
+			diag("negative shift in thumbasmout");
+		instoffset %= 32;
+		o1 = thumbopri(p->as);
+		if(r == NREG)
+			r = rt;
+		numr(p, instoffset, 0, 31);
+		lowreg(p, r);
+		lowreg(p, rt);
+		o1 |= (0x0<<13) | (instoffset<<6) | (r<<3) | rt;
+		break;
+	case 5:		/* add/sub/mov $I, -, R or cmp $I, R, - */
+		thumbaclass(&p->from, p);
+		o1 = thumbopri(p->as);	
+		if(rt == NREG)
+			rt = r;
+		numr(p, instoffset, 0, 255);
+		lowreg(p, rt);
+		o1 |= (0x1<<13) | (rt<<8) | instoffset;
+		break;
+	case 6:		/* add $I, PC/SP, R */
+		if(p->as == ASUB)
+			diag("subtract in add $I, PC/SP, R");
+		thumbaclass(&p->from, p);
+		o1 = r == REGSP ? 0x1<<11 : 0x0<<11;
+		numr(p, instoffset, 0, 255);
+		regis(p, r, REGSP, REGPC);
+		lowreg(p, rt);
+		o1 |= (0xa<<12) | (rt<<8) | instoffset;
+		break;
+	case 7:		/* add, sub $I, SP */
+		thumbaclass(&p->from, p);
+		o1 = p->as == AADD ? 0x0<<7 : 0x1<<7;
+		numr(p, instoffset, 0, 508);
+		mult(p, instoffset, 4);
+		regis(p, rt, REGSP, REGSP);
+		o1 |= (0xb0<<8) | (instoffset>>2);
+		break;
+	case 8:		/* add/mov/cmp R, R where at least 1 reg is high */
+		o1 = 0;
+		if(rt == NREG)
+			rt = r;
+		if(high(rf)){
+			o1 |= 1<<6;
+			rf -= 8;
+		}
+		if(high(rt)){
+			o1 |= 2<<6;
+			rt -= 8;
+		}
+		if(o1 == 0)
+			diag("no high register(%P)", p);
+		o1 |= thumbophh(p->as);
+		o1 |= (0x11<<10) | (rf<<3) | rt;
+		break;
+	case 9:		/* B	$I */
+		thumbaclass(&p->to, p);
+		numr(p, instoffset, -2048, 2046);
+		o1 = (0x1c<<11) | ((instoffset>>1)&0x7ff);
+		break;
+	case 10:		/* Bcc $I */
+		thumbaclass(&p->to, p);
+		numr(p, instoffset, -256, 254);
+		o1 = thumbopbra(p->as);
+		o1 |= (0xd<<12) | ((instoffset>>1)&0xff);
+		break;
+	case 11:		/* BL $I */
+		thumbaclass(&p->to, p);
+		numr(p, instoffset, -4194304, 4194302);
+		o1 = (0x1e<<11) | ((instoffset>>12)&0x7ff);
+		o2 = (0x1f<<11) | ((instoffset>>1)&0x7ff);
+		break;
+	case 12:		/* BX $I */
+#ifdef CALLEEBX
+		diag("BX $I case");
+#endif
+		thumbaclass(&p->to, p);
+		if(p->to.sym->thumb)
+			instoffset  |= 1;	// T bit
+		o1 = mvlh(REGPC, REGTMPT);
+		o2 = (0x6<<11) | (REGTMPT<<8) | 7;	// add 7, RTMP	(T bit + PC offset)
+		o3 = mvlh(REGTMPT, REGLINK);
+		o4 = mv(nil, REGTMPT, instoffset);
+		o5 = (0x11c<<6) | (REGTMPT<<3);
+		// o1 = mv(nil, REGTMPT, v);
+		// o2 = (0x11b<<6) | (REGPC<<3) | REGLINK;
+		// o3 = (0x11c<<6) | (REGTMPT<<3);
+		break;
+	case 13:		/* B O(R)  */
+		diag("B O(R)");
+		break;
+	case 14:		/* BL O(R) */
+		diag("BL O(R)");
+		break;
+	case 15:		/* BX R */
+		o1 = mvlh(REGPC, REGTMPT);
+		o2 = (0x6<<11) | (REGTMPT<<8) | 5;	// add 5, RTMP (T bit + PC offset)
+		o3 = mvlh(REGTMPT, REGLINK);
+		o4 = 0;
+		if(high(rt)){
+			rt -= 8;
+			o4 |= 1<<6;
+		}
+		o4 |= (0x8e<<7) | (rt<<3);
+		// o1 = (0x11c<<6) | (rt<<3);
+		break;
+	case 16:		/* SWI $I */
+		thumbaclass(&p->to, p);
+		numr(p, instoffset, 0, 255);
+		o1 = (0xdf<<8) | instoffset;
+		break;
+	case 17:		/* AWORD */
+		thumbaclass(&p->to, p);
+		o1 = instoffset&0xffff;
+		o2 = (instoffset>>16)&0xffff;
+		break;
+	case 18:		/* AMOVW O(SP), R and AMOVW O(PC), R */
+		thumbaclass(&p->from, p);
+		rf = o->param;
+		o1 = rf == REGSP ? 0x13<<11 : 0x9<<11;
+		regis(p, rf, REGSP, REGPC);
+		lowreg(p, rt);
+		mult(p, instoffset, 4);
+		numr(p, instoffset/4, 0, 255);
+		o1 |= (rt<<8) | (instoffset/4);
+		break;
+	case 19:		/* AMOVW... O(R), R */
+		thumbaclass(&p->from, p);
+		o1 = thumbopmv(p->as, 1);
+		v = 4;
+		if(p->as == AMOVHU)
+			v = 2;
+		else if(p->as == AMOVBU)
+			v = 1;
+		mult(p, instoffset, v);
+		lowreg(p, rf);
+		lowreg(p, rt);
+		numr(p, instoffset/v, 0, 31);
+		o1 |= ((instoffset/v)<<6) | (rf<<3) | rt;
+		break;
+	case 20:		/* AMOVW R, O(SP) */
+		thumbaclass(&p->to, p);
+		o1 = 0x12<<11;
+		if(rt != NREG) regis(p, rt, REGSP, REGSP);
+		lowreg(p, rf);
+		mult(p, instoffset, 4);
+		numr(p, instoffset/4, 0, 255);
+		o1 |= (rf<<8) | (instoffset/4);
+		break;
+	case 21:		/* AMOVW... R, O(R) */
+		thumbaclass(&p->to, p);
+		o1 = thumbopmv(p->as, 0);
+		v = 4;
+		if(p->as == AMOVHU || p->as == AMOVH)
+			v = 2;
+		else if(p->as == AMOVBU || p->as == AMOVB)
+			v = 1;
+		lowreg(p, rf);
+		lowreg(p, rt);
+		mult(p, instoffset, v);
+		numr(p, instoffset/v, 0, 31);
+		o1 |= ((instoffset/v)<<6) | (rt<<3) | rf;
+		break;
+	case 22:		/* AMOVW R, R -> ASLL $0, R, R */
+		o1 = thumbopri(ASLL);
+		lowreg(p, rf);
+		lowreg(p, rt);
+		o1 |= (0x0<<13) | (rf<<3) | rt;
+		break;
+	case 23:		/* AMOVB/AMOVH/AMOVBU/AMOVHU R, R */
+		o1 = thumbopri(ASLL);
+		o2 = p->as == AMOVB || p->as == AMOVH ? thumbopri(ASRA) : thumbopri(ASRL);
+		v = p->as == AMOVB || p->as == AMOVBU ? 24 : 16;
+		lowreg(p, rf);
+		lowreg(p, rt);
+		o1 |= (0x0<<13) | (v<<6) | (rf<<3) | rt;
+		o2 |= (0x0<<13) | (v<<6) | (rt<<3) | rt;
+		break;
+	case 24:	/* AMOVH/AMOVB O(R), R -> AMOVH/AMOVB [R, R], R */
+		thumbaclass(&p->from, p);
+		lowreg(p, rf);
+		lowreg(p, rt);
+		if(rf == rt)
+			r = REGTMPT;
+		else
+			r = rt;
+		if(p->as == AMOVB)
+			numr(p, instoffset, 0, 31);
+		else{
+			mult(p, instoffset, 2);
+			numr(p, instoffset, 0, 62);
+		}
+		o1 = mv(p, r, instoffset);
+		o2 = p->as == AMOVH ? 0x2f<<9 : 0x2b<<9;
+		o2 |= (r<<6) | (rf<<3) | rt;
+		break;
+	case 25:	/* MOVW $sacon, R */
+		thumbaclass(&p->from, p);
+// print("25: %d %d %d %d\n", instoffset, rf, r, rt);
+		if(rf == NREG)
+			rf = REGSP;
+		lowreg(p, rt);
+		if(rf == REGSP){
+			mult(p, instoffset, 4);
+			numr(p, instoffset>>2, 0, 255);
+			o1 = (0x15<<11) | (rt<<8) | (instoffset>>2);	// add $O, SP, R
+		}
+		else if(rf == rt){
+			numr(p, instoffset, 0, 255);
+			o1 = (0x6<<11) | (rt<<8) | instoffset;		// add $O, R
+		}
+		else{
+			lowreg(p, rf);
+			numr(p, instoffset, 0, 7);
+			o1 = (0xe<<9) | (instoffset<<6) | (rf<<3) | rt;	// add $O, Rs, Rd
+		}
+		break;
+	case 26:	/* AMOVM $c, oreg -> stmia */
+		lowreg(p, rt);
+		numr(p, p->from.offset, -256, 255);
+		o1 = (0x18<<11) | (rt<<8) | (p->from.offset&0xff);
+		break;
+	case 27:	/* AMOVM oreg, $c ->ldmia */
+		lowreg(p, rf);
+		numr(p, p->to.offset, -256, 256);
+		o1 = (0x19<<11) | (rf<<8) | (p->to.offset&0xff);
+		break;
+	case 28:	/* AMOV* O(R), R -> AMOV* [R, R], R 	(offset large)	*/
+		thumbaclass(&p->from, p);
+		lowreg(p, rf);
+		lowreg(p, rt);
+		if(rf == rt)
+			r = REGTMPT;
+		else
+			r = rt;
+		o1 = mv(p, r, instoffset);
+		o2 = thumboprrr(p->as, 1);
+		o2 |= (r<<6) | (rf<<3) | rt;
+		break;
+	case 29:	/* AMOV* R, O(R) -> AMOV* R, [R, R]	(offset large)	*/
+		thumbaclass(&p->to, p);
+		lowreg(p, rf);
+		lowreg(p, rt);
+		if(rt == REGTMPT){	// used as tmp reg
+			if(instoffset >= 0 && instoffset <= 255){
+				o1 = (1<<13) | (2<<11) | (rt<<8) | instoffset;	// add $O, R7
+				o2 = thumbopirr(p->as, 0);
+				o2 |= (0<<6) | (rt<<3) | rf;					// mov* R, 0(R)
+			}
+			else
+				diag("big offset - case 29");
+		}
+		else{
+			o1 = mv(p, REGTMPT, instoffset);
+			o2 = thumboprrr(p->as, 0);
+			o2 |= (REGTMPT<<6) | (rt<<3) | rf;
+		}
+		break;
+	case 30:		/* AMOVW... *addr, R */
+		thumbaclass(&p->from, p);
+		o1 = mv(p, rt, instoffset);		// MOV addr, rtmp
+		o2 = thumbopmv(p->as, 1);
+		lowreg(p, rt);
+		o2 |= (rt<<3) | rt;			// MOV* 0(rtmp), R
+		break;
+	case 31:		/* AMOVW... R, *addr */
+		thumbaclass(&p->to, p);
+		o1 = mv(p, REGTMPT, instoffset);
+		o2 = thumbopmv(p->as, 0);
+		lowreg(p, rf);
+		o2 |= (REGTMPT<<3) | rf;
+		break;
+	case 32:	/* AMOVH/AMOVB *addr, R -> AMOVH/AMOVB [R, R], R */
+		thumbaclass(&p->from, p);
+		o1 = mv(p, rt, instoffset);
+		lowreg(p, rt);
+		o2 = mv(nil, REGTMPT, 0);
+		o3 = p->as == AMOVH ? 0x2f<<9 : 0x2b<<9;
+		o3 |= (REGTMPT<<6) | (rt<<3) | rt;
+		break;
+	case 33:	/* AMOVW O(SP), R	(O large) */
+		thumbaclass(&p->from, p);
+		lowreg(p, rt);
+		o1 = mv(p, rt, instoffset);
+		o2 = (0x111<<6) | (REGSP-8)<<3 | rt;	// add SP, rt
+		o3 = thumbopmv(p->as, 1);
+		o3 |= (rt<<3) | rt;
+		break;
+	case 34:	/* AMOVW R, O(SP)	(O large) */
+		thumbaclass(&p->to, p);
+		lowreg(p, rf);
+		o1 = mv(p, REGTMPT, instoffset);
+		o2 = (0x111<<6) | (REGSP-8)<<3 | REGTMPT;	// add SP, REGTMP
+		o3 = thumbopmv(p->as, 0);
+		o3 |= (REGTMPT<<3) | rf;
+		break;
+	case 35:	/* AMOVW $lacon, R */
+		thumbaclass(&p->from, p);
+		lowreg(p, rt);
+		if(rf == NREG)
+			rf = REGSP;
+		if(rf == rt)
+			rf = r = REGTMPT;
+		else
+			r = rt;
+// print("35: io=%d rf=%d rt=%d\n", instoffset, rf, rt);
+		o1 = mv(p, r, instoffset);		// mov O, Rd
+		if(high(rf))
+			o2 = (0x44<<8) | (0x1<<6) | ((rf-8)<<3) | rt;	// add Rs, Rd
+		else
+			o2 = (0x6<<10) | (rf<<6) | (rt<<3) | rt;		// add Rs, Rd
+		break;
+	case 36:	/* AADD/ASUB $i, r, r when $i too big */
+		thumbaclass(&p->from, p);
+		lowreg(p, r);
+		lowreg(p, rt);
+		o1 = mv(p, REGTMPT, instoffset);
+		o2 = p->as == AADD ? 0xc<<9 : 0xd<<9;
+		o2 |= (REGTMPT<<6) | (r<<3) | rt;
+		break;
+	case 37:	/* AADD/ASUB $i, r when $i too big */
+		thumbaclass(&p->from, p);
+		lowreg(p, rt);
+		o1 = mv(p, REGTMPT, instoffset);
+		o2 = p->as == AADD ? 0xc<<9 : 0xd<<9;
+		o2 |= (REGTMPT<<6) | (rt<<3) | rt;
+		break;
+	case 38:	/* AMOVW $i, r when $i too big */
+		thumbaclass(&p->from, p);
+		lowreg(p, rt);
+		o1 = mv(p, rt, instoffset);
+		break;
+	case 39:	/* ACMP $i, r when $i too big */
+		thumbaclass(&p->from, p);
+		lowreg(p, r);
+		o1 = mv(p, REGTMPT, instoffset);
+		o2 = (0x10a<<6) | (REGTMPT<<3) | r;
+		break;
+	case 40:		/* add, sub $I, SP when $I large*/
+		thumbaclass(&p->from, p);
+		if(p->as == ASUB)
+			instoffset = -instoffset;
+		o1 = mv(p, REGTMPT, instoffset);
+		o2 = (0x112<<6) | (REGTMPT<<3) | (REGSP-8);
+		regis(p, rt, REGSP, REGSP);
+		break;
+	case	41:		/* BL LBRA */
+		thumbaclass(&p->to, p);
+		o1 = (0x9<<11) | (REGTMPT<<8);	// mov 0(pc), r7
+		o2 = mvlh(REGTMPT, REGPC);		// mov r7, pc
+		o3 = instoffset&0xffff;			// $lab
+		o4 = (instoffset>>16)&0xffff;
+		break;
+	case 42:		/* Bcc GBRA */
+		thumbaclass(&p->to, p);
+		o1 = (0xd<<12) | thumbopbra(relinv(p->as)) | (6>>1);		// bccnot 
+		// ab lbra
+		o2 = (0x9<<11) | (REGTMPT<<8);	// mov 0(pc), r7
+		o3 = mvlh(REGTMPT, REGPC);		// mov r7, pc
+		o4 = instoffset&0xffff;			// $lab
+		o5 = (instoffset>>16)&0xffff;
+		break;
+	case 43:		/* BL LBRA */
+		thumbaclass(&p->to, p);
+		o1 = mvlh(REGPC, REGTMPT);						// mov pc, r7
+		o2 = (0x6<<11) | (REGTMPT<<8) | 10;				// add 10, r7
+		o3 = mvlh(REGTMPT, REGLINK);					// mov r7, lr
+		o4 = (0x9<<11) | (REGTMPT<<8);					// mov o(pc), r7
+		o5 = mvlh(REGTMPT, REGPC);						// mov r7, pc
+		o6 = instoffset&0xffff;							// $lab
+		o7 = (instoffset>>16)&0xffff;
+		break;
+	case 44:		/* BX LBRA */
+#ifdef CALLEEBX
+		diag("BX LBRA case");
+#endif
+		thumbaclass(&p->to, p);
+		if(p->to.sym->thumb)
+			instoffset  |= 1;	// T bit
+		o1 = mvlh(REGPC, REGTMPT);						// mov pc, r7
+		o2 = (0x6<<11) | (REGTMPT<<8) | 11;				// add 11, r7
+		o3 = mvlh(REGTMPT, REGLINK);					// mov r7, lr
+		o4 = (0x9<<11) | (REGTMPT<<8);					// mov o(pc), r7
+		o5 = (0x11c<<6) | (REGTMPT<<3);					// bx r7
+		o6 = instoffset&0xffff;							// $lab
+		o7 = (instoffset>>16)&0xffff;
+		break;
+	case 45:	/* BX R when returning from fn */
+		o1 = 0;
+		if(high(rt)){
+			rt -= 8;
+			o1 |= 1<<6;
+		}
+		o1 |= (0x8e<<7) | (rt<<3);
+		break;
+	case 46:		/* Bcc LBRA */
+		thumbaclass(&p->to, p);
+		o1 = (0xd<<12) | thumbopbra(relinv(p->as)) | (0>>1);		// bccnot 
+		// ab lbra
+		instoffset -= 2;
+		numr(p, instoffset, -2048, 2046);
+		o2 = (0x1c<<11) | ((instoffset>>1)&0x7ff);
+		break;
+	case 47:	/* mov $i, R where $i can be built */
+		thumbaclass(&p->from, p);
+		mvcon(p, rt, instoffset, &o1, &o2);
+		break;
+	case 48: /* ACMP $i, r when $i built up */
+		thumbaclass(&p->from, p);
+		lowreg(p, r);
+		mvcon(p, REGTMPT, instoffset, &o1, &o2);
+		o3 = (0x10a<<6) | (REGTMPT<<3) | r;
+		break;
+	case 49:	/* AADD $i, r, r when $i is between 0 and 255 - could merge with case 36 */
+		thumbaclass(&p->from, p);
+		lowreg(p, r);
+		lowreg(p, rt);
+		numr(p, instoffset, 0, 255);
+		o1 = mv(p, REGTMPT, instoffset);
+		o2 = p->as == AADD ? 0xc<<9 : 0xd<<9;
+		o2 |= (REGTMPT<<6) | (r<<3) | rt;
+		break;
+	case 50:		/* ADWORD */
+		thumbaclass(&p->from, p);
+		o1 = instoffset&0xffff;
+		o2 = (instoffset>>16)&0xffff;
+		thumbaclass(&p->to, p);
+		o3 = instoffset&0xffff;
+		o4 = (instoffset>>16)&0xffff;
+		break;
+	case 51:	/* BL r */
+		o1 = mvlh(REGPC, REGLINK);	// mov pc, lr
+		o2 = mvlh(rt, REGPC);		// mov r, pc
+		break;
+	}
+
+	v = p->pc;
+	switch(o->size) {
+	default:
+		if(debug['a'])
+			Bprint(&bso, " %.8lux:\t\t%P\n", v, p);
+		break;
+	case 2:
+		if(debug['a'])
+			Bprint(&bso, " %.8lux: %.8lux\t%P\n", v, o1, p);
+		hputl(o1);
+		break;
+	case 4:
+		if(debug['a'])
+			Bprint(&bso, " %.8lux: %.8lux %.8lux\t%P\n", v, o1, o2, p);
+		hputl(o1);
+		hputl(o2);
+		break;
+	case 6:
+		if(debug['a'])
+			Bprint(&bso, "%.8lux: %.8lux %.8lux %.8lux\t%P\n", v, o1, o2, o3, p);
+		hputl(o1);
+		hputl(o2);
+		hputl(o3);
+		break;
+	case 8:
+		if(debug['a'])
+			Bprint(&bso, "%.8lux: %.8lux %.8lux %.8lux %.8lux\t%P\n", v, o1, o2, o3, o4, p);
+		hputl(o1);
+		hputl(o2);
+		hputl(o3);
+		hputl(o4);
+		break;
+	case 10:
+		if(debug['a'])
+			Bprint(&bso, "%.8lux: %.8lux %.8lux %.8lux %.8lux %.8lux\t%P\n", v, o1, o2, o3, o4, o5, p);
+		hputl(o1);
+		hputl(o2);
+		hputl(o3);
+		hputl(o4);
+		hputl(o5);
+		break;
+	case 12:
+		if(debug['a'])
+			Bprint(&bso, "%.8lux: %.8lux %.8lux %.8lux %.8lux %.8lux %.8lux\t%P\n", v, o1, o2, o3, o4, o5, o6, p);
+		hputl(o1);
+		hputl(o2);
+		hputl(o3);
+		hputl(o4);
+		hputl(o5);
+		hputl(o6);
+		break;
+	case 14:
+		if(debug['a'])
+			Bprint(&bso, "%.8lux: %.8lux %.8lux %.8lux %.8lux %.8lux %.8lux %.8lux\t%P\n", v, o1, o2, o3, o4, o5, o6, o7, p);
+		hputl(o1);
+		hputl(o2);
+		hputl(o3);
+		hputl(o4);
+		hputl(o5);
+		hputl(o6);
+		hputl(o7);
+		break;
+	}
+	if(debug['G']){
+		if(o->type == 17){
+			print("%lx:	word %ld\n", p->pc, (o2<<16)+o1);
+			return;
+		}
+		if(o->type == 50){
+			print("%lx:	word %ld\n", p->pc, (o2<<16)+o1);
+			print("%lx:	word %ld\n", p->pc, (o4<<16)+o3);
+			return;
+		}
+		if(o->size > 0) dis(o1, p->pc);
+		if(o->size > 2) dis(o2, p->pc+2);
+		if(o->size > 4) dis(o3, p->pc+4);
+		if(o->size > 6) dis(o4, p->pc+6);
+		if(o->size > 8) dis(o5, p->pc+8);
+		if(o->size > 10) dis(o6, p->pc+10);
+		if(o->size > 12) dis(o7, p->pc+12);
+		// if(o->size > 14) dis(o8, p->pc+14);
+	}
+}
+
+static long
+thumboprr(int a)
+{
+	switch(a) {
+	case AMVN:	return 0xf<<6;
+	case ACMP:	return 0xa<<6;
+	case ACMN:	return 0xb<<6;
+	case ATST:	return 0x8<<6;
+	case AADC:	return 0x5<<6;
+	case ASBC:	return 0x6<<6;
+	case AMUL:
+	case AMULU:	return 0xd<<6;
+	case AAND:	return 0x0<<6;
+	case AEOR:	return 0x1<<6;
+	case AORR:	return 0xc<<6;
+	case ABIC:	return 0xe<<6;
+	case ASRL:	return 0x3<<6;
+	case ASRA:	return 0x4<<6;
+	case ASLL:	return 0x2<<6;
+	}
+	diag("bad thumbop oprr %d", a);
+	prasm(curp);
+	return 0;
+}
+
+static long
+thumbopirr(int a, int ld)
+{
+	if(ld)
+		diag("load in thumbopirr");
+	switch(a){
+		case AMOVW:	return 0xc<<11;
+		case AMOVH:
+		case AMOVHU:	return 0x10<<11;
+		case AMOVB:
+		case AMOVBU:	return 0xe<<11;
+	}
+	return 0;
+}
+	
+static long
+thumboprrr(int a, int ld)
+{
+	if(ld){
+		switch(a){
+		case AMOVW:	return 0x2c<<9;
+		case AMOVH:	return 0x2f<<9;
+		case AMOVB:	return 0x2b<<9;
+		case AMOVHU:	return 0x2d<<9;
+		case AMOVBU:	return 0x2e<<9;
+		}
+	}
+	else{
+		switch(a){
+		case AMOVW:	return 0x28<<9;
+		case AMOVHU:
+		case AMOVH:	return 0x29<<9;
+		case AMOVBU:
+		case AMOVB:	return 0x2a<<9;
+		}
+	}
+	diag("bad thumbop oprrr %d", a);
+	prasm(curp);
+	return 0;
+}
+
+static long
+thumbopri(int a)
+{
+	switch(a) {
+	case ASRL:	return 0x1<<11;
+	case ASRA:	return 0x2<<11;
+	case ASLL:	return 0x0<<11;
+	case AADD:	return 0x2<<11;
+	case ASUB:	return 0x3<<11;
+	case AMOVW:	return 0x0<<11;
+	case ACMP:	return 0x1<<11;
+	}
+	diag("bad thumbop opri %d", a);
+	prasm(curp);
+	return 0;
+}
+
+static long
+thumbophh(int a)
+{
+	switch(a) {
+	case AADD:	return 0x0<<8;
+	case AMOVW:	return 0x2<<8;
+	case ACMP:	return 0x1<<8;
+	}
+	diag("bad thumbop ophh %d", a);
+	prasm(curp);
+	return 0;
+}
+
+static long
+thumbopbra(int a)
+{
+	switch(a) {
+	case ABEQ:	return 0x0<<8;
+	case ABNE:	return 0x1<<8;
+	case ABCS:	return 0x2<<8;
+	case ABHS:	return 0x2<<8;
+	case ABCC:	return 0x3<<8;
+	case ABLO:	return 0x3<<8;
+	case ABMI:	return 0x4<<8;
+	case ABPL:	return 0x5<<8;
+	case ABVS:	return 0x6<<8;
+	case ABVC:	return 0x7<<8;
+	case ABHI:	return 0x8<<8;
+	case ABLS:	return 0x9<<8;
+	case ABGE:	return 0xa<<8;
+	case ABLT:	return 0xb<<8;
+	case ABGT:	return 0xc<<8;
+	case ABLE:	return 0xd<<8;
+	}
+	diag("bad thumbop opbra %d", a);
+	prasm(curp);
+	return 0;
+}
+
+static long
+thumbopmv(int a, int ld)
+{
+	switch(a) {
+	case AMOVW: 	return (ld ? 0xd : 0xc)<<11;
+	case AMOVH:
+	case AMOVHU:	return (ld ? 0x11: 0x10)<<11;
+	case AMOVB:
+	case AMOVBU:	return (ld ? 0xf : 0xe)<<11;
+	}
+	diag("bad thumbop opmv %d", a);
+	prasm(curp);
+	return 0;
+}
+
+static void 
+lowreg(Prog *p, int r)
+{
+	if(high(r))
+		diag("high reg [%P]", p);
+}
+
+static void
+mult(Prog *p, int n, int m)
+{
+	if(m*(n/m) != n)
+		diag("%d not M(%d) [%P]", n, m, p);
+}
+
+static void 
+numr(Prog *p, int n, int min, int max)
+{
+	if(n < min || n > max)
+		diag("%d not in %d-%d [%P]", n, min, max, p);
+}
+
+static void 
+regis(Prog *p, int r, int r1, int r2)
+{
+	if(r != r1 && r != r2)
+		diag("reg %d not %d or %d [%P]", r, r1, r2, p);
+}
+
+void
+hputl(int n)
+{
+	cbp[1] = n>>8;
+	cbp[0] = n;
+	cbp += 2;
+	cbc -= 2;
+	if(cbc <= 0)
+		cflush();
+}
+
+void
+thumbcount()
+{
+	int i, c = 0, t = 0;
+
+	for (i = 0; i < OPCNTSZ; i++)
+		t += opcount[i];
+	if(t == 0)
+		return;
+	for (i = 0; i < OPCNTSZ; i++){
+		c += opcount[i];
+		print("%d:	%d %d %d%%\n", i, opcount[i], c, (opcount[i]*100+t/2)/t);
+	}
+}
+	
+char *op1[] = { "lsl", "lsr", "asr" };
+char *op2[] = { "add", "sub" };
+char *op3[] = { "movw", "cmp", "add", "sub" };
+char *op4[] = { "and", "eor", "lsl", "lsr", "asr", "adc", "sbc", "ror",
+		        "tst", "neg", "cmp", "cmpn", "or", "mul", "bitc", "movn" };
+char *op5[] = { "add", "cmp", "movw", "bx" };
+char *op6[] = { "smovw", "smovh", "smovb", "lmovb", "lmovw", "lmovhu", "lmovbu", "lmovh" };
+char *op7[] = { "smovw", "lmovw", "smovb", "lmovbu" };
+char *op8[] = { "smovh", "lmovhu" };
+char *op9[] = { "smovw", "lmovw" };
+char *op10[] = { "push", "pop" };
+char *op11[] = { "stmia", "ldmia" };
+
+char *cond[] = { "eq", "ne", "hs", "lo", "mi", "pl", "vs", "vc",
+			 "hi", "ls", "ge", "lt", "gt", "le", "al", "nv" };
+
+#define B(h, l)		bits(i, h, l)
+#define IMM(h, l)	B(h, l)
+#define REG(h, l)	reg(B(h, l))
+#define LHREG(h, l, lh)	lhreg(B(h, l), B(lh, lh))
+#define COND(h, l)	cond[B(h, l)]
+#define OP1(h, l)	op1[B(h, l)]
+#define OP2(h, l)	op2[B(h, l)]
+#define OP3(h, l)	op3[B(h, l)]
+#define OP4(h, l)	op4[B(h, l)]
+#define OP5(h, l)	op5[B(h, l)]
+#define OP6(h, l)	op6[B(h, l)]
+#define OP7(h, l)	op7[B(h, l)]
+#define OP8(h, l)	op8[B(h, l)]
+#define OP9(h, l)	op9[B(h, l)]
+#define OP10(h, l)	op10[B(h, l)]
+#define OP11(h, l)	op11[B(h, l)]
+#define SBZ(h, l)	if(IMM(h, l) != 0) diag("%x: %x bits %d,%d not zero", pc, i, h, l)
+#define SNBZ(h, l)	if(IMM(h, l) == 0) diag("%x: %x bits %d,%d zero", pc, i, h, l)
+#define SBO(h, l)	if(IMM(h, l) != 1) diag("%x: %x bits %d,%d not one", pc, i, h, l)
+
+static int
+bits(int i, int h, int l)
+{
+	if(h < l)
+		diag("h < l in bits");
+	return (i&(((1<<(h-l+1))-1)<<l))>>l;
+}
+
+static char *
+reg(int r)
+{
+	static char s[4][4];
+	static int i = 0;
+
+	if(r < 0 || r > 7)
+		diag("register %d out of range", r);
+	i++;
+	if(i == 4)
+		i = 0;
+	sprint(s[i], "r%d", r);
+	return s[i];
+}
+
+static char *regnames[] = { "sp", "lr", "pc" };
+
+static char *
+lhreg(int r, int lh)
+{
+	static char s[4][4];
+	static int i = 0;
+
+	if(lh == 0)
+		return reg(r);
+	if(r < 0 || r > 7)
+		diag("high register %d out of range", r);
+	i++;
+	if(i == 4)
+		i = 0;
+	if(r >= 5)
+		sprint(s[i], "%s", regnames[r-5]);
+	else
+		sprint(s[i], "r%d", r+8);
+	return s[i];
+}
+	
+static void
+illegal(int i, int pc)
+{
+	diag("%x: %x illegal instruction", pc, i);
+}
+
+static void
+dis(int i, int pc)
+{
+	static int lasto;
+	int o, l;
+	char *op;
+
+	print("%x: %x:	", pc, i);
+	if(i&0xffff0000)
+		illegal(i, pc);
+	o = B(15, 13);
+	switch(o){
+	case 0:
+		o = B(12, 11);
+		switch(o){
+			case 0:
+			case 1:
+			case 2:
+				print("%s	%d, %s, %s\n", OP1(12, 11), IMM(10, 6), REG(5, 3), REG(2, 0));
+				return;
+			case 3:
+				if(B(10, 10) == 0)
+					print("%s	%s, %s, %s\n", OP2(9, 9), REG(8, 6), REG(5, 3), REG(2, 0));
+				else
+					print("%s	%d, %s, %s\n", OP2(9, 9), IMM(8, 6), REG(5, 3), REG(2, 0));
+				return;
+		}
+	case 1:
+		print("%s	%d, %s\n", OP3(12, 11), IMM(7, 0), REG(10, 8));
+		return;
+	case 2:
+		o = B(12, 10);
+		if(o == 0){
+			print("%s	%s, %s\n", OP4(9, 6), REG(5, 3), REG(2, 0));
+			return;
+		}
+		if(o == 1){
+			o = B(9, 8);
+			if(o == 3){
+				SBZ(7, 7);
+				SBZ(2, 0);
+				print("%s	%s\n", OP5(9, 8), LHREG(5, 3, 6));
+				return;
+			}
+			SNBZ(7, 6);
+			print("%s	%s, %s\n", OP5(9, 8), LHREG(5, 3, 6), LHREG(2, 0, 7));
+			return;
+		}
+		if(o == 2 || o == 3){
+			print("movw	%d(pc)[%x], %s\n", 4*IMM(7, 0), 4*IMM(7, 0)+pc+4, REG(10, 8));
+			return;
+		}
+		op = OP6(11, 9);
+		if(*op == 'l')
+			print("%s	[%s, %s], %s\n", op+1, REG(8, 6), REG(5, 3), REG(2, 0));
+		else
+			print("%s	%s, [%s, %s]\n", op+1, REG(2, 0), REG(8, 6), REG(5, 3));
+		return;
+	case 3:
+		op = OP7(12, 11);
+		if(B(12, 11) == 0 || B(12,11) == 1)
+			l = 4;
+		else
+			l = 1;
+		if(*op == 'l')
+			print("%s	%d(%s), %s\n", op+1, l*IMM(10, 6), REG(5, 3), REG(2, 0));
+		else
+			print("%s	%s, %d(%s)\n", op+1, REG(2, 0), l*IMM(10, 6), REG(5, 3));
+		return;
+	case 4:
+		if(B(12, 12) == 0){
+			op = OP8(11, 11);
+			if(*op == 'l')
+				print("%s	%d(%s), %s\n", op+1, 2*IMM(10, 6), REG(5, 3), REG(2, 0));
+			else
+				print("%s	%s, %d(%s)\n", op+1, REG(2, 0), 2*IMM(10, 6), REG(5, 3));
+			return;
+		}
+		op = OP9(11, 11);
+		if(*op == 'l')
+			print("%s	%d(sp), %s\n", op+1, 4*IMM(7, 0), REG(10, 8));
+		else
+			print("%s	%s, %d(sp)\n", op+1, REG(10, 8), 4*IMM(7, 0));
+		return;
+	case 5:
+		if(B(12, 12) == 0){
+			if(B(11, 11) == 0)
+				print("add	%d, pc, %s\n", 4*IMM(7, 0), REG(10, 8));
+			else
+				print("add	%d, sp, %s\n", 4*IMM(7, 0), REG(10, 8));
+			return;
+		}
+		if(B(11, 8) == 0){
+			print("%s	%d, sp\n", OP2(7, 7), 4*IMM(6, 0));
+			return;
+		}
+		SBO(10, 10);
+		SBZ(9, 9);
+		if(B(8, 8) == 0)
+			print("%s	sp, %d\n", OP10(11, 11), IMM(7, 0));
+		else
+			print("%s	sp, %d|15\n", OP10(11, 11), IMM(7, 0));
+		return;
+	case 6:
+		if(B(12, 12) == 0){
+			print("%s	%s, %d\n", OP11(11, 11), REG(10, 8), IMM(7, 0));
+			return;
+		}
+		if(B(11, 8) == 0xf){
+			print("swi	%d\n", IMM(7, 0));
+			return;
+		}
+		o = IMM(7, 0);
+		if(o&0x80)
+			o |= 0xffffff00;
+		o = pc+4+(o<<1);
+		print("b%s	%x\n", COND(11, 8), o);
+		return;
+	case 7:
+		o = B(12, 11);
+		switch(o){
+			case 0:
+				o = IMM(10, 0);
+				if(o&0x400)
+					o |= 0xfffff800;
+				o = pc+4+(o<<1);
+				print("b	%x\n", o);
+				return;
+			case 1:
+				illegal(i, pc);
+				return;
+			case 2:
+				lasto = IMM(10, 0);
+				print("bl\n");
+				return;
+			case 3:
+				if(lasto&0x400)
+					lasto |= 0xfffff800;
+				o = IMM(10, 0);
+				o = (pc-2)+4+(o<<1)+(lasto<<12);
+				print("bl %x\n", o);
+				return;
+		}
+	}
+}
