commit 0a0ee89f8bf0c6a07a7793be23645e353de96144
Author: Robert Griesemer <gri@golang.org>
Date:   Fri Jan 9 16:30:00 2009 -0800

    - remove obsolete files (missed before)
    
    R=r
    OCL=22475
    CL=22475
---
 usr/gri/pretty/globals.go | 246 ----------------------------------------------
 usr/gri/pretty/object.go  |  38 -------
 usr/gri/pretty/type.go    | 207 --------------------------------------
 3 files changed, 491 deletions(-)

diff --git a/usr/gri/pretty/globals.go b/usr/gri/pretty/globals.go
deleted file mode 100644
index 4ad3bba094..0000000000
--- a/usr/gri/pretty/globals.go
+++ /dev/null
@@ -1,246 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package Globals
-
-
-import "array"
-
-// The following types should really be in their respective files
-// (object.go, type.go, scope.go, package.go, compilation.go, etc.) but
-// they refer to each other and we don't know how to handle forward
-// declared pointers across packages yet.
-
-
-// ----------------------------------------------------------------------------
-
-type Type struct
-type Scope struct
-type OldCompilation struct
-
-// Object represents a language object, such as a constant, variable, type,
-// etc. (kind). An objects is (pre-)declared at a particular position in the
-// source code (pos), has a name (ident), a type (typ), and a package number
-// or nesting level (pnolev).
-
-export type Object struct {
-	id int;  // unique id
-
-	exported bool;
-	pos int;  // source position (< 0 if unknown position)
-	kind int;
-	ident string;
-	typ *Type;  // nil for packages
-	pnolev int;  // >= 0: package no., <= 0: function nesting level, 0: global level
-	
-	// attached values
-	block *array.Array; end int;  // stats for function literals; end of block pos
-}
-
-
-export type Type struct {
-	id int;  // unique id
-
-	ref int;  // for exporting only: >= 0 means already exported
-	form int;
-	size int;  // in bytes
-	len int;  // array length, no. of function/method parameters (w/o recv)
-	aux int;  // channel info
-	obj *Object;  // primary type object or NULL
-	key *Type;  // alias base type or map key
-	elt *Type;  // aliased type, array, map, channel or pointer element type, function result type, tuple function type
-	scope *Scope;  // forwards, structs, interfaces, functions
-}
-
-
-export type Package struct {
-	ref int;  // for exporting only: >= 0 means already exported
-	file_name string;
-	key string;
-	obj *Object;
-	scope *Scope;  // holds the (global) objects in this package
-}
-
-
-export type Scope struct {
-	parent *Scope;
-	entries map[string] *Object;
-}
-
-
-export type Environment struct {
-	Error *(comp *OldCompilation, pos int, msg string);
-	Import *(comp *OldCompilation, pkg_file string) *Package;
-	Export *(comp *OldCompilation, pkg_file string);
-	Compile *(comp *OldCompilation, src_file string);
-}
-
-
-export type OldCompilation struct {
-	// environment
-	env *Environment;
-
-	// TODO rethink the need for this here
-	src_file string;
-	src string;
-
-	// Error handling
-	nerrors int;  // number of errors reported
-	errpos int;  // last error position
-
-	// TODO use open arrays eventually
-	pkg_list [256] *Package;  // pkg_list[0] is the current package
-	pkg_ref int;
-}
-
-
-export type Expr interface {
-	op() int;  // node operation
-	pos() int;  // source position
-	typ() *Type;
-	// ... more to come here
-}
-
-
-export type Stat interface {
-	// ... more to come here
-}
-
-
-// ----------------------------------------------------------------------------
-// Creation
-
-export var Universe_void_typ *Type  // initialized by Universe to Universe.void_typ
-var ObjectId int;
-
-export func NewObject(pos, kind int, ident string) *Object {
-	obj := new(Object);
-	obj.id = ObjectId;
-	ObjectId++;
-	
-	obj.exported = false;
-	obj.pos = pos;
-	obj.kind = kind;
-	obj.ident = ident;
-	obj.typ = Universe_void_typ;
-	obj.pnolev = 0;
-
-	return obj;
-}
-
-
-var TypeId int;
-
-export func NewType(form int) *Type {
-	typ := new(Type);
-	typ.id = TypeId;
-	TypeId++;
-
-	typ.ref = -1;  // not yet exported
-	typ.form = form;
-
-	return typ;
-}
-
-
-export func NewPackage(file_name string, obj *Object, scope *Scope) *Package {
-	pkg := new(Package);
-	pkg.ref = -1;  // not yet exported
-	pkg.file_name = file_name;
-	pkg.key = "<the package key>";  // empty key means package forward declaration
-	pkg.obj = obj;
-	pkg.scope = scope;
-	return pkg;
-}
-
-
-export func NewScope(parent *Scope) *Scope {
-	scope := new(Scope);
-	scope.parent = parent;
-	scope.entries = make(map[string]*Object, 8);
-	return scope;
-}
-
-
-// ----------------------------------------------------------------------------
-// Object methods
-
-func (obj *Object) Copy() *Object {
-	copy := new(Object);
-	copy.exported = obj.exported;
-	copy.pos = obj.pos;
-	copy.kind = obj.kind;
-	copy.ident = obj.ident;
-	copy.typ = obj.typ;
-	copy.pnolev = obj.pnolev;
-	return copy;
-}
-
-
-// ----------------------------------------------------------------------------
-// Scope methods
-
-func (scope *Scope) Lookup(ident string) *Object {
-	obj, found := scope.entries[ident];
-	if found {
-		return obj;
-	}
-	return nil;
-}
-
-
-func (scope *Scope) Add(obj* Object) {
-	scope.entries[obj.ident] = obj;
-}
-
-
-func (scope *Scope) Insert(obj *Object) {
-	if scope.Lookup(obj.ident) != nil {
-		panic("obj already inserted");
-	}
-	scope.Add(obj);
-}
-
-
-func (scope *Scope) InsertImport(obj *Object) *Object {
-	 p := scope.Lookup(obj.ident);
-	 if p == nil {
-		scope.Add(obj);
-		p = obj;
-	 }
-	 return p;
-}
-
-
-func (scope *Scope) Print() {
-	print("scope {");
-	for key := range scope.entries {
-		print("\n  ", key);
-	}
-	print("\n}\n");
-}
-
-
-// ----------------------------------------------------------------------------
-// Compilation methods
-
-func (C *OldCompilation) Lookup(file_name string) *Package {
-	for i := 0; i < C.pkg_ref; i++ {
-		pkg := C.pkg_list[i];
-		if pkg.file_name == file_name {
-			return pkg;
-		}
-	}
-	return nil;
-}
-
-
-func (C *OldCompilation) Insert(pkg *Package) {
-	if C.Lookup(pkg.file_name) != nil {
-		panic("package already inserted");
-	}
-	pkg.obj.pnolev = C.pkg_ref;
-	C.pkg_list[C.pkg_ref] = pkg;
-	C.pkg_ref++;
-}
diff --git a/usr/gri/pretty/object.go b/usr/gri/pretty/object.go
deleted file mode 100755
index b09e563d44..0000000000
--- a/usr/gri/pretty/object.go
+++ /dev/null
@@ -1,38 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package Object
-
-import Globals "globals"
-
-
-export const /* kind */ (
-	BAD = iota;  // error handling
-	NONE;  // kind unknown
-	CONST; TYPE; VAR; FIELD; FUNC; BUILTIN; PACKAGE; LABEL;
-	END;  // end of scope (import/export only)
-)
-
-
-// The 'Object' declaration should be here as well, but 6g cannot handle
-// this due to cross-package circular references. For now it's all in
-// globals.go.
-
-
-export func KindStr(kind int) string {
-	switch kind {
-	case BAD: return "BAD";
-	case NONE: return "NONE";
-	case CONST: return "CONST";
-	case TYPE: return "TYPE";
-	case VAR: return "VAR";
-	case FIELD: return "FIELD";
-	case FUNC: return "FUNC";
-	case BUILTIN: return "BUILTIN";
-	case PACKAGE: return "PACKAGE";
-	case LABEL: return "LABEL";
-	case END: return "END";
-	}
-	return "<unknown Object kind>";
-}
diff --git a/usr/gri/pretty/type.go b/usr/gri/pretty/type.go
deleted file mode 100644
index 507357e65d..0000000000
--- a/usr/gri/pretty/type.go
+++ /dev/null
@@ -1,207 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package Type
-
-import Globals "globals"
-import Object "object"
-
-
-export const /* form */ (
-	// internal types
-	// We should never see one of these.
-	UNDEF = iota;
-	
-	// VOID types are used when we don't have a type. Never exported.
-	// (exported type forms must be > 0)
-	VOID;
-	
-	// BAD types are compatible with any type and don't cause further errors.
-	// They are introduced only as a result of an error in the source code. A
-	// correct program cannot have BAD types.
-	BAD;
-	
-	// FORWARD types are forward-declared (incomplete) types. They can only
-	// be used as element types of pointer types and must be resolved before
-	// their internals are accessible.
-	FORWARD;
-
-	// TUPLE types represent multi-valued result types of functions and
-	// methods.
-	TUPLE;
-	
-	// The type of nil.
-	NIL;
-
-	// basic types
-	BOOL; UINT; INT; FLOAT; STRING; INTEGER;
-	
-	// 'any' type  // TODO this should go away eventually
-	ANY;
-	
-	// composite types
-	ALIAS; ARRAY; STRUCT; INTERFACE; MAP; CHANNEL; FUNCTION; METHOD; POINTER;
-)
-
-
-export const /* Type.aux */ (
-	SEND = 1;  // chan>
-	RECV = 2;  // chan<
-)
-
-
-// The 'Type' declaration should be here as well, but 6g cannot handle
-// this due to cross-package circular references. For now it's all in
-// globals.go.
-
-
-export func FormStr(form int) string {
-	switch form {
-	case VOID: return "VOID";
-	case BAD: return "BAD";
-	case FORWARD: return "FORWARD";
-	case TUPLE: return "TUPLE";
-	case NIL: return "NIL";
-	case BOOL: return "BOOL";
-	case UINT: return "UINT";
-	case INT: return "INT";
-	case FLOAT: return "FLOAT";
-	case STRING: return "STRING";
-	case ANY: return "ANY";
-	case ALIAS: return "ALIAS";
-	case ARRAY: return "ARRAY";
-	case STRUCT: return "STRUCT";
-	case INTERFACE: return "INTERFACE";
-	case MAP: return "MAP";
-	case CHANNEL: return "CHANNEL";
-	case FUNCTION: return "FUNCTION";
-	case METHOD: return "METHOD";
-	case POINTER: return "POINTER";
-	}
-	return "<unknown Type form>";
-}
-
-
-export func Equal(x, y *Globals.Type) bool;
-
-func Equal0(x, y *Globals.Type) bool {
-	if x == y {
-		return true;  // identical types are equal
-	}
-
-	if x.form == BAD || y.form == BAD {
-		return true;  // bad types are always equal (avoid excess error messages)
-	}
-
-	// TODO where to check for *T == nil ?  
-	if x.form != y.form {
-		return false;  // types of different forms are not equal
-	}
-
-	switch x.form {
-	case FORWARD, BAD:
-		break;
-
-	case NIL, BOOL, STRING, ANY:
-		return true;
-
-	case UINT, INT, FLOAT:
-		return x.size == y.size;
-
-	case ARRAY:
-		return
-			x.len == y.len &&
-			Equal(x.elt, y.elt);
-
-	case MAP:
-		return
-			Equal(x.key, y.key) &&
-			Equal(x.elt, y.elt);
-
-	case CHANNEL:
-		return
-			x.aux == y.aux &&
-			Equal(x.elt, y.elt);
-
-	case FUNCTION, METHOD:
-		{	panic();
-			/*
-			xp := x.scope.entries;
-			yp := x.scope.entries;
-			if	x.len != y.len &&  // number of parameters
-				xp.len != yp.len  // recv + parameters + results
-			{
-				return false;
-			}
-			for p, q := xp.first, yp.first; p != nil; p, q = p.next, q.next {
-				xf := p.obj;
-				yf := q.obj;
-				if xf.kind != Object.VAR || yf.kind != Object.VAR {
-					panic("parameters must be vars");
-				}
-				if !Equal(xf.typ, yf.typ) {
-					return false;
-				}
-			}
-			*/
-		}
-		return true;
-
-	case STRUCT:
-		/*
-		{	ObjList* xl = &x.scope.list;
-			ObjList* yl = &y.scope.list;
-			if xl.len() != yl.len() {
-				return false;  // scopes of different sizes are not equal
-			}
-			for int i = xl.len(); i-- > 0; {
-				Object* xf = (*xl)[i];
-				Object* yf = (*yl)[i];
-				ASSERT(xf.kind == Object.VAR && yf.kind == Object.VAR);
-				if xf.name != yf.name) || ! EqualTypes(xf.type(), yf.type() {
-					return false;
-				}
-			}
-		}
-		return true;
-		*/
-		// Scopes must be identical for them to be equal.
-		// If we reach here, they weren't.
-		return false;
-
-	case INTERFACE:
-		panic("UNIMPLEMENTED");
-		return false;
-
-	case POINTER:
-		return Equal(x.elt, y.elt);
-		
-	case TUPLE:
-		panic("UNIMPLEMENTED");
-		return false;
-	}
-
-	panic("UNREACHABLE");
-	return false;
-}
-
-
-export func Equal(x, y *Globals.Type) bool {
-	res := Equal0(x, y);
-	// TODO should do the check below only in debug mode
-	if Equal0(y, x) != res {
-		panic("type equality must be symmetric");
-	}
-	return res;
-}
-
-
-export func Assigneable(from, to *Globals.Type) bool {
-	if Equal(from, to) {
-		return true;
-	}
-	
-	panic("UNIMPLEMENTED");
-	return false;
-}
