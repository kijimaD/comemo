commit 49da9a8e44fecbf9b3287472b6554419840b03b5
Author: RÃ©my Oudompheng <oudomphe@phare.normalesup.org>
Date:   Mon Aug 5 22:09:53 2013 +0200

    cmd/gc: fix inlining of unnamed structs with embedded fields.
    
    Update #5910.
    
    R=golang-dev, daniel.morsing, rsc
    CC=golang-dev
    https://golang.org/cl/11373044
---
 src/cmd/gc/go.y                      |    4 +-
 src/cmd/gc/y.tab.c                   | 1260 +++++++++++++++++++++++++---------
 src/cmd/gc/y.tab.h                   |   46 +-
 test/fixedbugs/issue5910.dir/a.go    |   17 +
 test/fixedbugs/issue5910.dir/main.go |    8 +
 test/fixedbugs/issue5910.go          |   10 +
 6 files changed, 992 insertions(+), 353 deletions(-)

diff --git a/src/cmd/gc/go.y b/src/cmd/gc/go.y
index 662f48ffc9..4fcb8c0f05 100644
--- a/src/cmd/gc/go.y
+++ b/src/cmd/gc/go.y
@@ -1541,8 +1541,8 @@ structdcl:
 
 		Node *n;
 		l = $1;
-		if(l != nil && l->next == nil && l->n == nil) {
-			// ? symbol, during import
+		if(l == nil) {
+			// ? symbol, during import (list1(N) == nil)
 			n = $2;
 			if(n->op == OIND)
 				n = n->left;
diff --git a/src/cmd/gc/y.tab.c b/src/cmd/gc/y.tab.c
index 08705bd514..39c0b12b64 100644
--- a/src/cmd/gc/y.tab.c
+++ b/src/cmd/gc/y.tab.c
@@ -1,24 +1,21 @@
-/* A Bison parser, made by GNU Bison 2.3.  */
+/* A Bison parser, made by GNU Bison 2.5.  */
 
-/* Skeleton implementation for Bison's Yacc-like parsers in C
-
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
-   Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
+/* Bison implementation for Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
+   
    You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -29,7 +26,7 @@
    special exception, which will cause the skeleton and the resulting
    Bison output files to be licensed under the GNU General Public
    License without this special exception.
-
+   
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
@@ -47,7 +44,7 @@
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "2.3"
+#define YYBISON_VERSION "2.5"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -55,11 +52,54 @@
 /* Pure parsers.  */
 #define YYPURE 0
 
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
 /* Using locations.  */
 #define YYLSP_NEEDED 0
 
 
 
+/* Copy the first part of user declarations.  */
+
+/* Line 268 of yacc.c  */
+#line 20 "go.y"
+
+#include <u.h>
+#include <stdio.h>	/* if we don't, bison will, and go.h re-#defines getc */
+#include <libc.h>
+#include "go.h"
+
+static int isrelease = -1;
+
+static void fixlbrace(int);
+
+
+/* Line 268 of yacc.c  */
+#line 83 "y.tab.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 1
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
 /* Tokens.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
@@ -171,63 +211,36 @@
 
 
 
-/* Copy the first part of user declarations.  */
-#line 20 "go.y"
-
-#include <u.h>
-#include <stdio.h>	/* if we don't, bison will, and go.h re-#defines getc */
-#include <libc.h>
-#include "go.h"
-
-static int isrelease = -1;
-
-static void fixlbrace(int);
-
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 1
-#endif
-
-/* Enabling the token table.  */
-#ifndef YYTOKEN_TABLE
-# define YYTOKEN_TABLE 0
-#endif
-
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-#line 30 "go.y"
 {
+
+/* Line 293 of yacc.c  */
+#line 30 "go.y"
+
 	Node*		node;
 	NodeList*		list;
 	Type*		type;
 	Sym*		sym;
 	struct	Val	val;
 	int		i;
-}
-/* Line 193 of yacc.c.  */
-#line 218 "y.tab.c"
-	YYSTYPE;
+
+
+
+/* Line 293 of yacc.c  */
+#line 232 "y.tab.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
 #endif
 
 
-
 /* Copy the second part of user declarations.  */
 
 
-/* Line 216 of yacc.c.  */
-#line 231 "y.tab.c"
+/* Line 343 of yacc.c  */
+#line 244 "y.tab.c"
 
 #ifdef short
 # undef short
@@ -302,14 +315,14 @@ typedef short int yytype_int16;
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 static int
-YYID (int i)
+YYID (int yyi)
 #else
 static int
-YYID (i)
-    int i;
+YYID (yyi)
+    int yyi;
 #endif
 {
-  return i;
+  return yyi;
 }
 #endif
 
@@ -330,11 +343,11 @@ YYID (i)
 #    define alloca _alloca
 #   else
 #    define YYSTACK_ALLOC alloca
-#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 #     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#     ifndef _STDLIB_H
-#      define _STDLIB_H 1
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
 #     endif
 #    endif
 #   endif
@@ -357,24 +370,24 @@ YYID (i)
 #  ifndef YYSTACK_ALLOC_MAXIMUM
 #   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
 #  endif
-#  if (defined __cplusplus && ! defined _STDLIB_H \
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
        && ! ((defined YYMALLOC || defined malloc) \
 	     && (defined YYFREE || defined free)))
 #   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   ifndef _STDLIB_H
-#    define _STDLIB_H 1
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
 #   endif
 #  endif
 #  ifndef YYMALLOC
 #   define YYMALLOC malloc
-#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+#   if ! defined malloc && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
 #  ifndef YYFREE
 #   define YYFREE free
-#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+#   if ! defined free && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 void free (void *); /* INFRINGES ON USER NAME SPACE */
 #   endif
@@ -390,9 +403,9 @@ void free (void *); /* INFRINGES ON USER NAME SPACE */
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  yytype_int16 yyss;
-  YYSTYPE yyvs;
-  };
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
 
 /* The size of the maximum gap between one aligned stack and the next.  */
 # define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
@@ -403,6 +416,27 @@ union yyalloc
      ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
@@ -420,24 +454,7 @@ union yyalloc
       while (YYID (0))
 #  endif
 # endif
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (YYID (0))
-
-#endif
+#endif /* !YYCOPY_NEEDED */
 
 /* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  4
@@ -714,16 +731,16 @@ const char *yytname[] =
   "'/'", "'%'", "'&'", "NotPackage", "NotParen", "'('", "')'",
   "PreferToRightParen", "';'", "'.'", "'$'", "'='", "':'", "'{'", "'}'",
   "'!'", "'~'", "'['", "']'", "'?'", "'@'", "','", "$accept", "file",
-  "package", "loadsys", "@1", "imports", "import", "import_stmt",
+  "package", "loadsys", "$@1", "imports", "import", "import_stmt",
   "import_stmt_list", "import_here", "import_package", "import_safety",
-  "import_there", "@2", "xdcl", "common_dcl", "lconst", "vardcl",
+  "import_there", "$@2", "xdcl", "common_dcl", "lconst", "vardcl",
   "constdcl", "constdcl1", "typedclname", "typedcl", "simple_stmt", "case",
-  "compound_stmt", "@3", "caseblock", "@4", "caseblock_list", "loop_body",
-  "@5", "range_stmt", "for_header", "for_body", "for_stmt", "@6",
-  "if_header", "if_stmt", "@7", "@8", "@9", "elseif", "@10", "elseif_list",
-  "else", "switch_stmt", "@11", "@12", "select_stmt", "@13", "expr",
-  "uexpr", "pseudocall", "pexpr_no_paren", "start_complit", "keyval",
-  "bare_complitexpr", "complitexpr", "pexpr", "expr_or_type",
+  "compound_stmt", "$@3", "caseblock", "$@4", "caseblock_list",
+  "loop_body", "$@5", "range_stmt", "for_header", "for_body", "for_stmt",
+  "$@6", "if_header", "if_stmt", "$@7", "$@8", "$@9", "elseif", "$@10",
+  "elseif_list", "else", "switch_stmt", "$@11", "$@12", "select_stmt",
+  "$@13", "expr", "uexpr", "pseudocall", "pexpr_no_paren", "start_complit",
+  "keyval", "bare_complitexpr", "complitexpr", "pexpr", "expr_or_type",
   "name_or_type", "lbrace", "new_name", "dcl_name", "onew_name", "sym",
   "hidden_importsym", "name", "labelname", "dotdotdot", "ntype",
   "non_expr_type", "non_recvchantype", "convtype", "comptype",
@@ -733,7 +750,7 @@ const char *yytname[] =
   "vardcl_list", "constdcl_list", "typedcl_list", "structdcl_list",
   "interfacedcl_list", "structdcl", "packname", "embed", "interfacedcl",
   "indcl", "arg_type", "arg_type_list", "oarg_type_list_ocomma", "stmt",
-  "non_dcl_stmt", "@14", "stmt_list", "new_name_list", "dcl_name_list",
+  "non_dcl_stmt", "$@14", "stmt_list", "new_name_list", "dcl_name_list",
   "expr_list", "expr_or_type_list", "keyval_list", "braced_keyval_list",
   "osemi", "ocomma", "oexpr", "oexpr_list", "osimple_stmt",
   "ohidden_funarg_list", "ohidden_structdcl_list",
@@ -846,8 +863,8 @@ static const yytype_uint8 yyr2[] =
        3
 };
 
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
+   Performed when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
 static const yytype_uint16 yydefact[] =
 {
@@ -1036,8 +1053,7 @@ static const yytype_int16 yypgoto[] =
 
 /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
    positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, syntax error.  */
+   number is the opposite.  If YYTABLE_NINF, syntax error.  */
 #define YYTABLE_NINF -276
 static const yytype_int16 yytable[] =
 {
@@ -1263,6 +1279,12 @@ static const yytype_int16 yytable[] =
      189,   190,   191,   192,   193,   194,   195,   196,   197
 };
 
+#define yypact_value_is_default(yystate) \
+  ((yystate) == (-552))
+
+#define yytable_value_is_error(yytable_value) \
+  YYID (0)
+
 static const yytype_int16 yycheck[] =
 {
       37,    37,    61,   142,    67,    37,    37,   201,   250,   143,
@@ -1572,9 +1594,18 @@ static const yytype_uint8 yystos[] =
 
 /* Like YYERROR except do call yyerror.  This remains here temporarily
    to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
+   Once GCC version 2 has supplanted version 1, this can go.  However,
+   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
+   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
+   discussed.  */
 
 #define YYFAIL		goto yyerrlab
+#if defined YYFAIL
+  /* This is here to suppress warnings from the GCC cpp's
+     -Wunused-macros.  Normally we don't worry about that warning, but
+     some users do, and we want to make it easy for users to remove
+     YYFAIL uses, which will produce warnings from Bison 2.5.  */
+#endif
 
 #define YYRECOVERING()  (!!yyerrstatus)
 
@@ -1584,7 +1615,6 @@ do								\
     {								\
       yychar = (Token);						\
       yylval = (Value);						\
-      yytoken = YYTRANSLATE (yychar);				\
       YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
@@ -1626,19 +1656,10 @@ while (YYID (0))
 #endif
 
 
-/* YY_LOCATION_PRINT -- Print the location on the stream.
-   This macro was not mandated originally: define only if we know
-   we won't break user code: when these are the locations we know.  */
+/* This macro is provided for backward compatibility. */
 
 #ifndef YY_LOCATION_PRINT
-# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
-#  define YY_LOCATION_PRINT(File, Loc)			\
-     fprintf (File, "%d.%d-%d.%d",			\
-	      (Loc).first_line, (Loc).first_column,	\
-	      (Loc).last_line,  (Loc).last_column)
-# else
-#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-# endif
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
 #endif
 
 
@@ -1742,17 +1763,20 @@ yy_symbol_print (yyoutput, yytype, yyvaluep)
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 static void
-yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
 #else
 static void
-yy_stack_print (bottom, top)
-    yytype_int16 *bottom;
-    yytype_int16 *top;
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
   YYFPRINTF (stderr, "\n");
 }
 
@@ -1786,11 +1810,11 @@ yy_reduce_print (yyvsp, yyrule)
   /* The symbols being reduced.  */
   for (yyi = 0; yyi < yynrhs; yyi++)
     {
-      fprintf (stderr, "   $%d = ", yyi + 1);
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
       yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
 		       &(yyvsp[(yyi + 1) - (yynrhs)])
 		       		       );
-      fprintf (stderr, "\n");
+      YYFPRINTF (stderr, "\n");
     }
 }
 
@@ -1827,7 +1851,6 @@ int yydebug;
 # define YYMAXDEPTH 10000
 #endif
 
-
 
 #if YYERROR_VERBOSE
 
@@ -1930,115 +1953,142 @@ yytnamerr (char *yyres, const char *yystr)
 }
 # endif
 
-/* Copy into YYRESULT an error message about the unexpected token
-   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
-   including the terminating null byte.  If YYRESULT is null, do not
-   copy anything; just return the number of bytes that would be
-   copied.  As a special case, return 0 if an ordinary "syntax error"
-   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
-   size calculation.  */
-static YYSIZE_T
-yysyntax_error (char *yyresult, int yystate, int yychar)
-{
-  int yyn = yypact[yystate];
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
 
-  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
-    return 0;
-  else
-    {
-      int yytype = YYTRANSLATE (yychar);
-      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
-      YYSIZE_T yysize = yysize0;
-      YYSIZE_T yysize1;
-      int yysize_overflow = 0;
-      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-      int yyx;
-
-# if 0
-      /* This is so xgettext sees the translatable formats that are
-	 constructed on the fly.  */
-      YY_("syntax error, unexpected %s");
-      YY_("syntax error, unexpected %s, expecting %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
-# endif
-      char *yyfmt;
-      char const *yyf;
-      static char const yyunexpected[] = "syntax error, unexpected %s";
-      static char const yyexpecting[] = ", expecting %s";
-      static char const yyor[] = " or %s";
-      char yyformat[sizeof yyunexpected
-		    + sizeof yyexpecting - 1
-		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
-		       * (sizeof yyor - 1))];
-      char const *yyprefix = yyexpecting;
-
-      /* Start YYX at -YYN if negative to avoid negative indexes in
-	 YYCHECK.  */
-      int yyxbegin = yyn < 0 ? -yyn : 0;
-
-      /* Stay within bounds of both yycheck and yytname.  */
-      int yychecklim = YYLAST - yyn + 1;
-      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-      int yycount = 1;
-
-      yyarg[0] = yytname[yytype];
-      yyfmt = yystpcpy (yyformat, yyunexpected);
-
-      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	  {
-	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-	      {
-		yycount = 1;
-		yysize = yysize0;
-		yyformat[sizeof yyunexpected - 1] = '\0';
-		break;
-	      }
-	    yyarg[yycount++] = yytname[yyx];
-	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
-	    yysize_overflow |= (yysize1 < yysize);
-	    yysize = yysize1;
-	    yyfmt = yystpcpy (yyfmt, yyprefix);
-	    yyprefix = yyor;
-	  }
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  YYSIZE_T yysize1;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = 0;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - Assume YYFAIL is not used.  It's too flawed to consider.  See
+       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
+       for details.  YYERROR is fine as it does not invoke this
+       function.
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+                if (! (yysize <= yysize1
+                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                  return 2;
+                yysize = yysize1;
+              }
+        }
+    }
 
-      yyf = YY_(yyformat);
-      yysize1 = yysize + yystrlen (yyf);
-      yysize_overflow |= (yysize1 < yysize);
-      yysize = yysize1;
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
 
-      if (yysize_overflow)
-	return YYSIZE_MAXIMUM;
+  yysize1 = yysize + yystrlen (yyformat);
+  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+    return 2;
+  yysize = yysize1;
 
-      if (yyresult)
-	{
-	  /* Avoid sprintf, as that infringes on the user's name space.
-	     Don't have undefined behavior even if the translation
-	     produced a string with the wrong number of "%s"s.  */
-	  char *yyp = yyresult;
-	  int yyi = 0;
-	  while ((*yyp = *yyf) != '\0')
-	    {
-	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
-		{
-		  yyp += yytnamerr (yyp, yyarg[yyi++]);
-		  yyf += 2;
-		}
-	      else
-		{
-		  yyp++;
-		  yyf++;
-		}
-	    }
-	}
-      return yysize;
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
     }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
 }
 #endif /* YYERROR_VERBOSE */
-
 
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
@@ -2070,10 +2120,9 @@ yydestruct (yymsg, yytype, yyvaluep)
 	break;
     }
 }
-
 
-/* Prevent warnings from -Wmissing-prototypes.  */
 
+/* Prevent warnings from -Wmissing-prototypes.  */
 #ifdef YYPARSE_PARAM
 #if defined __STDC__ || defined __cplusplus
 int yyparse (void *YYPARSE_PARAM);
@@ -2089,18 +2138,16 @@ int yyparse ();
 #endif /* ! YYPARSE_PARAM */
 
 
-
-/* The look-ahead symbol.  */
+/* The lookahead symbol.  */
 int yychar, yystate;
 
-/* The semantic value of the look-ahead symbol.  */
+/* The semantic value of the lookahead symbol.  */
 YYSTYPE yylval;
 
 /* Number of syntax errors so far.  */
 int yynerrs;
 
 
-
 /*----------.
 | yyparse.  |
 `----------*/
@@ -2127,65 +2174,65 @@ yyparse ()
 #endif
 #endif
 {
-  
-  int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Look-ahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-#if YYERROR_VERBOSE
-  /* Buffer for error messages, and its allocated size.  */
-  char yymsgbuf[128];
-  char *yymsg = yymsgbuf;
-  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
-#endif
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
 
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
 
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
 
-  /* The state stack.  */
-  yytype_int16 yyssa[YYINITDEPTH];
-  yytype_int16 *yyss = yyssa;
-  yytype_int16 *yyssp;
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
 
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  YYSTYPE *yyvsp;
-
-
-
-#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
 
-  YYSIZE_T yystacksize = YYINITDEPTH;
+    YYSIZE_T yystacksize;
 
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
   /* The variables used to return semantic value and location from the
      action routines.  */
   YYSTYPE yyval;
 
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
   /* The number of symbols on the RHS of the reduced rule.
      Keep to zero when no symbol should be popped.  */
   int yylen = 0;
 
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
   YYDPRINTF ((stderr, "Starting parse\n"));
 
   yystate = 0;
   yyerrstatus = 0;
   yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
+  yychar = YYEMPTY; /* Cause a token to be read.  */
 
   /* Initialize stack pointers.
      Waste one element of value and location stack
      so that they stay on the same level as the state stack.
      The wasted elements are never initialized.  */
-
   yyssp = yyss;
   yyvsp = yyvs;
 
@@ -2215,7 +2262,6 @@ yyparse ()
 	YYSTYPE *yyvs1 = yyvs;
 	yytype_int16 *yyss1 = yyss;
 
-
 	/* Each stack pointer address is followed by the size of the
 	   data in use in that stack, in bytes.  This used to be a
 	   conditional around just the two extra args, but that might
@@ -2223,7 +2269,6 @@ yyparse ()
 	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
-
 		    &yystacksize);
 
 	yyss = yyss1;
@@ -2246,9 +2291,8 @@ yyparse ()
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
 	  goto yyexhaustedlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
 #  undef YYSTACK_RELOCATE
 	if (yyss1 != yyssa)
 	  YYSTACK_FREE (yyss1);
@@ -2259,7 +2303,6 @@ yyparse ()
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
 
-
       YYDPRINTF ((stderr, "Stack size increased to %lu\n",
 		  (unsigned long int) yystacksize));
 
@@ -2269,6 +2312,9 @@ yyparse ()
 
   YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
   goto yybackup;
 
 /*-----------.
@@ -2277,16 +2323,16 @@ yyparse ()
 yybackup:
 
   /* Do appropriate processing given the current state.  Read a
-     look-ahead token if we need one and don't already have one.  */
+     lookahead token if we need one and don't already have one.  */
 
-  /* First try to decide what to do without reference to look-ahead token.  */
+  /* First try to decide what to do without reference to lookahead token.  */
   yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
+  if (yypact_value_is_default (yyn))
     goto yydefault;
 
-  /* Not known => get a look-ahead token if don't already have one.  */
+  /* Not known => get a lookahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
@@ -2312,26 +2358,22 @@ yybackup:
   yyn = yytable[yyn];
   if (yyn <= 0)
     {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
-	goto yyerrlab;
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
 
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
-  /* Shift the look-ahead token.  */
+  /* Shift the lookahead token.  */
   YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
 
-  /* Discard the shifted token unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
 
   yystate = yyn;
   *++yyvsp = yylval;
@@ -2371,6 +2413,8 @@ yyreduce:
   switch (yyn)
     {
         case 2:
+
+/* Line 1806 of yacc.c  */
 #line 130 "go.y"
     {
 		xtop = concat(xtop, (yyvsp[(4) - (4)].list));
@@ -2378,6 +2422,8 @@ yyreduce:
     break;
 
   case 3:
+
+/* Line 1806 of yacc.c  */
 #line 136 "go.y"
     {
 		prevlineno = lineno;
@@ -2388,6 +2434,8 @@ yyreduce:
     break;
 
   case 4:
+
+/* Line 1806 of yacc.c  */
 #line 143 "go.y"
     {
 		mkpackage((yyvsp[(2) - (3)].sym)->name);
@@ -2395,6 +2443,8 @@ yyreduce:
     break;
 
   case 5:
+
+/* Line 1806 of yacc.c  */
 #line 153 "go.y"
     {
 		importpkg = runtimepkg;
@@ -2408,6 +2458,8 @@ yyreduce:
     break;
 
   case 6:
+
+/* Line 1806 of yacc.c  */
 #line 164 "go.y"
     {
 		importpkg = nil;
@@ -2415,6 +2467,8 @@ yyreduce:
     break;
 
   case 12:
+
+/* Line 1806 of yacc.c  */
 #line 178 "go.y"
     {
 		Pkg *ipkg;
@@ -2455,6 +2509,8 @@ yyreduce:
     break;
 
   case 13:
+
+/* Line 1806 of yacc.c  */
 #line 215 "go.y"
     {
 		// When an invalid import path is passed to importfile,
@@ -2467,6 +2523,8 @@ yyreduce:
     break;
 
   case 16:
+
+/* Line 1806 of yacc.c  */
 #line 230 "go.y"
     {
 		// import with original name
@@ -2477,6 +2535,8 @@ yyreduce:
     break;
 
   case 17:
+
+/* Line 1806 of yacc.c  */
 #line 237 "go.y"
     {
 		// import with given name
@@ -2487,6 +2547,8 @@ yyreduce:
     break;
 
   case 18:
+
+/* Line 1806 of yacc.c  */
 #line 244 "go.y"
     {
 		// import into my name space
@@ -2497,6 +2559,8 @@ yyreduce:
     break;
 
   case 19:
+
+/* Line 1806 of yacc.c  */
 #line 253 "go.y"
     {
 		if(importpkg->name == nil) {
@@ -2513,6 +2577,8 @@ yyreduce:
     break;
 
   case 21:
+
+/* Line 1806 of yacc.c  */
 #line 268 "go.y"
     {
 		if(strcmp((yyvsp[(1) - (1)].sym)->name, "safe") == 0)
@@ -2521,6 +2587,8 @@ yyreduce:
     break;
 
   case 22:
+
+/* Line 1806 of yacc.c  */
 #line 274 "go.y"
     {
 		defercheckwidth();
@@ -2528,6 +2596,8 @@ yyreduce:
     break;
 
   case 23:
+
+/* Line 1806 of yacc.c  */
 #line 278 "go.y"
     {
 		resumecheckwidth();
@@ -2536,6 +2606,8 @@ yyreduce:
     break;
 
   case 24:
+
+/* Line 1806 of yacc.c  */
 #line 287 "go.y"
     {
 		yyerror("empty top-level declaration");
@@ -2544,6 +2616,8 @@ yyreduce:
     break;
 
   case 26:
+
+/* Line 1806 of yacc.c  */
 #line 293 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -2551,6 +2625,8 @@ yyreduce:
     break;
 
   case 27:
+
+/* Line 1806 of yacc.c  */
 #line 297 "go.y"
     {
 		yyerror("non-declaration statement outside function body");
@@ -2559,6 +2635,8 @@ yyreduce:
     break;
 
   case 28:
+
+/* Line 1806 of yacc.c  */
 #line 302 "go.y"
     {
 		(yyval.list) = nil;
@@ -2566,6 +2644,8 @@ yyreduce:
     break;
 
   case 29:
+
+/* Line 1806 of yacc.c  */
 #line 308 "go.y"
     {
 		(yyval.list) = (yyvsp[(2) - (2)].list);
@@ -2573,6 +2653,8 @@ yyreduce:
     break;
 
   case 30:
+
+/* Line 1806 of yacc.c  */
 #line 312 "go.y"
     {
 		(yyval.list) = (yyvsp[(3) - (5)].list);
@@ -2580,6 +2662,8 @@ yyreduce:
     break;
 
   case 31:
+
+/* Line 1806 of yacc.c  */
 #line 316 "go.y"
     {
 		(yyval.list) = nil;
@@ -2587,6 +2671,8 @@ yyreduce:
     break;
 
   case 32:
+
+/* Line 1806 of yacc.c  */
 #line 320 "go.y"
     {
 		(yyval.list) = (yyvsp[(2) - (2)].list);
@@ -2596,6 +2682,8 @@ yyreduce:
     break;
 
   case 33:
+
+/* Line 1806 of yacc.c  */
 #line 326 "go.y"
     {
 		(yyval.list) = (yyvsp[(3) - (5)].list);
@@ -2605,6 +2693,8 @@ yyreduce:
     break;
 
   case 34:
+
+/* Line 1806 of yacc.c  */
 #line 332 "go.y"
     {
 		(yyval.list) = concat((yyvsp[(3) - (7)].list), (yyvsp[(5) - (7)].list));
@@ -2614,6 +2704,8 @@ yyreduce:
     break;
 
   case 35:
+
+/* Line 1806 of yacc.c  */
 #line 338 "go.y"
     {
 		(yyval.list) = nil;
@@ -2622,6 +2714,8 @@ yyreduce:
     break;
 
   case 36:
+
+/* Line 1806 of yacc.c  */
 #line 343 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(2) - (2)].node));
@@ -2629,6 +2723,8 @@ yyreduce:
     break;
 
   case 37:
+
+/* Line 1806 of yacc.c  */
 #line 347 "go.y"
     {
 		(yyval.list) = (yyvsp[(3) - (5)].list);
@@ -2636,6 +2732,8 @@ yyreduce:
     break;
 
   case 38:
+
+/* Line 1806 of yacc.c  */
 #line 351 "go.y"
     {
 		(yyval.list) = nil;
@@ -2643,6 +2741,8 @@ yyreduce:
     break;
 
   case 39:
+
+/* Line 1806 of yacc.c  */
 #line 357 "go.y"
     {
 		iota = 0;
@@ -2650,6 +2750,8 @@ yyreduce:
     break;
 
   case 40:
+
+/* Line 1806 of yacc.c  */
 #line 363 "go.y"
     {
 		(yyval.list) = variter((yyvsp[(1) - (2)].list), (yyvsp[(2) - (2)].node), nil);
@@ -2657,6 +2759,8 @@ yyreduce:
     break;
 
   case 41:
+
+/* Line 1806 of yacc.c  */
 #line 367 "go.y"
     {
 		(yyval.list) = variter((yyvsp[(1) - (4)].list), (yyvsp[(2) - (4)].node), (yyvsp[(4) - (4)].list));
@@ -2664,6 +2768,8 @@ yyreduce:
     break;
 
   case 42:
+
+/* Line 1806 of yacc.c  */
 #line 371 "go.y"
     {
 		(yyval.list) = variter((yyvsp[(1) - (3)].list), nil, (yyvsp[(3) - (3)].list));
@@ -2671,6 +2777,8 @@ yyreduce:
     break;
 
   case 43:
+
+/* Line 1806 of yacc.c  */
 #line 377 "go.y"
     {
 		(yyval.list) = constiter((yyvsp[(1) - (4)].list), (yyvsp[(2) - (4)].node), (yyvsp[(4) - (4)].list));
@@ -2678,6 +2786,8 @@ yyreduce:
     break;
 
   case 44:
+
+/* Line 1806 of yacc.c  */
 #line 381 "go.y"
     {
 		(yyval.list) = constiter((yyvsp[(1) - (3)].list), N, (yyvsp[(3) - (3)].list));
@@ -2685,6 +2795,8 @@ yyreduce:
     break;
 
   case 46:
+
+/* Line 1806 of yacc.c  */
 #line 388 "go.y"
     {
 		(yyval.list) = constiter((yyvsp[(1) - (2)].list), (yyvsp[(2) - (2)].node), nil);
@@ -2692,6 +2804,8 @@ yyreduce:
     break;
 
   case 47:
+
+/* Line 1806 of yacc.c  */
 #line 392 "go.y"
     {
 		(yyval.list) = constiter((yyvsp[(1) - (1)].list), N, nil);
@@ -2699,6 +2813,8 @@ yyreduce:
     break;
 
   case 48:
+
+/* Line 1806 of yacc.c  */
 #line 398 "go.y"
     {
 		// different from dclname because the name
@@ -2709,6 +2825,8 @@ yyreduce:
     break;
 
   case 49:
+
+/* Line 1806 of yacc.c  */
 #line 407 "go.y"
     {
 		(yyval.node) = typedcl1((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].node), 1);
@@ -2716,6 +2834,8 @@ yyreduce:
     break;
 
   case 50:
+
+/* Line 1806 of yacc.c  */
 #line 413 "go.y"
     {
 		(yyval.node) = (yyvsp[(1) - (1)].node);
@@ -2737,6 +2857,8 @@ yyreduce:
     break;
 
   case 51:
+
+/* Line 1806 of yacc.c  */
 #line 431 "go.y"
     {
 		(yyval.node) = nod(OASOP, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -2745,6 +2867,8 @@ yyreduce:
     break;
 
   case 52:
+
+/* Line 1806 of yacc.c  */
 #line 436 "go.y"
     {
 		if((yyvsp[(1) - (3)].list)->next == nil && (yyvsp[(3) - (3)].list)->next == nil) {
@@ -2760,6 +2884,8 @@ yyreduce:
     break;
 
   case 53:
+
+/* Line 1806 of yacc.c  */
 #line 448 "go.y"
     {
 		if((yyvsp[(3) - (3)].list)->n->op == OTYPESW) {
@@ -2779,6 +2905,8 @@ yyreduce:
     break;
 
   case 54:
+
+/* Line 1806 of yacc.c  */
 #line 464 "go.y"
     {
 		(yyval.node) = nod(OASOP, (yyvsp[(1) - (2)].node), nodintconst(1));
@@ -2787,6 +2915,8 @@ yyreduce:
     break;
 
   case 55:
+
+/* Line 1806 of yacc.c  */
 #line 469 "go.y"
     {
 		(yyval.node) = nod(OASOP, (yyvsp[(1) - (2)].node), nodintconst(1));
@@ -2795,6 +2925,8 @@ yyreduce:
     break;
 
   case 56:
+
+/* Line 1806 of yacc.c  */
 #line 476 "go.y"
     {
 		Node *n, *nn;
@@ -2818,6 +2950,8 @@ yyreduce:
     break;
 
   case 57:
+
+/* Line 1806 of yacc.c  */
 #line 496 "go.y"
     {
 		Node *n;
@@ -2839,6 +2973,8 @@ yyreduce:
     break;
 
   case 58:
+
+/* Line 1806 of yacc.c  */
 #line 514 "go.y"
     {
 		// will be converted to OCASE
@@ -2851,6 +2987,8 @@ yyreduce:
     break;
 
   case 59:
+
+/* Line 1806 of yacc.c  */
 #line 523 "go.y"
     {
 		Node *n, *nn;
@@ -2870,6 +3008,8 @@ yyreduce:
     break;
 
   case 60:
+
+/* Line 1806 of yacc.c  */
 #line 541 "go.y"
     {
 		markdcl();
@@ -2877,6 +3017,8 @@ yyreduce:
     break;
 
   case 61:
+
+/* Line 1806 of yacc.c  */
 #line 545 "go.y"
     {
 		if((yyvsp[(3) - (4)].list) == nil)
@@ -2888,6 +3030,8 @@ yyreduce:
     break;
 
   case 62:
+
+/* Line 1806 of yacc.c  */
 #line 555 "go.y"
     {
 		// If the last token read by the lexer was consumed
@@ -2901,6 +3045,8 @@ yyreduce:
     break;
 
   case 63:
+
+/* Line 1806 of yacc.c  */
 #line 565 "go.y"
     {
 		int last;
@@ -2923,6 +3069,8 @@ yyreduce:
     break;
 
   case 64:
+
+/* Line 1806 of yacc.c  */
 #line 585 "go.y"
     {
 		(yyval.list) = nil;
@@ -2930,6 +3078,8 @@ yyreduce:
     break;
 
   case 65:
+
+/* Line 1806 of yacc.c  */
 #line 589 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (2)].list), (yyvsp[(2) - (2)].node));
@@ -2937,6 +3087,8 @@ yyreduce:
     break;
 
   case 66:
+
+/* Line 1806 of yacc.c  */
 #line 595 "go.y"
     {
 		markdcl();
@@ -2944,6 +3096,8 @@ yyreduce:
     break;
 
   case 67:
+
+/* Line 1806 of yacc.c  */
 #line 599 "go.y"
     {
 		(yyval.list) = (yyvsp[(3) - (4)].list);
@@ -2952,6 +3106,8 @@ yyreduce:
     break;
 
   case 68:
+
+/* Line 1806 of yacc.c  */
 #line 606 "go.y"
     {
 		(yyval.node) = nod(ORANGE, N, (yyvsp[(4) - (4)].node));
@@ -2961,6 +3117,8 @@ yyreduce:
     break;
 
   case 69:
+
+/* Line 1806 of yacc.c  */
 #line 612 "go.y"
     {
 		(yyval.node) = nod(ORANGE, N, (yyvsp[(4) - (4)].node));
@@ -2971,6 +3129,8 @@ yyreduce:
     break;
 
   case 70:
+
+/* Line 1806 of yacc.c  */
 #line 621 "go.y"
     {
 		// init ; test ; incr
@@ -2985,6 +3145,8 @@ yyreduce:
     break;
 
   case 71:
+
+/* Line 1806 of yacc.c  */
 #line 632 "go.y"
     {
 		// normal test
@@ -2994,6 +3156,8 @@ yyreduce:
     break;
 
   case 73:
+
+/* Line 1806 of yacc.c  */
 #line 641 "go.y"
     {
 		(yyval.node) = (yyvsp[(1) - (2)].node);
@@ -3002,6 +3166,8 @@ yyreduce:
     break;
 
   case 74:
+
+/* Line 1806 of yacc.c  */
 #line 648 "go.y"
     {
 		markdcl();
@@ -3009,6 +3175,8 @@ yyreduce:
     break;
 
   case 75:
+
+/* Line 1806 of yacc.c  */
 #line 652 "go.y"
     {
 		(yyval.node) = (yyvsp[(3) - (3)].node);
@@ -3017,6 +3185,8 @@ yyreduce:
     break;
 
   case 76:
+
+/* Line 1806 of yacc.c  */
 #line 659 "go.y"
     {
 		// test
@@ -3026,6 +3196,8 @@ yyreduce:
     break;
 
   case 77:
+
+/* Line 1806 of yacc.c  */
 #line 665 "go.y"
     {
 		// init ; test
@@ -3037,6 +3209,8 @@ yyreduce:
     break;
 
   case 78:
+
+/* Line 1806 of yacc.c  */
 #line 676 "go.y"
     {
 		markdcl();
@@ -3044,6 +3218,8 @@ yyreduce:
     break;
 
   case 79:
+
+/* Line 1806 of yacc.c  */
 #line 680 "go.y"
     {
 		if((yyvsp[(3) - (3)].node)->ntest == N)
@@ -3052,6 +3228,8 @@ yyreduce:
     break;
 
   case 80:
+
+/* Line 1806 of yacc.c  */
 #line 685 "go.y"
     {
 		(yyvsp[(3) - (5)].node)->nbody = (yyvsp[(5) - (5)].list);
@@ -3059,6 +3237,8 @@ yyreduce:
     break;
 
   case 81:
+
+/* Line 1806 of yacc.c  */
 #line 689 "go.y"
     {
 		Node *n;
@@ -3077,6 +3257,8 @@ yyreduce:
     break;
 
   case 82:
+
+/* Line 1806 of yacc.c  */
 #line 706 "go.y"
     {
 		markdcl();
@@ -3084,6 +3266,8 @@ yyreduce:
     break;
 
   case 83:
+
+/* Line 1806 of yacc.c  */
 #line 710 "go.y"
     {
 		if((yyvsp[(4) - (5)].node)->ntest == N)
@@ -3094,6 +3278,8 @@ yyreduce:
     break;
 
   case 84:
+
+/* Line 1806 of yacc.c  */
 #line 718 "go.y"
     {
 		(yyval.list) = nil;
@@ -3101,6 +3287,8 @@ yyreduce:
     break;
 
   case 85:
+
+/* Line 1806 of yacc.c  */
 #line 722 "go.y"
     {
 		(yyval.list) = concat((yyvsp[(1) - (2)].list), (yyvsp[(2) - (2)].list));
@@ -3108,6 +3296,8 @@ yyreduce:
     break;
 
   case 86:
+
+/* Line 1806 of yacc.c  */
 #line 727 "go.y"
     {
 		(yyval.list) = nil;
@@ -3115,6 +3305,8 @@ yyreduce:
     break;
 
   case 87:
+
+/* Line 1806 of yacc.c  */
 #line 731 "go.y"
     {
 		NodeList *node;
@@ -3127,6 +3319,8 @@ yyreduce:
     break;
 
   case 88:
+
+/* Line 1806 of yacc.c  */
 #line 742 "go.y"
     {
 		markdcl();
@@ -3134,6 +3328,8 @@ yyreduce:
     break;
 
   case 89:
+
+/* Line 1806 of yacc.c  */
 #line 746 "go.y"
     {
 		Node *n;
@@ -3145,6 +3341,8 @@ yyreduce:
     break;
 
   case 90:
+
+/* Line 1806 of yacc.c  */
 #line 754 "go.y"
     {
 		(yyval.node) = (yyvsp[(3) - (7)].node);
@@ -3156,6 +3354,8 @@ yyreduce:
     break;
 
   case 91:
+
+/* Line 1806 of yacc.c  */
 #line 764 "go.y"
     {
 		typesw = nod(OXXX, typesw, N);
@@ -3163,6 +3363,8 @@ yyreduce:
     break;
 
   case 92:
+
+/* Line 1806 of yacc.c  */
 #line 768 "go.y"
     {
 		(yyval.node) = nod(OSELECT, N, N);
@@ -3173,6 +3375,8 @@ yyreduce:
     break;
 
   case 94:
+
+/* Line 1806 of yacc.c  */
 #line 781 "go.y"
     {
 		(yyval.node) = nod(OOROR, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3180,6 +3384,8 @@ yyreduce:
     break;
 
   case 95:
+
+/* Line 1806 of yacc.c  */
 #line 785 "go.y"
     {
 		(yyval.node) = nod(OANDAND, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3187,6 +3393,8 @@ yyreduce:
     break;
 
   case 96:
+
+/* Line 1806 of yacc.c  */
 #line 789 "go.y"
     {
 		(yyval.node) = nod(OEQ, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3194,6 +3402,8 @@ yyreduce:
     break;
 
   case 97:
+
+/* Line 1806 of yacc.c  */
 #line 793 "go.y"
     {
 		(yyval.node) = nod(ONE, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3201,6 +3411,8 @@ yyreduce:
     break;
 
   case 98:
+
+/* Line 1806 of yacc.c  */
 #line 797 "go.y"
     {
 		(yyval.node) = nod(OLT, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3208,6 +3420,8 @@ yyreduce:
     break;
 
   case 99:
+
+/* Line 1806 of yacc.c  */
 #line 801 "go.y"
     {
 		(yyval.node) = nod(OLE, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3215,6 +3429,8 @@ yyreduce:
     break;
 
   case 100:
+
+/* Line 1806 of yacc.c  */
 #line 805 "go.y"
     {
 		(yyval.node) = nod(OGE, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3222,6 +3438,8 @@ yyreduce:
     break;
 
   case 101:
+
+/* Line 1806 of yacc.c  */
 #line 809 "go.y"
     {
 		(yyval.node) = nod(OGT, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3229,6 +3447,8 @@ yyreduce:
     break;
 
   case 102:
+
+/* Line 1806 of yacc.c  */
 #line 813 "go.y"
     {
 		(yyval.node) = nod(OADD, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3236,6 +3456,8 @@ yyreduce:
     break;
 
   case 103:
+
+/* Line 1806 of yacc.c  */
 #line 817 "go.y"
     {
 		(yyval.node) = nod(OSUB, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3243,6 +3465,8 @@ yyreduce:
     break;
 
   case 104:
+
+/* Line 1806 of yacc.c  */
 #line 821 "go.y"
     {
 		(yyval.node) = nod(OOR, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3250,6 +3474,8 @@ yyreduce:
     break;
 
   case 105:
+
+/* Line 1806 of yacc.c  */
 #line 825 "go.y"
     {
 		(yyval.node) = nod(OXOR, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3257,6 +3483,8 @@ yyreduce:
     break;
 
   case 106:
+
+/* Line 1806 of yacc.c  */
 #line 829 "go.y"
     {
 		(yyval.node) = nod(OMUL, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3264,6 +3492,8 @@ yyreduce:
     break;
 
   case 107:
+
+/* Line 1806 of yacc.c  */
 #line 833 "go.y"
     {
 		(yyval.node) = nod(ODIV, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3271,6 +3501,8 @@ yyreduce:
     break;
 
   case 108:
+
+/* Line 1806 of yacc.c  */
 #line 837 "go.y"
     {
 		(yyval.node) = nod(OMOD, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3278,6 +3510,8 @@ yyreduce:
     break;
 
   case 109:
+
+/* Line 1806 of yacc.c  */
 #line 841 "go.y"
     {
 		(yyval.node) = nod(OAND, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3285,6 +3519,8 @@ yyreduce:
     break;
 
   case 110:
+
+/* Line 1806 of yacc.c  */
 #line 845 "go.y"
     {
 		(yyval.node) = nod(OANDNOT, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3292,6 +3528,8 @@ yyreduce:
     break;
 
   case 111:
+
+/* Line 1806 of yacc.c  */
 #line 849 "go.y"
     {
 		(yyval.node) = nod(OLSH, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3299,6 +3537,8 @@ yyreduce:
     break;
 
   case 112:
+
+/* Line 1806 of yacc.c  */
 #line 853 "go.y"
     {
 		(yyval.node) = nod(ORSH, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3306,6 +3546,8 @@ yyreduce:
     break;
 
   case 113:
+
+/* Line 1806 of yacc.c  */
 #line 858 "go.y"
     {
 		(yyval.node) = nod(OSEND, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3313,6 +3555,8 @@ yyreduce:
     break;
 
   case 115:
+
+/* Line 1806 of yacc.c  */
 #line 865 "go.y"
     {
 		(yyval.node) = nod(OIND, (yyvsp[(2) - (2)].node), N);
@@ -3320,6 +3564,8 @@ yyreduce:
     break;
 
   case 116:
+
+/* Line 1806 of yacc.c  */
 #line 869 "go.y"
     {
 		if((yyvsp[(2) - (2)].node)->op == OCOMPLIT) {
@@ -3334,6 +3580,8 @@ yyreduce:
     break;
 
   case 117:
+
+/* Line 1806 of yacc.c  */
 #line 880 "go.y"
     {
 		(yyval.node) = nod(OPLUS, (yyvsp[(2) - (2)].node), N);
@@ -3341,6 +3589,8 @@ yyreduce:
     break;
 
   case 118:
+
+/* Line 1806 of yacc.c  */
 #line 884 "go.y"
     {
 		(yyval.node) = nod(OMINUS, (yyvsp[(2) - (2)].node), N);
@@ -3348,6 +3598,8 @@ yyreduce:
     break;
 
   case 119:
+
+/* Line 1806 of yacc.c  */
 #line 888 "go.y"
     {
 		(yyval.node) = nod(ONOT, (yyvsp[(2) - (2)].node), N);
@@ -3355,6 +3607,8 @@ yyreduce:
     break;
 
   case 120:
+
+/* Line 1806 of yacc.c  */
 #line 892 "go.y"
     {
 		yyerror("the bitwise complement operator is ^");
@@ -3363,6 +3617,8 @@ yyreduce:
     break;
 
   case 121:
+
+/* Line 1806 of yacc.c  */
 #line 897 "go.y"
     {
 		(yyval.node) = nod(OCOM, (yyvsp[(2) - (2)].node), N);
@@ -3370,6 +3626,8 @@ yyreduce:
     break;
 
   case 122:
+
+/* Line 1806 of yacc.c  */
 #line 901 "go.y"
     {
 		(yyval.node) = nod(ORECV, (yyvsp[(2) - (2)].node), N);
@@ -3377,6 +3635,8 @@ yyreduce:
     break;
 
   case 123:
+
+/* Line 1806 of yacc.c  */
 #line 911 "go.y"
     {
 		(yyval.node) = nod(OCALL, (yyvsp[(1) - (3)].node), N);
@@ -3384,6 +3644,8 @@ yyreduce:
     break;
 
   case 124:
+
+/* Line 1806 of yacc.c  */
 #line 915 "go.y"
     {
 		(yyval.node) = nod(OCALL, (yyvsp[(1) - (5)].node), N);
@@ -3392,6 +3654,8 @@ yyreduce:
     break;
 
   case 125:
+
+/* Line 1806 of yacc.c  */
 #line 920 "go.y"
     {
 		(yyval.node) = nod(OCALL, (yyvsp[(1) - (6)].node), N);
@@ -3401,6 +3665,8 @@ yyreduce:
     break;
 
   case 126:
+
+/* Line 1806 of yacc.c  */
 #line 928 "go.y"
     {
 		(yyval.node) = nodlit((yyvsp[(1) - (1)].val));
@@ -3408,6 +3674,8 @@ yyreduce:
     break;
 
   case 128:
+
+/* Line 1806 of yacc.c  */
 #line 933 "go.y"
     {
 		if((yyvsp[(1) - (3)].node)->op == OPACK) {
@@ -3422,6 +3690,8 @@ yyreduce:
     break;
 
   case 129:
+
+/* Line 1806 of yacc.c  */
 #line 944 "go.y"
     {
 		(yyval.node) = nod(ODOTTYPE, (yyvsp[(1) - (5)].node), (yyvsp[(4) - (5)].node));
@@ -3429,6 +3699,8 @@ yyreduce:
     break;
 
   case 130:
+
+/* Line 1806 of yacc.c  */
 #line 948 "go.y"
     {
 		(yyval.node) = nod(OTYPESW, N, (yyvsp[(1) - (5)].node));
@@ -3436,6 +3708,8 @@ yyreduce:
     break;
 
   case 131:
+
+/* Line 1806 of yacc.c  */
 #line 952 "go.y"
     {
 		(yyval.node) = nod(OINDEX, (yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].node));
@@ -3443,6 +3717,8 @@ yyreduce:
     break;
 
   case 132:
+
+/* Line 1806 of yacc.c  */
 #line 956 "go.y"
     {
 		(yyval.node) = nod(OSLICE, (yyvsp[(1) - (6)].node), nod(OKEY, (yyvsp[(3) - (6)].node), (yyvsp[(5) - (6)].node)));
@@ -3450,6 +3726,8 @@ yyreduce:
     break;
 
   case 133:
+
+/* Line 1806 of yacc.c  */
 #line 960 "go.y"
     {
 		// Make sure we don't accidentally release this experimental feature.
@@ -3468,6 +3746,8 @@ yyreduce:
     break;
 
   case 135:
+
+/* Line 1806 of yacc.c  */
 #line 976 "go.y"
     {
 		// conversion
@@ -3477,6 +3757,8 @@ yyreduce:
     break;
 
   case 136:
+
+/* Line 1806 of yacc.c  */
 #line 982 "go.y"
     {
 		(yyval.node) = (yyvsp[(3) - (5)].node);
@@ -3487,6 +3769,8 @@ yyreduce:
     break;
 
   case 137:
+
+/* Line 1806 of yacc.c  */
 #line 989 "go.y"
     {
 		(yyval.node) = (yyvsp[(3) - (5)].node);
@@ -3496,6 +3780,8 @@ yyreduce:
     break;
 
   case 138:
+
+/* Line 1806 of yacc.c  */
 #line 995 "go.y"
     {
 		yyerror("cannot parenthesize type in composite literal");
@@ -3506,6 +3792,8 @@ yyreduce:
     break;
 
   case 140:
+
+/* Line 1806 of yacc.c  */
 #line 1004 "go.y"
     {
 		// composite expression.
@@ -3515,6 +3803,8 @@ yyreduce:
     break;
 
   case 141:
+
+/* Line 1806 of yacc.c  */
 #line 1012 "go.y"
     {
 		(yyval.node) = nod(OKEY, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3522,6 +3812,8 @@ yyreduce:
     break;
 
   case 142:
+
+/* Line 1806 of yacc.c  */
 #line 1018 "go.y"
     {
 		// These nodes do not carry line numbers.
@@ -3542,6 +3834,8 @@ yyreduce:
     break;
 
   case 143:
+
+/* Line 1806 of yacc.c  */
 #line 1035 "go.y"
     {
 		(yyval.node) = (yyvsp[(2) - (4)].node);
@@ -3550,6 +3844,8 @@ yyreduce:
     break;
 
   case 145:
+
+/* Line 1806 of yacc.c  */
 #line 1043 "go.y"
     {
 		(yyval.node) = (yyvsp[(2) - (4)].node);
@@ -3558,6 +3854,8 @@ yyreduce:
     break;
 
   case 147:
+
+/* Line 1806 of yacc.c  */
 #line 1051 "go.y"
     {
 		(yyval.node) = (yyvsp[(2) - (3)].node);
@@ -3578,6 +3876,8 @@ yyreduce:
     break;
 
   case 151:
+
+/* Line 1806 of yacc.c  */
 #line 1077 "go.y"
     {
 		(yyval.i) = LBODY;
@@ -3585,6 +3885,8 @@ yyreduce:
     break;
 
   case 152:
+
+/* Line 1806 of yacc.c  */
 #line 1081 "go.y"
     {
 		(yyval.i) = '{';
@@ -3592,6 +3894,8 @@ yyreduce:
     break;
 
   case 153:
+
+/* Line 1806 of yacc.c  */
 #line 1092 "go.y"
     {
 		if((yyvsp[(1) - (1)].sym) == S)
@@ -3602,6 +3906,8 @@ yyreduce:
     break;
 
   case 154:
+
+/* Line 1806 of yacc.c  */
 #line 1101 "go.y"
     {
 		(yyval.node) = dclname((yyvsp[(1) - (1)].sym));
@@ -3609,6 +3915,8 @@ yyreduce:
     break;
 
   case 155:
+
+/* Line 1806 of yacc.c  */
 #line 1106 "go.y"
     {
 		(yyval.node) = N;
@@ -3616,6 +3924,8 @@ yyreduce:
     break;
 
   case 157:
+
+/* Line 1806 of yacc.c  */
 #line 1113 "go.y"
     {
 		(yyval.sym) = (yyvsp[(1) - (1)].sym);
@@ -3626,6 +3936,8 @@ yyreduce:
     break;
 
   case 159:
+
+/* Line 1806 of yacc.c  */
 #line 1121 "go.y"
     {
 		(yyval.sym) = S;
@@ -3633,6 +3945,8 @@ yyreduce:
     break;
 
   case 160:
+
+/* Line 1806 of yacc.c  */
 #line 1127 "go.y"
     {
 		Pkg *p;
@@ -3649,6 +3963,8 @@ yyreduce:
     break;
 
   case 161:
+
+/* Line 1806 of yacc.c  */
 #line 1142 "go.y"
     {
 		(yyval.node) = oldname((yyvsp[(1) - (1)].sym));
@@ -3658,6 +3974,8 @@ yyreduce:
     break;
 
   case 163:
+
+/* Line 1806 of yacc.c  */
 #line 1162 "go.y"
     {
 		yyerror("final argument in variadic function missing type");
@@ -3666,6 +3984,8 @@ yyreduce:
     break;
 
   case 164:
+
+/* Line 1806 of yacc.c  */
 #line 1167 "go.y"
     {
 		(yyval.node) = nod(ODDD, (yyvsp[(2) - (2)].node), N);
@@ -3673,6 +3993,8 @@ yyreduce:
     break;
 
   case 170:
+
+/* Line 1806 of yacc.c  */
 #line 1178 "go.y"
     {
 		(yyval.node) = nod(OTPAREN, (yyvsp[(2) - (3)].node), N);
@@ -3680,6 +4002,8 @@ yyreduce:
     break;
 
   case 174:
+
+/* Line 1806 of yacc.c  */
 #line 1187 "go.y"
     {
 		(yyval.node) = nod(OIND, (yyvsp[(2) - (2)].node), N);
@@ -3687,6 +4011,8 @@ yyreduce:
     break;
 
   case 179:
+
+/* Line 1806 of yacc.c  */
 #line 1197 "go.y"
     {
 		(yyval.node) = nod(OTPAREN, (yyvsp[(2) - (3)].node), N);
@@ -3694,6 +4020,8 @@ yyreduce:
     break;
 
   case 189:
+
+/* Line 1806 of yacc.c  */
 #line 1218 "go.y"
     {
 		if((yyvsp[(1) - (3)].node)->op == OPACK) {
@@ -3708,6 +4036,8 @@ yyreduce:
     break;
 
   case 190:
+
+/* Line 1806 of yacc.c  */
 #line 1231 "go.y"
     {
 		(yyval.node) = nod(OTARRAY, (yyvsp[(2) - (4)].node), (yyvsp[(4) - (4)].node));
@@ -3715,6 +4045,8 @@ yyreduce:
     break;
 
   case 191:
+
+/* Line 1806 of yacc.c  */
 #line 1235 "go.y"
     {
 		// array literal of nelem
@@ -3723,6 +4055,8 @@ yyreduce:
     break;
 
   case 192:
+
+/* Line 1806 of yacc.c  */
 #line 1240 "go.y"
     {
 		(yyval.node) = nod(OTCHAN, (yyvsp[(2) - (2)].node), N);
@@ -3731,6 +4065,8 @@ yyreduce:
     break;
 
   case 193:
+
+/* Line 1806 of yacc.c  */
 #line 1245 "go.y"
     {
 		(yyval.node) = nod(OTCHAN, (yyvsp[(3) - (3)].node), N);
@@ -3739,6 +4075,8 @@ yyreduce:
     break;
 
   case 194:
+
+/* Line 1806 of yacc.c  */
 #line 1250 "go.y"
     {
 		(yyval.node) = nod(OTMAP, (yyvsp[(3) - (5)].node), (yyvsp[(5) - (5)].node));
@@ -3746,6 +4084,8 @@ yyreduce:
     break;
 
   case 197:
+
+/* Line 1806 of yacc.c  */
 #line 1258 "go.y"
     {
 		(yyval.node) = nod(OIND, (yyvsp[(2) - (2)].node), N);
@@ -3753,6 +4093,8 @@ yyreduce:
     break;
 
   case 198:
+
+/* Line 1806 of yacc.c  */
 #line 1264 "go.y"
     {
 		(yyval.node) = nod(OTCHAN, (yyvsp[(3) - (3)].node), N);
@@ -3761,6 +4103,8 @@ yyreduce:
     break;
 
   case 199:
+
+/* Line 1806 of yacc.c  */
 #line 1271 "go.y"
     {
 		(yyval.node) = nod(OTSTRUCT, N, N);
@@ -3770,6 +4114,8 @@ yyreduce:
     break;
 
   case 200:
+
+/* Line 1806 of yacc.c  */
 #line 1277 "go.y"
     {
 		(yyval.node) = nod(OTSTRUCT, N, N);
@@ -3778,6 +4124,8 @@ yyreduce:
     break;
 
   case 201:
+
+/* Line 1806 of yacc.c  */
 #line 1284 "go.y"
     {
 		(yyval.node) = nod(OTINTER, N, N);
@@ -3787,6 +4135,8 @@ yyreduce:
     break;
 
   case 202:
+
+/* Line 1806 of yacc.c  */
 #line 1290 "go.y"
     {
 		(yyval.node) = nod(OTINTER, N, N);
@@ -3795,6 +4145,8 @@ yyreduce:
     break;
 
   case 203:
+
+/* Line 1806 of yacc.c  */
 #line 1301 "go.y"
     {
 		(yyval.node) = (yyvsp[(2) - (3)].node);
@@ -3810,6 +4162,8 @@ yyreduce:
     break;
 
   case 204:
+
+/* Line 1806 of yacc.c  */
 #line 1315 "go.y"
     {
 		Node *t;
@@ -3842,6 +4196,8 @@ yyreduce:
     break;
 
   case 205:
+
+/* Line 1806 of yacc.c  */
 #line 1344 "go.y"
     {
 		Node *rcvr, *t;
@@ -3883,6 +4239,8 @@ yyreduce:
     break;
 
   case 206:
+
+/* Line 1806 of yacc.c  */
 #line 1384 "go.y"
     {
 		Sym *s;
@@ -3911,6 +4269,8 @@ yyreduce:
     break;
 
   case 207:
+
+/* Line 1806 of yacc.c  */
 #line 1409 "go.y"
     {
 		(yyval.node) = methodname1(newname((yyvsp[(4) - (8)].sym)), (yyvsp[(2) - (8)].list)->n->right); 
@@ -3930,6 +4290,8 @@ yyreduce:
     break;
 
   case 208:
+
+/* Line 1806 of yacc.c  */
 #line 1427 "go.y"
     {
 		(yyvsp[(3) - (5)].list) = checkarglist((yyvsp[(3) - (5)].list), 1);
@@ -3940,6 +4302,8 @@ yyreduce:
     break;
 
   case 209:
+
+/* Line 1806 of yacc.c  */
 #line 1435 "go.y"
     {
 		(yyval.list) = nil;
@@ -3947,6 +4311,8 @@ yyreduce:
     break;
 
   case 210:
+
+/* Line 1806 of yacc.c  */
 #line 1439 "go.y"
     {
 		(yyval.list) = (yyvsp[(2) - (3)].list);
@@ -3956,6 +4322,8 @@ yyreduce:
     break;
 
   case 211:
+
+/* Line 1806 of yacc.c  */
 #line 1447 "go.y"
     {
 		(yyval.list) = nil;
@@ -3963,6 +4331,8 @@ yyreduce:
     break;
 
   case 212:
+
+/* Line 1806 of yacc.c  */
 #line 1451 "go.y"
     {
 		(yyval.list) = list1(nod(ODCLFIELD, N, (yyvsp[(1) - (1)].node)));
@@ -3970,6 +4340,8 @@ yyreduce:
     break;
 
   case 213:
+
+/* Line 1806 of yacc.c  */
 #line 1455 "go.y"
     {
 		(yyvsp[(2) - (3)].list) = checkarglist((yyvsp[(2) - (3)].list), 0);
@@ -3978,6 +4350,8 @@ yyreduce:
     break;
 
   case 214:
+
+/* Line 1806 of yacc.c  */
 #line 1462 "go.y"
     {
 		closurehdr((yyvsp[(1) - (1)].node));
@@ -3985,6 +4359,8 @@ yyreduce:
     break;
 
   case 215:
+
+/* Line 1806 of yacc.c  */
 #line 1468 "go.y"
     {
 		(yyval.node) = closurebody((yyvsp[(3) - (4)].list));
@@ -3993,6 +4369,8 @@ yyreduce:
     break;
 
   case 216:
+
+/* Line 1806 of yacc.c  */
 #line 1473 "go.y"
     {
 		(yyval.node) = closurebody(nil);
@@ -4000,6 +4378,8 @@ yyreduce:
     break;
 
   case 217:
+
+/* Line 1806 of yacc.c  */
 #line 1484 "go.y"
     {
 		(yyval.list) = nil;
@@ -4007,6 +4387,8 @@ yyreduce:
     break;
 
   case 218:
+
+/* Line 1806 of yacc.c  */
 #line 1488 "go.y"
     {
 		(yyval.list) = concat((yyvsp[(1) - (3)].list), (yyvsp[(2) - (3)].list));
@@ -4018,6 +4400,8 @@ yyreduce:
     break;
 
   case 220:
+
+/* Line 1806 of yacc.c  */
 #line 1499 "go.y"
     {
 		(yyval.list) = concat((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].list));
@@ -4025,6 +4409,8 @@ yyreduce:
     break;
 
   case 222:
+
+/* Line 1806 of yacc.c  */
 #line 1506 "go.y"
     {
 		(yyval.list) = concat((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].list));
@@ -4032,6 +4418,8 @@ yyreduce:
     break;
 
   case 223:
+
+/* Line 1806 of yacc.c  */
 #line 1512 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4039,6 +4427,8 @@ yyreduce:
     break;
 
   case 224:
+
+/* Line 1806 of yacc.c  */
 #line 1516 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4046,6 +4436,8 @@ yyreduce:
     break;
 
   case 226:
+
+/* Line 1806 of yacc.c  */
 #line 1523 "go.y"
     {
 		(yyval.list) = concat((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].list));
@@ -4053,6 +4445,8 @@ yyreduce:
     break;
 
   case 227:
+
+/* Line 1806 of yacc.c  */
 #line 1529 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4060,6 +4454,8 @@ yyreduce:
     break;
 
   case 228:
+
+/* Line 1806 of yacc.c  */
 #line 1533 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4067,14 +4463,16 @@ yyreduce:
     break;
 
   case 229:
+
+/* Line 1806 of yacc.c  */
 #line 1539 "go.y"
     {
 		NodeList *l;
 
 		Node *n;
 		l = (yyvsp[(1) - (3)].list);
-		if(l != nil && l->next == nil && l->n == nil) {
-			// ? symbol, during import
+		if(l == nil) {
+			// ? symbol, during import (list1(N) == nil)
 			n = (yyvsp[(2) - (3)].node);
 			if(n->op == OIND)
 				n = n->left;
@@ -4093,6 +4491,8 @@ yyreduce:
     break;
 
   case 230:
+
+/* Line 1806 of yacc.c  */
 #line 1562 "go.y"
     {
 		(yyvsp[(1) - (2)].node)->val = (yyvsp[(2) - (2)].val);
@@ -4101,6 +4501,8 @@ yyreduce:
     break;
 
   case 231:
+
+/* Line 1806 of yacc.c  */
 #line 1567 "go.y"
     {
 		(yyvsp[(2) - (4)].node)->val = (yyvsp[(4) - (4)].val);
@@ -4110,6 +4512,8 @@ yyreduce:
     break;
 
   case 232:
+
+/* Line 1806 of yacc.c  */
 #line 1573 "go.y"
     {
 		(yyvsp[(2) - (3)].node)->right = nod(OIND, (yyvsp[(2) - (3)].node)->right, N);
@@ -4119,6 +4523,8 @@ yyreduce:
     break;
 
   case 233:
+
+/* Line 1806 of yacc.c  */
 #line 1579 "go.y"
     {
 		(yyvsp[(3) - (5)].node)->right = nod(OIND, (yyvsp[(3) - (5)].node)->right, N);
@@ -4129,6 +4535,8 @@ yyreduce:
     break;
 
   case 234:
+
+/* Line 1806 of yacc.c  */
 #line 1586 "go.y"
     {
 		(yyvsp[(3) - (5)].node)->right = nod(OIND, (yyvsp[(3) - (5)].node)->right, N);
@@ -4139,6 +4547,8 @@ yyreduce:
     break;
 
   case 235:
+
+/* Line 1806 of yacc.c  */
 #line 1595 "go.y"
     {
 		Node *n;
@@ -4151,6 +4561,8 @@ yyreduce:
     break;
 
   case 236:
+
+/* Line 1806 of yacc.c  */
 #line 1604 "go.y"
     {
 		Pkg *pkg;
@@ -4167,6 +4579,8 @@ yyreduce:
     break;
 
   case 237:
+
+/* Line 1806 of yacc.c  */
 #line 1619 "go.y"
     {
 		(yyval.node) = embedded((yyvsp[(1) - (1)].sym));
@@ -4174,6 +4588,8 @@ yyreduce:
     break;
 
   case 238:
+
+/* Line 1806 of yacc.c  */
 #line 1625 "go.y"
     {
 		(yyval.node) = nod(ODCLFIELD, (yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].node));
@@ -4182,6 +4598,8 @@ yyreduce:
     break;
 
   case 239:
+
+/* Line 1806 of yacc.c  */
 #line 1630 "go.y"
     {
 		(yyval.node) = nod(ODCLFIELD, N, oldname((yyvsp[(1) - (1)].sym)));
@@ -4189,6 +4607,8 @@ yyreduce:
     break;
 
   case 240:
+
+/* Line 1806 of yacc.c  */
 #line 1634 "go.y"
     {
 		(yyval.node) = nod(ODCLFIELD, N, oldname((yyvsp[(2) - (3)].sym)));
@@ -4197,6 +4617,8 @@ yyreduce:
     break;
 
   case 241:
+
+/* Line 1806 of yacc.c  */
 #line 1641 "go.y"
     {
 		// without func keyword
@@ -4208,6 +4630,8 @@ yyreduce:
     break;
 
   case 243:
+
+/* Line 1806 of yacc.c  */
 #line 1655 "go.y"
     {
 		(yyval.node) = nod(ONONAME, N, N);
@@ -4217,6 +4641,8 @@ yyreduce:
     break;
 
   case 244:
+
+/* Line 1806 of yacc.c  */
 #line 1661 "go.y"
     {
 		(yyval.node) = nod(ONONAME, N, N);
@@ -4226,6 +4652,8 @@ yyreduce:
     break;
 
   case 246:
+
+/* Line 1806 of yacc.c  */
 #line 1670 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4233,6 +4661,8 @@ yyreduce:
     break;
 
   case 247:
+
+/* Line 1806 of yacc.c  */
 #line 1674 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4240,6 +4670,8 @@ yyreduce:
     break;
 
   case 248:
+
+/* Line 1806 of yacc.c  */
 #line 1679 "go.y"
     {
 		(yyval.list) = nil;
@@ -4247,6 +4679,8 @@ yyreduce:
     break;
 
   case 249:
+
+/* Line 1806 of yacc.c  */
 #line 1683 "go.y"
     {
 		(yyval.list) = (yyvsp[(1) - (2)].list);
@@ -4254,6 +4688,8 @@ yyreduce:
     break;
 
   case 250:
+
+/* Line 1806 of yacc.c  */
 #line 1691 "go.y"
     {
 		(yyval.node) = N;
@@ -4261,6 +4697,8 @@ yyreduce:
     break;
 
   case 252:
+
+/* Line 1806 of yacc.c  */
 #line 1696 "go.y"
     {
 		(yyval.node) = liststmt((yyvsp[(1) - (1)].list));
@@ -4268,6 +4706,8 @@ yyreduce:
     break;
 
   case 254:
+
+/* Line 1806 of yacc.c  */
 #line 1701 "go.y"
     {
 		(yyval.node) = N;
@@ -4275,6 +4715,8 @@ yyreduce:
     break;
 
   case 260:
+
+/* Line 1806 of yacc.c  */
 #line 1712 "go.y"
     {
 		(yyvsp[(1) - (2)].node) = nod(OLABEL, (yyvsp[(1) - (2)].node), N);
@@ -4283,6 +4725,8 @@ yyreduce:
     break;
 
   case 261:
+
+/* Line 1806 of yacc.c  */
 #line 1717 "go.y"
     {
 		NodeList *l;
@@ -4296,6 +4740,8 @@ yyreduce:
     break;
 
   case 262:
+
+/* Line 1806 of yacc.c  */
 #line 1727 "go.y"
     {
 		// will be converted to OFALL
@@ -4304,6 +4750,8 @@ yyreduce:
     break;
 
   case 263:
+
+/* Line 1806 of yacc.c  */
 #line 1732 "go.y"
     {
 		(yyval.node) = nod(OBREAK, (yyvsp[(2) - (2)].node), N);
@@ -4311,6 +4759,8 @@ yyreduce:
     break;
 
   case 264:
+
+/* Line 1806 of yacc.c  */
 #line 1736 "go.y"
     {
 		(yyval.node) = nod(OCONTINUE, (yyvsp[(2) - (2)].node), N);
@@ -4318,6 +4768,8 @@ yyreduce:
     break;
 
   case 265:
+
+/* Line 1806 of yacc.c  */
 #line 1740 "go.y"
     {
 		(yyval.node) = nod(OPROC, (yyvsp[(2) - (2)].node), N);
@@ -4325,6 +4777,8 @@ yyreduce:
     break;
 
   case 266:
+
+/* Line 1806 of yacc.c  */
 #line 1744 "go.y"
     {
 		(yyval.node) = nod(ODEFER, (yyvsp[(2) - (2)].node), N);
@@ -4332,6 +4786,8 @@ yyreduce:
     break;
 
   case 267:
+
+/* Line 1806 of yacc.c  */
 #line 1748 "go.y"
     {
 		(yyval.node) = nod(OGOTO, (yyvsp[(2) - (2)].node), N);
@@ -4340,6 +4796,8 @@ yyreduce:
     break;
 
   case 268:
+
+/* Line 1806 of yacc.c  */
 #line 1753 "go.y"
     {
 		(yyval.node) = nod(ORETURN, N, N);
@@ -4360,6 +4818,8 @@ yyreduce:
     break;
 
   case 269:
+
+/* Line 1806 of yacc.c  */
 #line 1772 "go.y"
     {
 		(yyval.list) = nil;
@@ -4369,6 +4829,8 @@ yyreduce:
     break;
 
   case 270:
+
+/* Line 1806 of yacc.c  */
 #line 1778 "go.y"
     {
 		(yyval.list) = (yyvsp[(1) - (3)].list);
@@ -4378,6 +4840,8 @@ yyreduce:
     break;
 
   case 271:
+
+/* Line 1806 of yacc.c  */
 #line 1786 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4385,6 +4849,8 @@ yyreduce:
     break;
 
   case 272:
+
+/* Line 1806 of yacc.c  */
 #line 1790 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4392,6 +4858,8 @@ yyreduce:
     break;
 
   case 273:
+
+/* Line 1806 of yacc.c  */
 #line 1796 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4399,6 +4867,8 @@ yyreduce:
     break;
 
   case 274:
+
+/* Line 1806 of yacc.c  */
 #line 1800 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4406,6 +4876,8 @@ yyreduce:
     break;
 
   case 275:
+
+/* Line 1806 of yacc.c  */
 #line 1806 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4413,6 +4885,8 @@ yyreduce:
     break;
 
   case 276:
+
+/* Line 1806 of yacc.c  */
 #line 1810 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4420,6 +4894,8 @@ yyreduce:
     break;
 
   case 277:
+
+/* Line 1806 of yacc.c  */
 #line 1816 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4427,6 +4903,8 @@ yyreduce:
     break;
 
   case 278:
+
+/* Line 1806 of yacc.c  */
 #line 1820 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4434,6 +4912,8 @@ yyreduce:
     break;
 
   case 279:
+
+/* Line 1806 of yacc.c  */
 #line 1829 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4441,6 +4921,8 @@ yyreduce:
     break;
 
   case 280:
+
+/* Line 1806 of yacc.c  */
 #line 1833 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4448,6 +4930,8 @@ yyreduce:
     break;
 
   case 281:
+
+/* Line 1806 of yacc.c  */
 #line 1837 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4455,6 +4939,8 @@ yyreduce:
     break;
 
   case 282:
+
+/* Line 1806 of yacc.c  */
 #line 1841 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4462,6 +4948,8 @@ yyreduce:
     break;
 
   case 283:
+
+/* Line 1806 of yacc.c  */
 #line 1846 "go.y"
     {
 		(yyval.list) = nil;
@@ -4469,6 +4957,8 @@ yyreduce:
     break;
 
   case 284:
+
+/* Line 1806 of yacc.c  */
 #line 1850 "go.y"
     {
 		(yyval.list) = (yyvsp[(1) - (2)].list);
@@ -4476,6 +4966,8 @@ yyreduce:
     break;
 
   case 289:
+
+/* Line 1806 of yacc.c  */
 #line 1864 "go.y"
     {
 		(yyval.node) = N;
@@ -4483,6 +4975,8 @@ yyreduce:
     break;
 
   case 291:
+
+/* Line 1806 of yacc.c  */
 #line 1870 "go.y"
     {
 		(yyval.list) = nil;
@@ -4490,6 +4984,8 @@ yyreduce:
     break;
 
   case 293:
+
+/* Line 1806 of yacc.c  */
 #line 1876 "go.y"
     {
 		(yyval.node) = N;
@@ -4497,6 +4993,8 @@ yyreduce:
     break;
 
   case 295:
+
+/* Line 1806 of yacc.c  */
 #line 1882 "go.y"
     {
 		(yyval.list) = nil;
@@ -4504,6 +5002,8 @@ yyreduce:
     break;
 
   case 297:
+
+/* Line 1806 of yacc.c  */
 #line 1888 "go.y"
     {
 		(yyval.list) = nil;
@@ -4511,6 +5011,8 @@ yyreduce:
     break;
 
   case 299:
+
+/* Line 1806 of yacc.c  */
 #line 1894 "go.y"
     {
 		(yyval.list) = nil;
@@ -4518,6 +5020,8 @@ yyreduce:
     break;
 
   case 301:
+
+/* Line 1806 of yacc.c  */
 #line 1900 "go.y"
     {
 		(yyval.val).ctype = CTxxx;
@@ -4525,6 +5029,8 @@ yyreduce:
     break;
 
   case 303:
+
+/* Line 1806 of yacc.c  */
 #line 1910 "go.y"
     {
 		importimport((yyvsp[(2) - (4)].sym), (yyvsp[(3) - (4)].val).u.sval);
@@ -4532,6 +5038,8 @@ yyreduce:
     break;
 
   case 304:
+
+/* Line 1806 of yacc.c  */
 #line 1914 "go.y"
     {
 		importvar((yyvsp[(2) - (4)].sym), (yyvsp[(3) - (4)].type));
@@ -4539,6 +5047,8 @@ yyreduce:
     break;
 
   case 305:
+
+/* Line 1806 of yacc.c  */
 #line 1918 "go.y"
     {
 		importconst((yyvsp[(2) - (5)].sym), types[TIDEAL], (yyvsp[(4) - (5)].node));
@@ -4546,6 +5056,8 @@ yyreduce:
     break;
 
   case 306:
+
+/* Line 1806 of yacc.c  */
 #line 1922 "go.y"
     {
 		importconst((yyvsp[(2) - (6)].sym), (yyvsp[(3) - (6)].type), (yyvsp[(5) - (6)].node));
@@ -4553,6 +5065,8 @@ yyreduce:
     break;
 
   case 307:
+
+/* Line 1806 of yacc.c  */
 #line 1926 "go.y"
     {
 		importtype((yyvsp[(2) - (4)].type), (yyvsp[(3) - (4)].type));
@@ -4560,6 +5074,8 @@ yyreduce:
     break;
 
   case 308:
+
+/* Line 1806 of yacc.c  */
 #line 1930 "go.y"
     {
 		if((yyvsp[(2) - (4)].node) == N) {
@@ -4581,6 +5097,8 @@ yyreduce:
     break;
 
   case 309:
+
+/* Line 1806 of yacc.c  */
 #line 1950 "go.y"
     {
 		(yyval.sym) = (yyvsp[(1) - (1)].sym);
@@ -4589,6 +5107,8 @@ yyreduce:
     break;
 
   case 310:
+
+/* Line 1806 of yacc.c  */
 #line 1957 "go.y"
     {
 		(yyval.type) = pkgtype((yyvsp[(1) - (1)].sym));
@@ -4597,6 +5117,8 @@ yyreduce:
     break;
 
   case 316:
+
+/* Line 1806 of yacc.c  */
 #line 1977 "go.y"
     {
 		(yyval.type) = pkgtype((yyvsp[(1) - (1)].sym));
@@ -4604,6 +5126,8 @@ yyreduce:
     break;
 
   case 317:
+
+/* Line 1806 of yacc.c  */
 #line 1981 "go.y"
     {
 		// predefined name like uint8
@@ -4617,6 +5141,8 @@ yyreduce:
     break;
 
   case 318:
+
+/* Line 1806 of yacc.c  */
 #line 1991 "go.y"
     {
 		(yyval.type) = aindex(N, (yyvsp[(3) - (3)].type));
@@ -4624,6 +5150,8 @@ yyreduce:
     break;
 
   case 319:
+
+/* Line 1806 of yacc.c  */
 #line 1995 "go.y"
     {
 		(yyval.type) = aindex(nodlit((yyvsp[(2) - (4)].val)), (yyvsp[(4) - (4)].type));
@@ -4631,6 +5159,8 @@ yyreduce:
     break;
 
   case 320:
+
+/* Line 1806 of yacc.c  */
 #line 1999 "go.y"
     {
 		(yyval.type) = maptype((yyvsp[(3) - (5)].type), (yyvsp[(5) - (5)].type));
@@ -4638,6 +5168,8 @@ yyreduce:
     break;
 
   case 321:
+
+/* Line 1806 of yacc.c  */
 #line 2003 "go.y"
     {
 		(yyval.type) = tostruct((yyvsp[(3) - (4)].list));
@@ -4645,6 +5177,8 @@ yyreduce:
     break;
 
   case 322:
+
+/* Line 1806 of yacc.c  */
 #line 2007 "go.y"
     {
 		(yyval.type) = tointerface((yyvsp[(3) - (4)].list));
@@ -4652,6 +5186,8 @@ yyreduce:
     break;
 
   case 323:
+
+/* Line 1806 of yacc.c  */
 #line 2011 "go.y"
     {
 		(yyval.type) = ptrto((yyvsp[(2) - (2)].type));
@@ -4659,6 +5195,8 @@ yyreduce:
     break;
 
   case 324:
+
+/* Line 1806 of yacc.c  */
 #line 2015 "go.y"
     {
 		(yyval.type) = typ(TCHAN);
@@ -4668,6 +5206,8 @@ yyreduce:
     break;
 
   case 325:
+
+/* Line 1806 of yacc.c  */
 #line 2021 "go.y"
     {
 		(yyval.type) = typ(TCHAN);
@@ -4677,6 +5217,8 @@ yyreduce:
     break;
 
   case 326:
+
+/* Line 1806 of yacc.c  */
 #line 2027 "go.y"
     {
 		(yyval.type) = typ(TCHAN);
@@ -4686,6 +5228,8 @@ yyreduce:
     break;
 
   case 327:
+
+/* Line 1806 of yacc.c  */
 #line 2035 "go.y"
     {
 		(yyval.type) = typ(TCHAN);
@@ -4695,6 +5239,8 @@ yyreduce:
     break;
 
   case 328:
+
+/* Line 1806 of yacc.c  */
 #line 2043 "go.y"
     {
 		(yyval.type) = functype(nil, (yyvsp[(3) - (5)].list), (yyvsp[(5) - (5)].list));
@@ -4702,6 +5248,8 @@ yyreduce:
     break;
 
   case 329:
+
+/* Line 1806 of yacc.c  */
 #line 2049 "go.y"
     {
 		(yyval.node) = nod(ODCLFIELD, N, typenod((yyvsp[(2) - (3)].type)));
@@ -4712,6 +5260,8 @@ yyreduce:
     break;
 
   case 330:
+
+/* Line 1806 of yacc.c  */
 #line 2056 "go.y"
     {
 		Type *t;
@@ -4729,6 +5279,8 @@ yyreduce:
     break;
 
   case 331:
+
+/* Line 1806 of yacc.c  */
 #line 2072 "go.y"
     {
 		Sym *s;
@@ -4748,6 +5300,8 @@ yyreduce:
     break;
 
   case 332:
+
+/* Line 1806 of yacc.c  */
 #line 2090 "go.y"
     {
 		(yyval.node) = nod(ODCLFIELD, newname((yyvsp[(1) - (5)].sym)), typenod(functype(fakethis(), (yyvsp[(3) - (5)].list), (yyvsp[(5) - (5)].list))));
@@ -4755,6 +5309,8 @@ yyreduce:
     break;
 
   case 333:
+
+/* Line 1806 of yacc.c  */
 #line 2094 "go.y"
     {
 		(yyval.node) = nod(ODCLFIELD, N, typenod((yyvsp[(1) - (1)].type)));
@@ -4762,6 +5318,8 @@ yyreduce:
     break;
 
   case 334:
+
+/* Line 1806 of yacc.c  */
 #line 2099 "go.y"
     {
 		(yyval.list) = nil;
@@ -4769,6 +5327,8 @@ yyreduce:
     break;
 
   case 336:
+
+/* Line 1806 of yacc.c  */
 #line 2106 "go.y"
     {
 		(yyval.list) = (yyvsp[(2) - (3)].list);
@@ -4776,6 +5336,8 @@ yyreduce:
     break;
 
   case 337:
+
+/* Line 1806 of yacc.c  */
 #line 2110 "go.y"
     {
 		(yyval.list) = list1(nod(ODCLFIELD, N, typenod((yyvsp[(1) - (1)].type))));
@@ -4783,6 +5345,8 @@ yyreduce:
     break;
 
   case 338:
+
+/* Line 1806 of yacc.c  */
 #line 2120 "go.y"
     {
 		(yyval.node) = nodlit((yyvsp[(1) - (1)].val));
@@ -4790,6 +5354,8 @@ yyreduce:
     break;
 
   case 339:
+
+/* Line 1806 of yacc.c  */
 #line 2124 "go.y"
     {
 		(yyval.node) = nodlit((yyvsp[(2) - (2)].val));
@@ -4808,6 +5374,8 @@ yyreduce:
     break;
 
   case 340:
+
+/* Line 1806 of yacc.c  */
 #line 2139 "go.y"
     {
 		(yyval.node) = oldname(pkglookup((yyvsp[(1) - (1)].sym)->name, builtinpkg));
@@ -4817,6 +5385,8 @@ yyreduce:
     break;
 
   case 342:
+
+/* Line 1806 of yacc.c  */
 #line 2148 "go.y"
     {
 		if((yyvsp[(2) - (5)].node)->val.ctype == CTRUNE && (yyvsp[(4) - (5)].node)->val.ctype == CTINT) {
@@ -4831,6 +5401,8 @@ yyreduce:
     break;
 
   case 345:
+
+/* Line 1806 of yacc.c  */
 #line 2164 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4838,6 +5410,8 @@ yyreduce:
     break;
 
   case 346:
+
+/* Line 1806 of yacc.c  */
 #line 2168 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4845,6 +5419,8 @@ yyreduce:
     break;
 
   case 347:
+
+/* Line 1806 of yacc.c  */
 #line 2174 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4852,6 +5428,8 @@ yyreduce:
     break;
 
   case 348:
+
+/* Line 1806 of yacc.c  */
 #line 2178 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4859,6 +5437,8 @@ yyreduce:
     break;
 
   case 349:
+
+/* Line 1806 of yacc.c  */
 #line 2184 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4866,6 +5446,8 @@ yyreduce:
     break;
 
   case 350:
+
+/* Line 1806 of yacc.c  */
 #line 2188 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4873,10 +5455,22 @@ yyreduce:
     break;
 
 
-/* Line 1267 of yacc.c.  */
-#line 4879 "y.tab.c"
+
+/* Line 1806 of yacc.c  */
+#line 5462 "y.tab.c"
       default: break;
     }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
   YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
   YYPOPSTACK (yylen);
@@ -4885,7 +5479,6 @@ yyreduce:
 
   *++yyvsp = yyval;
 
-
   /* Now `shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
      number reduced by.  */
@@ -4905,6 +5498,10 @@ yyreduce:
 | yyerrlab -- here on detecting error |
 `------------------------------------*/
 yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
   /* If not already recovering from an error, report this error.  */
   if (!yyerrstatus)
     {
@@ -4912,37 +5509,36 @@ yyerrlab:
 #if ! YYERROR_VERBOSE
       yyerror (YY_("syntax error"));
 #else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
       {
-	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
-	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
-	  {
-	    YYSIZE_T yyalloc = 2 * yysize;
-	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
-	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
-	    if (yymsg != yymsgbuf)
-	      YYSTACK_FREE (yymsg);
-	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
-	    if (yymsg)
-	      yymsg_alloc = yyalloc;
-	    else
-	      {
-		yymsg = yymsgbuf;
-		yymsg_alloc = sizeof yymsgbuf;
-	      }
-	  }
-
-	if (0 < yysize && yysize <= yymsg_alloc)
-	  {
-	    (void) yysyntax_error (yymsg, yystate, yychar);
-	    yyerror (yymsg);
-	  }
-	else
-	  {
-	    yyerror (YY_("syntax error"));
-	    if (yysize != 0)
-	      goto yyexhaustedlab;
-	  }
+        char *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
       }
+# undef YYSYNTAX_ERROR
 #endif
     }
 
@@ -4950,7 +5546,7 @@ yyerrlab:
 
   if (yyerrstatus == 3)
     {
-      /* If just tried and failed to reuse look-ahead token after an
+      /* If just tried and failed to reuse lookahead token after an
 	 error, discard it.  */
 
       if (yychar <= YYEOF)
@@ -4967,7 +5563,7 @@ yyerrlab:
 	}
     }
 
-  /* Else will try to reuse look-ahead token after shifting the error
+  /* Else will try to reuse lookahead token after shifting the error
      token.  */
   goto yyerrlab1;
 
@@ -5001,7 +5597,7 @@ yyerrlab1:
   for (;;)
     {
       yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
+      if (!yypact_value_is_default (yyn))
 	{
 	  yyn += YYTERROR;
 	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
@@ -5024,9 +5620,6 @@ yyerrlab1:
       YY_STACK_PRINT (yyss, yyssp);
     }
 
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
   *++yyvsp = yylval;
 
 
@@ -5051,7 +5644,7 @@ yyabortlab:
   yyresult = 1;
   goto yyreturn;
 
-#ifndef yyoverflow
+#if !defined(yyoverflow) || YYERROR_VERBOSE
 /*-------------------------------------------------.
 | yyexhaustedlab -- memory exhaustion comes here.  |
 `-------------------------------------------------*/
@@ -5062,9 +5655,14 @@ yyexhaustedlab:
 #endif
 
 yyreturn:
-  if (yychar != YYEOF && yychar != YYEMPTY)
-     yydestruct ("Cleanup: discarding lookahead",
-		 yytoken, &yylval);
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
   /* Do not reclaim the symbols of the rule which action triggered
      this YYABORT or YYACCEPT.  */
   YYPOPSTACK (yylen);
@@ -5088,6 +5686,8 @@ yyreturn:
 }
 
 
+
+/* Line 2067 of yacc.c  */
 #line 2192 "go.y"
 
 
diff --git a/src/cmd/gc/y.tab.h b/src/cmd/gc/y.tab.h
index b8e9d41b66..05259b1d49 100644
--- a/src/cmd/gc/y.tab.h
+++ b/src/cmd/gc/y.tab.h
@@ -1,24 +1,21 @@
-/* A Bison parser, made by GNU Bison 2.3.  */
+/* A Bison parser, made by GNU Bison 2.5.  */
 
-/* Skeleton interface for Bison's Yacc-like parsers in C
-
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
-   Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
+/* Bison interface for Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
+   
    You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -29,10 +26,11 @@
    special exception, which will cause the skeleton and the resulting
    Bison output files to be licensed under the GNU General Public
    License without this special exception.
-
+   
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
+
 /* Tokens.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
@@ -146,22 +144,28 @@
 
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-#line 30 "go.y"
 {
+
+/* Line 2068 of yacc.c  */
+#line 30 "go.y"
+
 	Node*		node;
 	NodeList*		list;
 	Type*		type;
 	Sym*		sym;
 	struct	Val	val;
 	int		i;
-}
-/* Line 1529 of yacc.c.  */
-#line 160 "y.tab.h"
-	YYSTYPE;
+
+
+
+/* Line 2068 of yacc.c  */
+#line 163 "y.tab.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
 #endif
 
 extern YYSTYPE yylval;
 
+
diff --git a/test/fixedbugs/issue5910.dir/a.go b/test/fixedbugs/issue5910.dir/a.go
new file mode 100644
index 0000000000..ea223917b6
--- /dev/null
+++ b/test/fixedbugs/issue5910.dir/a.go
@@ -0,0 +1,17 @@
+package a
+
+type Package struct {
+	name string
+}
+
+type Future struct {
+	result chan struct {
+		*Package
+	}
+}
+
+func (t *Future) Result() *Package {
+	result := <-t.result
+	t.result <- result
+	return result.Package
+}
diff --git a/test/fixedbugs/issue5910.dir/main.go b/test/fixedbugs/issue5910.dir/main.go
new file mode 100644
index 0000000000..6196381951
--- /dev/null
+++ b/test/fixedbugs/issue5910.dir/main.go
@@ -0,0 +1,8 @@
+package main
+
+import "a"
+
+func main() {
+	f := new(a.Future)
+	f.Result()
+}
diff --git a/test/fixedbugs/issue5910.go b/test/fixedbugs/issue5910.go
new file mode 100644
index 0000000000..54e74bac8d
--- /dev/null
+++ b/test/fixedbugs/issue5910.go
@@ -0,0 +1,10 @@
+// compiledir
+
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Issue 5910: parsing of unnamed struct types
+// in inlined bodies was broken.
+
+package ignored
