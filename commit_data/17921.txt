commit f7aaa553daf41f006bbc2c96d062e661be0c3501
Author: Russ Cox <rsc@golang.org>
Date:   Sun Dec 8 22:49:56 2013 -0500

    cmd/5a, cmd/6a, cmd/8a: use liblink
    
    Preparation for golang.org/s/go13linker work.
    
    This CL does not build by itself. It depends on 35740044
    and 35790044 and will be submitted at the same time.
    
    R=iant
    CC=golang-dev
    https://golang.org/cl/35830043
---
 src/cmd/5a/a.h     |   44 +-
 src/cmd/5a/a.y     |   26 +-
 src/cmd/5a/lex.c   |  294 ++---------
 src/cmd/5a/y.tab.c | 1310 +++++++++++++++++++---------------------------
 src/cmd/5a/y.tab.h |   48 +-
 src/cmd/6a/a.h     |   51 +-
 src/cmd/6a/a.y     |   28 +-
 src/cmd/6a/lex.c   |  302 ++---------
 src/cmd/6a/y.tab.c | 1457 +++++++++++++++++++++-------------------------------
 src/cmd/6a/y.tab.h |   50 +-
 src/cmd/8a/a.h     |   52 +-
 src/cmd/8a/a.y     |   26 +-
 src/cmd/8a/lex.c   |  299 ++---------
 src/cmd/8a/y.tab.c | 1446 +++++++++++++++++++++------------------------------
 src/cmd/8a/y.tab.h |   50 +-
 src/cmd/cc/lexbody |   74 +--
 16 files changed, 1941 insertions(+), 3616 deletions(-)

diff --git a/src/cmd/5a/a.h b/src/cmd/5a/a.h
index 8b39d610f6..0f2348a197 100644
--- a/src/cmd/5a/a.h
+++ b/src/cmd/5a/a.h
@@ -29,6 +29,7 @@
 // THE SOFTWARE.
 
 #include <bio.h>
+#include <link.h>
 #include "../5l/5.out.h"
 
 #ifndef	EXTERN
@@ -43,9 +44,7 @@
 #define	ungetc	ccungetc
 
 typedef	struct	Sym	Sym;
-typedef	struct	Gen	Gen;
 typedef	struct	Io	Io;
-typedef	struct	Hist	Hist;
 
 #define	MAXALIGN	7
 #define	FPCHIP		1
@@ -88,33 +87,6 @@ struct	Io
 };
 #define	I	((Io*)0)
 
-EXTERN	struct
-{
-	Sym*	sym;
-	short	type;
-} h[NSYM];
-
-struct	Gen
-{
-	Sym*	sym;
-	int32	offset;
-	int32	offset2;
-	short	type;
-	short	reg;
-	short	name;
-	double	dval;
-	char	sval[8];
-};
-
-struct	Hist
-{
-	Hist*	link;
-	char*	name;
-	int32	line;
-	int32	offset;
-};
-#define	H	((Hist*)0)
-
 enum
 {
 	CLAST,
@@ -129,9 +101,7 @@ EXTERN	char	debug[256];
 EXTERN	Sym*	hash[NHASH];
 EXTERN	char**	Dlist;
 EXTERN	int	nDlist;
-EXTERN	Hist*	ehist;
 EXTERN	int	newflag;
-EXTERN	Hist*	hist;
 EXTERN	char*	hunk;
 EXTERN	char**	include;
 EXTERN	Io*	iofree;
@@ -142,10 +112,9 @@ EXTERN	int	nerrors;
 EXTERN	int32	nhunk;
 EXTERN	int	ninclude;
 EXTERN	int32	nsymb;
-EXTERN	Gen	nullgen;
+EXTERN	Addr	nullgen;
 EXTERN	char*	outfile;
 EXTERN	int	pass;
-EXTERN	char*	pathname;
 EXTERN	int32	pc;
 EXTERN	int	peekc;
 EXTERN	int32	stmtline;
@@ -155,6 +124,7 @@ EXTERN	int	thechar;
 EXTERN	char*	thestring;
 EXTERN	int32	thunk;
 EXTERN	Biobuf	obuf;
+EXTERN	Link*	ctxt;
 
 void*	alloc(int32);
 void*	allocn(void*, int32, int32);
@@ -174,11 +144,8 @@ int	escchar(int);
 void	cinit(void);
 void	pinit(char*);
 void	cclean(void);
-int	isreg(Gen*);
-void	outcode(int, int, Gen*, int, Gen*);
-void	zname(char*, int, int);
-void	zaddr(Gen*, int);
-void	ieeedtod(Ieee*, double);
+int	isreg(Addr*);
+void	outcode(int, int, Addr*, int, Addr*);
 int	filbuf(void);
 Sym*	getsym(void);
 void	domacro(void);
@@ -190,7 +157,6 @@ void	maclin(void);
 void	macprag(void);
 void	macif(int);
 void	macend(void);
-void	outhist(void);
 void	dodefine(char*);
 void	prfile(int32);
 void	linehist(char*, int);
diff --git a/src/cmd/5a/a.y b/src/cmd/5a/a.y
index c506ff9d57..154ce8b3a6 100644
--- a/src/cmd/5a/a.y
+++ b/src/cmd/5a/a.y
@@ -41,7 +41,7 @@
 	int32	lval;
 	double	dval;
 	char	sval[8];
-	Gen	gen;
+	LAddr	addr;
 }
 %left	'|'
 %left	'^'
@@ -62,8 +62,8 @@
 %token	<sym>	LNAME LLAB LVAR
 %type	<lval>	con expr oexpr pointer offset sreg spreg creg
 %type	<lval>	rcon cond reglist
-%type	<gen>	gen rel reg regreg freg shift fcon frcon
-%type	<gen>	imm ximm name oreg ireg nireg ioreg imsr
+%type	<addr>	gen rel reg regreg freg shift fcon frcon
+%type	<addr>	imm ximm name oreg ireg nireg ioreg imsr
 %%
 prog:
 |	prog
@@ -175,7 +175,7 @@ inst:
  */
 |	LTYPE8 cond ioreg ',' '[' reglist ']'
 	{
-		Gen g;
+		LAddr g;
 
 		g = nullgen;
 		g.type = D_CONST;
@@ -184,7 +184,7 @@ inst:
 	}
 |	LTYPE8 cond '[' reglist ']' ',' ioreg
 	{
-		Gen g;
+		LAddr g;
 
 		g = nullgen;
 		g.type = D_CONST;
@@ -279,7 +279,7 @@ inst:
  */
 |	LTYPEJ cond con ',' expr ',' spreg ',' creg ',' creg oexpr
 	{
-		Gen g;
+		LAddr g;
 
 		g = nullgen;
 		g.type = D_CONST;
@@ -377,14 +377,12 @@ rel:
 		if(pass == 2)
 			yyerror("undefined label: %s", $1->name);
 		$$.type = D_BRANCH;
-		$$.sym = $1;
 		$$.offset = $2;
 	}
 |	LLAB offset
 	{
 		$$ = nullgen;
 		$$.type = D_BRANCH;
-		$$.sym = $1;
 		$$.offset = $1->value + $2;
 	}
 
@@ -408,7 +406,7 @@ ximm:	'$' con
 	{
 		$$ = nullgen;
 		$$.type = D_SCONST;
-		memcpy($$.sval, $2, sizeof($$.sval));
+		memcpy($$.u.sval, $2, sizeof($$.u.sval));
 	}
 |	fcon
 
@@ -417,13 +415,13 @@ fcon:
 	{
 		$$ = nullgen;
 		$$.type = D_FCONST;
-		$$.dval = $2;
+		$$.u.dval = $2;
 	}
 |	'$' '-' LFCONST
 	{
 		$$ = nullgen;
 		$$.type = D_FCONST;
-		$$.dval = -$3;
+		$$.u.dval = -$3;
 	}
 
 reglist:
@@ -635,7 +633,7 @@ name:
 		$$ = nullgen;
 		$$.type = D_OREG;
 		$$.name = $3;
-		$$.sym = S;
+		$$.sym = nil;
 		$$.offset = $1;
 	}
 |	LNAME offset '(' pointer ')'
@@ -643,7 +641,7 @@ name:
 		$$ = nullgen;
 		$$.type = D_OREG;
 		$$.name = $4;
-		$$.sym = $1;
+		$$.sym = linklookup(ctxt, $1->name, 0);
 		$$.offset = $2;
 	}
 |	LNAME '<' '>' offset '(' LSB ')'
@@ -651,7 +649,7 @@ name:
 		$$ = nullgen;
 		$$.type = D_OREG;
 		$$.name = D_STATIC;
-		$$.sym = $1;
+		$$.sym = linklookup(ctxt, $1->name, 1);
 		$$.offset = $4;
 	}
 
diff --git a/src/cmd/5a/lex.c b/src/cmd/5a/lex.c
index c1b54e50b0..b5abb3cdbb 100644
--- a/src/cmd/5a/lex.c
+++ b/src/cmd/5a/lex.c
@@ -59,6 +59,8 @@ main(int argc, char *argv[])
 
 	thechar = '5';
 	thestring = "arm";
+	ctxt = linknew(&linkarm);
+	ctxt->diag = yyerror;
 
 	ensuresymb(NSYMB);
 	memset(debug, 0, sizeof(debug));
@@ -90,10 +92,15 @@ main(int argc, char *argv[])
 		p = ARGF();
 		setinclude(p);
 		break;
+
 	case 't':
 		thechar = 't';
 		thestring = "thumb";
 		break;
+
+	case 'S':
+		ctxt->debugasm++;
+		break;
 	} ARGEND
 	if(*argv == 0) {
 		print("usage: %ca [-options] file.s\n", thechar);
@@ -143,30 +150,23 @@ assemble(char *file)
 		errorexit();
 	}
 	Binit(&obuf, of, OWRITE);
-
-	pass = 1;
-	pinit(file);
-
 	Bprint(&obuf, "go object %s %s %s\n", getgoos(), thestring, getgoversion());
+	Bprint(&obuf, "\n!\n");
 
-	for(i=0; i<nDlist; i++)
-		dodefine(Dlist[i]);
-	yyparse();
-	if(nerrors) {
+	for(pass = 1; pass <= 2; pass++) {
+		pinit(file);
+		for(i=0; i<nDlist; i++)
+			dodefine(Dlist[i]);
+		yyparse();
 		cclean();
-		return nerrors;
+		if(nerrors)
+			return nerrors;
 	}
 
-	Bprint(&obuf, "\n!\n");
-
-	pass = 2;
-	outhist();
-	pinit(file);
-	for(i=0; i<nDlist; i++)
-		dodefine(Dlist[i]);
-	yyparse();
-	cclean();
-	return nerrors;
+	linkouthist(ctxt, &obuf);
+	linkwritefuncs(ctxt, &obuf);
+	Bflush(&obuf);
+	return 0;
 }
 
 struct
@@ -426,15 +426,9 @@ cinit(void)
 	Sym *s;
 	int i;
 
-	nullgen.sym = S;
-	nullgen.offset = 0;
 	nullgen.type = D_NONE;
 	nullgen.name = D_NONE;
 	nullgen.reg = NREG;
-	if(FPCHIP)
-		nullgen.dval = 0;
-	for(i=0; i<sizeof(nullgen.sval); i++)
-		nullgen.sval[i] = 0;
 
 	nerrors = 0;
 	iostack = I;
@@ -448,13 +442,6 @@ cinit(void)
 		s->type = itab[i].type;
 		s->value = itab[i].value;
 	}
-
-	pathname = allocn(pathname, 0, 100);
-	if(getwd(pathname, 99) == 0) {
-		pathname = allocn(pathname, 100, 900);
-		if(getwd(pathname, 999) == 0)
-			strcpy(pathname, "/???");
-	}
 }
 
 void
@@ -466,7 +453,7 @@ syminit(Sym *s)
 }
 
 int
-isreg(Gen *g)
+isreg(Addr *g)
 {
 
 	USED(g);
@@ -476,81 +463,7 @@ isreg(Gen *g)
 void
 cclean(void)
 {
-
 	outcode(AEND, Always, &nullgen, NREG, &nullgen);
-	Bflush(&obuf);
-}
-
-void
-zname(char *n, int t, int s)
-{
-
-	BPUTC(&obuf, ANAME);
-	BPUTC(&obuf, t);	/* type */
-	BPUTC(&obuf, s);	/* sym */
-	while(*n) {
-		BPUTC(&obuf, *n);
-		n++;
-	}
-	BPUTC(&obuf, 0);
-}
-
-void
-zaddr(Gen *a, int s)
-{
-	int32 l;
-	int i;
-	char *n;
-	Ieee e;
-
-	BPUTC(&obuf, a->type);
-	BPUTC(&obuf, a->reg);
-	BPUTC(&obuf, s);
-	BPUTC(&obuf, a->name);
-	BPUTC(&obuf, 0);
-	switch(a->type) {
-	default:
-		print("unknown type %d\n", a->type);
-		exits("arg");
-
-	case D_NONE:
-	case D_REG:
-	case D_FREG:
-	case D_PSR:
-	case D_FPCR:
-		break;
-
-	case D_REGREG:
-	case D_REGREG2:
-		BPUTC(&obuf, a->offset);
-		break;
-
-	case D_CONST2:
-		l = a->offset2;
-		BPUTLE4(&obuf, l);
-		// fall through
-	case D_OREG:
-	case D_CONST:
-	case D_BRANCH:
-	case D_SHIFT:
-		l = a->offset;
-		BPUTLE4(&obuf, l);
-		break;
-
-	case D_SCONST:
-		n = a->sval;
-		for(i=0; i<NSNAME; i++) {
-			BPUTC(&obuf, *n);
-			n++;
-		}
-		break;
-
-	case D_FCONST:
-		ieeedtod(&e, a->dval);
-		BPUTLE4(&obuf, e.l);
-		BPUTLE4(&obuf, e.h);
-		break;
-	}
 }
 
 static int bcode[] =
@@ -573,11 +486,13 @@ static int bcode[] =
 	ANOP,
 };
 
+static Prog *lastpc;
+
 void
-outcode(int a, int scond, Gen *g1, int reg, Gen *g2)
+outcode(int a, int scond, Addr *g1, int reg, Addr *g2)
 {
-	int sf, st, t;
-	Sym *s;
+	Prog *p;
+	Plist *pl;
 
 	/* hack to make B.NE etc. work: turn it into the corresponding conditional */
 	if(a == AB){
@@ -587,154 +502,27 @@ outcode(int a, int scond, Gen *g1, int reg, Gen *g2)
 
 	if(pass == 1)
 		goto out;
-jackpot:
-	sf = 0;
-	s = g1->sym;
-	while(s != S) {
-		sf = s->sym;
-		if(sf < 0 || sf >= NSYM)
-			sf = 0;
-		t = g1->name;
-		if(h[sf].type == t)
-		if(h[sf].sym == s)
-			break;
-		zname(s->name, t, sym);
-		s->sym = sym;
-		h[sym].sym = s;
-		h[sym].type = t;
-		sf = sym;
-		sym++;
-		if(sym >= NSYM)
-			sym = 1;
-		break;
-	}
-	st = 0;
-	s = g2->sym;
-	while(s != S) {
-		st = s->sym;
-		if(st < 0 || st >= NSYM)
-			st = 0;
-		t = g2->name;
-		if(h[st].type == t)
-		if(h[st].sym == s)
-			break;
-		zname(s->name, t, sym);
-		s->sym = sym;
-		h[sym].sym = s;
-		h[sym].type = t;
-		st = sym;
-		sym++;
-		if(sym >= NSYM)
-			sym = 1;
-		if(st == sf)
-			goto jackpot;
-		break;
-	}
-	BPUTC(&obuf, a);
-	BPUTC(&obuf, scond);
-	BPUTC(&obuf, reg);
-	BPUTLE4(&obuf, stmtline);
-	zaddr(g1, sf);
-	zaddr(g2, st);
+	
+	p = malloc(sizeof *p);
+	memset(p, 0, sizeof *p);
+	p->as = a;
+	p->lineno = stmtline;
+	p->scond = scond;
+	p->from = *g1;
+	p->reg = reg;
+	p->to = *g2;
+
+	if(lastpc == nil) {
+		pl = linknewplist(ctxt);
+		pl->firstpc = p;
+	} else
+		lastpc->link = p;
+	lastpc = p;	
 
 out:
 	if(a != AGLOBL && a != ADATA)
 		pc++;
 }
 
-void
-outhist(void)
-{
-	Gen g;
-	Hist *h;
-	char *p, *q, *op, c;
-	int n;
- 	char *tofree;
- 	static int first = 1;
- 	static char *goroot, *goroot_final;
- 
- 	if(first) {
- 		// Decide whether we need to rewrite paths from $GOROOT to $GOROOT_FINAL.
- 		first = 0;
- 		goroot = getenv("GOROOT");
- 		goroot_final = getenv("GOROOT_FINAL");
- 		if(goroot == nil)
- 			goroot = "";
- 		if(goroot_final == nil)
- 			goroot_final = goroot;
- 		if(strcmp(goroot, goroot_final) == 0) {
- 			goroot = nil;
- 			goroot_final = nil;
- 		}
- 	}
- 
- 	tofree = nil;
-	g = nullgen;
-	c = '/';
-	for(h = hist; h != H; h = h->link) {
-		p = h->name;
- 		if(p != nil && goroot != nil) {
- 			n = strlen(goroot);
- 			if(strncmp(p, goroot, strlen(goroot)) == 0 && p[n] == '/') {
- 				tofree = smprint("%s%s", goroot_final, p+n);
- 				p = tofree;
- 			}
- 		}
-		op = 0;
-		if(systemtype(Windows) && p && p[1] == ':'){
-			c = p[2];
-		} else if(p && p[0] != c && h->offset == 0 && pathname){
-			if(systemtype(Windows) && pathname[1] == ':') {
-				op = p;
-				p = pathname;
-				c = p[2];
-			} else if(pathname[0] == c){
-				op = p;
-				p = pathname;
-			}
-		}
-		while(p) {
-			q = strchr(p, c);
-			if(q) {
-				n = q-p;
-				if(n == 0){
-					n = 1;	/* leading "/" */
-					*p = '/';	/* don't emit "\" on windows */
-				}
-				q++;
-			} else {
-				n = strlen(p);
-				q = 0;
-			}
-			if(n) {
-				BPUTC(&obuf, ANAME);
-				BPUTC(&obuf, D_FILE);	/* type */
-				BPUTC(&obuf, 1);	/* sym */
-				BPUTC(&obuf, '<');
-				Bwrite(&obuf, p, n);
-				BPUTC(&obuf, 0);
-			}
-			p = q;
-			if(p == 0 && op) {
-				p = op;
-				op = 0;
-			}
-		}
-		g.offset = h->offset;
-
-		BPUTC(&obuf, AHISTORY);
-		BPUTC(&obuf, Always);
-		BPUTC(&obuf, 0);
-		BPUTLE4(&obuf, h->line);
-		zaddr(&nullgen, 0);
-		zaddr(&g, 0);
-
-		if(tofree) {
-			free(tofree);
-			tofree = nil;
-		}
-	}
-}
-
 #include "../cc/lexbody"
 #include "../cc/macbody"
diff --git a/src/cmd/5a/y.tab.c b/src/cmd/5a/y.tab.c
index dd102a09a1..6b6d5e7a38 100644
--- a/src/cmd/5a/y.tab.c
+++ b/src/cmd/5a/y.tab.c
@@ -1,21 +1,24 @@
-/* A Bison parser, made by GNU Bison 2.5.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Bison implementation for Yacc-like parsers in C
-   
-      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
-   
-   This program is free software: you can redistribute it and/or modify
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-   
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -26,7 +29,7 @@
    special exception, which will cause the skeleton and the resulting
    Bison output files to be licensed under the GNU General Public
    License without this special exception.
-   
+
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
@@ -44,7 +47,7 @@
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "2.5"
+#define YYBISON_VERSION "2.3"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -52,51 +55,11 @@
 /* Pure parsers.  */
 #define YYPURE 0
 
-/* Push parsers.  */
-#define YYPUSH 0
-
-/* Pull parsers.  */
-#define YYPULL 1
-
 /* Using locations.  */
 #define YYLSP_NEEDED 0
 
 
 
-/* Copy the first part of user declarations.  */
-
-/* Line 268 of yacc.c  */
-#line 31 "a.y"
-
-#include <u.h>
-#include <stdio.h>	/* if we don't, bison will, and a.h re-#defines getc */
-#include <libc.h>
-#include "a.h"
-#include "../../pkg/runtime/funcdata.h"
-
-
-/* Line 268 of yacc.c  */
-#line 80 "y.tab.c"
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-/* Enabling the token table.  */
-#ifndef YYTOKEN_TABLE
-# define YYTOKEN_TABLE 0
-#endif
-
-
 /* Tokens.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
@@ -206,35 +169,59 @@
 
 
 
+/* Copy the first part of user declarations.  */
+#line 31 "a.y"
+
+#include <u.h>
+#include <stdio.h>	/* if we don't, bison will, and a.h re-#defines getc */
+#include <libc.h>
+#include "a.h"
+#include "../../pkg/runtime/funcdata.h"
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-{
-
-/* Line 293 of yacc.c  */
 #line 39 "a.y"
-
+{
 	Sym	*sym;
 	int32	lval;
 	double	dval;
 	char	sval[8];
-	Gen	gen;
-
-
-
-/* Line 293 of yacc.c  */
-#line 226 "y.tab.c"
-} YYSTYPE;
-# define YYSTYPE_IS_TRIVIAL 1
+	Addr	addr;
+}
+/* Line 193 of yacc.c.  */
+#line 212 "y.tab.c"
+	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
 #endif
 
 
+
 /* Copy the second part of user declarations.  */
 
 
-/* Line 343 of yacc.c  */
-#line 238 "y.tab.c"
+/* Line 216 of yacc.c.  */
+#line 225 "y.tab.c"
 
 #ifdef short
 # undef short
@@ -309,14 +296,14 @@ typedef short int yytype_int16;
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 static int
-YYID (int yyi)
+YYID (int i)
 #else
 static int
-YYID (yyi)
-    int yyi;
+YYID (i)
+    int i;
 #endif
 {
-  return yyi;
+  return i;
 }
 #endif
 
@@ -337,11 +324,11 @@ YYID (yyi)
 #    define alloca _alloca
 #   else
 #    define YYSTACK_ALLOC alloca
-#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 #     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#     ifndef EXIT_SUCCESS
-#      define EXIT_SUCCESS 0
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
 #     endif
 #    endif
 #   endif
@@ -364,24 +351,24 @@ YYID (yyi)
 #  ifndef YYSTACK_ALLOC_MAXIMUM
 #   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
 #  endif
-#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+#  if (defined __cplusplus && ! defined _STDLIB_H \
        && ! ((defined YYMALLOC || defined malloc) \
 	     && (defined YYFREE || defined free)))
 #   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   ifndef EXIT_SUCCESS
-#    define EXIT_SUCCESS 0
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
 #   endif
 #  endif
 #  ifndef YYMALLOC
 #   define YYMALLOC malloc
-#   if ! defined malloc && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
 #  ifndef YYFREE
 #   define YYFREE free
-#   if ! defined free && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 void free (void *); /* INFRINGES ON USER NAME SPACE */
 #   endif
@@ -397,9 +384,9 @@ void free (void *); /* INFRINGES ON USER NAME SPACE */
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  yytype_int16 yyss_alloc;
-  YYSTYPE yyvs_alloc;
-};
+  yytype_int16 yyss;
+  YYSTYPE yyvs;
+  };
 
 /* The size of the maximum gap between one aligned stack and the next.  */
 # define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
@@ -410,27 +397,6 @@ union yyalloc
      ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
-# define YYCOPY_NEEDED 1
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
-	Stack = &yyptr->Stack_alloc;					\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (YYID (0))
-
-#endif
-
-#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
@@ -448,7 +414,24 @@ union yyalloc
       while (YYID (0))
 #  endif
 # endif
-#endif /* !YYCOPY_NEEDED */
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
 
 /* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  2
@@ -594,15 +577,15 @@ static const yytype_uint16 yyrline[] =
      141,   148,   155,   162,   169,   176,   185,   197,   201,   205,
      212,   219,   225,   231,   240,   247,   254,   261,   265,   269,
      273,   280,   302,   310,   319,   326,   335,   346,   352,   355,
-     359,   364,   365,   368,   374,   383,   391,   397,   402,   407,
-     413,   416,   422,   430,   434,   443,   449,   450,   451,   452,
-     457,   463,   469,   475,   476,   479,   480,   488,   497,   498,
-     507,   508,   514,   517,   518,   519,   521,   529,   537,   546,
-     552,   558,   564,   572,   578,   586,   587,   591,   599,   600,
-     606,   607,   615,   616,   619,   625,   633,   641,   649,   659,
-     662,   666,   672,   673,   674,   677,   678,   682,   686,   690,
-     694,   700,   703,   709,   710,   714,   718,   722,   726,   730,
-     734,   738,   742,   746
+     359,   364,   365,   368,   374,   382,   389,   395,   400,   405,
+     411,   414,   420,   428,   432,   441,   447,   448,   449,   450,
+     455,   461,   467,   473,   474,   477,   478,   486,   495,   496,
+     505,   506,   512,   515,   516,   517,   519,   527,   535,   544,
+     550,   556,   562,   570,   576,   584,   585,   589,   597,   598,
+     604,   605,   613,   614,   617,   623,   631,   639,   647,   657,
+     660,   664,   670,   671,   672,   675,   676,   680,   684,   688,
+     692,   698,   701,   707,   708,   712,   716,   720,   724,   728,
+     732,   736,   740,   744
 };
 #endif
 
@@ -619,11 +602,11 @@ static const char *const yytname[] =
   "LSP", "LSB", "LFP", "LPC", "LTYPEX", "LTYPEPC", "LTYPEF", "LR", "LREG",
   "LF", "LFREG", "LC", "LCREG", "LPSR", "LFCR", "LCOND", "LS", "LAT",
   "LFCONST", "LSCONST", "LNAME", "LLAB", "LVAR", "':'", "'='", "';'",
-  "','", "'['", "']'", "'('", "')'", "'$'", "'~'", "$accept", "prog",
-  "$@1", "line", "$@2", "$@3", "inst", "cond", "comma", "rel", "ximm",
-  "fcon", "reglist", "gen", "nireg", "ireg", "ioreg", "oreg", "imsr",
-  "imm", "reg", "regreg", "shift", "rcon", "sreg", "spreg", "creg",
-  "frcon", "freg", "name", "offset", "pointer", "con", "oexpr", "expr", 0
+  "','", "'['", "']'", "'('", "')'", "'$'", "'~'", "$accept", "prog", "@1",
+  "line", "@2", "@3", "inst", "cond", "comma", "rel", "ximm", "fcon",
+  "reglist", "gen", "nireg", "ireg", "ioreg", "oreg", "imsr", "imm", "reg",
+  "regreg", "shift", "rcon", "sreg", "spreg", "creg", "frcon", "freg",
+  "name", "offset", "pointer", "con", "oexpr", "expr", 0
 };
 #endif
 
@@ -681,8 +664,8 @@ static const yytype_uint8 yyr2[] =
        4,     3,     3,     3
 };
 
-/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
-   Performed when YYTABLE doesn't specify something else to do.  Zero
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
 static const yytype_uint8 yydefact[] =
 {
@@ -783,7 +766,8 @@ static const yytype_int16 yypgoto[] =
 
 /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
    positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If YYTABLE_NINF, syntax error.  */
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
 #define YYTABLE_NINF -64
 static const yytype_int16 yytable[] =
 {
@@ -850,12 +834,6 @@ static const yytype_int16 yytable[] =
      202,   203,   204,   198,   199,   200,   201,   202,   203,   204
 };
 
-#define yypact_value_is_default(yystate) \
-  ((yystate) == (-128))
-
-#define yytable_value_is_error(yytable_value) \
-  YYID (0)
-
 static const yytype_int16 yycheck[] =
 {
       28,    29,    45,    60,     0,   132,    27,    15,    16,    37,
@@ -973,18 +951,9 @@ static const yytype_uint8 yystos[] =
 
 /* Like YYERROR except do call yyerror.  This remains here temporarily
    to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  However,
-   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
-   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
-   discussed.  */
+   Once GCC version 2 has supplanted version 1, this can go.  */
 
 #define YYFAIL		goto yyerrlab
-#if defined YYFAIL
-  /* This is here to suppress warnings from the GCC cpp's
-     -Wunused-macros.  Normally we don't worry about that warning, but
-     some users do, and we want to make it easy for users to remove
-     YYFAIL uses, which will produce warnings from Bison 2.5.  */
-#endif
 
 #define YYRECOVERING()  (!!yyerrstatus)
 
@@ -994,6 +963,7 @@ do								\
     {								\
       yychar = (Token);						\
       yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
       YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
@@ -1035,10 +1005,19 @@ while (YYID (0))
 #endif
 
 
-/* This macro is provided for backward compatibility. */
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
 
 #ifndef YY_LOCATION_PRINT
-# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
 #endif
 
 
@@ -1142,20 +1121,17 @@ yy_symbol_print (yyoutput, yytype, yyvaluep)
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 static void
-yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
 #else
 static void
-yy_stack_print (yybottom, yytop)
-    yytype_int16 *yybottom;
-    yytype_int16 *yytop;
+yy_stack_print (bottom, top)
+    yytype_int16 *bottom;
+    yytype_int16 *top;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (; yybottom <= yytop; yybottom++)
-    {
-      int yybot = *yybottom;
-      YYFPRINTF (stderr, " %d", yybot);
-    }
+  for (; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
   YYFPRINTF (stderr, "\n");
 }
 
@@ -1189,11 +1165,11 @@ yy_reduce_print (yyvsp, yyrule)
   /* The symbols being reduced.  */
   for (yyi = 0; yyi < yynrhs; yyi++)
     {
-      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      fprintf (stderr, "   $%d = ", yyi + 1);
       yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
 		       &(yyvsp[(yyi + 1) - (yynrhs)])
 		       		       );
-      YYFPRINTF (stderr, "\n");
+      fprintf (stderr, "\n");
     }
 }
 
@@ -1230,6 +1206,7 @@ int yydebug;
 # define YYMAXDEPTH 10000
 #endif
 
+
 
 #if YYERROR_VERBOSE
 
@@ -1332,142 +1309,115 @@ yytnamerr (char *yyres, const char *yystr)
 }
 # endif
 
-/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
-   about the unexpected token YYTOKEN for the state stack whose top is
-   YYSSP.
-
-   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
-   not large enough to hold the message.  In that case, also set
-   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
-   required number of bytes is too large to store.  */
-static int
-yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
-                yytype_int16 *yyssp, int yytoken)
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
 {
-  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytoken]);
-  YYSIZE_T yysize = yysize0;
-  YYSIZE_T yysize1;
-  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-  /* Internationalized format string. */
-  const char *yyformat = 0;
-  /* Arguments of yyformat. */
-  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-  /* Number of reported tokens (one for the "unexpected", one per
-     "expected"). */
-  int yycount = 0;
-
-  /* There are many possibilities here to consider:
-     - Assume YYFAIL is not used.  It's too flawed to consider.  See
-       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
-       for details.  YYERROR is fine as it does not invoke this
-       function.
-     - If this state is a consistent state with a default action, then
-       the only way this function was invoked is if the default action
-       is an error action.  In that case, don't check for expected
-       tokens because there are none.
-     - The only way there can be no lookahead present (in yychar) is if
-       this state is a consistent state with a default action.  Thus,
-       detecting the absence of a lookahead is sufficient to determine
-       that there is no unexpected or expected token to report.  In that
-       case, just report a simple "syntax error".
-     - Don't assume there isn't a lookahead just because this state is a
-       consistent state with a default action.  There might have been a
-       previous inconsistent state, consistent state with a non-default
-       action, or user semantic action that manipulated yychar.
-     - Of course, the expected token list depends on states to have
-       correct lookahead information, and it depends on the parser not
-       to perform extra reductions after fetching a lookahead from the
-       scanner and before detecting a syntax error.  Thus, state merging
-       (from LALR or IELR) and default reductions corrupt the expected
-       token list.  However, the list is correct for canonical LR with
-       one exception: it will still contain any token that will not be
-       accepted due to an error action in a later state.
-  */
-  if (yytoken != YYEMPTY)
-    {
-      int yyn = yypact[*yyssp];
-      yyarg[yycount++] = yytname[yytoken];
-      if (!yypact_value_is_default (yyn))
-        {
-          /* Start YYX at -YYN if negative to avoid negative indexes in
-             YYCHECK.  In other words, skip the first -YYN actions for
-             this state because they are default actions.  */
-          int yyxbegin = yyn < 0 ? -yyn : 0;
-          /* Stay within bounds of both yycheck and yytname.  */
-          int yychecklim = YYLAST - yyn + 1;
-          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-          int yyx;
-
-          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
-                && !yytable_value_is_error (yytable[yyx + yyn]))
-              {
-                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-                  {
-                    yycount = 1;
-                    yysize = yysize0;
-                    break;
-                  }
-                yyarg[yycount++] = yytname[yyx];
-                yysize1 = yysize + yytnamerr (0, yytname[yyx]);
-                if (! (yysize <= yysize1
-                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-                  return 2;
-                yysize = yysize1;
-              }
-        }
-    }
+  int yyn = yypact[yystate];
 
-  switch (yycount)
-    {
-# define YYCASE_(N, S)                      \
-      case N:                               \
-        yyformat = S;                       \
-      break
-      YYCASE_(0, YY_("syntax error"));
-      YYCASE_(1, YY_("syntax error, unexpected %s"));
-      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
-      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
-      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
-      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
-# undef YYCASE_
-    }
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
 
-  yysize1 = yysize + yystrlen (yyformat);
-  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-    return 2;
-  yysize = yysize1;
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
 
-  if (*yymsg_alloc < yysize)
-    {
-      *yymsg_alloc = 2 * yysize;
-      if (! (yysize <= *yymsg_alloc
-             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
-        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
-      return 1;
-    }
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
 
-  /* Avoid sprintf, as that infringes on the user's name space.
-     Don't have undefined behavior even if the translation
-     produced a string with the wrong number of "%s"s.  */
-  {
-    char *yyp = *yymsg;
-    int yyi = 0;
-    while ((*yyp = *yyformat) != '\0')
-      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
-        {
-          yyp += yytnamerr (yyp, yyarg[yyi++]);
-          yyformat += 2;
-        }
-      else
-        {
-          yyp++;
-          yyformat++;
-        }
-  }
-  return 0;
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
 }
 #endif /* YYERROR_VERBOSE */
+
 
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
@@ -1499,9 +1449,10 @@ yydestruct (yymsg, yytype, yyvaluep)
 	break;
     }
 }
-
+
 
 /* Prevent warnings from -Wmissing-prototypes.  */
+
 #ifdef YYPARSE_PARAM
 #if defined __STDC__ || defined __cplusplus
 int yyparse (void *YYPARSE_PARAM);
@@ -1517,16 +1468,18 @@ int yyparse ();
 #endif /* ! YYPARSE_PARAM */
 
 
-/* The lookahead symbol.  */
+
+/* The look-ahead symbol.  */
 int yychar;
 
-/* The semantic value of the lookahead symbol.  */
+/* The semantic value of the look-ahead symbol.  */
 YYSTYPE yylval;
 
 /* Number of syntax errors so far.  */
 int yynerrs;
 
 
+
 /*----------.
 | yyparse.  |
 `----------*/
@@ -1553,37 +1506,14 @@ yyparse ()
 #endif
 #endif
 {
-    int yystate;
-    /* Number of tokens to shift before error messages enabled.  */
-    int yyerrstatus;
-
-    /* The stacks and their tools:
-       `yyss': related to states.
-       `yyvs': related to semantic values.
-
-       Refer to the stacks thru separate pointers, to allow yyoverflow
-       to reallocate them elsewhere.  */
-
-    /* The state stack.  */
-    yytype_int16 yyssa[YYINITDEPTH];
-    yytype_int16 *yyss;
-    yytype_int16 *yyssp;
-
-    /* The semantic value stack.  */
-    YYSTYPE yyvsa[YYINITDEPTH];
-    YYSTYPE *yyvs;
-    YYSTYPE *yyvsp;
-
-    YYSIZE_T yystacksize;
-
+  
+  int yystate;
   int yyn;
   int yyresult;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken;
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
 #if YYERROR_VERBOSE
   /* Buffer for error messages, and its allocated size.  */
   char yymsgbuf[128];
@@ -1591,28 +1521,51 @@ yyparse ()
   YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
 #endif
 
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  YYSTYPE *yyvsp;
+
+
+
 #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
   /* The number of symbols on the RHS of the reduced rule.
      Keep to zero when no symbol should be popped.  */
   int yylen = 0;
 
-  yytoken = 0;
-  yyss = yyssa;
-  yyvs = yyvsa;
-  yystacksize = YYINITDEPTH;
-
   YYDPRINTF ((stderr, "Starting parse\n"));
 
   yystate = 0;
   yyerrstatus = 0;
   yynerrs = 0;
-  yychar = YYEMPTY; /* Cause a token to be read.  */
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
 
   /* Initialize stack pointers.
      Waste one element of value and location stack
      so that they stay on the same level as the state stack.
      The wasted elements are never initialized.  */
+
   yyssp = yyss;
   yyvsp = yyvs;
 
@@ -1642,6 +1595,7 @@ yyparse ()
 	YYSTYPE *yyvs1 = yyvs;
 	yytype_int16 *yyss1 = yyss;
 
+
 	/* Each stack pointer address is followed by the size of the
 	   data in use in that stack, in bytes.  This used to be a
 	   conditional around just the two extra args, but that might
@@ -1649,6 +1603,7 @@ yyparse ()
 	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
+
 		    &yystacksize);
 
 	yyss = yyss1;
@@ -1671,8 +1626,9 @@ yyparse ()
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
 	  goto yyexhaustedlab;
-	YYSTACK_RELOCATE (yyss_alloc, yyss);
-	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
 #  undef YYSTACK_RELOCATE
 	if (yyss1 != yyssa)
 	  YYSTACK_FREE (yyss1);
@@ -1683,6 +1639,7 @@ yyparse ()
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
 
+
       YYDPRINTF ((stderr, "Stack size increased to %lu\n",
 		  (unsigned long int) yystacksize));
 
@@ -1692,9 +1649,6 @@ yyparse ()
 
   YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
-  if (yystate == YYFINAL)
-    YYACCEPT;
-
   goto yybackup;
 
 /*-----------.
@@ -1703,16 +1657,16 @@ yyparse ()
 yybackup:
 
   /* Do appropriate processing given the current state.  Read a
-     lookahead token if we need one and don't already have one.  */
+     look-ahead token if we need one and don't already have one.  */
 
-  /* First try to decide what to do without reference to lookahead token.  */
+  /* First try to decide what to do without reference to look-ahead token.  */
   yyn = yypact[yystate];
-  if (yypact_value_is_default (yyn))
+  if (yyn == YYPACT_NINF)
     goto yydefault;
 
-  /* Not known => get a lookahead token if don't already have one.  */
+  /* Not known => get a look-ahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
@@ -1738,22 +1692,26 @@ yybackup:
   yyn = yytable[yyn];
   if (yyn <= 0)
     {
-      if (yytable_value_is_error (yyn))
-        goto yyerrlab;
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
 
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
-  /* Shift the lookahead token.  */
+  /* Shift the look-ahead token.  */
   YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
 
-  /* Discard the shifted token.  */
-  yychar = YYEMPTY;
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
 
   yystate = yyn;
   *++yyvsp = yylval;
@@ -1793,8 +1751,6 @@ yyreduce:
   switch (yyn)
     {
         case 3:
-
-/* Line 1806 of yacc.c  */
 #line 70 "a.y"
     {
 		stmtline = lineno;
@@ -1802,8 +1758,6 @@ yyreduce:
     break;
 
   case 5:
-
-/* Line 1806 of yacc.c  */
 #line 77 "a.y"
     {
 		if((yyvsp[(1) - (2)].sym)->value != pc)
@@ -1813,8 +1767,6 @@ yyreduce:
     break;
 
   case 7:
-
-/* Line 1806 of yacc.c  */
 #line 84 "a.y"
     {
 		(yyvsp[(1) - (2)].sym)->type = LLAB;
@@ -1823,8 +1775,6 @@ yyreduce:
     break;
 
   case 9:
-
-/* Line 1806 of yacc.c  */
 #line 90 "a.y"
     {
 		(yyvsp[(1) - (4)].sym)->type = LVAR;
@@ -1833,8 +1783,6 @@ yyreduce:
     break;
 
   case 10:
-
-/* Line 1806 of yacc.c  */
 #line 95 "a.y"
     {
 		if((yyvsp[(1) - (4)].sym)->value != (yyvsp[(3) - (4)].lval))
@@ -1844,162 +1792,128 @@ yyreduce:
     break;
 
   case 14:
-
-/* Line 1806 of yacc.c  */
 #line 109 "a.y"
     {
-		outcode((yyvsp[(1) - (7)].lval), (yyvsp[(2) - (7)].lval), &(yyvsp[(3) - (7)].gen), (yyvsp[(5) - (7)].lval), &(yyvsp[(7) - (7)].gen));
+		outcode((yyvsp[(1) - (7)].lval), (yyvsp[(2) - (7)].lval), &(yyvsp[(3) - (7)].addr), (yyvsp[(5) - (7)].lval), &(yyvsp[(7) - (7)].addr));
 	}
     break;
 
   case 15:
-
-/* Line 1806 of yacc.c  */
 #line 113 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), (yyvsp[(2) - (6)].lval), &(yyvsp[(3) - (6)].gen), (yyvsp[(5) - (6)].lval), &nullgen);
+		outcode((yyvsp[(1) - (6)].lval), (yyvsp[(2) - (6)].lval), &(yyvsp[(3) - (6)].addr), (yyvsp[(5) - (6)].lval), &nullgen);
 	}
     break;
 
   case 16:
-
-/* Line 1806 of yacc.c  */
 #line 117 "a.y"
     {
-		outcode((yyvsp[(1) - (5)].lval), (yyvsp[(2) - (5)].lval), &(yyvsp[(3) - (5)].gen), NREG, &(yyvsp[(5) - (5)].gen));
+		outcode((yyvsp[(1) - (5)].lval), (yyvsp[(2) - (5)].lval), &(yyvsp[(3) - (5)].addr), NREG, &(yyvsp[(5) - (5)].addr));
 	}
     break;
 
   case 17:
-
-/* Line 1806 of yacc.c  */
 #line 124 "a.y"
     {
-		outcode((yyvsp[(1) - (5)].lval), (yyvsp[(2) - (5)].lval), &(yyvsp[(3) - (5)].gen), NREG, &(yyvsp[(5) - (5)].gen));
+		outcode((yyvsp[(1) - (5)].lval), (yyvsp[(2) - (5)].lval), &(yyvsp[(3) - (5)].addr), NREG, &(yyvsp[(5) - (5)].addr));
 	}
     break;
 
   case 18:
-
-/* Line 1806 of yacc.c  */
 #line 131 "a.y"
     {
-		outcode((yyvsp[(1) - (5)].lval), (yyvsp[(2) - (5)].lval), &(yyvsp[(3) - (5)].gen), NREG, &(yyvsp[(5) - (5)].gen));
+		outcode((yyvsp[(1) - (5)].lval), (yyvsp[(2) - (5)].lval), &(yyvsp[(3) - (5)].addr), NREG, &(yyvsp[(5) - (5)].addr));
 	}
     break;
 
   case 19:
-
-/* Line 1806 of yacc.c  */
 #line 138 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), (yyvsp[(2) - (4)].lval), &nullgen, NREG, &(yyvsp[(4) - (4)].gen));
+		outcode((yyvsp[(1) - (4)].lval), (yyvsp[(2) - (4)].lval), &nullgen, NREG, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 20:
-
-/* Line 1806 of yacc.c  */
 #line 142 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), (yyvsp[(2) - (4)].lval), &nullgen, NREG, &(yyvsp[(4) - (4)].gen));
+		outcode((yyvsp[(1) - (4)].lval), (yyvsp[(2) - (4)].lval), &nullgen, NREG, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 21:
-
-/* Line 1806 of yacc.c  */
 #line 149 "a.y"
     {
-		outcode((yyvsp[(1) - (3)].lval), Always, &nullgen, NREG, &(yyvsp[(3) - (3)].gen));
+		outcode((yyvsp[(1) - (3)].lval), Always, &nullgen, NREG, &(yyvsp[(3) - (3)].addr));
 	}
     break;
 
   case 22:
-
-/* Line 1806 of yacc.c  */
 #line 156 "a.y"
     {
-		outcode((yyvsp[(1) - (3)].lval), Always, &nullgen, NREG, &(yyvsp[(3) - (3)].gen));
+		outcode((yyvsp[(1) - (3)].lval), Always, &nullgen, NREG, &(yyvsp[(3) - (3)].addr));
 	}
     break;
 
   case 23:
-
-/* Line 1806 of yacc.c  */
 #line 163 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), (yyvsp[(2) - (4)].lval), &nullgen, NREG, &(yyvsp[(4) - (4)].gen));
+		outcode((yyvsp[(1) - (4)].lval), (yyvsp[(2) - (4)].lval), &nullgen, NREG, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 24:
-
-/* Line 1806 of yacc.c  */
 #line 170 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), (yyvsp[(2) - (6)].lval), &(yyvsp[(3) - (6)].gen), (yyvsp[(5) - (6)].lval), &nullgen);
+		outcode((yyvsp[(1) - (6)].lval), (yyvsp[(2) - (6)].lval), &(yyvsp[(3) - (6)].addr), (yyvsp[(5) - (6)].lval), &nullgen);
 	}
     break;
 
   case 25:
-
-/* Line 1806 of yacc.c  */
 #line 177 "a.y"
     {
-		Gen g;
+		Addr g;
 
 		g = nullgen;
 		g.type = D_CONST;
 		g.offset = (yyvsp[(6) - (7)].lval);
-		outcode((yyvsp[(1) - (7)].lval), (yyvsp[(2) - (7)].lval), &(yyvsp[(3) - (7)].gen), NREG, &g);
+		outcode((yyvsp[(1) - (7)].lval), (yyvsp[(2) - (7)].lval), &(yyvsp[(3) - (7)].addr), NREG, &g);
 	}
     break;
 
   case 26:
-
-/* Line 1806 of yacc.c  */
 #line 186 "a.y"
     {
-		Gen g;
+		Addr g;
 
 		g = nullgen;
 		g.type = D_CONST;
 		g.offset = (yyvsp[(4) - (7)].lval);
-		outcode((yyvsp[(1) - (7)].lval), (yyvsp[(2) - (7)].lval), &g, NREG, &(yyvsp[(7) - (7)].gen));
+		outcode((yyvsp[(1) - (7)].lval), (yyvsp[(2) - (7)].lval), &g, NREG, &(yyvsp[(7) - (7)].addr));
 	}
     break;
 
   case 27:
-
-/* Line 1806 of yacc.c  */
 #line 198 "a.y"
     {
-		outcode((yyvsp[(1) - (7)].lval), (yyvsp[(2) - (7)].lval), &(yyvsp[(5) - (7)].gen), (yyvsp[(3) - (7)].gen).reg, &(yyvsp[(7) - (7)].gen));
+		outcode((yyvsp[(1) - (7)].lval), (yyvsp[(2) - (7)].lval), &(yyvsp[(5) - (7)].addr), (yyvsp[(3) - (7)].addr).reg, &(yyvsp[(7) - (7)].addr));
 	}
     break;
 
   case 28:
-
-/* Line 1806 of yacc.c  */
 #line 202 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), (yyvsp[(2) - (6)].lval), &(yyvsp[(5) - (6)].gen), (yyvsp[(3) - (6)].gen).reg, &(yyvsp[(3) - (6)].gen));
+		outcode((yyvsp[(1) - (6)].lval), (yyvsp[(2) - (6)].lval), &(yyvsp[(5) - (6)].addr), (yyvsp[(3) - (6)].addr).reg, &(yyvsp[(3) - (6)].addr));
 	}
     break;
 
   case 29:
-
-/* Line 1806 of yacc.c  */
 #line 206 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), (yyvsp[(2) - (6)].lval), &(yyvsp[(4) - (6)].gen), (yyvsp[(6) - (6)].gen).reg, &(yyvsp[(6) - (6)].gen));
+		outcode((yyvsp[(1) - (6)].lval), (yyvsp[(2) - (6)].lval), &(yyvsp[(4) - (6)].addr), (yyvsp[(6) - (6)].addr).reg, &(yyvsp[(6) - (6)].addr));
 	}
     break;
 
   case 30:
-
-/* Line 1806 of yacc.c  */
 #line 213 "a.y"
     {
 		outcode((yyvsp[(1) - (3)].lval), (yyvsp[(2) - (3)].lval), &nullgen, NREG, &nullgen);
@@ -2007,107 +1921,85 @@ yyreduce:
     break;
 
   case 31:
-
-/* Line 1806 of yacc.c  */
 #line 220 "a.y"
     {
-		(yyvsp[(4) - (4)].gen).type = D_CONST2;
-		(yyvsp[(4) - (4)].gen).offset2 = ArgsSizeUnknown;
-		outcode((yyvsp[(1) - (4)].lval), Always, &(yyvsp[(2) - (4)].gen), 0, &(yyvsp[(4) - (4)].gen));
+		(yyvsp[(4) - (4)].addr).type = D_CONST2;
+		(yyvsp[(4) - (4)].addr).offset2 = ArgsSizeUnknown;
+		outcode((yyvsp[(1) - (4)].lval), Always, &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 32:
-
-/* Line 1806 of yacc.c  */
 #line 226 "a.y"
     {
-		(yyvsp[(6) - (6)].gen).type = D_CONST2;
-		(yyvsp[(6) - (6)].gen).offset2 = ArgsSizeUnknown;
-		outcode((yyvsp[(1) - (6)].lval), Always, &(yyvsp[(2) - (6)].gen), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].gen));
+		(yyvsp[(6) - (6)].addr).type = D_CONST2;
+		(yyvsp[(6) - (6)].addr).offset2 = ArgsSizeUnknown;
+		outcode((yyvsp[(1) - (6)].lval), Always, &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
 	}
     break;
 
   case 33:
-
-/* Line 1806 of yacc.c  */
 #line 232 "a.y"
     {
-		(yyvsp[(6) - (8)].gen).type = D_CONST2;
-		(yyvsp[(6) - (8)].gen).offset2 = (yyvsp[(8) - (8)].lval);
-		outcode((yyvsp[(1) - (8)].lval), Always, &(yyvsp[(2) - (8)].gen), (yyvsp[(4) - (8)].lval), &(yyvsp[(6) - (8)].gen));
+		(yyvsp[(6) - (8)].addr).type = D_CONST2;
+		(yyvsp[(6) - (8)].addr).offset2 = (yyvsp[(8) - (8)].lval);
+		outcode((yyvsp[(1) - (8)].lval), Always, &(yyvsp[(2) - (8)].addr), (yyvsp[(4) - (8)].lval), &(yyvsp[(6) - (8)].addr));
 	}
     break;
 
   case 34:
-
-/* Line 1806 of yacc.c  */
 #line 241 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), Always, &(yyvsp[(2) - (6)].gen), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].gen));
+		outcode((yyvsp[(1) - (6)].lval), Always, &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
 	}
     break;
 
   case 35:
-
-/* Line 1806 of yacc.c  */
 #line 248 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), (yyvsp[(2) - (4)].lval), &(yyvsp[(3) - (4)].gen), NREG, &nullgen);
+		outcode((yyvsp[(1) - (4)].lval), (yyvsp[(2) - (4)].lval), &(yyvsp[(3) - (4)].addr), NREG, &nullgen);
 	}
     break;
 
   case 36:
-
-/* Line 1806 of yacc.c  */
 #line 255 "a.y"
     {
-		outcode((yyvsp[(1) - (3)].lval), Always, &nullgen, NREG, &(yyvsp[(3) - (3)].gen));
+		outcode((yyvsp[(1) - (3)].lval), Always, &nullgen, NREG, &(yyvsp[(3) - (3)].addr));
 	}
     break;
 
   case 37:
-
-/* Line 1806 of yacc.c  */
 #line 262 "a.y"
     {
-		outcode((yyvsp[(1) - (5)].lval), (yyvsp[(2) - (5)].lval), &(yyvsp[(3) - (5)].gen), NREG, &(yyvsp[(5) - (5)].gen));
+		outcode((yyvsp[(1) - (5)].lval), (yyvsp[(2) - (5)].lval), &(yyvsp[(3) - (5)].addr), NREG, &(yyvsp[(5) - (5)].addr));
 	}
     break;
 
   case 38:
-
-/* Line 1806 of yacc.c  */
 #line 266 "a.y"
     {
-		outcode((yyvsp[(1) - (5)].lval), (yyvsp[(2) - (5)].lval), &(yyvsp[(3) - (5)].gen), NREG, &(yyvsp[(5) - (5)].gen));
+		outcode((yyvsp[(1) - (5)].lval), (yyvsp[(2) - (5)].lval), &(yyvsp[(3) - (5)].addr), NREG, &(yyvsp[(5) - (5)].addr));
 	}
     break;
 
   case 39:
-
-/* Line 1806 of yacc.c  */
 #line 270 "a.y"
     {
-		outcode((yyvsp[(1) - (7)].lval), (yyvsp[(2) - (7)].lval), &(yyvsp[(3) - (7)].gen), (yyvsp[(5) - (7)].lval), &(yyvsp[(7) - (7)].gen));
+		outcode((yyvsp[(1) - (7)].lval), (yyvsp[(2) - (7)].lval), &(yyvsp[(3) - (7)].addr), (yyvsp[(5) - (7)].lval), &(yyvsp[(7) - (7)].addr));
 	}
     break;
 
   case 40:
-
-/* Line 1806 of yacc.c  */
 #line 274 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), (yyvsp[(2) - (6)].lval), &(yyvsp[(3) - (6)].gen), (yyvsp[(5) - (6)].gen).reg, &nullgen);
+		outcode((yyvsp[(1) - (6)].lval), (yyvsp[(2) - (6)].lval), &(yyvsp[(3) - (6)].addr), (yyvsp[(5) - (6)].addr).reg, &nullgen);
 	}
     break;
 
   case 41:
-
-/* Line 1806 of yacc.c  */
 #line 281 "a.y"
     {
-		Gen g;
+		Addr g;
 
 		g = nullgen;
 		g.type = D_CONST;
@@ -2127,61 +2019,49 @@ yyreduce:
     break;
 
   case 42:
-
-/* Line 1806 of yacc.c  */
 #line 303 "a.y"
     {
-		outcode((yyvsp[(1) - (7)].lval), (yyvsp[(2) - (7)].lval), &(yyvsp[(3) - (7)].gen), (yyvsp[(5) - (7)].gen).reg, &(yyvsp[(7) - (7)].gen));
+		outcode((yyvsp[(1) - (7)].lval), (yyvsp[(2) - (7)].lval), &(yyvsp[(3) - (7)].addr), (yyvsp[(5) - (7)].addr).reg, &(yyvsp[(7) - (7)].addr));
 	}
     break;
 
   case 43:
-
-/* Line 1806 of yacc.c  */
 #line 311 "a.y"
     {
-		(yyvsp[(7) - (9)].gen).type = D_REGREG2;
-		(yyvsp[(7) - (9)].gen).offset = (yyvsp[(9) - (9)].lval);
-		outcode((yyvsp[(1) - (9)].lval), (yyvsp[(2) - (9)].lval), &(yyvsp[(3) - (9)].gen), (yyvsp[(5) - (9)].gen).reg, &(yyvsp[(7) - (9)].gen));
+		(yyvsp[(7) - (9)].addr).type = D_REGREG2;
+		(yyvsp[(7) - (9)].addr).offset = (yyvsp[(9) - (9)].lval);
+		outcode((yyvsp[(1) - (9)].lval), (yyvsp[(2) - (9)].lval), &(yyvsp[(3) - (9)].addr), (yyvsp[(5) - (9)].addr).reg, &(yyvsp[(7) - (9)].addr));
 	}
     break;
 
   case 44:
-
-/* Line 1806 of yacc.c  */
 #line 320 "a.y"
     {
-		outcode((yyvsp[(1) - (2)].lval), Always, &(yyvsp[(2) - (2)].gen), NREG, &nullgen);
+		outcode((yyvsp[(1) - (2)].lval), Always, &(yyvsp[(2) - (2)].addr), NREG, &nullgen);
 	}
     break;
 
   case 45:
-
-/* Line 1806 of yacc.c  */
 #line 327 "a.y"
     {
-		if((yyvsp[(2) - (4)].gen).type != D_CONST || (yyvsp[(4) - (4)].gen).type != D_CONST)
+		if((yyvsp[(2) - (4)].addr).type != D_CONST || (yyvsp[(4) - (4)].addr).type != D_CONST)
 			yyerror("arguments to PCDATA must be integer constants");
-		outcode((yyvsp[(1) - (4)].lval), Always, &(yyvsp[(2) - (4)].gen), NREG, &(yyvsp[(4) - (4)].gen));
+		outcode((yyvsp[(1) - (4)].lval), Always, &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 46:
-
-/* Line 1806 of yacc.c  */
 #line 336 "a.y"
     {
-		if((yyvsp[(2) - (4)].gen).type != D_CONST)
+		if((yyvsp[(2) - (4)].addr).type != D_CONST)
 			yyerror("index for FUNCDATA must be integer constant");
-		if((yyvsp[(4) - (4)].gen).type != D_EXTERN && (yyvsp[(4) - (4)].gen).type != D_STATIC)
+		if((yyvsp[(4) - (4)].addr).type != D_EXTERN && (yyvsp[(4) - (4)].addr).type != D_STATIC)
 			yyerror("value for FUNCDATA must be symbol reference");
- 		outcode((yyvsp[(1) - (4)].lval), Always, &(yyvsp[(2) - (4)].gen), NREG, &(yyvsp[(4) - (4)].gen));
+ 		outcode((yyvsp[(1) - (4)].lval), Always, &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 47:
-
-/* Line 1806 of yacc.c  */
 #line 347 "a.y"
     {
 		outcode((yyvsp[(1) - (2)].lval), Always, &nullgen, NREG, &nullgen);
@@ -2189,8 +2069,6 @@ yyreduce:
     break;
 
   case 48:
-
-/* Line 1806 of yacc.c  */
 #line 352 "a.y"
     {
 		(yyval.lval) = Always;
@@ -2198,8 +2076,6 @@ yyreduce:
     break;
 
   case 49:
-
-/* Line 1806 of yacc.c  */
 #line 356 "a.y"
     {
 		(yyval.lval) = ((yyvsp[(1) - (2)].lval) & ~C_SCOND) | (yyvsp[(2) - (2)].lval);
@@ -2207,8 +2083,6 @@ yyreduce:
     break;
 
   case 50:
-
-/* Line 1806 of yacc.c  */
 #line 360 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (2)].lval) | (yyvsp[(2) - (2)].lval);
@@ -2216,119 +2090,95 @@ yyreduce:
     break;
 
   case 53:
-
-/* Line 1806 of yacc.c  */
 #line 369 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_BRANCH;
-		(yyval.gen).offset = (yyvsp[(1) - (4)].lval) + pc;
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_BRANCH;
+		(yyval.addr).offset = (yyvsp[(1) - (4)].lval) + pc;
 	}
     break;
 
   case 54:
-
-/* Line 1806 of yacc.c  */
 #line 375 "a.y"
     {
-		(yyval.gen) = nullgen;
+		(yyval.addr) = nullgen;
 		if(pass == 2)
 			yyerror("undefined label: %s", (yyvsp[(1) - (2)].sym)->name);
-		(yyval.gen).type = D_BRANCH;
-		(yyval.gen).sym = (yyvsp[(1) - (2)].sym);
-		(yyval.gen).offset = (yyvsp[(2) - (2)].lval);
+		(yyval.addr).type = D_BRANCH;
+		(yyval.addr).offset = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 55:
-
-/* Line 1806 of yacc.c  */
-#line 384 "a.y"
+#line 383 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_BRANCH;
-		(yyval.gen).sym = (yyvsp[(1) - (2)].sym);
-		(yyval.gen).offset = (yyvsp[(1) - (2)].sym)->value + (yyvsp[(2) - (2)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_BRANCH;
+		(yyval.addr).offset = (yyvsp[(1) - (2)].sym)->value + (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 56:
-
-/* Line 1806 of yacc.c  */
-#line 392 "a.y"
+#line 390 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_CONST;
-		(yyval.gen).offset = (yyvsp[(2) - (2)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_CONST;
+		(yyval.addr).offset = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 57:
-
-/* Line 1806 of yacc.c  */
-#line 398 "a.y"
+#line 396 "a.y"
     {
-		(yyval.gen) = (yyvsp[(2) - (2)].gen);
-		(yyval.gen).type = D_CONST;
+		(yyval.addr) = (yyvsp[(2) - (2)].addr);
+		(yyval.addr).type = D_CONST;
 	}
     break;
 
   case 58:
-
-/* Line 1806 of yacc.c  */
-#line 403 "a.y"
+#line 401 "a.y"
     {
-		(yyval.gen) = (yyvsp[(4) - (4)].gen);
-		(yyval.gen).type = D_OCONST;
+		(yyval.addr) = (yyvsp[(4) - (4)].addr);
+		(yyval.addr).type = D_OCONST;
 	}
     break;
 
   case 59:
-
-/* Line 1806 of yacc.c  */
-#line 408 "a.y"
+#line 406 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_SCONST;
-		memcpy((yyval.gen).sval, (yyvsp[(2) - (2)].sval), sizeof((yyval.gen).sval));
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_SCONST;
+		memcpy((yyval.addr).u.sval, (yyvsp[(2) - (2)].sval), sizeof((yyval.addr).u.sval));
 	}
     break;
 
   case 61:
-
-/* Line 1806 of yacc.c  */
-#line 417 "a.y"
+#line 415 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_FCONST;
-		(yyval.gen).dval = (yyvsp[(2) - (2)].dval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_FCONST;
+		(yyval.addr).u.dval = (yyvsp[(2) - (2)].dval);
 	}
     break;
 
   case 62:
-
-/* Line 1806 of yacc.c  */
-#line 423 "a.y"
+#line 421 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_FCONST;
-		(yyval.gen).dval = -(yyvsp[(3) - (3)].dval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_FCONST;
+		(yyval.addr).u.dval = -(yyvsp[(3) - (3)].dval);
 	}
     break;
 
   case 63:
-
-/* Line 1806 of yacc.c  */
-#line 431 "a.y"
+#line 429 "a.y"
     {
 		(yyval.lval) = 1 << (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 64:
-
-/* Line 1806 of yacc.c  */
-#line 435 "a.y"
+#line 433 "a.y"
     {
 		int i;
 		(yyval.lval)=0;
@@ -2340,185 +2190,151 @@ yyreduce:
     break;
 
   case 65:
-
-/* Line 1806 of yacc.c  */
-#line 444 "a.y"
+#line 442 "a.y"
     {
 		(yyval.lval) = (1<<(yyvsp[(1) - (3)].lval)) | (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 69:
-
-/* Line 1806 of yacc.c  */
-#line 453 "a.y"
+#line 451 "a.y"
     {
-		(yyval.gen) = (yyvsp[(1) - (4)].gen);
-		(yyval.gen).reg = (yyvsp[(3) - (4)].lval);
+		(yyval.addr) = (yyvsp[(1) - (4)].addr);
+		(yyval.addr).reg = (yyvsp[(3) - (4)].lval);
 	}
     break;
 
   case 70:
-
-/* Line 1806 of yacc.c  */
-#line 458 "a.y"
+#line 456 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_PSR;
-		(yyval.gen).reg = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_PSR;
+		(yyval.addr).reg = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 71:
-
-/* Line 1806 of yacc.c  */
-#line 464 "a.y"
+#line 462 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_FPCR;
-		(yyval.gen).reg = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_FPCR;
+		(yyval.addr).reg = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 72:
-
-/* Line 1806 of yacc.c  */
-#line 470 "a.y"
+#line 468 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_OREG;
-		(yyval.gen).offset = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_OREG;
+		(yyval.addr).offset = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 76:
-
-/* Line 1806 of yacc.c  */
-#line 481 "a.y"
+#line 479 "a.y"
     {
-		(yyval.gen) = (yyvsp[(1) - (1)].gen);
-		if((yyvsp[(1) - (1)].gen).name != D_EXTERN && (yyvsp[(1) - (1)].gen).name != D_STATIC) {
+		(yyval.addr) = (yyvsp[(1) - (1)].addr);
+		if((yyvsp[(1) - (1)].addr).name != D_EXTERN && (yyvsp[(1) - (1)].addr).name != D_STATIC) {
 		}
 	}
     break;
 
   case 77:
-
-/* Line 1806 of yacc.c  */
-#line 489 "a.y"
+#line 487 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_OREG;
-		(yyval.gen).reg = (yyvsp[(2) - (3)].lval);
-		(yyval.gen).offset = 0;
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_OREG;
+		(yyval.addr).reg = (yyvsp[(2) - (3)].lval);
+		(yyval.addr).offset = 0;
 	}
     break;
 
   case 79:
-
-/* Line 1806 of yacc.c  */
-#line 499 "a.y"
+#line 497 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_OREG;
-		(yyval.gen).reg = (yyvsp[(3) - (4)].lval);
-		(yyval.gen).offset = (yyvsp[(1) - (4)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_OREG;
+		(yyval.addr).reg = (yyvsp[(3) - (4)].lval);
+		(yyval.addr).offset = (yyvsp[(1) - (4)].lval);
 	}
     break;
 
   case 81:
-
-/* Line 1806 of yacc.c  */
-#line 509 "a.y"
+#line 507 "a.y"
     {
-		(yyval.gen) = (yyvsp[(1) - (4)].gen);
-		(yyval.gen).type = D_OREG;
-		(yyval.gen).reg = (yyvsp[(3) - (4)].lval);
+		(yyval.addr) = (yyvsp[(1) - (4)].addr);
+		(yyval.addr).type = D_OREG;
+		(yyval.addr).reg = (yyvsp[(3) - (4)].lval);
 	}
     break;
 
   case 86:
-
-/* Line 1806 of yacc.c  */
-#line 522 "a.y"
+#line 520 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_CONST;
-		(yyval.gen).offset = (yyvsp[(2) - (2)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_CONST;
+		(yyval.addr).offset = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 87:
-
-/* Line 1806 of yacc.c  */
-#line 530 "a.y"
+#line 528 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_REG;
-		(yyval.gen).reg = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_REG;
+		(yyval.addr).reg = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 88:
-
-/* Line 1806 of yacc.c  */
-#line 538 "a.y"
+#line 536 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_REGREG;
-		(yyval.gen).reg = (yyvsp[(2) - (5)].lval);
-		(yyval.gen).offset = (yyvsp[(4) - (5)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_REGREG;
+		(yyval.addr).reg = (yyvsp[(2) - (5)].lval);
+		(yyval.addr).offset = (yyvsp[(4) - (5)].lval);
 	}
     break;
 
   case 89:
-
-/* Line 1806 of yacc.c  */
-#line 547 "a.y"
+#line 545 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_SHIFT;
-		(yyval.gen).offset = (yyvsp[(1) - (4)].lval) | (yyvsp[(4) - (4)].lval) | (0 << 5);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_SHIFT;
+		(yyval.addr).offset = (yyvsp[(1) - (4)].lval) | (yyvsp[(4) - (4)].lval) | (0 << 5);
 	}
     break;
 
   case 90:
-
-/* Line 1806 of yacc.c  */
-#line 553 "a.y"
+#line 551 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_SHIFT;
-		(yyval.gen).offset = (yyvsp[(1) - (4)].lval) | (yyvsp[(4) - (4)].lval) | (1 << 5);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_SHIFT;
+		(yyval.addr).offset = (yyvsp[(1) - (4)].lval) | (yyvsp[(4) - (4)].lval) | (1 << 5);
 	}
     break;
 
   case 91:
-
-/* Line 1806 of yacc.c  */
-#line 559 "a.y"
+#line 557 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_SHIFT;
-		(yyval.gen).offset = (yyvsp[(1) - (4)].lval) | (yyvsp[(4) - (4)].lval) | (2 << 5);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_SHIFT;
+		(yyval.addr).offset = (yyvsp[(1) - (4)].lval) | (yyvsp[(4) - (4)].lval) | (2 << 5);
 	}
     break;
 
   case 92:
-
-/* Line 1806 of yacc.c  */
-#line 565 "a.y"
+#line 563 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_SHIFT;
-		(yyval.gen).offset = (yyvsp[(1) - (4)].lval) | (yyvsp[(4) - (4)].lval) | (3 << 5);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_SHIFT;
+		(yyval.addr).offset = (yyvsp[(1) - (4)].lval) | (yyvsp[(4) - (4)].lval) | (3 << 5);
 	}
     break;
 
   case 93:
-
-/* Line 1806 of yacc.c  */
-#line 573 "a.y"
+#line 571 "a.y"
     {
 		if((yyval.lval) < 0 || (yyval.lval) >= 16)
 			print("register value out of range\n");
@@ -2527,9 +2343,7 @@ yyreduce:
     break;
 
   case 94:
-
-/* Line 1806 of yacc.c  */
-#line 579 "a.y"
+#line 577 "a.y"
     {
 		if((yyval.lval) < 0 || (yyval.lval) >= 32)
 			print("shift value out of range\n");
@@ -2538,18 +2352,14 @@ yyreduce:
     break;
 
   case 96:
-
-/* Line 1806 of yacc.c  */
-#line 588 "a.y"
+#line 586 "a.y"
     {
 		(yyval.lval) = REGPC;
 	}
     break;
 
   case 97:
-
-/* Line 1806 of yacc.c  */
-#line 592 "a.y"
+#line 590 "a.y"
     {
 		if((yyvsp[(3) - (4)].lval) < 0 || (yyvsp[(3) - (4)].lval) >= NREG)
 			print("register value out of range\n");
@@ -2558,18 +2368,14 @@ yyreduce:
     break;
 
   case 99:
-
-/* Line 1806 of yacc.c  */
-#line 601 "a.y"
+#line 599 "a.y"
     {
 		(yyval.lval) = REGSP;
 	}
     break;
 
   case 101:
-
-/* Line 1806 of yacc.c  */
-#line 608 "a.y"
+#line 606 "a.y"
     {
 		if((yyvsp[(3) - (4)].lval) < 0 || (yyvsp[(3) - (4)].lval) >= NREG)
 			print("register value out of range\n");
@@ -2578,263 +2384,201 @@ yyreduce:
     break;
 
   case 104:
-
-/* Line 1806 of yacc.c  */
-#line 620 "a.y"
+#line 618 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_FREG;
-		(yyval.gen).reg = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_FREG;
+		(yyval.addr).reg = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 105:
-
-/* Line 1806 of yacc.c  */
-#line 626 "a.y"
+#line 624 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_FREG;
-		(yyval.gen).reg = (yyvsp[(3) - (4)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_FREG;
+		(yyval.addr).reg = (yyvsp[(3) - (4)].lval);
 	}
     break;
 
   case 106:
-
-/* Line 1806 of yacc.c  */
-#line 634 "a.y"
+#line 632 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_OREG;
-		(yyval.gen).name = (yyvsp[(3) - (4)].lval);
-		(yyval.gen).sym = S;
-		(yyval.gen).offset = (yyvsp[(1) - (4)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_OREG;
+		(yyval.addr).name = (yyvsp[(3) - (4)].lval);
+		(yyval.addr).sym = nil;
+		(yyval.addr).offset = (yyvsp[(1) - (4)].lval);
 	}
     break;
 
   case 107:
-
-/* Line 1806 of yacc.c  */
-#line 642 "a.y"
+#line 640 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_OREG;
-		(yyval.gen).name = (yyvsp[(4) - (5)].lval);
-		(yyval.gen).sym = (yyvsp[(1) - (5)].sym);
-		(yyval.gen).offset = (yyvsp[(2) - (5)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_OREG;
+		(yyval.addr).name = (yyvsp[(4) - (5)].lval);
+		(yyval.addr).sym = linklookup(ctxt, (yyvsp[(1) - (5)].sym)->name, 0);
+		(yyval.addr).offset = (yyvsp[(2) - (5)].lval);
 	}
     break;
 
   case 108:
-
-/* Line 1806 of yacc.c  */
-#line 650 "a.y"
+#line 648 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_OREG;
-		(yyval.gen).name = D_STATIC;
-		(yyval.gen).sym = (yyvsp[(1) - (7)].sym);
-		(yyval.gen).offset = (yyvsp[(4) - (7)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_OREG;
+		(yyval.addr).name = D_STATIC;
+		(yyval.addr).sym = linklookup(ctxt, (yyvsp[(1) - (7)].sym)->name, 1);
+		(yyval.addr).offset = (yyvsp[(4) - (7)].lval);
 	}
     break;
 
   case 109:
-
-/* Line 1806 of yacc.c  */
-#line 659 "a.y"
+#line 657 "a.y"
     {
 		(yyval.lval) = 0;
 	}
     break;
 
   case 110:
-
-/* Line 1806 of yacc.c  */
-#line 663 "a.y"
+#line 661 "a.y"
     {
 		(yyval.lval) = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 111:
-
-/* Line 1806 of yacc.c  */
-#line 667 "a.y"
+#line 665 "a.y"
     {
 		(yyval.lval) = -(yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 116:
-
-/* Line 1806 of yacc.c  */
-#line 679 "a.y"
+#line 677 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (1)].sym)->value;
 	}
     break;
 
   case 117:
-
-/* Line 1806 of yacc.c  */
-#line 683 "a.y"
+#line 681 "a.y"
     {
 		(yyval.lval) = -(yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 118:
-
-/* Line 1806 of yacc.c  */
-#line 687 "a.y"
+#line 685 "a.y"
     {
 		(yyval.lval) = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 119:
-
-/* Line 1806 of yacc.c  */
-#line 691 "a.y"
+#line 689 "a.y"
     {
 		(yyval.lval) = ~(yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 120:
-
-/* Line 1806 of yacc.c  */
-#line 695 "a.y"
+#line 693 "a.y"
     {
 		(yyval.lval) = (yyvsp[(2) - (3)].lval);
 	}
     break;
 
   case 121:
-
-/* Line 1806 of yacc.c  */
-#line 700 "a.y"
+#line 698 "a.y"
     {
 		(yyval.lval) = 0;
 	}
     break;
 
   case 122:
-
-/* Line 1806 of yacc.c  */
-#line 704 "a.y"
+#line 702 "a.y"
     {
 		(yyval.lval) = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 124:
-
-/* Line 1806 of yacc.c  */
-#line 711 "a.y"
+#line 709 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) + (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 125:
-
-/* Line 1806 of yacc.c  */
-#line 715 "a.y"
+#line 713 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) - (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 126:
-
-/* Line 1806 of yacc.c  */
-#line 719 "a.y"
+#line 717 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) * (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 127:
-
-/* Line 1806 of yacc.c  */
-#line 723 "a.y"
+#line 721 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) / (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 128:
-
-/* Line 1806 of yacc.c  */
-#line 727 "a.y"
+#line 725 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) % (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 129:
-
-/* Line 1806 of yacc.c  */
-#line 731 "a.y"
+#line 729 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (4)].lval) << (yyvsp[(4) - (4)].lval);
 	}
     break;
 
   case 130:
-
-/* Line 1806 of yacc.c  */
-#line 735 "a.y"
+#line 733 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (4)].lval) >> (yyvsp[(4) - (4)].lval);
 	}
     break;
 
   case 131:
-
-/* Line 1806 of yacc.c  */
-#line 739 "a.y"
+#line 737 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) & (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 132:
-
-/* Line 1806 of yacc.c  */
-#line 743 "a.y"
+#line 741 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) ^ (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 133:
-
-/* Line 1806 of yacc.c  */
-#line 747 "a.y"
+#line 745 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) | (yyvsp[(3) - (3)].lval);
 	}
     break;
 
 
-
-/* Line 1806 of yacc.c  */
-#line 2825 "y.tab.c"
+/* Line 1267 of yacc.c.  */
+#line 2580 "y.tab.c"
       default: break;
     }
-  /* User semantic actions sometimes alter yychar, and that requires
-     that yytoken be updated with the new translation.  We take the
-     approach of translating immediately before every use of yytoken.
-     One alternative is translating here after every semantic action,
-     but that translation would be missed if the semantic action invokes
-     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
-     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
-     incorrect destructor might then be invoked immediately.  In the
-     case of YYERROR or YYBACKUP, subsequent parser actions might lead
-     to an incorrect destructor call or verbose syntax error message
-     before the lookahead is translated.  */
   YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
   YYPOPSTACK (yylen);
@@ -2843,6 +2587,7 @@ yyreduce:
 
   *++yyvsp = yyval;
 
+
   /* Now `shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
      number reduced by.  */
@@ -2862,10 +2607,6 @@ yyreduce:
 | yyerrlab -- here on detecting error |
 `------------------------------------*/
 yyerrlab:
-  /* Make sure we have latest lookahead translation.  See comments at
-     user semantic actions for why this is necessary.  */
-  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
-
   /* If not already recovering from an error, report this error.  */
   if (!yyerrstatus)
     {
@@ -2873,36 +2614,37 @@ yyerrlab:
 #if ! YYERROR_VERBOSE
       yyerror (YY_("syntax error"));
 #else
-# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
-                                        yyssp, yytoken)
       {
-        char const *yymsgp = YY_("syntax error");
-        int yysyntax_error_status;
-        yysyntax_error_status = YYSYNTAX_ERROR;
-        if (yysyntax_error_status == 0)
-          yymsgp = yymsg;
-        else if (yysyntax_error_status == 1)
-          {
-            if (yymsg != yymsgbuf)
-              YYSTACK_FREE (yymsg);
-            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
-            if (!yymsg)
-              {
-                yymsg = yymsgbuf;
-                yymsg_alloc = sizeof yymsgbuf;
-                yysyntax_error_status = 2;
-              }
-            else
-              {
-                yysyntax_error_status = YYSYNTAX_ERROR;
-                yymsgp = yymsg;
-              }
-          }
-        yyerror (yymsgp);
-        if (yysyntax_error_status == 2)
-          goto yyexhaustedlab;
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
       }
-# undef YYSYNTAX_ERROR
 #endif
     }
 
@@ -2910,7 +2652,7 @@ yyerrlab:
 
   if (yyerrstatus == 3)
     {
-      /* If just tried and failed to reuse lookahead token after an
+      /* If just tried and failed to reuse look-ahead token after an
 	 error, discard it.  */
 
       if (yychar <= YYEOF)
@@ -2927,7 +2669,7 @@ yyerrlab:
 	}
     }
 
-  /* Else will try to reuse lookahead token after shifting the error
+  /* Else will try to reuse look-ahead token after shifting the error
      token.  */
   goto yyerrlab1;
 
@@ -2961,7 +2703,7 @@ yyerrlab1:
   for (;;)
     {
       yyn = yypact[yystate];
-      if (!yypact_value_is_default (yyn))
+      if (yyn != YYPACT_NINF)
 	{
 	  yyn += YYTERROR;
 	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
@@ -2984,6 +2726,9 @@ yyerrlab1:
       YY_STACK_PRINT (yyss, yyssp);
     }
 
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
   *++yyvsp = yylval;
 
 
@@ -3008,7 +2753,7 @@ yyabortlab:
   yyresult = 1;
   goto yyreturn;
 
-#if !defined(yyoverflow) || YYERROR_VERBOSE
+#ifndef yyoverflow
 /*-------------------------------------------------.
 | yyexhaustedlab -- memory exhaustion comes here.  |
 `-------------------------------------------------*/
@@ -3019,14 +2764,9 @@ yyexhaustedlab:
 #endif
 
 yyreturn:
-  if (yychar != YYEMPTY)
-    {
-      /* Make sure we have latest lookahead translation.  See comments at
-         user semantic actions for why this is necessary.  */
-      yytoken = YYTRANSLATE (yychar);
-      yydestruct ("Cleanup: discarding lookahead",
-                  yytoken, &yylval);
-    }
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
   /* Do not reclaim the symbols of the rule which action triggered
      this YYABORT or YYACCEPT.  */
   YYPOPSTACK (yylen);
diff --git a/src/cmd/5a/y.tab.h b/src/cmd/5a/y.tab.h
index 92230a2a57..f75cb22a75 100644
--- a/src/cmd/5a/y.tab.h
+++ b/src/cmd/5a/y.tab.h
@@ -1,21 +1,24 @@
-/* A Bison parser, made by GNU Bison 2.5.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Bison interface for Yacc-like parsers in C
-   
-      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
-   
-   This program is free software: you can redistribute it and/or modify
+/* Skeleton interface for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-   
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -26,11 +29,10 @@
    special exception, which will cause the skeleton and the resulting
    Bison output files to be licensed under the GNU General Public
    License without this special exception.
-   
+
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
-
 /* Tokens.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
@@ -142,27 +144,21 @@
 
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-{
-
-/* Line 2068 of yacc.c  */
 #line 39 "a.y"
-
+{
 	Sym	*sym;
 	int32	lval;
 	double	dval;
 	char	sval[8];
-	Gen	gen;
-
-
-
-/* Line 2068 of yacc.c  */
-#line 160 "y.tab.h"
-} YYSTYPE;
-# define YYSTYPE_IS_TRIVIAL 1
+	Addr	addr;
+}
+/* Line 1529 of yacc.c.  */
+#line 157 "y.tab.h"
+	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
 #endif
 
 extern YYSTYPE yylval;
 
-
diff --git a/src/cmd/6a/a.h b/src/cmd/6a/a.h
index 5c7868070c..db72accd7f 100644
--- a/src/cmd/6a/a.h
+++ b/src/cmd/6a/a.h
@@ -29,9 +29,9 @@
 // THE SOFTWARE.
 
 #include <bio.h>
+#include <link.h>
 #include "../6l/6.out.h"
 
-
 #ifndef	EXTERN
 #define	EXTERN	extern
 #endif
@@ -45,10 +45,8 @@
 
 typedef	struct	Sym	Sym;
 typedef	struct	Ref	Ref;
-typedef	struct	Gen	Gen;
 typedef	struct	Io	Io;
-typedef	struct	Hist	Hist;
-typedef	struct	Gen2	Gen2;
+typedef	struct	Addr2	Addr2;
 
 #define	MAXALIGN	7
 #define	FPCHIP		1
@@ -97,36 +95,11 @@ struct	Io
 };
 #define	I	((Io*)0)
 
-EXTERN struct
-{
-	Sym*	sym;
-	short	type;
-} h[NSYM];
-
-struct	Gen
-{
-	double	dval;
-	char	sval[8];
-	vlong	offset;
-	Sym*	sym;
-	short	type;
-	short	index;
-	short	scale;
-};
-struct	Gen2
-{
-	Gen	from;
-	Gen	to;
-};
-
-struct	Hist
+struct	Addr2
 {
-	Hist*	link;
-	char*	name;
-	int32	line;
-	vlong	offset;
+	Addr	from;
+	Addr	to;
 };
-#define	H	((Hist*)0)
 
 enum
 {
@@ -136,14 +109,11 @@ enum
 	CPREPROC,
 };
 
-
 EXTERN	char	debug[256];
 EXTERN	Sym*	hash[NHASH];
 EXTERN	char**	Dlist;
 EXTERN	int	nDlist;
-EXTERN	Hist*	ehist;
 EXTERN	int	newflag;
-EXTERN	Hist*	hist;
 EXTERN	char*	hunk;
 EXTERN	char**	include;
 EXTERN	Io*	iofree;
@@ -154,10 +124,9 @@ EXTERN	int	nerrors;
 EXTERN	int32	nhunk;
 EXTERN	int	ninclude;
 EXTERN	int32	nsymb;
-EXTERN	Gen	nullgen;
+EXTERN	Addr	nullgen;
 EXTERN	char*	outfile;
 EXTERN	int	pass;
-EXTERN	char*	pathname;
 EXTERN	int32	pc;
 EXTERN	int	peekc;
 EXTERN	int32	stmtline;
@@ -167,6 +136,7 @@ EXTERN	int	thechar;
 EXTERN	char*	thestring;
 EXTERN	int32	thunk;
 EXTERN	Biobuf	obuf;
+EXTERN	Link*	ctxt;
 
 void*	alloc(int32);
 void*	allocn(void*, int32, int32);
@@ -187,12 +157,11 @@ void	cinit(void);
 void	checkscale(int);
 void	pinit(char*);
 void	cclean(void);
-int	isreg(Gen*);
-void	outcode(int, Gen2*);
+int	isreg(Addr*);
+void	outcode(int, Addr2*);
 void	outhist(void);
-void	zaddr(Gen*, int);
+void	zaddr(Addr*, int);
 void	zname(char*, int, int);
-void	ieeedtod(Ieee*, double);
 int	filbuf(void);
 Sym*	getsym(void);
 void	domacro(void);
diff --git a/src/cmd/6a/a.y b/src/cmd/6a/a.y
index ed72916b2e..aeaf86b809 100644
--- a/src/cmd/6a/a.y
+++ b/src/cmd/6a/a.y
@@ -40,8 +40,8 @@
 	vlong	lval;
 	double	dval;
 	char	sval[8];
-	Gen	gen;
-	Gen2	gen2;
+	LAddr	addr;
+	Addr2	addr2;
 }
 %left	'|'
 %left	'^'
@@ -58,10 +58,10 @@
 %token	<sval>	LSCONST LSP
 %token	<sym>	LNAME LLAB LVAR
 %type	<lval>	con con2 expr pointer offset
-%type	<gen>	mem imm imm2 reg nam rel rem rim rom omem nmem
-%type	<gen2>	nonnon nonrel nonrem rimnon rimrem remrim
-%type	<gen2>	spec1 spec2 spec3 spec4 spec5 spec6 spec7 spec8 spec9
-%type	<gen2>	spec10 spec11 spec12 spec13
+%type	<addr>	mem imm imm2 reg nam rel rem rim rom omem nmem
+%type	<addr2>	nonnon nonrel nonrem rimnon rimrem remrim
+%type	<addr2>	spec1 spec2 spec3 spec4 spec5 spec6 spec7 spec8 spec9
+%type	<addr2>	spec10 spec11 spec12 spec13
 %%
 prog:
 |	prog 
@@ -367,14 +367,12 @@ rel:
 		if(pass == 2)
 			yyerror("undefined label: %s", $1->name);
 		$$.type = D_BRANCH;
-		$$.sym = $1;
 		$$.offset = $2;
 	}
 |	LLAB offset
 	{
 		$$ = nullgen;
 		$$.type = D_BRANCH;
-		$$.sym = $1;
 		$$.offset = $1->value + $2;
 	}
 
@@ -444,31 +442,31 @@ imm:
 	{
 		$$ = nullgen;
 		$$.type = D_SCONST;
-		memcpy($$.sval, $2, sizeof($$.sval));
+		memcpy($$.u.sval, $2, sizeof($$.u.sval));
 	}
 |	'$' LFCONST
 	{
 		$$ = nullgen;
 		$$.type = D_FCONST;
-		$$.dval = $2;
+		$$.u.dval = $2;
 	}
 |	'$' '(' LFCONST ')'
 	{
 		$$ = nullgen;
 		$$.type = D_FCONST;
-		$$.dval = $3;
+		$$.u.dval = $3;
 	}
 |	'$' '(' '-' LFCONST ')'
 	{
 		$$ = nullgen;
 		$$.type = D_FCONST;
-		$$.dval = -$4;
+		$$.u.dval = -$4;
 	}
 |	'$' '-' LFCONST
 	{
 		$$ = nullgen;
 		$$.type = D_FCONST;
-		$$.dval = -$3;
+		$$.u.dval = -$3;
 	}
 
 mem:
@@ -572,14 +570,14 @@ nam:
 	{
 		$$ = nullgen;
 		$$.type = $4;
-		$$.sym = $1;
+		$$.sym = linklookup(ctxt, $1->name, 0);
 		$$.offset = $2;
 	}
 |	LNAME '<' '>' offset '(' LSB ')'
 	{
 		$$ = nullgen;
 		$$.type = D_STATIC;
-		$$.sym = $1;
+		$$.sym = linklookup(ctxt, $1->name, 1);
 		$$.offset = $4;
 	}
 
diff --git a/src/cmd/6a/lex.c b/src/cmd/6a/lex.c
index ab34e82209..97c78d1616 100644
--- a/src/cmd/6a/lex.c
+++ b/src/cmd/6a/lex.c
@@ -65,6 +65,8 @@ main(int argc, char *argv[])
 
 	thechar = '6';
 	thestring = "amd64";
+	ctxt = linknew(&linkamd64);
+	ctxt->diag = yyerror;
 
 	ensuresymb(NSYMB);
 	memset(debug, 0, sizeof(debug));
@@ -96,6 +98,10 @@ main(int argc, char *argv[])
 		p = ARGF();
 		setinclude(p);
 		break;
+
+	case 'S':
+		ctxt->debugasm++;
+		break;
 	} ARGEND
 	if(*argv == 0) {
 		print("usage: %ca [-options] file.s\n", thechar);
@@ -145,30 +151,23 @@ assemble(char *file)
 		errorexit();
 	}
 	Binit(&obuf, of, OWRITE);
-
-	pass = 1;
-	pinit(file);
-
 	Bprint(&obuf, "go object %s %s %s\n", getgoos(), thestring, getgoversion());
+	Bprint(&obuf, "\n!\n");
 
-	for(i=0; i<nDlist; i++)
-		dodefine(Dlist[i]);
-	yyparse();
-	if(nerrors) {
+	for(pass = 1; pass <= 2; pass++) {
+		pinit(file);
+		for(i=0; i<nDlist; i++)
+			dodefine(Dlist[i]);
+		yyparse();
 		cclean();
-		return nerrors;
+		if(nerrors)
+			return nerrors;
 	}
 
-	Bprint(&obuf, "\n!\n");
-
-	pass = 2;
-	outhist();
-	pinit(file);
-	for(i=0; i<nDlist; i++)
-		dodefine(Dlist[i]);
-	yyparse();
-	cclean();
-	return nerrors;
+	linkouthist(ctxt, &obuf);
+	linkwritefuncs(ctxt, &obuf);
+	Bflush(&obuf);
+	return 0;
 }
 
 struct
@@ -1031,15 +1030,8 @@ cinit(void)
 	Sym *s;
 	int i;
 
-	nullgen.sym = S;
-	nullgen.offset = 0;
-	if(FPCHIP)
-		nullgen.dval = 0;
-	for(i=0; i<sizeof(nullgen.sval); i++)
-		nullgen.sval[i] = 0;
 	nullgen.type = D_NONE;
 	nullgen.index = D_NONE;
-	nullgen.scale = 0;
 
 	nerrors = 0;
 	iostack = I;
@@ -1055,13 +1047,6 @@ cinit(void)
 		s->type = itab[i].type;
 		s->value = itab[i].value;
 	}
-
-	pathname = allocn(pathname, 0, 100);
-	if(getwd(pathname, 99) == 0) {
-		pathname = allocn(pathname, 100, 900);
-		if(getwd(pathname, 999) == 0)
-			strcpy(pathname, "/???");
-	}
 }
 
 void
@@ -1089,255 +1074,42 @@ syminit(Sym *s)
 void
 cclean(void)
 {
-	Gen2 g2;
+	Addr2 g2;
 
 	g2.from = nullgen;
 	g2.to = nullgen;
 	outcode(AEND, &g2);
-	Bflush(&obuf);
 }
 
-void
-zname(char *n, int t, int s)
-{
-
-	BPUTLE2(&obuf, ANAME);		/* as(2) */
-	BPUTC(&obuf, t);		/* type */
-	BPUTC(&obuf, s);		/* sym */
-	while(*n) {
-		BPUTC(&obuf, *n);
-		n++;
-	}
-	BPUTC(&obuf, 0);
-}
-
-void
-zaddr(Gen *a, int s)
-{
-	int32 l;
-	int i, t;
-	char *n;
-	Ieee e;
-
-	t = 0;
-	if(a->index != D_NONE || a->scale != 0)
-		t |= T_INDEX;
-	if(a->offset != 0) {
-		t |= T_OFFSET;
-		l = a->offset;
-		if((vlong)l != a->offset)
-			t |= T_64;
-	}
-	if(s != 0)
-		t |= T_SYM;
-
-	switch(a->type) {
-	default:
-		t |= T_TYPE;
-		break;
-	case D_FCONST:
-		t |= T_FCONST;
-		break;
-	case D_SCONST:
-		t |= T_SCONST;
-		break;
-	case D_NONE:
-		break;
-	}
-	BPUTC(&obuf, t);
-
-	if(t & T_INDEX) {	/* implies index, scale */
-		BPUTC(&obuf, a->index);
-		BPUTC(&obuf, a->scale);
-	}
-	if(t & T_OFFSET) {	/* implies offset */
-		l = a->offset;
-		BPUTLE4(&obuf, l);
-		if(t & T_64) {
-			l = a->offset>>32;
-			BPUTLE4(&obuf, l);
-		}
-	}
-	if(t & T_SYM)		/* implies sym */
-		BPUTC(&obuf, s);
-	if(t & T_FCONST) {
-		ieeedtod(&e, a->dval);
-		l = e.l;
-		BPUTLE4(&obuf, l);
-		l = e.h;
-		BPUTLE4(&obuf, l);
-		return;
-	}
-	if(t & T_SCONST) {
-		n = a->sval;
-		for(i=0; i<NSNAME; i++) {
-			BPUTC(&obuf, *n);
-			n++;
-		}
-		return;
-	}
-	if(t & T_TYPE)
-		BPUTC(&obuf, a->type);
-}
+static Prog *lastpc;
 
 void
-outcode(int a, Gen2 *g2)
+outcode(int a, Addr2 *g2)
 {
-	int sf, st, t;
-	Sym *s;
-
+	Prog *p;
+	Plist *pl;
+	
 	if(pass == 1)
 		goto out;
 
-jackpot:
-	sf = 0;
-	s = g2->from.sym;
-	while(s != S) {
-		sf = s->sym;
-		if(sf < 0 || sf >= NSYM)
-			sf = 0;
-		t = g2->from.type;
-		if(t == D_ADDR)
-			t = g2->from.index;
-		if(h[sf].type == t)
-		if(h[sf].sym == s)
-			break;
-		zname(s->name, t, sym);
-		s->sym = sym;
-		h[sym].sym = s;
-		h[sym].type = t;
-		sf = sym;
-		sym++;
-		if(sym >= NSYM)
-			sym = 1;
-		break;
-	}
-	st = 0;
-	s = g2->to.sym;
-	while(s != S) {
-		st = s->sym;
-		if(st < 0 || st >= NSYM)
-			st = 0;
-		t = g2->to.type;
-		if(t == D_ADDR)
-			t = g2->to.index;
-		if(h[st].type == t)
-		if(h[st].sym == s)
-			break;
-		zname(s->name, t, sym);
-		s->sym = sym;
-		h[sym].sym = s;
-		h[sym].type = t;
-		st = sym;
-		sym++;
-		if(sym >= NSYM)
-			sym = 1;
-		if(st == sf)
-			goto jackpot;
-		break;
-	}
-	BPUTLE2(&obuf, a);
-	BPUTLE4(&obuf, stmtline);
-	zaddr(&g2->from, sf);
-	zaddr(&g2->to, st);
+	p = malloc(sizeof *p);
+	memset(p, 0, sizeof *p);
+	p->as = a;
+	p->lineno = stmtline;
+	p->from = g2->from;
+	p->to = g2->to;
+
+	if(lastpc == nil) {
+		pl = linknewplist(ctxt);
+		pl->firstpc = p;
+	} else
+		lastpc->link = p;
+	lastpc = p;	
 
 out:
 	if(a != AGLOBL && a != ADATA)
 		pc++;
 }
 
-void
-outhist(void)
-{
-	Gen g;
-	Hist *h;
-	char *p, *q, *op, c;
-	int n;
-	char *tofree;
-	static int first = 1;
-	static char *goroot, *goroot_final;
-
-	if(first) {
-		// Decide whether we need to rewrite paths from $GOROOT to $GOROOT_FINAL.
-		first = 0;
-		goroot = getenv("GOROOT");
-		goroot_final = getenv("GOROOT_FINAL");
-		if(goroot == nil)
-			goroot = "";
-		if(goroot_final == nil)
-			goroot_final = goroot;
-		if(strcmp(goroot, goroot_final) == 0) {
-			goroot = nil;
-			goroot_final = nil;
-		}
-	}
-
-	tofree = nil;
-
-	g = nullgen;
-	c = pathchar();
-	for(h = hist; h != H; h = h->link) {
-		p = h->name;
-		if(p != nil && goroot != nil) {
-			n = strlen(goroot);
-			if(strncmp(p, goroot, strlen(goroot)) == 0 && p[n] == '/') {
-				tofree = smprint("%s%s", goroot_final, p+n);
-				p = tofree;
-			}
-		}
-		op = 0;
-		if(systemtype(Windows) && p && p[1] == ':'){
-			c = p[2];
-		} else if(p && p[0] != c && h->offset == 0 && pathname){
-			if(systemtype(Windows) && pathname[1] == ':') {
-				op = p;
-				p = pathname;
-				c = p[2];
-			} else if(pathname[0] == c){
-				op = p;
-				p = pathname;
-			}
-		}
-		while(p) {
-			q = strchr(p, c);
-			if(q) {
-				n = q-p;
-				if(n == 0){
-					n = 1;	/* leading "/" */
-					*p = '/';	/* don't emit "\" on windows */
-				}
-				q++;
-			} else {
-				n = strlen(p);
-				q = 0;
-			}
-			if(n) {
-				BPUTLE2(&obuf, ANAME);
-				BPUTC(&obuf, D_FILE);	/* type */
-				BPUTC(&obuf, 1);	/* sym */
-				BPUTC(&obuf, '<');
-				Bwrite(&obuf, p, n);
-				BPUTC(&obuf, 0);
-			}
-			p = q;
-			if(p == 0 && op) {
-				p = op;
-				op = 0;
-			}
-		}
-		g.offset = h->offset;
-
-		BPUTLE2(&obuf, AHISTORY);
-		BPUTLE4(&obuf, h->line);
-		zaddr(&nullgen, 0);
-		zaddr(&g, 0);
-
-		if(tofree) {
-			free(tofree);
-			tofree = nil;
-		}
-	}
-}
-
 #include "../cc/lexbody"
 #include "../cc/macbody"
diff --git a/src/cmd/6a/y.tab.c b/src/cmd/6a/y.tab.c
index 3e5058b9d2..a4f0f74cca 100644
--- a/src/cmd/6a/y.tab.c
+++ b/src/cmd/6a/y.tab.c
@@ -1,21 +1,24 @@
-/* A Bison parser, made by GNU Bison 2.5.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Bison implementation for Yacc-like parsers in C
-   
-      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
-   
-   This program is free software: you can redistribute it and/or modify
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-   
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -26,7 +29,7 @@
    special exception, which will cause the skeleton and the resulting
    Bison output files to be licensed under the GNU General Public
    License without this special exception.
-   
+
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
@@ -44,7 +47,7 @@
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "2.5"
+#define YYBISON_VERSION "2.3"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -52,51 +55,11 @@
 /* Pure parsers.  */
 #define YYPURE 0
 
-/* Push parsers.  */
-#define YYPUSH 0
-
-/* Pull parsers.  */
-#define YYPULL 1
-
 /* Using locations.  */
 #define YYLSP_NEEDED 0
 
 
 
-/* Copy the first part of user declarations.  */
-
-/* Line 268 of yacc.c  */
-#line 31 "a.y"
-
-#include <u.h>
-#include <stdio.h>	/* if we don't, bison will, and a.h re-#defines getc */
-#include <libc.h>
-#include "a.h"
-#include "../../pkg/runtime/funcdata.h"
-
-
-/* Line 268 of yacc.c  */
-#line 80 "y.tab.c"
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-/* Enabling the token table.  */
-#ifndef YYTOKEN_TABLE
-# define YYTOKEN_TABLE 0
-#endif
-
-
 /* Tokens.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
@@ -180,36 +143,60 @@
 
 
 
+/* Copy the first part of user declarations.  */
+#line 31 "a.y"
+
+#include <u.h>
+#include <stdio.h>	/* if we don't, bison will, and a.h re-#defines getc */
+#include <libc.h>
+#include "a.h"
+#include "../../pkg/runtime/funcdata.h"
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-{
-
-/* Line 293 of yacc.c  */
 #line 38 "a.y"
-
+{
 	Sym	*sym;
 	vlong	lval;
 	double	dval;
 	char	sval[8];
-	Gen	gen;
-	Gen2	gen2;
-
-
-
-/* Line 293 of yacc.c  */
-#line 201 "y.tab.c"
-} YYSTYPE;
-# define YYSTYPE_IS_TRIVIAL 1
+	Addr	addr;
+	Addr2	addr2;
+}
+/* Line 193 of yacc.c.  */
+#line 187 "y.tab.c"
+	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
 #endif
 
 
+
 /* Copy the second part of user declarations.  */
 
 
-/* Line 343 of yacc.c  */
-#line 213 "y.tab.c"
+/* Line 216 of yacc.c.  */
+#line 200 "y.tab.c"
 
 #ifdef short
 # undef short
@@ -284,14 +271,14 @@ typedef short int yytype_int16;
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 static int
-YYID (int yyi)
+YYID (int i)
 #else
 static int
-YYID (yyi)
-    int yyi;
+YYID (i)
+    int i;
 #endif
 {
-  return yyi;
+  return i;
 }
 #endif
 
@@ -312,11 +299,11 @@ YYID (yyi)
 #    define alloca _alloca
 #   else
 #    define YYSTACK_ALLOC alloca
-#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 #     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#     ifndef EXIT_SUCCESS
-#      define EXIT_SUCCESS 0
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
 #     endif
 #    endif
 #   endif
@@ -339,24 +326,24 @@ YYID (yyi)
 #  ifndef YYSTACK_ALLOC_MAXIMUM
 #   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
 #  endif
-#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+#  if (defined __cplusplus && ! defined _STDLIB_H \
        && ! ((defined YYMALLOC || defined malloc) \
 	     && (defined YYFREE || defined free)))
 #   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   ifndef EXIT_SUCCESS
-#    define EXIT_SUCCESS 0
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
 #   endif
 #  endif
 #  ifndef YYMALLOC
 #   define YYMALLOC malloc
-#   if ! defined malloc && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
 #  ifndef YYFREE
 #   define YYFREE free
-#   if ! defined free && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 void free (void *); /* INFRINGES ON USER NAME SPACE */
 #   endif
@@ -372,9 +359,9 @@ void free (void *); /* INFRINGES ON USER NAME SPACE */
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  yytype_int16 yyss_alloc;
-  YYSTYPE yyvs_alloc;
-};
+  yytype_int16 yyss;
+  YYSTYPE yyvs;
+  };
 
 /* The size of the maximum gap between one aligned stack and the next.  */
 # define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
@@ -385,27 +372,6 @@ union yyalloc
      ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
-# define YYCOPY_NEEDED 1
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
-	Stack = &yyptr->Stack_alloc;					\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (YYID (0))
-
-#endif
-
-#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
@@ -423,7 +389,24 @@ union yyalloc
       while (YYID (0))
 #  endif
 # endif
-#endif /* !YYCOPY_NEEDED */
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
 
 /* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  2
@@ -564,13 +547,13 @@ static const yytype_uint16 yyrline[] =
      166,   173,   178,   183,   190,   198,   203,   211,   216,   223,
      224,   227,   232,   242,   247,   257,   262,   267,   274,   282,
      292,   296,   303,   308,   316,   325,   336,   337,   340,   341,
-     342,   346,   350,   351,   354,   355,   358,   364,   373,   382,
-     387,   392,   397,   402,   407,   412,   418,   426,   432,   443,
-     449,   455,   461,   467,   475,   476,   479,   485,   491,   497,
-     503,   512,   521,   530,   535,   540,   548,   558,   562,   571,
-     578,   587,   590,   594,   600,   601,   605,   608,   609,   613,
-     617,   621,   625,   631,   636,   641,   646,   653,   654,   658,
-     662,   666,   670,   674,   678,   682,   686,   690
+     342,   346,   350,   351,   354,   355,   358,   364,   372,   380,
+     385,   390,   395,   400,   405,   410,   416,   424,   430,   441,
+     447,   453,   459,   465,   473,   474,   477,   483,   489,   495,
+     501,   510,   519,   528,   533,   538,   546,   556,   560,   569,
+     576,   585,   588,   592,   598,   599,   603,   606,   607,   611,
+     615,   619,   623,   629,   634,   639,   644,   651,   652,   656,
+     660,   664,   668,   672,   676,   680,   684,   688
 };
 #endif
 
@@ -586,12 +569,11 @@ static const char *const yytname[] =
   "LTYPEF", "LCONST", "LFP", "LPC", "LSB", "LBREG", "LLREG", "LSREG",
   "LFREG", "LMREG", "LXREG", "LFCONST", "LSCONST", "LSP", "LNAME", "LLAB",
   "LVAR", "':'", "';'", "'='", "','", "'('", "')'", "'$'", "'~'",
-  "$accept", "prog", "$@1", "line", "$@2", "$@3", "inst", "nonnon",
-  "rimrem", "remrim", "rimnon", "nonrem", "nonrel", "spec1", "spec2",
-  "spec3", "spec4", "spec5", "spec6", "spec7", "spec8", "spec9", "spec10",
-  "spec11", "spec12", "spec13", "rem", "rom", "rim", "rel", "reg", "imm2",
-  "imm", "mem", "omem", "nmem", "nam", "offset", "pointer", "con", "con2",
-  "expr", 0
+  "$accept", "prog", "@1", "line", "@2", "@3", "inst", "nonnon", "rimrem",
+  "remrim", "rimnon", "nonrem", "nonrel", "spec1", "spec2", "spec3",
+  "spec4", "spec5", "spec6", "spec7", "spec8", "spec9", "spec10", "spec11",
+  "spec12", "spec13", "rem", "rom", "rim", "rel", "reg", "imm2", "imm",
+  "mem", "omem", "nmem", "nam", "offset", "pointer", "con", "con2", "expr", 0
 };
 #endif
 
@@ -647,8 +629,8 @@ static const yytype_uint8 yyr2[] =
        3,     3,     3,     4,     4,     3,     3,     3
 };
 
-/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
-   Performed when YYTABLE doesn't specify something else to do.  Zero
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
 static const yytype_uint8 yydefact[] =
 {
@@ -739,7 +721,8 @@ static const yytype_int16 yypgoto[] =
 
 /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
    positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If YYTABLE_NINF, syntax error.  */
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
 #define YYTABLE_NINF -1
 static const yytype_uint16 yytable[] =
 {
@@ -802,12 +785,6 @@ static const yytype_uint16 yytable[] =
      177
 };
 
-#define yypact_value_is_default(yystate) \
-  ((yystate) == (-94))
-
-#define yytable_value_is_error(yytable_value) \
-  YYID (0)
-
 static const yytype_int16 yycheck[] =
 {
       10,    10,    13,    13,    10,    13,    66,    67,    10,    10,
@@ -915,18 +892,9 @@ static const yytype_uint8 yystos[] =
 
 /* Like YYERROR except do call yyerror.  This remains here temporarily
    to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  However,
-   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
-   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
-   discussed.  */
+   Once GCC version 2 has supplanted version 1, this can go.  */
 
 #define YYFAIL		goto yyerrlab
-#if defined YYFAIL
-  /* This is here to suppress warnings from the GCC cpp's
-     -Wunused-macros.  Normally we don't worry about that warning, but
-     some users do, and we want to make it easy for users to remove
-     YYFAIL uses, which will produce warnings from Bison 2.5.  */
-#endif
 
 #define YYRECOVERING()  (!!yyerrstatus)
 
@@ -936,6 +904,7 @@ do								\
     {								\
       yychar = (Token);						\
       yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
       YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
@@ -977,10 +946,19 @@ while (YYID (0))
 #endif
 
 
-/* This macro is provided for backward compatibility. */
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
 
 #ifndef YY_LOCATION_PRINT
-# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
 #endif
 
 
@@ -1084,20 +1062,17 @@ yy_symbol_print (yyoutput, yytype, yyvaluep)
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 static void
-yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
 #else
 static void
-yy_stack_print (yybottom, yytop)
-    yytype_int16 *yybottom;
-    yytype_int16 *yytop;
+yy_stack_print (bottom, top)
+    yytype_int16 *bottom;
+    yytype_int16 *top;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (; yybottom <= yytop; yybottom++)
-    {
-      int yybot = *yybottom;
-      YYFPRINTF (stderr, " %d", yybot);
-    }
+  for (; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
   YYFPRINTF (stderr, "\n");
 }
 
@@ -1131,11 +1106,11 @@ yy_reduce_print (yyvsp, yyrule)
   /* The symbols being reduced.  */
   for (yyi = 0; yyi < yynrhs; yyi++)
     {
-      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      fprintf (stderr, "   $%d = ", yyi + 1);
       yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
 		       &(yyvsp[(yyi + 1) - (yynrhs)])
 		       		       );
-      YYFPRINTF (stderr, "\n");
+      fprintf (stderr, "\n");
     }
 }
 
@@ -1172,6 +1147,7 @@ int yydebug;
 # define YYMAXDEPTH 10000
 #endif
 
+
 
 #if YYERROR_VERBOSE
 
@@ -1274,142 +1250,115 @@ yytnamerr (char *yyres, const char *yystr)
 }
 # endif
 
-/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
-   about the unexpected token YYTOKEN for the state stack whose top is
-   YYSSP.
-
-   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
-   not large enough to hold the message.  In that case, also set
-   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
-   required number of bytes is too large to store.  */
-static int
-yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
-                yytype_int16 *yyssp, int yytoken)
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
 {
-  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytoken]);
-  YYSIZE_T yysize = yysize0;
-  YYSIZE_T yysize1;
-  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-  /* Internationalized format string. */
-  const char *yyformat = 0;
-  /* Arguments of yyformat. */
-  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-  /* Number of reported tokens (one for the "unexpected", one per
-     "expected"). */
-  int yycount = 0;
-
-  /* There are many possibilities here to consider:
-     - Assume YYFAIL is not used.  It's too flawed to consider.  See
-       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
-       for details.  YYERROR is fine as it does not invoke this
-       function.
-     - If this state is a consistent state with a default action, then
-       the only way this function was invoked is if the default action
-       is an error action.  In that case, don't check for expected
-       tokens because there are none.
-     - The only way there can be no lookahead present (in yychar) is if
-       this state is a consistent state with a default action.  Thus,
-       detecting the absence of a lookahead is sufficient to determine
-       that there is no unexpected or expected token to report.  In that
-       case, just report a simple "syntax error".
-     - Don't assume there isn't a lookahead just because this state is a
-       consistent state with a default action.  There might have been a
-       previous inconsistent state, consistent state with a non-default
-       action, or user semantic action that manipulated yychar.
-     - Of course, the expected token list depends on states to have
-       correct lookahead information, and it depends on the parser not
-       to perform extra reductions after fetching a lookahead from the
-       scanner and before detecting a syntax error.  Thus, state merging
-       (from LALR or IELR) and default reductions corrupt the expected
-       token list.  However, the list is correct for canonical LR with
-       one exception: it will still contain any token that will not be
-       accepted due to an error action in a later state.
-  */
-  if (yytoken != YYEMPTY)
-    {
-      int yyn = yypact[*yyssp];
-      yyarg[yycount++] = yytname[yytoken];
-      if (!yypact_value_is_default (yyn))
-        {
-          /* Start YYX at -YYN if negative to avoid negative indexes in
-             YYCHECK.  In other words, skip the first -YYN actions for
-             this state because they are default actions.  */
-          int yyxbegin = yyn < 0 ? -yyn : 0;
-          /* Stay within bounds of both yycheck and yytname.  */
-          int yychecklim = YYLAST - yyn + 1;
-          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-          int yyx;
-
-          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
-                && !yytable_value_is_error (yytable[yyx + yyn]))
-              {
-                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-                  {
-                    yycount = 1;
-                    yysize = yysize0;
-                    break;
-                  }
-                yyarg[yycount++] = yytname[yyx];
-                yysize1 = yysize + yytnamerr (0, yytname[yyx]);
-                if (! (yysize <= yysize1
-                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-                  return 2;
-                yysize = yysize1;
-              }
-        }
-    }
+  int yyn = yypact[yystate];
 
-  switch (yycount)
-    {
-# define YYCASE_(N, S)                      \
-      case N:                               \
-        yyformat = S;                       \
-      break
-      YYCASE_(0, YY_("syntax error"));
-      YYCASE_(1, YY_("syntax error, unexpected %s"));
-      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
-      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
-      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
-      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
-# undef YYCASE_
-    }
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
 
-  yysize1 = yysize + yystrlen (yyformat);
-  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-    return 2;
-  yysize = yysize1;
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
 
-  if (*yymsg_alloc < yysize)
-    {
-      *yymsg_alloc = 2 * yysize;
-      if (! (yysize <= *yymsg_alloc
-             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
-        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
-      return 1;
-    }
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
 
-  /* Avoid sprintf, as that infringes on the user's name space.
-     Don't have undefined behavior even if the translation
-     produced a string with the wrong number of "%s"s.  */
-  {
-    char *yyp = *yymsg;
-    int yyi = 0;
-    while ((*yyp = *yyformat) != '\0')
-      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
-        {
-          yyp += yytnamerr (yyp, yyarg[yyi++]);
-          yyformat += 2;
-        }
-      else
-        {
-          yyp++;
-          yyformat++;
-        }
-  }
-  return 0;
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
 }
 #endif /* YYERROR_VERBOSE */
+
 
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
@@ -1441,9 +1390,10 @@ yydestruct (yymsg, yytype, yyvaluep)
 	break;
     }
 }
-
+
 
 /* Prevent warnings from -Wmissing-prototypes.  */
+
 #ifdef YYPARSE_PARAM
 #if defined __STDC__ || defined __cplusplus
 int yyparse (void *YYPARSE_PARAM);
@@ -1459,16 +1409,18 @@ int yyparse ();
 #endif /* ! YYPARSE_PARAM */
 
 
-/* The lookahead symbol.  */
+
+/* The look-ahead symbol.  */
 int yychar;
 
-/* The semantic value of the lookahead symbol.  */
+/* The semantic value of the look-ahead symbol.  */
 YYSTYPE yylval;
 
 /* Number of syntax errors so far.  */
 int yynerrs;
 
 
+
 /*----------.
 | yyparse.  |
 `----------*/
@@ -1495,37 +1447,14 @@ yyparse ()
 #endif
 #endif
 {
-    int yystate;
-    /* Number of tokens to shift before error messages enabled.  */
-    int yyerrstatus;
-
-    /* The stacks and their tools:
-       `yyss': related to states.
-       `yyvs': related to semantic values.
-
-       Refer to the stacks thru separate pointers, to allow yyoverflow
-       to reallocate them elsewhere.  */
-
-    /* The state stack.  */
-    yytype_int16 yyssa[YYINITDEPTH];
-    yytype_int16 *yyss;
-    yytype_int16 *yyssp;
-
-    /* The semantic value stack.  */
-    YYSTYPE yyvsa[YYINITDEPTH];
-    YYSTYPE *yyvs;
-    YYSTYPE *yyvsp;
-
-    YYSIZE_T yystacksize;
-
+  
+  int yystate;
   int yyn;
   int yyresult;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken;
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
 #if YYERROR_VERBOSE
   /* Buffer for error messages, and its allocated size.  */
   char yymsgbuf[128];
@@ -1533,28 +1462,51 @@ yyparse ()
   YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
 #endif
 
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  YYSTYPE *yyvsp;
+
+
+
 #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
   /* The number of symbols on the RHS of the reduced rule.
      Keep to zero when no symbol should be popped.  */
   int yylen = 0;
 
-  yytoken = 0;
-  yyss = yyssa;
-  yyvs = yyvsa;
-  yystacksize = YYINITDEPTH;
-
   YYDPRINTF ((stderr, "Starting parse\n"));
 
   yystate = 0;
   yyerrstatus = 0;
   yynerrs = 0;
-  yychar = YYEMPTY; /* Cause a token to be read.  */
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
 
   /* Initialize stack pointers.
      Waste one element of value and location stack
      so that they stay on the same level as the state stack.
      The wasted elements are never initialized.  */
+
   yyssp = yyss;
   yyvsp = yyvs;
 
@@ -1584,6 +1536,7 @@ yyparse ()
 	YYSTYPE *yyvs1 = yyvs;
 	yytype_int16 *yyss1 = yyss;
 
+
 	/* Each stack pointer address is followed by the size of the
 	   data in use in that stack, in bytes.  This used to be a
 	   conditional around just the two extra args, but that might
@@ -1591,6 +1544,7 @@ yyparse ()
 	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
+
 		    &yystacksize);
 
 	yyss = yyss1;
@@ -1613,8 +1567,9 @@ yyparse ()
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
 	  goto yyexhaustedlab;
-	YYSTACK_RELOCATE (yyss_alloc, yyss);
-	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
 #  undef YYSTACK_RELOCATE
 	if (yyss1 != yyssa)
 	  YYSTACK_FREE (yyss1);
@@ -1625,6 +1580,7 @@ yyparse ()
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
 
+
       YYDPRINTF ((stderr, "Stack size increased to %lu\n",
 		  (unsigned long int) yystacksize));
 
@@ -1634,9 +1590,6 @@ yyparse ()
 
   YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
-  if (yystate == YYFINAL)
-    YYACCEPT;
-
   goto yybackup;
 
 /*-----------.
@@ -1645,16 +1598,16 @@ yyparse ()
 yybackup:
 
   /* Do appropriate processing given the current state.  Read a
-     lookahead token if we need one and don't already have one.  */
+     look-ahead token if we need one and don't already have one.  */
 
-  /* First try to decide what to do without reference to lookahead token.  */
+  /* First try to decide what to do without reference to look-ahead token.  */
   yyn = yypact[yystate];
-  if (yypact_value_is_default (yyn))
+  if (yyn == YYPACT_NINF)
     goto yydefault;
 
-  /* Not known => get a lookahead token if don't already have one.  */
+  /* Not known => get a look-ahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
@@ -1680,22 +1633,26 @@ yybackup:
   yyn = yytable[yyn];
   if (yyn <= 0)
     {
-      if (yytable_value_is_error (yyn))
-        goto yyerrlab;
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
 
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
-  /* Shift the lookahead token.  */
+  /* Shift the look-ahead token.  */
   YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
 
-  /* Discard the shifted token.  */
-  yychar = YYEMPTY;
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
 
   yystate = yyn;
   *++yyvsp = yylval;
@@ -1735,8 +1692,6 @@ yyreduce:
   switch (yyn)
     {
         case 3:
-
-/* Line 1806 of yacc.c  */
 #line 68 "a.y"
     {
 		stmtline = lineno;
@@ -1744,8 +1699,6 @@ yyreduce:
     break;
 
   case 5:
-
-/* Line 1806 of yacc.c  */
 #line 75 "a.y"
     {
 		if((yyvsp[(1) - (2)].sym)->value != pc)
@@ -1755,8 +1708,6 @@ yyreduce:
     break;
 
   case 7:
-
-/* Line 1806 of yacc.c  */
 #line 82 "a.y"
     {
 		(yyvsp[(1) - (2)].sym)->type = LLAB;
@@ -1765,8 +1716,6 @@ yyreduce:
     break;
 
   case 12:
-
-/* Line 1806 of yacc.c  */
 #line 93 "a.y"
     {
 		(yyvsp[(1) - (3)].sym)->type = LVAR;
@@ -1775,8 +1724,6 @@ yyreduce:
     break;
 
   case 13:
-
-/* Line 1806 of yacc.c  */
 #line 98 "a.y"
     {
 		if((yyvsp[(1) - (3)].sym)->value != (yyvsp[(3) - (3)].lval))
@@ -1786,622 +1733,490 @@ yyreduce:
     break;
 
   case 14:
-
-/* Line 1806 of yacc.c  */
 #line 103 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 15:
-
-/* Line 1806 of yacc.c  */
 #line 104 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 16:
-
-/* Line 1806 of yacc.c  */
 #line 105 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 17:
-
-/* Line 1806 of yacc.c  */
 #line 106 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 18:
-
-/* Line 1806 of yacc.c  */
 #line 107 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 19:
-
-/* Line 1806 of yacc.c  */
 #line 108 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 20:
-
-/* Line 1806 of yacc.c  */
 #line 109 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 21:
-
-/* Line 1806 of yacc.c  */
 #line 110 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 22:
-
-/* Line 1806 of yacc.c  */
 #line 111 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 23:
-
-/* Line 1806 of yacc.c  */
 #line 112 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 24:
-
-/* Line 1806 of yacc.c  */
 #line 113 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 25:
-
-/* Line 1806 of yacc.c  */
 #line 114 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 26:
-
-/* Line 1806 of yacc.c  */
 #line 115 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 27:
-
-/* Line 1806 of yacc.c  */
 #line 116 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 28:
-
-/* Line 1806 of yacc.c  */
 #line 117 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 29:
-
-/* Line 1806 of yacc.c  */
 #line 118 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 30:
-
-/* Line 1806 of yacc.c  */
 #line 119 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 31:
-
-/* Line 1806 of yacc.c  */
 #line 120 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 32:
-
-/* Line 1806 of yacc.c  */
 #line 121 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 33:
-
-/* Line 1806 of yacc.c  */
 #line 124 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = nullgen;
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = nullgen;
 	}
     break;
 
   case 34:
-
-/* Line 1806 of yacc.c  */
 #line 129 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = nullgen;
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = nullgen;
 	}
     break;
 
   case 35:
-
-/* Line 1806 of yacc.c  */
 #line 136 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 36:
-
-/* Line 1806 of yacc.c  */
 #line 143 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 37:
-
-/* Line 1806 of yacc.c  */
 #line 150 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (2)].gen);
-		(yyval.gen2).to = nullgen;
+		(yyval.addr2).from = (yyvsp[(1) - (2)].addr);
+		(yyval.addr2).to = nullgen;
 	}
     break;
 
   case 38:
-
-/* Line 1806 of yacc.c  */
 #line 155 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (1)].gen);
-		(yyval.gen2).to = nullgen;
+		(yyval.addr2).from = (yyvsp[(1) - (1)].addr);
+		(yyval.addr2).to = nullgen;
 	}
     break;
 
   case 39:
-
-/* Line 1806 of yacc.c  */
 #line 162 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = (yyvsp[(2) - (2)].gen);
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = (yyvsp[(2) - (2)].addr);
 	}
     break;
 
   case 40:
-
-/* Line 1806 of yacc.c  */
 #line 167 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = (yyvsp[(1) - (1)].gen);
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = (yyvsp[(1) - (1)].addr);
 	}
     break;
 
   case 41:
-
-/* Line 1806 of yacc.c  */
 #line 174 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = (yyvsp[(2) - (2)].gen);
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = (yyvsp[(2) - (2)].addr);
 	}
     break;
 
   case 42:
-
-/* Line 1806 of yacc.c  */
 #line 179 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = (yyvsp[(1) - (1)].gen);
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = (yyvsp[(1) - (1)].addr);
 	}
     break;
 
   case 43:
-
-/* Line 1806 of yacc.c  */
 #line 184 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 44:
-
-/* Line 1806 of yacc.c  */
 #line 191 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (5)].gen);
-		(yyval.gen2).from.scale = (yyvsp[(3) - (5)].lval);
-		(yyval.gen2).to = (yyvsp[(5) - (5)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (5)].addr);
+		(yyval.addr2).from.scale = (yyvsp[(3) - (5)].lval);
+		(yyval.addr2).to = (yyvsp[(5) - (5)].addr);
 	}
     break;
 
   case 45:
-
-/* Line 1806 of yacc.c  */
 #line 199 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 46:
-
-/* Line 1806 of yacc.c  */
 #line 204 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (5)].gen);
-		(yyval.gen2).from.scale = (yyvsp[(3) - (5)].lval);
-		(yyval.gen2).to = (yyvsp[(5) - (5)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (5)].addr);
+		(yyval.addr2).from.scale = (yyvsp[(3) - (5)].lval);
+		(yyval.addr2).to = (yyvsp[(5) - (5)].addr);
 	}
     break;
 
   case 47:
-
-/* Line 1806 of yacc.c  */
 #line 212 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = (yyvsp[(2) - (2)].gen);
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = (yyvsp[(2) - (2)].addr);
 	}
     break;
 
   case 48:
-
-/* Line 1806 of yacc.c  */
 #line 217 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = (yyvsp[(1) - (1)].gen);
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = (yyvsp[(1) - (1)].addr);
 	}
     break;
 
   case 51:
-
-/* Line 1806 of yacc.c  */
 #line 228 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 52:
-
-/* Line 1806 of yacc.c  */
 #line 233 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (5)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (5)].gen);
-		if((yyval.gen2).from.index != D_NONE)
+		(yyval.addr2).from = (yyvsp[(1) - (5)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (5)].addr);
+		if((yyval.addr2).from.index != D_NONE)
 			yyerror("dp shift with lhs index");
-		(yyval.gen2).from.index = (yyvsp[(5) - (5)].lval);
+		(yyval.addr2).from.index = (yyvsp[(5) - (5)].lval);
 	}
     break;
 
   case 53:
-
-/* Line 1806 of yacc.c  */
 #line 243 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 54:
-
-/* Line 1806 of yacc.c  */
 #line 248 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (5)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (5)].gen);
-		if((yyval.gen2).to.index != D_NONE)
+		(yyval.addr2).from = (yyvsp[(1) - (5)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (5)].addr);
+		if((yyval.addr2).to.index != D_NONE)
 			yyerror("dp move with lhs index");
-		(yyval.gen2).to.index = (yyvsp[(5) - (5)].lval);
+		(yyval.addr2).to.index = (yyvsp[(5) - (5)].lval);
 	}
     break;
 
   case 55:
-
-/* Line 1806 of yacc.c  */
 #line 258 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (2)].gen);
-		(yyval.gen2).to = nullgen;
+		(yyval.addr2).from = (yyvsp[(1) - (2)].addr);
+		(yyval.addr2).to = nullgen;
 	}
     break;
 
   case 56:
-
-/* Line 1806 of yacc.c  */
 #line 263 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (1)].gen);
-		(yyval.gen2).to = nullgen;
+		(yyval.addr2).from = (yyvsp[(1) - (1)].addr);
+		(yyval.addr2).to = nullgen;
 	}
     break;
 
   case 57:
-
-/* Line 1806 of yacc.c  */
 #line 268 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 58:
-
-/* Line 1806 of yacc.c  */
 #line 275 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (5)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (5)].gen);
-		(yyval.gen2).to.offset = (yyvsp[(5) - (5)].lval);
+		(yyval.addr2).from = (yyvsp[(1) - (5)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (5)].addr);
+		(yyval.addr2).to.offset = (yyvsp[(5) - (5)].lval);
 	}
     break;
 
   case 59:
-
-/* Line 1806 of yacc.c  */
 #line 283 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(3) - (5)].gen);
-		(yyval.gen2).to = (yyvsp[(5) - (5)].gen);
-		if((yyvsp[(1) - (5)].gen).type != D_CONST)
+		(yyval.addr2).from = (yyvsp[(3) - (5)].addr);
+		(yyval.addr2).to = (yyvsp[(5) - (5)].addr);
+		if((yyvsp[(1) - (5)].addr).type != D_CONST)
 			yyerror("illegal constant");
-		(yyval.gen2).to.offset = (yyvsp[(1) - (5)].gen).offset;
+		(yyval.addr2).to.offset = (yyvsp[(1) - (5)].addr).offset;
 	}
     break;
 
   case 60:
-
-/* Line 1806 of yacc.c  */
 #line 292 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = nullgen;
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = nullgen;
 	}
     break;
 
   case 61:
-
-/* Line 1806 of yacc.c  */
 #line 297 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (1)].gen);
-		(yyval.gen2).to = nullgen;
+		(yyval.addr2).from = (yyvsp[(1) - (1)].addr);
+		(yyval.addr2).to = nullgen;
 	}
     break;
 
   case 62:
-
-/* Line 1806 of yacc.c  */
 #line 304 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 63:
-
-/* Line 1806 of yacc.c  */
 #line 309 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (5)].gen);
-		(yyval.gen2).from.scale = (yyvsp[(3) - (5)].lval);
-		(yyval.gen2).to = (yyvsp[(5) - (5)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (5)].addr);
+		(yyval.addr2).from.scale = (yyvsp[(3) - (5)].lval);
+		(yyval.addr2).to = (yyvsp[(5) - (5)].addr);
 	}
     break;
 
   case 64:
-
-/* Line 1806 of yacc.c  */
 #line 317 "a.y"
     {
-		if((yyvsp[(1) - (3)].gen).type != D_CONST || (yyvsp[(3) - (3)].gen).type != D_CONST)
+		if((yyvsp[(1) - (3)].addr).type != D_CONST || (yyvsp[(3) - (3)].addr).type != D_CONST)
 			yyerror("arguments to PCDATA must be integer constants");
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 65:
-
-/* Line 1806 of yacc.c  */
 #line 326 "a.y"
     {
-		if((yyvsp[(1) - (3)].gen).type != D_CONST)
+		if((yyvsp[(1) - (3)].addr).type != D_CONST)
 			yyerror("index for FUNCDATA must be integer constant");
-		if((yyvsp[(3) - (3)].gen).type != D_EXTERN && (yyvsp[(3) - (3)].gen).type != D_STATIC)
+		if((yyvsp[(3) - (3)].addr).type != D_EXTERN && (yyvsp[(3) - (3)].addr).type != D_STATIC)
 			yyerror("value for FUNCDATA must be symbol reference");
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 70:
-
-/* Line 1806 of yacc.c  */
 #line 343 "a.y"
     {
-		(yyval.gen) = (yyvsp[(2) - (2)].gen);
+		(yyval.addr) = (yyvsp[(2) - (2)].addr);
 	}
     break;
 
   case 71:
-
-/* Line 1806 of yacc.c  */
 #line 347 "a.y"
     {
-		(yyval.gen) = (yyvsp[(2) - (2)].gen);
+		(yyval.addr) = (yyvsp[(2) - (2)].addr);
 	}
     break;
 
   case 76:
-
-/* Line 1806 of yacc.c  */
 #line 359 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_BRANCH;
-		(yyval.gen).offset = (yyvsp[(1) - (4)].lval) + pc;
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_BRANCH;
+		(yyval.addr).offset = (yyvsp[(1) - (4)].lval) + pc;
 	}
     break;
 
   case 77:
-
-/* Line 1806 of yacc.c  */
 #line 365 "a.y"
     {
-		(yyval.gen) = nullgen;
+		(yyval.addr) = nullgen;
 		if(pass == 2)
 			yyerror("undefined label: %s", (yyvsp[(1) - (2)].sym)->name);
-		(yyval.gen).type = D_BRANCH;
-		(yyval.gen).sym = (yyvsp[(1) - (2)].sym);
-		(yyval.gen).offset = (yyvsp[(2) - (2)].lval);
+		(yyval.addr).type = D_BRANCH;
+		(yyval.addr).offset = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 78:
-
-/* Line 1806 of yacc.c  */
-#line 374 "a.y"
+#line 373 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_BRANCH;
-		(yyval.gen).sym = (yyvsp[(1) - (2)].sym);
-		(yyval.gen).offset = (yyvsp[(1) - (2)].sym)->value + (yyvsp[(2) - (2)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_BRANCH;
+		(yyval.addr).offset = (yyvsp[(1) - (2)].sym)->value + (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 79:
-
-/* Line 1806 of yacc.c  */
-#line 383 "a.y"
+#line 381 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 80:
-
-/* Line 1806 of yacc.c  */
-#line 388 "a.y"
+#line 386 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 81:
-
-/* Line 1806 of yacc.c  */
-#line 393 "a.y"
+#line 391 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 82:
-
-/* Line 1806 of yacc.c  */
-#line 398 "a.y"
+#line 396 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 83:
-
-/* Line 1806 of yacc.c  */
-#line 403 "a.y"
+#line 401 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_SP;
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_SP;
 	}
     break;
 
   case 84:
-
-/* Line 1806 of yacc.c  */
-#line 408 "a.y"
+#line 406 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 85:
-
-/* Line 1806 of yacc.c  */
-#line 413 "a.y"
+#line 411 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 86:
-
-/* Line 1806 of yacc.c  */
-#line 419 "a.y"
+#line 417 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_CONST;
-		(yyval.gen).offset = (yyvsp[(2) - (2)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_CONST;
+		(yyval.addr).offset = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 87:
-
-/* Line 1806 of yacc.c  */
-#line 427 "a.y"
+#line 425 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_CONST;
-		(yyval.gen).offset = (yyvsp[(2) - (2)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_CONST;
+		(yyval.addr).offset = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 88:
-
-/* Line 1806 of yacc.c  */
-#line 433 "a.y"
+#line 431 "a.y"
     {
-		(yyval.gen) = (yyvsp[(2) - (2)].gen);
-		(yyval.gen).index = (yyvsp[(2) - (2)].gen).type;
-		(yyval.gen).type = D_ADDR;
+		(yyval.addr) = (yyvsp[(2) - (2)].addr);
+		(yyval.addr).index = (yyvsp[(2) - (2)].addr).type;
+		(yyval.addr).type = D_ADDR;
 		/*
 		if($2.type == D_AUTO || $2.type == D_PARAM)
 			yyerror("constant cannot be automatic: %s",
@@ -2411,322 +2226,262 @@ yyreduce:
     break;
 
   case 89:
-
-/* Line 1806 of yacc.c  */
-#line 444 "a.y"
+#line 442 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_SCONST;
-		memcpy((yyval.gen).sval, (yyvsp[(2) - (2)].sval), sizeof((yyval.gen).sval));
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_SCONST;
+		memcpy((yyval.addr).u.sval, (yyvsp[(2) - (2)].sval), sizeof((yyval.addr).u.sval));
 	}
     break;
 
   case 90:
-
-/* Line 1806 of yacc.c  */
-#line 450 "a.y"
+#line 448 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_FCONST;
-		(yyval.gen).dval = (yyvsp[(2) - (2)].dval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_FCONST;
+		(yyval.addr).u.dval = (yyvsp[(2) - (2)].dval);
 	}
     break;
 
   case 91:
-
-/* Line 1806 of yacc.c  */
-#line 456 "a.y"
+#line 454 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_FCONST;
-		(yyval.gen).dval = (yyvsp[(3) - (4)].dval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_FCONST;
+		(yyval.addr).u.dval = (yyvsp[(3) - (4)].dval);
 	}
     break;
 
   case 92:
-
-/* Line 1806 of yacc.c  */
-#line 462 "a.y"
+#line 460 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_FCONST;
-		(yyval.gen).dval = -(yyvsp[(4) - (5)].dval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_FCONST;
+		(yyval.addr).u.dval = -(yyvsp[(4) - (5)].dval);
 	}
     break;
 
   case 93:
-
-/* Line 1806 of yacc.c  */
-#line 468 "a.y"
+#line 466 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_FCONST;
-		(yyval.gen).dval = -(yyvsp[(3) - (3)].dval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_FCONST;
+		(yyval.addr).u.dval = -(yyvsp[(3) - (3)].dval);
 	}
     break;
 
   case 96:
-
-/* Line 1806 of yacc.c  */
-#line 480 "a.y"
+#line 478 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+D_NONE;
-		(yyval.gen).offset = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+D_NONE;
+		(yyval.addr).offset = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 97:
-
-/* Line 1806 of yacc.c  */
-#line 486 "a.y"
+#line 484 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+(yyvsp[(3) - (4)].lval);
-		(yyval.gen).offset = (yyvsp[(1) - (4)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+(yyvsp[(3) - (4)].lval);
+		(yyval.addr).offset = (yyvsp[(1) - (4)].lval);
 	}
     break;
 
   case 98:
-
-/* Line 1806 of yacc.c  */
-#line 492 "a.y"
+#line 490 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+D_SP;
-		(yyval.gen).offset = (yyvsp[(1) - (4)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+D_SP;
+		(yyval.addr).offset = (yyvsp[(1) - (4)].lval);
 	}
     break;
 
   case 99:
-
-/* Line 1806 of yacc.c  */
-#line 498 "a.y"
+#line 496 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+(yyvsp[(3) - (4)].lval);
-		(yyval.gen).offset = (yyvsp[(1) - (4)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+(yyvsp[(3) - (4)].lval);
+		(yyval.addr).offset = (yyvsp[(1) - (4)].lval);
 	}
     break;
 
   case 100:
-
-/* Line 1806 of yacc.c  */
-#line 504 "a.y"
+#line 502 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+D_NONE;
-		(yyval.gen).offset = (yyvsp[(1) - (6)].lval);
-		(yyval.gen).index = (yyvsp[(3) - (6)].lval);
-		(yyval.gen).scale = (yyvsp[(5) - (6)].lval);
-		checkscale((yyval.gen).scale);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+D_NONE;
+		(yyval.addr).offset = (yyvsp[(1) - (6)].lval);
+		(yyval.addr).index = (yyvsp[(3) - (6)].lval);
+		(yyval.addr).scale = (yyvsp[(5) - (6)].lval);
+		checkscale((yyval.addr).scale);
 	}
     break;
 
   case 101:
-
-/* Line 1806 of yacc.c  */
-#line 513 "a.y"
+#line 511 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+(yyvsp[(3) - (9)].lval);
-		(yyval.gen).offset = (yyvsp[(1) - (9)].lval);
-		(yyval.gen).index = (yyvsp[(6) - (9)].lval);
-		(yyval.gen).scale = (yyvsp[(8) - (9)].lval);
-		checkscale((yyval.gen).scale);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+(yyvsp[(3) - (9)].lval);
+		(yyval.addr).offset = (yyvsp[(1) - (9)].lval);
+		(yyval.addr).index = (yyvsp[(6) - (9)].lval);
+		(yyval.addr).scale = (yyvsp[(8) - (9)].lval);
+		checkscale((yyval.addr).scale);
 	}
     break;
 
   case 102:
-
-/* Line 1806 of yacc.c  */
-#line 522 "a.y"
+#line 520 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+(yyvsp[(3) - (9)].lval);
-		(yyval.gen).offset = (yyvsp[(1) - (9)].lval);
-		(yyval.gen).index = (yyvsp[(6) - (9)].lval);
-		(yyval.gen).scale = (yyvsp[(8) - (9)].lval);
-		checkscale((yyval.gen).scale);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+(yyvsp[(3) - (9)].lval);
+		(yyval.addr).offset = (yyvsp[(1) - (9)].lval);
+		(yyval.addr).index = (yyvsp[(6) - (9)].lval);
+		(yyval.addr).scale = (yyvsp[(8) - (9)].lval);
+		checkscale((yyval.addr).scale);
 	}
     break;
 
   case 103:
-
-/* Line 1806 of yacc.c  */
-#line 531 "a.y"
+#line 529 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+(yyvsp[(2) - (3)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+(yyvsp[(2) - (3)].lval);
 	}
     break;
 
   case 104:
-
-/* Line 1806 of yacc.c  */
-#line 536 "a.y"
+#line 534 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+D_SP;
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+D_SP;
 	}
     break;
 
   case 105:
-
-/* Line 1806 of yacc.c  */
-#line 541 "a.y"
+#line 539 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+D_NONE;
-		(yyval.gen).index = (yyvsp[(2) - (5)].lval);
-		(yyval.gen).scale = (yyvsp[(4) - (5)].lval);
-		checkscale((yyval.gen).scale);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+D_NONE;
+		(yyval.addr).index = (yyvsp[(2) - (5)].lval);
+		(yyval.addr).scale = (yyvsp[(4) - (5)].lval);
+		checkscale((yyval.addr).scale);
 	}
     break;
 
   case 106:
-
-/* Line 1806 of yacc.c  */
-#line 549 "a.y"
+#line 547 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+(yyvsp[(2) - (8)].lval);
-		(yyval.gen).index = (yyvsp[(5) - (8)].lval);
-		(yyval.gen).scale = (yyvsp[(7) - (8)].lval);
-		checkscale((yyval.gen).scale);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+(yyvsp[(2) - (8)].lval);
+		(yyval.addr).index = (yyvsp[(5) - (8)].lval);
+		(yyval.addr).scale = (yyvsp[(7) - (8)].lval);
+		checkscale((yyval.addr).scale);
 	}
     break;
 
   case 107:
-
-/* Line 1806 of yacc.c  */
-#line 559 "a.y"
+#line 557 "a.y"
     {
-		(yyval.gen) = (yyvsp[(1) - (1)].gen);
+		(yyval.addr) = (yyvsp[(1) - (1)].addr);
 	}
     break;
 
   case 108:
-
-/* Line 1806 of yacc.c  */
-#line 563 "a.y"
+#line 561 "a.y"
     {
-		(yyval.gen) = (yyvsp[(1) - (6)].gen);
-		(yyval.gen).index = (yyvsp[(3) - (6)].lval);
-		(yyval.gen).scale = (yyvsp[(5) - (6)].lval);
-		checkscale((yyval.gen).scale);
+		(yyval.addr) = (yyvsp[(1) - (6)].addr);
+		(yyval.addr).index = (yyvsp[(3) - (6)].lval);
+		(yyval.addr).scale = (yyvsp[(5) - (6)].lval);
+		checkscale((yyval.addr).scale);
 	}
     break;
 
   case 109:
-
-/* Line 1806 of yacc.c  */
-#line 572 "a.y"
+#line 570 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = (yyvsp[(4) - (5)].lval);
-		(yyval.gen).sym = (yyvsp[(1) - (5)].sym);
-		(yyval.gen).offset = (yyvsp[(2) - (5)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = (yyvsp[(4) - (5)].lval);
+		(yyval.addr).sym = linklookup(ctxt, (yyvsp[(1) - (5)].sym)->name, 0);
+		(yyval.addr).offset = (yyvsp[(2) - (5)].lval);
 	}
     break;
 
   case 110:
-
-/* Line 1806 of yacc.c  */
-#line 579 "a.y"
+#line 577 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_STATIC;
-		(yyval.gen).sym = (yyvsp[(1) - (7)].sym);
-		(yyval.gen).offset = (yyvsp[(4) - (7)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_STATIC;
+		(yyval.addr).sym = linklookup(ctxt, (yyvsp[(1) - (7)].sym)->name, 1);
+		(yyval.addr).offset = (yyvsp[(4) - (7)].lval);
 	}
     break;
 
   case 111:
-
-/* Line 1806 of yacc.c  */
-#line 587 "a.y"
+#line 585 "a.y"
     {
 		(yyval.lval) = 0;
 	}
     break;
 
   case 112:
-
-/* Line 1806 of yacc.c  */
-#line 591 "a.y"
+#line 589 "a.y"
     {
 		(yyval.lval) = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 113:
-
-/* Line 1806 of yacc.c  */
-#line 595 "a.y"
+#line 593 "a.y"
     {
 		(yyval.lval) = -(yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 115:
-
-/* Line 1806 of yacc.c  */
-#line 602 "a.y"
+#line 600 "a.y"
     {
 		(yyval.lval) = D_AUTO;
 	}
     break;
 
   case 118:
-
-/* Line 1806 of yacc.c  */
-#line 610 "a.y"
+#line 608 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (1)].sym)->value;
 	}
     break;
 
   case 119:
-
-/* Line 1806 of yacc.c  */
-#line 614 "a.y"
+#line 612 "a.y"
     {
 		(yyval.lval) = -(yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 120:
-
-/* Line 1806 of yacc.c  */
-#line 618 "a.y"
+#line 616 "a.y"
     {
 		(yyval.lval) = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 121:
-
-/* Line 1806 of yacc.c  */
-#line 622 "a.y"
+#line 620 "a.y"
     {
 		(yyval.lval) = ~(yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 122:
-
-/* Line 1806 of yacc.c  */
-#line 626 "a.y"
+#line 624 "a.y"
     {
 		(yyval.lval) = (yyvsp[(2) - (3)].lval);
 	}
     break;
 
   case 123:
-
-/* Line 1806 of yacc.c  */
-#line 632 "a.y"
+#line 630 "a.y"
     {
 		(yyval.lval) = ((yyvsp[(1) - (1)].lval) & 0xffffffffLL) +
 			((vlong)ArgsSizeUnknown << 32);
@@ -2734,9 +2489,7 @@ yyreduce:
     break;
 
   case 124:
-
-/* Line 1806 of yacc.c  */
-#line 637 "a.y"
+#line 635 "a.y"
     {
 		(yyval.lval) = (-(yyvsp[(2) - (2)].lval) & 0xffffffffLL) +
 			((vlong)ArgsSizeUnknown << 32);
@@ -2744,9 +2497,7 @@ yyreduce:
     break;
 
   case 125:
-
-/* Line 1806 of yacc.c  */
-#line 642 "a.y"
+#line 640 "a.y"
     {
 		(yyval.lval) = ((yyvsp[(1) - (3)].lval) & 0xffffffffLL) +
 			(((yyvsp[(3) - (3)].lval) & 0xffffLL) << 32);
@@ -2754,9 +2505,7 @@ yyreduce:
     break;
 
   case 126:
-
-/* Line 1806 of yacc.c  */
-#line 647 "a.y"
+#line 645 "a.y"
     {
 		(yyval.lval) = (-(yyvsp[(2) - (4)].lval) & 0xffffffffLL) +
 			(((yyvsp[(4) - (4)].lval) & 0xffffLL) << 32);
@@ -2764,112 +2513,80 @@ yyreduce:
     break;
 
   case 128:
-
-/* Line 1806 of yacc.c  */
-#line 655 "a.y"
+#line 653 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) + (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 129:
-
-/* Line 1806 of yacc.c  */
-#line 659 "a.y"
+#line 657 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) - (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 130:
-
-/* Line 1806 of yacc.c  */
-#line 663 "a.y"
+#line 661 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) * (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 131:
-
-/* Line 1806 of yacc.c  */
-#line 667 "a.y"
+#line 665 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) / (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 132:
-
-/* Line 1806 of yacc.c  */
-#line 671 "a.y"
+#line 669 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) % (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 133:
-
-/* Line 1806 of yacc.c  */
-#line 675 "a.y"
+#line 673 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (4)].lval) << (yyvsp[(4) - (4)].lval);
 	}
     break;
 
   case 134:
-
-/* Line 1806 of yacc.c  */
-#line 679 "a.y"
+#line 677 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (4)].lval) >> (yyvsp[(4) - (4)].lval);
 	}
     break;
 
   case 135:
-
-/* Line 1806 of yacc.c  */
-#line 683 "a.y"
+#line 681 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) & (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 136:
-
-/* Line 1806 of yacc.c  */
-#line 687 "a.y"
+#line 685 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) ^ (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 137:
-
-/* Line 1806 of yacc.c  */
-#line 691 "a.y"
+#line 689 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) | (yyvsp[(3) - (3)].lval);
 	}
     break;
 
 
-
-/* Line 1806 of yacc.c  */
-#line 2860 "y.tab.c"
+/* Line 1267 of yacc.c.  */
+#line 2588 "y.tab.c"
       default: break;
     }
-  /* User semantic actions sometimes alter yychar, and that requires
-     that yytoken be updated with the new translation.  We take the
-     approach of translating immediately before every use of yytoken.
-     One alternative is translating here after every semantic action,
-     but that translation would be missed if the semantic action invokes
-     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
-     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
-     incorrect destructor might then be invoked immediately.  In the
-     case of YYERROR or YYBACKUP, subsequent parser actions might lead
-     to an incorrect destructor call or verbose syntax error message
-     before the lookahead is translated.  */
   YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
   YYPOPSTACK (yylen);
@@ -2878,6 +2595,7 @@ yyreduce:
 
   *++yyvsp = yyval;
 
+
   /* Now `shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
      number reduced by.  */
@@ -2897,10 +2615,6 @@ yyreduce:
 | yyerrlab -- here on detecting error |
 `------------------------------------*/
 yyerrlab:
-  /* Make sure we have latest lookahead translation.  See comments at
-     user semantic actions for why this is necessary.  */
-  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
-
   /* If not already recovering from an error, report this error.  */
   if (!yyerrstatus)
     {
@@ -2908,36 +2622,37 @@ yyerrlab:
 #if ! YYERROR_VERBOSE
       yyerror (YY_("syntax error"));
 #else
-# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
-                                        yyssp, yytoken)
       {
-        char const *yymsgp = YY_("syntax error");
-        int yysyntax_error_status;
-        yysyntax_error_status = YYSYNTAX_ERROR;
-        if (yysyntax_error_status == 0)
-          yymsgp = yymsg;
-        else if (yysyntax_error_status == 1)
-          {
-            if (yymsg != yymsgbuf)
-              YYSTACK_FREE (yymsg);
-            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
-            if (!yymsg)
-              {
-                yymsg = yymsgbuf;
-                yymsg_alloc = sizeof yymsgbuf;
-                yysyntax_error_status = 2;
-              }
-            else
-              {
-                yysyntax_error_status = YYSYNTAX_ERROR;
-                yymsgp = yymsg;
-              }
-          }
-        yyerror (yymsgp);
-        if (yysyntax_error_status == 2)
-          goto yyexhaustedlab;
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
       }
-# undef YYSYNTAX_ERROR
 #endif
     }
 
@@ -2945,7 +2660,7 @@ yyerrlab:
 
   if (yyerrstatus == 3)
     {
-      /* If just tried and failed to reuse lookahead token after an
+      /* If just tried and failed to reuse look-ahead token after an
 	 error, discard it.  */
 
       if (yychar <= YYEOF)
@@ -2962,7 +2677,7 @@ yyerrlab:
 	}
     }
 
-  /* Else will try to reuse lookahead token after shifting the error
+  /* Else will try to reuse look-ahead token after shifting the error
      token.  */
   goto yyerrlab1;
 
@@ -2996,7 +2711,7 @@ yyerrlab1:
   for (;;)
     {
       yyn = yypact[yystate];
-      if (!yypact_value_is_default (yyn))
+      if (yyn != YYPACT_NINF)
 	{
 	  yyn += YYTERROR;
 	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
@@ -3019,6 +2734,9 @@ yyerrlab1:
       YY_STACK_PRINT (yyss, yyssp);
     }
 
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
   *++yyvsp = yylval;
 
 
@@ -3043,7 +2761,7 @@ yyabortlab:
   yyresult = 1;
   goto yyreturn;
 
-#if !defined(yyoverflow) || YYERROR_VERBOSE
+#ifndef yyoverflow
 /*-------------------------------------------------.
 | yyexhaustedlab -- memory exhaustion comes here.  |
 `-------------------------------------------------*/
@@ -3054,14 +2772,9 @@ yyexhaustedlab:
 #endif
 
 yyreturn:
-  if (yychar != YYEMPTY)
-    {
-      /* Make sure we have latest lookahead translation.  See comments at
-         user semantic actions for why this is necessary.  */
-      yytoken = YYTRANSLATE (yychar);
-      yydestruct ("Cleanup: discarding lookahead",
-                  yytoken, &yylval);
-    }
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
   /* Do not reclaim the symbols of the rule which action triggered
      this YYABORT or YYACCEPT.  */
   YYPOPSTACK (yylen);
diff --git a/src/cmd/6a/y.tab.h b/src/cmd/6a/y.tab.h
index bba6081dc3..e0eb5e12cf 100644
--- a/src/cmd/6a/y.tab.h
+++ b/src/cmd/6a/y.tab.h
@@ -1,21 +1,24 @@
-/* A Bison parser, made by GNU Bison 2.5.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Bison interface for Yacc-like parsers in C
-   
-      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
-   
-   This program is free software: you can redistribute it and/or modify
+/* Skeleton interface for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-   
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -26,11 +29,10 @@
    special exception, which will cause the skeleton and the resulting
    Bison output files to be licensed under the GNU General Public
    License without this special exception.
-   
+
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
-
 /* Tokens.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
@@ -116,28 +118,22 @@
 
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-{
-
-/* Line 2068 of yacc.c  */
 #line 38 "a.y"
-
+{
 	Sym	*sym;
 	vlong	lval;
 	double	dval;
 	char	sval[8];
-	Gen	gen;
-	Gen2	gen2;
-
-
-
-/* Line 2068 of yacc.c  */
-#line 135 "y.tab.h"
-} YYSTYPE;
-# define YYSTYPE_IS_TRIVIAL 1
+	Addr	addr;
+	Addr2	addr2;
+}
+/* Line 1529 of yacc.c.  */
+#line 132 "y.tab.h"
+	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
 #endif
 
 extern YYSTYPE yylval;
 
-
diff --git a/src/cmd/8a/a.h b/src/cmd/8a/a.h
index c5c22d7baa..41fe580483 100644
--- a/src/cmd/8a/a.h
+++ b/src/cmd/8a/a.h
@@ -29,9 +29,9 @@
 // THE SOFTWARE.
 
 #include <bio.h>
+#include <link.h>
 #include "../8l/8.out.h"
 
-
 #ifndef	EXTERN
 #define	EXTERN	extern
 #endif
@@ -45,10 +45,8 @@
 
 typedef	struct	Sym	Sym;
 typedef	struct	Ref	Ref;
-typedef	struct	Gen	Gen;
 typedef	struct	Io	Io;
-typedef	struct	Hist	Hist;
-typedef	struct	Gen2	Gen2;
+typedef	struct	Addr2	Addr2;
 
 #define	MAXALIGN	7
 #define	FPCHIP		1
@@ -97,37 +95,11 @@ struct	Io
 };
 #define	I	((Io*)0)
 
-EXTERN struct
-{
-	Sym*	sym;
-	short	type;
-} h[NSYM];
-
-struct	Gen
-{
-	double	dval;
-	char	sval[8];
-	int32	offset;
-	int32	offset2;
-	Sym*	sym;
-	short	type;
-	short	index;
-	short	scale;
-};
-struct	Gen2
-{
-	Gen	from;
-	Gen	to;
-};
-
-struct	Hist
+struct	Addr2
 {
-	Hist*	link;
-	char*	name;
-	int32	line;
-	int32	offset;
+	Addr	from;
+	Addr	to;
 };
-#define	H	((Hist*)0)
 
 enum
 {
@@ -137,14 +109,11 @@ enum
 	CPREPROC,
 };
 
-
 EXTERN	char	debug[256];
 EXTERN	Sym*	hash[NHASH];
 EXTERN	char**	Dlist;
 EXTERN	int	nDlist;
-EXTERN	Hist*	ehist;
 EXTERN	int	newflag;
-EXTERN	Hist*	hist;
 EXTERN	char*	hunk;
 EXTERN	char**	include;
 EXTERN	Io*	iofree;
@@ -155,10 +124,9 @@ EXTERN	int	nerrors;
 EXTERN	int32	nhunk;
 EXTERN	int	ninclude;
 EXTERN	int32	nsymb;
-EXTERN	Gen	nullgen;
+EXTERN	Addr	nullgen;
 EXTERN	char*	outfile;
 EXTERN	int	pass;
-EXTERN	char*	pathname;
 EXTERN	int32	pc;
 EXTERN	int	peekc;
 EXTERN	int32	stmtline;
@@ -168,6 +136,7 @@ EXTERN	int	thechar;
 EXTERN	char*	thestring;
 EXTERN	int32	thunk;
 EXTERN	Biobuf	obuf;
+EXTERN	Link*	ctxt;
 
 void*	alloc(int32);
 void*	allocn(void*, int32, int32);
@@ -188,12 +157,9 @@ void	cinit(void);
 void	checkscale(int);
 void	pinit(char*);
 void	cclean(void);
-int	isreg(Gen*);
-void	outcode(int, Gen2*);
+int	isreg(Addr*);
+void	outcode(int, Addr2*);
 void	outhist(void);
-void	zaddr(Gen*, int);
-void	zname(char*, int, int);
-void	ieeedtod(Ieee*, double);
 int	filbuf(void);
 Sym*	getsym(void);
 void	domacro(void);
diff --git a/src/cmd/8a/a.y b/src/cmd/8a/a.y
index 13ccc985b5..c4ad7e289c 100644
--- a/src/cmd/8a/a.y
+++ b/src/cmd/8a/a.y
@@ -44,8 +44,8 @@
 	} con2;
 	double	dval;
 	char	sval[8];
-	Gen	gen;
-	Gen2	gen2;
+	LAddr	addr;
+	Addr2	addr2;
 }
 %left	'|'
 %left	'^'
@@ -62,9 +62,9 @@
 %token	<sym>	LNAME LLAB LVAR
 %type	<lval>	con expr pointer offset
 %type	<con2>	con2
-%type	<gen>	mem imm imm2 reg nam rel rem rim rom omem nmem
-%type	<gen2>	nonnon nonrel nonrem rimnon rimrem remrim
-%type	<gen2>	spec1 spec2 spec3 spec4 spec5 spec6 spec7 spec8 spec9 spec10 spec11 spec12
+%type	<addr>	mem imm imm2 reg nam rel rem rim rom omem nmem
+%type	<addr2>	nonnon nonrel nonrem rimnon rimrem remrim
+%type	<addr2>	spec1 spec2 spec3 spec4 spec5 spec6 spec7 spec8 spec9 spec10 spec11 spec12
 %%
 prog:
 |	prog
@@ -366,14 +366,12 @@ rel:
 		if(pass == 2)
 			yyerror("undefined label: %s", $1->name);
 		$$.type = D_BRANCH;
-		$$.sym = $1;
 		$$.offset = $2;
 	}
 |	LLAB offset
 	{
 		$$ = nullgen;
 		$$.type = D_BRANCH;
-		$$.sym = $1;
 		$$.offset = $1->value + $2;
 	}
 
@@ -431,31 +429,31 @@ imm:
 	{
 		$$ = nullgen;
 		$$.type = D_SCONST;
-		memcpy($$.sval, $2, sizeof($$.sval));
+		memcpy($$.u.sval, $2, sizeof($$.u.sval));
 	}
 |	'$' LFCONST
 	{
 		$$ = nullgen;
 		$$.type = D_FCONST;
-		$$.dval = $2;
+		$$.u.dval = $2;
 	}
 |	'$' '(' LFCONST ')'
 	{
 		$$ = nullgen;
 		$$.type = D_FCONST;
-		$$.dval = $3;
+		$$.u.dval = $3;
 	}
 |	'$' '(' '-' LFCONST ')'
 	{
 		$$ = nullgen;
 		$$.type = D_FCONST;
-		$$.dval = -$4;
+		$$.u.dval = -$4;
 	}
 |	'$' '-' LFCONST
 	{
 		$$ = nullgen;
 		$$.type = D_FCONST;
-		$$.dval = -$3;
+		$$.u.dval = -$3;
 	}
 
 imm2:
@@ -590,14 +588,14 @@ nam:
 	{
 		$$ = nullgen;
 		$$.type = $4;
-		$$.sym = $1;
+		$$.sym = linklookup(ctxt, $1->name, 0);
 		$$.offset = $2;
 	}
 |	LNAME '<' '>' offset '(' LSB ')'
 	{
 		$$ = nullgen;
 		$$.type = D_STATIC;
-		$$.sym = $1;
+		$$.sym = linklookup(ctxt, $1->name, 1);
 		$$.offset = $4;
 	}
 
diff --git a/src/cmd/8a/lex.c b/src/cmd/8a/lex.c
index f2ccc3361a..12034210f5 100644
--- a/src/cmd/8a/lex.c
+++ b/src/cmd/8a/lex.c
@@ -65,6 +65,8 @@ main(int argc, char *argv[])
 
 	thechar = '8';
 	thestring = "386";
+	ctxt = linknew(&link386);
+	ctxt->diag = yyerror;
 
 	ensuresymb(NSYMB);
 	memset(debug, 0, sizeof(debug));
@@ -96,6 +98,10 @@ main(int argc, char *argv[])
 		p = ARGF();
 		setinclude(p);
 		break;
+
+	case 'S':
+		ctxt->debugasm++;
+		break;
 	} ARGEND
 	if(*argv == 0) {
 		print("usage: %ca [-options] file.s\n", thechar);
@@ -145,30 +151,23 @@ assemble(char *file)
 		errorexit();
 	}
 	Binit(&obuf, of, OWRITE);
-
-	pass = 1;
-	pinit(file);
-
 	Bprint(&obuf, "go object %s %s %s\n", getgoos(), thestring, getgoversion());
+	Bprint(&obuf, "\n!\n");
 
-	for(i=0; i<nDlist; i++)
-		dodefine(Dlist[i]);
-	yyparse();
-	if(nerrors) {
+	for(pass = 1; pass <= 2; pass++) {
+		pinit(file);
+		for(i=0; i<nDlist; i++)
+			dodefine(Dlist[i]);
+		yyparse();
 		cclean();
-		return nerrors;
+		if(nerrors)
+			return nerrors;
 	}
 
-	Bprint(&obuf, "\n!\n");
-
-	pass = 2;
-	outhist();
-	pinit(file);
-	for(i=0; i<nDlist; i++)
-		dodefine(Dlist[i]);
-	yyparse();
-	cclean();
-	return nerrors;
+	linkouthist(ctxt, &obuf);
+	linkwritefuncs(ctxt, &obuf);
+	Bflush(&obuf);
+	return 0;
 }
 
 struct
@@ -810,15 +809,8 @@ cinit(void)
 	Sym *s;
 	int i;
 
-	nullgen.sym = S;
-	nullgen.offset = 0;
-	if(FPCHIP)
-		nullgen.dval = 0;
-	for(i=0; i<sizeof(nullgen.sval); i++)
-		nullgen.sval[i] = 0;
 	nullgen.type = D_NONE;
 	nullgen.index = D_NONE;
-	nullgen.scale = 0;
 
 	nerrors = 0;
 	iostack = I;
@@ -834,13 +826,6 @@ cinit(void)
 		s->type = itab[i].type;
 		s->value = itab[i].value;
 	}
-
-	pathname = allocn(pathname, 0, 100);
-	if(getwd(pathname, 99) == 0) {
-		pathname = allocn(pathname, 100, 900);
-		if(getwd(pathname, 999) == 0)
-			strcpy(pathname, "/???");
-	}
 }
 
 void
@@ -868,252 +853,42 @@ syminit(Sym *s)
 void
 cclean(void)
 {
-	Gen2 g2;
+	Addr2 g2;
 
 	g2.from = nullgen;
 	g2.to = nullgen;
 	outcode(AEND, &g2);
-	Bflush(&obuf);
 }
 
-void
-zname(char *n, int t, int s)
-{
-
-	BPUTLE2(&obuf, ANAME);		/* as(2) */
-	BPUTC(&obuf, t);		/* type */
-	BPUTC(&obuf, s);		/* sym */
-	while(*n) {
-		BPUTC(&obuf, *n);
-		n++;
-	}
-	BPUTC(&obuf, 0);
-}
-
-void
-zaddr(Gen *a, int s)
-{
-	int32 l;
-	int i, t;
-	char *n;
-	Ieee e;
-
-	t = 0;
-	if(a->index != D_NONE || a->scale != 0)
-		t |= T_INDEX;
-	if(a->offset != 0)
-		t |= T_OFFSET;
-	if(s != 0)
-		t |= T_SYM;
-
-	switch(a->type) {
-	default:
-		t |= T_TYPE;
-		break;
-	case D_FCONST:
-		t |= T_FCONST;
-		break;
-	case D_CONST2:
-		t |= T_OFFSET|T_OFFSET2;
-		break;
-	case D_SCONST:
-		t |= T_SCONST;
-		break;
-	case D_NONE:
-		break;
-	}
-	BPUTC(&obuf, t);
-
-	if(t & T_INDEX) {	/* implies index, scale */
-		BPUTC(&obuf, a->index);
-		BPUTC(&obuf, a->scale);
-	}
-	if(t & T_OFFSET) {	/* implies offset */
-		l = a->offset;
-		BPUTLE4(&obuf, l);
-	}
-	if(t & T_OFFSET2) {
-		l = a->offset2;
-		BPUTLE4(&obuf, l);
-	}
-	if(t & T_SYM)		/* implies sym */
-		BPUTC(&obuf, s);
-	if(t & T_FCONST) {
-		ieeedtod(&e, a->dval);
-		BPUTLE4(&obuf, e.l);
-		BPUTLE4(&obuf, e.h);
-		return;
-	}
-	if(t & T_SCONST) {
-		n = a->sval;
-		for(i=0; i<NSNAME; i++) {
-			BPUTC(&obuf, *n);
-			n++;
-		}
-		return;
-	}
-	if(t & T_TYPE)
-		BPUTC(&obuf, a->type);
-}
+static Prog *lastpc;
 
 void
-outcode(int a, Gen2 *g2)
+outcode(int a, Addr2 *g2)
 {
-	int sf, st, t;
-	Sym *s;
-
+	Prog *p;
+	Plist *pl;
+	
 	if(pass == 1)
 		goto out;
 
-jackpot:
-	sf = 0;
-	s = g2->from.sym;
-	while(s != S) {
-		sf = s->sym;
-		if(sf < 0 || sf >= NSYM)
-			sf = 0;
-		t = g2->from.type;
-		if(t == D_ADDR)
-			t = g2->from.index;
-		if(h[sf].type == t)
-		if(h[sf].sym == s)
-			break;
-		zname(s->name, t, sym);
-		s->sym = sym;
-		h[sym].sym = s;
-		h[sym].type = t;
-		sf = sym;
-		sym++;
-		if(sym >= NSYM)
-			sym = 1;
-		break;
-	}
-	st = 0;
-	s = g2->to.sym;
-	while(s != S) {
-		st = s->sym;
-		if(st < 0 || st >= NSYM)
-			st = 0;
-		t = g2->to.type;
-		if(t == D_ADDR)
-			t = g2->to.index;
-		if(h[st].type == t)
-		if(h[st].sym == s)
-			break;
-		zname(s->name, t, sym);
-		s->sym = sym;
-		h[sym].sym = s;
-		h[sym].type = t;
-		st = sym;
-		sym++;
-		if(sym >= NSYM)
-			sym = 1;
-		if(st == sf)
-			goto jackpot;
-		break;
-	}
-	BPUTLE2(&obuf, a);
-	BPUTLE4(&obuf, stmtline);
-	zaddr(&g2->from, sf);
-	zaddr(&g2->to, st);
+	p = malloc(sizeof *p);
+	memset(p, 0, sizeof *p);
+	p->as = a;
+	p->lineno = stmtline;
+	p->from = g2->from;
+	p->to = g2->to;
+
+	if(lastpc == nil) {
+		pl = linknewplist(ctxt);
+		pl->firstpc = p;
+	} else
+		lastpc->link = p;
+	lastpc = p;	
 
 out:
 	if(a != AGLOBL && a != ADATA)
 		pc++;
 }
 
-void
-outhist(void)
-{
-	Gen g;
-	Hist *h;
-	char *p, *q, *op, c;
-	int n;
-	char *tofree;
-	static int first = 1;
-	static char *goroot, *goroot_final;
-
-	if(first) {
-		// Decide whether we need to rewrite paths from $GOROOT to $GOROOT_FINAL.
-		first = 0;
-		goroot = getenv("GOROOT");
-		goroot_final = getenv("GOROOT_FINAL");
-		if(goroot == nil)
-			goroot = "";
-		if(goroot_final == nil)
-			goroot_final = goroot;
-		if(strcmp(goroot, goroot_final) == 0) {
-			goroot = nil;
-			goroot_final = nil;
-		}
-	}
-
-	tofree = nil;
-
-	g = nullgen;
-	c = pathchar();
-	for(h = hist; h != H; h = h->link) {
-		p = h->name;
-		if(p != nil && goroot != nil) {
-			n = strlen(goroot);
-			if(strncmp(p, goroot, strlen(goroot)) == 0 && p[n] == '/') {
-				tofree = smprint("%s%s", goroot_final, p+n);
-				p = tofree;
-			}
-		}
-		op = 0;
-		if(systemtype(Windows) && p && p[1] == ':'){
-			c = p[2];
-		} else if(p && p[0] != c && h->offset == 0 && pathname){
-			if(systemtype(Windows) && pathname[1] == ':') {
-				op = p;
-				p = pathname;
-				c = p[2];
-			} else if(pathname[0] == c){
-				op = p;
-				p = pathname;
-			}
-		}
-		while(p) {
-			q = strchr(p, c);
-			if(q) {
-				n = q-p;
-				if(n == 0){
-					n = 1;	/* leading "/" */
-					*p = '/';	/* don't emit "\" on windows */
-				}
-				q++;
-			} else {
-				n = strlen(p);
-				q = 0;
-			}
-			if(n) {
-				BPUTLE2(&obuf, ANAME);
-				BPUTC(&obuf, D_FILE);	/* type */
-				BPUTC(&obuf, 1);	/* sym */
-				BPUTC(&obuf, '<');
-				Bwrite(&obuf, p, n);
-				BPUTC(&obuf, 0);
-			}
-			p = q;
-			if(p == 0 && op) {
-				p = op;
-				op = 0;
-			}
-		}
-		g.offset = h->offset;
-
-		BPUTLE2(&obuf, AHISTORY);
-		BPUTLE4(&obuf, h->line);
-		zaddr(&nullgen, 0);
-		zaddr(&g, 0);
-
-		if(tofree) {
-			free(tofree);
-			tofree = nil;
-		}
-	}
-}
-
 #include "../cc/lexbody"
 #include "../cc/macbody"
diff --git a/src/cmd/8a/y.tab.c b/src/cmd/8a/y.tab.c
index aec4856f60..f48c9fe1f8 100644
--- a/src/cmd/8a/y.tab.c
+++ b/src/cmd/8a/y.tab.c
@@ -1,21 +1,24 @@
-/* A Bison parser, made by GNU Bison 2.5.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Bison implementation for Yacc-like parsers in C
-   
-      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
-   
-   This program is free software: you can redistribute it and/or modify
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-   
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -26,7 +29,7 @@
    special exception, which will cause the skeleton and the resulting
    Bison output files to be licensed under the GNU General Public
    License without this special exception.
-   
+
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
@@ -44,7 +47,7 @@
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "2.5"
+#define YYBISON_VERSION "2.3"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -52,51 +55,11 @@
 /* Pure parsers.  */
 #define YYPURE 0
 
-/* Push parsers.  */
-#define YYPUSH 0
-
-/* Pull parsers.  */
-#define YYPULL 1
-
 /* Using locations.  */
 #define YYLSP_NEEDED 0
 
 
 
-/* Copy the first part of user declarations.  */
-
-/* Line 268 of yacc.c  */
-#line 31 "a.y"
-
-#include <u.h>
-#include <stdio.h>	/* if we don't, bison will, and a.h re-#defines getc */
-#include <libc.h>
-#include "a.h"
-#include "../../pkg/runtime/funcdata.h"
-
-
-/* Line 268 of yacc.c  */
-#line 80 "y.tab.c"
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-/* Enabling the token table.  */
-#ifndef YYTOKEN_TABLE
-# define YYTOKEN_TABLE 0
-#endif
-
-
 /* Tokens.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
@@ -176,13 +139,38 @@
 
 
 
+/* Copy the first part of user declarations.  */
+#line 31 "a.y"
+
+#include <u.h>
+#include <stdio.h>	/* if we don't, bison will, and a.h re-#defines getc */
+#include <libc.h>
+#include "a.h"
+#include "../../pkg/runtime/funcdata.h"
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-{
-
-/* Line 293 of yacc.c  */
 #line 38 "a.y"
-
+{
 	Sym	*sym;
 	int32	lval;
 	struct {
@@ -191,25 +179,24 @@ typedef union YYSTYPE
 	} con2;
 	double	dval;
 	char	sval[8];
-	Gen	gen;
-	Gen2	gen2;
-
-
-
-/* Line 293 of yacc.c  */
-#line 201 "y.tab.c"
-} YYSTYPE;
-# define YYSTYPE_IS_TRIVIAL 1
+	Addr	addr;
+	Addr2	addr2;
+}
+/* Line 193 of yacc.c.  */
+#line 187 "y.tab.c"
+	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
 #endif
 
 
+
 /* Copy the second part of user declarations.  */
 
 
-/* Line 343 of yacc.c  */
-#line 213 "y.tab.c"
+/* Line 216 of yacc.c.  */
+#line 200 "y.tab.c"
 
 #ifdef short
 # undef short
@@ -284,14 +271,14 @@ typedef short int yytype_int16;
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 static int
-YYID (int yyi)
+YYID (int i)
 #else
 static int
-YYID (yyi)
-    int yyi;
+YYID (i)
+    int i;
 #endif
 {
-  return yyi;
+  return i;
 }
 #endif
 
@@ -312,11 +299,11 @@ YYID (yyi)
 #    define alloca _alloca
 #   else
 #    define YYSTACK_ALLOC alloca
-#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 #     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#     ifndef EXIT_SUCCESS
-#      define EXIT_SUCCESS 0
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
 #     endif
 #    endif
 #   endif
@@ -339,24 +326,24 @@ YYID (yyi)
 #  ifndef YYSTACK_ALLOC_MAXIMUM
 #   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
 #  endif
-#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+#  if (defined __cplusplus && ! defined _STDLIB_H \
        && ! ((defined YYMALLOC || defined malloc) \
 	     && (defined YYFREE || defined free)))
 #   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   ifndef EXIT_SUCCESS
-#    define EXIT_SUCCESS 0
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
 #   endif
 #  endif
 #  ifndef YYMALLOC
 #   define YYMALLOC malloc
-#   if ! defined malloc && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
 #  ifndef YYFREE
 #   define YYFREE free
-#   if ! defined free && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 void free (void *); /* INFRINGES ON USER NAME SPACE */
 #   endif
@@ -372,9 +359,9 @@ void free (void *); /* INFRINGES ON USER NAME SPACE */
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  yytype_int16 yyss_alloc;
-  YYSTYPE yyvs_alloc;
-};
+  yytype_int16 yyss;
+  YYSTYPE yyvs;
+  };
 
 /* The size of the maximum gap between one aligned stack and the next.  */
 # define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
@@ -385,27 +372,6 @@ union yyalloc
      ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
-# define YYCOPY_NEEDED 1
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
-	Stack = &yyptr->Stack_alloc;					\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (YYID (0))
-
-#endif
-
-#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
@@ -423,7 +389,24 @@ union yyalloc
       while (YYID (0))
 #  endif
 # endif
-#endif /* !YYCOPY_NEEDED */
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
 
 /* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  2
@@ -564,13 +547,13 @@ static const yytype_uint16 yyrline[] =
      175,   180,   185,   192,   200,   205,   213,   218,   223,   232,
      233,   236,   241,   251,   256,   266,   271,   276,   283,   288,
      296,   304,   314,   323,   334,   335,   338,   339,   340,   344,
-     348,   349,   350,   353,   354,   357,   363,   372,   381,   386,
-     391,   396,   401,   406,   413,   419,   430,   436,   442,   448,
-     454,   462,   471,   476,   481,   486,   493,   494,   497,   503,
-     509,   515,   524,   533,   542,   547,   552,   558,   566,   576,
-     580,   589,   596,   605,   608,   612,   618,   619,   623,   626,
-     627,   631,   635,   639,   643,   649,   650,   654,   658,   662,
-     666,   670,   674,   678,   682,   686
+     348,   349,   350,   353,   354,   357,   363,   371,   379,   384,
+     389,   394,   399,   404,   411,   417,   428,   434,   440,   446,
+     452,   460,   469,   474,   479,   484,   491,   492,   495,   501,
+     507,   513,   522,   531,   540,   545,   550,   556,   564,   574,
+     578,   587,   594,   603,   606,   610,   616,   617,   621,   624,
+     625,   629,   633,   637,   641,   647,   648,   652,   656,   660,
+     664,   668,   672,   676,   680,   684
 };
 #endif
 
@@ -585,12 +568,12 @@ static const char *const yytname[] =
   "LTYPEM", "LTYPEI", "LTYPEG", "LTYPEXC", "LTYPEX", "LTYPEPC", "LTYPEF",
   "LCONST", "LFP", "LPC", "LSB", "LBREG", "LLREG", "LSREG", "LFREG",
   "LXREG", "LFCONST", "LSCONST", "LSP", "LNAME", "LLAB", "LVAR", "':'",
-  "';'", "'='", "','", "'('", "')'", "'$'", "'~'", "$accept", "prog",
-  "$@1", "line", "$@2", "$@3", "inst", "nonnon", "rimrem", "remrim",
-  "rimnon", "nonrem", "nonrel", "spec1", "spec2", "spec3", "spec4",
-  "spec5", "spec6", "spec7", "spec8", "spec9", "spec10", "spec11",
-  "spec12", "rem", "rom", "rim", "rel", "reg", "imm", "imm2", "con2",
-  "mem", "omem", "nmem", "nam", "offset", "pointer", "con", "expr", 0
+  "';'", "'='", "','", "'('", "')'", "'$'", "'~'", "$accept", "prog", "@1",
+  "line", "@2", "@3", "inst", "nonnon", "rimrem", "remrim", "rimnon",
+  "nonrem", "nonrel", "spec1", "spec2", "spec3", "spec4", "spec5", "spec6",
+  "spec7", "spec8", "spec9", "spec10", "spec11", "spec12", "rem", "rom",
+  "rim", "rel", "reg", "imm", "imm2", "con2", "mem", "omem", "nmem", "nam",
+  "offset", "pointer", "con", "expr", 0
 };
 #endif
 
@@ -646,8 +629,8 @@ static const yytype_uint8 yyr2[] =
        3,     4,     4,     3,     3,     3
 };
 
-/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
-   Performed when YYTABLE doesn't specify something else to do.  Zero
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
 static const yytype_uint8 yydefact[] =
 {
@@ -738,7 +721,8 @@ static const yytype_int16 yypgoto[] =
 
 /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
    positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If YYTABLE_NINF, syntax error.  */
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
 #define YYTABLE_NINF -1
 static const yytype_uint16 yytable[] =
 {
@@ -799,12 +783,6 @@ static const yytype_uint16 yytable[] =
      170,   171,   172,   173,   174,   175,   176
 };
 
-#define yypact_value_is_default(yystate) \
-  ((yystate) == (-104))
-
-#define yytable_value_is_error(yytable_value) \
-  YYID (0)
-
 static const yytype_int16 yycheck[] =
 {
       10,    10,    10,    13,     0,    13,     8,    13,    11,    10,
@@ -910,18 +888,9 @@ static const yytype_uint8 yystos[] =
 
 /* Like YYERROR except do call yyerror.  This remains here temporarily
    to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  However,
-   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
-   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
-   discussed.  */
+   Once GCC version 2 has supplanted version 1, this can go.  */
 
 #define YYFAIL		goto yyerrlab
-#if defined YYFAIL
-  /* This is here to suppress warnings from the GCC cpp's
-     -Wunused-macros.  Normally we don't worry about that warning, but
-     some users do, and we want to make it easy for users to remove
-     YYFAIL uses, which will produce warnings from Bison 2.5.  */
-#endif
 
 #define YYRECOVERING()  (!!yyerrstatus)
 
@@ -931,6 +900,7 @@ do								\
     {								\
       yychar = (Token);						\
       yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
       YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
@@ -972,10 +942,19 @@ while (YYID (0))
 #endif
 
 
-/* This macro is provided for backward compatibility. */
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
 
 #ifndef YY_LOCATION_PRINT
-# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
 #endif
 
 
@@ -1079,20 +1058,17 @@ yy_symbol_print (yyoutput, yytype, yyvaluep)
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 static void
-yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
 #else
 static void
-yy_stack_print (yybottom, yytop)
-    yytype_int16 *yybottom;
-    yytype_int16 *yytop;
+yy_stack_print (bottom, top)
+    yytype_int16 *bottom;
+    yytype_int16 *top;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (; yybottom <= yytop; yybottom++)
-    {
-      int yybot = *yybottom;
-      YYFPRINTF (stderr, " %d", yybot);
-    }
+  for (; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
   YYFPRINTF (stderr, "\n");
 }
 
@@ -1126,11 +1102,11 @@ yy_reduce_print (yyvsp, yyrule)
   /* The symbols being reduced.  */
   for (yyi = 0; yyi < yynrhs; yyi++)
     {
-      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      fprintf (stderr, "   $%d = ", yyi + 1);
       yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
 		       &(yyvsp[(yyi + 1) - (yynrhs)])
 		       		       );
-      YYFPRINTF (stderr, "\n");
+      fprintf (stderr, "\n");
     }
 }
 
@@ -1167,6 +1143,7 @@ int yydebug;
 # define YYMAXDEPTH 10000
 #endif
 
+
 
 #if YYERROR_VERBOSE
 
@@ -1269,142 +1246,115 @@ yytnamerr (char *yyres, const char *yystr)
 }
 # endif
 
-/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
-   about the unexpected token YYTOKEN for the state stack whose top is
-   YYSSP.
-
-   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
-   not large enough to hold the message.  In that case, also set
-   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
-   required number of bytes is too large to store.  */
-static int
-yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
-                yytype_int16 *yyssp, int yytoken)
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
 {
-  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytoken]);
-  YYSIZE_T yysize = yysize0;
-  YYSIZE_T yysize1;
-  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-  /* Internationalized format string. */
-  const char *yyformat = 0;
-  /* Arguments of yyformat. */
-  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-  /* Number of reported tokens (one for the "unexpected", one per
-     "expected"). */
-  int yycount = 0;
-
-  /* There are many possibilities here to consider:
-     - Assume YYFAIL is not used.  It's too flawed to consider.  See
-       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
-       for details.  YYERROR is fine as it does not invoke this
-       function.
-     - If this state is a consistent state with a default action, then
-       the only way this function was invoked is if the default action
-       is an error action.  In that case, don't check for expected
-       tokens because there are none.
-     - The only way there can be no lookahead present (in yychar) is if
-       this state is a consistent state with a default action.  Thus,
-       detecting the absence of a lookahead is sufficient to determine
-       that there is no unexpected or expected token to report.  In that
-       case, just report a simple "syntax error".
-     - Don't assume there isn't a lookahead just because this state is a
-       consistent state with a default action.  There might have been a
-       previous inconsistent state, consistent state with a non-default
-       action, or user semantic action that manipulated yychar.
-     - Of course, the expected token list depends on states to have
-       correct lookahead information, and it depends on the parser not
-       to perform extra reductions after fetching a lookahead from the
-       scanner and before detecting a syntax error.  Thus, state merging
-       (from LALR or IELR) and default reductions corrupt the expected
-       token list.  However, the list is correct for canonical LR with
-       one exception: it will still contain any token that will not be
-       accepted due to an error action in a later state.
-  */
-  if (yytoken != YYEMPTY)
-    {
-      int yyn = yypact[*yyssp];
-      yyarg[yycount++] = yytname[yytoken];
-      if (!yypact_value_is_default (yyn))
-        {
-          /* Start YYX at -YYN if negative to avoid negative indexes in
-             YYCHECK.  In other words, skip the first -YYN actions for
-             this state because they are default actions.  */
-          int yyxbegin = yyn < 0 ? -yyn : 0;
-          /* Stay within bounds of both yycheck and yytname.  */
-          int yychecklim = YYLAST - yyn + 1;
-          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-          int yyx;
-
-          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
-                && !yytable_value_is_error (yytable[yyx + yyn]))
-              {
-                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-                  {
-                    yycount = 1;
-                    yysize = yysize0;
-                    break;
-                  }
-                yyarg[yycount++] = yytname[yyx];
-                yysize1 = yysize + yytnamerr (0, yytname[yyx]);
-                if (! (yysize <= yysize1
-                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-                  return 2;
-                yysize = yysize1;
-              }
-        }
-    }
+  int yyn = yypact[yystate];
 
-  switch (yycount)
-    {
-# define YYCASE_(N, S)                      \
-      case N:                               \
-        yyformat = S;                       \
-      break
-      YYCASE_(0, YY_("syntax error"));
-      YYCASE_(1, YY_("syntax error, unexpected %s"));
-      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
-      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
-      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
-      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
-# undef YYCASE_
-    }
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
 
-  yysize1 = yysize + yystrlen (yyformat);
-  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-    return 2;
-  yysize = yysize1;
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
 
-  if (*yymsg_alloc < yysize)
-    {
-      *yymsg_alloc = 2 * yysize;
-      if (! (yysize <= *yymsg_alloc
-             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
-        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
-      return 1;
-    }
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
 
-  /* Avoid sprintf, as that infringes on the user's name space.
-     Don't have undefined behavior even if the translation
-     produced a string with the wrong number of "%s"s.  */
-  {
-    char *yyp = *yymsg;
-    int yyi = 0;
-    while ((*yyp = *yyformat) != '\0')
-      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
-        {
-          yyp += yytnamerr (yyp, yyarg[yyi++]);
-          yyformat += 2;
-        }
-      else
-        {
-          yyp++;
-          yyformat++;
-        }
-  }
-  return 0;
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
 }
 #endif /* YYERROR_VERBOSE */
+
 
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
@@ -1436,9 +1386,10 @@ yydestruct (yymsg, yytype, yyvaluep)
 	break;
     }
 }
-
+
 
 /* Prevent warnings from -Wmissing-prototypes.  */
+
 #ifdef YYPARSE_PARAM
 #if defined __STDC__ || defined __cplusplus
 int yyparse (void *YYPARSE_PARAM);
@@ -1454,16 +1405,18 @@ int yyparse ();
 #endif /* ! YYPARSE_PARAM */
 
 
-/* The lookahead symbol.  */
+
+/* The look-ahead symbol.  */
 int yychar;
 
-/* The semantic value of the lookahead symbol.  */
+/* The semantic value of the look-ahead symbol.  */
 YYSTYPE yylval;
 
 /* Number of syntax errors so far.  */
 int yynerrs;
 
 
+
 /*----------.
 | yyparse.  |
 `----------*/
@@ -1490,37 +1443,14 @@ yyparse ()
 #endif
 #endif
 {
-    int yystate;
-    /* Number of tokens to shift before error messages enabled.  */
-    int yyerrstatus;
-
-    /* The stacks and their tools:
-       `yyss': related to states.
-       `yyvs': related to semantic values.
-
-       Refer to the stacks thru separate pointers, to allow yyoverflow
-       to reallocate them elsewhere.  */
-
-    /* The state stack.  */
-    yytype_int16 yyssa[YYINITDEPTH];
-    yytype_int16 *yyss;
-    yytype_int16 *yyssp;
-
-    /* The semantic value stack.  */
-    YYSTYPE yyvsa[YYINITDEPTH];
-    YYSTYPE *yyvs;
-    YYSTYPE *yyvsp;
-
-    YYSIZE_T yystacksize;
-
+  
+  int yystate;
   int yyn;
   int yyresult;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken;
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
 #if YYERROR_VERBOSE
   /* Buffer for error messages, and its allocated size.  */
   char yymsgbuf[128];
@@ -1528,28 +1458,51 @@ yyparse ()
   YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
 #endif
 
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  YYSTYPE *yyvsp;
+
+
+
 #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
   /* The number of symbols on the RHS of the reduced rule.
      Keep to zero when no symbol should be popped.  */
   int yylen = 0;
 
-  yytoken = 0;
-  yyss = yyssa;
-  yyvs = yyvsa;
-  yystacksize = YYINITDEPTH;
-
   YYDPRINTF ((stderr, "Starting parse\n"));
 
   yystate = 0;
   yyerrstatus = 0;
   yynerrs = 0;
-  yychar = YYEMPTY; /* Cause a token to be read.  */
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
 
   /* Initialize stack pointers.
      Waste one element of value and location stack
      so that they stay on the same level as the state stack.
      The wasted elements are never initialized.  */
+
   yyssp = yyss;
   yyvsp = yyvs;
 
@@ -1579,6 +1532,7 @@ yyparse ()
 	YYSTYPE *yyvs1 = yyvs;
 	yytype_int16 *yyss1 = yyss;
 
+
 	/* Each stack pointer address is followed by the size of the
 	   data in use in that stack, in bytes.  This used to be a
 	   conditional around just the two extra args, but that might
@@ -1586,6 +1540,7 @@ yyparse ()
 	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
+
 		    &yystacksize);
 
 	yyss = yyss1;
@@ -1608,8 +1563,9 @@ yyparse ()
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
 	  goto yyexhaustedlab;
-	YYSTACK_RELOCATE (yyss_alloc, yyss);
-	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
 #  undef YYSTACK_RELOCATE
 	if (yyss1 != yyssa)
 	  YYSTACK_FREE (yyss1);
@@ -1620,6 +1576,7 @@ yyparse ()
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
 
+
       YYDPRINTF ((stderr, "Stack size increased to %lu\n",
 		  (unsigned long int) yystacksize));
 
@@ -1629,9 +1586,6 @@ yyparse ()
 
   YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
-  if (yystate == YYFINAL)
-    YYACCEPT;
-
   goto yybackup;
 
 /*-----------.
@@ -1640,16 +1594,16 @@ yyparse ()
 yybackup:
 
   /* Do appropriate processing given the current state.  Read a
-     lookahead token if we need one and don't already have one.  */
+     look-ahead token if we need one and don't already have one.  */
 
-  /* First try to decide what to do without reference to lookahead token.  */
+  /* First try to decide what to do without reference to look-ahead token.  */
   yyn = yypact[yystate];
-  if (yypact_value_is_default (yyn))
+  if (yyn == YYPACT_NINF)
     goto yydefault;
 
-  /* Not known => get a lookahead token if don't already have one.  */
+  /* Not known => get a look-ahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
@@ -1675,22 +1629,26 @@ yybackup:
   yyn = yytable[yyn];
   if (yyn <= 0)
     {
-      if (yytable_value_is_error (yyn))
-        goto yyerrlab;
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
 
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
-  /* Shift the lookahead token.  */
+  /* Shift the look-ahead token.  */
   YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
 
-  /* Discard the shifted token.  */
-  yychar = YYEMPTY;
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
 
   yystate = yyn;
   *++yyvsp = yylval;
@@ -1730,8 +1688,6 @@ yyreduce:
   switch (yyn)
     {
         case 3:
-
-/* Line 1806 of yacc.c  */
 #line 71 "a.y"
     {
 		stmtline = lineno;
@@ -1739,8 +1695,6 @@ yyreduce:
     break;
 
   case 5:
-
-/* Line 1806 of yacc.c  */
 #line 78 "a.y"
     {
 		if((yyvsp[(1) - (2)].sym)->value != pc)
@@ -1750,8 +1704,6 @@ yyreduce:
     break;
 
   case 7:
-
-/* Line 1806 of yacc.c  */
 #line 85 "a.y"
     {
 		(yyvsp[(1) - (2)].sym)->type = LLAB;
@@ -1760,8 +1712,6 @@ yyreduce:
     break;
 
   case 12:
-
-/* Line 1806 of yacc.c  */
 #line 96 "a.y"
     {
 		(yyvsp[(1) - (3)].sym)->type = LVAR;
@@ -1770,8 +1720,6 @@ yyreduce:
     break;
 
   case 13:
-
-/* Line 1806 of yacc.c  */
 #line 101 "a.y"
     {
 		if((yyvsp[(1) - (3)].sym)->value != (yyvsp[(3) - (3)].lval))
@@ -1781,586 +1729,462 @@ yyreduce:
     break;
 
   case 14:
-
-/* Line 1806 of yacc.c  */
 #line 106 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 15:
-
-/* Line 1806 of yacc.c  */
 #line 107 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 16:
-
-/* Line 1806 of yacc.c  */
 #line 108 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 17:
-
-/* Line 1806 of yacc.c  */
 #line 109 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 18:
-
-/* Line 1806 of yacc.c  */
 #line 110 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 19:
-
-/* Line 1806 of yacc.c  */
 #line 111 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 20:
-
-/* Line 1806 of yacc.c  */
 #line 112 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 21:
-
-/* Line 1806 of yacc.c  */
 #line 113 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 22:
-
-/* Line 1806 of yacc.c  */
 #line 114 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 23:
-
-/* Line 1806 of yacc.c  */
 #line 115 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 24:
-
-/* Line 1806 of yacc.c  */
 #line 116 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 25:
-
-/* Line 1806 of yacc.c  */
 #line 117 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 26:
-
-/* Line 1806 of yacc.c  */
 #line 118 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 27:
-
-/* Line 1806 of yacc.c  */
 #line 119 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 28:
-
-/* Line 1806 of yacc.c  */
 #line 120 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 29:
-
-/* Line 1806 of yacc.c  */
 #line 121 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 30:
-
-/* Line 1806 of yacc.c  */
 #line 122 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 31:
-
-/* Line 1806 of yacc.c  */
 #line 123 "a.y"
-    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].gen2)); }
+    { outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr2)); }
     break;
 
   case 32:
-
-/* Line 1806 of yacc.c  */
 #line 126 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = nullgen;
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = nullgen;
 	}
     break;
 
   case 33:
-
-/* Line 1806 of yacc.c  */
 #line 131 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = nullgen;
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = nullgen;
 	}
     break;
 
   case 34:
-
-/* Line 1806 of yacc.c  */
 #line 138 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 35:
-
-/* Line 1806 of yacc.c  */
 #line 145 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 36:
-
-/* Line 1806 of yacc.c  */
 #line 152 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (2)].gen);
-		(yyval.gen2).to = nullgen;
+		(yyval.addr2).from = (yyvsp[(1) - (2)].addr);
+		(yyval.addr2).to = nullgen;
 	}
     break;
 
   case 37:
-
-/* Line 1806 of yacc.c  */
 #line 157 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (1)].gen);
-		(yyval.gen2).to = nullgen;
+		(yyval.addr2).from = (yyvsp[(1) - (1)].addr);
+		(yyval.addr2).to = nullgen;
 	}
     break;
 
   case 38:
-
-/* Line 1806 of yacc.c  */
 #line 164 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = (yyvsp[(2) - (2)].gen);
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = (yyvsp[(2) - (2)].addr);
 	}
     break;
 
   case 39:
-
-/* Line 1806 of yacc.c  */
 #line 169 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = (yyvsp[(1) - (1)].gen);
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = (yyvsp[(1) - (1)].addr);
 	}
     break;
 
   case 40:
-
-/* Line 1806 of yacc.c  */
 #line 176 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = (yyvsp[(2) - (2)].gen);
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = (yyvsp[(2) - (2)].addr);
 	}
     break;
 
   case 41:
-
-/* Line 1806 of yacc.c  */
 #line 181 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = (yyvsp[(1) - (1)].gen);
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = (yyvsp[(1) - (1)].addr);
 	}
     break;
 
   case 42:
-
-/* Line 1806 of yacc.c  */
 #line 186 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 43:
-
-/* Line 1806 of yacc.c  */
 #line 193 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (5)].gen);
-		(yyval.gen2).from.scale = (yyvsp[(3) - (5)].lval);
-		(yyval.gen2).to = (yyvsp[(5) - (5)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (5)].addr);
+		(yyval.addr2).from.scale = (yyvsp[(3) - (5)].lval);
+		(yyval.addr2).to = (yyvsp[(5) - (5)].addr);
 	}
     break;
 
   case 44:
-
-/* Line 1806 of yacc.c  */
 #line 201 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 45:
-
-/* Line 1806 of yacc.c  */
 #line 206 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (5)].gen);
-		(yyval.gen2).from.scale = (yyvsp[(3) - (5)].lval);
-		(yyval.gen2).to = (yyvsp[(5) - (5)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (5)].addr);
+		(yyval.addr2).from.scale = (yyvsp[(3) - (5)].lval);
+		(yyval.addr2).to = (yyvsp[(5) - (5)].addr);
 	}
     break;
 
   case 46:
-
-/* Line 1806 of yacc.c  */
 #line 214 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = (yyvsp[(2) - (2)].gen);
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = (yyvsp[(2) - (2)].addr);
 	}
     break;
 
   case 47:
-
-/* Line 1806 of yacc.c  */
 #line 219 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = (yyvsp[(1) - (1)].gen);
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = (yyvsp[(1) - (1)].addr);
 	}
     break;
 
   case 48:
-
-/* Line 1806 of yacc.c  */
 #line 224 "a.y"
     {
-		(yyval.gen2).from = nullgen;
-		(yyval.gen2).to = (yyvsp[(2) - (2)].gen);
-		(yyval.gen2).to.index = (yyvsp[(2) - (2)].gen).type;
-		(yyval.gen2).to.type = D_INDIR+D_ADDR;
+		(yyval.addr2).from = nullgen;
+		(yyval.addr2).to = (yyvsp[(2) - (2)].addr);
+		(yyval.addr2).to.index = (yyvsp[(2) - (2)].addr).type;
+		(yyval.addr2).to.type = D_INDIR+D_ADDR;
 	}
     break;
 
   case 51:
-
-/* Line 1806 of yacc.c  */
 #line 237 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 52:
-
-/* Line 1806 of yacc.c  */
 #line 242 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (5)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (5)].gen);
-		if((yyval.gen2).from.index != D_NONE)
+		(yyval.addr2).from = (yyvsp[(1) - (5)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (5)].addr);
+		if((yyval.addr2).from.index != D_NONE)
 			yyerror("dp shift with lhs index");
-		(yyval.gen2).from.index = (yyvsp[(5) - (5)].lval);
+		(yyval.addr2).from.index = (yyvsp[(5) - (5)].lval);
 	}
     break;
 
   case 53:
-
-/* Line 1806 of yacc.c  */
 #line 252 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 54:
-
-/* Line 1806 of yacc.c  */
 #line 257 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (5)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (5)].gen);
-		if((yyval.gen2).to.index != D_NONE)
+		(yyval.addr2).from = (yyvsp[(1) - (5)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (5)].addr);
+		if((yyval.addr2).to.index != D_NONE)
 			yyerror("dp move with lhs index");
-		(yyval.gen2).to.index = (yyvsp[(5) - (5)].lval);
+		(yyval.addr2).to.index = (yyvsp[(5) - (5)].lval);
 	}
     break;
 
   case 55:
-
-/* Line 1806 of yacc.c  */
 #line 267 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (2)].gen);
-		(yyval.gen2).to = nullgen;
+		(yyval.addr2).from = (yyvsp[(1) - (2)].addr);
+		(yyval.addr2).to = nullgen;
 	}
     break;
 
   case 56:
-
-/* Line 1806 of yacc.c  */
 #line 272 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (1)].gen);
-		(yyval.gen2).to = nullgen;
+		(yyval.addr2).from = (yyvsp[(1) - (1)].addr);
+		(yyval.addr2).to = nullgen;
 	}
     break;
 
   case 57:
-
-/* Line 1806 of yacc.c  */
 #line 277 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 58:
-
-/* Line 1806 of yacc.c  */
 #line 284 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 59:
-
-/* Line 1806 of yacc.c  */
 #line 289 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (5)].gen);
-		(yyval.gen2).from.scale = (yyvsp[(3) - (5)].lval);
-		(yyval.gen2).to = (yyvsp[(5) - (5)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (5)].addr);
+		(yyval.addr2).from.scale = (yyvsp[(3) - (5)].lval);
+		(yyval.addr2).to = (yyvsp[(5) - (5)].addr);
 	}
     break;
 
   case 60:
-
-/* Line 1806 of yacc.c  */
 #line 297 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(1) - (5)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (5)].gen);
-		(yyval.gen2).to.offset = (yyvsp[(5) - (5)].lval);
+		(yyval.addr2).from = (yyvsp[(1) - (5)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (5)].addr);
+		(yyval.addr2).to.offset = (yyvsp[(5) - (5)].lval);
 	}
     break;
 
   case 61:
-
-/* Line 1806 of yacc.c  */
 #line 305 "a.y"
     {
-		(yyval.gen2).from = (yyvsp[(3) - (5)].gen);
-		(yyval.gen2).to = (yyvsp[(5) - (5)].gen);
-		if((yyvsp[(1) - (5)].gen).type != D_CONST)
+		(yyval.addr2).from = (yyvsp[(3) - (5)].addr);
+		(yyval.addr2).to = (yyvsp[(5) - (5)].addr);
+		if((yyvsp[(1) - (5)].addr).type != D_CONST)
 			yyerror("illegal constant");
-		(yyval.gen2).to.offset = (yyvsp[(1) - (5)].gen).offset;
+		(yyval.addr2).to.offset = (yyvsp[(1) - (5)].addr).offset;
 	}
     break;
 
   case 62:
-
-/* Line 1806 of yacc.c  */
 #line 315 "a.y"
     {
-		if((yyvsp[(1) - (3)].gen).type != D_CONST || (yyvsp[(3) - (3)].gen).type != D_CONST)
+		if((yyvsp[(1) - (3)].addr).type != D_CONST || (yyvsp[(3) - (3)].addr).type != D_CONST)
 			yyerror("arguments to PCDATA must be integer constants");
-		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
-		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
 	}
     break;
 
   case 63:
-
-/* Line 1806 of yacc.c  */
 #line 324 "a.y"
     {
-		if((yyvsp[(1) - (3)].gen).type != D_CONST)
+		if((yyvsp[(1) - (3)].addr).type != D_CONST)
 			yyerror("index for FUNCDATA must be integer constant");
-		if((yyvsp[(3) - (3)].gen).type != D_EXTERN && (yyvsp[(3) - (3)].gen).type != D_STATIC)
+		if((yyvsp[(3) - (3)].addr).type != D_EXTERN && (yyvsp[(3) - (3)].addr).type != D_STATIC)
 			yyerror("value for FUNCDATA must be symbol reference");
- 		(yyval.gen2).from = (yyvsp[(1) - (3)].gen);
- 		(yyval.gen2).to = (yyvsp[(3) - (3)].gen);
+ 		(yyval.addr2).from = (yyvsp[(1) - (3)].addr);
+ 		(yyval.addr2).to = (yyvsp[(3) - (3)].addr);
  	}
     break;
 
   case 68:
-
-/* Line 1806 of yacc.c  */
 #line 341 "a.y"
     {
-		(yyval.gen) = (yyvsp[(2) - (2)].gen);
+		(yyval.addr) = (yyvsp[(2) - (2)].addr);
 	}
     break;
 
   case 69:
-
-/* Line 1806 of yacc.c  */
 #line 345 "a.y"
     {
-		(yyval.gen) = (yyvsp[(2) - (2)].gen);
+		(yyval.addr) = (yyvsp[(2) - (2)].addr);
 	}
     break;
 
   case 75:
-
-/* Line 1806 of yacc.c  */
 #line 358 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_BRANCH;
-		(yyval.gen).offset = (yyvsp[(1) - (4)].lval) + pc;
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_BRANCH;
+		(yyval.addr).offset = (yyvsp[(1) - (4)].lval) + pc;
 	}
     break;
 
   case 76:
-
-/* Line 1806 of yacc.c  */
 #line 364 "a.y"
     {
-		(yyval.gen) = nullgen;
+		(yyval.addr) = nullgen;
 		if(pass == 2)
 			yyerror("undefined label: %s", (yyvsp[(1) - (2)].sym)->name);
-		(yyval.gen).type = D_BRANCH;
-		(yyval.gen).sym = (yyvsp[(1) - (2)].sym);
-		(yyval.gen).offset = (yyvsp[(2) - (2)].lval);
+		(yyval.addr).type = D_BRANCH;
+		(yyval.addr).offset = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 77:
-
-/* Line 1806 of yacc.c  */
-#line 373 "a.y"
+#line 372 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_BRANCH;
-		(yyval.gen).sym = (yyvsp[(1) - (2)].sym);
-		(yyval.gen).offset = (yyvsp[(1) - (2)].sym)->value + (yyvsp[(2) - (2)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_BRANCH;
+		(yyval.addr).offset = (yyvsp[(1) - (2)].sym)->value + (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 78:
-
-/* Line 1806 of yacc.c  */
-#line 382 "a.y"
+#line 380 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 79:
-
-/* Line 1806 of yacc.c  */
-#line 387 "a.y"
+#line 385 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 80:
-
-/* Line 1806 of yacc.c  */
-#line 392 "a.y"
+#line 390 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 81:
-
-/* Line 1806 of yacc.c  */
-#line 397 "a.y"
+#line 395 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 82:
-
-/* Line 1806 of yacc.c  */
-#line 402 "a.y"
+#line 400 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_SP;
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_SP;
 	}
     break;
 
   case 83:
-
-/* Line 1806 of yacc.c  */
-#line 407 "a.y"
+#line 405 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 84:
-
-/* Line 1806 of yacc.c  */
-#line 414 "a.y"
+#line 412 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_CONST;
-		(yyval.gen).offset = (yyvsp[(2) - (2)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_CONST;
+		(yyval.addr).offset = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 85:
-
-/* Line 1806 of yacc.c  */
-#line 420 "a.y"
+#line 418 "a.y"
     {
-		(yyval.gen) = (yyvsp[(2) - (2)].gen);
-		(yyval.gen).index = (yyvsp[(2) - (2)].gen).type;
-		(yyval.gen).type = D_ADDR;
+		(yyval.addr) = (yyvsp[(2) - (2)].addr);
+		(yyval.addr).index = (yyvsp[(2) - (2)].addr).type;
+		(yyval.addr).type = D_ADDR;
 		/*
 		if($2.type == D_AUTO || $2.type == D_PARAM)
 			yyerror("constant cannot be automatic: %s",
@@ -2370,76 +2194,62 @@ yyreduce:
     break;
 
   case 86:
-
-/* Line 1806 of yacc.c  */
-#line 431 "a.y"
+#line 429 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_SCONST;
-		memcpy((yyval.gen).sval, (yyvsp[(2) - (2)].sval), sizeof((yyval.gen).sval));
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_SCONST;
+		memcpy((yyval.addr).u.sval, (yyvsp[(2) - (2)].sval), sizeof((yyval.addr).u.sval));
 	}
     break;
 
   case 87:
-
-/* Line 1806 of yacc.c  */
-#line 437 "a.y"
+#line 435 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_FCONST;
-		(yyval.gen).dval = (yyvsp[(2) - (2)].dval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_FCONST;
+		(yyval.addr).u.dval = (yyvsp[(2) - (2)].dval);
 	}
     break;
 
   case 88:
-
-/* Line 1806 of yacc.c  */
-#line 443 "a.y"
+#line 441 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_FCONST;
-		(yyval.gen).dval = (yyvsp[(3) - (4)].dval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_FCONST;
+		(yyval.addr).u.dval = (yyvsp[(3) - (4)].dval);
 	}
     break;
 
   case 89:
-
-/* Line 1806 of yacc.c  */
-#line 449 "a.y"
+#line 447 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_FCONST;
-		(yyval.gen).dval = -(yyvsp[(4) - (5)].dval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_FCONST;
+		(yyval.addr).u.dval = -(yyvsp[(4) - (5)].dval);
 	}
     break;
 
   case 90:
-
-/* Line 1806 of yacc.c  */
-#line 455 "a.y"
+#line 453 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_FCONST;
-		(yyval.gen).dval = -(yyvsp[(3) - (3)].dval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_FCONST;
+		(yyval.addr).u.dval = -(yyvsp[(3) - (3)].dval);
 	}
     break;
 
   case 91:
-
-/* Line 1806 of yacc.c  */
-#line 463 "a.y"
+#line 461 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_CONST2;
-		(yyval.gen).offset = (yyvsp[(2) - (2)].con2).v1;
-		(yyval.gen).offset2 = (yyvsp[(2) - (2)].con2).v2;
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_CONST2;
+		(yyval.addr).offset = (yyvsp[(2) - (2)].con2).v1;
+		(yyval.addr).offset2 = (yyvsp[(2) - (2)].con2).v2;
 	}
     break;
 
   case 92:
-
-/* Line 1806 of yacc.c  */
-#line 472 "a.y"
+#line 470 "a.y"
     {
 		(yyval.con2).v1 = (yyvsp[(1) - (1)].lval);
 		(yyval.con2).v2 = ArgsSizeUnknown;
@@ -2447,9 +2257,7 @@ yyreduce:
     break;
 
   case 93:
-
-/* Line 1806 of yacc.c  */
-#line 477 "a.y"
+#line 475 "a.y"
     {
 		(yyval.con2).v1 = -(yyvsp[(2) - (2)].lval);
 		(yyval.con2).v2 = ArgsSizeUnknown;
@@ -2457,9 +2265,7 @@ yyreduce:
     break;
 
   case 94:
-
-/* Line 1806 of yacc.c  */
-#line 482 "a.y"
+#line 480 "a.y"
     {
 		(yyval.con2).v1 = (yyvsp[(1) - (3)].lval);
 		(yyval.con2).v2 = (yyvsp[(3) - (3)].lval);
@@ -2467,9 +2273,7 @@ yyreduce:
     break;
 
   case 95:
-
-/* Line 1806 of yacc.c  */
-#line 487 "a.y"
+#line 485 "a.y"
     {
 		(yyval.con2).v1 = -(yyvsp[(2) - (4)].lval);
 		(yyval.con2).v2 = (yyvsp[(4) - (4)].lval);
@@ -2477,370 +2281,290 @@ yyreduce:
     break;
 
   case 98:
-
-/* Line 1806 of yacc.c  */
-#line 498 "a.y"
+#line 496 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+D_NONE;
-		(yyval.gen).offset = (yyvsp[(1) - (1)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+D_NONE;
+		(yyval.addr).offset = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 99:
-
-/* Line 1806 of yacc.c  */
-#line 504 "a.y"
+#line 502 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+(yyvsp[(3) - (4)].lval);
-		(yyval.gen).offset = (yyvsp[(1) - (4)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+(yyvsp[(3) - (4)].lval);
+		(yyval.addr).offset = (yyvsp[(1) - (4)].lval);
 	}
     break;
 
   case 100:
-
-/* Line 1806 of yacc.c  */
-#line 510 "a.y"
+#line 508 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+D_SP;
-		(yyval.gen).offset = (yyvsp[(1) - (4)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+D_SP;
+		(yyval.addr).offset = (yyvsp[(1) - (4)].lval);
 	}
     break;
 
   case 101:
-
-/* Line 1806 of yacc.c  */
-#line 516 "a.y"
+#line 514 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+D_NONE;
-		(yyval.gen).offset = (yyvsp[(1) - (6)].lval);
-		(yyval.gen).index = (yyvsp[(3) - (6)].lval);
-		(yyval.gen).scale = (yyvsp[(5) - (6)].lval);
-		checkscale((yyval.gen).scale);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+D_NONE;
+		(yyval.addr).offset = (yyvsp[(1) - (6)].lval);
+		(yyval.addr).index = (yyvsp[(3) - (6)].lval);
+		(yyval.addr).scale = (yyvsp[(5) - (6)].lval);
+		checkscale((yyval.addr).scale);
 	}
     break;
 
   case 102:
-
-/* Line 1806 of yacc.c  */
-#line 525 "a.y"
+#line 523 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+(yyvsp[(3) - (9)].lval);
-		(yyval.gen).offset = (yyvsp[(1) - (9)].lval);
-		(yyval.gen).index = (yyvsp[(6) - (9)].lval);
-		(yyval.gen).scale = (yyvsp[(8) - (9)].lval);
-		checkscale((yyval.gen).scale);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+(yyvsp[(3) - (9)].lval);
+		(yyval.addr).offset = (yyvsp[(1) - (9)].lval);
+		(yyval.addr).index = (yyvsp[(6) - (9)].lval);
+		(yyval.addr).scale = (yyvsp[(8) - (9)].lval);
+		checkscale((yyval.addr).scale);
 	}
     break;
 
   case 103:
-
-/* Line 1806 of yacc.c  */
-#line 534 "a.y"
+#line 532 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+(yyvsp[(3) - (9)].lval);
-		(yyval.gen).offset = (yyvsp[(1) - (9)].lval);
-		(yyval.gen).index = (yyvsp[(6) - (9)].lval);
-		(yyval.gen).scale = (yyvsp[(8) - (9)].lval);
-		checkscale((yyval.gen).scale);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+(yyvsp[(3) - (9)].lval);
+		(yyval.addr).offset = (yyvsp[(1) - (9)].lval);
+		(yyval.addr).index = (yyvsp[(6) - (9)].lval);
+		(yyval.addr).scale = (yyvsp[(8) - (9)].lval);
+		checkscale((yyval.addr).scale);
 	}
     break;
 
   case 104:
-
-/* Line 1806 of yacc.c  */
-#line 543 "a.y"
+#line 541 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+(yyvsp[(2) - (3)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+(yyvsp[(2) - (3)].lval);
 	}
     break;
 
   case 105:
-
-/* Line 1806 of yacc.c  */
-#line 548 "a.y"
+#line 546 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+D_SP;
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+D_SP;
 	}
     break;
 
   case 106:
-
-/* Line 1806 of yacc.c  */
-#line 553 "a.y"
+#line 551 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+(yyvsp[(3) - (4)].lval);
-		(yyval.gen).offset = (yyvsp[(1) - (4)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+(yyvsp[(3) - (4)].lval);
+		(yyval.addr).offset = (yyvsp[(1) - (4)].lval);
 	}
     break;
 
   case 107:
-
-/* Line 1806 of yacc.c  */
-#line 559 "a.y"
+#line 557 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+D_NONE;
-		(yyval.gen).index = (yyvsp[(2) - (5)].lval);
-		(yyval.gen).scale = (yyvsp[(4) - (5)].lval);
-		checkscale((yyval.gen).scale);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+D_NONE;
+		(yyval.addr).index = (yyvsp[(2) - (5)].lval);
+		(yyval.addr).scale = (yyvsp[(4) - (5)].lval);
+		checkscale((yyval.addr).scale);
 	}
     break;
 
   case 108:
-
-/* Line 1806 of yacc.c  */
-#line 567 "a.y"
+#line 565 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_INDIR+(yyvsp[(2) - (8)].lval);
-		(yyval.gen).index = (yyvsp[(5) - (8)].lval);
-		(yyval.gen).scale = (yyvsp[(7) - (8)].lval);
-		checkscale((yyval.gen).scale);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_INDIR+(yyvsp[(2) - (8)].lval);
+		(yyval.addr).index = (yyvsp[(5) - (8)].lval);
+		(yyval.addr).scale = (yyvsp[(7) - (8)].lval);
+		checkscale((yyval.addr).scale);
 	}
     break;
 
   case 109:
-
-/* Line 1806 of yacc.c  */
-#line 577 "a.y"
+#line 575 "a.y"
     {
-		(yyval.gen) = (yyvsp[(1) - (1)].gen);
+		(yyval.addr) = (yyvsp[(1) - (1)].addr);
 	}
     break;
 
   case 110:
-
-/* Line 1806 of yacc.c  */
-#line 581 "a.y"
+#line 579 "a.y"
     {
-		(yyval.gen) = (yyvsp[(1) - (6)].gen);
-		(yyval.gen).index = (yyvsp[(3) - (6)].lval);
-		(yyval.gen).scale = (yyvsp[(5) - (6)].lval);
-		checkscale((yyval.gen).scale);
+		(yyval.addr) = (yyvsp[(1) - (6)].addr);
+		(yyval.addr).index = (yyvsp[(3) - (6)].lval);
+		(yyval.addr).scale = (yyvsp[(5) - (6)].lval);
+		checkscale((yyval.addr).scale);
 	}
     break;
 
   case 111:
-
-/* Line 1806 of yacc.c  */
-#line 590 "a.y"
+#line 588 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = (yyvsp[(4) - (5)].lval);
-		(yyval.gen).sym = (yyvsp[(1) - (5)].sym);
-		(yyval.gen).offset = (yyvsp[(2) - (5)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = (yyvsp[(4) - (5)].lval);
+		(yyval.addr).sym = linklookup(ctxt, (yyvsp[(1) - (5)].sym)->name, 0);
+		(yyval.addr).offset = (yyvsp[(2) - (5)].lval);
 	}
     break;
 
   case 112:
-
-/* Line 1806 of yacc.c  */
-#line 597 "a.y"
+#line 595 "a.y"
     {
-		(yyval.gen) = nullgen;
-		(yyval.gen).type = D_STATIC;
-		(yyval.gen).sym = (yyvsp[(1) - (7)].sym);
-		(yyval.gen).offset = (yyvsp[(4) - (7)].lval);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = D_STATIC;
+		(yyval.addr).sym = linklookup(ctxt, (yyvsp[(1) - (7)].sym)->name, 1);
+		(yyval.addr).offset = (yyvsp[(4) - (7)].lval);
 	}
     break;
 
   case 113:
-
-/* Line 1806 of yacc.c  */
-#line 605 "a.y"
+#line 603 "a.y"
     {
 		(yyval.lval) = 0;
 	}
     break;
 
   case 114:
-
-/* Line 1806 of yacc.c  */
-#line 609 "a.y"
+#line 607 "a.y"
     {
 		(yyval.lval) = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 115:
-
-/* Line 1806 of yacc.c  */
-#line 613 "a.y"
+#line 611 "a.y"
     {
 		(yyval.lval) = -(yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 117:
-
-/* Line 1806 of yacc.c  */
-#line 620 "a.y"
+#line 618 "a.y"
     {
 		(yyval.lval) = D_AUTO;
 	}
     break;
 
   case 120:
-
-/* Line 1806 of yacc.c  */
-#line 628 "a.y"
+#line 626 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (1)].sym)->value;
 	}
     break;
 
   case 121:
-
-/* Line 1806 of yacc.c  */
-#line 632 "a.y"
+#line 630 "a.y"
     {
 		(yyval.lval) = -(yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 122:
-
-/* Line 1806 of yacc.c  */
-#line 636 "a.y"
+#line 634 "a.y"
     {
 		(yyval.lval) = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 123:
-
-/* Line 1806 of yacc.c  */
-#line 640 "a.y"
+#line 638 "a.y"
     {
 		(yyval.lval) = ~(yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 124:
-
-/* Line 1806 of yacc.c  */
-#line 644 "a.y"
+#line 642 "a.y"
     {
 		(yyval.lval) = (yyvsp[(2) - (3)].lval);
 	}
     break;
 
   case 126:
-
-/* Line 1806 of yacc.c  */
-#line 651 "a.y"
+#line 649 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) + (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 127:
-
-/* Line 1806 of yacc.c  */
-#line 655 "a.y"
+#line 653 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) - (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 128:
-
-/* Line 1806 of yacc.c  */
-#line 659 "a.y"
+#line 657 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) * (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 129:
-
-/* Line 1806 of yacc.c  */
-#line 663 "a.y"
+#line 661 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) / (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 130:
-
-/* Line 1806 of yacc.c  */
-#line 667 "a.y"
+#line 665 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) % (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 131:
-
-/* Line 1806 of yacc.c  */
-#line 671 "a.y"
+#line 669 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (4)].lval) << (yyvsp[(4) - (4)].lval);
 	}
     break;
 
   case 132:
-
-/* Line 1806 of yacc.c  */
-#line 675 "a.y"
+#line 673 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (4)].lval) >> (yyvsp[(4) - (4)].lval);
 	}
     break;
 
   case 133:
-
-/* Line 1806 of yacc.c  */
-#line 679 "a.y"
+#line 677 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) & (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 134:
-
-/* Line 1806 of yacc.c  */
-#line 683 "a.y"
+#line 681 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) ^ (yyvsp[(3) - (3)].lval);
 	}
     break;
 
   case 135:
-
-/* Line 1806 of yacc.c  */
-#line 687 "a.y"
+#line 685 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) | (yyvsp[(3) - (3)].lval);
 	}
     break;
 
 
-
-/* Line 1806 of yacc.c  */
-#line 2831 "y.tab.c"
+/* Line 1267 of yacc.c.  */
+#line 2566 "y.tab.c"
       default: break;
     }
-  /* User semantic actions sometimes alter yychar, and that requires
-     that yytoken be updated with the new translation.  We take the
-     approach of translating immediately before every use of yytoken.
-     One alternative is translating here after every semantic action,
-     but that translation would be missed if the semantic action invokes
-     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
-     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
-     incorrect destructor might then be invoked immediately.  In the
-     case of YYERROR or YYBACKUP, subsequent parser actions might lead
-     to an incorrect destructor call or verbose syntax error message
-     before the lookahead is translated.  */
   YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
   YYPOPSTACK (yylen);
@@ -2849,6 +2573,7 @@ yyreduce:
 
   *++yyvsp = yyval;
 
+
   /* Now `shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
      number reduced by.  */
@@ -2868,10 +2593,6 @@ yyreduce:
 | yyerrlab -- here on detecting error |
 `------------------------------------*/
 yyerrlab:
-  /* Make sure we have latest lookahead translation.  See comments at
-     user semantic actions for why this is necessary.  */
-  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
-
   /* If not already recovering from an error, report this error.  */
   if (!yyerrstatus)
     {
@@ -2879,36 +2600,37 @@ yyerrlab:
 #if ! YYERROR_VERBOSE
       yyerror (YY_("syntax error"));
 #else
-# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
-                                        yyssp, yytoken)
       {
-        char const *yymsgp = YY_("syntax error");
-        int yysyntax_error_status;
-        yysyntax_error_status = YYSYNTAX_ERROR;
-        if (yysyntax_error_status == 0)
-          yymsgp = yymsg;
-        else if (yysyntax_error_status == 1)
-          {
-            if (yymsg != yymsgbuf)
-              YYSTACK_FREE (yymsg);
-            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
-            if (!yymsg)
-              {
-                yymsg = yymsgbuf;
-                yymsg_alloc = sizeof yymsgbuf;
-                yysyntax_error_status = 2;
-              }
-            else
-              {
-                yysyntax_error_status = YYSYNTAX_ERROR;
-                yymsgp = yymsg;
-              }
-          }
-        yyerror (yymsgp);
-        if (yysyntax_error_status == 2)
-          goto yyexhaustedlab;
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
       }
-# undef YYSYNTAX_ERROR
 #endif
     }
 
@@ -2916,7 +2638,7 @@ yyerrlab:
 
   if (yyerrstatus == 3)
     {
-      /* If just tried and failed to reuse lookahead token after an
+      /* If just tried and failed to reuse look-ahead token after an
 	 error, discard it.  */
 
       if (yychar <= YYEOF)
@@ -2933,7 +2655,7 @@ yyerrlab:
 	}
     }
 
-  /* Else will try to reuse lookahead token after shifting the error
+  /* Else will try to reuse look-ahead token after shifting the error
      token.  */
   goto yyerrlab1;
 
@@ -2967,7 +2689,7 @@ yyerrlab1:
   for (;;)
     {
       yyn = yypact[yystate];
-      if (!yypact_value_is_default (yyn))
+      if (yyn != YYPACT_NINF)
 	{
 	  yyn += YYTERROR;
 	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
@@ -2990,6 +2712,9 @@ yyerrlab1:
       YY_STACK_PRINT (yyss, yyssp);
     }
 
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
   *++yyvsp = yylval;
 
 
@@ -3014,7 +2739,7 @@ yyabortlab:
   yyresult = 1;
   goto yyreturn;
 
-#if !defined(yyoverflow) || YYERROR_VERBOSE
+#ifndef yyoverflow
 /*-------------------------------------------------.
 | yyexhaustedlab -- memory exhaustion comes here.  |
 `-------------------------------------------------*/
@@ -3025,14 +2750,9 @@ yyexhaustedlab:
 #endif
 
 yyreturn:
-  if (yychar != YYEMPTY)
-    {
-      /* Make sure we have latest lookahead translation.  See comments at
-         user semantic actions for why this is necessary.  */
-      yytoken = YYTRANSLATE (yychar);
-      yydestruct ("Cleanup: discarding lookahead",
-                  yytoken, &yylval);
-    }
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
   /* Do not reclaim the symbols of the rule which action triggered
      this YYABORT or YYACCEPT.  */
   YYPOPSTACK (yylen);
diff --git a/src/cmd/8a/y.tab.h b/src/cmd/8a/y.tab.h
index 14637cb33e..d191455487 100644
--- a/src/cmd/8a/y.tab.h
+++ b/src/cmd/8a/y.tab.h
@@ -1,21 +1,24 @@
-/* A Bison parser, made by GNU Bison 2.5.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Bison interface for Yacc-like parsers in C
-   
-      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
-   
-   This program is free software: you can redistribute it and/or modify
+/* Skeleton interface for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-   
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -26,11 +29,10 @@
    special exception, which will cause the skeleton and the resulting
    Bison output files to be licensed under the GNU General Public
    License without this special exception.
-   
+
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
-
 /* Tokens.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
@@ -112,11 +114,8 @@
 
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-{
-
-/* Line 2068 of yacc.c  */
 #line 38 "a.y"
-
+{
 	Sym	*sym;
 	int32	lval;
 	struct {
@@ -125,19 +124,16 @@ typedef union YYSTYPE
 	} con2;
 	double	dval;
 	char	sval[8];
-	Gen	gen;
-	Gen2	gen2;
-
-
-
-/* Line 2068 of yacc.c  */
-#line 135 "y.tab.h"
-} YYSTYPE;
-# define YYSTYPE_IS_TRIVIAL 1
+	Addr	addr;
+	Addr2	addr2;
+}
+/* Line 1529 of yacc.c.  */
+#line 132 "y.tab.h"
+	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
 #endif
 
 extern YYSTYPE yylval;
 
-
diff --git a/src/cmd/cc/lexbody b/src/cmd/cc/lexbody
index 9d293b0898..29ecc5c87c 100644
--- a/src/cmd/cc/lexbody
+++ b/src/cmd/cc/lexbody
@@ -209,7 +209,7 @@ newfile(char *s, int f)
 		errorexit();
 	}
 	fi.c = 0;
-	linehist(s, 0);
+	linklinehist(ctxt, lineno, s, 0);
 }
 
 Sym*
@@ -477,7 +477,7 @@ l1:
 		return LCONST;
 
 	case '"':
-		memcpy(yylval.sval, nullgen.sval, sizeof(yylval.sval));
+		memcpy(yylval.sval, nullgen.u.sval, sizeof(yylval.sval));
 		cp = yylval.sval;
 		c1 = 0;
 		for(;;) {
@@ -638,10 +638,6 @@ pinit(char *f)
 	pc = 0;
 	peekc = IGN;
 	sym = 1;
-	for(i=0; i<NSYM; i++) {
-		h[i].type = 0;
-		h[i].sym = S;
-	}
 	for(i=0; i<NHASH; i++)
 		for(s = hash[i]; s != S; s = s->link)
 			s->macro = 0;
@@ -661,7 +657,7 @@ loop:
 	fi.c = read(i->f, i->b, BUFSIZ) - 1;
 	if(fi.c < 0) {
 		close(i->f);
-		linehist(0, 0);
+		linklinehist(ctxt, lineno, 0, 0);
 		goto pop;
 	}
 	fi.p = i->b + 1;
@@ -709,67 +705,5 @@ yyerror(char *a, ...)
 void
 prfile(int32 l)
 {
-	int i, n;
-	Hist a[HISTSZ], *h;
-	int32 d;
-
-	n = 0;
-	for(h = hist; h != H; h = h->link) {
-		if(l < h->line)
-			break;
-		if(h->name) {
-			if(h->offset == 0) {
-				if(n >= 0 && n < HISTSZ)
-					a[n] = *h;
-				n++;
-				continue;
-			}
-			if(n > 0 && n < HISTSZ)
-				if(a[n-1].offset == 0) {
-					a[n] = *h;
-					n++;
-				} else
-					a[n-1] = *h;
-			continue;
-		}
-		n--;
-		if(n >= 0 && n < HISTSZ) {
-			d = h->line - a[n].line;
-			for(i=0; i<n; i++)
-				a[i].line += d;
-		}
-	}
-	if(n > HISTSZ)
-		n = HISTSZ;
-	for(i=0; i<n; i++)
-		print("%s:%ld ", a[i].name, (long)(l-a[i].line+a[i].offset+1));
-}
-
-void
-ieeedtod(Ieee *ieee, double native)
-{
-	double fr, ho, f;
-	int exp;
-
-	if(native < 0) {
-		ieeedtod(ieee, -native);
-		ieee->h |= 0x80000000L;
-		return;
-	}
-	if(native == 0) {
-		ieee->l = 0;
-		ieee->h = 0;
-		return;
-	}
-	fr = frexp(native, &exp);
-	f = 2097152L;		/* shouldn't use fp constants here */
-	fr = modf(fr*f, &ho);
-	ieee->h = ho;
-	ieee->h &= 0xfffffL;
-	ieee->h |= (exp+1022L) << 20;
-	f = 65536L;
-	fr = modf(fr*f, &ho);
-	ieee->l = ho;
-	ieee->l = (uint32)ieee->l << 16;
-	ieee->l |= (int32)(fr*f);
+	linkprfile(ctxt, l);
 }
