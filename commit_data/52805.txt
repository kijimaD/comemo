commit d7941030c94ea14e9f32a4777424387b7f505cef
Author: Michael Anthony Knyszek <mknyszek@google.com>
Date:   Thu Jun 2 19:06:27 2022 +0000

    runtime: only use CPU time from the current window in the GC CPU limiter
    
    Currently the GC CPU limiter consumes CPU time from a few pools, but
    because the events that flush to those pools may overlap, rather than be
    strictly contained within, the update window for the GC CPU limiter, the
    limiter's accounting is ultimately sloppy.
    
    This sloppiness complicates accounting for idle time more completely,
    and makes reasoning about the transient behavior of the GC CPU limiter
    much more difficult.
    
    To remedy this, this CL adds a field to the P struct that tracks the
    start time of any in-flight event the limiter might care about, along
    with information about the nature of that event. This timestamp is
    managed atomically so that the GC CPU limiter can come in and perform a
    read of the partial CPU time consumed by a given event. The limiter also
    updates the timestamp so that only what's left over is flushed by the
    event itself when it completes.
    
    The end result of this change is that, since the GC CPU limiter is aware
    of all past completed events, and all in-flight events, it can much more
    accurately collect the CPU time of events since the last update. There's
    still the possibility for skew, but any leftover time will be captured
    in the following update, and the magnitude of this leftover time is
    effectively bounded by the update period of the GC CPU limiter, which is
    much easier to consider.
    
    One caveat of managing this timestamp-type combo atomically is that they
    need to be packed in 64 bits. So, this CL gives up the top 3 bits of the
    timestamp and places the type information there. What this means is we
    effectively have only a 61-bit resolution timestamp. This is fine when
    the top 3 bits are the same between calls to nanotime, but becomes a
    problem on boundaries when those 3 bits change. These cases may cause
    hiccups in the GC CPU limiter by not accounting for some source of CPU
    time correctly, but with 61 bits of resolution this should be extremely
    rare. The rate of update is on the order of milliseconds, so at worst
    the runtime will be off of any given measurement by only a few
    CPU-milliseconds (and this is directly bounded by the rate of update).
    We're probably more inaccurate from the fact that we don't measure real
    CPU time but only approximate it.
    
    For #52890.
    
    Change-Id: I347f30ac9e2ba6061806c21dfe0193ef2ab3bbe9
    Reviewed-on: https://go-review.googlesource.com/c/go/+/410120
    Reviewed-by: Michael Pratt <mpratt@google.com>
    Run-TryBot: Michael Knyszek <mknyszek@google.com>
    TryBot-Result: Gopher Robot <gobot@golang.org>

 src/runtime/export_test.go |   1 +
 src/runtime/mgc.go         |   9 ++-
 src/runtime/mgclimit.go    | 171 +++++++++++++++++++++++++++++++++++++++++++++
 src/runtime/mgcmark.go     |   8 ++-
 src/runtime/mheap.go       |  18 ++++-
 src/runtime/runtime2.go    |   3 +
 6 files changed, 203 insertions(+), 7 deletions(-)
