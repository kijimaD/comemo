commit a453f28c70c7b2317c9c1096d1b32ebe7b01d021
Author: Russ Cox <rsc@golang.org>
Date:   Tue Jan 21 13:47:47 2014 -0500

    cmd/link: pclntab generation
    
    R=iant
    CC=golang-codereviews
    https://golang.org/cl/53820043
---
 src/cmd/link/pclntab.go                       |  480 +++++++
 src/cmd/link/pclntab_test.go                  |  334 +++++
 src/cmd/link/prog.go                          |    2 +
 src/cmd/link/runtime.go                       |   17 +
 src/cmd/link/testdata/Makefile                |   10 +
 src/cmd/link/testdata/genpcln.go              |  112 ++
 src/cmd/link/testdata/link.hello.darwin.amd64 |   54 +-
 src/cmd/link/testdata/pclntab.s               | 1751 +++++++++++++++++++++++++
 8 files changed, 2744 insertions(+), 16 deletions(-)

diff --git a/src/cmd/link/pclntab.go b/src/cmd/link/pclntab.go
new file mode 100644
index 0000000000..76675c9ab2
--- /dev/null
+++ b/src/cmd/link/pclntab.go
@@ -0,0 +1,480 @@
+// Copyright 2014 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Generation of runtime function information (pclntab).
+
+package main
+
+import (
+	"debug/goobj"
+	"encoding/binary"
+	"os"
+	"sort"
+)
+
+var zerofunc goobj.Func
+
+// pclntab collects the runtime function data for each function that will
+// be listed in the binary and builds a single table describing all functions.
+// This table is used at run time for stack traces and to look up PC-specific
+// information during garbage collection. The symbol created is named
+// "pclntab" for historical reasons; the scope of the table has grown to
+// include more than just PC/line number correspondences.
+// The table format is documented at http://golang.org/s/go12symtab.
+func (p *Prog) pclntab() {
+	// Count number of functions going into the binary,
+	// so that we can size the initial index correctly.
+	nfunc := 0
+	for _, sym := range p.SymOrder {
+		if sym.Kind != goobj.STEXT {
+			continue
+		}
+		nfunc++
+	}
+
+	// Table header.
+	buf := new(SymBuffer)
+	buf.Init(p)
+	buf.SetSize(8 + p.ptrsize)
+	off := 0
+	off = buf.Uint32(off, 0xfffffffb)
+	off = buf.Uint8(off, 0)
+	off = buf.Uint8(off, 0)
+	off = buf.Uint8(off, uint8(p.pcquantum))
+	off = buf.Uint8(off, uint8(p.ptrsize))
+	off = buf.Uint(off, uint64(nfunc), p.ptrsize)
+	indexOff := off
+	off += (nfunc*2 + 1) * p.ptrsize // function index, to be filled in
+	off += 4                         // file table start offset, to be filled in
+	buf.SetSize(off)
+
+	// One-file cache for reading PCData tables from package files.
+	// TODO(rsc): Better I/O strategy.
+	var (
+		file  *os.File
+		fname string
+	)
+
+	// Files gives the file numbering for source file names recorded
+	// in the binary.
+	files := make(map[string]int)
+
+	// Build the table, build the index, and build the file name numbering.
+	// The loop here must visit functions in the same order that they will
+	// be stored in the binary, or else binary search over the index will fail.
+	// The runtime checks that the index is sorted properly at program start time.
+	var lastSym *Sym
+	for _, sym := range p.SymOrder {
+		if sym.Kind != goobj.STEXT {
+			continue
+		}
+		lastSym = sym
+
+		// Treat no recorded function information same as all zeros.
+		f := sym.Func
+		if f == nil {
+			f = &zerofunc
+		}
+
+		// Open package file if needed, for reading PC data.
+		if fname != sym.Package.File {
+			if file != nil {
+				file.Close()
+			}
+			var err error
+			file, err = os.Open(sym.Package.File)
+			if err != nil {
+				p.errorf("%v: %v", sym, err)
+				return
+			}
+			fname = sym.Package.File
+		}
+
+		// off is the offset of the table entry where we're going to write
+		// the encoded form of Func.
+		// indexOff is the current position in the table index;
+		// we add an entry in the index pointing at off.
+		off = (buf.Size() + p.ptrsize - 1) &^ (p.ptrsize - 1)
+		indexOff = buf.Addr(indexOff, sym.SymID, 0)
+		indexOff = buf.Uint(indexOff, uint64(off), p.ptrsize)
+
+		// The Func encoding starts with a header giving offsets
+		// to data blobs, and then the data blobs themselves.
+		// end gives the current write position for the data blobs.
+		end := off + p.ptrsize + 3*4 + 5*4 + len(f.PCData)*4 + len(f.FuncData)*p.ptrsize
+		if len(f.FuncData) > 0 {
+			end += -end & (p.ptrsize - 1)
+		}
+		buf.SetSize(end)
+
+		// entry uintptr
+		// name int32
+		// args int32
+		// frame int32
+		//
+		// The frame recorded in the object file is
+		// the frame size used in an assembly listing, which does
+		// not include the caller PC on the stack.
+		// The frame size we want to list here is the delta from
+		// this function's SP to its caller's SP, which does include
+		// the caller PC. Add p.ptrsize to f.Frame to adjust.
+		// TODO(rsc): Record the same frame size in the object file.
+		off = buf.Addr(off, sym.SymID, 0)
+		off = buf.Uint32(off, uint32(addString(buf, sym.Name)))
+		off = buf.Uint32(off, uint32(f.Args))
+		off = buf.Uint32(off, uint32(f.Frame+p.ptrsize))
+
+		// pcdata
+		off = buf.Uint32(off, uint32(addPCTable(p, buf, file, f.PCSP)))
+		off = buf.Uint32(off, uint32(addPCFileTable(p, buf, file, f.PCFile, sym, files)))
+		off = buf.Uint32(off, uint32(addPCTable(p, buf, file, f.PCLine)))
+		off = buf.Uint32(off, uint32(len(f.PCData)))
+		off = buf.Uint32(off, uint32(len(f.FuncData)))
+		for _, pcdata := range f.PCData {
+			off = buf.Uint32(off, uint32(addPCTable(p, buf, file, pcdata)))
+		}
+
+		// funcdata
+		if len(f.FuncData) > 0 {
+			off += -off & (p.ptrsize - 1) // must be pointer-aligned
+			for _, funcdata := range f.FuncData {
+				if funcdata.Sym.Name == "" {
+					off = buf.Uint(off, uint64(funcdata.Offset), p.ptrsize)
+				} else {
+					off = buf.Addr(off, funcdata.Sym, funcdata.Offset)
+				}
+			}
+		}
+
+		if off != end {
+			p.errorf("internal error: invalid math in pclntab: off=%#x end=%#x", off, end)
+			break
+		}
+	}
+	if file != nil {
+		file.Close()
+	}
+
+	// Final entry of index is end PC of last function.
+	indexOff = buf.Addr(indexOff, lastSym.SymID, int64(lastSym.Size))
+
+	// Start file table.
+	// Function index is immediately followed by offset to file table.
+	off = (buf.Size() + p.ptrsize - 1) &^ (p.ptrsize - 1)
+	buf.Uint32(indexOff, uint32(off))
+
+	// File table is an array of uint32s.
+	// The first entry gives 1+n, the size of the array.
+	// The following n entries hold offsets to string data.
+	// File number n uses the string pointed at by entry n.
+	// File number 0 is invalid.
+	buf.SetSize(off + (1+len(files))*4)
+	buf.Uint32(off, uint32(1+len(files)))
+	var filestr []string
+	for file := range files {
+		filestr = append(filestr, file)
+	}
+	sort.Strings(filestr)
+	for _, file := range filestr {
+		id := files[file]
+		buf.Uint32(off+4*id, uint32(addString(buf, file)))
+	}
+
+	pclntab := &Sym{
+		Sym: &goobj.Sym{
+			SymID: goobj.SymID{Name: "pclntab"},
+			Kind:  goobj.SPCLNTAB,
+			Size:  buf.Size(),
+			Reloc: buf.Reloc(),
+		},
+		Bytes: buf.Bytes(),
+	}
+	p.addSym(pclntab)
+}
+
+// addString appends the string s to the buffer b.
+// It returns the offset of the beginning of the string in the buffer.
+func addString(b *SymBuffer, s string) int {
+	off := b.Size()
+	b.SetSize(off + len(s) + 1)
+	copy(b.data[off:], s)
+	return off
+}
+
+// addPCTable appends the PC-data table stored in the file f at the location loc
+// to the symbol buffer b. It returns the offset of the beginning of the table
+// in the buffer.
+func addPCTable(p *Prog, b *SymBuffer, f *os.File, loc goobj.Data) int {
+	if loc.Size == 0 {
+		return 0
+	}
+	off := b.Size()
+	b.SetSize(off + int(loc.Size))
+	_, err := f.ReadAt(b.data[off:off+int(loc.Size)], loc.Offset)
+	if err != nil {
+		p.errorf("%v", err)
+	}
+	return off
+}
+
+// addPCFileTable is like addPCTable, but it renumbers the file names referred to by the table
+// to use the global numbering maintained in the files map. It adds new files to the
+// map as necessary.
+func addPCFileTable(p *Prog, b *SymBuffer, f *os.File, loc goobj.Data, sym *Sym, files map[string]int) int {
+	if loc.Size == 0 {
+		return 0
+	}
+	off := b.Size()
+
+	src := make([]byte, loc.Size)
+	_, err := f.ReadAt(src, loc.Offset)
+	if err != nil {
+		p.errorf("%v", err)
+		return 0
+	}
+
+	filenum := make([]int, len(sym.Func.File))
+	for i, name := range sym.Func.File {
+		num := files[name]
+		if num == 0 {
+			num = len(files) + 1
+			files[name] = num
+		}
+		filenum[i] = num
+	}
+
+	var dst []byte
+	newval := int32(-1)
+	var it PCIter
+	for it.Init(p, src); !it.Done; it.Next() {
+		// value delta
+		oldval := it.Value
+		val := oldval
+		if oldval != -1 {
+			if oldval < 0 || int(oldval) >= len(filenum) {
+				p.errorf("%s: corrupt pc-file table", sym)
+				break
+			}
+			val = int32(filenum[oldval])
+		}
+		dv := val - newval
+		newval = val
+		uv := uint32(dv<<1) ^ uint32(dv>>31)
+		dst = appendVarint(dst, uv)
+
+		// pc delta
+		dst = appendVarint(dst, it.NextPC-it.PC)
+	}
+	if it.Corrupt {
+		p.errorf("%s: corrupt pc-file table", sym)
+	}
+
+	// terminating value delta
+	dst = appendVarint(dst, 0)
+
+	b.SetSize(off + len(dst))
+	copy(b.data[off:], dst)
+	return off
+}
+
+// A SymBuffer is a buffer for preparing the data image of a
+// linker-generated symbol.
+type SymBuffer struct {
+	data    []byte
+	reloc   []goobj.Reloc
+	order   binary.ByteOrder
+	ptrsize int
+}
+
+// Init initializes the buffer for writing.
+func (b *SymBuffer) Init(p *Prog) {
+	b.data = nil
+	b.reloc = nil
+	b.order = p.byteorder
+	b.ptrsize = p.ptrsize
+}
+
+// Bytes returns the buffer data.
+func (b *SymBuffer) Bytes() []byte {
+	return b.data
+}
+
+// SetSize sets the buffer's data size to n bytes.
+func (b *SymBuffer) SetSize(n int) {
+	for cap(b.data) < n {
+		b.data = append(b.data[:cap(b.data)], 0)
+	}
+	b.data = b.data[:n]
+}
+
+// Size returns the buffer's data size.
+func (b *SymBuffer) Size() int {
+	return len(b.data)
+}
+
+// Reloc returns the buffered relocations.
+func (b *SymBuffer) Reloc() []goobj.Reloc {
+	return b.reloc
+}
+
+// Uint8 sets the uint8 at offset off to v.
+// It returns the offset just beyond v.
+func (b *SymBuffer) Uint8(off int, v uint8) int {
+	b.data[off] = v
+	return off + 1
+}
+
+// Uint16 sets the uint16 at offset off to v.
+// It returns the offset just beyond v.
+func (b *SymBuffer) Uint16(off int, v uint16) int {
+	b.order.PutUint16(b.data[off:], v)
+	return off + 2
+}
+
+// Uint32 sets the uint32 at offset off to v.
+// It returns the offset just beyond v.
+func (b *SymBuffer) Uint32(off int, v uint32) int {
+	b.order.PutUint32(b.data[off:], v)
+	return off + 4
+}
+
+// Uint64 sets the uint64 at offset off to v.
+// It returns the offset just beyond v.
+func (b *SymBuffer) Uint64(off int, v uint64) int {
+	b.order.PutUint64(b.data[off:], v)
+	return off + 8
+}
+
+// Uint sets the size-byte unsigned integer at offset off to v.
+// It returns the offset just beyond v.
+func (b *SymBuffer) Uint(off int, v uint64, size int) int {
+	switch size {
+	case 1:
+		return b.Uint8(off, uint8(v))
+	case 2:
+		return b.Uint16(off, uint16(v))
+	case 4:
+		return b.Uint32(off, uint32(v))
+	case 8:
+		return b.Uint64(off, v)
+	}
+	panic("invalid use of SymBuffer.SetUint")
+}
+
+// Addr sets the pointer-sized address at offset off to refer
+// to symoff bytes past the start of sym. It returns the offset
+// just beyond the address.
+func (b *SymBuffer) Addr(off int, sym goobj.SymID, symoff int64) int {
+	b.reloc = append(b.reloc, goobj.Reloc{
+		Offset: off,
+		Size:   b.ptrsize,
+		Sym:    sym,
+		Add:    int(symoff),
+		Type:   D_ADDR,
+	})
+	return off + b.ptrsize
+}
+
+// A PCIter implements iteration over PC-data tables.
+//
+//	var it PCIter
+//	it.Init(p, data)
+//	for it.Init(p, data); !it.Done; it.Next() {
+//		it.Value holds from it.PC up to (but not including) it.NextPC
+//	}
+//	if it.Corrupt {
+//		data was malformed
+//	}
+//
+type PCIter struct {
+	PC        uint32
+	NextPC    uint32
+	Value     int32
+	Done      bool
+	Corrupt   bool
+	p         []byte
+	start     bool
+	pcquantum uint32
+}
+
+// Init initializes the iteration.
+// On return, if it.Done is true, the iteration is over.
+// Otherwise it.Value applies in the pc range [it.PC, it.NextPC).
+func (it *PCIter) Init(p *Prog, buf []byte) {
+	it.p = buf
+	it.PC = 0
+	it.NextPC = 0
+	it.Value = -1
+	it.start = true
+	it.pcquantum = uint32(p.pcquantum)
+	it.Done = false
+	it.Next()
+}
+
+// Next steps forward one entry in the table.
+// On return, if it.Done is true, the iteration is over.
+// Otherwise it.Value applies in the pc range [it.PC, it.NextPC).
+func (it *PCIter) Next() {
+	it.PC = it.NextPC
+	if it.Done {
+		return
+	}
+	if len(it.p) == 0 {
+		it.Done = true
+		return
+	}
+
+	// value delta
+	uv, p, ok := decodeVarint(it.p)
+	if !ok {
+		it.Done = true
+		it.Corrupt = true
+		return
+	}
+	it.p = p
+	if uv == 0 && !it.start {
+		it.Done = true
+		return
+	}
+	it.start = false
+	sv := int32(uv)>>1 ^ int32(uv)<<31>>31
+	it.Value += sv
+
+	// pc delta
+	uv, it.p, ok = decodeVarint(it.p)
+	if !ok {
+		it.Done = true
+		it.Corrupt = true
+		return
+	}
+	it.NextPC = it.PC + uv*it.pcquantum
+}
+
+// decodeVarint decodes an unsigned varint from p,
+// reporting the value, the remainder of the data, and
+// whether the decoding was successful.
+func decodeVarint(p []byte) (v uint32, rest []byte, ok bool) {
+	for shift := uint(0); ; shift += 7 {
+		if len(p) == 0 {
+			return
+		}
+		c := uint32(p[0])
+		p = p[1:]
+		v |= (c & 0x7F) << shift
+		if c&0x80 == 0 {
+			break
+		}
+	}
+	return v, p, true
+}
+
+// appendVarint appends an unsigned varint encoding of v to p
+// and returns the resulting slice.
+func appendVarint(p []byte, v uint32) []byte {
+	for ; v >= 0x80; v >>= 7 {
+		p = append(p, byte(v)|0x80)
+	}
+	p = append(p, byte(v))
+	return p
+}
diff --git a/src/cmd/link/pclntab_test.go b/src/cmd/link/pclntab_test.go
new file mode 100644
index 0000000000..5696a0978d
--- /dev/null
+++ b/src/cmd/link/pclntab_test.go
@@ -0,0 +1,334 @@
+// Copyright 2014 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package main
+
+import (
+	"bytes"
+	"debug/goobj"
+	"fmt"
+	"math/rand"
+	"sort"
+	"strings"
+	"testing"
+)
+
+// Test of pcln table encoding.
+// testdata/genpcln.go generates an assembly file with
+// pseudorandom values for the data that pclntab stores.
+// This test recomputes the same pseudorandom stream
+// and checks that the final linked binary uses those values
+// as well.
+func TestPclntab(t *testing.T) {
+	p := &Prog{
+		GOOS:        "darwin",
+		GOARCH:      "amd64",
+		Error:       func(s string) { t.Error(s) },
+		StartSym:    "start",
+		omitRuntime: true,
+	}
+	var buf bytes.Buffer
+	p.link(&buf, "testdata/pclntab.6")
+	if p.NumError > 0 {
+		return
+	}
+
+	// The algorithm for computing values here must match
+	// the one in testdata/genpcln.go.
+	for f := 0; f < 3; f++ {
+		file := "input"
+		line := 1
+		rnd := rand.New(rand.NewSource(int64(f)))
+		args := rnd.Intn(100) * 8
+		frame := 32 + rnd.Intn(32)/8*8
+		size := 200 + rnd.Intn(100)*8
+
+		name := fmt.Sprintf("func%d", f)
+		r, off, fargs, fframe, ok := findFunc(t, p, name)
+		if !ok {
+			continue // error already printed
+		}
+		if fargs != args {
+			t.Errorf("%s: args=%d, want %d", name, fargs, args)
+		}
+		if fframe != frame+8 {
+			t.Errorf("%s: frame=%d, want %d", name, fframe, frame+8)
+		}
+
+		// Check FUNCDATA 1.
+		fdata, ok := loadFuncdata(t, r, name, off, 1)
+		if ok {
+			fsym := p.Syms[goobj.SymID{Name: fmt.Sprintf("funcdata%d", f)}]
+			if fsym == nil {
+				t.Errorf("funcdata%d is missing in binary", f)
+			} else if fdata != fsym.Addr {
+				t.Errorf("%s: funcdata 1 = %#x, want %#x", name, fdata, fsym.Addr)
+			}
+		}
+
+		// Walk code checking pcdata values.
+		spadj := 0
+		pcdata1 := -1
+		pcdata2 := -1
+
+		checkPCSP(t, r, name, off, 0, 0)
+		checkPCData(t, r, name, off, 0, 0, -1)
+		checkPCData(t, r, name, off, 0, 1, -1)
+		checkPCData(t, r, name, off, 0, 2, -1)
+
+		firstpc := 4
+		for i := 0; i < size; i++ {
+			pc := firstpc + i // skip SP adjustment to allocate frame
+			if i >= 0x100 && t.Failed() {
+				break
+			}
+			// Possible SP adjustment.
+			checkPCSP(t, r, name, off, pc, frame+spadj)
+			if rnd.Intn(100) == 0 {
+				checkPCFileLine(t, r, name, off, pc, file, line)
+				checkPCData(t, r, name, off, pc, 1, pcdata1)
+				checkPCData(t, r, name, off, pc, 2, pcdata2)
+				i += 1
+				pc = firstpc + i
+				checkPCFileLine(t, r, name, off, pc-1, file, line)
+				checkPCData(t, r, name, off, pc-1, 1, pcdata1)
+				checkPCData(t, r, name, off, pc-1, 2, pcdata2)
+				checkPCSP(t, r, name, off, pc-1, frame+spadj)
+
+				if spadj <= -32 || spadj < 32 && rnd.Intn(2) == 0 {
+					spadj += 8
+				} else {
+					spadj -= 8
+				}
+				checkPCSP(t, r, name, off, pc, frame+spadj)
+			}
+
+			// Possible PCFile change.
+			if rnd.Intn(100) == 0 {
+				file = fmt.Sprintf("file%d.s", rnd.Intn(10))
+				line = rnd.Intn(100) + 1
+			}
+
+			// Possible PCLine change.
+			if rnd.Intn(10) == 0 {
+				line = rnd.Intn(1000) + 1
+			}
+
+			// Possible PCData $1 change.
+			if rnd.Intn(100) == 0 {
+				pcdata1 = rnd.Intn(1000)
+			}
+
+			// Possible PCData $2 change.
+			if rnd.Intn(100) == 0 {
+				pcdata2 = rnd.Intn(1000)
+			}
+
+			if i == 0 {
+				checkPCFileLine(t, r, name, off, 0, file, line)
+				checkPCFileLine(t, r, name, off, pc-1, file, line)
+			}
+			checkPCFileLine(t, r, name, off, pc, file, line)
+			checkPCData(t, r, name, off, pc, 1, pcdata1)
+			checkPCData(t, r, name, off, pc, 2, pcdata2)
+		}
+	}
+}
+
+// findFunc finds the function information in the pclntab of p
+// for the function with the given name.
+// It returns a symbol reader for pclntab, the offset of the function information
+// within that symbol, and the args and frame values read out of the information.
+func findFunc(t *testing.T, p *Prog, name string) (r *SymReader, off, args, frame int, ok bool) {
+	tabsym := p.Syms[goobj.SymID{Name: "pclntab"}]
+	if tabsym == nil {
+		t.Errorf("pclntab is missing in binary")
+		return
+	}
+
+	r = new(SymReader)
+	r.Init(p, tabsym)
+
+	// pclntab must with 8-byte header
+	if r.Uint32(0) != 0xfffffffb || r.Uint8(4) != 0 || r.Uint8(5) != 0 || r.Uint8(6) != uint8(p.pcquantum) || r.Uint8(7) != uint8(p.ptrsize) {
+		t.Errorf("pclntab has incorrect header %.8x", r.data[:8])
+		return
+	}
+
+	sym := p.Syms[goobj.SymID{Name: name}]
+	if sym == nil {
+		t.Errorf("%s is missing in the binary", name)
+		return
+	}
+
+	// index is nfunc addr0 off0 addr1 off1 ... addr_nfunc (sentinel)
+	nfunc := int(r.Addr(8))
+	i := sort.Search(nfunc, func(i int) bool {
+		return r.Addr(8+p.ptrsize*(1+2*i)) >= sym.Addr
+	})
+	if entry := r.Addr(8 + p.ptrsize*(1+2*i)); entry != sym.Addr {
+		indexTab := make([]Addr, 2*nfunc+1)
+		for j := range indexTab {
+			indexTab[j] = r.Addr(8 + p.ptrsize*(1+j))
+		}
+		t.Errorf("pclntab is missing entry for %s (%#x): %#x", name, sym.Addr, indexTab)
+		return
+	}
+
+	off = int(r.Addr(8 + p.ptrsize*(1+2*i+1)))
+
+	// func description at off is
+	//	entry addr
+	//	nameoff uint32
+	//	args uint32
+	//	frame uint32
+	//	pcspoff uint32
+	//	pcfileoff uint32
+	//	pclineoff uint32
+	//	npcdata uint32
+	//	nfuncdata uint32
+	//	pcdata npcdata*uint32
+	//	funcdata nfuncdata*addr
+	//
+	if entry := r.Addr(off); entry != sym.Addr {
+		t.Errorf("pclntab inconsistent: entry for %s addr=%#x has entry=%#x", name, sym.Addr, entry)
+		return
+	}
+	nameoff := int(r.Uint32(off + p.ptrsize))
+	args = int(r.Uint32(off + p.ptrsize + 1*4))
+	frame = int(r.Uint32(off + p.ptrsize + 2*4))
+
+	fname := r.String(nameoff)
+	if fname != name {
+		t.Errorf("pclntab inconsistent: entry for %s addr=%#x has name %q", name, sym.Addr, fname)
+	}
+
+	ok = true // off, args, frame are usable
+	return
+}
+
+// loadFuncdata returns the funcdata #fnum value
+// loaded from the function information for name.
+func loadFuncdata(t *testing.T, r *SymReader, name string, off int, fnum int) (Addr, bool) {
+	npcdata := int(r.Uint32(off + r.p.ptrsize + 6*4))
+	nfuncdata := int(r.Uint32(off + r.p.ptrsize + 7*4))
+	if fnum >= nfuncdata {
+		t.Errorf("pclntab(%s): no funcdata %d (only < %d)", name, fnum, nfuncdata)
+		return 0, false
+	}
+	fdataoff := off + r.p.ptrsize + (8+npcdata)*4 + fnum*r.p.ptrsize
+	fdataoff += fdataoff & 4
+	return r.Addr(fdataoff), true
+}
+
+// checkPCSP checks that the PCSP table in the function information at off
+// lists spadj as the sp delta for pc.
+func checkPCSP(t *testing.T, r *SymReader, name string, off, pc, spadj int) {
+	pcoff := r.Uint32(off + r.p.ptrsize + 3*4)
+	pcval, ok := readPCData(t, r, name, "PCSP", pcoff, pc)
+	if !ok {
+		return
+	}
+	if pcval != spadj {
+		t.Errorf("pclntab(%s): at pc=+%#x, pcsp=%d, want %d", name, pc, pcval, spadj)
+	}
+}
+
+// checkPCSP checks that the PCFile and PCLine tables in the function information at off
+// list file, line as the file name and line number for pc.
+func checkPCFileLine(t *testing.T, r *SymReader, name string, off, pc int, file string, line int) {
+	pcfileoff := r.Uint32(off + r.p.ptrsize + 4*4)
+	pclineoff := r.Uint32(off + r.p.ptrsize + 5*4)
+	pcfilenum, ok1 := readPCData(t, r, name, "PCFile", pcfileoff, pc)
+	pcline, ok2 := readPCData(t, r, name, "PCLine", pclineoff, pc)
+	if !ok1 || !ok2 {
+		return
+	}
+	nfunc := int(r.Addr(8))
+	filetaboff := r.Uint32(8 + r.p.ptrsize*2*(nfunc+1))
+	nfile := int(r.Uint32(int(filetaboff)))
+	if pcfilenum <= 0 || pcfilenum >= nfile {
+		t.Errorf("pclntab(%s): at pc=+%#x, filenum=%d (invalid; nfile=%d)", name, pc, pcfilenum, nfile)
+	}
+	pcfile := r.String(int(r.Uint32(int(filetaboff) + pcfilenum*4)))
+	if !strings.HasSuffix(pcfile, file) {
+		t.Errorf("pclntab(%s): at pc=+%#x, file=%q, want %q", name, pc, pcfile, file)
+	}
+	if pcline != line {
+		t.Errorf("pclntab(%s): at pc=+%#x, line=%d, want %d", name, pc, pcline, line)
+	}
+}
+
+// checkPCData checks that the PCData#pnum table in the function information at off
+// list val as the value for pc.
+func checkPCData(t *testing.T, r *SymReader, name string, off, pc, pnum, val int) {
+	pcoff := r.Uint32(off + r.p.ptrsize + (8+pnum)*4)
+	pcval, ok := readPCData(t, r, name, fmt.Sprintf("PCData#%d", pnum), pcoff, pc)
+	if !ok {
+		return
+	}
+	if pcval != val {
+		t.Errorf("pclntab(%s): at pc=+%#x, pcdata#%d=%d, want %d", name, pc, pnum, pcval, val)
+	}
+}
+
+// readPCData reads the PCData table offset off
+// to obtain and return the value associated with pc.
+func readPCData(t *testing.T, r *SymReader, name, pcdataname string, pcoff uint32, pc int) (int, bool) {
+	var it PCIter
+	for it.Init(r.p, r.data[pcoff:]); !it.Done; it.Next() {
+		if it.PC <= uint32(pc) && uint32(pc) < it.NextPC {
+			return int(it.Value), true
+		}
+	}
+	if it.Corrupt {
+		t.Errorf("pclntab(%s): %s: corrupt pcdata table", name, pcdataname)
+	}
+	return 0, false
+}
+
+// A SymReader provides typed access to the data for a symbol.
+type SymReader struct {
+	p    *Prog
+	data []byte
+}
+
+func (r *SymReader) Init(p *Prog, sym *Sym) {
+	seg := sym.Section.Segment
+	off := sym.Addr - seg.VirtAddr
+	data := seg.Data[off : off+Addr(sym.Size)]
+	r.p = p
+	r.data = data
+}
+
+func (r *SymReader) Uint8(off int) uint8 {
+	return r.data[off]
+}
+
+func (r *SymReader) Uint16(off int) uint16 {
+	return r.p.byteorder.Uint16(r.data[off:])
+}
+
+func (r *SymReader) Uint32(off int) uint32 {
+	return r.p.byteorder.Uint32(r.data[off:])
+}
+
+func (r *SymReader) Uint64(off int) uint64 {
+	return r.p.byteorder.Uint64(r.data[off:])
+}
+
+func (r *SymReader) Addr(off int) Addr {
+	if r.p.ptrsize == 4 {
+		return Addr(r.Uint32(off))
+	}
+	return Addr(r.Uint64(off))
+}
+
+func (r *SymReader) String(off int) string {
+	end := off
+	for r.data[end] != '\x00' {
+		end++
+	}
+	return string(r.data[off:end])
+}
diff --git a/src/cmd/link/prog.go b/src/cmd/link/prog.go
index a63b36d385..a52b5ff9b2 100644
--- a/src/cmd/link/prog.go
+++ b/src/cmd/link/prog.go
@@ -66,6 +66,7 @@ type Prog struct {
 type arch struct {
 	byteorder binary.ByteOrder
 	ptrsize   int
+	pcquantum int
 }
 
 // A formatter takes care of the details of generating a particular
@@ -214,5 +215,6 @@ var arches = map[string]arch{
 	"amd64": {
 		byteorder: binary.LittleEndian,
 		ptrsize:   8,
+		pcquantum: 1,
 	},
 }
diff --git a/src/cmd/link/runtime.go b/src/cmd/link/runtime.go
index 6522194da5..5d37015eb1 100644
--- a/src/cmd/link/runtime.go
+++ b/src/cmd/link/runtime.go
@@ -7,5 +7,22 @@
 
 package main
 
+import "debug/goobj"
+
 func (p *Prog) runtime() {
+	p.pclntab()
+
+	// TODO: Implement garbage collection data.
+	p.addSym(&Sym{
+		Sym: &goobj.Sym{
+			SymID: goobj.SymID{Name: "gcdata"},
+			Kind:  goobj.SRODATA,
+		},
+	})
+	p.addSym(&Sym{
+		Sym: &goobj.Sym{
+			SymID: goobj.SymID{Name: "gcbss"},
+			Kind:  goobj.SRODATA,
+		},
+	})
 }
diff --git a/src/cmd/link/testdata/Makefile b/src/cmd/link/testdata/Makefile
new file mode 100644
index 0000000000..1d5810a800
--- /dev/null
+++ b/src/cmd/link/testdata/Makefile
@@ -0,0 +1,10 @@
+all: hello.6 pclntab.6
+
+hello.6: hello.s
+	go tool 6a hello.s
+
+pclntab.6: pclntab.s
+	go tool 6a pclntab.s
+
+pclntab.s: genpcln.go
+	go run genpcln.go >pclntab.s
diff --git a/src/cmd/link/testdata/genpcln.go b/src/cmd/link/testdata/genpcln.go
new file mode 100644
index 0000000000..684cc07a27
--- /dev/null
+++ b/src/cmd/link/testdata/genpcln.go
@@ -0,0 +1,112 @@
+// Copyright 2014 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// This program generates a .s file using a pseudorandom
+// value stream for the runtime function data.
+// The pclntab test checks that the linked copy
+// still has the same pseudorandom value stream.
+
+package main
+
+import (
+	"fmt"
+	"math/rand"
+)
+
+func main() {
+	fmt.Printf("// generated by genpcln.go; do not edit\n\n")
+	for f := 0; f < 3; f++ {
+		r := rand.New(rand.NewSource(int64(f)))
+		file := "input"
+		line := 1
+		args := r.Intn(100) * 8
+		frame := 32 + r.Intn(32)/8*8
+		fmt.Printf("#line %d %q\n", line, file)
+		fmt.Printf("TEXT func%d(SB),7,$%d-%d\n", f, frame, args)
+		fmt.Printf("\tFUNCDATA $1, funcdata%d(SB)\n", f)
+		fmt.Printf("#line %d %q\n", line, file)
+		size := 200 + r.Intn(100)*8
+		spadj := 0
+		flushed := 0
+		firstpc := 4
+		flush := func(i int) {
+			for i-flushed >= 10 {
+				fmt.Printf("#line %d %q\n", line, file)
+				fmt.Printf("/*%#04x*/\tMOVQ $0x123456789, AX\n", firstpc+flushed)
+				flushed += 10
+			}
+			for i-flushed >= 5 {
+				fmt.Printf("#line %d %q\n", line, file)
+				fmt.Printf("/*%#04x*/\tMOVL $0x1234567, AX\n", firstpc+flushed)
+				flushed += 5
+			}
+			for i-flushed > 0 {
+				fmt.Printf("#line %d %q\n", line, file)
+				fmt.Printf("/*%#04x*/\tBYTE $0\n", firstpc+flushed)
+				flushed++
+			}
+		}
+		for i := 0; i < size; i++ {
+			// Possible SP adjustment.
+			if r.Intn(100) == 0 {
+				flush(i)
+				fmt.Printf("#line %d %q\n", line, file)
+				if spadj <= -32 || spadj < 32 && r.Intn(2) == 0 {
+					spadj += 8
+					fmt.Printf("/*%#04x*/\tPUSHQ AX\n", firstpc+i)
+				} else {
+					spadj -= 8
+					fmt.Printf("/*%#04x*/\tPOPQ AX\n", firstpc+i)
+				}
+				i += 1
+				flushed = i
+			}
+
+			// Possible PCFile change.
+			if r.Intn(100) == 0 {
+				flush(i)
+				file = fmt.Sprintf("file%d.s", r.Intn(10))
+				line = r.Intn(100) + 1
+			}
+
+			// Possible PCLine change.
+			if r.Intn(10) == 0 {
+				flush(i)
+				line = r.Intn(1000) + 1
+			}
+
+			// Possible PCData $1 change.
+			if r.Intn(100) == 0 {
+				flush(i)
+				fmt.Printf("/*%6s*/\tPCDATA $1, $%d\n", "", r.Intn(1000))
+			}
+
+			// Possible PCData $2 change.
+			if r.Intn(100) == 0 {
+				flush(i)
+				fmt.Printf("/*%6s*/\tPCDATA $2, $%d\n", "", r.Intn(1000))
+			}
+		}
+		flush(size)
+		for spadj < 0 {
+			fmt.Printf("\tPUSHQ AX\n")
+			spadj += 8
+		}
+		for spadj > 0 {
+			fmt.Printf("\tPOPQ AX\n")
+			spadj -= 8
+		}
+		fmt.Printf("\tRET\n")
+
+		fmt.Printf("\n")
+		fmt.Printf("GLOBL funcdata%d(SB), $16\n", f)
+	}
+
+	fmt.Printf("\nTEXT start(SB),7,$0\n")
+	for f := 0; f < 3; f++ {
+		fmt.Printf("\tCALL func%d(SB)\n", f)
+	}
+	fmt.Printf("\tMOVQ $pclntab(SB), AX\n")
+	fmt.Printf("\n\tRET\n")
+}
diff --git a/src/cmd/link/testdata/link.hello.darwin.amd64 b/src/cmd/link/testdata/link.hello.darwin.amd64
index 454867037e..5d94af1d9c 100644
--- a/src/cmd/link/testdata/link.hello.darwin.amd64
+++ b/src/cmd/link/testdata/link.hello.darwin.amd64
@@ -1,35 +1,57 @@
 00000000  cf fa ed fe 07 00 00 01  03 00 00 00 02 00 00 00  |................|
-00000010  04 00 00 00 30 02 00 00  01 00 00 00 00 00 00 00  |....0...........|
+00000010  04 00 00 00 d0 02 00 00  01 00 00 00 00 00 00 00  |................|
 00000020  19 00 00 00 48 00 00 00  5f 5f 50 41 47 45 5a 45  |....H...__PAGEZE|
 00000030  52 4f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |RO..............|
 00000040  00 10 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
 *
-00000060  00 00 00 00 00 00 00 00  19 00 00 00 98 00 00 00  |................|
+00000060  00 00 00 00 00 00 00 00  19 00 00 00 38 01 00 00  |............8...|
 00000070  5f 5f 54 45 58 54 00 00  00 00 00 00 00 00 00 00  |__TEXT..........|
-00000080  00 10 00 00 00 00 00 00  20 10 00 00 00 00 00 00  |........ .......|
-00000090  00 00 00 00 00 00 00 00  20 10 00 00 00 00 00 00  |........ .......|
-000000a0  07 00 00 00 05 00 00 00  01 00 00 00 00 00 00 00  |................|
+00000080  00 10 00 00 00 00 00 00  d6 10 00 00 00 00 00 00  |................|
+00000090  00 00 00 00 00 00 00 00  d6 10 00 00 00 00 00 00  |................|
+000000a0  07 00 00 00 05 00 00 00  03 00 00 00 00 00 00 00  |................|
 000000b0  5f 5f 74 65 78 74 00 00  00 00 00 00 00 00 00 00  |__text..........|
 000000c0  5f 5f 54 45 58 54 00 00  00 00 00 00 00 00 00 00  |__TEXT..........|
 000000d0  00 20 00 00 00 00 00 00  20 00 00 00 00 00 00 00  |. ...... .......|
 000000e0  00 10 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
 000000f0  00 04 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
-00000100  19 00 00 00 98 00 00 00  5f 5f 44 41 54 41 00 00  |........__DATA..|
-00000110  00 00 00 00 00 00 00 00  00 30 00 00 00 00 00 00  |.........0......|
-00000120  0c 00 00 00 00 00 00 00  00 20 00 00 00 00 00 00  |......... ......|
-00000130  0c 00 00 00 00 00 00 00  03 00 00 00 03 00 00 00  |................|
-00000140  01 00 00 00 00 00 00 00  5f 5f 64 61 74 61 00 00  |........__data..|
-00000150  00 00 00 00 00 00 00 00  5f 5f 44 41 54 41 00 00  |........__DATA..|
-00000160  00 00 00 00 00 00 00 00  00 30 00 00 00 00 00 00  |.........0......|
-00000170  0c 00 00 00 00 00 00 00  00 20 00 00 00 00 00 00  |......... ......|
+00000100  5f 5f 72 6f 64 61 74 61  00 00 00 00 00 00 00 00  |__rodata........|
+00000110  5f 5f 54 45 58 54 00 00  00 00 00 00 00 00 00 00  |__TEXT..........|
+00000120  20 20 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ..............|
+00000130  20 10 00 00 00 00 00 00  00 00 00 00 00 00 00 00  | ...............|
 *
-00000190  00 00 00 00 00 00 00 00  05 00 00 00 b8 00 00 00  |................|
-000001a0  04 00 00 00 2a 00 00 00  00 00 00 00 00 00 00 00  |....*...........|
+00000150  5f 5f 66 75 6e 63 74 61  62 00 00 00 00 00 00 00  |__functab.......|
+00000160  5f 5f 54 45 58 54 00 00  00 00 00 00 00 00 00 00  |__TEXT..........|
+00000170  20 20 00 00 00 00 00 00  b6 00 00 00 00 00 00 00  |  ..............|
+00000180  20 10 00 00 00 00 00 00  00 00 00 00 00 00 00 00  | ...............|
 *
-00000220  00 00 00 00 00 00 00 00  00 20 00 00 00 00 00 00  |......... ......|
+000001a0  19 00 00 00 98 00 00 00  5f 5f 44 41 54 41 00 00  |........__DATA..|
+000001b0  00 00 00 00 00 00 00 00  00 30 00 00 00 00 00 00  |.........0......|
+000001c0  0c 00 00 00 00 00 00 00  00 20 00 00 00 00 00 00  |......... ......|
+000001d0  0c 00 00 00 00 00 00 00  03 00 00 00 03 00 00 00  |................|
+000001e0  01 00 00 00 00 00 00 00  5f 5f 64 61 74 61 00 00  |........__data..|
+000001f0  00 00 00 00 00 00 00 00  5f 5f 44 41 54 41 00 00  |........__DATA..|
+00000200  00 00 00 00 00 00 00 00  00 30 00 00 00 00 00 00  |.........0......|
+00000210  0c 00 00 00 00 00 00 00  00 20 00 00 00 00 00 00  |......... ......|
+*
+00000230  00 00 00 00 00 00 00 00  05 00 00 00 b8 00 00 00  |................|
+00000240  04 00 00 00 2a 00 00 00  00 00 00 00 00 00 00 00  |....*...........|
+*
+000002c0  00 00 00 00 00 00 00 00  00 20 00 00 00 00 00 00  |......... ......|
 *
 00001000  bf 01 00 00 00 be 00 30  00 00 ba 0c 00 00 00 b8  |.......0........|
 00001010  04 00 00 02 0f 05 31 ff  b8 01 00 00 02 0f 05 c3  |......1.........|
+00001020  fb ff ff ff 00 00 01 08  01 00 00 00 00 00 00 00  |................|
+00001030  00 20 00 00 00 00 00 00  30 00 00 00 00 00 00 00  |. ......0.......|
+00001040  20 20 00 00 00 00 00 00  80 00 00 00 00 00 00 00  |  ..............|
+00001050  00 20 00 00 00 00 00 00  58 00 00 00 00 00 00 80  |. ......X.......|
+00001060  08 00 00 00 60 00 00 00  63 00 00 00 66 00 00 00  |....`...c...f...|
+00001070  00 00 00 00 00 00 00 00  5f 72 74 30 5f 67 6f 00  |........_rt0_go.|
+00001080  02 20 00 04 20 00 06 05  02 05 02 05 02 05 02 02  |. .. ...........|
+00001090  02 02 02 05 02 02 02 01  00 00 00 00 00 00 00 00  |................|
+000010a0  02 00 00 00 88 00 00 00  2f 55 73 65 72 73 2f 72  |......../Users/r|
+000010b0  73 63 2f 72 73 63 67 6f  2f 73 72 63 2f 63 6d 64  |sc/rscgo/src/cmd|
+000010c0  2f 6c 64 32 2f 74 65 73  74 64 61 74 61 2f 68 65  |/ld2/testdata/he|
+000010d0  6c 6c 6f 2e 73 00 00 00  00 00 00 00 00 00 00 00  |llo.s...........|
 *
 00002000  68 65 6c 6c 6f 20 77 6f  72 6c 64 0a              |hello world.|
 0000200c
diff --git a/src/cmd/link/testdata/pclntab.s b/src/cmd/link/testdata/pclntab.s
new file mode 100644
index 0000000000..22c4ee0dec
--- /dev/null
+++ b/src/cmd/link/testdata/pclntab.s
@@ -0,0 +1,1751 @@
+// generated by genpcln.go; do not edit
+
+#line 1 "input"
+TEXT func0(SB),7,$48-592
+	FUNCDATA $1, funcdata0(SB)
+#line 1 "input"
+#line 1 "input"
+/*0x0004*/	MOVL $0x1234567, AX
+#line 1 "input"
+/*0x0009*/	BYTE $0
+/*      */	PCDATA $1, $110
+#line 1 "input"
+/*0x000a*/	BYTE $0
+#line 1 "input"
+/*0x000b*/	BYTE $0
+/*      */	PCDATA $1, $422
+#line 1 "input"
+/*0x000c*/	BYTE $0
+#line 1 "input"
+/*0x000d*/	BYTE $0
+#line 1 "input"
+/*0x000e*/	POPQ AX
+#line 1 "input"
+/*0x000f*/	MOVL $0x1234567, AX
+#line 1 "input"
+/*0x0014*/	BYTE $0
+#line 1 "input"
+/*0x0015*/	BYTE $0
+#line 1 "input"
+/*0x0016*/	BYTE $0
+#line 542 "input"
+/*0x0017*/	BYTE $0
+#line 960 "input"
+/*0x0018*/	MOVL $0x1234567, AX
+#line 960 "input"
+/*0x001d*/	BYTE $0
+#line 960 "input"
+/*0x001e*/	PUSHQ AX
+#line 960 "input"
+/*0x001f*/	BYTE $0
+#line 960 "input"
+/*0x0020*/	BYTE $0
+#line 594 "input"
+/*0x0021*/	BYTE $0
+#line 671 "input"
+/*0x0022*/	MOVL $0x1234567, AX
+#line 671 "input"
+/*0x0027*/	BYTE $0
+#line 671 "input"
+/*0x0028*/	BYTE $0
+#line 230 "input"
+/*0x0029*/	BYTE $0
+#line 230 "input"
+/*0x002a*/	BYTE $0
+#line 413 "input"
+/*0x002b*/	BYTE $0
+#line 413 "input"
+/*0x002c*/	BYTE $0
+#line 413 "input"
+/*0x002d*/	BYTE $0
+#line 729 "input"
+/*0x002e*/	BYTE $0
+#line 729 "input"
+/*0x002f*/	BYTE $0
+#line 729 "input"
+/*0x0030*/	BYTE $0
+#line 948 "input"
+/*0x0031*/	BYTE $0
+#line 11 "input"
+/*0x0032*/	MOVQ $0x123456789, AX
+#line 11 "input"
+/*0x003c*/	MOVL $0x1234567, AX
+#line 11 "input"
+/*0x0041*/	BYTE $0
+#line 11 "input"
+/*0x0042*/	BYTE $0
+#line 11 "input"
+/*0x0043*/	POPQ AX
+/*      */	PCDATA $2, $342
+#line 11 "input"
+/*0x0044*/	MOVQ $0x123456789, AX
+#line 11 "input"
+/*0x004e*/	MOVQ $0x123456789, AX
+#line 11 "input"
+/*0x0058*/	MOVL $0x1234567, AX
+#line 11 "input"
+/*0x005d*/	BYTE $0
+#line 11 "input"
+/*0x005e*/	BYTE $0
+#line 70 "input"
+/*0x005f*/	BYTE $0
+#line 70 "input"
+/*0x0060*/	BYTE $0
+#line 70 "input"
+/*0x0061*/	BYTE $0
+#line 18 "input"
+/*0x0062*/	MOVQ $0x123456789, AX
+#line 18 "input"
+/*0x006c*/	MOVL $0x1234567, AX
+#line 18 "input"
+/*0x0071*/	BYTE $0
+#line 814 "input"
+/*0x0072*/	BYTE $0
+#line 814 "input"
+/*0x0073*/	PUSHQ AX
+#line 763 "input"
+/*0x0074*/	BYTE $0
+#line 763 "input"
+/*0x0075*/	BYTE $0
+#line 763 "input"
+/*0x0076*/	BYTE $0
+#line 530 "input"
+/*0x0077*/	BYTE $0
+#line 530 "input"
+/*0x0078*/	BYTE $0
+#line 530 "input"
+/*0x0079*/	BYTE $0
+#line 530 "input"
+/*0x007a*/	BYTE $0
+#line 985 "input"
+/*0x007b*/	BYTE $0
+#line 985 "input"
+/*0x007c*/	BYTE $0
+#line 985 "input"
+/*0x007d*/	BYTE $0
+#line 985 "input"
+/*0x007e*/	PUSHQ AX
+#line 985 "input"
+/*0x007f*/	MOVL $0x1234567, AX
+#line 958 "input"
+/*0x0084*/	BYTE $0
+#line 368 "input"
+/*0x0085*/	MOVQ $0x123456789, AX
+#line 368 "input"
+/*0x008f*/	MOVL $0x1234567, AX
+#line 368 "input"
+/*0x0094*/	BYTE $0
+#line 368 "input"
+/*0x0095*/	BYTE $0
+#line 368 "input"
+/*0x0096*/	BYTE $0
+#line 368 "input"
+/*0x0097*/	BYTE $0
+#line 75 "file0.s"
+/*0x0098*/	BYTE $0
+#line 75 "file0.s"
+/*0x0099*/	BYTE $0
+#line 75 "file0.s"
+/*0x009a*/	BYTE $0
+#line 75 "file0.s"
+/*0x009b*/	BYTE $0
+#line 588 "file0.s"
+/*0x009c*/	MOVQ $0x123456789, AX
+#line 187 "file0.s"
+/*0x00a6*/	MOVQ $0x123456789, AX
+#line 187 "file0.s"
+/*0x00b0*/	BYTE $0
+#line 202 "file0.s"
+/*0x00b1*/	MOVL $0x1234567, AX
+#line 202 "file0.s"
+/*0x00b6*/	BYTE $0
+#line 887 "file0.s"
+/*0x00b7*/	MOVL $0x1234567, AX
+#line 887 "file0.s"
+/*0x00bc*/	BYTE $0
+#line 887 "file0.s"
+/*0x00bd*/	BYTE $0
+#line 480 "file0.s"
+/*0x00be*/	MOVL $0x1234567, AX
+#line 480 "file0.s"
+/*0x00c3*/	BYTE $0
+#line 40 "file8.s"
+/*0x00c4*/	BYTE $0
+#line 17 "file0.s"
+/*0x00c5*/	MOVQ $0x123456789, AX
+#line 17 "file0.s"
+/*0x00cf*/	BYTE $0
+#line 17 "file0.s"
+/*0x00d0*/	BYTE $0
+#line 17 "file0.s"
+/*0x00d1*/	BYTE $0
+#line 17 "file0.s"
+/*0x00d2*/	BYTE $0
+#line 436 "file0.s"
+/*0x00d3*/	MOVL $0x1234567, AX
+#line 436 "file0.s"
+/*0x00d8*/	BYTE $0
+#line 436 "file0.s"
+/*0x00d9*/	BYTE $0
+#line 346 "file0.s"
+/*0x00da*/	BYTE $0
+#line 346 "file0.s"
+/*0x00db*/	BYTE $0
+#line 346 "file0.s"
+/*0x00dc*/	BYTE $0
+#line 812 "file0.s"
+/*0x00dd*/	BYTE $0
+#line 812 "file0.s"
+/*0x00de*/	BYTE $0
+#line 812 "file0.s"
+/*0x00df*/	BYTE $0
+#line 812 "file0.s"
+/*0x00e0*/	BYTE $0
+#line 94 "file1.s"
+/*0x00e1*/	BYTE $0
+#line 94 "file1.s"
+/*0x00e2*/	BYTE $0
+#line 165 "file1.s"
+/*0x00e3*/	MOVL $0x1234567, AX
+#line 165 "file1.s"
+/*0x00e8*/	BYTE $0
+#line 456 "file1.s"
+/*0x00e9*/	BYTE $0
+#line 810 "file1.s"
+/*0x00ea*/	BYTE $0
+#line 722 "file1.s"
+/*0x00eb*/	BYTE $0
+#line 722 "file1.s"
+/*0x00ec*/	BYTE $0
+#line 722 "file1.s"
+/*0x00ed*/	BYTE $0
+#line 722 "file1.s"
+/*0x00ee*/	BYTE $0
+#line 722 "file1.s"
+/*0x00ef*/	PUSHQ AX
+#line 722 "file1.s"
+/*0x00f0*/	BYTE $0
+#line 722 "file1.s"
+/*0x00f1*/	BYTE $0
+#line 722 "file1.s"
+/*0x00f2*/	BYTE $0
+#line 722 "file1.s"
+/*0x00f3*/	BYTE $0
+/*      */	PCDATA $2, $246
+#line 722 "file1.s"
+/*0x00f4*/	MOVQ $0x123456789, AX
+#line 722 "file1.s"
+/*0x00fe*/	MOVQ $0x123456789, AX
+#line 722 "file1.s"
+/*0x0108*/	MOVL $0x1234567, AX
+#line 722 "file1.s"
+/*0x010d*/	BYTE $0
+#line 722 "file1.s"
+/*0x010e*/	BYTE $0
+#line 497 "file1.s"
+/*0x010f*/	MOVQ $0x123456789, AX
+#line 497 "file1.s"
+/*0x0119*/	MOVQ $0x123456789, AX
+#line 497 "file1.s"
+/*0x0123*/	MOVQ $0x123456789, AX
+#line 497 "file1.s"
+/*0x012d*/	MOVL $0x1234567, AX
+#line 497 "file1.s"
+/*0x0132*/	BYTE $0
+#line 686 "file1.s"
+/*0x0133*/	BYTE $0
+#line 686 "file1.s"
+/*0x0134*/	BYTE $0
+#line 248 "file1.s"
+/*0x0135*/	BYTE $0
+#line 248 "file1.s"
+/*0x0136*/	BYTE $0
+#line 248 "file1.s"
+/*0x0137*/	BYTE $0
+#line 248 "file1.s"
+/*0x0138*/	BYTE $0
+#line 307 "file1.s"
+/*0x0139*/	BYTE $0
+#line 220 "file1.s"
+/*0x013a*/	MOVL $0x1234567, AX
+#line 220 "file1.s"
+/*0x013f*/	BYTE $0
+#line 220 "file1.s"
+/*0x0140*/	BYTE $0
+#line 467 "file1.s"
+/*0x0141*/	MOVQ $0x123456789, AX
+#line 467 "file1.s"
+/*0x014b*/	BYTE $0
+#line 467 "file1.s"
+/*0x014c*/	BYTE $0
+#line 467 "file1.s"
+/*0x014d*/	BYTE $0
+#line 467 "file1.s"
+/*0x014e*/	BYTE $0
+#line 786 "file1.s"
+/*0x014f*/	MOVL $0x1234567, AX
+#line 251 "file1.s"
+/*0x0154*/	BYTE $0
+/*      */	PCDATA $2, $64
+#line 251 "file1.s"
+/*0x0155*/	BYTE $0
+#line 251 "file1.s"
+/*0x0156*/	BYTE $0
+#line 251 "file1.s"
+/*0x0157*/	BYTE $0
+#line 618 "file1.s"
+/*0x0158*/	MOVQ $0x123456789, AX
+/*      */	PCDATA $1, $686
+#line 618 "file1.s"
+/*0x0162*/	BYTE $0
+#line 618 "file1.s"
+/*0x0163*/	BYTE $0
+#line 618 "file1.s"
+/*0x0164*/	BYTE $0
+#line 618 "file1.s"
+/*0x0165*/	PUSHQ AX
+/*      */	PCDATA $2, $915
+#line 618 "file1.s"
+/*0x0166*/	BYTE $0
+#line 618 "file1.s"
+/*0x0167*/	BYTE $0
+#line 618 "file1.s"
+/*0x0168*/	BYTE $0
+#line 618 "file1.s"
+/*0x0169*/	BYTE $0
+#line 230 "file1.s"
+/*0x016a*/	BYTE $0
+#line 823 "file1.s"
+/*0x016b*/	BYTE $0
+#line 145 "file1.s"
+/*0x016c*/	MOVQ $0x123456789, AX
+#line 145 "file1.s"
+/*0x0176*/	BYTE $0
+#line 145 "file1.s"
+/*0x0177*/	BYTE $0
+#line 675 "file1.s"
+/*0x0178*/	BYTE $0
+#line 62 "file9.s"
+/*0x0179*/	BYTE $0
+/*      */	PCDATA $2, $768
+#line 62 "file9.s"
+/*0x017a*/	BYTE $0
+#line 62 "file9.s"
+/*0x017b*/	BYTE $0
+#line 29 "file9.s"
+/*0x017c*/	BYTE $0
+#line 29 "file9.s"
+/*0x017d*/	BYTE $0
+#line 29 "file9.s"
+/*0x017e*/	BYTE $0
+#line 29 "file9.s"
+/*0x017f*/	BYTE $0
+#line 65 "file4.s"
+/*0x0180*/	BYTE $0
+#line 77 "file3.s"
+/*0x0181*/	MOVL $0x1234567, AX
+#line 77 "file3.s"
+/*0x0186*/	BYTE $0
+#line 77 "file3.s"
+/*0x0187*/	BYTE $0
+#line 77 "file3.s"
+/*0x0188*/	BYTE $0
+#line 307 "file3.s"
+/*0x0189*/	MOVQ $0x123456789, AX
+#line 307 "file3.s"
+/*0x0193*/	BYTE $0
+#line 654 "file3.s"
+/*0x0194*/	BYTE $0
+#line 654 "file3.s"
+/*0x0195*/	BYTE $0
+#line 115 "file3.s"
+/*0x0196*/	MOVL $0x1234567, AX
+#line 115 "file3.s"
+/*0x019b*/	BYTE $0
+#line 115 "file3.s"
+/*0x019c*/	BYTE $0
+#line 115 "file3.s"
+/*0x019d*/	BYTE $0
+#line 115 "file3.s"
+/*0x019e*/	BYTE $0
+#line 154 "file3.s"
+/*0x019f*/	MOVQ $0x123456789, AX
+#line 166 "file3.s"
+/*0x01a9*/	BYTE $0
+#line 166 "file3.s"
+/*0x01aa*/	BYTE $0
+#line 166 "file3.s"
+/*0x01ab*/	BYTE $0
+/*      */	PCDATA $1, $523
+#line 166 "file3.s"
+/*0x01ac*/	MOVL $0x1234567, AX
+#line 166 "file3.s"
+/*0x01b1*/	BYTE $0
+#line 779 "file3.s"
+/*0x01b2*/	BYTE $0
+#line 779 "file3.s"
+/*0x01b3*/	BYTE $0
+#line 515 "file3.s"
+/*0x01b4*/	BYTE $0
+#line 515 "file3.s"
+/*0x01b5*/	BYTE $0
+#line 369 "file3.s"
+/*0x01b6*/	MOVL $0x1234567, AX
+#line 369 "file3.s"
+/*0x01bb*/	BYTE $0
+#line 369 "file3.s"
+/*0x01bc*/	BYTE $0
+#line 369 "file3.s"
+/*0x01bd*/	BYTE $0
+#line 680 "file3.s"
+/*0x01be*/	BYTE $0
+#line 680 "file3.s"
+/*0x01bf*/	BYTE $0
+#line 680 "file3.s"
+/*0x01c0*/	BYTE $0
+#line 680 "file3.s"
+/*0x01c1*/	BYTE $0
+#line 131 "file3.s"
+/*0x01c2*/	MOVQ $0x123456789, AX
+#line 131 "file3.s"
+/*0x01cc*/	BYTE $0
+#line 131 "file3.s"
+/*0x01cd*/	BYTE $0
+#line 131 "file3.s"
+/*0x01ce*/	BYTE $0
+#line 131 "file3.s"
+/*0x01cf*/	BYTE $0
+#line 848 "file3.s"
+/*0x01d0*/	BYTE $0
+#line 848 "file3.s"
+/*0x01d1*/	BYTE $0
+#line 848 "file3.s"
+/*0x01d2*/	POPQ AX
+#line 848 "file3.s"
+/*0x01d3*/	BYTE $0
+#line 848 "file3.s"
+/*0x01d4*/	BYTE $0
+#line 848 "file3.s"
+/*0x01d5*/	BYTE $0
+/*      */	PCDATA $1, $86
+#line 848 "file3.s"
+/*0x01d6*/	MOVL $0x1234567, AX
+#line 438 "file3.s"
+/*0x01db*/	MOVQ $0x123456789, AX
+#line 438 "file3.s"
+/*0x01e5*/	MOVL $0x1234567, AX
+#line 5 "file3.s"
+/*0x01ea*/	BYTE $0
+#line 5 "file3.s"
+/*0x01eb*/	BYTE $0
+#line 531 "file3.s"
+/*0x01ec*/	MOVQ $0x123456789, AX
+#line 531 "file3.s"
+/*0x01f6*/	MOVQ $0x123456789, AX
+#line 531 "file3.s"
+/*0x0200*/	MOVQ $0x123456789, AX
+#line 531 "file3.s"
+/*0x020a*/	MOVL $0x1234567, AX
+#line 863 "file3.s"
+/*0x020f*/	BYTE $0
+#line 733 "file3.s"
+/*0x0210*/	MOVQ $0x123456789, AX
+#line 166 "file3.s"
+/*0x021a*/	MOVQ $0x123456789, AX
+#line 166 "file3.s"
+/*0x0224*/	BYTE $0
+#line 166 "file3.s"
+/*0x0225*/	BYTE $0
+#line 166 "file3.s"
+/*0x0226*/	BYTE $0
+#line 166 "file3.s"
+/*0x0227*/	BYTE $0
+#line 54 "file3.s"
+/*0x0228*/	MOVQ $0x123456789, AX
+#line 54 "file3.s"
+/*0x0232*/	BYTE $0
+#line 54 "file3.s"
+/*0x0233*/	BYTE $0
+#line 54 "file3.s"
+/*0x0234*/	BYTE $0
+#line 20 "file4.s"
+/*0x0235*/	BYTE $0
+#line 20 "file4.s"
+/*0x0236*/	BYTE $0
+#line 546 "file4.s"
+/*0x0237*/	BYTE $0
+#line 546 "file4.s"
+/*0x0238*/	BYTE $0
+#line 74 "file4.s"
+/*0x0239*/	BYTE $0
+#line 31 "file4.s"
+/*0x023a*/	BYTE $0
+#line 31 "file4.s"
+/*0x023b*/	BYTE $0
+#line 31 "file4.s"
+/*0x023c*/	BYTE $0
+#line 31 "file4.s"
+/*0x023d*/	BYTE $0
+#line 834 "file4.s"
+/*0x023e*/	BYTE $0
+#line 834 "file4.s"
+/*0x023f*/	BYTE $0
+#line 519 "file4.s"
+/*0x0240*/	MOVL $0x1234567, AX
+#line 342 "file4.s"
+/*0x0245*/	BYTE $0
+#line 342 "file4.s"
+/*0x0246*/	BYTE $0
+#line 342 "file4.s"
+/*0x0247*/	BYTE $0
+#line 458 "file4.s"
+/*0x0248*/	BYTE $0
+#line 458 "file4.s"
+/*0x0249*/	BYTE $0
+#line 458 "file4.s"
+/*0x024a*/	BYTE $0
+#line 458 "file4.s"
+/*0x024b*/	BYTE $0
+#line 13 "file9.s"
+/*0x024c*/	BYTE $0
+#line 13 "file9.s"
+/*0x024d*/	BYTE $0
+#line 13 "file9.s"
+/*0x024e*/	BYTE $0
+#line 365 "file9.s"
+/*0x024f*/	BYTE $0
+#line 749 "file9.s"
+/*0x0250*/	MOVL $0x1234567, AX
+#line 749 "file9.s"
+/*0x0255*/	BYTE $0
+#line 749 "file9.s"
+/*0x0256*/	BYTE $0
+#line 41 "file0.s"
+/*0x0257*/	MOVL $0x1234567, AX
+#line 41 "file0.s"
+/*0x025c*/	BYTE $0
+#line 41 "file0.s"
+/*0x025d*/	BYTE $0
+#line 41 "file0.s"
+/*0x025e*/	BYTE $0
+#line 869 "file0.s"
+/*0x025f*/	BYTE $0
+#line 881 "file0.s"
+/*0x0260*/	MOVQ $0x123456789, AX
+#line 881 "file0.s"
+/*0x026a*/	MOVQ $0x123456789, AX
+	POPQ AX
+	POPQ AX
+	RET
+
+GLOBL funcdata0(SB), $16
+#line 1 "input"
+TEXT func1(SB),7,$40-648
+	FUNCDATA $1, funcdata1(SB)
+#line 1 "input"
+#line 1 "input"
+/*0x0004*/	BYTE $0
+#line 12 "file4.s"
+/*0x0005*/	MOVL $0x1234567, AX
+#line 12 "file4.s"
+/*0x000a*/	BYTE $0
+#line 12 "file4.s"
+/*0x000b*/	BYTE $0
+#line 12 "file4.s"
+/*0x000c*/	BYTE $0
+/*      */	PCDATA $2, $705
+#line 12 "file4.s"
+/*0x000d*/	MOVQ $0x123456789, AX
+#line 12 "file4.s"
+/*0x0017*/	BYTE $0
+#line 633 "file4.s"
+/*0x0018*/	MOVQ $0x123456789, AX
+#line 633 "file4.s"
+/*0x0022*/	MOVL $0x1234567, AX
+#line 633 "file4.s"
+/*0x0027*/	POPQ AX
+#line 633 "file4.s"
+/*0x0028*/	BYTE $0
+#line 633 "file4.s"
+/*0x0029*/	BYTE $0
+#line 633 "file4.s"
+/*0x002a*/	BYTE $0
+#line 633 "file4.s"
+/*0x002b*/	PUSHQ AX
+#line 633 "file4.s"
+/*0x002c*/	MOVL $0x1234567, AX
+#line 997 "file4.s"
+/*0x0031*/	BYTE $0
+#line 997 "file4.s"
+/*0x0032*/	BYTE $0
+#line 997 "file4.s"
+/*0x0033*/	BYTE $0
+#line 997 "file4.s"
+/*0x0034*/	BYTE $0
+#line 997 "file4.s"
+/*0x0035*/	POPQ AX
+#line 997 "file4.s"
+/*0x0036*/	BYTE $0
+#line 997 "file4.s"
+/*0x0037*/	BYTE $0
+#line 1 "file4.s"
+/*0x0038*/	MOVQ $0x123456789, AX
+#line 1 "file4.s"
+/*0x0042*/	MOVQ $0x123456789, AX
+#line 1 "file4.s"
+/*0x004c*/	MOVQ $0x123456789, AX
+#line 1 "file4.s"
+/*0x0056*/	MOVQ $0x123456789, AX
+#line 1 "file4.s"
+/*0x0060*/	BYTE $0
+#line 922 "file4.s"
+/*0x0061*/	BYTE $0
+#line 375 "file4.s"
+/*0x0062*/	MOVL $0x1234567, AX
+/*      */	PCDATA $1, $51
+#line 31 "file4.s"
+/*0x0067*/	MOVQ $0x123456789, AX
+#line 31 "file4.s"
+/*0x0071*/	BYTE $0
+#line 620 "file4.s"
+/*0x0072*/	MOVL $0x1234567, AX
+#line 620 "file4.s"
+/*0x0077*/	BYTE $0
+#line 695 "file4.s"
+/*0x0078*/	MOVL $0x1234567, AX
+#line 799 "file4.s"
+/*0x007d*/	MOVL $0x1234567, AX
+#line 41 "file4.s"
+/*0x0082*/	BYTE $0
+#line 795 "file4.s"
+/*0x0083*/	MOVL $0x1234567, AX
+#line 908 "file4.s"
+/*0x0088*/	BYTE $0
+#line 905 "file4.s"
+/*0x0089*/	BYTE $0
+#line 905 "file4.s"
+/*0x008a*/	BYTE $0
+#line 905 "file4.s"
+/*0x008b*/	BYTE $0
+#line 905 "file4.s"
+/*0x008c*/	BYTE $0
+#line 861 "file4.s"
+/*0x008d*/	MOVL $0x1234567, AX
+#line 861 "file4.s"
+/*0x0092*/	BYTE $0
+#line 861 "file4.s"
+/*0x0093*/	BYTE $0
+#line 861 "file4.s"
+/*0x0094*/	BYTE $0
+#line 861 "file4.s"
+/*0x0095*/	BYTE $0
+/*      */	PCDATA $1, $192
+#line 861 "file4.s"
+/*0x0096*/	MOVQ $0x123456789, AX
+/*      */	PCDATA $1, $60
+#line 861 "file4.s"
+/*0x00a0*/	MOVL $0x1234567, AX
+#line 861 "file4.s"
+/*0x00a5*/	BYTE $0
+#line 861 "file4.s"
+/*0x00a6*/	BYTE $0
+#line 56 "file6.s"
+/*0x00a7*/	MOVQ $0x123456789, AX
+#line 56 "file6.s"
+/*0x00b1*/	BYTE $0
+#line 56 "file6.s"
+/*0x00b2*/	BYTE $0
+#line 56 "file6.s"
+/*0x00b3*/	BYTE $0
+#line 204 "file6.s"
+/*0x00b4*/	BYTE $0
+#line 204 "file6.s"
+/*0x00b5*/	BYTE $0
+#line 204 "file6.s"
+/*0x00b6*/	BYTE $0
+#line 204 "file6.s"
+/*0x00b7*/	BYTE $0
+#line 979 "file6.s"
+/*0x00b8*/	MOVL $0x1234567, AX
+#line 979 "file6.s"
+/*0x00bd*/	BYTE $0
+#line 979 "file6.s"
+/*0x00be*/	BYTE $0
+#line 979 "file6.s"
+/*0x00bf*/	BYTE $0
+#line 58 "file6.s"
+/*0x00c0*/	MOVL $0x1234567, AX
+#line 238 "file6.s"
+/*0x00c5*/	MOVL $0x1234567, AX
+#line 238 "file6.s"
+/*0x00ca*/	BYTE $0
+#line 238 "file6.s"
+/*0x00cb*/	BYTE $0
+#line 699 "file2.s"
+/*0x00cc*/	MOVQ $0x123456789, AX
+#line 699 "file2.s"
+/*0x00d6*/	BYTE $0
+#line 699 "file2.s"
+/*0x00d7*/	BYTE $0
+#line 514 "file2.s"
+/*0x00d8*/	MOVL $0x1234567, AX
+#line 514 "file2.s"
+/*0x00dd*/	BYTE $0
+#line 514 "file2.s"
+/*0x00de*/	BYTE $0
+#line 108 "file2.s"
+/*0x00df*/	MOVQ $0x123456789, AX
+#line 108 "file2.s"
+/*0x00e9*/	MOVQ $0x123456789, AX
+#line 108 "file2.s"
+/*0x00f3*/	MOVL $0x1234567, AX
+#line 108 "file2.s"
+/*0x00f8*/	BYTE $0
+#line 108 "file2.s"
+/*0x00f9*/	BYTE $0
+#line 918 "file2.s"
+/*0x00fa*/	BYTE $0
+#line 918 "file2.s"
+/*0x00fb*/	BYTE $0
+#line 785 "file2.s"
+/*0x00fc*/	BYTE $0
+#line 3 "file5.s"
+/*0x00fd*/	BYTE $0
+#line 918 "file5.s"
+/*0x00fe*/	BYTE $0
+#line 918 "file5.s"
+/*0x00ff*/	BYTE $0
+#line 670 "file5.s"
+/*0x0100*/	MOVL $0x1234567, AX
+#line 670 "file5.s"
+/*0x0105*/	BYTE $0
+#line 720 "file5.s"
+/*0x0106*/	BYTE $0
+#line 384 "file5.s"
+/*0x0107*/	MOVQ $0x123456789, AX
+#line 384 "file5.s"
+/*0x0111*/	MOVQ $0x123456789, AX
+#line 384 "file5.s"
+/*0x011b*/	MOVQ $0x123456789, AX
+#line 384 "file5.s"
+/*0x0125*/	BYTE $0
+#line 384 "file5.s"
+/*0x0126*/	BYTE $0
+#line 263 "file5.s"
+/*0x0127*/	BYTE $0
+#line 750 "file5.s"
+/*0x0128*/	MOVL $0x1234567, AX
+#line 750 "file5.s"
+/*0x012d*/	BYTE $0
+#line 679 "file5.s"
+/*0x012e*/	MOVL $0x1234567, AX
+#line 679 "file5.s"
+/*0x0133*/	BYTE $0
+#line 679 "file5.s"
+/*0x0134*/	BYTE $0
+#line 679 "file5.s"
+/*0x0135*/	BYTE $0
+#line 679 "file5.s"
+/*0x0136*/	POPQ AX
+#line 171 "file5.s"
+/*0x0137*/	MOVL $0x1234567, AX
+#line 171 "file5.s"
+/*0x013c*/	BYTE $0
+#line 34 "file2.s"
+/*0x013d*/	BYTE $0
+#line 34 "file2.s"
+/*0x013e*/	BYTE $0
+#line 34 "file2.s"
+/*0x013f*/	BYTE $0
+#line 732 "file2.s"
+/*0x0140*/	BYTE $0
+#line 732 "file2.s"
+/*0x0141*/	PUSHQ AX
+#line 485 "file2.s"
+/*0x0142*/	BYTE $0
+#line 485 "file2.s"
+/*0x0143*/	BYTE $0
+#line 485 "file2.s"
+/*0x0144*/	BYTE $0
+#line 222 "file2.s"
+/*0x0145*/	BYTE $0
+#line 222 "file2.s"
+/*0x0146*/	BYTE $0
+/*      */	PCDATA $1, $462
+#line 222 "file2.s"
+/*0x0147*/	MOVQ $0x123456789, AX
+#line 222 "file2.s"
+/*0x0151*/	MOVL $0x1234567, AX
+#line 222 "file2.s"
+/*0x0156*/	BYTE $0
+#line 677 "file2.s"
+/*0x0157*/	BYTE $0
+#line 117 "file2.s"
+/*0x0158*/	MOVL $0x1234567, AX
+#line 117 "file2.s"
+/*0x015d*/	BYTE $0
+#line 117 "file2.s"
+/*0x015e*/	BYTE $0
+#line 361 "file2.s"
+/*0x015f*/	MOVL $0x1234567, AX
+#line 590 "file2.s"
+/*0x0164*/	BYTE $0
+#line 590 "file2.s"
+/*0x0165*/	BYTE $0
+#line 58 "file2.s"
+/*0x0166*/	MOVL $0x1234567, AX
+#line 58 "file2.s"
+/*0x016b*/	BYTE $0
+#line 58 "file2.s"
+/*0x016c*/	BYTE $0
+#line 58 "file2.s"
+/*0x016d*/	BYTE $0
+#line 58 "file2.s"
+/*0x016e*/	BYTE $0
+#line 983 "file2.s"
+/*0x016f*/	BYTE $0
+#line 983 "file2.s"
+/*0x0170*/	BYTE $0
+#line 983 "file2.s"
+/*0x0171*/	BYTE $0
+#line 983 "file2.s"
+/*0x0172*/	BYTE $0
+#line 727 "file2.s"
+/*0x0173*/	MOVL $0x1234567, AX
+#line 450 "file2.s"
+/*0x0178*/	BYTE $0
+#line 450 "file2.s"
+/*0x0179*/	BYTE $0
+#line 450 "file2.s"
+/*0x017a*/	BYTE $0
+#line 450 "file2.s"
+/*0x017b*/	BYTE $0
+#line 334 "file2.s"
+/*0x017c*/	BYTE $0
+#line 334 "file2.s"
+/*0x017d*/	BYTE $0
+#line 334 "file2.s"
+/*0x017e*/	BYTE $0
+#line 334 "file2.s"
+/*0x017f*/	BYTE $0
+#line 465 "file2.s"
+/*0x0180*/	MOVL $0x1234567, AX
+/*      */	PCDATA $1, $518
+#line 465 "file2.s"
+/*0x0185*/	MOVL $0x1234567, AX
+#line 465 "file2.s"
+/*0x018a*/	BYTE $0
+#line 465 "file2.s"
+/*0x018b*/	BYTE $0
+#line 465 "file2.s"
+/*0x018c*/	BYTE $0
+#line 465 "file2.s"
+/*0x018d*/	BYTE $0
+#line 682 "file2.s"
+/*0x018e*/	MOVL $0x1234567, AX
+#line 682 "file2.s"
+/*0x0193*/	BYTE $0
+#line 682 "file2.s"
+/*0x0194*/	BYTE $0
+#line 846 "file2.s"
+/*0x0195*/	MOVQ $0x123456789, AX
+#line 846 "file2.s"
+/*0x019f*/	BYTE $0
+#line 846 "file2.s"
+/*0x01a0*/	BYTE $0
+#line 846 "file2.s"
+/*0x01a1*/	POPQ AX
+#line 846 "file2.s"
+/*0x01a2*/	BYTE $0
+#line 846 "file2.s"
+/*0x01a3*/	BYTE $0
+#line 49 "file2.s"
+/*0x01a4*/	BYTE $0
+#line 49 "file2.s"
+/*0x01a5*/	BYTE $0
+#line 49 "file2.s"
+/*0x01a6*/	BYTE $0
+#line 726 "file2.s"
+/*0x01a7*/	MOVQ $0x123456789, AX
+#line 726 "file2.s"
+/*0x01b1*/	MOVL $0x1234567, AX
+#line 726 "file2.s"
+/*0x01b6*/	BYTE $0
+#line 726 "file2.s"
+/*0x01b7*/	BYTE $0
+#line 726 "file2.s"
+/*0x01b8*/	BYTE $0
+#line 726 "file2.s"
+/*0x01b9*/	PUSHQ AX
+#line 726 "file2.s"
+/*0x01ba*/	BYTE $0
+#line 726 "file2.s"
+/*0x01bb*/	BYTE $0
+#line 726 "file2.s"
+/*0x01bc*/	BYTE $0
+#line 726 "file2.s"
+/*0x01bd*/	BYTE $0
+#line 13 "file1.s"
+/*0x01be*/	BYTE $0
+#line 13 "file1.s"
+/*0x01bf*/	BYTE $0
+#line 13 "file1.s"
+/*0x01c0*/	BYTE $0
+#line 827 "file1.s"
+/*0x01c1*/	MOVL $0x1234567, AX
+#line 827 "file1.s"
+/*0x01c6*/	BYTE $0
+#line 827 "file1.s"
+/*0x01c7*/	BYTE $0
+#line 827 "file1.s"
+/*0x01c8*/	BYTE $0
+#line 827 "file1.s"
+/*0x01c9*/	BYTE $0
+#line 783 "file1.s"
+/*0x01ca*/	BYTE $0
+#line 783 "file1.s"
+/*0x01cb*/	BYTE $0
+#line 783 "file1.s"
+/*0x01cc*/	BYTE $0
+#line 783 "file1.s"
+/*0x01cd*/	BYTE $0
+#line 367 "file1.s"
+/*0x01ce*/	MOVQ $0x123456789, AX
+#line 367 "file1.s"
+/*0x01d8*/	MOVL $0x1234567, AX
+#line 367 "file1.s"
+/*0x01dd*/	BYTE $0
+#line 367 "file1.s"
+/*0x01de*/	BYTE $0
+#line 367 "file1.s"
+/*0x01df*/	BYTE $0
+#line 367 "file1.s"
+/*0x01e0*/	BYTE $0
+#line 581 "file1.s"
+/*0x01e1*/	BYTE $0
+#line 581 "file1.s"
+/*0x01e2*/	BYTE $0
+#line 581 "file1.s"
+/*0x01e3*/	BYTE $0
+#line 638 "file1.s"
+/*0x01e4*/	MOVQ $0x123456789, AX
+#line 638 "file1.s"
+/*0x01ee*/	MOVL $0x1234567, AX
+#line 638 "file1.s"
+/*0x01f3*/	BYTE $0
+#line 638 "file1.s"
+/*0x01f4*/	BYTE $0
+#line 638 "file1.s"
+/*0x01f5*/	BYTE $0
+#line 359 "file1.s"
+/*0x01f6*/	BYTE $0
+#line 449 "file1.s"
+/*0x01f7*/	BYTE $0
+#line 449 "file1.s"
+/*0x01f8*/	BYTE $0
+#line 449 "file1.s"
+/*0x01f9*/	BYTE $0
+#line 298 "file1.s"
+/*0x01fa*/	BYTE $0
+#line 298 "file1.s"
+/*0x01fb*/	BYTE $0
+#line 257 "file1.s"
+/*0x01fc*/	BYTE $0
+#line 257 "file1.s"
+/*0x01fd*/	BYTE $0
+#line 257 "file1.s"
+/*0x01fe*/	BYTE $0
+#line 512 "file1.s"
+/*0x01ff*/	MOVL $0x1234567, AX
+#line 512 "file1.s"
+/*0x0204*/	BYTE $0
+#line 512 "file1.s"
+/*0x0205*/	BYTE $0
+#line 617 "file1.s"
+/*0x0206*/	MOVL $0x1234567, AX
+#line 478 "file1.s"
+/*0x020b*/	BYTE $0
+/*      */	PCDATA $2, $351
+#line 478 "file1.s"
+/*0x020c*/	BYTE $0
+#line 958 "file1.s"
+/*0x020d*/	BYTE $0
+#line 958 "file1.s"
+/*0x020e*/	BYTE $0
+#line 958 "file1.s"
+/*0x020f*/	BYTE $0
+#line 958 "file1.s"
+/*0x0210*/	BYTE $0
+#line 371 "file1.s"
+/*0x0211*/	MOVQ $0x123456789, AX
+#line 371 "file1.s"
+/*0x021b*/	BYTE $0
+#line 371 "file1.s"
+/*0x021c*/	BYTE $0
+#line 56 "file3.s"
+/*0x021d*/	MOVL $0x1234567, AX
+#line 56 "file3.s"
+/*0x0222*/	BYTE $0
+#line 56 "file3.s"
+/*0x0223*/	BYTE $0
+#line 56 "file9.s"
+/*0x0224*/	MOVQ $0x123456789, AX
+#line 56 "file9.s"
+/*0x022e*/	BYTE $0
+#line 56 "file9.s"
+/*0x022f*/	BYTE $0
+#line 56 "file9.s"
+/*0x0230*/	BYTE $0
+#line 56 "file9.s"
+/*0x0231*/	BYTE $0
+#line 684 "file9.s"
+/*0x0232*/	MOVQ $0x123456789, AX
+#line 684 "file9.s"
+/*0x023c*/	BYTE $0
+#line 684 "file9.s"
+/*0x023d*/	POPQ AX
+#line 407 "file9.s"
+/*0x023e*/	MOVL $0x1234567, AX
+#line 407 "file9.s"
+/*0x0243*/	BYTE $0
+	PUSHQ AX
+	PUSHQ AX
+	RET
+
+GLOBL funcdata1(SB), $16
+#line 1 "input"
+TEXT func2(SB),7,$40-688
+	FUNCDATA $1, funcdata2(SB)
+#line 1 "input"
+#line 1 "input"
+/*0x0004*/	BYTE $0
+#line 860 "input"
+/*0x0005*/	BYTE $0
+#line 860 "input"
+/*0x0006*/	BYTE $0
+#line 860 "input"
+/*0x0007*/	BYTE $0
+#line 860 "input"
+/*0x0008*/	BYTE $0
+#line 85 "input"
+/*0x0009*/	BYTE $0
+#line 85 "input"
+/*0x000a*/	BYTE $0
+#line 355 "input"
+/*0x000b*/	MOVQ $0x123456789, AX
+#line 355 "input"
+/*0x0015*/	MOVL $0x1234567, AX
+#line 355 "input"
+/*0x001a*/	BYTE $0
+#line 355 "input"
+/*0x001b*/	BYTE $0
+#line 355 "input"
+/*0x001c*/	BYTE $0
+#line 840 "input"
+/*0x001d*/	MOVL $0x1234567, AX
+#line 840 "input"
+/*0x0022*/	BYTE $0
+#line 294 "input"
+/*0x0023*/	MOVQ $0x123456789, AX
+#line 294 "input"
+/*0x002d*/	MOVQ $0x123456789, AX
+#line 294 "input"
+/*0x0037*/	MOVQ $0x123456789, AX
+#line 294 "input"
+/*0x0041*/	BYTE $0
+#line 294 "input"
+/*0x0042*/	BYTE $0
+#line 294 "input"
+/*0x0043*/	BYTE $0
+#line 294 "input"
+/*0x0044*/	BYTE $0
+/*      */	PCDATA $1, $385
+#line 294 "input"
+/*0x0045*/	BYTE $0
+#line 294 "input"
+/*0x0046*/	BYTE $0
+#line 294 "input"
+/*0x0047*/	BYTE $0
+#line 81 "file9.s"
+/*0x0048*/	MOVL $0x1234567, AX
+#line 81 "file9.s"
+/*0x004d*/	BYTE $0
+#line 81 "file9.s"
+/*0x004e*/	BYTE $0
+#line 81 "file9.s"
+/*0x004f*/	POPQ AX
+#line 81 "file9.s"
+/*0x0050*/	MOVL $0x1234567, AX
+#line 81 "file9.s"
+/*0x0055*/	BYTE $0
+/*      */	PCDATA $1, $701
+#line 81 "file9.s"
+/*0x0056*/	MOVL $0x1234567, AX
+#line 81 "file9.s"
+/*0x005b*/	BYTE $0
+#line 81 "file9.s"
+/*0x005c*/	BYTE $0
+#line 81 "file9.s"
+/*0x005d*/	BYTE $0
+#line 81 "file9.s"
+/*0x005e*/	BYTE $0
+#line 290 "file9.s"
+/*0x005f*/	BYTE $0
+#line 290 "file9.s"
+/*0x0060*/	BYTE $0
+#line 290 "file9.s"
+/*0x0061*/	BYTE $0
+#line 197 "file9.s"
+/*0x0062*/	MOVL $0x1234567, AX
+#line 197 "file9.s"
+/*0x0067*/	BYTE $0
+#line 608 "file9.s"
+/*0x0068*/	MOVQ $0x123456789, AX
+#line 608 "file9.s"
+/*0x0072*/	MOVQ $0x123456789, AX
+#line 608 "file9.s"
+/*0x007c*/	BYTE $0
+/*      */	PCDATA $1, $562
+#line 608 "file9.s"
+/*0x007d*/	BYTE $0
+#line 608 "file9.s"
+/*0x007e*/	BYTE $0
+#line 189 "file9.s"
+/*0x007f*/	MOVL $0x1234567, AX
+#line 189 "file9.s"
+/*0x0084*/	BYTE $0
+#line 189 "file9.s"
+/*0x0085*/	BYTE $0
+#line 189 "file9.s"
+/*0x0086*/	BYTE $0
+#line 189 "file9.s"
+/*0x0087*/	BYTE $0
+#line 472 "file9.s"
+/*0x0088*/	MOVL $0x1234567, AX
+#line 472 "file9.s"
+/*0x008d*/	BYTE $0
+#line 472 "file9.s"
+/*0x008e*/	BYTE $0
+#line 472 "file9.s"
+/*0x008f*/	PUSHQ AX
+#line 472 "file9.s"
+/*0x0090*/	MOVQ $0x123456789, AX
+#line 472 "file9.s"
+/*0x009a*/	MOVL $0x1234567, AX
+#line 472 "file9.s"
+/*0x009f*/	BYTE $0
+#line 472 "file9.s"
+/*0x00a0*/	BYTE $0
+#line 472 "file9.s"
+/*0x00a1*/	BYTE $0
+#line 472 "file9.s"
+/*0x00a2*/	BYTE $0
+#line 148 "file9.s"
+/*0x00a3*/	MOVQ $0x123456789, AX
+#line 148 "file9.s"
+/*0x00ad*/	BYTE $0
+#line 148 "file9.s"
+/*0x00ae*/	BYTE $0
+#line 148 "file9.s"
+/*0x00af*/	BYTE $0
+#line 148 "file9.s"
+/*0x00b0*/	BYTE $0
+#line 562 "file9.s"
+/*0x00b1*/	MOVL $0x1234567, AX
+#line 562 "file9.s"
+/*0x00b6*/	BYTE $0
+#line 562 "file9.s"
+/*0x00b7*/	PUSHQ AX
+#line 562 "file9.s"
+/*0x00b8*/	BYTE $0
+#line 532 "file9.s"
+/*0x00b9*/	MOVQ $0x123456789, AX
+#line 532 "file9.s"
+/*0x00c3*/	MOVQ $0x123456789, AX
+#line 282 "file9.s"
+/*0x00cd*/	BYTE $0
+#line 282 "file9.s"
+/*0x00ce*/	BYTE $0
+#line 282 "file9.s"
+/*0x00cf*/	BYTE $0
+/*      */	PCDATA $2, $861
+#line 282 "file9.s"
+/*0x00d0*/	BYTE $0
+#line 282 "file9.s"
+/*0x00d1*/	BYTE $0
+/*      */	PCDATA $2, $310
+#line 282 "file9.s"
+/*0x00d2*/	BYTE $0
+#line 416 "file9.s"
+/*0x00d3*/	MOVQ $0x123456789, AX
+#line 416 "file9.s"
+/*0x00dd*/	MOVL $0x1234567, AX
+#line 780 "file9.s"
+/*0x00e2*/	BYTE $0
+#line 780 "file9.s"
+/*0x00e3*/	BYTE $0
+#line 765 "file9.s"
+/*0x00e4*/	MOVL $0x1234567, AX
+#line 523 "file9.s"
+/*0x00e9*/	BYTE $0
+#line 523 "file9.s"
+/*0x00ea*/	BYTE $0
+#line 523 "file9.s"
+/*0x00eb*/	BYTE $0
+#line 733 "file9.s"
+/*0x00ec*/	MOVQ $0x123456789, AX
+#line 378 "file9.s"
+/*0x00f6*/	BYTE $0
+#line 378 "file9.s"
+/*0x00f7*/	BYTE $0
+#line 378 "file9.s"
+/*0x00f8*/	BYTE $0
+#line 378 "file9.s"
+/*0x00f9*/	BYTE $0
+#line 540 "file9.s"
+/*0x00fa*/	BYTE $0
+#line 540 "file9.s"
+/*0x00fb*/	BYTE $0
+#line 57 "file9.s"
+/*0x00fc*/	BYTE $0
+#line 57 "file9.s"
+/*0x00fd*/	BYTE $0
+#line 57 "file9.s"
+/*0x00fe*/	BYTE $0
+#line 417 "file9.s"
+/*0x00ff*/	BYTE $0
+/*      */	PCDATA $1, $932
+#line 417 "file9.s"
+/*0x0100*/	BYTE $0
+#line 417 "file9.s"
+/*0x0101*/	BYTE $0
+#line 417 "file9.s"
+/*0x0102*/	BYTE $0
+#line 417 "file9.s"
+/*0x0103*/	BYTE $0
+#line 713 "file9.s"
+/*0x0104*/	MOVL $0x1234567, AX
+#line 610 "file0.s"
+/*0x0109*/	MOVQ $0x123456789, AX
+#line 610 "file0.s"
+/*0x0113*/	MOVL $0x1234567, AX
+#line 610 "file0.s"
+/*0x0118*/	BYTE $0
+#line 787 "file0.s"
+/*0x0119*/	MOVQ $0x123456789, AX
+#line 829 "file0.s"
+/*0x0123*/	BYTE $0
+#line 829 "file0.s"
+/*0x0124*/	BYTE $0
+#line 829 "file0.s"
+/*0x0125*/	BYTE $0
+#line 849 "file0.s"
+/*0x0126*/	BYTE $0
+#line 849 "file0.s"
+/*0x0127*/	BYTE $0
+#line 849 "file0.s"
+/*0x0128*/	BYTE $0
+/*      */	PCDATA $2, $356
+#line 849 "file0.s"
+/*0x0129*/	BYTE $0
+#line 849 "file0.s"
+/*0x012a*/	BYTE $0
+#line 88 "file0.s"
+/*0x012b*/	MOVL $0x1234567, AX
+#line 88 "file0.s"
+/*0x0130*/	BYTE $0
+#line 88 "file0.s"
+/*0x0131*/	BYTE $0
+#line 88 "file0.s"
+/*0x0132*/	BYTE $0
+#line 684 "file0.s"
+/*0x0133*/	BYTE $0
+#line 684 "file0.s"
+/*0x0134*/	BYTE $0
+#line 684 "file0.s"
+/*0x0135*/	BYTE $0
+#line 684 "file0.s"
+/*0x0136*/	BYTE $0
+#line 238 "file0.s"
+/*0x0137*/	BYTE $0
+#line 238 "file0.s"
+/*0x0138*/	BYTE $0
+#line 238 "file0.s"
+/*0x0139*/	PUSHQ AX
+#line 238 "file0.s"
+/*0x013a*/	BYTE $0
+#line 238 "file0.s"
+/*0x013b*/	BYTE $0
+#line 603 "file0.s"
+/*0x013c*/	BYTE $0
+#line 981 "file0.s"
+/*0x013d*/	BYTE $0
+#line 981 "file0.s"
+/*0x013e*/	POPQ AX
+#line 616 "file0.s"
+/*0x013f*/	BYTE $0
+#line 616 "file0.s"
+/*0x0140*/	BYTE $0
+#line 616 "file0.s"
+/*0x0141*/	BYTE $0
+#line 616 "file0.s"
+/*0x0142*/	BYTE $0
+#line 716 "file0.s"
+/*0x0143*/	MOVL $0x1234567, AX
+#line 716 "file0.s"
+/*0x0148*/	BYTE $0
+#line 716 "file0.s"
+/*0x0149*/	BYTE $0
+#line 34 "file0.s"
+/*0x014a*/	BYTE $0
+#line 34 "file0.s"
+/*0x014b*/	BYTE $0
+#line 34 "file0.s"
+/*0x014c*/	BYTE $0
+#line 90 "file0.s"
+/*0x014d*/	MOVL $0x1234567, AX
+#line 316 "file0.s"
+/*0x0152*/	MOVQ $0x123456789, AX
+#line 230 "file0.s"
+/*0x015c*/	MOVQ $0x123456789, AX
+#line 799 "file0.s"
+/*0x0166*/	MOVQ $0x123456789, AX
+#line 799 "file0.s"
+/*0x0170*/	BYTE $0
+#line 799 "file0.s"
+/*0x0171*/	BYTE $0
+/*      */	PCDATA $1, $247
+#line 799 "file0.s"
+/*0x0172*/	BYTE $0
+#line 799 "file0.s"
+/*0x0173*/	BYTE $0
+#line 799 "file0.s"
+/*0x0174*/	BYTE $0
+#line 655 "file0.s"
+/*0x0175*/	MOVL $0x1234567, AX
+#line 655 "file0.s"
+/*0x017a*/	BYTE $0
+#line 551 "file0.s"
+/*0x017b*/	BYTE $0
+#line 551 "file0.s"
+/*0x017c*/	BYTE $0
+#line 271 "file0.s"
+/*0x017d*/	MOVQ $0x123456789, AX
+#line 271 "file0.s"
+/*0x0187*/	MOVQ $0x123456789, AX
+#line 271 "file0.s"
+/*0x0191*/	MOVL $0x1234567, AX
+#line 271 "file0.s"
+/*0x0196*/	BYTE $0
+#line 271 "file0.s"
+/*0x0197*/	BYTE $0
+#line 271 "file0.s"
+/*0x0198*/	BYTE $0
+#line 233 "file0.s"
+/*0x0199*/	MOVL $0x1234567, AX
+#line 233 "file0.s"
+/*0x019e*/	BYTE $0
+#line 233 "file0.s"
+/*0x019f*/	BYTE $0
+#line 233 "file0.s"
+/*0x01a0*/	BYTE $0
+#line 233 "file0.s"
+/*0x01a1*/	BYTE $0
+#line 738 "file0.s"
+/*0x01a2*/	MOVL $0x1234567, AX
+#line 738 "file0.s"
+/*0x01a7*/	BYTE $0
+#line 800 "file0.s"
+/*0x01a8*/	BYTE $0
+#line 800 "file0.s"
+/*0x01a9*/	BYTE $0
+#line 646 "file0.s"
+/*0x01aa*/	MOVQ $0x123456789, AX
+#line 646 "file0.s"
+/*0x01b4*/	BYTE $0
+#line 646 "file0.s"
+/*0x01b5*/	BYTE $0
+#line 646 "file0.s"
+/*0x01b6*/	BYTE $0
+#line 709 "file0.s"
+/*0x01b7*/	BYTE $0
+#line 709 "file0.s"
+/*0x01b8*/	BYTE $0
+#line 709 "file0.s"
+/*0x01b9*/	BYTE $0
+#line 709 "file0.s"
+/*0x01ba*/	BYTE $0
+#line 296 "file0.s"
+/*0x01bb*/	BYTE $0
+#line 296 "file0.s"
+/*0x01bc*/	BYTE $0
+#line 296 "file0.s"
+/*0x01bd*/	BYTE $0
+#line 71 "file0.s"
+/*0x01be*/	BYTE $0
+#line 71 "file0.s"
+/*0x01bf*/	BYTE $0
+#line 71 "file0.s"
+/*0x01c0*/	BYTE $0
+#line 7 "file2.s"
+/*0x01c1*/	BYTE $0
+#line 747 "file2.s"
+/*0x01c2*/	BYTE $0
+#line 177 "file2.s"
+/*0x01c3*/	MOVQ $0x123456789, AX
+#line 177 "file2.s"
+/*0x01cd*/	MOVQ $0x123456789, AX
+#line 177 "file2.s"
+/*0x01d7*/	MOVL $0x1234567, AX
+#line 177 "file2.s"
+/*0x01dc*/	BYTE $0
+#line 177 "file2.s"
+/*0x01dd*/	BYTE $0
+#line 177 "file2.s"
+/*0x01de*/	BYTE $0
+#line 72 "file2.s"
+/*0x01df*/	BYTE $0
+#line 215 "file2.s"
+/*0x01e0*/	MOVL $0x1234567, AX
+#line 215 "file2.s"
+/*0x01e5*/	BYTE $0
+#line 215 "file2.s"
+/*0x01e6*/	BYTE $0
+#line 215 "file2.s"
+/*0x01e7*/	BYTE $0
+#line 946 "file2.s"
+/*0x01e8*/	BYTE $0
+#line 946 "file2.s"
+/*0x01e9*/	BYTE $0
+#line 946 "file2.s"
+/*0x01ea*/	BYTE $0
+#line 946 "file2.s"
+/*0x01eb*/	BYTE $0
+#line 263 "file2.s"
+/*0x01ec*/	MOVL $0x1234567, AX
+#line 263 "file2.s"
+/*0x01f1*/	BYTE $0
+#line 897 "file2.s"
+/*0x01f2*/	MOVQ $0x123456789, AX
+#line 897 "file2.s"
+/*0x01fc*/	MOVQ $0x123456789, AX
+#line 897 "file2.s"
+/*0x0206*/	BYTE $0
+#line 897 "file2.s"
+/*0x0207*/	BYTE $0
+#line 897 "file2.s"
+/*0x0208*/	BYTE $0
+#line 229 "file2.s"
+/*0x0209*/	BYTE $0
+#line 229 "file2.s"
+/*0x020a*/	BYTE $0
+#line 229 "file2.s"
+/*0x020b*/	BYTE $0
+#line 229 "file2.s"
+/*0x020c*/	BYTE $0
+/*      */	PCDATA $1, $7
+#line 229 "file2.s"
+/*0x020d*/	MOVL $0x1234567, AX
+#line 229 "file2.s"
+/*0x0212*/	BYTE $0
+#line 353 "file2.s"
+/*0x0213*/	BYTE $0
+#line 353 "file2.s"
+/*0x0214*/	BYTE $0
+#line 353 "file2.s"
+/*0x0215*/	BYTE $0
+#line 353 "file2.s"
+/*0x0216*/	BYTE $0
+#line 852 "file2.s"
+/*0x0217*/	BYTE $0
+#line 852 "file2.s"
+/*0x0218*/	BYTE $0
+#line 852 "file2.s"
+/*0x0219*/	BYTE $0
+#line 852 "file2.s"
+/*0x021a*/	BYTE $0
+#line 852 "file2.s"
+/*0x021b*/	PUSHQ AX
+#line 852 "file2.s"
+/*0x021c*/	BYTE $0
+#line 852 "file2.s"
+/*0x021d*/	BYTE $0
+#line 852 "file2.s"
+/*0x021e*/	BYTE $0
+#line 904 "file2.s"
+/*0x021f*/	MOVQ $0x123456789, AX
+#line 904 "file2.s"
+/*0x0229*/	BYTE $0
+#line 904 "file2.s"
+/*0x022a*/	BYTE $0
+#line 882 "file2.s"
+/*0x022b*/	BYTE $0
+#line 905 "file2.s"
+/*0x022c*/	BYTE $0
+#line 410 "file2.s"
+/*0x022d*/	MOVQ $0x123456789, AX
+#line 410 "file2.s"
+/*0x0237*/	BYTE $0
+#line 410 "file2.s"
+/*0x0238*/	BYTE $0
+#line 410 "file2.s"
+/*0x0239*/	POPQ AX
+#line 410 "file2.s"
+/*0x023a*/	BYTE $0
+#line 410 "file2.s"
+/*0x023b*/	BYTE $0
+#line 410 "file2.s"
+/*0x023c*/	BYTE $0
+/*      */	PCDATA $2, $173
+#line 410 "file2.s"
+/*0x023d*/	MOVL $0x1234567, AX
+#line 410 "file2.s"
+/*0x0242*/	BYTE $0
+/*      */	PCDATA $1, $396
+#line 410 "file2.s"
+/*0x0243*/	BYTE $0
+#line 410 "file2.s"
+/*0x0244*/	BYTE $0
+#line 666 "file2.s"
+/*0x0245*/	BYTE $0
+#line 129 "file2.s"
+/*0x0246*/	MOVQ $0x123456789, AX
+#line 129 "file2.s"
+/*0x0250*/	BYTE $0
+#line 391 "file2.s"
+/*0x0251*/	BYTE $0
+#line 696 "file2.s"
+/*0x0252*/	MOVL $0x1234567, AX
+#line 940 "file2.s"
+/*0x0257*/	BYTE $0
+#line 940 "file2.s"
+/*0x0258*/	BYTE $0
+#line 606 "file2.s"
+/*0x0259*/	MOVL $0x1234567, AX
+#line 606 "file2.s"
+/*0x025e*/	BYTE $0
+#line 648 "file2.s"
+/*0x025f*/	MOVQ $0x123456789, AX
+#line 648 "file2.s"
+/*0x0269*/	BYTE $0
+#line 648 "file2.s"
+/*0x026a*/	BYTE $0
+/*      */	PCDATA $2, $84
+#line 648 "file2.s"
+/*0x026b*/	MOVQ $0x123456789, AX
+#line 648 "file2.s"
+/*0x0275*/	MOVQ $0x123456789, AX
+#line 648 "file2.s"
+/*0x027f*/	MOVQ $0x123456789, AX
+#line 648 "file2.s"
+/*0x0289*/	MOVQ $0x123456789, AX
+#line 648 "file2.s"
+/*0x0293*/	MOVQ $0x123456789, AX
+#line 648 "file2.s"
+/*0x029d*/	MOVL $0x1234567, AX
+#line 648 "file2.s"
+/*0x02a2*/	PUSHQ AX
+#line 648 "file2.s"
+/*0x02a3*/	MOVL $0x1234567, AX
+#line 648 "file2.s"
+/*0x02a8*/	BYTE $0
+#line 648 "file2.s"
+/*0x02a9*/	BYTE $0
+#line 648 "file2.s"
+/*0x02aa*/	BYTE $0
+#line 648 "file2.s"
+/*0x02ab*/	BYTE $0
+#line 449 "file2.s"
+/*0x02ac*/	MOVQ $0x123456789, AX
+#line 449 "file2.s"
+/*0x02b6*/	MOVL $0x1234567, AX
+#line 284 "file2.s"
+/*0x02bb*/	BYTE $0
+#line 284 "file2.s"
+/*0x02bc*/	BYTE $0
+#line 284 "file2.s"
+/*0x02bd*/	BYTE $0
+#line 284 "file2.s"
+/*0x02be*/	BYTE $0
+#line 26 "file2.s"
+/*0x02bf*/	MOVQ $0x123456789, AX
+#line 26 "file2.s"
+/*0x02c9*/	MOVL $0x1234567, AX
+#line 26 "file2.s"
+/*0x02ce*/	BYTE $0
+#line 26 "file2.s"
+/*0x02cf*/	BYTE $0
+#line 26 "file2.s"
+/*0x02d0*/	BYTE $0
+#line 605 "file2.s"
+/*0x02d1*/	MOVL $0x1234567, AX
+#line 605 "file2.s"
+/*0x02d6*/	BYTE $0
+#line 605 "file2.s"
+/*0x02d7*/	BYTE $0
+#line 605 "file2.s"
+/*0x02d8*/	BYTE $0
+#line 593 "file2.s"
+/*0x02d9*/	MOVL $0x1234567, AX
+#line 541 "file2.s"
+/*0x02de*/	MOVL $0x1234567, AX
+#line 541 "file2.s"
+/*0x02e3*/	BYTE $0
+#line 541 "file2.s"
+/*0x02e4*/	BYTE $0
+#line 181 "file2.s"
+/*0x02e5*/	MOVQ $0x123456789, AX
+#line 181 "file2.s"
+/*0x02ef*/	BYTE $0
+#line 907 "file2.s"
+/*0x02f0*/	MOVQ $0x123456789, AX
+#line 704 "file2.s"
+/*0x02fa*/	MOVQ $0x123456789, AX
+#line 704 "file2.s"
+/*0x0304*/	MOVQ $0x123456789, AX
+#line 704 "file2.s"
+/*0x030e*/	MOVL $0x1234567, AX
+#line 704 "file2.s"
+/*0x0313*/	BYTE $0
+#line 704 "file2.s"
+/*0x0314*/	BYTE $0
+#line 704 "file2.s"
+/*0x0315*/	BYTE $0
+#line 704 "file2.s"
+/*0x0316*/	BYTE $0
+#line 859 "file2.s"
+/*0x0317*/	MOVL $0x1234567, AX
+#line 407 "file2.s"
+/*0x031c*/	BYTE $0
+#line 407 "file2.s"
+/*0x031d*/	BYTE $0
+/*      */	PCDATA $2, $569
+#line 407 "file2.s"
+/*0x031e*/	MOVL $0x1234567, AX
+#line 407 "file2.s"
+/*0x0323*/	BYTE $0
+#line 407 "file2.s"
+/*0x0324*/	BYTE $0
+#line 407 "file2.s"
+/*0x0325*/	BYTE $0
+/*      */	PCDATA $1, $937
+#line 407 "file2.s"
+/*0x0326*/	MOVL $0x1234567, AX
+#line 407 "file2.s"
+/*0x032b*/	BYTE $0
+#line 774 "file2.s"
+/*0x032c*/	MOVQ $0x123456789, AX
+#line 774 "file2.s"
+/*0x0336*/	BYTE $0
+#line 547 "file2.s"
+/*0x0337*/	BYTE $0
+#line 547 "file2.s"
+/*0x0338*/	BYTE $0
+#line 547 "file2.s"
+/*0x0339*/	BYTE $0
+#line 547 "file2.s"
+/*0x033a*/	PUSHQ AX
+#line 547 "file2.s"
+/*0x033b*/	MOVL $0x1234567, AX
+#line 427 "file2.s"
+/*0x0340*/	MOVL $0x1234567, AX
+/*      */	PCDATA $1, $462
+#line 427 "file2.s"
+/*0x0345*/	MOVQ $0x123456789, AX
+#line 427 "file2.s"
+/*0x034f*/	MOVL $0x1234567, AX
+#line 427 "file2.s"
+/*0x0354*/	BYTE $0
+#line 427 "file2.s"
+/*0x0355*/	BYTE $0
+#line 427 "file2.s"
+/*0x0356*/	BYTE $0
+#line 427 "file2.s"
+/*0x0357*/	BYTE $0
+/*      */	PCDATA $2, $303
+#line 427 "file2.s"
+/*0x0358*/	MOVQ $0x123456789, AX
+#line 427 "file2.s"
+/*0x0362*/	BYTE $0
+#line 427 "file2.s"
+/*0x0363*/	BYTE $0
+#line 708 "file2.s"
+/*0x0364*/	BYTE $0
+#line 708 "file2.s"
+/*0x0365*/	BYTE $0
+#line 708 "file2.s"
+/*0x0366*/	BYTE $0
+#line 708 "file2.s"
+/*0x0367*/	BYTE $0
+#line 218 "file2.s"
+/*0x0368*/	MOVL $0x1234567, AX
+#line 44 "file2.s"
+/*0x036d*/	BYTE $0
+#line 915 "file2.s"
+/*0x036e*/	BYTE $0
+#line 915 "file2.s"
+/*0x036f*/	BYTE $0
+#line 915 "file2.s"
+/*0x0370*/	BYTE $0
+#line 915 "file2.s"
+/*0x0371*/	BYTE $0
+#line 122 "file2.s"
+/*0x0372*/	MOVQ $0x123456789, AX
+#line 122 "file2.s"
+/*0x037c*/	MOVL $0x1234567, AX
+#line 122 "file2.s"
+/*0x0381*/	BYTE $0
+#line 122 "file2.s"
+/*0x0382*/	BYTE $0
+#line 266 "file2.s"
+/*0x0383*/	BYTE $0
+#line 266 "file2.s"
+/*0x0384*/	BYTE $0
+#line 368 "file2.s"
+/*0x0385*/	BYTE $0
+#line 368 "file2.s"
+/*0x0386*/	BYTE $0
+#line 368 "file2.s"
+/*0x0387*/	BYTE $0
+#line 368 "file2.s"
+/*0x0388*/	BYTE $0
+#line 775 "file2.s"
+/*0x0389*/	BYTE $0
+#line 10 "file8.s"
+/*0x038a*/	BYTE $0
+#line 10 "file8.s"
+/*0x038b*/	BYTE $0
+#line 422 "file8.s"
+/*0x038c*/	MOVL $0x1234567, AX
+#line 422 "file8.s"
+/*0x0391*/	BYTE $0
+#line 613 "file8.s"
+/*0x0392*/	BYTE $0
+#line 613 "file8.s"
+/*0x0393*/	BYTE $0
+#line 613 "file8.s"
+/*0x0394*/	BYTE $0
+#line 697 "file8.s"
+/*0x0395*/	MOVQ $0x123456789, AX
+#line 697 "file8.s"
+/*0x039f*/	MOVQ $0x123456789, AX
+#line 697 "file8.s"
+/*0x03a9*/	BYTE $0
+#line 697 "file8.s"
+/*0x03aa*/	BYTE $0
+#line 697 "file8.s"
+/*0x03ab*/	BYTE $0
+	POPQ AX
+	POPQ AX
+	POPQ AX
+	RET
+
+GLOBL funcdata2(SB), $16
+
+TEXT start(SB),7,$0
+	CALL func0(SB)
+	CALL func1(SB)
+	CALL func2(SB)
+	MOVQ $pclntab(SB), AX
+
+	RET
