commit 1c729599996c05e7b743372baeec2b6c70472084
Author: Robert Griesemer <gri@golang.org>
Date:   Tue Dec 15 15:27:16 2009 -0800

                   1) Change default gofmt default settings for
                      parsing and printing to new syntax.
    
                      Use -oldparser to parse the old syntax,
                      use -oldprinter to print the old syntax.
    
                   2) Change default gofmt formatting settings
                      to use tabs for indentation only and to use
                      spaces for alignment. This will make the code
                      alignment insensitive to an editor's tabwidth.
    
                      Use -spaces=false to use tabs for alignment.
    
                   3) Manually changed src/exp/parser/parser_test.go
                      so that it doesn't try to parse the parser's
                      source files using the old syntax (they have
                      new syntax now).
    
                   4) gofmt -w src misc test/bench
    
                   2nd set of files.
    
    R=rsc
    CC=golang-dev
    https://golang.org/cl/179067
---
 src/pkg/debug/dwarf/buf.go               |  108 +-
 src/pkg/debug/dwarf/const.go             |  444 ++++----
 src/pkg/debug/dwarf/entry.go             |  172 +--
 src/pkg/debug/dwarf/open.go              |   40 +-
 src/pkg/debug/dwarf/type.go              |  370 +++----
 src/pkg/debug/dwarf/type_test.go         |   36 +-
 src/pkg/debug/dwarf/unit.go              |   50 +-
 src/pkg/debug/elf/elf.go                 | 1246 ++++++++++-----------
 src/pkg/debug/elf/elf_test.go            |   10 +-
 src/pkg/debug/elf/file.go                |  312 +++---
 src/pkg/debug/elf/file_test.go           |   60 +-
 src/pkg/debug/gosym/pclntab.go           |   42 +-
 src/pkg/debug/gosym/pclntab_test.go      |  110 +-
 src/pkg/debug/gosym/symtab.go            |  334 +++---
 src/pkg/debug/macho/file.go              |  322 +++---
 src/pkg/debug/macho/file_test.go         |   50 +-
 src/pkg/debug/macho/macho.go             |  234 ++--
 src/pkg/debug/proc/proc.go               |   92 +-
 src/pkg/debug/proc/proc_linux.go         |  670 ++++++------
 src/pkg/debug/proc/proc_nacl.go          |    4 +-
 src/pkg/debug/proc/regs_linux_386.go     |   38 +-
 src/pkg/debug/proc/regs_linux_amd64.go   |   36 +-
 src/pkg/debug/proc/regs_linux_arm.go     |   24 +-
 src/pkg/ebnf/ebnf.go                     |  146 +--
 src/pkg/ebnf/ebnf_test.go                |   12 +-
 src/pkg/ebnf/parser.go                   |  128 +--
 src/pkg/encoding/ascii85/ascii85.go      |  190 ++--
 src/pkg/encoding/ascii85/ascii85_test.go |  140 +--
 src/pkg/encoding/base64/base64.go        |  176 +--
 src/pkg/encoding/base64/base64_test.go   |  128 +--
 src/pkg/encoding/binary/binary.go        |  210 ++--
 src/pkg/encoding/binary/binary_test.go   |   70 +-
 src/pkg/encoding/git85/git.go            |  156 +--
 src/pkg/encoding/git85/git_test.go       |  130 +--
 src/pkg/encoding/hex/hex.go              |   42 +-
 src/pkg/encoding/hex/hex_test.go         |   32 +-
 src/pkg/encoding/pem/pem.go              |   74 +-
 src/pkg/encoding/pem/pem_test.go         |   16 +-
 src/pkg/exec/exec.go                     |   62 +-
 src/pkg/exec/exec_test.go                |   18 +-
 src/pkg/exp/4s/4s.go                     |   46 +-
 src/pkg/exp/4s/5s.go                     |    2 +-
 src/pkg/exp/4s/xs.go                     |  566 +++++-----
 src/pkg/exp/datafmt/datafmt.go           |  274 ++---
 src/pkg/exp/datafmt/datafmt_test.go      |  270 ++---
 src/pkg/exp/datafmt/parser.go            |  222 ++--
 src/pkg/exp/draw/arith.go                |   38 +-
 src/pkg/exp/draw/color.go                |   96 +-
 src/pkg/exp/draw/draw.go                 |   96 +-
 src/pkg/exp/draw/event.go                |   18 +-
 src/pkg/exp/draw/x11/auth.go             |   52 +-
 src/pkg/exp/draw/x11/conn.go             |  326 +++---
 src/pkg/exp/eval/abort.go                |   46 +-
 src/pkg/exp/eval/bridge.go               |   74 +-
 src/pkg/exp/eval/compiler.go             |   60 +-
 src/pkg/exp/eval/eval_test.go            |  178 +--
 src/pkg/exp/eval/expr.go                 | 1088 +++++++++---------
 src/pkg/exp/eval/expr1.go                | 1764 +++++++++++++++---------------
 src/pkg/exp/eval/expr_test.go            |    6 +-
 src/pkg/exp/eval/func.go                 |   50 +-
 src/pkg/exp/eval/gen.go                  |  102 +-
 src/pkg/exp/eval/main.go                 |   80 +-
 src/pkg/exp/eval/scope.go                |   98 +-
 src/pkg/exp/eval/stmt.go                 |  618 +++++------
 src/pkg/exp/eval/stmt_test.go            |    2 +-
 src/pkg/exp/eval/type.go                 |  698 ++++++------
 src/pkg/exp/eval/typec.go                |  268 ++---
 src/pkg/exp/eval/util.go                 |   26 +-
 src/pkg/exp/eval/value.go                |  356 +++---
 src/pkg/exp/eval/world.go                |  116 +-
 src/pkg/exp/exception/exception.go       |   22 +-
 src/pkg/exp/exception/exception_test.go  |   18 +-
 src/pkg/exp/iterable/array.go            |   32 +-
 src/pkg/exp/iterable/iterable.go         |  120 +-
 src/pkg/exp/iterable/iterable_test.go    |  302 ++---
 src/pkg/exp/nacl/av/av.go                |  172 +--
 src/pkg/exp/nacl/av/event.go             |  698 ++++++------
 src/pkg/exp/nacl/av/image.go             |   50 +-
 src/pkg/exp/nacl/srpc/client.go          |  172 +--
 src/pkg/exp/nacl/srpc/msg.go             |  412 +++----
 src/pkg/exp/nacl/srpc/server.go          |  118 +-
 src/pkg/exp/ogle/abort.go                |   22 +-
 src/pkg/exp/ogle/arch.go                 |   68 +-
 src/pkg/exp/ogle/cmd.go                  |  210 ++--
 src/pkg/exp/ogle/event.go                |  136 +--
 src/pkg/exp/ogle/frame.go                |  110 +-
 src/pkg/exp/ogle/goroutine.go            |   74 +-
 src/pkg/exp/ogle/main.go                 |    2 +-
 src/pkg/exp/ogle/process.go              |  272 ++---
 src/pkg/exp/ogle/rruntime.go             |  224 ++--
 src/pkg/exp/ogle/rtype.go                |  262 ++---
 src/pkg/exp/ogle/rvalue.go               |  218 ++--
 src/pkg/exp/ogle/vars.go                 |  134 +--
 src/pkg/exp/parser/interface.go          |   82 +-
 src/pkg/exp/parser/parser.go             | 1090 +++++++++---------
 src/pkg/exp/parser/parser_test.go        |   20 +-
 src/pkg/exp/spacewar/pdp1.go             |  236 ++--
 src/pkg/exp/spacewar/spacewar.go         |  128 +--
 src/pkg/expvar/expvar.go                 |  148 +--
 src/pkg/expvar/expvar_test.go            |   38 +-
 src/pkg/flag/flag.go                     |  312 +++---
 src/pkg/flag/flag_test.go                |   64 +-
 src/pkg/fmt/fmt_test.go                  |  132 +--
 src/pkg/fmt/format.go                    |  276 ++---
 src/pkg/fmt/print.go                     |  410 +++----
 105 files changed, 10478 insertions(+), 10476 deletions(-)

diff --git a/src/pkg/debug/dwarf/buf.go b/src/pkg/debug/dwarf/buf.go
index 2ece903a0d..2d29cebdd3 100644
--- a/src/pkg/debug/dwarf/buf.go
+++ b/src/pkg/debug/dwarf/buf.go
@@ -7,20 +7,20 @@
 package dwarf
 
 import (
-	"encoding/binary";
-	"os";
-	"strconv";
+	"encoding/binary"
+	"os"
+	"strconv"
 )
 
 // Data buffer being decoded.
 type buf struct {
-	dwarf		*Data;
-	order		binary.ByteOrder;
-	name		string;
-	off		Offset;
-	data		[]byte;
-	addrsize	int;
-	err		os.Error;
+	dwarf    *Data
+	order    binary.ByteOrder
+	name     string
+	off      Offset
+	data     []byte
+	addrsize int
+	err      os.Error
 }
 
 func makeBuf(d *Data, name string, off Offset, data []byte, addrsize int) buf {
@@ -29,95 +29,95 @@ func makeBuf(d *Data, name string, off Offset, data []byte, addrsize int) buf {
 
 func (b *buf) uint8() uint8 {
 	if len(b.data) < 1 {
-		b.error("underflow");
-		return 0;
+		b.error("underflow")
+		return 0
 	}
-	val := b.data[0];
-	b.data = b.data[1:];
-	b.off++;
-	return val;
+	val := b.data[0]
+	b.data = b.data[1:]
+	b.off++
+	return val
 }
 
 func (b *buf) bytes(n int) []byte {
 	if len(b.data) < n {
-		b.error("underflow");
-		return nil;
+		b.error("underflow")
+		return nil
 	}
-	data := b.data[0:n];
-	b.data = b.data[n:];
-	b.off += Offset(n);
-	return data;
+	data := b.data[0:n]
+	b.data = b.data[n:]
+	b.off += Offset(n)
+	return data
 }
 
-func (b *buf) skip(n int)	{ b.bytes(n) }
+func (b *buf) skip(n int) { b.bytes(n) }
 
 func (b *buf) string() string {
 	for i := 0; i < len(b.data); i++ {
 		if b.data[i] == 0 {
-			s := string(b.data[0:i]);
-			b.data = b.data[i+1:];
-			b.off += Offset(i + 1);
-			return s;
+			s := string(b.data[0:i])
+			b.data = b.data[i+1:]
+			b.off += Offset(i + 1)
+			return s
 		}
 	}
-	b.error("underflow");
-	return "";
+	b.error("underflow")
+	return ""
 }
 
 func (b *buf) uint16() uint16 {
-	a := b.bytes(2);
+	a := b.bytes(2)
 	if a == nil {
 		return 0
 	}
-	return b.order.Uint16(a);
+	return b.order.Uint16(a)
 }
 
 func (b *buf) uint32() uint32 {
-	a := b.bytes(4);
+	a := b.bytes(4)
 	if a == nil {
 		return 0
 	}
-	return b.order.Uint32(a);
+	return b.order.Uint32(a)
 }
 
 func (b *buf) uint64() uint64 {
-	a := b.bytes(8);
+	a := b.bytes(8)
 	if a == nil {
 		return 0
 	}
-	return b.order.Uint64(a);
+	return b.order.Uint64(a)
 }
 
 // Read a varint, which is 7 bits per byte, little endian.
 // the 0x80 bit means read another byte.
 func (b *buf) varint() (c uint64, bits uint) {
 	for i := 0; i < len(b.data); i++ {
-		byte := b.data[i];
-		c |= uint64(byte&0x7F) << bits;
-		bits += 7;
+		byte := b.data[i]
+		c |= uint64(byte&0x7F) << bits
+		bits += 7
 		if byte&0x80 == 0 {
-			b.off += Offset(i + 1);
-			b.data = b.data[i+1:];
-			return c, bits;
+			b.off += Offset(i + 1)
+			b.data = b.data[i+1:]
+			return c, bits
 		}
 	}
-	return 0, 0;
+	return 0, 0
 }
 
 // Unsigned int is just a varint.
 func (b *buf) uint() uint64 {
-	x, _ := b.varint();
-	return x;
+	x, _ := b.varint()
+	return x
 }
 
 // Signed int is a sign-extended varint.
 func (b *buf) int() int64 {
-	ux, bits := b.varint();
-	x := int64(ux);
+	ux, bits := b.varint()
+	x := int64(ux)
 	if x&(1<<(bits-1)) != 0 {
 		x |= -1 << bits
 	}
-	return x;
+	return x
 }
 
 // Address-sized uint.
@@ -132,21 +132,21 @@ func (b *buf) addr() uint64 {
 	case 8:
 		return uint64(b.uint64())
 	}
-	b.error("unknown address size");
-	return 0;
+	b.error("unknown address size")
+	return 0
 }
 
 func (b *buf) error(s string) {
 	if b.err == nil {
-		b.data = nil;
-		b.err = DecodeError{b.name, b.off, s};
+		b.data = nil
+		b.err = DecodeError{b.name, b.off, s}
 	}
 }
 
 type DecodeError struct {
-	Name	string;
-	Offset	Offset;
-	Error	string;
+	Name   string
+	Offset Offset
+	Error  string
 }
 
 func (e DecodeError) String() string {
diff --git a/src/pkg/debug/dwarf/const.go b/src/pkg/debug/dwarf/const.go
index 808a80c8a4..d73480cb20 100644
--- a/src/pkg/debug/dwarf/const.go
+++ b/src/pkg/debug/dwarf/const.go
@@ -12,78 +12,78 @@ import "strconv"
 type Attr uint32
 
 const (
-	AttrSibling		Attr	= 0x01;
-	AttrLocation		Attr	= 0x02;
-	AttrName		Attr	= 0x03;
-	AttrOrdering		Attr	= 0x09;
-	AttrByteSize		Attr	= 0x0B;
-	AttrBitOffset		Attr	= 0x0C;
-	AttrBitSize		Attr	= 0x0D;
-	AttrStmtList		Attr	= 0x10;
-	AttrLowpc		Attr	= 0x11;
-	AttrHighpc		Attr	= 0x12;
-	AttrLanguage		Attr	= 0x13;
-	AttrDiscr		Attr	= 0x15;
-	AttrDiscrValue		Attr	= 0x16;
-	AttrVisibility		Attr	= 0x17;
-	AttrImport		Attr	= 0x18;
-	AttrStringLength	Attr	= 0x19;
-	AttrCommonRef		Attr	= 0x1A;
-	AttrCompDir		Attr	= 0x1B;
-	AttrConstValue		Attr	= 0x1C;
-	AttrContainingType	Attr	= 0x1D;
-	AttrDefaultValue	Attr	= 0x1E;
-	AttrInline		Attr	= 0x20;
-	AttrIsOptional		Attr	= 0x21;
-	AttrLowerBound		Attr	= 0x22;
-	AttrProducer		Attr	= 0x25;
-	AttrPrototyped		Attr	= 0x27;
-	AttrReturnAddr		Attr	= 0x2A;
-	AttrStartScope		Attr	= 0x2C;
-	AttrStrideSize		Attr	= 0x2E;
-	AttrUpperBound		Attr	= 0x2F;
-	AttrAbstractOrigin	Attr	= 0x31;
-	AttrAccessibility	Attr	= 0x32;
-	AttrAddrClass		Attr	= 0x33;
-	AttrArtificial		Attr	= 0x34;
-	AttrBaseTypes		Attr	= 0x35;
-	AttrCalling		Attr	= 0x36;
-	AttrCount		Attr	= 0x37;
-	AttrDataMemberLoc	Attr	= 0x38;
-	AttrDeclColumn		Attr	= 0x39;
-	AttrDeclFile		Attr	= 0x3A;
-	AttrDeclLine		Attr	= 0x3B;
-	AttrDeclaration		Attr	= 0x3C;
-	AttrDiscrList		Attr	= 0x3D;
-	AttrEncoding		Attr	= 0x3E;
-	AttrExternal		Attr	= 0x3F;
-	AttrFrameBase		Attr	= 0x40;
-	AttrFriend		Attr	= 0x41;
-	AttrIdentifierCase	Attr	= 0x42;
-	AttrMacroInfo		Attr	= 0x43;
-	AttrNamelistItem	Attr	= 0x44;
-	AttrPriority		Attr	= 0x45;
-	AttrSegment		Attr	= 0x46;
-	AttrSpecification	Attr	= 0x47;
-	AttrStaticLink		Attr	= 0x48;
-	AttrType		Attr	= 0x49;
-	AttrUseLocation		Attr	= 0x4A;
-	AttrVarParam		Attr	= 0x4B;
-	AttrVirtuality		Attr	= 0x4C;
-	AttrVtableElemLoc	Attr	= 0x4D;
-	AttrAllocated		Attr	= 0x4E;
-	AttrAssociated		Attr	= 0x4F;
-	AttrDataLocation	Attr	= 0x50;
-	AttrStride		Attr	= 0x51;
-	AttrEntrypc		Attr	= 0x52;
-	AttrUseUTF8		Attr	= 0x53;
-	AttrExtension		Attr	= 0x54;
-	AttrRanges		Attr	= 0x55;
-	AttrTrampoline		Attr	= 0x56;
-	AttrCallColumn		Attr	= 0x57;
-	AttrCallFile		Attr	= 0x58;
-	AttrCallLine		Attr	= 0x59;
-	AttrDescription		Attr	= 0x5A;
+	AttrSibling        Attr = 0x01
+	AttrLocation       Attr = 0x02
+	AttrName           Attr = 0x03
+	AttrOrdering       Attr = 0x09
+	AttrByteSize       Attr = 0x0B
+	AttrBitOffset      Attr = 0x0C
+	AttrBitSize        Attr = 0x0D
+	AttrStmtList       Attr = 0x10
+	AttrLowpc          Attr = 0x11
+	AttrHighpc         Attr = 0x12
+	AttrLanguage       Attr = 0x13
+	AttrDiscr          Attr = 0x15
+	AttrDiscrValue     Attr = 0x16
+	AttrVisibility     Attr = 0x17
+	AttrImport         Attr = 0x18
+	AttrStringLength   Attr = 0x19
+	AttrCommonRef      Attr = 0x1A
+	AttrCompDir        Attr = 0x1B
+	AttrConstValue     Attr = 0x1C
+	AttrContainingType Attr = 0x1D
+	AttrDefaultValue   Attr = 0x1E
+	AttrInline         Attr = 0x20
+	AttrIsOptional     Attr = 0x21
+	AttrLowerBound     Attr = 0x22
+	AttrProducer       Attr = 0x25
+	AttrPrototyped     Attr = 0x27
+	AttrReturnAddr     Attr = 0x2A
+	AttrStartScope     Attr = 0x2C
+	AttrStrideSize     Attr = 0x2E
+	AttrUpperBound     Attr = 0x2F
+	AttrAbstractOrigin Attr = 0x31
+	AttrAccessibility  Attr = 0x32
+	AttrAddrClass      Attr = 0x33
+	AttrArtificial     Attr = 0x34
+	AttrBaseTypes      Attr = 0x35
+	AttrCalling        Attr = 0x36
+	AttrCount          Attr = 0x37
+	AttrDataMemberLoc  Attr = 0x38
+	AttrDeclColumn     Attr = 0x39
+	AttrDeclFile       Attr = 0x3A
+	AttrDeclLine       Attr = 0x3B
+	AttrDeclaration    Attr = 0x3C
+	AttrDiscrList      Attr = 0x3D
+	AttrEncoding       Attr = 0x3E
+	AttrExternal       Attr = 0x3F
+	AttrFrameBase      Attr = 0x40
+	AttrFriend         Attr = 0x41
+	AttrIdentifierCase Attr = 0x42
+	AttrMacroInfo      Attr = 0x43
+	AttrNamelistItem   Attr = 0x44
+	AttrPriority       Attr = 0x45
+	AttrSegment        Attr = 0x46
+	AttrSpecification  Attr = 0x47
+	AttrStaticLink     Attr = 0x48
+	AttrType           Attr = 0x49
+	AttrUseLocation    Attr = 0x4A
+	AttrVarParam       Attr = 0x4B
+	AttrVirtuality     Attr = 0x4C
+	AttrVtableElemLoc  Attr = 0x4D
+	AttrAllocated      Attr = 0x4E
+	AttrAssociated     Attr = 0x4F
+	AttrDataLocation   Attr = 0x50
+	AttrStride         Attr = 0x51
+	AttrEntrypc        Attr = 0x52
+	AttrUseUTF8        Attr = 0x53
+	AttrExtension      Attr = 0x54
+	AttrRanges         Attr = 0x55
+	AttrTrampoline     Attr = 0x56
+	AttrCallColumn     Attr = 0x57
+	AttrCallFile       Attr = 0x58
+	AttrCallLine       Attr = 0x59
+	AttrDescription    Attr = 0x5A
 )
 
 var attrNames = [...]string{
@@ -163,22 +163,22 @@ var attrNames = [...]string{
 
 func (a Attr) String() string {
 	if int(a) < len(attrNames) {
-		s := attrNames[a];
+		s := attrNames[a]
 		if s != "" {
 			return s
 		}
 	}
-	return strconv.Itoa(int(a));
+	return strconv.Itoa(int(a))
 }
 
 func (a Attr) GoString() string {
 	if int(a) < len(attrNames) {
-		s := attrNames[a];
+		s := attrNames[a]
 		if s != "" {
 			return "dwarf.Attr" + s
 		}
 	}
-	return "dwarf.Attr(" + strconv.Itoa64(int64(a)) + ")";
+	return "dwarf.Attr(" + strconv.Itoa64(int64(a)) + ")"
 }
 
 // A format is a DWARF data encoding format.
@@ -186,89 +186,89 @@ type format uint32
 
 const (
 	// value formats
-	formAddr	format	= 0x01;
-	formDwarfBlock2	format	= 0x03;
-	formDwarfBlock4	format	= 0x04;
-	formData2	format	= 0x05;
-	formData4	format	= 0x06;
-	formData8	format	= 0x07;
-	formString	format	= 0x08;
-	formDwarfBlock	format	= 0x09;
-	formDwarfBlock1	format	= 0x0A;
-	formData1	format	= 0x0B;
-	formFlag	format	= 0x0C;
-	formSdata	format	= 0x0D;
-	formStrp	format	= 0x0E;
-	formUdata	format	= 0x0F;
-	formRefAddr	format	= 0x10;
-	formRef1	format	= 0x11;
-	formRef2	format	= 0x12;
-	formRef4	format	= 0x13;
-	formRef8	format	= 0x14;
-	formRefUdata	format	= 0x15;
-	formIndirect	format	= 0x16;
+	formAddr        format = 0x01
+	formDwarfBlock2 format = 0x03
+	formDwarfBlock4 format = 0x04
+	formData2       format = 0x05
+	formData4       format = 0x06
+	formData8       format = 0x07
+	formString      format = 0x08
+	formDwarfBlock  format = 0x09
+	formDwarfBlock1 format = 0x0A
+	formData1       format = 0x0B
+	formFlag        format = 0x0C
+	formSdata       format = 0x0D
+	formStrp        format = 0x0E
+	formUdata       format = 0x0F
+	formRefAddr     format = 0x10
+	formRef1        format = 0x11
+	formRef2        format = 0x12
+	formRef4        format = 0x13
+	formRef8        format = 0x14
+	formRefUdata    format = 0x15
+	formIndirect    format = 0x16
 )
 
 // A Tag is the classification (the type) of an Entry.
 type Tag uint32
 
 const (
-	TagArrayType			Tag	= 0x01;
-	TagClassType			Tag	= 0x02;
-	TagEntryPoint			Tag	= 0x03;
-	TagEnumerationType		Tag	= 0x04;
-	TagFormalParameter		Tag	= 0x05;
-	TagImportedDeclaration		Tag	= 0x08;
-	TagLabel			Tag	= 0x0A;
-	TagLexDwarfBlock		Tag	= 0x0B;
-	TagMember			Tag	= 0x0D;
-	TagPointerType			Tag	= 0x0F;
-	TagReferenceType		Tag	= 0x10;
-	TagCompileUnit			Tag	= 0x11;
-	TagStringType			Tag	= 0x12;
-	TagStructType			Tag	= 0x13;
-	TagSubroutineType		Tag	= 0x15;
-	TagTypedef			Tag	= 0x16;
-	TagUnionType			Tag	= 0x17;
-	TagUnspecifiedParameters	Tag	= 0x18;
-	TagVariant			Tag	= 0x19;
-	TagCommonDwarfBlock		Tag	= 0x1A;
-	TagCommonInclusion		Tag	= 0x1B;
-	TagInheritance			Tag	= 0x1C;
-	TagInlinedSubroutine		Tag	= 0x1D;
-	TagModule			Tag	= 0x1E;
-	TagPtrToMemberType		Tag	= 0x1F;
-	TagSetType			Tag	= 0x20;
-	TagSubrangeType			Tag	= 0x21;
-	TagWithStmt			Tag	= 0x22;
-	TagAccessDeclaration		Tag	= 0x23;
-	TagBaseType			Tag	= 0x24;
-	TagCatchDwarfBlock		Tag	= 0x25;
-	TagConstType			Tag	= 0x26;
-	TagConstant			Tag	= 0x27;
-	TagEnumerator			Tag	= 0x28;
-	TagFileType			Tag	= 0x29;
-	TagFriend			Tag	= 0x2A;
-	TagNamelist			Tag	= 0x2B;
-	TagNamelistItem			Tag	= 0x2C;
-	TagPackedType			Tag	= 0x2D;
-	TagSubprogram			Tag	= 0x2E;
-	TagTemplateTypeParameter	Tag	= 0x2F;
-	TagTemplateValueParameter	Tag	= 0x30;
-	TagThrownType			Tag	= 0x31;
-	TagTryDwarfBlock		Tag	= 0x32;
-	TagVariantPart			Tag	= 0x33;
-	TagVariable			Tag	= 0x34;
-	TagVolatileType			Tag	= 0x35;
-	TagDwarfProcedure		Tag	= 0x36;
-	TagRestrictType			Tag	= 0x37;
-	TagInterfaceType		Tag	= 0x38;
-	TagNamespace			Tag	= 0x39;
-	TagImportedModule		Tag	= 0x3A;
-	TagUnspecifiedType		Tag	= 0x3B;
-	TagPartialUnit			Tag	= 0x3C;
-	TagImportedUnit			Tag	= 0x3D;
-	TagMutableType			Tag	= 0x3E;
+	TagArrayType              Tag = 0x01
+	TagClassType              Tag = 0x02
+	TagEntryPoint             Tag = 0x03
+	TagEnumerationType        Tag = 0x04
+	TagFormalParameter        Tag = 0x05
+	TagImportedDeclaration    Tag = 0x08
+	TagLabel                  Tag = 0x0A
+	TagLexDwarfBlock          Tag = 0x0B
+	TagMember                 Tag = 0x0D
+	TagPointerType            Tag = 0x0F
+	TagReferenceType          Tag = 0x10
+	TagCompileUnit            Tag = 0x11
+	TagStringType             Tag = 0x12
+	TagStructType             Tag = 0x13
+	TagSubroutineType         Tag = 0x15
+	TagTypedef                Tag = 0x16
+	TagUnionType              Tag = 0x17
+	TagUnspecifiedParameters  Tag = 0x18
+	TagVariant                Tag = 0x19
+	TagCommonDwarfBlock       Tag = 0x1A
+	TagCommonInclusion        Tag = 0x1B
+	TagInheritance            Tag = 0x1C
+	TagInlinedSubroutine      Tag = 0x1D
+	TagModule                 Tag = 0x1E
+	TagPtrToMemberType        Tag = 0x1F
+	TagSetType                Tag = 0x20
+	TagSubrangeType           Tag = 0x21
+	TagWithStmt               Tag = 0x22
+	TagAccessDeclaration      Tag = 0x23
+	TagBaseType               Tag = 0x24
+	TagCatchDwarfBlock        Tag = 0x25
+	TagConstType              Tag = 0x26
+	TagConstant               Tag = 0x27
+	TagEnumerator             Tag = 0x28
+	TagFileType               Tag = 0x29
+	TagFriend                 Tag = 0x2A
+	TagNamelist               Tag = 0x2B
+	TagNamelistItem           Tag = 0x2C
+	TagPackedType             Tag = 0x2D
+	TagSubprogram             Tag = 0x2E
+	TagTemplateTypeParameter  Tag = 0x2F
+	TagTemplateValueParameter Tag = 0x30
+	TagThrownType             Tag = 0x31
+	TagTryDwarfBlock          Tag = 0x32
+	TagVariantPart            Tag = 0x33
+	TagVariable               Tag = 0x34
+	TagVolatileType           Tag = 0x35
+	TagDwarfProcedure         Tag = 0x36
+	TagRestrictType           Tag = 0x37
+	TagInterfaceType          Tag = 0x38
+	TagNamespace              Tag = 0x39
+	TagImportedModule         Tag = 0x3A
+	TagUnspecifiedType        Tag = 0x3B
+	TagPartialUnit            Tag = 0x3C
+	TagImportedUnit           Tag = 0x3D
+	TagMutableType            Tag = 0x3E
 )
 
 var tagNames = [...]string{
@@ -332,22 +332,22 @@ var tagNames = [...]string{
 
 func (t Tag) String() string {
 	if int(t) < len(tagNames) {
-		s := tagNames[t];
+		s := tagNames[t]
 		if s != "" {
 			return s
 		}
 	}
-	return strconv.Itoa(int(t));
+	return strconv.Itoa(int(t))
 }
 
 func (t Tag) GoString() string {
 	if int(t) < len(tagNames) {
-		s := tagNames[t];
+		s := tagNames[t]
 		if s != "" {
 			return "dwarf.Tag" + s
 		}
 	}
-	return "dwarf.Tag(" + strconv.Itoa64(int64(t)) + ")";
+	return "dwarf.Tag(" + strconv.Itoa64(int64(t)) + ")"
 }
 
 // Location expression operators.
@@ -356,78 +356,78 @@ func (t Tag) GoString() string {
 // This package does not implement full expressions;
 // the opPlusUconst operator is expected by the type parser.
 const (
-	opAddr		= 0x03;	/* 1 op, const addr */
-	opDeref		= 0x06;
-	opConst1u	= 0x08;	/* 1 op, 1 byte const */
-	opConst1s	= 0x09;	/*	" signed */
-	opConst2u	= 0x0A;	/* 1 op, 2 byte const  */
-	opConst2s	= 0x0B;	/*	" signed */
-	opConst4u	= 0x0C;	/* 1 op, 4 byte const */
-	opConst4s	= 0x0D;	/*	" signed */
-	opConst8u	= 0x0E;	/* 1 op, 8 byte const */
-	opConst8s	= 0x0F;	/*	" signed */
-	opConstu	= 0x10;	/* 1 op, LEB128 const */
-	opConsts	= 0x11;	/*	" signed */
-	opDup		= 0x12;
-	opDrop		= 0x13;
-	opOver		= 0x14;
-	opPick		= 0x15;	/* 1 op, 1 byte stack index */
-	opSwap		= 0x16;
-	opRot		= 0x17;
-	opXderef	= 0x18;
-	opAbs		= 0x19;
-	opAnd		= 0x1A;
-	opDiv		= 0x1B;
-	opMinus		= 0x1C;
-	opMod		= 0x1D;
-	opMul		= 0x1E;
-	opNeg		= 0x1F;
-	opNot		= 0x20;
-	opOr		= 0x21;
-	opPlus		= 0x22;
-	opPlusUconst	= 0x23;	/* 1 op, ULEB128 addend */
-	opShl		= 0x24;
-	opShr		= 0x25;
-	opShra		= 0x26;
-	opXor		= 0x27;
-	opSkip		= 0x2F;	/* 1 op, signed 2-byte constant */
-	opBra		= 0x28;	/* 1 op, signed 2-byte constant */
-	opEq		= 0x29;
-	opGe		= 0x2A;
-	opGt		= 0x2B;
-	opLe		= 0x2C;
-	opLt		= 0x2D;
-	opNe		= 0x2E;
-	opLit0		= 0x30;
+	opAddr       = 0x03 /* 1 op, const addr */
+	opDeref      = 0x06
+	opConst1u    = 0x08 /* 1 op, 1 byte const */
+	opConst1s    = 0x09 /*	" signed */
+	opConst2u    = 0x0A /* 1 op, 2 byte const  */
+	opConst2s    = 0x0B /*	" signed */
+	opConst4u    = 0x0C /* 1 op, 4 byte const */
+	opConst4s    = 0x0D /*	" signed */
+	opConst8u    = 0x0E /* 1 op, 8 byte const */
+	opConst8s    = 0x0F /*	" signed */
+	opConstu     = 0x10 /* 1 op, LEB128 const */
+	opConsts     = 0x11 /*	" signed */
+	opDup        = 0x12
+	opDrop       = 0x13
+	opOver       = 0x14
+	opPick       = 0x15 /* 1 op, 1 byte stack index */
+	opSwap       = 0x16
+	opRot        = 0x17
+	opXderef     = 0x18
+	opAbs        = 0x19
+	opAnd        = 0x1A
+	opDiv        = 0x1B
+	opMinus      = 0x1C
+	opMod        = 0x1D
+	opMul        = 0x1E
+	opNeg        = 0x1F
+	opNot        = 0x20
+	opOr         = 0x21
+	opPlus       = 0x22
+	opPlusUconst = 0x23 /* 1 op, ULEB128 addend */
+	opShl        = 0x24
+	opShr        = 0x25
+	opShra       = 0x26
+	opXor        = 0x27
+	opSkip       = 0x2F /* 1 op, signed 2-byte constant */
+	opBra        = 0x28 /* 1 op, signed 2-byte constant */
+	opEq         = 0x29
+	opGe         = 0x2A
+	opGt         = 0x2B
+	opLe         = 0x2C
+	opLt         = 0x2D
+	opNe         = 0x2E
+	opLit0       = 0x30
 	/* OpLitN = OpLit0 + N for N = 0..31 */
-	opReg0	= 0x50;
+	opReg0 = 0x50
 	/* OpRegN = OpReg0 + N for N = 0..31 */
-	opBreg0	= 0x70;	/* 1 op, signed LEB128 constant */
+	opBreg0 = 0x70 /* 1 op, signed LEB128 constant */
 	/* OpBregN = OpBreg0 + N for N = 0..31 */
-	opRegx		= 0x90;	/* 1 op, ULEB128 register */
-	opFbreg		= 0x91;	/* 1 op, SLEB128 offset */
-	opBregx		= 0x92;	/* 2 op, ULEB128 reg; SLEB128 off */
-	opPiece		= 0x93;	/* 1 op, ULEB128 size of piece */
-	opDerefSize	= 0x94;	/* 1-byte size of data retrieved */
-	opXderefSize	= 0x95;	/* 1-byte size of data retrieved */
-	opNop		= 0x96;
+	opRegx       = 0x90 /* 1 op, ULEB128 register */
+	opFbreg      = 0x91 /* 1 op, SLEB128 offset */
+	opBregx      = 0x92 /* 2 op, ULEB128 reg; SLEB128 off */
+	opPiece      = 0x93 /* 1 op, ULEB128 size of piece */
+	opDerefSize  = 0x94 /* 1-byte size of data retrieved */
+	opXderefSize = 0x95 /* 1-byte size of data retrieved */
+	opNop        = 0x96
 	/* next four new in Dwarf v3 */
-	opPushObjAddr	= 0x97;
-	opCall2		= 0x98;	/* 2-byte offset of DIE */
-	opCall4		= 0x99;	/* 4-byte offset of DIE */
-	opCallRef	= 0x9A;	/* 4- or 8- byte offset of DIE */
+	opPushObjAddr = 0x97
+	opCall2       = 0x98 /* 2-byte offset of DIE */
+	opCall4       = 0x99 /* 4-byte offset of DIE */
+	opCallRef     = 0x9A /* 4- or 8- byte offset of DIE */
 	/* 0xE0-0xFF reserved for user-specific */
 )
 
 // Basic type encodings -- the value for AttrEncoding in a TagBaseType Entry.
 const (
-	encAddress		= 0x01;
-	encBoolean		= 0x02;
-	encComplexFloat		= 0x03;
-	encFloat		= 0x04;
-	encSigned		= 0x05;
-	encSignedChar		= 0x06;
-	encUnsigned		= 0x07;
-	encUnsignedChar		= 0x08;
-	encImaginaryFloat	= 0x09;
+	encAddress        = 0x01
+	encBoolean        = 0x02
+	encComplexFloat   = 0x03
+	encFloat          = 0x04
+	encSigned         = 0x05
+	encSignedChar     = 0x06
+	encUnsigned       = 0x07
+	encUnsignedChar   = 0x08
+	encImaginaryFloat = 0x09
 )
diff --git a/src/pkg/debug/dwarf/entry.go b/src/pkg/debug/dwarf/entry.go
index a4f013c393..5f739c426b 100644
--- a/src/pkg/debug/dwarf/entry.go
+++ b/src/pkg/debug/dwarf/entry.go
@@ -14,14 +14,14 @@ import "os"
 
 // a single entry's description: a sequence of attributes
 type abbrev struct {
-	tag		Tag;
-	children	bool;
-	field		[]afield;
+	tag      Tag
+	children bool
+	field    []afield
 }
 
 type afield struct {
-	attr	Attr;
-	fmt	format;
+	attr Attr
+	fmt  format
 }
 
 // a map from entry format ids to their descriptions
@@ -34,74 +34,74 @@ func (d *Data) parseAbbrev(off uint32) (abbrevTable, os.Error) {
 		return m, nil
 	}
 
-	data := d.abbrev;
+	data := d.abbrev
 	if off > uint32(len(data)) {
 		data = nil
 	} else {
 		data = data[off:]
 	}
-	b := makeBuf(d, "abbrev", 0, data, 0);
+	b := makeBuf(d, "abbrev", 0, data, 0)
 
 	// Error handling is simplified by the buf getters
 	// returning an endless stream of 0s after an error.
-	m := make(abbrevTable);
+	m := make(abbrevTable)
 	for {
 		// Table ends with id == 0.
-		id := uint32(b.uint());
+		id := uint32(b.uint())
 		if id == 0 {
 			break
 		}
 
 		// Walk over attributes, counting.
-		n := 0;
-		b1 := b;	// Read from copy of b.
-		b1.uint();
-		b1.uint8();
+		n := 0
+		b1 := b // Read from copy of b.
+		b1.uint()
+		b1.uint8()
 		for {
-			tag := b1.uint();
-			fmt := b1.uint();
+			tag := b1.uint()
+			fmt := b1.uint()
 			if tag == 0 && fmt == 0 {
 				break
 			}
-			n++;
+			n++
 		}
 		if b1.err != nil {
 			return nil, b1.err
 		}
 
 		// Walk over attributes again, this time writing them down.
-		var a abbrev;
-		a.tag = Tag(b.uint());
-		a.children = b.uint8() != 0;
-		a.field = make([]afield, n);
+		var a abbrev
+		a.tag = Tag(b.uint())
+		a.children = b.uint8() != 0
+		a.field = make([]afield, n)
 		for i := range a.field {
-			a.field[i].attr = Attr(b.uint());
-			a.field[i].fmt = format(b.uint());
+			a.field[i].attr = Attr(b.uint())
+			a.field[i].fmt = format(b.uint())
 		}
-		b.uint();
-		b.uint();
+		b.uint()
+		b.uint()
 
-		m[id] = a;
+		m[id] = a
 	}
 	if b.err != nil {
 		return nil, b.err
 	}
-	d.abbrevCache[off] = m;
-	return m, nil;
+	d.abbrevCache[off] = m
+	return m, nil
 }
 
 // An entry is a sequence of attribute/value pairs.
 type Entry struct {
-	Offset		Offset;	// offset of Entry in DWARF info
-	Tag		Tag;	// tag (kind of Entry)
-	Children	bool;	// whether Entry is followed by children
-	Field		[]Field;
+	Offset   Offset // offset of Entry in DWARF info
+	Tag      Tag    // tag (kind of Entry)
+	Children bool   // whether Entry is followed by children
+	Field    []Field
 }
 
 // A Field is a single attribute/value pair in an Entry.
 type Field struct {
-	Attr	Attr;
-	Val	interface{};
+	Attr Attr
+	Val  interface{}
 }
 
 // Val returns the value associated with attribute Attr in Entry,
@@ -117,7 +117,7 @@ func (e *Entry) Val(a Attr) interface{} {
 			return f.Val
 		}
 	}
-	return nil;
+	return nil
 }
 
 // An Offset represents the location of an Entry within the DWARF info.
@@ -127,25 +127,25 @@ type Offset uint32
 // Entry reads a single entry from buf, decoding
 // according to the given abbreviation table.
 func (b *buf) entry(atab abbrevTable, ubase Offset) *Entry {
-	off := b.off;
-	id := uint32(b.uint());
+	off := b.off
+	id := uint32(b.uint())
 	if id == 0 {
 		return &Entry{}
 	}
-	a, ok := atab[id];
+	a, ok := atab[id]
 	if !ok {
-		b.error("unknown abbreviation table index");
-		return nil;
+		b.error("unknown abbreviation table index")
+		return nil
 	}
 	e := &Entry{
 		Offset: off,
 		Tag: a.tag,
 		Children: a.children,
 		Field: make([]Field, len(a.field)),
-	};
+	}
 	for i := range e.Field {
-		e.Field[i].Attr = a.field[i].attr;
-		fmt := a.field[i].fmt;
+		e.Field[i].Attr = a.field[i].attr
+		fmt := a.field[i].fmt
 		if fmt == formIndirect {
 			fmt = format(b.uint())
 		}
@@ -204,24 +204,24 @@ func (b *buf) entry(atab abbrevTable, ubase Offset) *Entry {
 		case formString:
 			val = b.string()
 		case formStrp:
-			off := b.uint32();	// offset into .debug_str
+			off := b.uint32() // offset into .debug_str
 			if b.err != nil {
 				return nil
 			}
-			b1 := makeBuf(b.dwarf, "str", 0, b.dwarf.str, 0);
-			b1.skip(int(off));
-			val = b1.string();
+			b1 := makeBuf(b.dwarf, "str", 0, b.dwarf.str, 0)
+			b1.skip(int(off))
+			val = b1.string()
 			if b1.err != nil {
-				b.err = b1.err;
-				return nil;
+				b.err = b1.err
+				return nil
 			}
 		}
-		e.Field[i].Val = val;
+		e.Field[i].Val = val
 	}
 	if b.err != nil {
 		return nil
 	}
-	return e;
+	return e
 }
 
 // A Reader allows reading Entry structures from a DWARF ``info'' section.
@@ -230,58 +230,58 @@ func (b *buf) entry(atab abbrevTable, ubase Offset) *Entry {
 // If an entry has children, its Children field will be true, and the children
 // follow, terminated by an Entry with Tag 0.
 type Reader struct {
-	b		buf;
-	d		*Data;
-	err		os.Error;
-	unit		int;
-	lastChildren	bool;	// .Children of last entry returned by Next
-	lastSibling	Offset;	// .Val(AttrSibling) of last entry returned by Next
+	b            buf
+	d            *Data
+	err          os.Error
+	unit         int
+	lastChildren bool   // .Children of last entry returned by Next
+	lastSibling  Offset // .Val(AttrSibling) of last entry returned by Next
 }
 
 // Reader returns a new Reader for Data.
 // The reader is positioned at byte offset 0 in the DWARF ``info'' section.
 func (d *Data) Reader() *Reader {
-	r := &Reader{d: d};
-	r.Seek(0);
-	return r;
+	r := &Reader{d: d}
+	r.Seek(0)
+	return r
 }
 
 // Seek positions the Reader at offset off in the encoded entry stream.
 // Offset 0 can be used to denote the first entry.
 func (r *Reader) Seek(off Offset) {
-	d := r.d;
-	r.err = nil;
-	r.lastChildren = false;
+	d := r.d
+	r.err = nil
+	r.lastChildren = false
 	if off == 0 {
 		if len(d.unit) == 0 {
 			return
 		}
-		u := &d.unit[0];
-		r.unit = 0;
-		r.b = makeBuf(r.d, "info", u.off, u.data, u.addrsize);
-		return;
+		u := &d.unit[0]
+		r.unit = 0
+		r.b = makeBuf(r.d, "info", u.off, u.data, u.addrsize)
+		return
 	}
 
 	// TODO(rsc): binary search (maybe a new package)
-	var i int;
-	var u *unit;
+	var i int
+	var u *unit
 	for i = range d.unit {
-		u = &d.unit[i];
+		u = &d.unit[i]
 		if u.off <= off && off < u.off+Offset(len(u.data)) {
-			r.unit = i;
-			r.b = makeBuf(r.d, "info", off, u.data[off-u.off:], u.addrsize);
-			return;
+			r.unit = i
+			r.b = makeBuf(r.d, "info", off, u.data[off-u.off:], u.addrsize)
+			return
 		}
 	}
-	r.err = os.NewError("offset out of range");
+	r.err = os.NewError("offset out of range")
 }
 
 // maybeNextUnit advances to the next unit if this one is finished.
 func (r *Reader) maybeNextUnit() {
 	for len(r.b.data) == 0 && r.unit+1 < len(r.d.unit) {
-		r.unit++;
-		u := &r.d.unit[r.unit];
-		r.b = makeBuf(r.d, "info", u.off, u.data, u.addrsize);
+		r.unit++
+		u := &r.d.unit[r.unit]
+		r.b = makeBuf(r.d, "info", u.off, u.data, u.addrsize)
 	}
 }
 
@@ -293,25 +293,25 @@ func (r *Reader) Next() (*Entry, os.Error) {
 	if r.err != nil {
 		return nil, r.err
 	}
-	r.maybeNextUnit();
+	r.maybeNextUnit()
 	if len(r.b.data) == 0 {
 		return nil, nil
 	}
-	u := &r.d.unit[r.unit];
-	e := r.b.entry(u.atable, u.base);
+	u := &r.d.unit[r.unit]
+	e := r.b.entry(u.atable, u.base)
 	if r.b.err != nil {
-		r.err = r.b.err;
-		return nil, r.err;
+		r.err = r.b.err
+		return nil, r.err
 	}
 	if e != nil {
-		r.lastChildren = e.Children;
+		r.lastChildren = e.Children
 		if r.lastChildren {
 			r.lastSibling, _ = e.Val(AttrSibling).(Offset)
 		}
 	} else {
 		r.lastChildren = false
 	}
-	return e, nil;
+	return e, nil
 }
 
 // SkipChildren skips over the child entries associated with
@@ -327,12 +327,12 @@ func (r *Reader) SkipChildren() {
 	// sibling, so we can avoid decoding the
 	// child subtrees.
 	if r.lastSibling >= r.b.off {
-		r.Seek(r.lastSibling);
-		return;
+		r.Seek(r.lastSibling)
+		return
 	}
 
 	for {
-		e, err := r.Next();
+		e, err := r.Next()
 		if err != nil || e == nil || e.Tag == 0 {
 			break
 		}
diff --git a/src/pkg/debug/dwarf/open.go b/src/pkg/debug/dwarf/open.go
index a5cb1a1034..3a1b00311c 100644
--- a/src/pkg/debug/dwarf/open.go
+++ b/src/pkg/debug/dwarf/open.go
@@ -8,29 +8,29 @@
 package dwarf
 
 import (
-	"encoding/binary";
-	"os";
+	"encoding/binary"
+	"os"
 )
 
 // Data represents the DWARF debugging information
 // loaded from an executable file (for example, an ELF or Mach-O executable).
 type Data struct {
 	// raw data
-	abbrev		[]byte;
-	aranges		[]byte;
-	frame		[]byte;
-	info		[]byte;
-	line		[]byte;
-	pubnames	[]byte;
-	ranges		[]byte;
-	str		[]byte;
+	abbrev   []byte
+	aranges  []byte
+	frame    []byte
+	info     []byte
+	line     []byte
+	pubnames []byte
+	ranges   []byte
+	str      []byte
 
 	// parsed data
-	abbrevCache	map[uint32]abbrevTable;
-	addrsize	int;
-	order		binary.ByteOrder;
-	typeCache	map[Offset]Type;
-	unit		[]unit;
+	abbrevCache map[uint32]abbrevTable
+	addrsize    int
+	order       binary.ByteOrder
+	typeCache   map[Offset]Type
+	unit        []unit
 }
 
 // New returns a new Data object initialized from the given parameters.
@@ -52,14 +52,14 @@ func New(abbrev, aranges, frame, info, line, pubnames, ranges, str []byte) (*Dat
 		str: str,
 		abbrevCache: make(map[uint32]abbrevTable),
 		typeCache: make(map[Offset]Type),
-	};
+	}
 
 	// Sniff .debug_info to figure out byte order.
 	// bytes 4:6 are the version, a tiny 16-bit number (1, 2, 3).
 	if len(d.info) < 6 {
 		return nil, DecodeError{"info", Offset(len(d.info)), "too short"}
 	}
-	x, y := d.info[4], d.info[5];
+	x, y := d.info[4], d.info[5]
 	switch {
 	case x == 0 && y == 0:
 		return nil, DecodeError{"info", 4, "unsupported version 0"}
@@ -71,10 +71,10 @@ func New(abbrev, aranges, frame, info, line, pubnames, ranges, str []byte) (*Dat
 		return nil, DecodeError{"info", 4, "cannot determine byte order"}
 	}
 
-	u, err := d.parseUnits();
+	u, err := d.parseUnits()
 	if err != nil {
 		return nil, err
 	}
-	d.unit = u;
-	return d, nil;
+	d.unit = u
+	return d, nil
 }
diff --git a/src/pkg/debug/dwarf/type.go b/src/pkg/debug/dwarf/type.go
index bf57fd4bfa..5d4a516539 100644
--- a/src/pkg/debug/dwarf/type.go
+++ b/src/pkg/debug/dwarf/type.go
@@ -9,259 +9,259 @@
 package dwarf
 
 import (
-	"os";
-	"strconv";
+	"os"
+	"strconv"
 )
 
 // A Type conventionally represents a pointer to any of the
 // specific Type structures (CharType, StructType, etc.).
 type Type interface {
-	Common() *CommonType;
-	String() string;
-	Size() int64;
+	Common() *CommonType
+	String() string
+	Size() int64
 }
 
 // A CommonType holds fields common to multiple types.
 // If a field is not known or not applicable for a given type,
 // the zero value is used.
 type CommonType struct {
-	ByteSize	int64;	// size of value of this type, in bytes
-	Name		string;	// name that can be used to refer to type
+	ByteSize int64  // size of value of this type, in bytes
+	Name     string // name that can be used to refer to type
 }
 
-func (c *CommonType) Common() *CommonType	{ return c }
+func (c *CommonType) Common() *CommonType { return c }
 
-func (c *CommonType) Size() int64	{ return c.ByteSize }
+func (c *CommonType) Size() int64 { return c.ByteSize }
 
 // Basic types
 
 // A BasicType holds fields common to all basic types.
 type BasicType struct {
-	CommonType;
-	BitSize		int64;
-	BitOffset	int64;
+	CommonType
+	BitSize   int64
+	BitOffset int64
 }
 
-func (b *BasicType) Basic() *BasicType	{ return b }
+func (b *BasicType) Basic() *BasicType { return b }
 
 func (t *BasicType) String() string {
 	if t.Name != "" {
 		return t.Name
 	}
-	return "?";
+	return "?"
 }
 
 // A CharType represents a signed character type.
 type CharType struct {
-	BasicType;
+	BasicType
 }
 
 // A UcharType represents an unsigned character type.
 type UcharType struct {
-	BasicType;
+	BasicType
 }
 
 // An IntType represents a signed integer type.
 type IntType struct {
-	BasicType;
+	BasicType
 }
 
 // A UintType represents an unsigned integer type.
 type UintType struct {
-	BasicType;
+	BasicType
 }
 
 // A FloatType represents a floating point type.
 type FloatType struct {
-	BasicType;
+	BasicType
 }
 
 // A ComplexType represents a complex floating point type.
 type ComplexType struct {
-	BasicType;
+	BasicType
 }
 
 // A BoolType represents a boolean type.
 type BoolType struct {
-	BasicType;
+	BasicType
 }
 
 // An AddrType represents a machine address type.
 type AddrType struct {
-	BasicType;
+	BasicType
 }
 
 // qualifiers
 
 // A QualType represents a type that has the C/C++ "const", "restrict", or "volatile" qualifier.
 type QualType struct {
-	CommonType;
-	Qual	string;
-	Type	Type;
+	CommonType
+	Qual string
+	Type Type
 }
 
-func (t *QualType) String() string	{ return t.Qual + " " + t.Type.String() }
+func (t *QualType) String() string { return t.Qual + " " + t.Type.String() }
 
-func (t *QualType) Size() int64	{ return t.Type.Size() }
+func (t *QualType) Size() int64 { return t.Type.Size() }
 
 // An ArrayType represents a fixed size array type.
 type ArrayType struct {
-	CommonType;
-	Type		Type;
-	StrideBitSize	int64;	// if > 0, number of bits to hold each element
-	Count		int64;	// if == -1, an incomplete array, like char x[].
+	CommonType
+	Type          Type
+	StrideBitSize int64 // if > 0, number of bits to hold each element
+	Count         int64 // if == -1, an incomplete array, like char x[].
 }
 
 func (t *ArrayType) String() string {
 	return "[" + strconv.Itoa64(t.Count) + "]" + t.Type.String()
 }
 
-func (t *ArrayType) Size() int64	{ return t.Count * t.Type.Size() }
+func (t *ArrayType) Size() int64 { return t.Count * t.Type.Size() }
 
 // A VoidType represents the C void type.
 type VoidType struct {
-	CommonType;
+	CommonType
 }
 
-func (t *VoidType) String() string	{ return "void" }
+func (t *VoidType) String() string { return "void" }
 
 // A PtrType represents a pointer type.
 type PtrType struct {
-	CommonType;
-	Type	Type;
+	CommonType
+	Type Type
 }
 
-func (t *PtrType) String() string	{ return "*" + t.Type.String() }
+func (t *PtrType) String() string { return "*" + t.Type.String() }
 
 // A StructType represents a struct, union, or C++ class type.
 type StructType struct {
-	CommonType;
-	StructName	string;
-	Kind		string;	// "struct", "union", or "class".
-	Field		[]*StructField;
-	Incomplete	bool;	// if true, struct, union, class is declared but not defined
+	CommonType
+	StructName string
+	Kind       string // "struct", "union", or "class".
+	Field      []*StructField
+	Incomplete bool // if true, struct, union, class is declared but not defined
 }
 
 // A StructField represents a field in a struct, union, or C++ class type.
 type StructField struct {
-	Name		string;
-	Type		Type;
-	ByteOffset	int64;
-	ByteSize	int64;
-	BitOffset	int64;	// within the ByteSize bytes at ByteOffset
-	BitSize		int64;	// zero if not a bit field
+	Name       string
+	Type       Type
+	ByteOffset int64
+	ByteSize   int64
+	BitOffset  int64 // within the ByteSize bytes at ByteOffset
+	BitSize    int64 // zero if not a bit field
 }
 
 func (t *StructType) String() string {
 	if t.StructName != "" {
 		return t.Kind + " " + t.StructName
 	}
-	return t.Defn();
+	return t.Defn()
 }
 
 func (t *StructType) Defn() string {
-	s := t.Kind;
+	s := t.Kind
 	if t.StructName != "" {
 		s += " " + t.StructName
 	}
 	if t.Incomplete {
-		s += " /*incomplete*/";
-		return s;
+		s += " /*incomplete*/"
+		return s
 	}
-	s += " {";
+	s += " {"
 	for i, f := range t.Field {
 		if i > 0 {
 			s += "; "
 		}
-		s += f.Name + " " + f.Type.String();
-		s += "@" + strconv.Itoa64(f.ByteOffset);
+		s += f.Name + " " + f.Type.String()
+		s += "@" + strconv.Itoa64(f.ByteOffset)
 		if f.BitSize > 0 {
-			s += " : " + strconv.Itoa64(f.BitSize);
-			s += "@" + strconv.Itoa64(f.BitOffset);
+			s += " : " + strconv.Itoa64(f.BitSize)
+			s += "@" + strconv.Itoa64(f.BitOffset)
 		}
 	}
-	s += "}";
-	return s;
+	s += "}"
+	return s
 }
 
 // An EnumType represents an enumerated type.
 // The only indication of its native integer type is its ByteSize
 // (inside CommonType).
 type EnumType struct {
-	CommonType;
-	EnumName	string;
-	Val		[]*EnumValue;
+	CommonType
+	EnumName string
+	Val      []*EnumValue
 }
 
 // An EnumValue represents a single enumeration value.
 type EnumValue struct {
-	Name	string;
-	Val	int64;
+	Name string
+	Val  int64
 }
 
 func (t *EnumType) String() string {
-	s := "enum";
+	s := "enum"
 	if t.EnumName != "" {
 		s += " " + t.EnumName
 	}
-	s += " {";
+	s += " {"
 	for i, v := range t.Val {
 		if i > 0 {
 			s += "; "
 		}
-		s += v.Name + "=" + strconv.Itoa64(v.Val);
+		s += v.Name + "=" + strconv.Itoa64(v.Val)
 	}
-	s += "}";
-	return s;
+	s += "}"
+	return s
 }
 
 // A FuncType represents a function type.
 type FuncType struct {
-	CommonType;
-	ReturnType	Type;
-	ParamType	[]Type;
+	CommonType
+	ReturnType Type
+	ParamType  []Type
 }
 
 func (t *FuncType) String() string {
-	s := "func(";
+	s := "func("
 	for i, t := range t.ParamType {
 		if i > 0 {
 			s += ", "
 		}
-		s += t.String();
+		s += t.String()
 	}
-	s += ")";
+	s += ")"
 	if t.ReturnType != nil {
 		s += " " + t.ReturnType.String()
 	}
-	return s;
+	return s
 }
 
 // A DotDotDotType represents the variadic ... function parameter.
 type DotDotDotType struct {
-	CommonType;
+	CommonType
 }
 
-func (t *DotDotDotType) String() string	{ return "..." }
+func (t *DotDotDotType) String() string { return "..." }
 
 // A TypedefType represents a named type.
 type TypedefType struct {
-	CommonType;
-	Type	Type;
+	CommonType
+	Type Type
 }
 
-func (t *TypedefType) String() string	{ return t.Name }
+func (t *TypedefType) String() string { return t.Name }
 
-func (t *TypedefType) Size() int64	{ return t.Type.Size() }
+func (t *TypedefType) Size() int64 { return t.Type.Size() }
 
 func (d *Data) Type(off Offset) (Type, os.Error) {
 	if t, ok := d.typeCache[off]; ok {
 		return t, nil
 	}
 
-	r := d.Reader();
-	r.Seek(off);
-	e, err := r.Next();
+	r := d.Reader()
+	r.Seek(off)
+	e, err := r.Next()
 	if err != nil {
 		return nil, err
 	}
@@ -272,42 +272,42 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 	// Parse type from Entry.
 	// Must always set d.typeCache[off] before calling
 	// d.Type recursively, to handle circular types correctly.
-	var typ Type;
+	var typ Type
 
 	// Get next child; set err if error happens.
 	next := func() *Entry {
 		if !e.Children {
 			return nil
 		}
-		kid, err1 := r.Next();
+		kid, err1 := r.Next()
 		if err1 != nil {
-			err = err1;
-			return nil;
+			err = err1
+			return nil
 		}
 		if kid == nil {
-			err = DecodeError{"info", r.b.off, "unexpected end of DWARF entries"};
-			return nil;
+			err = DecodeError{"info", r.b.off, "unexpected end of DWARF entries"}
+			return nil
 		}
 		if kid.Tag == 0 {
 			return nil
 		}
-		return kid;
-	};
+		return kid
+	}
 
 	// Get Type referred to by Entry's AttrType field.
 	// Set err if error happens.  Not having a type is an error.
 	typeOf := func(e *Entry) Type {
-		toff, ok := e.Val(AttrType).(Offset);
+		toff, ok := e.Val(AttrType).(Offset)
 		if !ok {
 			// It appears that no Type means "void".
 			return new(VoidType)
 		}
-		var t Type;
+		var t Type
 		if t, err = d.Type(toff); err != nil {
 			return nil
 		}
-		return t;
-	};
+		return t
+	}
 
 	switch e.Tag {
 	case TagArrayType:
@@ -319,24 +319,24 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 		// Children:
 		//	TagSubrangeType or TagEnumerationType giving one dimension.
 		//	dimensions are in left to right order.
-		t := new(ArrayType);
-		typ = t;
-		d.typeCache[off] = t;
+		t := new(ArrayType)
+		typ = t
+		d.typeCache[off] = t
 		if t.Type = typeOf(e); err != nil {
 			goto Error
 		}
-		t.StrideBitSize, _ = e.Val(AttrStrideSize).(int64);
+		t.StrideBitSize, _ = e.Val(AttrStrideSize).(int64)
 
 		// Accumulate dimensions,
-		ndim := 0;
+		ndim := 0
 		for kid := next(); kid != nil; kid = next() {
 			// TODO(rsc): Can also be TagEnumerationType
 			// but haven't seen that in the wild yet.
 			switch kid.Tag {
 			case TagSubrangeType:
-				max, ok := kid.Val(AttrUpperBound).(int64);
+				max, ok := kid.Val(AttrUpperBound).(int64)
 				if !ok {
-					max = -2	// Count == -1, as in x[].
+					max = -2 // Count == -1, as in x[].
 				}
 				if ndim == 0 {
 					t.Count = max + 1
@@ -345,15 +345,15 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 					// Create new array type underneath this one.
 					t.Type = &ArrayType{Type: t.Type, Count: max + 1}
 				}
-				ndim++;
+				ndim++
 			case TagEnumerationType:
-				err = DecodeError{"info", kid.Offset, "cannot handle enumeration type as array bound"};
-				goto Error;
+				err = DecodeError{"info", kid.Offset, "cannot handle enumeration type as array bound"}
+				goto Error
 			}
 		}
 		if ndim == 0 {
-			err = DecodeError{"info", e.Offset, "missing dimension for array"};
-			goto Error;
+			err = DecodeError{"info", e.Offset, "missing dimension for array"}
+			goto Error
 		}
 
 	case TagBaseType:
@@ -364,16 +364,16 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 		//	AttrByteSize: size of type in bytes [required]
 		//	AttrBitOffset: for sub-byte types, size in bits
 		//	AttrBitSize: for sub-byte types, bit offset of high order bit in the AttrByteSize bytes
-		name, _ := e.Val(AttrName).(string);
-		enc, ok := e.Val(AttrEncoding).(int64);
+		name, _ := e.Val(AttrName).(string)
+		enc, ok := e.Val(AttrEncoding).(int64)
 		if !ok {
-			err = DecodeError{"info", e.Offset, "missing encoding attribute for " + name};
-			goto Error;
+			err = DecodeError{"info", e.Offset, "missing encoding attribute for " + name}
+			goto Error
 		}
 		switch enc {
 		default:
-			err = DecodeError{"info", e.Offset, "unrecognized encoding attribute value"};
-			goto Error;
+			err = DecodeError{"info", e.Offset, "unrecognized encoding attribute value"}
+			goto Error
 
 		case encAddress:
 			typ = new(AddrType)
@@ -392,13 +392,13 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 		case encUnsignedChar:
 			typ = new(UcharType)
 		}
-		d.typeCache[off] = typ;
+		d.typeCache[off] = typ
 		t := typ.(interface {
-			Basic() *BasicType;
-		}).Basic();
-		t.Name = name;
-		t.BitSize, _ = e.Val(AttrBitSize).(int64);
-		t.BitOffset, _ = e.Val(AttrBitOffset).(int64);
+			Basic() *BasicType
+		}).Basic()
+		t.Name = name
+		t.BitSize, _ = e.Val(AttrBitSize).(int64)
+		t.BitOffset, _ = e.Val(AttrBitOffset).(int64)
 
 	case TagClassType, TagStructType, TagUnionType:
 		// Structure, union, or class type.  (DWARF v2 ยง5.5)
@@ -415,9 +415,9 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 		//		AttrBitSize: bit size for bit fields
 		//		AttrDataMemberLoc: location within struct [required for struct, class]
 		// There is much more to handle C++, all ignored for now.
-		t := new(StructType);
-		typ = t;
-		d.typeCache[off] = t;
+		t := new(StructType)
+		typ = t
+		d.typeCache[off] = t
 		switch e.Tag {
 		case TagClassType:
 			t.Kind = "class"
@@ -426,41 +426,41 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 		case TagUnionType:
 			t.Kind = "union"
 		}
-		t.StructName, _ = e.Val(AttrName).(string);
-		t.Incomplete = e.Val(AttrDeclaration) != nil;
-		t.Field = make([]*StructField, 0, 8);
+		t.StructName, _ = e.Val(AttrName).(string)
+		t.Incomplete = e.Val(AttrDeclaration) != nil
+		t.Field = make([]*StructField, 0, 8)
 		for kid := next(); kid != nil; kid = next() {
 			if kid.Tag == TagMember {
-				f := new(StructField);
+				f := new(StructField)
 				if f.Type = typeOf(kid); err != nil {
 					goto Error
 				}
 				if loc, ok := kid.Val(AttrDataMemberLoc).([]byte); ok {
-					b := makeBuf(d, "location", 0, loc, d.addrsize);
+					b := makeBuf(d, "location", 0, loc, d.addrsize)
 					if b.uint8() != opPlusUconst {
-						err = DecodeError{"info", kid.Offset, "unexpected opcode"};
-						goto Error;
+						err = DecodeError{"info", kid.Offset, "unexpected opcode"}
+						goto Error
 					}
-					f.ByteOffset = int64(b.uint());
+					f.ByteOffset = int64(b.uint())
 					if b.err != nil {
-						err = b.err;
-						goto Error;
+						err = b.err
+						goto Error
 					}
 				}
-				f.Name, _ = kid.Val(AttrName).(string);
-				f.ByteSize, _ = kid.Val(AttrByteSize).(int64);
-				f.BitOffset, _ = kid.Val(AttrBitOffset).(int64);
-				f.BitSize, _ = kid.Val(AttrBitSize).(int64);
-				n := len(t.Field);
+				f.Name, _ = kid.Val(AttrName).(string)
+				f.ByteSize, _ = kid.Val(AttrByteSize).(int64)
+				f.BitOffset, _ = kid.Val(AttrBitOffset).(int64)
+				f.BitSize, _ = kid.Val(AttrBitSize).(int64)
+				n := len(t.Field)
 				if n >= cap(t.Field) {
-					fld := make([]*StructField, n, n*2);
+					fld := make([]*StructField, n, n*2)
 					for i, f := range t.Field {
 						fld[i] = f
 					}
-					t.Field = fld;
+					t.Field = fld
 				}
-				t.Field = t.Field[0 : n+1];
-				t.Field[n] = f;
+				t.Field = t.Field[0 : n+1]
+				t.Field[n] = f
 			}
 		}
 
@@ -468,9 +468,9 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 		// Type modifier (DWARF v2 ยง5.2)
 		// Attributes:
 		//	AttrType: subtype
-		t := new(QualType);
-		typ = t;
-		d.typeCache[off] = t;
+		t := new(QualType)
+		typ = t
+		d.typeCache[off] = t
 		if t.Type = typeOf(e); err != nil {
 			goto Error
 		}
@@ -492,26 +492,26 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 		//	TagEnumerator:
 		//		AttrName: name of constant
 		//		AttrConstValue: value of constant
-		t := new(EnumType);
-		typ = t;
-		d.typeCache[off] = t;
-		t.EnumName, _ = e.Val(AttrName).(string);
-		t.Val = make([]*EnumValue, 0, 8);
+		t := new(EnumType)
+		typ = t
+		d.typeCache[off] = t
+		t.EnumName, _ = e.Val(AttrName).(string)
+		t.Val = make([]*EnumValue, 0, 8)
 		for kid := next(); kid != nil; kid = next() {
 			if kid.Tag == TagEnumerator {
-				f := new(EnumValue);
-				f.Name, _ = kid.Val(AttrName).(string);
-				f.Val, _ = kid.Val(AttrConstValue).(int64);
-				n := len(t.Val);
+				f := new(EnumValue)
+				f.Name, _ = kid.Val(AttrName).(string)
+				f.Val, _ = kid.Val(AttrConstValue).(int64)
+				n := len(t.Val)
 				if n >= cap(t.Val) {
-					val := make([]*EnumValue, n, n*2);
+					val := make([]*EnumValue, n, n*2)
 					for i, f := range t.Val {
 						val[i] = f
 					}
-					t.Val = val;
+					t.Val = val
 				}
-				t.Val = t.Val[0 : n+1];
-				t.Val[n] = f;
+				t.Val = t.Val[0 : n+1]
+				t.Val[n] = f
 			}
 		}
 
@@ -520,14 +520,14 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 		// Attributes:
 		//	AttrType: subtype [not required!  void* has no AttrType]
 		//	AttrAddrClass: address class [ignored]
-		t := new(PtrType);
-		typ = t;
-		d.typeCache[off] = t;
+		t := new(PtrType)
+		typ = t
+		d.typeCache[off] = t
 		if e.Val(AttrType) == nil {
-			t.Type = &VoidType{};
-			break;
+			t.Type = &VoidType{}
+			break
 		}
-		t.Type = typeOf(e);
+		t.Type = typeOf(e)
 
 	case TagSubroutineType:
 		// Subroutine type.  (DWARF v2 ยง5.7)
@@ -539,15 +539,15 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 		//	TagFormalParameter: typed parameter
 		//		AttrType: type of parameter
 		//	TagUnspecifiedParameter: final ...
-		t := new(FuncType);
-		typ = t;
-		d.typeCache[off] = t;
+		t := new(FuncType)
+		typ = t
+		d.typeCache[off] = t
 		if t.ReturnType = typeOf(e); err != nil {
 			goto Error
 		}
-		t.ParamType = make([]Type, 0, 8);
+		t.ParamType = make([]Type, 0, 8)
 		for kid := next(); kid != nil; kid = next() {
-			var tkid Type;
+			var tkid Type
 			switch kid.Tag {
 			default:
 				continue
@@ -558,16 +558,16 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 			case TagUnspecifiedParameters:
 				tkid = &DotDotDotType{}
 			}
-			n := len(t.ParamType);
+			n := len(t.ParamType)
 			if n >= cap(t.ParamType) {
-				param := make([]Type, n, n*2);
+				param := make([]Type, n, n*2)
 				for i, t := range t.ParamType {
 					param[i] = t
 				}
-				t.ParamType = param;
+				t.ParamType = param
 			}
-			t.ParamType = t.ParamType[0 : n+1];
-			t.ParamType[n] = tkid;
+			t.ParamType = t.ParamType[0 : n+1]
+			t.ParamType[n] = tkid
 		}
 
 	case TagTypedef:
@@ -575,29 +575,29 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 		// Attributes:
 		//	AttrName: name [required]
 		//	AttrType: type definition [required]
-		t := new(TypedefType);
-		typ = t;
-		d.typeCache[off] = t;
-		t.Name, _ = e.Val(AttrName).(string);
-		t.Type = typeOf(e);
+		t := new(TypedefType)
+		typ = t
+		d.typeCache[off] = t
+		t.Name, _ = e.Val(AttrName).(string)
+		t.Type = typeOf(e)
 	}
 
 	if err != nil {
 		goto Error
 	}
 
-	b, ok := e.Val(AttrByteSize).(int64);
+	b, ok := e.Val(AttrByteSize).(int64)
 	if !ok {
 		b = -1
 	}
-	typ.Common().ByteSize = b;
+	typ.Common().ByteSize = b
 
-	return typ, nil;
+	return typ, nil
 
 Error:
 	// If the parse fails, take the type out of the cache
 	// so that the next call with this offset doesn't hit
 	// the cache and return success.
-	d.typeCache[off] = nil, false;
-	return nil, err;
+	d.typeCache[off] = nil, false
+	return nil, err
 }
diff --git a/src/pkg/debug/dwarf/type_test.go b/src/pkg/debug/dwarf/type_test.go
index 629f0fb166..2c5aabd397 100644
--- a/src/pkg/debug/dwarf/type_test.go
+++ b/src/pkg/debug/dwarf/type_test.go
@@ -5,10 +5,10 @@
 package dwarf_test
 
 import (
-	. "debug/dwarf";
-	"debug/elf";
-	"debug/macho";
-	"testing";
+	. "debug/dwarf"
+	"debug/elf"
+	"debug/macho"
+	"testing"
 )
 
 var typedefTests = map[string]string{
@@ -30,43 +30,43 @@ var typedefTests = map[string]string{
 }
 
 func elfData(t *testing.T, name string) *Data {
-	f, err := elf.Open(name);
+	f, err := elf.Open(name)
 	if err != nil {
 		t.Fatal(err)
 	}
 
-	d, err := f.DWARF();
+	d, err := f.DWARF()
 	if err != nil {
 		t.Fatal(err)
 	}
-	return d;
+	return d
 }
 
 func machoData(t *testing.T, name string) *Data {
-	f, err := macho.Open(name);
+	f, err := macho.Open(name)
 	if err != nil {
 		t.Fatal(err)
 	}
 
-	d, err := f.DWARF();
+	d, err := f.DWARF()
 	if err != nil {
 		t.Fatal(err)
 	}
-	return d;
+	return d
 }
 
 
-func TestTypedefsELF(t *testing.T)	{ testTypedefs(t, elfData(t, "testdata/typedef.elf")) }
+func TestTypedefsELF(t *testing.T) { testTypedefs(t, elfData(t, "testdata/typedef.elf")) }
 
 func TestTypedefsMachO(t *testing.T) {
 	testTypedefs(t, machoData(t, "testdata/typedef.macho"))
 }
 
 func testTypedefs(t *testing.T, d *Data) {
-	r := d.Reader();
-	seen := make(map[string]bool);
+	r := d.Reader()
+	seen := make(map[string]bool)
 	for {
-		e, err := r.Next();
+		e, err := r.Next()
 		if err != nil {
 			t.Fatal("r.Next:", err)
 		}
@@ -74,12 +74,12 @@ func testTypedefs(t *testing.T, d *Data) {
 			break
 		}
 		if e.Tag == TagTypedef {
-			typ, err := d.Type(e.Offset);
+			typ, err := d.Type(e.Offset)
 			if err != nil {
 				t.Fatal("d.Type:", err)
 			}
-			t1 := typ.(*TypedefType);
-			var typstr string;
+			t1 := typ.(*TypedefType)
+			var typstr string
 			if ts, ok := t1.Type.(*StructType); ok {
 				typstr = ts.Defn()
 			} else {
@@ -90,7 +90,7 @@ func testTypedefs(t *testing.T, d *Data) {
 				if _, ok := seen[t1.Name]; ok {
 					t.Errorf("multiple definitions for %s", t1.Name)
 				}
-				seen[t1.Name] = true;
+				seen[t1.Name] = true
 				if typstr != want {
 					t.Errorf("%s:\n\thave %s\n\twant %s", t1.Name, typstr, want)
 				}
diff --git a/src/pkg/debug/dwarf/unit.go b/src/pkg/debug/dwarf/unit.go
index eb4e7656e5..02cb363b40 100644
--- a/src/pkg/debug/dwarf/unit.go
+++ b/src/pkg/debug/dwarf/unit.go
@@ -5,58 +5,58 @@
 package dwarf
 
 import (
-	"os";
-	"strconv";
+	"os"
+	"strconv"
 )
 
 // DWARF debug info is split into a sequence of compilation units.
 // Each unit has its own abbreviation table and address size.
 
 type unit struct {
-	base		Offset;	// byte offset of header within the aggregate info
-	off		Offset;	// byte offset of data within the aggregate info
-	data		[]byte;
-	atable		abbrevTable;
-	addrsize	int;
+	base     Offset // byte offset of header within the aggregate info
+	off      Offset // byte offset of data within the aggregate info
+	data     []byte
+	atable   abbrevTable
+	addrsize int
 }
 
 func (d *Data) parseUnits() ([]unit, os.Error) {
 	// Count units.
-	nunit := 0;
-	b := makeBuf(d, "info", 0, d.info, 0);
+	nunit := 0
+	b := makeBuf(d, "info", 0, d.info, 0)
 	for len(b.data) > 0 {
-		b.skip(int(b.uint32()));
-		nunit++;
+		b.skip(int(b.uint32()))
+		nunit++
 	}
 	if b.err != nil {
 		return nil, b.err
 	}
 
 	// Again, this time writing them down.
-	b = makeBuf(d, "info", 0, d.info, 0);
-	units := make([]unit, nunit);
+	b = makeBuf(d, "info", 0, d.info, 0)
+	units := make([]unit, nunit)
 	for i := range units {
-		u := &units[i];
-		u.base = b.off;
-		n := b.uint32();
+		u := &units[i]
+		u.base = b.off
+		n := b.uint32()
 		if vers := b.uint16(); vers != 2 {
-			b.error("unsupported DWARF version " + strconv.Itoa(int(vers)));
-			break;
+			b.error("unsupported DWARF version " + strconv.Itoa(int(vers)))
+			break
 		}
-		atable, err := d.parseAbbrev(b.uint32());
+		atable, err := d.parseAbbrev(b.uint32())
 		if err != nil {
 			if b.err == nil {
 				b.err = err
 			}
-			break;
+			break
 		}
-		u.atable = atable;
-		u.addrsize = int(b.uint8());
-		u.off = b.off;
-		u.data = b.bytes(int(n - (2 + 4 + 1)));
+		u.atable = atable
+		u.addrsize = int(b.uint8())
+		u.off = b.off
+		u.data = b.bytes(int(n - (2 + 4 + 1)))
 	}
 	if b.err != nil {
 		return nil, b.err
 	}
-	return units, nil;
+	return units, nil
 }
diff --git a/src/pkg/debug/elf/elf.go b/src/pkg/debug/elf/elf.go
index 70a11f6f65..f0e49851bf 100644
--- a/src/pkg/debug/elf/elf.go
+++ b/src/pkg/debug/elf/elf.go
@@ -48,13 +48,13 @@ import "strconv"
 
 // Indexes into the Header.Ident array.
 const (
-	EI_CLASS	= 4;	/* Class of machine. */
-	EI_DATA		= 5;	/* Data format. */
-	EI_VERSION	= 6;	/* ELF format version. */
-	EI_OSABI	= 7;	/* Operating system / ABI identification */
-	EI_ABIVERSION	= 8;	/* ABI version */
-	EI_PAD		= 9;	/* Start of padding (per SVR4 ABI). */
-	EI_NIDENT	= 16;	/* Size of e_ident array. */
+	EI_CLASS      = 4  /* Class of machine. */
+	EI_DATA       = 5  /* Data format. */
+	EI_VERSION    = 6  /* ELF format version. */
+	EI_OSABI      = 7  /* Operating system / ABI identification */
+	EI_ABIVERSION = 8  /* ABI version */
+	EI_PAD        = 9  /* Start of padding (per SVR4 ABI). */
+	EI_NIDENT     = 16 /* Size of e_ident array. */
 )
 
 // Initial magic number for ELF files.
@@ -64,8 +64,8 @@ const ELFMAG = "\177ELF"
 type Version byte
 
 const (
-	EV_NONE		Version	= 0;
-	EV_CURRENT	Version	= 1;
+	EV_NONE    Version = 0
+	EV_CURRENT Version = 1
 )
 
 var versionStrings = []intName{
@@ -73,16 +73,16 @@ var versionStrings = []intName{
 	intName{1, "EV_CURRENT"},
 }
 
-func (i Version) String() string	{ return stringName(uint32(i), versionStrings, false) }
-func (i Version) GoString() string	{ return stringName(uint32(i), versionStrings, true) }
+func (i Version) String() string   { return stringName(uint32(i), versionStrings, false) }
+func (i Version) GoString() string { return stringName(uint32(i), versionStrings, true) }
 
 // Class is found in Header.Ident[EI_CLASS] and Header.Class.
 type Class byte
 
 const (
-	ELFCLASSNONE	Class	= 0;	/* Unknown class. */
-	ELFCLASS32	Class	= 1;	/* 32-bit architecture. */
-	ELFCLASS64	Class	= 2;	/* 64-bit architecture. */
+	ELFCLASSNONE Class = 0 /* Unknown class. */
+	ELFCLASS32   Class = 1 /* 32-bit architecture. */
+	ELFCLASS64   Class = 2 /* 64-bit architecture. */
 )
 
 var classStrings = []intName{
@@ -91,16 +91,16 @@ var classStrings = []intName{
 	intName{2, "ELFCLASS64"},
 }
 
-func (i Class) String() string		{ return stringName(uint32(i), classStrings, false) }
-func (i Class) GoString() string	{ return stringName(uint32(i), classStrings, true) }
+func (i Class) String() string   { return stringName(uint32(i), classStrings, false) }
+func (i Class) GoString() string { return stringName(uint32(i), classStrings, true) }
 
 // Data is found in Header.Ident[EI_DATA] and Header.Data.
 type Data byte
 
 const (
-	ELFDATANONE	Data	= 0;	/* Unknown data format. */
-	ELFDATA2LSB	Data	= 1;	/* 2's complement little-endian. */
-	ELFDATA2MSB	Data	= 2;	/* 2's complement big-endian. */
+	ELFDATANONE Data = 0 /* Unknown data format. */
+	ELFDATA2LSB Data = 1 /* 2's complement little-endian. */
+	ELFDATA2MSB Data = 2 /* 2's complement big-endian. */
 )
 
 var dataStrings = []intName{
@@ -109,30 +109,30 @@ var dataStrings = []intName{
 	intName{2, "ELFDATA2MSB"},
 }
 
-func (i Data) String() string	{ return stringName(uint32(i), dataStrings, false) }
-func (i Data) GoString() string	{ return stringName(uint32(i), dataStrings, true) }
+func (i Data) String() string   { return stringName(uint32(i), dataStrings, false) }
+func (i Data) GoString() string { return stringName(uint32(i), dataStrings, true) }
 
 // OSABI is found in Header.Ident[EI_OSABI] and Header.OSABI.
 type OSABI byte
 
 const (
-	ELFOSABI_NONE		OSABI	= 0;	/* UNIX System V ABI */
-	ELFOSABI_HPUX		OSABI	= 1;	/* HP-UX operating system */
-	ELFOSABI_NETBSD		OSABI	= 2;	/* NetBSD */
-	ELFOSABI_LINUX		OSABI	= 3;	/* GNU/Linux */
-	ELFOSABI_HURD		OSABI	= 4;	/* GNU/Hurd */
-	ELFOSABI_86OPEN		OSABI	= 5;	/* 86Open common IA32 ABI */
-	ELFOSABI_SOLARIS	OSABI	= 6;	/* Solaris */
-	ELFOSABI_AIX		OSABI	= 7;	/* AIX */
-	ELFOSABI_IRIX		OSABI	= 8;	/* IRIX */
-	ELFOSABI_FREEBSD	OSABI	= 9;	/* FreeBSD */
-	ELFOSABI_TRU64		OSABI	= 10;	/* TRU64 UNIX */
-	ELFOSABI_MODESTO	OSABI	= 11;	/* Novell Modesto */
-	ELFOSABI_OPENBSD	OSABI	= 12;	/* OpenBSD */
-	ELFOSABI_OPENVMS	OSABI	= 13;	/* Open VMS */
-	ELFOSABI_NSK		OSABI	= 14;	/* HP Non-Stop Kernel */
-	ELFOSABI_ARM		OSABI	= 97;	/* ARM */
-	ELFOSABI_STANDALONE	OSABI	= 255;	/* Standalone (embedded) application */
+	ELFOSABI_NONE       OSABI = 0   /* UNIX System V ABI */
+	ELFOSABI_HPUX       OSABI = 1   /* HP-UX operating system */
+	ELFOSABI_NETBSD     OSABI = 2   /* NetBSD */
+	ELFOSABI_LINUX      OSABI = 3   /* GNU/Linux */
+	ELFOSABI_HURD       OSABI = 4   /* GNU/Hurd */
+	ELFOSABI_86OPEN     OSABI = 5   /* 86Open common IA32 ABI */
+	ELFOSABI_SOLARIS    OSABI = 6   /* Solaris */
+	ELFOSABI_AIX        OSABI = 7   /* AIX */
+	ELFOSABI_IRIX       OSABI = 8   /* IRIX */
+	ELFOSABI_FREEBSD    OSABI = 9   /* FreeBSD */
+	ELFOSABI_TRU64      OSABI = 10  /* TRU64 UNIX */
+	ELFOSABI_MODESTO    OSABI = 11  /* Novell Modesto */
+	ELFOSABI_OPENBSD    OSABI = 12  /* OpenBSD */
+	ELFOSABI_OPENVMS    OSABI = 13  /* Open VMS */
+	ELFOSABI_NSK        OSABI = 14  /* HP Non-Stop Kernel */
+	ELFOSABI_ARM        OSABI = 97  /* ARM */
+	ELFOSABI_STANDALONE OSABI = 255 /* Standalone (embedded) application */
 )
 
 var osabiStrings = []intName{
@@ -155,22 +155,22 @@ var osabiStrings = []intName{
 	intName{255, "ELFOSABI_STANDALONE"},
 }
 
-func (i OSABI) String() string		{ return stringName(uint32(i), osabiStrings, false) }
-func (i OSABI) GoString() string	{ return stringName(uint32(i), osabiStrings, true) }
+func (i OSABI) String() string   { return stringName(uint32(i), osabiStrings, false) }
+func (i OSABI) GoString() string { return stringName(uint32(i), osabiStrings, true) }
 
 // Type is found in Header.Type.
 type Type uint16
 
 const (
-	ET_NONE		Type	= 0;		/* Unknown type. */
-	ET_REL		Type	= 1;		/* Relocatable. */
-	ET_EXEC		Type	= 2;		/* Executable. */
-	ET_DYN		Type	= 3;		/* Shared object. */
-	ET_CORE		Type	= 4;		/* Core file. */
-	ET_LOOS		Type	= 0xfe00;	/* First operating system specific. */
-	ET_HIOS		Type	= 0xfeff;	/* Last operating system-specific. */
-	ET_LOPROC	Type	= 0xff00;	/* First processor-specific. */
-	ET_HIPROC	Type	= 0xffff;	/* Last processor-specific. */
+	ET_NONE   Type = 0      /* Unknown type. */
+	ET_REL    Type = 1      /* Relocatable. */
+	ET_EXEC   Type = 2      /* Executable. */
+	ET_DYN    Type = 3      /* Shared object. */
+	ET_CORE   Type = 4      /* Core file. */
+	ET_LOOS   Type = 0xfe00 /* First operating system specific. */
+	ET_HIOS   Type = 0xfeff /* Last operating system-specific. */
+	ET_LOPROC Type = 0xff00 /* First processor-specific. */
+	ET_HIPROC Type = 0xffff /* Last processor-specific. */
 )
 
 var typeStrings = []intName{
@@ -185,62 +185,62 @@ var typeStrings = []intName{
 	intName{0xffff, "ET_HIPROC"},
 }
 
-func (i Type) String() string	{ return stringName(uint32(i), typeStrings, false) }
-func (i Type) GoString() string	{ return stringName(uint32(i), typeStrings, true) }
+func (i Type) String() string   { return stringName(uint32(i), typeStrings, false) }
+func (i Type) GoString() string { return stringName(uint32(i), typeStrings, true) }
 
 // Machine is found in Header.Machine.
 type Machine uint16
 
 const (
-	EM_NONE		Machine	= 0;	/* Unknown machine. */
-	EM_M32		Machine	= 1;	/* AT&T WE32100. */
-	EM_SPARC	Machine	= 2;	/* Sun SPARC. */
-	EM_386		Machine	= 3;	/* Intel i386. */
-	EM_68K		Machine	= 4;	/* Motorola 68000. */
-	EM_88K		Machine	= 5;	/* Motorola 88000. */
-	EM_860		Machine	= 7;	/* Intel i860. */
-	EM_MIPS		Machine	= 8;	/* MIPS R3000 Big-Endian only. */
-	EM_S370		Machine	= 9;	/* IBM System/370. */
-	EM_MIPS_RS3_LE	Machine	= 10;	/* MIPS R3000 Little-Endian. */
-	EM_PARISC	Machine	= 15;	/* HP PA-RISC. */
-	EM_VPP500	Machine	= 17;	/* Fujitsu VPP500. */
-	EM_SPARC32PLUS	Machine	= 18;	/* SPARC v8plus. */
-	EM_960		Machine	= 19;	/* Intel 80960. */
-	EM_PPC		Machine	= 20;	/* PowerPC 32-bit. */
-	EM_PPC64	Machine	= 21;	/* PowerPC 64-bit. */
-	EM_S390		Machine	= 22;	/* IBM System/390. */
-	EM_V800		Machine	= 36;	/* NEC V800. */
-	EM_FR20		Machine	= 37;	/* Fujitsu FR20. */
-	EM_RH32		Machine	= 38;	/* TRW RH-32. */
-	EM_RCE		Machine	= 39;	/* Motorola RCE. */
-	EM_ARM		Machine	= 40;	/* ARM. */
-	EM_SH		Machine	= 42;	/* Hitachi SH. */
-	EM_SPARCV9	Machine	= 43;	/* SPARC v9 64-bit. */
-	EM_TRICORE	Machine	= 44;	/* Siemens TriCore embedded processor. */
-	EM_ARC		Machine	= 45;	/* Argonaut RISC Core. */
-	EM_H8_300	Machine	= 46;	/* Hitachi H8/300. */
-	EM_H8_300H	Machine	= 47;	/* Hitachi H8/300H. */
-	EM_H8S		Machine	= 48;	/* Hitachi H8S. */
-	EM_H8_500	Machine	= 49;	/* Hitachi H8/500. */
-	EM_IA_64	Machine	= 50;	/* Intel IA-64 Processor. */
-	EM_MIPS_X	Machine	= 51;	/* Stanford MIPS-X. */
-	EM_COLDFIRE	Machine	= 52;	/* Motorola ColdFire. */
-	EM_68HC12	Machine	= 53;	/* Motorola M68HC12. */
-	EM_MMA		Machine	= 54;	/* Fujitsu MMA. */
-	EM_PCP		Machine	= 55;	/* Siemens PCP. */
-	EM_NCPU		Machine	= 56;	/* Sony nCPU. */
-	EM_NDR1		Machine	= 57;	/* Denso NDR1 microprocessor. */
-	EM_STARCORE	Machine	= 58;	/* Motorola Star*Core processor. */
-	EM_ME16		Machine	= 59;	/* Toyota ME16 processor. */
-	EM_ST100	Machine	= 60;	/* STMicroelectronics ST100 processor. */
-	EM_TINYJ	Machine	= 61;	/* Advanced Logic Corp. TinyJ processor. */
-	EM_X86_64	Machine	= 62;	/* Advanced Micro Devices x86-64 */
+	EM_NONE        Machine = 0  /* Unknown machine. */
+	EM_M32         Machine = 1  /* AT&T WE32100. */
+	EM_SPARC       Machine = 2  /* Sun SPARC. */
+	EM_386         Machine = 3  /* Intel i386. */
+	EM_68K         Machine = 4  /* Motorola 68000. */
+	EM_88K         Machine = 5  /* Motorola 88000. */
+	EM_860         Machine = 7  /* Intel i860. */
+	EM_MIPS        Machine = 8  /* MIPS R3000 Big-Endian only. */
+	EM_S370        Machine = 9  /* IBM System/370. */
+	EM_MIPS_RS3_LE Machine = 10 /* MIPS R3000 Little-Endian. */
+	EM_PARISC      Machine = 15 /* HP PA-RISC. */
+	EM_VPP500      Machine = 17 /* Fujitsu VPP500. */
+	EM_SPARC32PLUS Machine = 18 /* SPARC v8plus. */
+	EM_960         Machine = 19 /* Intel 80960. */
+	EM_PPC         Machine = 20 /* PowerPC 32-bit. */
+	EM_PPC64       Machine = 21 /* PowerPC 64-bit. */
+	EM_S390        Machine = 22 /* IBM System/390. */
+	EM_V800        Machine = 36 /* NEC V800. */
+	EM_FR20        Machine = 37 /* Fujitsu FR20. */
+	EM_RH32        Machine = 38 /* TRW RH-32. */
+	EM_RCE         Machine = 39 /* Motorola RCE. */
+	EM_ARM         Machine = 40 /* ARM. */
+	EM_SH          Machine = 42 /* Hitachi SH. */
+	EM_SPARCV9     Machine = 43 /* SPARC v9 64-bit. */
+	EM_TRICORE     Machine = 44 /* Siemens TriCore embedded processor. */
+	EM_ARC         Machine = 45 /* Argonaut RISC Core. */
+	EM_H8_300      Machine = 46 /* Hitachi H8/300. */
+	EM_H8_300H     Machine = 47 /* Hitachi H8/300H. */
+	EM_H8S         Machine = 48 /* Hitachi H8S. */
+	EM_H8_500      Machine = 49 /* Hitachi H8/500. */
+	EM_IA_64       Machine = 50 /* Intel IA-64 Processor. */
+	EM_MIPS_X      Machine = 51 /* Stanford MIPS-X. */
+	EM_COLDFIRE    Machine = 52 /* Motorola ColdFire. */
+	EM_68HC12      Machine = 53 /* Motorola M68HC12. */
+	EM_MMA         Machine = 54 /* Fujitsu MMA. */
+	EM_PCP         Machine = 55 /* Siemens PCP. */
+	EM_NCPU        Machine = 56 /* Sony nCPU. */
+	EM_NDR1        Machine = 57 /* Denso NDR1 microprocessor. */
+	EM_STARCORE    Machine = 58 /* Motorola Star*Core processor. */
+	EM_ME16        Machine = 59 /* Toyota ME16 processor. */
+	EM_ST100       Machine = 60 /* STMicroelectronics ST100 processor. */
+	EM_TINYJ       Machine = 61 /* Advanced Logic Corp. TinyJ processor. */
+	EM_X86_64      Machine = 62 /* Advanced Micro Devices x86-64 */
 
 	/* Non-standard or deprecated. */
-	EM_486		Machine	= 6;		/* Intel i486. */
-	EM_MIPS_RS4_BE	Machine	= 10;		/* MIPS R4000 Big-Endian */
-	EM_ALPHA_STD	Machine	= 41;		/* Digital Alpha (standard value). */
-	EM_ALPHA	Machine	= 0x9026;	/* Alpha (written in the absence of an ABI) */
+	EM_486         Machine = 6      /* Intel i486. */
+	EM_MIPS_RS4_BE Machine = 10     /* MIPS R4000 Big-Endian */
+	EM_ALPHA_STD   Machine = 41     /* Digital Alpha (standard value). */
+	EM_ALPHA       Machine = 0x9026 /* Alpha (written in the absence of an ABI) */
 )
 
 var machineStrings = []intName{
@@ -295,23 +295,23 @@ var machineStrings = []intName{
 	intName{0x9026, "EM_ALPHA"},
 }
 
-func (i Machine) String() string	{ return stringName(uint32(i), machineStrings, false) }
-func (i Machine) GoString() string	{ return stringName(uint32(i), machineStrings, true) }
+func (i Machine) String() string   { return stringName(uint32(i), machineStrings, false) }
+func (i Machine) GoString() string { return stringName(uint32(i), machineStrings, true) }
 
 // Special section indices.
 type SectionIndex int
 
 const (
-	SHN_UNDEF	SectionIndex	= 0;		/* Undefined, missing, irrelevant. */
-	SHN_LORESERVE	SectionIndex	= 0xff00;	/* First of reserved range. */
-	SHN_LOPROC	SectionIndex	= 0xff00;	/* First processor-specific. */
-	SHN_HIPROC	SectionIndex	= 0xff1f;	/* Last processor-specific. */
-	SHN_LOOS	SectionIndex	= 0xff20;	/* First operating system-specific. */
-	SHN_HIOS	SectionIndex	= 0xff3f;	/* Last operating system-specific. */
-	SHN_ABS		SectionIndex	= 0xfff1;	/* Absolute values. */
-	SHN_COMMON	SectionIndex	= 0xfff2;	/* Common data. */
-	SHN_XINDEX	SectionIndex	= 0xffff;	/* Escape -- index stored elsewhere. */
-	SHN_HIRESERVE	SectionIndex	= 0xffff;	/* Last of reserved range. */
+	SHN_UNDEF     SectionIndex = 0      /* Undefined, missing, irrelevant. */
+	SHN_LORESERVE SectionIndex = 0xff00 /* First of reserved range. */
+	SHN_LOPROC    SectionIndex = 0xff00 /* First processor-specific. */
+	SHN_HIPROC    SectionIndex = 0xff1f /* Last processor-specific. */
+	SHN_LOOS      SectionIndex = 0xff20 /* First operating system-specific. */
+	SHN_HIOS      SectionIndex = 0xff3f /* Last operating system-specific. */
+	SHN_ABS       SectionIndex = 0xfff1 /* Absolute values. */
+	SHN_COMMON    SectionIndex = 0xfff2 /* Common data. */
+	SHN_XINDEX    SectionIndex = 0xffff /* Escape -- index stored elsewhere. */
+	SHN_HIRESERVE SectionIndex = 0xffff /* Last of reserved range. */
 )
 
 var shnStrings = []intName{
@@ -323,36 +323,36 @@ var shnStrings = []intName{
 	intName{0xffff, "SHN_XINDEX"},
 }
 
-func (i SectionIndex) String() string	{ return stringName(uint32(i), shnStrings, false) }
-func (i SectionIndex) GoString() string	{ return stringName(uint32(i), shnStrings, true) }
+func (i SectionIndex) String() string   { return stringName(uint32(i), shnStrings, false) }
+func (i SectionIndex) GoString() string { return stringName(uint32(i), shnStrings, true) }
 
 // Section type.
 type SectionType uint32
 
 const (
-	SHT_NULL		SectionType	= 0;		/* inactive */
-	SHT_PROGBITS		SectionType	= 1;		/* program defined information */
-	SHT_SYMTAB		SectionType	= 2;		/* symbol table section */
-	SHT_STRTAB		SectionType	= 3;		/* string table section */
-	SHT_RELA		SectionType	= 4;		/* relocation section with addends */
-	SHT_HASH		SectionType	= 5;		/* symbol hash table section */
-	SHT_DYNAMIC		SectionType	= 6;		/* dynamic section */
-	SHT_NOTE		SectionType	= 7;		/* note section */
-	SHT_NOBITS		SectionType	= 8;		/* no space section */
-	SHT_REL			SectionType	= 9;		/* relocation section - no addends */
-	SHT_SHLIB		SectionType	= 10;		/* reserved - purpose unknown */
-	SHT_DYNSYM		SectionType	= 11;		/* dynamic symbol table section */
-	SHT_INIT_ARRAY		SectionType	= 14;		/* Initialization function pointers. */
-	SHT_FINI_ARRAY		SectionType	= 15;		/* Termination function pointers. */
-	SHT_PREINIT_ARRAY	SectionType	= 16;		/* Pre-initialization function ptrs. */
-	SHT_GROUP		SectionType	= 17;		/* Section group. */
-	SHT_SYMTAB_SHNDX	SectionType	= 18;		/* Section indexes (see SHN_XINDEX). */
-	SHT_LOOS		SectionType	= 0x60000000;	/* First of OS specific semantics */
-	SHT_HIOS		SectionType	= 0x6fffffff;	/* Last of OS specific semantics */
-	SHT_LOPROC		SectionType	= 0x70000000;	/* reserved range for processor */
-	SHT_HIPROC		SectionType	= 0x7fffffff;	/* specific section header types */
-	SHT_LOUSER		SectionType	= 0x80000000;	/* reserved range for application */
-	SHT_HIUSER		SectionType	= 0xffffffff;	/* specific indexes */
+	SHT_NULL          SectionType = 0          /* inactive */
+	SHT_PROGBITS      SectionType = 1          /* program defined information */
+	SHT_SYMTAB        SectionType = 2          /* symbol table section */
+	SHT_STRTAB        SectionType = 3          /* string table section */
+	SHT_RELA          SectionType = 4          /* relocation section with addends */
+	SHT_HASH          SectionType = 5          /* symbol hash table section */
+	SHT_DYNAMIC       SectionType = 6          /* dynamic section */
+	SHT_NOTE          SectionType = 7          /* note section */
+	SHT_NOBITS        SectionType = 8          /* no space section */
+	SHT_REL           SectionType = 9          /* relocation section - no addends */
+	SHT_SHLIB         SectionType = 10         /* reserved - purpose unknown */
+	SHT_DYNSYM        SectionType = 11         /* dynamic symbol table section */
+	SHT_INIT_ARRAY    SectionType = 14         /* Initialization function pointers. */
+	SHT_FINI_ARRAY    SectionType = 15         /* Termination function pointers. */
+	SHT_PREINIT_ARRAY SectionType = 16         /* Pre-initialization function ptrs. */
+	SHT_GROUP         SectionType = 17         /* Section group. */
+	SHT_SYMTAB_SHNDX  SectionType = 18         /* Section indexes (see SHN_XINDEX). */
+	SHT_LOOS          SectionType = 0x60000000 /* First of OS specific semantics */
+	SHT_HIOS          SectionType = 0x6fffffff /* Last of OS specific semantics */
+	SHT_LOPROC        SectionType = 0x70000000 /* reserved range for processor */
+	SHT_HIPROC        SectionType = 0x7fffffff /* specific section header types */
+	SHT_LOUSER        SectionType = 0x80000000 /* reserved range for application */
+	SHT_HIUSER        SectionType = 0xffffffff /* specific indexes */
 )
 
 var shtStrings = []intName{
@@ -381,25 +381,25 @@ var shtStrings = []intName{
 	intName{0xffffffff, "SHT_HIUSER"},
 }
 
-func (i SectionType) String() string	{ return stringName(uint32(i), shtStrings, false) }
-func (i SectionType) GoString() string	{ return stringName(uint32(i), shtStrings, true) }
+func (i SectionType) String() string   { return stringName(uint32(i), shtStrings, false) }
+func (i SectionType) GoString() string { return stringName(uint32(i), shtStrings, true) }
 
 // Section flags.
 type SectionFlag uint32
 
 const (
-	SHF_WRITE		SectionFlag	= 0x1;		/* Section contains writable data. */
-	SHF_ALLOC		SectionFlag	= 0x2;		/* Section occupies memory. */
-	SHF_EXECINSTR		SectionFlag	= 0x4;		/* Section contains instructions. */
-	SHF_MERGE		SectionFlag	= 0x10;		/* Section may be merged. */
-	SHF_STRINGS		SectionFlag	= 0x20;		/* Section contains strings. */
-	SHF_INFO_LINK		SectionFlag	= 0x40;		/* sh_info holds section index. */
-	SHF_LINK_ORDER		SectionFlag	= 0x80;		/* Special ordering requirements. */
-	SHF_OS_NONCONFORMING	SectionFlag	= 0x100;	/* OS-specific processing required. */
-	SHF_GROUP		SectionFlag	= 0x200;	/* Member of section group. */
-	SHF_TLS			SectionFlag	= 0x400;	/* Section contains TLS data. */
-	SHF_MASKOS		SectionFlag	= 0x0ff00000;	/* OS-specific semantics. */
-	SHF_MASKPROC		SectionFlag	= 0xf0000000;	/* Processor-specific semantics. */
+	SHF_WRITE            SectionFlag = 0x1        /* Section contains writable data. */
+	SHF_ALLOC            SectionFlag = 0x2        /* Section occupies memory. */
+	SHF_EXECINSTR        SectionFlag = 0x4        /* Section contains instructions. */
+	SHF_MERGE            SectionFlag = 0x10       /* Section may be merged. */
+	SHF_STRINGS          SectionFlag = 0x20       /* Section contains strings. */
+	SHF_INFO_LINK        SectionFlag = 0x40       /* sh_info holds section index. */
+	SHF_LINK_ORDER       SectionFlag = 0x80       /* Special ordering requirements. */
+	SHF_OS_NONCONFORMING SectionFlag = 0x100      /* OS-specific processing required. */
+	SHF_GROUP            SectionFlag = 0x200      /* Member of section group. */
+	SHF_TLS              SectionFlag = 0x400      /* Section contains TLS data. */
+	SHF_MASKOS           SectionFlag = 0x0ff00000 /* OS-specific semantics. */
+	SHF_MASKPROC         SectionFlag = 0xf0000000 /* Processor-specific semantics. */
 )
 
 var shfStrings = []intName{
@@ -415,25 +415,25 @@ var shfStrings = []intName{
 	intName{0x400, "SHF_TLS"},
 }
 
-func (i SectionFlag) String() string	{ return flagName(uint32(i), shfStrings, false) }
-func (i SectionFlag) GoString() string	{ return flagName(uint32(i), shfStrings, true) }
+func (i SectionFlag) String() string   { return flagName(uint32(i), shfStrings, false) }
+func (i SectionFlag) GoString() string { return flagName(uint32(i), shfStrings, true) }
 
 // Prog.Type
 type ProgType int
 
 const (
-	PT_NULL		ProgType	= 0;		/* Unused entry. */
-	PT_LOAD		ProgType	= 1;		/* Loadable segment. */
-	PT_DYNAMIC	ProgType	= 2;		/* Dynamic linking information segment. */
-	PT_INTERP	ProgType	= 3;		/* Pathname of interpreter. */
-	PT_NOTE		ProgType	= 4;		/* Auxiliary information. */
-	PT_SHLIB	ProgType	= 5;		/* Reserved (not used). */
-	PT_PHDR		ProgType	= 6;		/* Location of program header itself. */
-	PT_TLS		ProgType	= 7;		/* Thread local storage segment */
-	PT_LOOS		ProgType	= 0x60000000;	/* First OS-specific. */
-	PT_HIOS		ProgType	= 0x6fffffff;	/* Last OS-specific. */
-	PT_LOPROC	ProgType	= 0x70000000;	/* First processor-specific type. */
-	PT_HIPROC	ProgType	= 0x7fffffff;	/* Last processor-specific type. */
+	PT_NULL    ProgType = 0          /* Unused entry. */
+	PT_LOAD    ProgType = 1          /* Loadable segment. */
+	PT_DYNAMIC ProgType = 2          /* Dynamic linking information segment. */
+	PT_INTERP  ProgType = 3          /* Pathname of interpreter. */
+	PT_NOTE    ProgType = 4          /* Auxiliary information. */
+	PT_SHLIB   ProgType = 5          /* Reserved (not used). */
+	PT_PHDR    ProgType = 6          /* Location of program header itself. */
+	PT_TLS     ProgType = 7          /* Thread local storage segment */
+	PT_LOOS    ProgType = 0x60000000 /* First OS-specific. */
+	PT_HIOS    ProgType = 0x6fffffff /* Last OS-specific. */
+	PT_LOPROC  ProgType = 0x70000000 /* First processor-specific type. */
+	PT_HIPROC  ProgType = 0x7fffffff /* Last processor-specific type. */
 )
 
 var ptStrings = []intName{
@@ -451,18 +451,18 @@ var ptStrings = []intName{
 	intName{0x7fffffff, "PT_HIPROC"},
 }
 
-func (i ProgType) String() string	{ return stringName(uint32(i), ptStrings, false) }
-func (i ProgType) GoString() string	{ return stringName(uint32(i), ptStrings, true) }
+func (i ProgType) String() string   { return stringName(uint32(i), ptStrings, false) }
+func (i ProgType) GoString() string { return stringName(uint32(i), ptStrings, true) }
 
 // Prog.Flag
 type ProgFlag uint32
 
 const (
-	PF_X		ProgFlag	= 0x1;		/* Executable. */
-	PF_W		ProgFlag	= 0x2;		/* Writable. */
-	PF_R		ProgFlag	= 0x4;		/* Readable. */
-	PF_MASKOS	ProgFlag	= 0x0ff00000;	/* Operating system-specific. */
-	PF_MASKPROC	ProgFlag	= 0xf0000000;	/* Processor-specific. */
+	PF_X        ProgFlag = 0x1        /* Executable. */
+	PF_W        ProgFlag = 0x2        /* Writable. */
+	PF_R        ProgFlag = 0x4        /* Readable. */
+	PF_MASKOS   ProgFlag = 0x0ff00000 /* Operating system-specific. */
+	PF_MASKPROC ProgFlag = 0xf0000000 /* Processor-specific. */
 )
 
 var pfStrings = []intName{
@@ -471,55 +471,55 @@ var pfStrings = []intName{
 	intName{0x4, "PF_R"},
 }
 
-func (i ProgFlag) String() string	{ return flagName(uint32(i), pfStrings, false) }
-func (i ProgFlag) GoString() string	{ return flagName(uint32(i), pfStrings, true) }
+func (i ProgFlag) String() string   { return flagName(uint32(i), pfStrings, false) }
+func (i ProgFlag) GoString() string { return flagName(uint32(i), pfStrings, true) }
 
 // Dyn.Tag
 type DynTag int
 
 const (
-	DT_NULL		DynTag	= 0;	/* Terminating entry. */
-	DT_NEEDED	DynTag	= 1;	/* String table offset of a needed shared library. */
-	DT_PLTRELSZ	DynTag	= 2;	/* Total size in bytes of PLT relocations. */
-	DT_PLTGOT	DynTag	= 3;	/* Processor-dependent address. */
-	DT_HASH		DynTag	= 4;	/* Address of symbol hash table. */
-	DT_STRTAB	DynTag	= 5;	/* Address of string table. */
-	DT_SYMTAB	DynTag	= 6;	/* Address of symbol table. */
-	DT_RELA		DynTag	= 7;	/* Address of ElfNN_Rela relocations. */
-	DT_RELASZ	DynTag	= 8;	/* Total size of ElfNN_Rela relocations. */
-	DT_RELAENT	DynTag	= 9;	/* Size of each ElfNN_Rela relocation entry. */
-	DT_STRSZ	DynTag	= 10;	/* Size of string table. */
-	DT_SYMENT	DynTag	= 11;	/* Size of each symbol table entry. */
-	DT_INIT		DynTag	= 12;	/* Address of initialization function. */
-	DT_FINI		DynTag	= 13;	/* Address of finalization function. */
-	DT_SONAME	DynTag	= 14;	/* String table offset of shared object name. */
-	DT_RPATH	DynTag	= 15;	/* String table offset of library path. [sup] */
-	DT_SYMBOLIC	DynTag	= 16;	/* Indicates "symbolic" linking. [sup] */
-	DT_REL		DynTag	= 17;	/* Address of ElfNN_Rel relocations. */
-	DT_RELSZ	DynTag	= 18;	/* Total size of ElfNN_Rel relocations. */
-	DT_RELENT	DynTag	= 19;	/* Size of each ElfNN_Rel relocation. */
-	DT_PLTREL	DynTag	= 20;	/* Type of relocation used for PLT. */
-	DT_DEBUG	DynTag	= 21;	/* Reserved (not used). */
-	DT_TEXTREL	DynTag	= 22;	/* Indicates there may be relocations in non-writable segments. [sup] */
-	DT_JMPREL	DynTag	= 23;	/* Address of PLT relocations. */
-	DT_BIND_NOW	DynTag	= 24;	/* [sup] */
-	DT_INIT_ARRAY	DynTag	= 25;	/* Address of the array of pointers to initialization functions */
-	DT_FINI_ARRAY	DynTag	= 26;	/* Address of the array of pointers to termination functions */
-	DT_INIT_ARRAYSZ	DynTag	= 27;	/* Size in bytes of the array of initialization functions. */
-	DT_FINI_ARRAYSZ	DynTag	= 28;	/* Size in bytes of the array of terminationfunctions. */
-	DT_RUNPATH	DynTag	= 29;	/* String table offset of a null-terminated library search path string. */
-	DT_FLAGS	DynTag	= 30;	/* Object specific flag values. */
-	DT_ENCODING	DynTag	= 32;	/* Values greater than or equal to DT_ENCODING
+	DT_NULL         DynTag = 0  /* Terminating entry. */
+	DT_NEEDED       DynTag = 1  /* String table offset of a needed shared library. */
+	DT_PLTRELSZ     DynTag = 2  /* Total size in bytes of PLT relocations. */
+	DT_PLTGOT       DynTag = 3  /* Processor-dependent address. */
+	DT_HASH         DynTag = 4  /* Address of symbol hash table. */
+	DT_STRTAB       DynTag = 5  /* Address of string table. */
+	DT_SYMTAB       DynTag = 6  /* Address of symbol table. */
+	DT_RELA         DynTag = 7  /* Address of ElfNN_Rela relocations. */
+	DT_RELASZ       DynTag = 8  /* Total size of ElfNN_Rela relocations. */
+	DT_RELAENT      DynTag = 9  /* Size of each ElfNN_Rela relocation entry. */
+	DT_STRSZ        DynTag = 10 /* Size of string table. */
+	DT_SYMENT       DynTag = 11 /* Size of each symbol table entry. */
+	DT_INIT         DynTag = 12 /* Address of initialization function. */
+	DT_FINI         DynTag = 13 /* Address of finalization function. */
+	DT_SONAME       DynTag = 14 /* String table offset of shared object name. */
+	DT_RPATH        DynTag = 15 /* String table offset of library path. [sup] */
+	DT_SYMBOLIC     DynTag = 16 /* Indicates "symbolic" linking. [sup] */
+	DT_REL          DynTag = 17 /* Address of ElfNN_Rel relocations. */
+	DT_RELSZ        DynTag = 18 /* Total size of ElfNN_Rel relocations. */
+	DT_RELENT       DynTag = 19 /* Size of each ElfNN_Rel relocation. */
+	DT_PLTREL       DynTag = 20 /* Type of relocation used for PLT. */
+	DT_DEBUG        DynTag = 21 /* Reserved (not used). */
+	DT_TEXTREL      DynTag = 22 /* Indicates there may be relocations in non-writable segments. [sup] */
+	DT_JMPREL       DynTag = 23 /* Address of PLT relocations. */
+	DT_BIND_NOW     DynTag = 24 /* [sup] */
+	DT_INIT_ARRAY   DynTag = 25 /* Address of the array of pointers to initialization functions */
+	DT_FINI_ARRAY   DynTag = 26 /* Address of the array of pointers to termination functions */
+	DT_INIT_ARRAYSZ DynTag = 27 /* Size in bytes of the array of initialization functions. */
+	DT_FINI_ARRAYSZ DynTag = 28 /* Size in bytes of the array of terminationfunctions. */
+	DT_RUNPATH      DynTag = 29 /* String table offset of a null-terminated library search path string. */
+	DT_FLAGS        DynTag = 30 /* Object specific flag values. */
+	DT_ENCODING     DynTag = 32 /* Values greater than or equal to DT_ENCODING
 	   and less than DT_LOOS follow the rules for
 	   the interpretation of the d_un union
 	   as follows: even == 'd_ptr', even == 'd_val'
 	   or none */
-	DT_PREINIT_ARRAY	DynTag	= 32;		/* Address of the array of pointers to pre-initialization functions. */
-	DT_PREINIT_ARRAYSZ	DynTag	= 33;		/* Size in bytes of the array of pre-initialization functions. */
-	DT_LOOS			DynTag	= 0x6000000d;	/* First OS-specific */
-	DT_HIOS			DynTag	= 0x6ffff000;	/* Last OS-specific */
-	DT_LOPROC		DynTag	= 0x70000000;	/* First processor-specific type. */
-	DT_HIPROC		DynTag	= 0x7fffffff;	/* Last processor-specific type. */
+	DT_PREINIT_ARRAY   DynTag = 32         /* Address of the array of pointers to pre-initialization functions. */
+	DT_PREINIT_ARRAYSZ DynTag = 33         /* Size in bytes of the array of pre-initialization functions. */
+	DT_LOOS            DynTag = 0x6000000d /* First OS-specific */
+	DT_HIOS            DynTag = 0x6ffff000 /* Last OS-specific */
+	DT_LOPROC          DynTag = 0x70000000 /* First processor-specific type. */
+	DT_HIPROC          DynTag = 0x7fffffff /* Last processor-specific type. */
 )
 
 var dtStrings = []intName{
@@ -563,23 +563,23 @@ var dtStrings = []intName{
 	intName{0x7fffffff, "DT_HIPROC"},
 }
 
-func (i DynTag) String() string		{ return stringName(uint32(i), dtStrings, false) }
-func (i DynTag) GoString() string	{ return stringName(uint32(i), dtStrings, true) }
+func (i DynTag) String() string   { return stringName(uint32(i), dtStrings, false) }
+func (i DynTag) GoString() string { return stringName(uint32(i), dtStrings, true) }
 
 // DT_FLAGS values.
 type DynFlag int
 
 const (
-	DF_ORIGIN	DynFlag	= 0x0001;	/* Indicates that the object being loaded may
+	DF_ORIGIN DynFlag = 0x0001 /* Indicates that the object being loaded may
 	   make reference to the
 	   $ORIGIN substitution string */
-	DF_SYMBOLIC	DynFlag	= 0x0002;	/* Indicates "symbolic" linking. */
-	DF_TEXTREL	DynFlag	= 0x0004;	/* Indicates there may be relocations in non-writable segments. */
-	DF_BIND_NOW	DynFlag	= 0x0008;	/* Indicates that the dynamic linker should
+	DF_SYMBOLIC DynFlag = 0x0002 /* Indicates "symbolic" linking. */
+	DF_TEXTREL  DynFlag = 0x0004 /* Indicates there may be relocations in non-writable segments. */
+	DF_BIND_NOW DynFlag = 0x0008 /* Indicates that the dynamic linker should
 	   process all relocations for the object
 	   containing this entry before transferring
 	   control to the program. */
-	DF_STATIC_TLS	DynFlag	= 0x0010;	/* Indicates that the shared object or
+	DF_STATIC_TLS DynFlag = 0x0010 /* Indicates that the shared object or
 	   executable contains code using a static
 	   thread-local storage scheme. */
 )
@@ -592,16 +592,16 @@ var dflagStrings = []intName{
 	intName{0x0010, "DF_STATIC_TLS"},
 }
 
-func (i DynFlag) String() string	{ return flagName(uint32(i), dflagStrings, false) }
-func (i DynFlag) GoString() string	{ return flagName(uint32(i), dflagStrings, true) }
+func (i DynFlag) String() string   { return flagName(uint32(i), dflagStrings, false) }
+func (i DynFlag) GoString() string { return flagName(uint32(i), dflagStrings, true) }
 
 // NType values; used in core files.
 type NType int
 
 const (
-	NT_PRSTATUS	NType	= 1;	/* Process status. */
-	NT_FPREGSET	NType	= 2;	/* Floating point registers. */
-	NT_PRPSINFO	NType	= 3;	/* Process state info. */
+	NT_PRSTATUS NType = 1 /* Process status. */
+	NT_FPREGSET NType = 2 /* Floating point registers. */
+	NT_PRPSINFO NType = 3 /* Process state info. */
 )
 
 var ntypeStrings = []intName{
@@ -610,20 +610,20 @@ var ntypeStrings = []intName{
 	intName{3, "NT_PRPSINFO"},
 }
 
-func (i NType) String() string		{ return stringName(uint32(i), ntypeStrings, false) }
-func (i NType) GoString() string	{ return stringName(uint32(i), ntypeStrings, true) }
+func (i NType) String() string   { return stringName(uint32(i), ntypeStrings, false) }
+func (i NType) GoString() string { return stringName(uint32(i), ntypeStrings, true) }
 
 /* Symbol Binding - ELFNN_ST_BIND - st_info */
 type SymBind int
 
 const (
-	STB_LOCAL	SymBind	= 0;	/* Local symbol */
-	STB_GLOBAL	SymBind	= 1;	/* Global symbol */
-	STB_WEAK	SymBind	= 2;	/* like global - lower precedence */
-	STB_LOOS	SymBind	= 10;	/* Reserved range for operating system */
-	STB_HIOS	SymBind	= 12;	/*   specific semantics. */
-	STB_LOPROC	SymBind	= 13;	/* reserved range for processor */
-	STB_HIPROC	SymBind	= 15;	/*   specific semantics. */
+	STB_LOCAL  SymBind = 0  /* Local symbol */
+	STB_GLOBAL SymBind = 1  /* Global symbol */
+	STB_WEAK   SymBind = 2  /* like global - lower precedence */
+	STB_LOOS   SymBind = 10 /* Reserved range for operating system */
+	STB_HIOS   SymBind = 12 /*   specific semantics. */
+	STB_LOPROC SymBind = 13 /* reserved range for processor */
+	STB_HIPROC SymBind = 15 /*   specific semantics. */
 )
 
 var stbStrings = []intName{
@@ -636,24 +636,24 @@ var stbStrings = []intName{
 	intName{15, "STB_HIPROC"},
 }
 
-func (i SymBind) String() string	{ return stringName(uint32(i), stbStrings, false) }
-func (i SymBind) GoString() string	{ return stringName(uint32(i), stbStrings, true) }
+func (i SymBind) String() string   { return stringName(uint32(i), stbStrings, false) }
+func (i SymBind) GoString() string { return stringName(uint32(i), stbStrings, true) }
 
 /* Symbol type - ELFNN_ST_TYPE - st_info */
 type SymType int
 
 const (
-	STT_NOTYPE	SymType	= 0;	/* Unspecified type. */
-	STT_OBJECT	SymType	= 1;	/* Data object. */
-	STT_FUNC	SymType	= 2;	/* Function. */
-	STT_SECTION	SymType	= 3;	/* Section. */
-	STT_FILE	SymType	= 4;	/* Source file. */
-	STT_COMMON	SymType	= 5;	/* Uninitialized common block. */
-	STT_TLS		SymType	= 6;	/* TLS object. */
-	STT_LOOS	SymType	= 10;	/* Reserved range for operating system */
-	STT_HIOS	SymType	= 12;	/*   specific semantics. */
-	STT_LOPROC	SymType	= 13;	/* reserved range for processor */
-	STT_HIPROC	SymType	= 15;	/*   specific semantics. */
+	STT_NOTYPE  SymType = 0  /* Unspecified type. */
+	STT_OBJECT  SymType = 1  /* Data object. */
+	STT_FUNC    SymType = 2  /* Function. */
+	STT_SECTION SymType = 3  /* Section. */
+	STT_FILE    SymType = 4  /* Source file. */
+	STT_COMMON  SymType = 5  /* Uninitialized common block. */
+	STT_TLS     SymType = 6  /* TLS object. */
+	STT_LOOS    SymType = 10 /* Reserved range for operating system */
+	STT_HIOS    SymType = 12 /*   specific semantics. */
+	STT_LOPROC  SymType = 13 /* reserved range for processor */
+	STT_HIPROC  SymType = 15 /*   specific semantics. */
 )
 
 var sttStrings = []intName{
@@ -670,17 +670,17 @@ var sttStrings = []intName{
 	intName{15, "STT_HIPROC"},
 }
 
-func (i SymType) String() string	{ return stringName(uint32(i), sttStrings, false) }
-func (i SymType) GoString() string	{ return stringName(uint32(i), sttStrings, true) }
+func (i SymType) String() string   { return stringName(uint32(i), sttStrings, false) }
+func (i SymType) GoString() string { return stringName(uint32(i), sttStrings, true) }
 
 /* Symbol visibility - ELFNN_ST_VISIBILITY - st_other */
 type SymVis int
 
 const (
-	STV_DEFAULT	SymVis	= 0x0;	/* Default visibility (see binding). */
-	STV_INTERNAL	SymVis	= 0x1;	/* Special meaning in relocatable objects. */
-	STV_HIDDEN	SymVis	= 0x2;	/* Not visible. */
-	STV_PROTECTED	SymVis	= 0x3;	/* Visible but not preemptible. */
+	STV_DEFAULT   SymVis = 0x0 /* Default visibility (see binding). */
+	STV_INTERNAL  SymVis = 0x1 /* Special meaning in relocatable objects. */
+	STV_HIDDEN    SymVis = 0x2 /* Not visible. */
+	STV_PROTECTED SymVis = 0x3 /* Visible but not preemptible. */
 )
 
 var stvStrings = []intName{
@@ -690,8 +690,8 @@ var stvStrings = []intName{
 	intName{0x3, "STV_PROTECTED"},
 }
 
-func (i SymVis) String() string		{ return stringName(uint32(i), stvStrings, false) }
-func (i SymVis) GoString() string	{ return stringName(uint32(i), stvStrings, true) }
+func (i SymVis) String() string   { return stringName(uint32(i), stvStrings, false) }
+func (i SymVis) GoString() string { return stringName(uint32(i), stvStrings, true) }
 
 /*
  * Relocation types.
@@ -701,30 +701,30 @@ func (i SymVis) GoString() string	{ return stringName(uint32(i), stvStrings, tru
 type R_X86_64 int
 
 const (
-	R_X86_64_NONE		R_X86_64	= 0;	/* No relocation. */
-	R_X86_64_64		R_X86_64	= 1;	/* Add 64 bit symbol value. */
-	R_X86_64_PC32		R_X86_64	= 2;	/* PC-relative 32 bit signed sym value. */
-	R_X86_64_GOT32		R_X86_64	= 3;	/* PC-relative 32 bit GOT offset. */
-	R_X86_64_PLT32		R_X86_64	= 4;	/* PC-relative 32 bit PLT offset. */
-	R_X86_64_COPY		R_X86_64	= 5;	/* Copy data from shared object. */
-	R_X86_64_GLOB_DAT	R_X86_64	= 6;	/* Set GOT entry to data address. */
-	R_X86_64_JMP_SLOT	R_X86_64	= 7;	/* Set GOT entry to code address. */
-	R_X86_64_RELATIVE	R_X86_64	= 8;	/* Add load address of shared object. */
-	R_X86_64_GOTPCREL	R_X86_64	= 9;	/* Add 32 bit signed pcrel offset to GOT. */
-	R_X86_64_32		R_X86_64	= 10;	/* Add 32 bit zero extended symbol value */
-	R_X86_64_32S		R_X86_64	= 11;	/* Add 32 bit sign extended symbol value */
-	R_X86_64_16		R_X86_64	= 12;	/* Add 16 bit zero extended symbol value */
-	R_X86_64_PC16		R_X86_64	= 13;	/* Add 16 bit signed extended pc relative symbol value */
-	R_X86_64_8		R_X86_64	= 14;	/* Add 8 bit zero extended symbol value */
-	R_X86_64_PC8		R_X86_64	= 15;	/* Add 8 bit signed extended pc relative symbol value */
-	R_X86_64_DTPMOD64	R_X86_64	= 16;	/* ID of module containing symbol */
-	R_X86_64_DTPOFF64	R_X86_64	= 17;	/* Offset in TLS block */
-	R_X86_64_TPOFF64	R_X86_64	= 18;	/* Offset in static TLS block */
-	R_X86_64_TLSGD		R_X86_64	= 19;	/* PC relative offset to GD GOT entry */
-	R_X86_64_TLSLD		R_X86_64	= 20;	/* PC relative offset to LD GOT entry */
-	R_X86_64_DTPOFF32	R_X86_64	= 21;	/* Offset in TLS block */
-	R_X86_64_GOTTPOFF	R_X86_64	= 22;	/* PC relative offset to IE GOT entry */
-	R_X86_64_TPOFF32	R_X86_64	= 23;	/* Offset in static TLS block */
+	R_X86_64_NONE     R_X86_64 = 0  /* No relocation. */
+	R_X86_64_64       R_X86_64 = 1  /* Add 64 bit symbol value. */
+	R_X86_64_PC32     R_X86_64 = 2  /* PC-relative 32 bit signed sym value. */
+	R_X86_64_GOT32    R_X86_64 = 3  /* PC-relative 32 bit GOT offset. */
+	R_X86_64_PLT32    R_X86_64 = 4  /* PC-relative 32 bit PLT offset. */
+	R_X86_64_COPY     R_X86_64 = 5  /* Copy data from shared object. */
+	R_X86_64_GLOB_DAT R_X86_64 = 6  /* Set GOT entry to data address. */
+	R_X86_64_JMP_SLOT R_X86_64 = 7  /* Set GOT entry to code address. */
+	R_X86_64_RELATIVE R_X86_64 = 8  /* Add load address of shared object. */
+	R_X86_64_GOTPCREL R_X86_64 = 9  /* Add 32 bit signed pcrel offset to GOT. */
+	R_X86_64_32       R_X86_64 = 10 /* Add 32 bit zero extended symbol value */
+	R_X86_64_32S      R_X86_64 = 11 /* Add 32 bit sign extended symbol value */
+	R_X86_64_16       R_X86_64 = 12 /* Add 16 bit zero extended symbol value */
+	R_X86_64_PC16     R_X86_64 = 13 /* Add 16 bit signed extended pc relative symbol value */
+	R_X86_64_8        R_X86_64 = 14 /* Add 8 bit zero extended symbol value */
+	R_X86_64_PC8      R_X86_64 = 15 /* Add 8 bit signed extended pc relative symbol value */
+	R_X86_64_DTPMOD64 R_X86_64 = 16 /* ID of module containing symbol */
+	R_X86_64_DTPOFF64 R_X86_64 = 17 /* Offset in TLS block */
+	R_X86_64_TPOFF64  R_X86_64 = 18 /* Offset in static TLS block */
+	R_X86_64_TLSGD    R_X86_64 = 19 /* PC relative offset to GD GOT entry */
+	R_X86_64_TLSLD    R_X86_64 = 20 /* PC relative offset to LD GOT entry */
+	R_X86_64_DTPOFF32 R_X86_64 = 21 /* Offset in TLS block */
+	R_X86_64_GOTTPOFF R_X86_64 = 22 /* PC relative offset to IE GOT entry */
+	R_X86_64_TPOFF32  R_X86_64 = 23 /* Offset in static TLS block */
 )
 
 var rx86_64Strings = []intName{
@@ -754,41 +754,41 @@ var rx86_64Strings = []intName{
 	intName{23, "R_X86_64_TPOFF32"},
 }
 
-func (i R_X86_64) String() string	{ return stringName(uint32(i), rx86_64Strings, false) }
-func (i R_X86_64) GoString() string	{ return stringName(uint32(i), rx86_64Strings, true) }
+func (i R_X86_64) String() string   { return stringName(uint32(i), rx86_64Strings, false) }
+func (i R_X86_64) GoString() string { return stringName(uint32(i), rx86_64Strings, true) }
 
 // Relocation types for Alpha.
 type R_ALPHA int
 
 const (
-	R_ALPHA_NONE		R_ALPHA	= 0;	/* No reloc */
-	R_ALPHA_REFLONG		R_ALPHA	= 1;	/* Direct 32 bit */
-	R_ALPHA_REFQUAD		R_ALPHA	= 2;	/* Direct 64 bit */
-	R_ALPHA_GPREL32		R_ALPHA	= 3;	/* GP relative 32 bit */
-	R_ALPHA_LITERAL		R_ALPHA	= 4;	/* GP relative 16 bit w/optimization */
-	R_ALPHA_LITUSE		R_ALPHA	= 5;	/* Optimization hint for LITERAL */
-	R_ALPHA_GPDISP		R_ALPHA	= 6;	/* Add displacement to GP */
-	R_ALPHA_BRADDR		R_ALPHA	= 7;	/* PC+4 relative 23 bit shifted */
-	R_ALPHA_HINT		R_ALPHA	= 8;	/* PC+4 relative 16 bit shifted */
-	R_ALPHA_SREL16		R_ALPHA	= 9;	/* PC relative 16 bit */
-	R_ALPHA_SREL32		R_ALPHA	= 10;	/* PC relative 32 bit */
-	R_ALPHA_SREL64		R_ALPHA	= 11;	/* PC relative 64 bit */
-	R_ALPHA_OP_PUSH		R_ALPHA	= 12;	/* OP stack push */
-	R_ALPHA_OP_STORE	R_ALPHA	= 13;	/* OP stack pop and store */
-	R_ALPHA_OP_PSUB		R_ALPHA	= 14;	/* OP stack subtract */
-	R_ALPHA_OP_PRSHIFT	R_ALPHA	= 15;	/* OP stack right shift */
-	R_ALPHA_GPVALUE		R_ALPHA	= 16;
-	R_ALPHA_GPRELHIGH	R_ALPHA	= 17;
-	R_ALPHA_GPRELLOW	R_ALPHA	= 18;
-	R_ALPHA_IMMED_GP_16	R_ALPHA	= 19;
-	R_ALPHA_IMMED_GP_HI32	R_ALPHA	= 20;
-	R_ALPHA_IMMED_SCN_HI32	R_ALPHA	= 21;
-	R_ALPHA_IMMED_BR_HI32	R_ALPHA	= 22;
-	R_ALPHA_IMMED_LO32	R_ALPHA	= 23;
-	R_ALPHA_COPY		R_ALPHA	= 24;	/* Copy symbol at runtime */
-	R_ALPHA_GLOB_DAT	R_ALPHA	= 25;	/* Create GOT entry */
-	R_ALPHA_JMP_SLOT	R_ALPHA	= 26;	/* Create PLT entry */
-	R_ALPHA_RELATIVE	R_ALPHA	= 27;	/* Adjust by program base */
+	R_ALPHA_NONE           R_ALPHA = 0  /* No reloc */
+	R_ALPHA_REFLONG        R_ALPHA = 1  /* Direct 32 bit */
+	R_ALPHA_REFQUAD        R_ALPHA = 2  /* Direct 64 bit */
+	R_ALPHA_GPREL32        R_ALPHA = 3  /* GP relative 32 bit */
+	R_ALPHA_LITERAL        R_ALPHA = 4  /* GP relative 16 bit w/optimization */
+	R_ALPHA_LITUSE         R_ALPHA = 5  /* Optimization hint for LITERAL */
+	R_ALPHA_GPDISP         R_ALPHA = 6  /* Add displacement to GP */
+	R_ALPHA_BRADDR         R_ALPHA = 7  /* PC+4 relative 23 bit shifted */
+	R_ALPHA_HINT           R_ALPHA = 8  /* PC+4 relative 16 bit shifted */
+	R_ALPHA_SREL16         R_ALPHA = 9  /* PC relative 16 bit */
+	R_ALPHA_SREL32         R_ALPHA = 10 /* PC relative 32 bit */
+	R_ALPHA_SREL64         R_ALPHA = 11 /* PC relative 64 bit */
+	R_ALPHA_OP_PUSH        R_ALPHA = 12 /* OP stack push */
+	R_ALPHA_OP_STORE       R_ALPHA = 13 /* OP stack pop and store */
+	R_ALPHA_OP_PSUB        R_ALPHA = 14 /* OP stack subtract */
+	R_ALPHA_OP_PRSHIFT     R_ALPHA = 15 /* OP stack right shift */
+	R_ALPHA_GPVALUE        R_ALPHA = 16
+	R_ALPHA_GPRELHIGH      R_ALPHA = 17
+	R_ALPHA_GPRELLOW       R_ALPHA = 18
+	R_ALPHA_IMMED_GP_16    R_ALPHA = 19
+	R_ALPHA_IMMED_GP_HI32  R_ALPHA = 20
+	R_ALPHA_IMMED_SCN_HI32 R_ALPHA = 21
+	R_ALPHA_IMMED_BR_HI32  R_ALPHA = 22
+	R_ALPHA_IMMED_LO32     R_ALPHA = 23
+	R_ALPHA_COPY           R_ALPHA = 24 /* Copy symbol at runtime */
+	R_ALPHA_GLOB_DAT       R_ALPHA = 25 /* Create GOT entry */
+	R_ALPHA_JMP_SLOT       R_ALPHA = 26 /* Create PLT entry */
+	R_ALPHA_RELATIVE       R_ALPHA = 27 /* Adjust by program base */
 )
 
 var ralphaStrings = []intName{
@@ -822,46 +822,46 @@ var ralphaStrings = []intName{
 	intName{27, "R_ALPHA_RELATIVE"},
 }
 
-func (i R_ALPHA) String() string	{ return stringName(uint32(i), ralphaStrings, false) }
-func (i R_ALPHA) GoString() string	{ return stringName(uint32(i), ralphaStrings, true) }
+func (i R_ALPHA) String() string   { return stringName(uint32(i), ralphaStrings, false) }
+func (i R_ALPHA) GoString() string { return stringName(uint32(i), ralphaStrings, true) }
 
 // Relocation types for ARM.
 type R_ARM int
 
 const (
-	R_ARM_NONE		R_ARM	= 0;	/* No relocation. */
-	R_ARM_PC24		R_ARM	= 1;
-	R_ARM_ABS32		R_ARM	= 2;
-	R_ARM_REL32		R_ARM	= 3;
-	R_ARM_PC13		R_ARM	= 4;
-	R_ARM_ABS16		R_ARM	= 5;
-	R_ARM_ABS12		R_ARM	= 6;
-	R_ARM_THM_ABS5		R_ARM	= 7;
-	R_ARM_ABS8		R_ARM	= 8;
-	R_ARM_SBREL32		R_ARM	= 9;
-	R_ARM_THM_PC22		R_ARM	= 10;
-	R_ARM_THM_PC8		R_ARM	= 11;
-	R_ARM_AMP_VCALL9	R_ARM	= 12;
-	R_ARM_SWI24		R_ARM	= 13;
-	R_ARM_THM_SWI8		R_ARM	= 14;
-	R_ARM_XPC25		R_ARM	= 15;
-	R_ARM_THM_XPC22		R_ARM	= 16;
-	R_ARM_COPY		R_ARM	= 20;	/* Copy data from shared object. */
-	R_ARM_GLOB_DAT		R_ARM	= 21;	/* Set GOT entry to data address. */
-	R_ARM_JUMP_SLOT		R_ARM	= 22;	/* Set GOT entry to code address. */
-	R_ARM_RELATIVE		R_ARM	= 23;	/* Add load address of shared object. */
-	R_ARM_GOTOFF		R_ARM	= 24;	/* Add GOT-relative symbol address. */
-	R_ARM_GOTPC		R_ARM	= 25;	/* Add PC-relative GOT table address. */
-	R_ARM_GOT32		R_ARM	= 26;	/* Add PC-relative GOT offset. */
-	R_ARM_PLT32		R_ARM	= 27;	/* Add PC-relative PLT offset. */
-	R_ARM_GNU_VTENTRY	R_ARM	= 100;
-	R_ARM_GNU_VTINHERIT	R_ARM	= 101;
-	R_ARM_RSBREL32		R_ARM	= 250;
-	R_ARM_THM_RPC22		R_ARM	= 251;
-	R_ARM_RREL32		R_ARM	= 252;
-	R_ARM_RABS32		R_ARM	= 253;
-	R_ARM_RPC24		R_ARM	= 254;
-	R_ARM_RBASE		R_ARM	= 255;
+	R_ARM_NONE          R_ARM = 0 /* No relocation. */
+	R_ARM_PC24          R_ARM = 1
+	R_ARM_ABS32         R_ARM = 2
+	R_ARM_REL32         R_ARM = 3
+	R_ARM_PC13          R_ARM = 4
+	R_ARM_ABS16         R_ARM = 5
+	R_ARM_ABS12         R_ARM = 6
+	R_ARM_THM_ABS5      R_ARM = 7
+	R_ARM_ABS8          R_ARM = 8
+	R_ARM_SBREL32       R_ARM = 9
+	R_ARM_THM_PC22      R_ARM = 10
+	R_ARM_THM_PC8       R_ARM = 11
+	R_ARM_AMP_VCALL9    R_ARM = 12
+	R_ARM_SWI24         R_ARM = 13
+	R_ARM_THM_SWI8      R_ARM = 14
+	R_ARM_XPC25         R_ARM = 15
+	R_ARM_THM_XPC22     R_ARM = 16
+	R_ARM_COPY          R_ARM = 20 /* Copy data from shared object. */
+	R_ARM_GLOB_DAT      R_ARM = 21 /* Set GOT entry to data address. */
+	R_ARM_JUMP_SLOT     R_ARM = 22 /* Set GOT entry to code address. */
+	R_ARM_RELATIVE      R_ARM = 23 /* Add load address of shared object. */
+	R_ARM_GOTOFF        R_ARM = 24 /* Add GOT-relative symbol address. */
+	R_ARM_GOTPC         R_ARM = 25 /* Add PC-relative GOT table address. */
+	R_ARM_GOT32         R_ARM = 26 /* Add PC-relative GOT offset. */
+	R_ARM_PLT32         R_ARM = 27 /* Add PC-relative PLT offset. */
+	R_ARM_GNU_VTENTRY   R_ARM = 100
+	R_ARM_GNU_VTINHERIT R_ARM = 101
+	R_ARM_RSBREL32      R_ARM = 250
+	R_ARM_THM_RPC22     R_ARM = 251
+	R_ARM_RREL32        R_ARM = 252
+	R_ARM_RABS32        R_ARM = 253
+	R_ARM_RPC24         R_ARM = 254
+	R_ARM_RBASE         R_ARM = 255
 )
 
 var rarmStrings = []intName{
@@ -900,44 +900,44 @@ var rarmStrings = []intName{
 	intName{255, "R_ARM_RBASE"},
 }
 
-func (i R_ARM) String() string		{ return stringName(uint32(i), rarmStrings, false) }
-func (i R_ARM) GoString() string	{ return stringName(uint32(i), rarmStrings, true) }
+func (i R_ARM) String() string   { return stringName(uint32(i), rarmStrings, false) }
+func (i R_ARM) GoString() string { return stringName(uint32(i), rarmStrings, true) }
 
 // Relocation types for 386.
 type R_386 int
 
 const (
-	R_386_NONE		R_386	= 0;	/* No relocation. */
-	R_386_32		R_386	= 1;	/* Add symbol value. */
-	R_386_PC32		R_386	= 2;	/* Add PC-relative symbol value. */
-	R_386_GOT32		R_386	= 3;	/* Add PC-relative GOT offset. */
-	R_386_PLT32		R_386	= 4;	/* Add PC-relative PLT offset. */
-	R_386_COPY		R_386	= 5;	/* Copy data from shared object. */
-	R_386_GLOB_DAT		R_386	= 6;	/* Set GOT entry to data address. */
-	R_386_JMP_SLOT		R_386	= 7;	/* Set GOT entry to code address. */
-	R_386_RELATIVE		R_386	= 8;	/* Add load address of shared object. */
-	R_386_GOTOFF		R_386	= 9;	/* Add GOT-relative symbol address. */
-	R_386_GOTPC		R_386	= 10;	/* Add PC-relative GOT table address. */
-	R_386_TLS_TPOFF		R_386	= 14;	/* Negative offset in static TLS block */
-	R_386_TLS_IE		R_386	= 15;	/* Absolute address of GOT for -ve static TLS */
-	R_386_TLS_GOTIE		R_386	= 16;	/* GOT entry for negative static TLS block */
-	R_386_TLS_LE		R_386	= 17;	/* Negative offset relative to static TLS */
-	R_386_TLS_GD		R_386	= 18;	/* 32 bit offset to GOT (index,off) pair */
-	R_386_TLS_LDM		R_386	= 19;	/* 32 bit offset to GOT (index,zero) pair */
-	R_386_TLS_GD_32		R_386	= 24;	/* 32 bit offset to GOT (index,off) pair */
-	R_386_TLS_GD_PUSH	R_386	= 25;	/* pushl instruction for Sun ABI GD sequence */
-	R_386_TLS_GD_CALL	R_386	= 26;	/* call instruction for Sun ABI GD sequence */
-	R_386_TLS_GD_POP	R_386	= 27;	/* popl instruction for Sun ABI GD sequence */
-	R_386_TLS_LDM_32	R_386	= 28;	/* 32 bit offset to GOT (index,zero) pair */
-	R_386_TLS_LDM_PUSH	R_386	= 29;	/* pushl instruction for Sun ABI LD sequence */
-	R_386_TLS_LDM_CALL	R_386	= 30;	/* call instruction for Sun ABI LD sequence */
-	R_386_TLS_LDM_POP	R_386	= 31;	/* popl instruction for Sun ABI LD sequence */
-	R_386_TLS_LDO_32	R_386	= 32;	/* 32 bit offset from start of TLS block */
-	R_386_TLS_IE_32		R_386	= 33;	/* 32 bit offset to GOT static TLS offset entry */
-	R_386_TLS_LE_32		R_386	= 34;	/* 32 bit offset within static TLS block */
-	R_386_TLS_DTPMOD32	R_386	= 35;	/* GOT entry containing TLS index */
-	R_386_TLS_DTPOFF32	R_386	= 36;	/* GOT entry containing TLS offset */
-	R_386_TLS_TPOFF32	R_386	= 37;	/* GOT entry of -ve static TLS offset */
+	R_386_NONE         R_386 = 0  /* No relocation. */
+	R_386_32           R_386 = 1  /* Add symbol value. */
+	R_386_PC32         R_386 = 2  /* Add PC-relative symbol value. */
+	R_386_GOT32        R_386 = 3  /* Add PC-relative GOT offset. */
+	R_386_PLT32        R_386 = 4  /* Add PC-relative PLT offset. */
+	R_386_COPY         R_386 = 5  /* Copy data from shared object. */
+	R_386_GLOB_DAT     R_386 = 6  /* Set GOT entry to data address. */
+	R_386_JMP_SLOT     R_386 = 7  /* Set GOT entry to code address. */
+	R_386_RELATIVE     R_386 = 8  /* Add load address of shared object. */
+	R_386_GOTOFF       R_386 = 9  /* Add GOT-relative symbol address. */
+	R_386_GOTPC        R_386 = 10 /* Add PC-relative GOT table address. */
+	R_386_TLS_TPOFF    R_386 = 14 /* Negative offset in static TLS block */
+	R_386_TLS_IE       R_386 = 15 /* Absolute address of GOT for -ve static TLS */
+	R_386_TLS_GOTIE    R_386 = 16 /* GOT entry for negative static TLS block */
+	R_386_TLS_LE       R_386 = 17 /* Negative offset relative to static TLS */
+	R_386_TLS_GD       R_386 = 18 /* 32 bit offset to GOT (index,off) pair */
+	R_386_TLS_LDM      R_386 = 19 /* 32 bit offset to GOT (index,zero) pair */
+	R_386_TLS_GD_32    R_386 = 24 /* 32 bit offset to GOT (index,off) pair */
+	R_386_TLS_GD_PUSH  R_386 = 25 /* pushl instruction for Sun ABI GD sequence */
+	R_386_TLS_GD_CALL  R_386 = 26 /* call instruction for Sun ABI GD sequence */
+	R_386_TLS_GD_POP   R_386 = 27 /* popl instruction for Sun ABI GD sequence */
+	R_386_TLS_LDM_32   R_386 = 28 /* 32 bit offset to GOT (index,zero) pair */
+	R_386_TLS_LDM_PUSH R_386 = 29 /* pushl instruction for Sun ABI LD sequence */
+	R_386_TLS_LDM_CALL R_386 = 30 /* call instruction for Sun ABI LD sequence */
+	R_386_TLS_LDM_POP  R_386 = 31 /* popl instruction for Sun ABI LD sequence */
+	R_386_TLS_LDO_32   R_386 = 32 /* 32 bit offset from start of TLS block */
+	R_386_TLS_IE_32    R_386 = 33 /* 32 bit offset to GOT static TLS offset entry */
+	R_386_TLS_LE_32    R_386 = 34 /* 32 bit offset within static TLS block */
+	R_386_TLS_DTPMOD32 R_386 = 35 /* GOT entry containing TLS index */
+	R_386_TLS_DTPOFF32 R_386 = 36 /* GOT entry containing TLS offset */
+	R_386_TLS_TPOFF32  R_386 = 37 /* GOT entry of -ve static TLS offset */
 )
 
 var r386Strings = []intName{
@@ -974,90 +974,90 @@ var r386Strings = []intName{
 	intName{37, "R_386_TLS_TPOFF32"},
 }
 
-func (i R_386) String() string		{ return stringName(uint32(i), r386Strings, false) }
-func (i R_386) GoString() string	{ return stringName(uint32(i), r386Strings, true) }
+func (i R_386) String() string   { return stringName(uint32(i), r386Strings, false) }
+func (i R_386) GoString() string { return stringName(uint32(i), r386Strings, true) }
 
 // Relocation types for PowerPC.
 type R_PPC int
 
 const (
-	R_PPC_NONE		R_PPC	= 0;	/* No relocation. */
-	R_PPC_ADDR32		R_PPC	= 1;
-	R_PPC_ADDR24		R_PPC	= 2;
-	R_PPC_ADDR16		R_PPC	= 3;
-	R_PPC_ADDR16_LO		R_PPC	= 4;
-	R_PPC_ADDR16_HI		R_PPC	= 5;
-	R_PPC_ADDR16_HA		R_PPC	= 6;
-	R_PPC_ADDR14		R_PPC	= 7;
-	R_PPC_ADDR14_BRTAKEN	R_PPC	= 8;
-	R_PPC_ADDR14_BRNTAKEN	R_PPC	= 9;
-	R_PPC_REL24		R_PPC	= 10;
-	R_PPC_REL14		R_PPC	= 11;
-	R_PPC_REL14_BRTAKEN	R_PPC	= 12;
-	R_PPC_REL14_BRNTAKEN	R_PPC	= 13;
-	R_PPC_GOT16		R_PPC	= 14;
-	R_PPC_GOT16_LO		R_PPC	= 15;
-	R_PPC_GOT16_HI		R_PPC	= 16;
-	R_PPC_GOT16_HA		R_PPC	= 17;
-	R_PPC_PLTREL24		R_PPC	= 18;
-	R_PPC_COPY		R_PPC	= 19;
-	R_PPC_GLOB_DAT		R_PPC	= 20;
-	R_PPC_JMP_SLOT		R_PPC	= 21;
-	R_PPC_RELATIVE		R_PPC	= 22;
-	R_PPC_LOCAL24PC		R_PPC	= 23;
-	R_PPC_UADDR32		R_PPC	= 24;
-	R_PPC_UADDR16		R_PPC	= 25;
-	R_PPC_REL32		R_PPC	= 26;
-	R_PPC_PLT32		R_PPC	= 27;
-	R_PPC_PLTREL32		R_PPC	= 28;
-	R_PPC_PLT16_LO		R_PPC	= 29;
-	R_PPC_PLT16_HI		R_PPC	= 30;
-	R_PPC_PLT16_HA		R_PPC	= 31;
-	R_PPC_SDAREL16		R_PPC	= 32;
-	R_PPC_SECTOFF		R_PPC	= 33;
-	R_PPC_SECTOFF_LO	R_PPC	= 34;
-	R_PPC_SECTOFF_HI	R_PPC	= 35;
-	R_PPC_SECTOFF_HA	R_PPC	= 36;
-	R_PPC_TLS		R_PPC	= 67;
-	R_PPC_DTPMOD32		R_PPC	= 68;
-	R_PPC_TPREL16		R_PPC	= 69;
-	R_PPC_TPREL16_LO	R_PPC	= 70;
-	R_PPC_TPREL16_HI	R_PPC	= 71;
-	R_PPC_TPREL16_HA	R_PPC	= 72;
-	R_PPC_TPREL32		R_PPC	= 73;
-	R_PPC_DTPREL16		R_PPC	= 74;
-	R_PPC_DTPREL16_LO	R_PPC	= 75;
-	R_PPC_DTPREL16_HI	R_PPC	= 76;
-	R_PPC_DTPREL16_HA	R_PPC	= 77;
-	R_PPC_DTPREL32		R_PPC	= 78;
-	R_PPC_GOT_TLSGD16	R_PPC	= 79;
-	R_PPC_GOT_TLSGD16_LO	R_PPC	= 80;
-	R_PPC_GOT_TLSGD16_HI	R_PPC	= 81;
-	R_PPC_GOT_TLSGD16_HA	R_PPC	= 82;
-	R_PPC_GOT_TLSLD16	R_PPC	= 83;
-	R_PPC_GOT_TLSLD16_LO	R_PPC	= 84;
-	R_PPC_GOT_TLSLD16_HI	R_PPC	= 85;
-	R_PPC_GOT_TLSLD16_HA	R_PPC	= 86;
-	R_PPC_GOT_TPREL16	R_PPC	= 87;
-	R_PPC_GOT_TPREL16_LO	R_PPC	= 88;
-	R_PPC_GOT_TPREL16_HI	R_PPC	= 89;
-	R_PPC_GOT_TPREL16_HA	R_PPC	= 90;
-	R_PPC_EMB_NADDR32	R_PPC	= 101;
-	R_PPC_EMB_NADDR16	R_PPC	= 102;
-	R_PPC_EMB_NADDR16_LO	R_PPC	= 103;
-	R_PPC_EMB_NADDR16_HI	R_PPC	= 104;
-	R_PPC_EMB_NADDR16_HA	R_PPC	= 105;
-	R_PPC_EMB_SDAI16	R_PPC	= 106;
-	R_PPC_EMB_SDA2I16	R_PPC	= 107;
-	R_PPC_EMB_SDA2REL	R_PPC	= 108;
-	R_PPC_EMB_SDA21		R_PPC	= 109;
-	R_PPC_EMB_MRKREF	R_PPC	= 110;
-	R_PPC_EMB_RELSEC16	R_PPC	= 111;
-	R_PPC_EMB_RELST_LO	R_PPC	= 112;
-	R_PPC_EMB_RELST_HI	R_PPC	= 113;
-	R_PPC_EMB_RELST_HA	R_PPC	= 114;
-	R_PPC_EMB_BIT_FLD	R_PPC	= 115;
-	R_PPC_EMB_RELSDA	R_PPC	= 116;
+	R_PPC_NONE            R_PPC = 0 /* No relocation. */
+	R_PPC_ADDR32          R_PPC = 1
+	R_PPC_ADDR24          R_PPC = 2
+	R_PPC_ADDR16          R_PPC = 3
+	R_PPC_ADDR16_LO       R_PPC = 4
+	R_PPC_ADDR16_HI       R_PPC = 5
+	R_PPC_ADDR16_HA       R_PPC = 6
+	R_PPC_ADDR14          R_PPC = 7
+	R_PPC_ADDR14_BRTAKEN  R_PPC = 8
+	R_PPC_ADDR14_BRNTAKEN R_PPC = 9
+	R_PPC_REL24           R_PPC = 10
+	R_PPC_REL14           R_PPC = 11
+	R_PPC_REL14_BRTAKEN   R_PPC = 12
+	R_PPC_REL14_BRNTAKEN  R_PPC = 13
+	R_PPC_GOT16           R_PPC = 14
+	R_PPC_GOT16_LO        R_PPC = 15
+	R_PPC_GOT16_HI        R_PPC = 16
+	R_PPC_GOT16_HA        R_PPC = 17
+	R_PPC_PLTREL24        R_PPC = 18
+	R_PPC_COPY            R_PPC = 19
+	R_PPC_GLOB_DAT        R_PPC = 20
+	R_PPC_JMP_SLOT        R_PPC = 21
+	R_PPC_RELATIVE        R_PPC = 22
+	R_PPC_LOCAL24PC       R_PPC = 23
+	R_PPC_UADDR32         R_PPC = 24
+	R_PPC_UADDR16         R_PPC = 25
+	R_PPC_REL32           R_PPC = 26
+	R_PPC_PLT32           R_PPC = 27
+	R_PPC_PLTREL32        R_PPC = 28
+	R_PPC_PLT16_LO        R_PPC = 29
+	R_PPC_PLT16_HI        R_PPC = 30
+	R_PPC_PLT16_HA        R_PPC = 31
+	R_PPC_SDAREL16        R_PPC = 32
+	R_PPC_SECTOFF         R_PPC = 33
+	R_PPC_SECTOFF_LO      R_PPC = 34
+	R_PPC_SECTOFF_HI      R_PPC = 35
+	R_PPC_SECTOFF_HA      R_PPC = 36
+	R_PPC_TLS             R_PPC = 67
+	R_PPC_DTPMOD32        R_PPC = 68
+	R_PPC_TPREL16         R_PPC = 69
+	R_PPC_TPREL16_LO      R_PPC = 70
+	R_PPC_TPREL16_HI      R_PPC = 71
+	R_PPC_TPREL16_HA      R_PPC = 72
+	R_PPC_TPREL32         R_PPC = 73
+	R_PPC_DTPREL16        R_PPC = 74
+	R_PPC_DTPREL16_LO     R_PPC = 75
+	R_PPC_DTPREL16_HI     R_PPC = 76
+	R_PPC_DTPREL16_HA     R_PPC = 77
+	R_PPC_DTPREL32        R_PPC = 78
+	R_PPC_GOT_TLSGD16     R_PPC = 79
+	R_PPC_GOT_TLSGD16_LO  R_PPC = 80
+	R_PPC_GOT_TLSGD16_HI  R_PPC = 81
+	R_PPC_GOT_TLSGD16_HA  R_PPC = 82
+	R_PPC_GOT_TLSLD16     R_PPC = 83
+	R_PPC_GOT_TLSLD16_LO  R_PPC = 84
+	R_PPC_GOT_TLSLD16_HI  R_PPC = 85
+	R_PPC_GOT_TLSLD16_HA  R_PPC = 86
+	R_PPC_GOT_TPREL16     R_PPC = 87
+	R_PPC_GOT_TPREL16_LO  R_PPC = 88
+	R_PPC_GOT_TPREL16_HI  R_PPC = 89
+	R_PPC_GOT_TPREL16_HA  R_PPC = 90
+	R_PPC_EMB_NADDR32     R_PPC = 101
+	R_PPC_EMB_NADDR16     R_PPC = 102
+	R_PPC_EMB_NADDR16_LO  R_PPC = 103
+	R_PPC_EMB_NADDR16_HI  R_PPC = 104
+	R_PPC_EMB_NADDR16_HA  R_PPC = 105
+	R_PPC_EMB_SDAI16      R_PPC = 106
+	R_PPC_EMB_SDA2I16     R_PPC = 107
+	R_PPC_EMB_SDA2REL     R_PPC = 108
+	R_PPC_EMB_SDA21       R_PPC = 109
+	R_PPC_EMB_MRKREF      R_PPC = 110
+	R_PPC_EMB_RELSEC16    R_PPC = 111
+	R_PPC_EMB_RELST_LO    R_PPC = 112
+	R_PPC_EMB_RELST_HI    R_PPC = 113
+	R_PPC_EMB_RELST_HA    R_PPC = 114
+	R_PPC_EMB_BIT_FLD     R_PPC = 115
+	R_PPC_EMB_RELSDA      R_PPC = 116
 )
 
 var rppcStrings = []intName{
@@ -1142,69 +1142,69 @@ var rppcStrings = []intName{
 	intName{116, "R_PPC_EMB_RELSDA"},
 }
 
-func (i R_PPC) String() string		{ return stringName(uint32(i), rppcStrings, false) }
-func (i R_PPC) GoString() string	{ return stringName(uint32(i), rppcStrings, true) }
+func (i R_PPC) String() string   { return stringName(uint32(i), rppcStrings, false) }
+func (i R_PPC) GoString() string { return stringName(uint32(i), rppcStrings, true) }
 
 // Relocation types for SPARC.
 type R_SPARC int
 
 const (
-	R_SPARC_NONE		R_SPARC	= 0;
-	R_SPARC_8		R_SPARC	= 1;
-	R_SPARC_16		R_SPARC	= 2;
-	R_SPARC_32		R_SPARC	= 3;
-	R_SPARC_DISP8		R_SPARC	= 4;
-	R_SPARC_DISP16		R_SPARC	= 5;
-	R_SPARC_DISP32		R_SPARC	= 6;
-	R_SPARC_WDISP30		R_SPARC	= 7;
-	R_SPARC_WDISP22		R_SPARC	= 8;
-	R_SPARC_HI22		R_SPARC	= 9;
-	R_SPARC_22		R_SPARC	= 10;
-	R_SPARC_13		R_SPARC	= 11;
-	R_SPARC_LO10		R_SPARC	= 12;
-	R_SPARC_GOT10		R_SPARC	= 13;
-	R_SPARC_GOT13		R_SPARC	= 14;
-	R_SPARC_GOT22		R_SPARC	= 15;
-	R_SPARC_PC10		R_SPARC	= 16;
-	R_SPARC_PC22		R_SPARC	= 17;
-	R_SPARC_WPLT30		R_SPARC	= 18;
-	R_SPARC_COPY		R_SPARC	= 19;
-	R_SPARC_GLOB_DAT	R_SPARC	= 20;
-	R_SPARC_JMP_SLOT	R_SPARC	= 21;
-	R_SPARC_RELATIVE	R_SPARC	= 22;
-	R_SPARC_UA32		R_SPARC	= 23;
-	R_SPARC_PLT32		R_SPARC	= 24;
-	R_SPARC_HIPLT22		R_SPARC	= 25;
-	R_SPARC_LOPLT10		R_SPARC	= 26;
-	R_SPARC_PCPLT32		R_SPARC	= 27;
-	R_SPARC_PCPLT22		R_SPARC	= 28;
-	R_SPARC_PCPLT10		R_SPARC	= 29;
-	R_SPARC_10		R_SPARC	= 30;
-	R_SPARC_11		R_SPARC	= 31;
-	R_SPARC_64		R_SPARC	= 32;
-	R_SPARC_OLO10		R_SPARC	= 33;
-	R_SPARC_HH22		R_SPARC	= 34;
-	R_SPARC_HM10		R_SPARC	= 35;
-	R_SPARC_LM22		R_SPARC	= 36;
-	R_SPARC_PC_HH22		R_SPARC	= 37;
-	R_SPARC_PC_HM10		R_SPARC	= 38;
-	R_SPARC_PC_LM22		R_SPARC	= 39;
-	R_SPARC_WDISP16		R_SPARC	= 40;
-	R_SPARC_WDISP19		R_SPARC	= 41;
-	R_SPARC_GLOB_JMP	R_SPARC	= 42;
-	R_SPARC_7		R_SPARC	= 43;
-	R_SPARC_5		R_SPARC	= 44;
-	R_SPARC_6		R_SPARC	= 45;
-	R_SPARC_DISP64		R_SPARC	= 46;
-	R_SPARC_PLT64		R_SPARC	= 47;
-	R_SPARC_HIX22		R_SPARC	= 48;
-	R_SPARC_LOX10		R_SPARC	= 49;
-	R_SPARC_H44		R_SPARC	= 50;
-	R_SPARC_M44		R_SPARC	= 51;
-	R_SPARC_L44		R_SPARC	= 52;
-	R_SPARC_REGISTER	R_SPARC	= 53;
-	R_SPARC_UA64		R_SPARC	= 54;
-	R_SPARC_UA16		R_SPARC	= 55;
+	R_SPARC_NONE     R_SPARC = 0
+	R_SPARC_8        R_SPARC = 1
+	R_SPARC_16       R_SPARC = 2
+	R_SPARC_32       R_SPARC = 3
+	R_SPARC_DISP8    R_SPARC = 4
+	R_SPARC_DISP16   R_SPARC = 5
+	R_SPARC_DISP32   R_SPARC = 6
+	R_SPARC_WDISP30  R_SPARC = 7
+	R_SPARC_WDISP22  R_SPARC = 8
+	R_SPARC_HI22     R_SPARC = 9
+	R_SPARC_22       R_SPARC = 10
+	R_SPARC_13       R_SPARC = 11
+	R_SPARC_LO10     R_SPARC = 12
+	R_SPARC_GOT10    R_SPARC = 13
+	R_SPARC_GOT13    R_SPARC = 14
+	R_SPARC_GOT22    R_SPARC = 15
+	R_SPARC_PC10     R_SPARC = 16
+	R_SPARC_PC22     R_SPARC = 17
+	R_SPARC_WPLT30   R_SPARC = 18
+	R_SPARC_COPY     R_SPARC = 19
+	R_SPARC_GLOB_DAT R_SPARC = 20
+	R_SPARC_JMP_SLOT R_SPARC = 21
+	R_SPARC_RELATIVE R_SPARC = 22
+	R_SPARC_UA32     R_SPARC = 23
+	R_SPARC_PLT32    R_SPARC = 24
+	R_SPARC_HIPLT22  R_SPARC = 25
+	R_SPARC_LOPLT10  R_SPARC = 26
+	R_SPARC_PCPLT32  R_SPARC = 27
+	R_SPARC_PCPLT22  R_SPARC = 28
+	R_SPARC_PCPLT10  R_SPARC = 29
+	R_SPARC_10       R_SPARC = 30
+	R_SPARC_11       R_SPARC = 31
+	R_SPARC_64       R_SPARC = 32
+	R_SPARC_OLO10    R_SPARC = 33
+	R_SPARC_HH22     R_SPARC = 34
+	R_SPARC_HM10     R_SPARC = 35
+	R_SPARC_LM22     R_SPARC = 36
+	R_SPARC_PC_HH22  R_SPARC = 37
+	R_SPARC_PC_HM10  R_SPARC = 38
+	R_SPARC_PC_LM22  R_SPARC = 39
+	R_SPARC_WDISP16  R_SPARC = 40
+	R_SPARC_WDISP19  R_SPARC = 41
+	R_SPARC_GLOB_JMP R_SPARC = 42
+	R_SPARC_7        R_SPARC = 43
+	R_SPARC_5        R_SPARC = 44
+	R_SPARC_6        R_SPARC = 45
+	R_SPARC_DISP64   R_SPARC = 46
+	R_SPARC_PLT64    R_SPARC = 47
+	R_SPARC_HIX22    R_SPARC = 48
+	R_SPARC_LOX10    R_SPARC = 49
+	R_SPARC_H44      R_SPARC = 50
+	R_SPARC_M44      R_SPARC = 51
+	R_SPARC_L44      R_SPARC = 52
+	R_SPARC_REGISTER R_SPARC = 53
+	R_SPARC_UA64     R_SPARC = 54
+	R_SPARC_UA16     R_SPARC = 55
 )
 
 var rsparcStrings = []intName{
@@ -1266,8 +1266,8 @@ var rsparcStrings = []intName{
 	intName{55, "R_SPARC_UA16"},
 }
 
-func (i R_SPARC) String() string	{ return stringName(uint32(i), rsparcStrings, false) }
-func (i R_SPARC) GoString() string	{ return stringName(uint32(i), rsparcStrings, true) }
+func (i R_SPARC) String() string   { return stringName(uint32(i), rsparcStrings, false) }
+func (i R_SPARC) GoString() string { return stringName(uint32(i), rsparcStrings, true) }
 
 /*
  * Magic number for the elf trampoline, chosen wisely to be an immediate
@@ -1280,58 +1280,58 @@ const ARM_MAGIC_TRAMP_NUMBER = 0x5c000003
  * ELF32 File header.
  */
 type Header32 struct {
-	Ident		[EI_NIDENT]byte;	/* File identification. */
-	Type		uint16;			/* File type. */
-	Machine		uint16;			/* Machine architecture. */
-	Version		uint32;			/* ELF format version. */
-	Entry		uint32;			/* Entry point. */
-	Phoff		uint32;			/* Program header file offset. */
-	Shoff		uint32;			/* Section header file offset. */
-	Flags		uint32;			/* Architecture-specific flags. */
-	Ehsize		uint16;			/* Size of ELF header in bytes. */
-	Phentsize	uint16;			/* Size of program header entry. */
-	Phnum		uint16;			/* Number of program header entries. */
-	Shentsize	uint16;			/* Size of section header entry. */
-	Shnum		uint16;			/* Number of section header entries. */
-	Shstrndx	uint16;			/* Section name strings section. */
+	Ident     [EI_NIDENT]byte /* File identification. */
+	Type      uint16          /* File type. */
+	Machine   uint16          /* Machine architecture. */
+	Version   uint32          /* ELF format version. */
+	Entry     uint32          /* Entry point. */
+	Phoff     uint32          /* Program header file offset. */
+	Shoff     uint32          /* Section header file offset. */
+	Flags     uint32          /* Architecture-specific flags. */
+	Ehsize    uint16          /* Size of ELF header in bytes. */
+	Phentsize uint16          /* Size of program header entry. */
+	Phnum     uint16          /* Number of program header entries. */
+	Shentsize uint16          /* Size of section header entry. */
+	Shnum     uint16          /* Number of section header entries. */
+	Shstrndx  uint16          /* Section name strings section. */
 }
 
 /*
  * ELF32 Section header.
  */
 type Section32 struct {
-	Name		uint32;	/* Section name (index into the section header string table). */
-	Type		uint32;	/* Section type. */
-	Flags		uint32;	/* Section flags. */
-	Addr		uint32;	/* Address in memory image. */
-	Off		uint32;	/* Offset in file. */
-	Size		uint32;	/* Size in bytes. */
-	Link		uint32;	/* Index of a related section. */
-	Info		uint32;	/* Depends on section type. */
-	Addralign	uint32;	/* Alignment in bytes. */
-	Entsize		uint32;	/* Size of each entry in section. */
+	Name      uint32 /* Section name (index into the section header string table). */
+	Type      uint32 /* Section type. */
+	Flags     uint32 /* Section flags. */
+	Addr      uint32 /* Address in memory image. */
+	Off       uint32 /* Offset in file. */
+	Size      uint32 /* Size in bytes. */
+	Link      uint32 /* Index of a related section. */
+	Info      uint32 /* Depends on section type. */
+	Addralign uint32 /* Alignment in bytes. */
+	Entsize   uint32 /* Size of each entry in section. */
 }
 
 /*
  * ELF32 Program header.
  */
 type Prog32 struct {
-	Type	uint32;	/* Entry type. */
-	Off	uint32;	/* File offset of contents. */
-	Vaddr	uint32;	/* Virtual address in memory image. */
-	Paddr	uint32;	/* Physical address (not used). */
-	Filesz	uint32;	/* Size of contents in file. */
-	Memsz	uint32;	/* Size of contents in memory. */
-	Flags	uint32;	/* Access permission flags. */
-	Align	uint32;	/* Alignment in memory and file. */
+	Type   uint32 /* Entry type. */
+	Off    uint32 /* File offset of contents. */
+	Vaddr  uint32 /* Virtual address in memory image. */
+	Paddr  uint32 /* Physical address (not used). */
+	Filesz uint32 /* Size of contents in file. */
+	Memsz  uint32 /* Size of contents in memory. */
+	Flags  uint32 /* Access permission flags. */
+	Align  uint32 /* Alignment in memory and file. */
 }
 
 /*
  * ELF32 Dynamic structure.  The ".dynamic" section contains an array of them.
  */
 type Dyn32 struct {
-	Tag	int32;	/* Entry type. */
-	Val	uint32;	/* Integer/Address value. */
+	Tag int32  /* Entry type. */
+	Val uint32 /* Integer/Address value. */
 }
 
 /*
@@ -1340,36 +1340,36 @@ type Dyn32 struct {
 
 // ELF32 Relocations that don't need an addend field.
 type Rel32 struct {
-	Off	uint32;	/* Location to be relocated. */
-	Info	uint32;	/* Relocation type and symbol index. */
+	Off  uint32 /* Location to be relocated. */
+	Info uint32 /* Relocation type and symbol index. */
 }
 
 // ELF32 Relocations that need an addend field.
 type Rela32 struct {
-	Off	uint32;	/* Location to be relocated. */
-	Info	uint32;	/* Relocation type and symbol index. */
-	Addend	int32;	/* Addend. */
+	Off    uint32 /* Location to be relocated. */
+	Info   uint32 /* Relocation type and symbol index. */
+	Addend int32  /* Addend. */
 }
 
-func R_SYM32(info uint32) uint32	{ return uint32(info >> 8) }
-func R_TYPE32(info uint32) uint32	{ return uint32(info & 0xff) }
-func R_INFO32(sym, typ uint32) uint32	{ return sym<<8 | typ }
+func R_SYM32(info uint32) uint32      { return uint32(info >> 8) }
+func R_TYPE32(info uint32) uint32     { return uint32(info & 0xff) }
+func R_INFO32(sym, typ uint32) uint32 { return sym<<8 | typ }
 
 // ELF32 Symbol.
 type Sym32 struct {
-	Name	uint32;
-	Value	uint32;
-	Size	uint32;
-	Info	uint8;
-	Other	uint8;
-	Shndx	uint16;
+	Name  uint32
+	Value uint32
+	Size  uint32
+	Info  uint8
+	Other uint8
+	Shndx uint16
 }
 
 const Sym32Size = 16
 
-func ST_BIND(info uint8) SymBind		{ return SymBind(info >> 4) }
-func ST_TYPE(bind SymBind, typ SymType) uint8	{ return uint8(bind)<<4 | uint8(typ)&0xf }
-func ST_VISIBILITY(other uint8) SymVis		{ return SymVis(other & 3) }
+func ST_BIND(info uint8) SymBind              { return SymBind(info >> 4) }
+func ST_TYPE(bind SymBind, typ SymType) uint8 { return uint8(bind)<<4 | uint8(typ)&0xf }
+func ST_VISIBILITY(other uint8) SymVis        { return SymVis(other & 3) }
 
 /*
  * ELF64
@@ -1380,20 +1380,20 @@ func ST_VISIBILITY(other uint8) SymVis		{ return SymVis(other & 3) }
  */
 
 type Header64 struct {
-	Ident		[EI_NIDENT]byte;	/* File identification. */
-	Type		uint16;			/* File type. */
-	Machine		uint16;			/* Machine architecture. */
-	Version		uint32;			/* ELF format version. */
-	Entry		uint64;			/* Entry point. */
-	Phoff		uint64;			/* Program header file offset. */
-	Shoff		uint64;			/* Section header file offset. */
-	Flags		uint32;			/* Architecture-specific flags. */
-	Ehsize		uint16;			/* Size of ELF header in bytes. */
-	Phentsize	uint16;			/* Size of program header entry. */
-	Phnum		uint16;			/* Number of program header entries. */
-	Shentsize	uint16;			/* Size of section header entry. */
-	Shnum		uint16;			/* Number of section header entries. */
-	Shstrndx	uint16;			/* Section name strings section. */
+	Ident     [EI_NIDENT]byte /* File identification. */
+	Type      uint16          /* File type. */
+	Machine   uint16          /* Machine architecture. */
+	Version   uint32          /* ELF format version. */
+	Entry     uint64          /* Entry point. */
+	Phoff     uint64          /* Program header file offset. */
+	Shoff     uint64          /* Section header file offset. */
+	Flags     uint32          /* Architecture-specific flags. */
+	Ehsize    uint16          /* Size of ELF header in bytes. */
+	Phentsize uint16          /* Size of program header entry. */
+	Phnum     uint16          /* Number of program header entries. */
+	Shentsize uint16          /* Size of section header entry. */
+	Shnum     uint16          /* Number of section header entries. */
+	Shstrndx  uint16          /* Section name strings section. */
 }
 
 /*
@@ -1401,16 +1401,16 @@ type Header64 struct {
  */
 
 type Section64 struct {
-	Name		uint32;	/* Section name (index into the section header string table). */
-	Type		uint32;	/* Section type. */
-	Flags		uint64;	/* Section flags. */
-	Addr		uint64;	/* Address in memory image. */
-	Off		uint64;	/* Offset in file. */
-	Size		uint64;	/* Size in bytes. */
-	Link		uint32;	/* Index of a related section. */
-	Info		uint32;	/* Depends on section type. */
-	Addralign	uint64;	/* Alignment in bytes. */
-	Entsize		uint64;	/* Size of each entry in section. */
+	Name      uint32 /* Section name (index into the section header string table). */
+	Type      uint32 /* Section type. */
+	Flags     uint64 /* Section flags. */
+	Addr      uint64 /* Address in memory image. */
+	Off       uint64 /* Offset in file. */
+	Size      uint64 /* Size in bytes. */
+	Link      uint32 /* Index of a related section. */
+	Info      uint32 /* Depends on section type. */
+	Addralign uint64 /* Alignment in bytes. */
+	Entsize   uint64 /* Size of each entry in section. */
 }
 
 /*
@@ -1418,14 +1418,14 @@ type Section64 struct {
  */
 
 type Prog64 struct {
-	Type	uint32;	/* Entry type. */
-	Flags	uint32;	/* Access permission flags. */
-	Off	uint64;	/* File offset of contents. */
-	Vaddr	uint64;	/* Virtual address in memory image. */
-	Paddr	uint64;	/* Physical address (not used). */
-	Filesz	uint64;	/* Size of contents in file. */
-	Memsz	uint64;	/* Size of contents in memory. */
-	Align	uint64;	/* Alignment in memory and file. */
+	Type   uint32 /* Entry type. */
+	Flags  uint32 /* Access permission flags. */
+	Off    uint64 /* File offset of contents. */
+	Vaddr  uint64 /* Virtual address in memory image. */
+	Paddr  uint64 /* Physical address (not used). */
+	Filesz uint64 /* Size of contents in file. */
+	Memsz  uint64 /* Size of contents in memory. */
+	Align  uint64 /* Alignment in memory and file. */
 }
 
 /*
@@ -1433,8 +1433,8 @@ type Prog64 struct {
  */
 
 type Dyn64 struct {
-	Tag	int64;	/* Entry type. */
-	Val	uint64;	/* Integer/address value */
+	Tag int64  /* Entry type. */
+	Val uint64 /* Integer/address value */
 }
 
 /*
@@ -1443,39 +1443,39 @@ type Dyn64 struct {
 
 /* ELF64 relocations that don't need an addend field. */
 type Rel64 struct {
-	Off	uint64;	/* Location to be relocated. */
-	Info	uint64;	/* Relocation type and symbol index. */
+	Off  uint64 /* Location to be relocated. */
+	Info uint64 /* Relocation type and symbol index. */
 }
 
 /* ELF64 relocations that need an addend field. */
 type Rela64 struct {
-	Off	uint64;	/* Location to be relocated. */
-	Info	uint64;	/* Relocation type and symbol index. */
-	Addend	int64;	/* Addend. */
+	Off    uint64 /* Location to be relocated. */
+	Info   uint64 /* Relocation type and symbol index. */
+	Addend int64  /* Addend. */
 }
 
-func R_SYM64(info uint64) uint32	{ return uint32(info >> 32) }
-func R_TYPE64(info uint64) uint32	{ return uint32(info) }
-func R_INFO(sym, typ uint32) uint64	{ return uint64(sym)<<32 | uint64(typ) }
+func R_SYM64(info uint64) uint32    { return uint32(info >> 32) }
+func R_TYPE64(info uint64) uint32   { return uint32(info) }
+func R_INFO(sym, typ uint32) uint64 { return uint64(sym)<<32 | uint64(typ) }
 
 
 /*
  * ELF64 symbol table entries.
  */
 type Sym64 struct {
-	Name	uint32;	/* String table index of name. */
-	Info	uint8;	/* Type and binding information. */
-	Other	uint8;	/* Reserved (not used). */
-	Shndx	uint16;	/* Section index of symbol. */
-	Value	uint64;	/* Symbol value. */
-	Size	uint64;	/* Size of associated object. */
+	Name  uint32 /* String table index of name. */
+	Info  uint8  /* Type and binding information. */
+	Other uint8  /* Reserved (not used). */
+	Shndx uint16 /* Section index of symbol. */
+	Value uint64 /* Symbol value. */
+	Size  uint64 /* Size of associated object. */
 }
 
 const Sym64Size = 24
 
 type intName struct {
-	i	uint32;
-	s	string;
+	i uint32
+	s string
 }
 
 func stringName(i uint32, names []intName, goSyntax bool) string {
@@ -1484,28 +1484,28 @@ func stringName(i uint32, names []intName, goSyntax bool) string {
 			if goSyntax {
 				return "elf." + n.s
 			}
-			return n.s;
+			return n.s
 		}
 	}
 
 	// second pass - look for smaller to add with.
 	// assume sorted already
 	for j := len(names) - 1; j >= 0; j-- {
-		n := names[j];
+		n := names[j]
 		if n.i < i {
-			s := n.s;
+			s := n.s
 			if goSyntax {
 				s = "elf." + s
 			}
-			return s + "+" + strconv.Uitoa64(uint64(i-n.i));
+			return s + "+" + strconv.Uitoa64(uint64(i-n.i))
 		}
 	}
 
-	return strconv.Uitoa64(uint64(i));
+	return strconv.Uitoa64(uint64(i))
 }
 
 func flagName(i uint32, names []intName, goSyntax bool) string {
-	s := "";
+	s := ""
 	for _, n := range names {
 		if n.i&i == n.i {
 			if len(s) > 0 {
@@ -1514,8 +1514,8 @@ func flagName(i uint32, names []intName, goSyntax bool) string {
 			if goSyntax {
 				s += "elf."
 			}
-			s += n.s;
-			i -= n.i;
+			s += n.s
+			i -= n.i
 		}
 	}
 	if len(s) == 0 {
@@ -1524,5 +1524,5 @@ func flagName(i uint32, names []intName, goSyntax bool) string {
 	if i != 0 {
 		s += "+0x" + strconv.Uitob64(uint64(i), 16)
 	}
-	return s;
+	return s
 }
diff --git a/src/pkg/debug/elf/elf_test.go b/src/pkg/debug/elf/elf_test.go
index bc2a4f6875..6f827faf00 100644
--- a/src/pkg/debug/elf/elf_test.go
+++ b/src/pkg/debug/elf/elf_test.go
@@ -5,13 +5,13 @@
 package elf
 
 import (
-	"fmt";
-	"testing";
+	"fmt"
+	"testing"
 )
 
 type nameTest struct {
-	val	interface{};
-	str	string;
+	val interface{}
+	str string
 }
 
 var nameTests = []nameTest{
@@ -41,7 +41,7 @@ var nameTests = []nameTest{
 
 func TestNames(t *testing.T) {
 	for i, tt := range nameTests {
-		s := fmt.Sprint(tt.val);
+		s := fmt.Sprint(tt.val)
 		if s != tt.str {
 			t.Errorf("#%d: want %q have %q", i, s, tt.str)
 		}
diff --git a/src/pkg/debug/elf/file.go b/src/pkg/debug/elf/file.go
index e610bc2eb9..c7ef955e61 100644
--- a/src/pkg/debug/elf/file.go
+++ b/src/pkg/debug/elf/file.go
@@ -6,12 +6,12 @@
 package elf
 
 import (
-	"bytes";
-	"debug/dwarf";
-	"encoding/binary";
-	"fmt";
-	"io";
-	"os";
+	"bytes"
+	"debug/dwarf"
+	"encoding/binary"
+	"fmt"
+	"io"
+	"os"
 )
 
 // TODO: error reporting detail
@@ -22,41 +22,41 @@ import (
 
 // A FileHeader represents an ELF file header.
 type FileHeader struct {
-	Class		Class;
-	Data		Data;
-	Version		Version;
-	OSABI		OSABI;
-	ABIVersion	uint8;
-	ByteOrder	binary.ByteOrder;
-	Type		Type;
-	Machine		Machine;
+	Class      Class
+	Data       Data
+	Version    Version
+	OSABI      OSABI
+	ABIVersion uint8
+	ByteOrder  binary.ByteOrder
+	Type       Type
+	Machine    Machine
 }
 
 // A File represents an open ELF file.
 type File struct {
-	FileHeader;
-	Sections	[]*Section;
-	Progs		[]*Prog;
-	closer		io.Closer;
+	FileHeader
+	Sections []*Section
+	Progs    []*Prog
+	closer   io.Closer
 }
 
 // A SectionHeader represents a single ELF section header.
 type SectionHeader struct {
-	Name		string;
-	Type		SectionType;
-	Flags		SectionFlag;
-	Addr		uint64;
-	Offset		uint64;
-	Size		uint64;
-	Link		uint32;
-	Info		uint32;
-	Addralign	uint64;
-	Entsize		uint64;
+	Name      string
+	Type      SectionType
+	Flags     SectionFlag
+	Addr      uint64
+	Offset    uint64
+	Size      uint64
+	Link      uint32
+	Info      uint32
+	Addralign uint64
+	Entsize   uint64
 }
 
 // A Section represents a single section in an ELF file.
 type Section struct {
-	SectionHeader;
+	SectionHeader
 
 	// Embed ReaderAt for ReadAt method.
 	// Do not embed SectionReader directly
@@ -64,34 +64,34 @@ type Section struct {
 	// If a client wants Read and Seek it must use
 	// Open() to avoid fighting over the seek offset
 	// with other clients.
-	io.ReaderAt;
-	sr	*io.SectionReader;
+	io.ReaderAt
+	sr *io.SectionReader
 }
 
 // Data reads and returns the contents of the ELF section.
 func (s *Section) Data() ([]byte, os.Error) {
-	dat := make([]byte, s.sr.Size());
-	n, err := s.sr.ReadAt(dat, 0);
-	return dat[0:n], err;
+	dat := make([]byte, s.sr.Size())
+	n, err := s.sr.ReadAt(dat, 0)
+	return dat[0:n], err
 }
 
 // Open returns a new ReadSeeker reading the ELF section.
-func (s *Section) Open() io.ReadSeeker	{ return io.NewSectionReader(s.sr, 0, 1<<63-1) }
+func (s *Section) Open() io.ReadSeeker { return io.NewSectionReader(s.sr, 0, 1<<63-1) }
 
 // A ProgHeader represents a single ELF program header.
 type ProgHeader struct {
-	Type	ProgType;
-	Flags	ProgFlag;
-	Vaddr	uint64;
-	Paddr	uint64;
-	Filesz	uint64;
-	Memsz	uint64;
-	Align	uint64;
+	Type   ProgType
+	Flags  ProgFlag
+	Vaddr  uint64
+	Paddr  uint64
+	Filesz uint64
+	Memsz  uint64
+	Align  uint64
 }
 
 // A Prog represents a single ELF program header in an ELF binary.
 type Prog struct {
-	ProgHeader;
+	ProgHeader
 
 	// Embed ReaderAt for ReadAt method.
 	// Do not embed SectionReader directly
@@ -99,19 +99,19 @@ type Prog struct {
 	// If a client wants Read and Seek it must use
 	// Open() to avoid fighting over the seek offset
 	// with other clients.
-	io.ReaderAt;
-	sr	*io.SectionReader;
+	io.ReaderAt
+	sr *io.SectionReader
 }
 
 // Open returns a new ReadSeeker reading the ELF program body.
-func (p *Prog) Open() io.ReadSeeker	{ return io.NewSectionReader(p.sr, 0, 1<<63-1) }
+func (p *Prog) Open() io.ReadSeeker { return io.NewSectionReader(p.sr, 0, 1<<63-1) }
 
 // A Symbol represents an entry in an ELF symbol table section.
 type Symbol struct {
-	Name		uint32;
-	Info, Other	byte;
-	Section		uint32;
-	Value, Size	uint64;
+	Name        uint32
+	Info, Other byte
+	Section     uint32
+	Value, Size uint64
 }
 
 /*
@@ -119,53 +119,53 @@ type Symbol struct {
  */
 
 type FormatError struct {
-	off	int64;
-	msg	string;
-	val	interface{};
+	off int64
+	msg string
+	val interface{}
 }
 
 func (e *FormatError) String() string {
-	msg := e.msg;
+	msg := e.msg
 	if e.val != nil {
 		msg += fmt.Sprintf(" '%v' ", e.val)
 	}
-	msg += fmt.Sprintf("in record at byte %#x", e.off);
-	return msg;
+	msg += fmt.Sprintf("in record at byte %#x", e.off)
+	return msg
 }
 
 // Open opens the named file using os.Open and prepares it for use as an ELF binary.
 func Open(name string) (*File, os.Error) {
-	f, err := os.Open(name, os.O_RDONLY, 0);
+	f, err := os.Open(name, os.O_RDONLY, 0)
 	if err != nil {
 		return nil, err
 	}
-	ff, err := NewFile(f);
+	ff, err := NewFile(f)
 	if err != nil {
-		f.Close();
-		return nil, err;
+		f.Close()
+		return nil, err
 	}
-	ff.closer = f;
-	return ff, nil;
+	ff.closer = f
+	return ff, nil
 }
 
 // Close closes the File.
 // If the File was created using NewFile directly instead of Open,
 // Close has no effect.
 func (f *File) Close() os.Error {
-	var err os.Error;
+	var err os.Error
 	if f.closer != nil {
-		err = f.closer.Close();
-		f.closer = nil;
+		err = f.closer.Close()
+		f.closer = nil
 	}
-	return err;
+	return err
 }
 
 // NewFile creates a new File for acecssing an ELF binary in an underlying reader.
 // The ELF binary is expected to start at position 0 in the ReaderAt.
 func NewFile(r io.ReaderAt) (*File, os.Error) {
-	sr := io.NewSectionReader(r, 0, 1<<63-1);
+	sr := io.NewSectionReader(r, 0, 1<<63-1)
 	// Read and decode ELF identifier
-	var ident [16]uint8;
+	var ident [16]uint8
 	if _, err := r.ReadAt(&ident, 0); err != nil {
 		return nil, err
 	}
@@ -173,8 +173,8 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 		return nil, &FormatError{0, "bad magic number", ident[0:4]}
 	}
 
-	f := new(File);
-	f.Class = Class(ident[EI_CLASS]);
+	f := new(File)
+	f.Class = Class(ident[EI_CLASS])
 	switch f.Class {
 	case ELFCLASS32:
 	case ELFCLASS64:
@@ -183,7 +183,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 		return nil, &FormatError{0, "unknown ELF class", f.Class}
 	}
 
-	f.Data = Data(ident[EI_DATA]);
+	f.Data = Data(ident[EI_DATA])
 	switch f.Data {
 	case ELFDATA2LSB:
 		f.ByteOrder = binary.LittleEndian
@@ -193,49 +193,49 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 		return nil, &FormatError{0, "unknown ELF data encoding", f.Data}
 	}
 
-	f.Version = Version(ident[EI_VERSION]);
+	f.Version = Version(ident[EI_VERSION])
 	if f.Version != EV_CURRENT {
 		return nil, &FormatError{0, "unknown ELF version", f.Version}
 	}
 
-	f.OSABI = OSABI(ident[EI_OSABI]);
-	f.ABIVersion = ident[EI_ABIVERSION];
+	f.OSABI = OSABI(ident[EI_OSABI])
+	f.ABIVersion = ident[EI_ABIVERSION]
 
 	// Read ELF file header
-	var shoff int64;
-	var shentsize, shnum, shstrndx int;
-	shstrndx = -1;
+	var shoff int64
+	var shentsize, shnum, shstrndx int
+	shstrndx = -1
 	switch f.Class {
 	case ELFCLASS32:
-		hdr := new(Header32);
-		sr.Seek(0, 0);
+		hdr := new(Header32)
+		sr.Seek(0, 0)
 		if err := binary.Read(sr, f.ByteOrder, hdr); err != nil {
 			return nil, err
 		}
-		f.Type = Type(hdr.Type);
-		f.Machine = Machine(hdr.Machine);
+		f.Type = Type(hdr.Type)
+		f.Machine = Machine(hdr.Machine)
 		if v := Version(hdr.Version); v != f.Version {
 			return nil, &FormatError{0, "mismatched ELF version", v}
 		}
-		shoff = int64(hdr.Shoff);
-		shentsize = int(hdr.Shentsize);
-		shnum = int(hdr.Shnum);
-		shstrndx = int(hdr.Shstrndx);
+		shoff = int64(hdr.Shoff)
+		shentsize = int(hdr.Shentsize)
+		shnum = int(hdr.Shnum)
+		shstrndx = int(hdr.Shstrndx)
 	case ELFCLASS64:
-		hdr := new(Header64);
-		sr.Seek(0, 0);
+		hdr := new(Header64)
+		sr.Seek(0, 0)
 		if err := binary.Read(sr, f.ByteOrder, hdr); err != nil {
 			return nil, err
 		}
-		f.Type = Type(hdr.Type);
-		f.Machine = Machine(hdr.Machine);
+		f.Type = Type(hdr.Type)
+		f.Machine = Machine(hdr.Machine)
 		if v := Version(hdr.Version); v != f.Version {
 			return nil, &FormatError{0, "mismatched ELF version", v}
 		}
-		shoff = int64(hdr.Shoff);
-		shentsize = int(hdr.Shentsize);
-		shnum = int(hdr.Shnum);
-		shstrndx = int(hdr.Shstrndx);
+		shoff = int64(hdr.Shoff)
+		shentsize = int(hdr.Shentsize)
+		shnum = int(hdr.Shnum)
+		shstrndx = int(hdr.Shstrndx)
 	}
 	if shstrndx < 0 || shstrndx >= shnum {
 		return nil, &FormatError{0, "invalid ELF shstrndx", shstrndx}
@@ -245,19 +245,19 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 	// TODO
 
 	// Read section headers
-	f.Sections = make([]*Section, shnum);
-	names := make([]uint32, shnum);
+	f.Sections = make([]*Section, shnum)
+	names := make([]uint32, shnum)
 	for i := 0; i < shnum; i++ {
-		off := shoff + int64(i)*int64(shentsize);
-		sr.Seek(off, 0);
-		s := new(Section);
+		off := shoff + int64(i)*int64(shentsize)
+		sr.Seek(off, 0)
+		s := new(Section)
 		switch f.Class {
 		case ELFCLASS32:
-			sh := new(Section32);
+			sh := new(Section32)
 			if err := binary.Read(sr, f.ByteOrder, sh); err != nil {
 				return nil, err
 			}
-			names[i] = sh.Name;
+			names[i] = sh.Name
 			s.SectionHeader = SectionHeader{
 				Type: SectionType(sh.Type),
 				Flags: SectionFlag(sh.Flags),
@@ -268,13 +268,13 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 				Info: uint32(sh.Info),
 				Addralign: uint64(sh.Addralign),
 				Entsize: uint64(sh.Entsize),
-			};
+			}
 		case ELFCLASS64:
-			sh := new(Section64);
+			sh := new(Section64)
 			if err := binary.Read(sr, f.ByteOrder, sh); err != nil {
 				return nil, err
 			}
-			names[i] = sh.Name;
+			names[i] = sh.Name
 			s.SectionHeader = SectionHeader{
 				Type: SectionType(sh.Type),
 				Flags: SectionFlag(sh.Flags),
@@ -285,28 +285,28 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 				Info: uint32(sh.Info),
 				Addralign: uint64(sh.Addralign),
 				Entsize: uint64(sh.Entsize),
-			};
+			}
 		}
-		s.sr = io.NewSectionReader(r, int64(s.Offset), int64(s.Size));
-		s.ReaderAt = s.sr;
-		f.Sections[i] = s;
+		s.sr = io.NewSectionReader(r, int64(s.Offset), int64(s.Size))
+		s.ReaderAt = s.sr
+		f.Sections[i] = s
 	}
 
 	// Load section header string table.
-	s := f.Sections[shstrndx];
-	shstrtab := make([]byte, s.Size);
+	s := f.Sections[shstrndx]
+	shstrtab := make([]byte, s.Size)
 	if _, err := r.ReadAt(shstrtab, int64(s.Offset)); err != nil {
 		return nil, err
 	}
 	for i, s := range f.Sections {
-		var ok bool;
-		s.Name, ok = getString(shstrtab, int(names[i]));
+		var ok bool
+		s.Name, ok = getString(shstrtab, int(names[i]))
 		if !ok {
 			return nil, &FormatError{shoff + int64(i*shentsize), "bad section name index", names[i]}
 		}
 	}
 
-	return f, nil;
+	return f, nil
 }
 
 func (f *File) getSymbols() ([]Symbol, os.Error) {
@@ -315,16 +315,16 @@ func (f *File) getSymbols() ([]Symbol, os.Error) {
 		return f.getSymbols64()
 	}
 
-	return nil, os.ErrorString("not implemented");
+	return nil, os.ErrorString("not implemented")
 }
 
 // GetSymbols returns a slice of Symbols from parsing the symbol table.
 func (f *File) getSymbols64() ([]Symbol, os.Error) {
-	var symtabSection *Section;
+	var symtabSection *Section
 	for _, section := range f.Sections {
 		if section.Type == SHT_SYMTAB {
-			symtabSection = section;
-			break;
+			symtabSection = section
+			break
 		}
 	}
 
@@ -332,35 +332,35 @@ func (f *File) getSymbols64() ([]Symbol, os.Error) {
 		return nil, os.ErrorString("no symbol section")
 	}
 
-	data, err := symtabSection.Data();
+	data, err := symtabSection.Data()
 	if err != nil {
 		return nil, os.ErrorString("cannot load symbol section")
 	}
-	symtab := bytes.NewBuffer(data);
+	symtab := bytes.NewBuffer(data)
 	if symtab.Len()%Sym64Size != 0 {
 		return nil, os.ErrorString("length of symbol section is not a multiple of Sym64Size")
 	}
 
 	// The first entry is all zeros.
-	var skip [Sym64Size]byte;
-	symtab.Read(skip[0:]);
+	var skip [Sym64Size]byte
+	symtab.Read(skip[0:])
 
-	symbols := make([]Symbol, symtab.Len()/Sym64Size);
+	symbols := make([]Symbol, symtab.Len()/Sym64Size)
 
-	i := 0;
-	var sym Sym64;
+	i := 0
+	var sym Sym64
 	for symtab.Len() > 0 {
-		binary.Read(symtab, f.ByteOrder, &sym);
-		symbols[i].Name = sym.Name;
-		symbols[i].Info = sym.Info;
-		symbols[i].Other = sym.Other;
-		symbols[i].Section = uint32(sym.Shndx);
-		symbols[i].Value = sym.Value;
-		symbols[i].Size = sym.Size;
-		i++;
+		binary.Read(symtab, f.ByteOrder, &sym)
+		symbols[i].Name = sym.Name
+		symbols[i].Info = sym.Info
+		symbols[i].Other = sym.Other
+		symbols[i].Section = uint32(sym.Shndx)
+		symbols[i].Value = sym.Value
+		symbols[i].Size = sym.Size
+		i++
 	}
 
-	return symbols, nil;
+	return symbols, nil
 }
 
 // getString extracts a string from an ELF string table.
@@ -374,7 +374,7 @@ func getString(section []byte, start int) (string, bool) {
 			return string(section[start:end]), true
 		}
 	}
-	return "", false;
+	return "", false
 }
 
 // Section returns a section with the given name, or nil if no such
@@ -385,7 +385,7 @@ func (f *File) Section(name string) *Section {
 			return s
 		}
 	}
-	return nil;
+	return nil
 }
 
 // applyRelocations applies relocations to dst. rels is a relocations section
@@ -395,7 +395,7 @@ func (f *File) applyRelocations(dst []byte, rels []byte) os.Error {
 		return f.applyRelocationsAMD64(dst, rels)
 	}
 
-	return os.ErrorString("not implemented");
+	return os.ErrorString("not implemented")
 }
 
 func (f *File) applyRelocationsAMD64(dst []byte, rels []byte) os.Error {
@@ -403,23 +403,23 @@ func (f *File) applyRelocationsAMD64(dst []byte, rels []byte) os.Error {
 		return os.ErrorString("length of relocation section is not a multiple of Sym64Size")
 	}
 
-	symbols, err := f.getSymbols();
+	symbols, err := f.getSymbols()
 	if err != nil {
 		return err
 	}
 
-	b := bytes.NewBuffer(rels);
-	var rela Rela64;
+	b := bytes.NewBuffer(rels)
+	var rela Rela64
 
 	for b.Len() > 0 {
-		binary.Read(b, f.ByteOrder, &rela);
-		symNo := rela.Info >> 32;
-		t := R_X86_64(rela.Info & 0xffff);
+		binary.Read(b, f.ByteOrder, &rela)
+		symNo := rela.Info >> 32
+		t := R_X86_64(rela.Info & 0xffff)
 
 		if symNo >= uint64(len(symbols)) {
 			continue
 		}
-		sym := &symbols[symNo];
+		sym := &symbols[symNo]
 		if SymType(sym.Info&0xf) != STT_SECTION {
 			// We don't handle non-section relocations for now.
 			continue
@@ -430,51 +430,51 @@ func (f *File) applyRelocationsAMD64(dst []byte, rels []byte) os.Error {
 			if rela.Off+8 >= uint64(len(dst)) || rela.Addend < 0 {
 				continue
 			}
-			f.ByteOrder.PutUint64(dst[rela.Off:rela.Off+8], uint64(rela.Addend));
+			f.ByteOrder.PutUint64(dst[rela.Off:rela.Off+8], uint64(rela.Addend))
 		case R_X86_64_32:
 			if rela.Off+4 >= uint64(len(dst)) || rela.Addend < 0 {
 				continue
 			}
-			f.ByteOrder.PutUint32(dst[rela.Off:rela.Off+4], uint32(rela.Addend));
+			f.ByteOrder.PutUint32(dst[rela.Off:rela.Off+4], uint32(rela.Addend))
 		}
 	}
 
-	return nil;
+	return nil
 }
 
 func (f *File) DWARF() (*dwarf.Data, os.Error) {
 	// There are many other DWARF sections, but these
 	// are the required ones, and the debug/dwarf package
 	// does not use the others, so don't bother loading them.
-	var names = [...]string{"abbrev", "info", "str"};
-	var dat [len(names)][]byte;
+	var names = [...]string{"abbrev", "info", "str"}
+	var dat [len(names)][]byte
 	for i, name := range names {
-		name = ".debug_" + name;
-		s := f.Section(name);
+		name = ".debug_" + name
+		s := f.Section(name)
 		if s == nil {
 			continue
 		}
-		b, err := s.Data();
+		b, err := s.Data()
 		if err != nil && uint64(len(b)) < s.Size {
 			return nil, err
 		}
-		dat[i] = b;
+		dat[i] = b
 	}
 
 	// If there's a relocation table for .debug_info, we have to process it
 	// now otherwise the data in .debug_info is invalid for x86-64 objects.
-	rela := f.Section(".rela.debug_info");
+	rela := f.Section(".rela.debug_info")
 	if rela != nil && rela.Type == SHT_RELA && f.Machine == EM_X86_64 {
-		data, err := rela.Data();
+		data, err := rela.Data()
 		if err != nil {
 			return nil, err
 		}
-		err = f.applyRelocations(dat[1], data);
+		err = f.applyRelocations(dat[1], data)
 		if err != nil {
 			return nil, err
 		}
 	}
 
-	abbrev, info, str := dat[0], dat[1], dat[2];
-	return dwarf.New(abbrev, nil, nil, info, nil, nil, nil, str);
+	abbrev, info, str := dat[0], dat[1], dat[2]
+	return dwarf.New(abbrev, nil, nil, info, nil, nil, nil, str)
 }
diff --git a/src/pkg/debug/elf/file_test.go b/src/pkg/debug/elf/file_test.go
index 9cd15fbd3d..49adc4dc76 100644
--- a/src/pkg/debug/elf/file_test.go
+++ b/src/pkg/debug/elf/file_test.go
@@ -5,16 +5,16 @@
 package elf
 
 import (
-	"debug/dwarf";
-	"encoding/binary";
-	"reflect";
-	"testing";
+	"debug/dwarf"
+	"encoding/binary"
+	"reflect"
+	"testing"
 )
 
 type fileTest struct {
-	file		string;
-	hdr		FileHeader;
-	sections	[]SectionHeader;
+	file     string
+	hdr      FileHeader
+	sections []SectionHeader
 }
 
 var fileTests = []fileTest{
@@ -101,28 +101,28 @@ var fileTests = []fileTest{
 
 func TestOpen(t *testing.T) {
 	for i := range fileTests {
-		tt := &fileTests[i];
+		tt := &fileTests[i]
 
-		f, err := Open(tt.file);
+		f, err := Open(tt.file)
 		if err != nil {
-			t.Error(err);
-			continue;
+			t.Error(err)
+			continue
 		}
 		if !reflect.DeepEqual(f.FileHeader, tt.hdr) {
-			t.Errorf("open %s:\n\thave %#v\n\twant %#v\n", tt.file, f.FileHeader, tt.hdr);
-			continue;
+			t.Errorf("open %s:\n\thave %#v\n\twant %#v\n", tt.file, f.FileHeader, tt.hdr)
+			continue
 		}
 		for i, s := range f.Sections {
 			if i >= len(tt.sections) {
 				break
 			}
-			sh := &tt.sections[i];
+			sh := &tt.sections[i]
 			if !reflect.DeepEqual(&s.SectionHeader, sh) {
 				t.Errorf("open %s, section %d:\n\thave %#v\n\twant %#v\n", tt.file, i, &s.SectionHeader, sh)
 			}
 		}
-		tn := len(tt.sections);
-		fn := len(f.Sections);
+		tn := len(tt.sections)
+		fn := len(f.Sections)
 		if tn != fn {
 			t.Errorf("open %s: len(Sections) = %d, want %d", tt.file, fn, tn)
 		}
@@ -130,8 +130,8 @@ func TestOpen(t *testing.T) {
 }
 
 type relocationTest struct {
-	file		string;
-	firstEntry	*dwarf.Entry;
+	file       string
+	firstEntry *dwarf.Entry
 }
 
 var relocationTests = []relocationTest{
@@ -151,30 +151,30 @@ var relocationTests = []relocationTest{
 
 func TestDWARFRelocations(t *testing.T) {
 	for i, test := range relocationTests {
-		f, err := Open(test.file);
+		f, err := Open(test.file)
 		if err != nil {
-			t.Error(err);
-			continue;
+			t.Error(err)
+			continue
 		}
-		dwarf, err := f.DWARF();
+		dwarf, err := f.DWARF()
 		if err != nil {
-			t.Error(err);
-			continue;
+			t.Error(err)
+			continue
 		}
-		reader := dwarf.Reader();
+		reader := dwarf.Reader()
 		// Checking only the first entry is sufficient since it has
 		// many different strings. If the relocation had failed, all
 		// the string offsets would be zero and all the strings would
 		// end up being the same.
-		firstEntry, err := reader.Next();
+		firstEntry, err := reader.Next()
 		if err != nil {
-			t.Error(err);
-			continue;
+			t.Error(err)
+			continue
 		}
 
 		if !reflect.DeepEqual(test.firstEntry, firstEntry) {
-			t.Errorf("#%d: mismatch: got:%#v want:%#v", i, firstEntry, test.firstEntry);
-			continue;
+			t.Errorf("#%d: mismatch: got:%#v want:%#v", i, firstEntry, test.firstEntry)
+			continue
 		}
 	}
 }
diff --git a/src/pkg/debug/gosym/pclntab.go b/src/pkg/debug/gosym/pclntab.go
index 6c6a18868b..9d7b0d15f3 100644
--- a/src/pkg/debug/gosym/pclntab.go
+++ b/src/pkg/debug/gosym/pclntab.go
@@ -11,9 +11,9 @@ package gosym
 import "encoding/binary"
 
 type LineTable struct {
-	Data	[]byte;
-	PC	uint64;
-	Line	int;
+	Data []byte
+	PC   uint64
+	Line int
 }
 
 // TODO(rsc): Need to pull in quantum from architecture definition.
@@ -28,49 +28,49 @@ func (t *LineTable) parse(targetPC uint64, targetLine int) (b []byte, pc uint64,
 	//
 	// Here we process each update individually, which simplifies
 	// the code, but makes the corner cases more confusing.
-	b, pc, line = t.Data, t.PC, t.Line;
+	b, pc, line = t.Data, t.PC, t.Line
 	for pc <= targetPC && line != targetLine && len(b) > 0 {
-		code := b[0];
-		b = b[1:];
+		code := b[0]
+		b = b[1:]
 		switch {
 		case code == 0:
 			if len(b) < 4 {
-				b = b[0:0];
-				break;
+				b = b[0:0]
+				break
 			}
-			val := binary.BigEndian.Uint32(b);
-			b = b[4:];
-			line += int(val);
+			val := binary.BigEndian.Uint32(b)
+			b = b[4:]
+			line += int(val)
 		case code <= 64:
 			line += int(code)
 		case code <= 128:
 			line -= int(code - 64)
 		default:
-			pc += quantum * uint64(code-128);
-			continue;
+			pc += quantum * uint64(code-128)
+			continue
 		}
-		pc += quantum;
+		pc += quantum
 	}
-	return b, pc, line;
+	return b, pc, line
 }
 
 func (t *LineTable) slice(pc uint64) *LineTable {
-	data, pc, line := t.parse(pc, -1);
-	return &LineTable{data, pc, line};
+	data, pc, line := t.parse(pc, -1)
+	return &LineTable{data, pc, line}
 }
 
 func (t *LineTable) PCToLine(pc uint64) int {
-	_, _, line := t.parse(pc, -1);
-	return line;
+	_, _, line := t.parse(pc, -1)
+	return line
 }
 
 func (t *LineTable) LineToPC(line int, maxpc uint64) uint64 {
-	_, pc, line1 := t.parse(maxpc, line);
+	_, pc, line1 := t.parse(maxpc, line)
 	if line1 != line {
 		return 0
 	}
 	// Subtract quantum from PC to account for post-line increment
-	return pc - quantum;
+	return pc - quantum
 }
 
 // NewLineTable returns a new PC/line table
diff --git a/src/pkg/debug/gosym/pclntab_test.go b/src/pkg/debug/gosym/pclntab_test.go
index 66609d9cf7..9ab493d596 100644
--- a/src/pkg/debug/gosym/pclntab_test.go
+++ b/src/pkg/debug/gosym/pclntab_test.go
@@ -5,10 +5,10 @@
 package gosym
 
 import (
-	"debug/elf";
-	"os";
-	"testing";
-	"syscall";
+	"debug/elf"
+	"os"
+	"testing"
+	"syscall"
 )
 
 func dotest() bool {
@@ -17,40 +17,40 @@ func dotest() bool {
 }
 
 func getTable(t *testing.T) *Table {
-	f, tab := crack(os.Args[0], t);
-	f.Close();
-	return tab;
+	f, tab := crack(os.Args[0], t)
+	f.Close()
+	return tab
 }
 
 func crack(file string, t *testing.T) (*elf.File, *Table) {
 	// Open self
-	f, err := elf.Open(file);
+	f, err := elf.Open(file)
 	if err != nil {
 		t.Fatal(err)
 	}
-	return parse(file, f, t);
+	return parse(file, f, t)
 }
 
 func parse(file string, f *elf.File, t *testing.T) (*elf.File, *Table) {
-	symdat, err := f.Section(".gosymtab").Data();
+	symdat, err := f.Section(".gosymtab").Data()
 	if err != nil {
-		f.Close();
-		t.Fatalf("reading %s gosymtab: %v", file, err);
+		f.Close()
+		t.Fatalf("reading %s gosymtab: %v", file, err)
 	}
-	pclndat, err := f.Section(".gopclntab").Data();
+	pclndat, err := f.Section(".gopclntab").Data()
 	if err != nil {
-		f.Close();
-		t.Fatalf("reading %s gopclntab: %v", file, err);
+		f.Close()
+		t.Fatalf("reading %s gopclntab: %v", file, err)
 	}
 
-	pcln := NewLineTable(pclndat, f.Section(".text").Addr);
-	tab, err := NewTable(symdat, pcln);
+	pcln := NewLineTable(pclndat, f.Section(".text").Addr)
+	tab, err := NewTable(symdat, pcln)
 	if err != nil {
-		f.Close();
-		t.Fatalf("parsing %s gosymtab: %v", file, err);
+		f.Close()
+		t.Fatalf("parsing %s gosymtab: %v", file, err)
 	}
 
-	return f, tab;
+	return f, tab
 }
 
 var goarch = os.Getenv("O")
@@ -60,42 +60,42 @@ func TestLineFromAline(t *testing.T) {
 		return
 	}
 
-	tab := getTable(t);
+	tab := getTable(t)
 
 	// Find the sym package
-	pkg := tab.LookupFunc("gosym.TestLineFromAline").Obj;
+	pkg := tab.LookupFunc("gosym.TestLineFromAline").Obj
 	if pkg == nil {
 		t.Fatalf("nil pkg")
 	}
 
 	// Walk every absolute line and ensure that we hit every
 	// source line monotonically
-	lastline := make(map[string]int);
-	final := -1;
+	lastline := make(map[string]int)
+	final := -1
 	for i := 0; i < 10000; i++ {
-		path, line := pkg.lineFromAline(i);
+		path, line := pkg.lineFromAline(i)
 		// Check for end of object
 		if path == "" {
 			if final == -1 {
 				final = i - 1
 			}
-			continue;
+			continue
 		} else if final != -1 {
 			t.Fatalf("reached end of package at absolute line %d, but absolute line %d mapped to %s:%d", final, i, path, line)
 		}
 		// It's okay to see files multiple times (e.g., sys.a)
 		if line == 1 {
-			lastline[path] = 1;
-			continue;
+			lastline[path] = 1
+			continue
 		}
 		// Check that the is the next line in path
-		ll, ok := lastline[path];
+		ll, ok := lastline[path]
 		if !ok {
 			t.Errorf("file %s starts on line %d", path, line)
 		} else if line != ll+1 {
 			t.Errorf("expected next line of file %s to be %d, got %d", path, ll+1, line)
 		}
-		lastline[path] = line;
+		lastline[path] = line
 	}
 	if final == -1 {
 		t.Errorf("never reached end of object")
@@ -107,15 +107,15 @@ func TestLineAline(t *testing.T) {
 		return
 	}
 
-	tab := getTable(t);
+	tab := getTable(t)
 
 	for _, o := range tab.Files {
 		// A source file can appear multiple times in a
 		// object.  alineFromLine will always return alines in
 		// the first file, so track which lines we've seen.
-		found := make(map[string]int);
+		found := make(map[string]int)
 		for i := 0; i < 1000; i++ {
-			path, line := o.lineFromAline(i);
+			path, line := o.lineFromAline(i)
 			if path == "" {
 				break
 			}
@@ -131,9 +131,9 @@ func TestLineAline(t *testing.T) {
 					continue
 				}
 			}
-			found[path] = line;
+			found[path] = line
 
-			a, err := o.alineFromLine(path, line);
+			a, err := o.alineFromLine(path, line)
 			if err != nil {
 				t.Errorf("absolute line %d in object %s maps to %s:%d, but mapping that back gives error %s", i, o.Paths[0].Name, path, line, err)
 			} else if a != i {
@@ -151,20 +151,20 @@ func TestPCLine(t *testing.T) {
 		return
 	}
 
-	f, tab := crack("_test/pclinetest", t);
-	text := f.Section(".text");
-	textdat, err := text.Data();
+	f, tab := crack("_test/pclinetest", t)
+	text := f.Section(".text")
+	textdat, err := text.Data()
 	if err != nil {
 		t.Fatalf("reading .text: %v", err)
 	}
 
 	// Test PCToLine
-	sym := tab.LookupFunc("linefrompc");
-	wantLine := 0;
+	sym := tab.LookupFunc("linefrompc")
+	wantLine := 0
 	for pc := sym.Entry; pc < sym.End; pc++ {
-		file, line, fn := tab.PCToLine(pc);
-		off := pc - text.Addr;	// TODO(rsc): should not need off; bug in 8g
-		wantLine += int(textdat[off]);
+		file, line, fn := tab.PCToLine(pc)
+		off := pc - text.Addr // TODO(rsc): should not need off; bug in 8g
+		wantLine += int(textdat[off])
 		if fn == nil {
 			t.Errorf("failed to get line of PC %#x", pc)
 		} else if len(file) < 12 || file[len(file)-12:] != "pclinetest.s" || line != wantLine || fn != sym {
@@ -173,24 +173,24 @@ func TestPCLine(t *testing.T) {
 	}
 
 	// Test LineToPC
-	sym = tab.LookupFunc("pcfromline");
-	lookupline := -1;
-	wantLine = 0;
-	off := uint64(0);	// TODO(rsc): should not need off; bug in 8g
+	sym = tab.LookupFunc("pcfromline")
+	lookupline := -1
+	wantLine = 0
+	off := uint64(0) // TODO(rsc): should not need off; bug in 8g
 	for pc := sym.Value; pc < sym.End; pc += 2 + uint64(textdat[off]) {
-		file, line, fn := tab.PCToLine(pc);
-		off = pc - text.Addr;
-		wantLine += int(textdat[off]);
+		file, line, fn := tab.PCToLine(pc)
+		off = pc - text.Addr
+		wantLine += int(textdat[off])
 		if line != wantLine {
-			t.Errorf("expected line %d at PC %#x in pcfromline, got %d", wantLine, pc, line);
-			off = pc + 1 - text.Addr;
-			continue;
+			t.Errorf("expected line %d at PC %#x in pcfromline, got %d", wantLine, pc, line)
+			off = pc + 1 - text.Addr
+			continue
 		}
 		if lookupline == -1 {
 			lookupline = line
 		}
 		for ; lookupline <= line; lookupline++ {
-			pc2, fn2, err := tab.LineToPC(file, lookupline);
+			pc2, fn2, err := tab.LineToPC(file, lookupline)
 			if lookupline != line {
 				// Should be nothing on this line
 				if err == nil {
@@ -202,6 +202,6 @@ func TestPCLine(t *testing.T) {
 				t.Errorf("expected PC %#x (%s) at line %d, got PC %#x (%s)", pc, fn.Name, line, pc2, fn2.Name)
 			}
 		}
-		off = pc + 1 - text.Addr;
+		off = pc + 1 - text.Addr
 	}
 }
diff --git a/src/pkg/debug/gosym/symtab.go b/src/pkg/debug/gosym/symtab.go
index 39e397ecef..dea460d71f 100644
--- a/src/pkg/debug/gosym/symtab.go
+++ b/src/pkg/debug/gosym/symtab.go
@@ -13,11 +13,11 @@ package gosym
 // and the Go format is the runtime source, specifically ../../runtime/symtab.c.
 
 import (
-	"encoding/binary";
-	"fmt";
-	"os";
-	"strconv";
-	"strings";
+	"encoding/binary"
+	"fmt"
+	"os"
+	"strconv"
+	"strings"
 )
 
 /*
@@ -26,16 +26,16 @@ import (
 
 // A Sym represents a single symbol table entry.
 type Sym struct {
-	Value	uint64;
-	Type	byte;
-	Name	string;
-	GoType	uint64;
+	Value  uint64
+	Type   byte
+	Name   string
+	GoType uint64
 	// If this symbol if a function symbol, the corresponding Func
-	Func	*Func;
+	Func *Func
 }
 
 // Static returns whether this symbol is static (not visible outside its file).
-func (s *Sym) Static() bool	{ return s.Type >= 'a' }
+func (s *Sym) Static() bool { return s.Type >= 'a' }
 
 // PackageName returns the package part of the symbol name,
 // or the empty string if there is none.
@@ -43,18 +43,18 @@ func (s *Sym) PackageName() string {
 	if i := strings.Index(s.Name, "."); i != -1 {
 		return s.Name[0:i]
 	}
-	return "";
+	return ""
 }
 
 // ReceiverName returns the receiver type name of this symbol,
 // or the empty string if there is none.
 func (s *Sym) ReceiverName() string {
-	l := strings.Index(s.Name, ".");
-	r := strings.LastIndex(s.Name, ".");
+	l := strings.Index(s.Name, ".")
+	r := strings.LastIndex(s.Name, ".")
 	if l == -1 || r == -1 || l == r {
 		return ""
 	}
-	return s.Name[l+1 : r];
+	return s.Name[l+1 : r]
 }
 
 // BaseName returns the symbol name without the package or receiver name.
@@ -62,25 +62,25 @@ func (s *Sym) BaseName() string {
 	if i := strings.LastIndex(s.Name, "."); i != -1 {
 		return s.Name[i+1:]
 	}
-	return s.Name;
+	return s.Name
 }
 
 // A Func collects information about a single function.
 type Func struct {
-	Entry	uint64;
-	*Sym;
-	End		uint64;
-	Params		[]*Sym;
-	Locals		[]*Sym;
-	FrameSize	int;
-	LineTable	*LineTable;
-	Obj		*Obj;
+	Entry uint64
+	*Sym
+	End       uint64
+	Params    []*Sym
+	Locals    []*Sym
+	FrameSize int
+	LineTable *LineTable
+	Obj       *Obj
 }
 
 // An Obj represents a single object file.
 type Obj struct {
-	Funcs	[]Func;
-	Paths	[]Sym;
+	Funcs []Func
+	Paths []Sym
 }
 
 /*
@@ -91,115 +91,115 @@ type Obj struct {
 // symbols decoded from the program and provides methods to translate
 // between symbols, names, and addresses.
 type Table struct {
-	Syms	[]Sym;
-	Funcs	[]Func;
-	Files	map[string]*Obj;
-	Objs	[]Obj;
+	Syms  []Sym
+	Funcs []Func
+	Files map[string]*Obj
+	Objs  []Obj
 	//	textEnd uint64;
 }
 
 type sym struct {
-	value	uint32;
-	gotype	uint32;
-	typ	byte;
-	name	[]byte;
+	value  uint32
+	gotype uint32
+	typ    byte
+	name   []byte
 }
 
 func walksymtab(data []byte, fn func(sym) os.Error) os.Error {
-	var s sym;
-	p := data;
+	var s sym
+	p := data
 	for len(p) >= 6 {
-		s.value = binary.BigEndian.Uint32(p[0:4]);
-		typ := p[4];
+		s.value = binary.BigEndian.Uint32(p[0:4])
+		typ := p[4]
 		if typ&0x80 == 0 {
 			return &DecodingError{len(data) - len(p) + 4, "bad symbol type", typ}
 		}
-		typ &^= 0x80;
-		s.typ = typ;
-		p = p[5:];
-		var i int;
-		var nnul int;
+		typ &^= 0x80
+		s.typ = typ
+		p = p[5:]
+		var i int
+		var nnul int
 		for i = 0; i < len(p); i++ {
 			if p[i] == 0 {
-				nnul = 1;
-				break;
+				nnul = 1
+				break
 			}
 		}
 		switch typ {
 		case 'z', 'Z':
-			p = p[i+nnul:];
+			p = p[i+nnul:]
 			for i = 0; i+2 <= len(p); i += 2 {
 				if p[i] == 0 && p[i+1] == 0 {
-					nnul = 2;
-					break;
+					nnul = 2
+					break
 				}
 			}
 		}
 		if i+nnul+4 > len(p) {
 			return &DecodingError{len(data), "unexpected EOF", nil}
 		}
-		s.name = p[0:i];
-		i += nnul;
-		s.gotype = binary.BigEndian.Uint32(p[i : i+4]);
-		p = p[i+4:];
-		fn(s);
+		s.name = p[0:i]
+		i += nnul
+		s.gotype = binary.BigEndian.Uint32(p[i : i+4])
+		p = p[i+4:]
+		fn(s)
 	}
-	return nil;
+	return nil
 }
 
 // NewTable decodes the Go symbol table in data,
 // returning an in-memory representation.
 func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
-	var n int;
+	var n int
 	err := walksymtab(symtab, func(s sym) os.Error {
-		n++;
-		return nil;
-	});
+		n++
+		return nil
+	})
 	if err != nil {
 		return nil, err
 	}
 
-	var t Table;
-	fname := make(map[uint16]string);
-	t.Syms = make([]Sym, 0, n);
-	nf := 0;
-	nz := 0;
-	lasttyp := uint8(0);
+	var t Table
+	fname := make(map[uint16]string)
+	t.Syms = make([]Sym, 0, n)
+	nf := 0
+	nz := 0
+	lasttyp := uint8(0)
 	err = walksymtab(symtab, func(s sym) os.Error {
-		n := len(t.Syms);
-		t.Syms = t.Syms[0 : n+1];
-		ts := &t.Syms[n];
-		ts.Type = s.typ;
-		ts.Value = uint64(s.value);
-		ts.GoType = uint64(s.gotype);
+		n := len(t.Syms)
+		t.Syms = t.Syms[0 : n+1]
+		ts := &t.Syms[n]
+		ts.Type = s.typ
+		ts.Value = uint64(s.value)
+		ts.GoType = uint64(s.gotype)
 		switch s.typ {
 		default:
 			// rewrite name to use . instead of ยท (c2 b7)
-			w := 0;
-			b := s.name;
+			w := 0
+			b := s.name
 			for i := 0; i < len(b); i++ {
 				if b[i] == 0xc2 && i+1 < len(b) && b[i+1] == 0xb7 {
-					i++;
-					b[i] = '.';
+					i++
+					b[i] = '.'
 				}
-				b[w] = b[i];
-				w++;
+				b[w] = b[i]
+				w++
 			}
-			ts.Name = string(s.name[0:w]);
+			ts.Name = string(s.name[0:w])
 		case 'z', 'Z':
 			if lasttyp != 'z' && lasttyp != 'Z' {
 				nz++
 			}
 			for i := 0; i < len(s.name); i += 2 {
-				eltIdx := binary.BigEndian.Uint16(s.name[i : i+2]);
-				elt, ok := fname[eltIdx];
+				eltIdx := binary.BigEndian.Uint16(s.name[i : i+2])
+				elt, ok := fname[eltIdx]
 				if !ok {
 					return &DecodingError{-1, "bad filename code", eltIdx}
 				}
 				if n := len(ts.Name); n > 0 && ts.Name[n-1] != '/' {
 					ts.Name += "/"
 				}
-				ts.Name += elt;
+				ts.Name += elt
 			}
 		}
 		switch s.typ {
@@ -208,61 +208,61 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 		case 'f':
 			fname[uint16(s.value)] = ts.Name
 		}
-		lasttyp = s.typ;
-		return nil;
-	});
+		lasttyp = s.typ
+		return nil
+	})
 	if err != nil {
 		return nil, err
 	}
 
-	t.Funcs = make([]Func, 0, nf);
-	t.Objs = make([]Obj, 0, nz);
-	t.Files = make(map[string]*Obj);
+	t.Funcs = make([]Func, 0, nf)
+	t.Objs = make([]Obj, 0, nz)
+	t.Files = make(map[string]*Obj)
 
 	// Count text symbols and attach frame sizes, parameters, and
 	// locals to them.  Also, find object file boundaries.
-	var obj *Obj;
-	lastf := 0;
+	var obj *Obj
+	lastf := 0
 	for i := 0; i < len(t.Syms); i++ {
-		sym := &t.Syms[i];
+		sym := &t.Syms[i]
 		switch sym.Type {
-		case 'Z', 'z':	// path symbol
+		case 'Z', 'z': // path symbol
 			// Finish the current object
 			if obj != nil {
 				obj.Funcs = t.Funcs[lastf:]
 			}
-			lastf = len(t.Funcs);
+			lastf = len(t.Funcs)
 
 			// Start new object
-			n := len(t.Objs);
-			t.Objs = t.Objs[0 : n+1];
-			obj = &t.Objs[n];
+			n := len(t.Objs)
+			t.Objs = t.Objs[0 : n+1]
+			obj = &t.Objs[n]
 
 			// Count & copy path symbols
-			var end int;
+			var end int
 			for end = i + 1; end < len(t.Syms); end++ {
 				if c := t.Syms[end].Type; c != 'Z' && c != 'z' {
 					break
 				}
 			}
-			obj.Paths = t.Syms[i:end];
-			i = end - 1;	// loop will i++
+			obj.Paths = t.Syms[i:end]
+			i = end - 1 // loop will i++
 
 			// Record file names
-			depth := 0;
+			depth := 0
 			for j := range obj.Paths {
-				s := &obj.Paths[j];
+				s := &obj.Paths[j]
 				if s.Name == "" {
 					depth--
 				} else {
 					if depth == 0 {
 						t.Files[s.Name] = obj
 					}
-					depth++;
+					depth++
 				}
 			}
 
-		case 'T', 't', 'L', 'l':	// text symbol
+		case 'T', 't', 'L', 'l': // text symbol
 			if n := len(t.Funcs); n > 0 {
 				t.Funcs[n-1].End = sym.Value
 			}
@@ -271,8 +271,8 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 			}
 
 			// Count parameter and local (auto) syms
-			var np, na int;
-			var end int;
+			var np, na int
+			var end int
 		countloop:
 			for end = i + 1; end < len(t.Syms); end++ {
 				switch t.Syms[end].Type {
@@ -286,50 +286,50 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 			}
 
 			// Fill in the function symbol
-			n := len(t.Funcs);
-			t.Funcs = t.Funcs[0 : n+1];
-			fn := &t.Funcs[n];
-			sym.Func = fn;
-			fn.Params = make([]*Sym, 0, np);
-			fn.Locals = make([]*Sym, 0, na);
-			fn.Sym = sym;
-			fn.Entry = sym.Value;
-			fn.Obj = obj;
+			n := len(t.Funcs)
+			t.Funcs = t.Funcs[0 : n+1]
+			fn := &t.Funcs[n]
+			sym.Func = fn
+			fn.Params = make([]*Sym, 0, np)
+			fn.Locals = make([]*Sym, 0, na)
+			fn.Sym = sym
+			fn.Entry = sym.Value
+			fn.Obj = obj
 			if pcln != nil {
-				fn.LineTable = pcln.slice(fn.Entry);
-				pcln = fn.LineTable;
+				fn.LineTable = pcln.slice(fn.Entry)
+				pcln = fn.LineTable
 			}
 			for j := i; j < end; j++ {
-				s := &t.Syms[j];
+				s := &t.Syms[j]
 				switch s.Type {
 				case 'm':
 					fn.FrameSize = int(s.Value)
 				case 'p':
-					n := len(fn.Params);
-					fn.Params = fn.Params[0 : n+1];
-					fn.Params[n] = s;
+					n := len(fn.Params)
+					fn.Params = fn.Params[0 : n+1]
+					fn.Params[n] = s
 				case 'a':
-					n := len(fn.Locals);
-					fn.Locals = fn.Locals[0 : n+1];
-					fn.Locals[n] = s;
+					n := len(fn.Locals)
+					fn.Locals = fn.Locals[0 : n+1]
+					fn.Locals[n] = s
 				}
 			}
-			i = end - 1;	// loop will i++
+			i = end - 1 // loop will i++
 		}
 	}
 	if obj != nil {
 		obj.Funcs = t.Funcs[lastf:]
 	}
-	return &t, nil;
+	return &t, nil
 }
 
 // PCToFunc returns the function containing the program counter pc,
 // or nil if there is no such function.
 func (t *Table) PCToFunc(pc uint64) *Func {
-	funcs := t.Funcs;
+	funcs := t.Funcs
 	for len(funcs) > 0 {
-		m := len(funcs) / 2;
-		fn := &funcs[m];
+		m := len(funcs) / 2
+		fn := &funcs[m]
 		switch {
 		case pc < fn.Entry:
 			funcs = funcs[0:m]
@@ -339,7 +339,7 @@ func (t *Table) PCToFunc(pc uint64) *Func {
 			funcs = funcs[m+1:]
 		}
 	}
-	return nil;
+	return nil
 }
 
 // PCToLine looks up line number information for a program counter.
@@ -348,30 +348,30 @@ func (t *Table) PCToLine(pc uint64) (file string, line int, fn *Func) {
 	if fn = t.PCToFunc(pc); fn == nil {
 		return
 	}
-	file, line = fn.Obj.lineFromAline(fn.LineTable.PCToLine(pc));
-	return;
+	file, line = fn.Obj.lineFromAline(fn.LineTable.PCToLine(pc))
+	return
 }
 
 // LineToPC looks up the first program counter on the given line in
 // the named file.  Returns UnknownPathError or UnknownLineError if
 // there is an error looking up this line.
 func (t *Table) LineToPC(file string, line int) (pc uint64, fn *Func, err os.Error) {
-	obj, ok := t.Files[file];
+	obj, ok := t.Files[file]
 	if !ok {
 		return 0, nil, UnknownFileError(file)
 	}
-	abs, err := obj.alineFromLine(file, line);
+	abs, err := obj.alineFromLine(file, line)
 	if err != nil {
 		return
 	}
 	for i := range obj.Funcs {
-		f := &obj.Funcs[i];
-		pc := f.LineTable.LineToPC(abs, f.End);
+		f := &obj.Funcs[i]
+		pc := f.LineTable.LineToPC(abs, f.End)
 		if pc != 0 {
 			return pc, f, nil
 		}
 	}
-	return 0, nil, &UnknownLineError{file, line};
+	return 0, nil, &UnknownLineError{file, line}
 }
 
 // LookupSym returns the text, data, or bss symbol with the given name,
@@ -379,7 +379,7 @@ func (t *Table) LineToPC(file string, line int) (pc uint64, fn *Func, err os.Err
 func (t *Table) LookupSym(name string) *Sym {
 	// TODO(austin) Maybe make a map
 	for i := range t.Syms {
-		s := &t.Syms[i];
+		s := &t.Syms[i]
 		switch s.Type {
 		case 'T', 't', 'L', 'l', 'D', 'd', 'B', 'b':
 			if s.Name == name {
@@ -387,19 +387,19 @@ func (t *Table) LookupSym(name string) *Sym {
 			}
 		}
 	}
-	return nil;
+	return nil
 }
 
 // LookupFunc returns the text, data, or bss symbol with the given name,
 // or nil if no such symbol is found.
 func (t *Table) LookupFunc(name string) *Func {
 	for i := range t.Funcs {
-		f := &t.Funcs[i];
+		f := &t.Funcs[i]
 		if f.Sym.Name == name {
 			return f
 		}
 	}
-	return nil;
+	return nil
 }
 
 // SymByAddr returns the text, data, or bss symbol starting at the given address.
@@ -407,7 +407,7 @@ func (t *Table) LookupFunc(name string) *Func {
 func (t *Table) SymByAddr(addr uint64) *Sym {
 	// TODO(austin) Maybe make a map
 	for i := range t.Syms {
-		s := &t.Syms[i];
+		s := &t.Syms[i]
 		switch s.Type {
 		case 'T', 't', 'L', 'l', 'D', 'd', 'B', 'b':
 			if s.Value == addr {
@@ -415,7 +415,7 @@ func (t *Table) SymByAddr(addr uint64) *Sym {
 			}
 		}
 	}
-	return nil;
+	return nil
 }
 
 /*
@@ -424,20 +424,20 @@ func (t *Table) SymByAddr(addr uint64) *Sym {
 
 func (o *Obj) lineFromAline(aline int) (string, int) {
 	type stackEnt struct {
-		path	string;
-		start	int;
-		offset	int;
-		prev	*stackEnt;
+		path   string
+		start  int
+		offset int
+		prev   *stackEnt
 	}
 
-	noPath := &stackEnt{"", 0, 0, nil};
-	tos := noPath;
+	noPath := &stackEnt{"", 0, 0, nil}
+	tos := noPath
 
 	// TODO(austin) I have no idea how 'Z' symbols work, except
 	// that they pop the stack.
 pathloop:
 	for _, s := range o.Paths {
-		val := int(s.Value);
+		val := int(s.Value)
 		switch {
 		case val > aline:
 			break pathloop
@@ -451,8 +451,8 @@ pathloop:
 			if tos == noPath {
 				return "<malformed symbol table>", 0
 			}
-			tos.prev.offset += val - tos.start;
-			tos = tos.prev;
+			tos.prev.offset += val - tos.start
+			tos = tos.prev
 
 		default:
 			// Push
@@ -463,7 +463,7 @@ pathloop:
 	if tos == noPath {
 		return "", 0
 	}
-	return tos.path, aline - tos.start - tos.offset + 1;
+	return tos.path, aline - tos.start - tos.offset + 1
 }
 
 func (o *Obj) alineFromLine(path string, line int) (int, os.Error) {
@@ -478,18 +478,18 @@ func (o *Obj) alineFromLine(path string, line int) (int, os.Error) {
 		}
 
 		// Find this line at this stack level
-		depth := 0;
-		var incstart int;
-		line += int(s.Value);
+		depth := 0
+		var incstart int
+		line += int(s.Value)
 	pathloop:
 		for _, s := range o.Paths[i:] {
-			val := int(s.Value);
+			val := int(s.Value)
 			switch {
 			case depth == 1 && val >= line:
 				return line - 1, nil
 
 			case s.Name == "":
-				depth--;
+				depth--
 				if depth == 0 {
 					break pathloop
 				} else if depth == 1 {
@@ -500,12 +500,12 @@ func (o *Obj) alineFromLine(path string, line int) (int, os.Error) {
 				if depth == 1 {
 					incstart = val
 				}
-				depth++;
+				depth++
 			}
 		}
-		return 0, &UnknownLineError{path, line};
+		return 0, &UnknownLineError{path, line}
 	}
-	return 0, UnknownFileError(path);
+	return 0, UnknownFileError(path)
 }
 
 /*
@@ -516,14 +516,14 @@ func (o *Obj) alineFromLine(path string, line int) (int, os.Error) {
 // the symbol table.
 type UnknownFileError string
 
-func (e UnknownFileError) String() string	{ return "unknown file: " + string(e) }
+func (e UnknownFileError) String() string { return "unknown file: " + string(e) }
 
 // UnknownLineError represents a failure to map a line to a program
 // counter, either because the line is beyond the bounds of the file
 // or because there is no code on the given line.
 type UnknownLineError struct {
-	File	string;
-	Line	int;
+	File string
+	Line int
 }
 
 func (e *UnknownLineError) String() string {
@@ -533,16 +533,16 @@ func (e *UnknownLineError) String() string {
 // DecodingError represents an error during the decoding of
 // the symbol table.
 type DecodingError struct {
-	off	int;
-	msg	string;
-	val	interface{};
+	off int
+	msg string
+	val interface{}
 }
 
 func (e *DecodingError) String() string {
-	msg := e.msg;
+	msg := e.msg
 	if e.val != nil {
 		msg += fmt.Sprintf(" '%v'", e.val)
 	}
-	msg += fmt.Sprintf(" at byte %#x", e.off);
-	return msg;
+	msg += fmt.Sprintf(" at byte %#x", e.off)
+	return msg
 }
diff --git a/src/pkg/debug/macho/file.go b/src/pkg/debug/macho/file.go
index 233490c835..7c492ef524 100644
--- a/src/pkg/debug/macho/file.go
+++ b/src/pkg/debug/macho/file.go
@@ -9,53 +9,53 @@ package macho
 // High level access to low level data structures.
 
 import (
-	"bytes";
-	"debug/dwarf";
-	"encoding/binary";
-	"fmt";
-	"io";
-	"os";
+	"bytes"
+	"debug/dwarf"
+	"encoding/binary"
+	"fmt"
+	"io"
+	"os"
 )
 
 // A File represents an open Mach-O file.
 type File struct {
-	FileHeader;
-	ByteOrder	binary.ByteOrder;
-	Loads		[]Load;
-	Sections	[]*Section;
+	FileHeader
+	ByteOrder binary.ByteOrder
+	Loads     []Load
+	Sections  []*Section
 
-	closer	io.Closer;
+	closer io.Closer
 }
 
 // A Load represents any Mach-O load command.
 type Load interface {
-	Raw() []byte;
+	Raw() []byte
 }
 
 // A LoadBytes is the uninterpreted bytes of a Mach-O load command.
 type LoadBytes []byte
 
-func (b LoadBytes) Raw() []byte	{ return b }
+func (b LoadBytes) Raw() []byte { return b }
 
 // A SegmentHeader is the header for a Mach-O 32-bit or 64-bit load segment command.
 type SegmentHeader struct {
-	Cmd	LoadCmd;
-	Len	uint32;
-	Name	string;
-	Addr	uint64;
-	Memsz	uint64;
-	Offset	uint64;
-	Filesz	uint64;
-	Maxprot	uint32;
-	Prot	uint32;
-	Nsect	uint32;
-	Flag	uint32;
+	Cmd     LoadCmd
+	Len     uint32
+	Name    string
+	Addr    uint64
+	Memsz   uint64
+	Offset  uint64
+	Filesz  uint64
+	Maxprot uint32
+	Prot    uint32
+	Nsect   uint32
+	Flag    uint32
 }
 
 // A Segment represents a Mach-O 32-bit or 64-bit load segment command.
 type Segment struct {
-	LoadBytes;
-	SegmentHeader;
+	LoadBytes
+	SegmentHeader
 
 	// Embed ReaderAt for ReadAt method.
 	// Do not embed SectionReader directly
@@ -63,34 +63,34 @@ type Segment struct {
 	// If a client wants Read and Seek it must use
 	// Open() to avoid fighting over the seek offset
 	// with other clients.
-	io.ReaderAt;
-	sr	*io.SectionReader;
+	io.ReaderAt
+	sr *io.SectionReader
 }
 
 // Data reads and returns the contents of the segment.
 func (s *Segment) Data() ([]byte, os.Error) {
-	dat := make([]byte, s.sr.Size());
-	n, err := s.sr.ReadAt(dat, 0);
-	return dat[0:n], err;
+	dat := make([]byte, s.sr.Size())
+	n, err := s.sr.ReadAt(dat, 0)
+	return dat[0:n], err
 }
 
 // Open returns a new ReadSeeker reading the segment.
-func (s *Segment) Open() io.ReadSeeker	{ return io.NewSectionReader(s.sr, 0, 1<<63-1) }
+func (s *Segment) Open() io.ReadSeeker { return io.NewSectionReader(s.sr, 0, 1<<63-1) }
 
 type SectionHeader struct {
-	Name	string;
-	Seg	string;
-	Addr	uint64;
-	Size	uint64;
-	Offset	uint32;
-	Align	uint32;
-	Reloff	uint32;
-	Nreloc	uint32;
-	Flags	uint32;
+	Name   string
+	Seg    string
+	Addr   uint64
+	Size   uint64
+	Offset uint32
+	Align  uint32
+	Reloff uint32
+	Nreloc uint32
+	Flags  uint32
 }
 
 type Section struct {
-	SectionHeader;
+	SectionHeader
 
 	// Embed ReaderAt for ReadAt method.
 	// Do not embed SectionReader directly
@@ -98,19 +98,19 @@ type Section struct {
 	// If a client wants Read and Seek it must use
 	// Open() to avoid fighting over the seek offset
 	// with other clients.
-	io.ReaderAt;
-	sr	*io.SectionReader;
+	io.ReaderAt
+	sr *io.SectionReader
 }
 
 // Data reads and returns the contents of the Mach-O section.
 func (s *Section) Data() ([]byte, os.Error) {
-	dat := make([]byte, s.sr.Size());
-	n, err := s.sr.ReadAt(dat, 0);
-	return dat[0:n], err;
+	dat := make([]byte, s.sr.Size())
+	n, err := s.sr.ReadAt(dat, 0)
+	return dat[0:n], err
 }
 
 // Open returns a new ReadSeeker reading the Mach-O section.
-func (s *Section) Open() io.ReadSeeker	{ return io.NewSectionReader(s.sr, 0, 1<<63-1) }
+func (s *Section) Open() io.ReadSeeker { return io.NewSectionReader(s.sr, 0, 1<<63-1) }
 
 
 /*
@@ -118,68 +118,68 @@ func (s *Section) Open() io.ReadSeeker	{ return io.NewSectionReader(s.sr, 0, 1<<
  */
 
 type FormatError struct {
-	off	int64;
-	msg	string;
-	val	interface{};
+	off int64
+	msg string
+	val interface{}
 }
 
 func (e *FormatError) String() string {
-	msg := e.msg;
+	msg := e.msg
 	if e.val != nil {
 		msg += fmt.Sprintf(" '%v' ", e.val)
 	}
-	msg += fmt.Sprintf("in record at byte %#x", e.off);
-	return msg;
+	msg += fmt.Sprintf("in record at byte %#x", e.off)
+	return msg
 }
 
 // Open opens the named file using os.Open and prepares it for use as a Mach-O binary.
 func Open(name string) (*File, os.Error) {
-	f, err := os.Open(name, os.O_RDONLY, 0);
+	f, err := os.Open(name, os.O_RDONLY, 0)
 	if err != nil {
 		return nil, err
 	}
-	ff, err := NewFile(f);
+	ff, err := NewFile(f)
 	if err != nil {
-		f.Close();
-		return nil, err;
+		f.Close()
+		return nil, err
 	}
-	ff.closer = f;
-	return ff, nil;
+	ff.closer = f
+	return ff, nil
 }
 
 // Close closes the File.
 // If the File was created using NewFile directly instead of Open,
 // Close has no effect.
 func (f *File) Close() os.Error {
-	var err os.Error;
+	var err os.Error
 	if f.closer != nil {
-		err = f.closer.Close();
-		f.closer = nil;
+		err = f.closer.Close()
+		f.closer = nil
 	}
-	return err;
+	return err
 }
 
 // NewFile creates a new File for acecssing a Mach-O binary in an underlying reader.
 // The Mach-O binary is expected to start at position 0 in the ReaderAt.
 func NewFile(r io.ReaderAt) (*File, os.Error) {
-	f := new(File);
-	sr := io.NewSectionReader(r, 0, 1<<63-1);
+	f := new(File)
+	sr := io.NewSectionReader(r, 0, 1<<63-1)
 
 	// Read and decode Mach magic to determine byte order, size.
 	// Magic32 and Magic64 differ only in the bottom bit.
-	var ident [4]uint8;
+	var ident [4]uint8
 	if _, err := r.ReadAt(&ident, 0); err != nil {
 		return nil, err
 	}
-	be := binary.BigEndian.Uint32(&ident);
-	le := binary.LittleEndian.Uint32(&ident);
+	be := binary.BigEndian.Uint32(&ident)
+	le := binary.LittleEndian.Uint32(&ident)
 	switch Magic32 &^ 1 {
 	case be &^ 1:
-		f.ByteOrder = binary.BigEndian;
-		f.Magic = be;
+		f.ByteOrder = binary.BigEndian
+		f.Magic = be
 	case le &^ 1:
-		f.ByteOrder = binary.LittleEndian;
-		f.Magic = le;
+		f.ByteOrder = binary.LittleEndian
+		f.Magic = le
 	}
 
 	// Read entire file header.
@@ -188,138 +188,138 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 	}
 
 	// Then load commands.
-	offset := int64(fileHeaderSize32);
+	offset := int64(fileHeaderSize32)
 	if f.Magic == Magic64 {
 		offset = fileHeaderSize64
 	}
-	dat := make([]byte, f.Cmdsz);
+	dat := make([]byte, f.Cmdsz)
 	if _, err := r.ReadAt(dat, offset); err != nil {
 		return nil, err
 	}
-	f.Loads = make([]Load, f.Ncmd);
-	bo := f.ByteOrder;
+	f.Loads = make([]Load, f.Ncmd)
+	bo := f.ByteOrder
 	for i := range f.Loads {
 		// Each load command begins with uint32 command and length.
 		if len(dat) < 8 {
 			return nil, &FormatError{offset, "command block too small", nil}
 		}
-		cmd, siz := LoadCmd(bo.Uint32(dat[0:4])), bo.Uint32(dat[4:8]);
+		cmd, siz := LoadCmd(bo.Uint32(dat[0:4])), bo.Uint32(dat[4:8])
 		if siz < 8 || siz > uint32(len(dat)) {
 			return nil, &FormatError{offset, "invalid command block size", nil}
 		}
-		var cmddat []byte;
-		cmddat, dat = dat[0:siz], dat[siz:];
-		offset += int64(siz);
-		var s *Segment;
+		var cmddat []byte
+		cmddat, dat = dat[0:siz], dat[siz:]
+		offset += int64(siz)
+		var s *Segment
 		switch cmd {
 		default:
 			f.Loads[i] = LoadBytes(cmddat)
 
 		case LoadCmdSegment:
-			var seg32 Segment32;
-			b := bytes.NewBuffer(cmddat);
+			var seg32 Segment32
+			b := bytes.NewBuffer(cmddat)
 			if err := binary.Read(b, bo, &seg32); err != nil {
 				return nil, err
 			}
-			s = new(Segment);
-			s.LoadBytes = cmddat;
-			s.Cmd = cmd;
-			s.Len = siz;
-			s.Name = cstring(&seg32.Name);
-			s.Addr = uint64(seg32.Addr);
-			s.Memsz = uint64(seg32.Memsz);
-			s.Offset = uint64(seg32.Offset);
-			s.Filesz = uint64(seg32.Filesz);
-			s.Maxprot = seg32.Maxprot;
-			s.Prot = seg32.Prot;
-			s.Nsect = seg32.Nsect;
-			s.Flag = seg32.Flag;
-			f.Loads[i] = s;
+			s = new(Segment)
+			s.LoadBytes = cmddat
+			s.Cmd = cmd
+			s.Len = siz
+			s.Name = cstring(&seg32.Name)
+			s.Addr = uint64(seg32.Addr)
+			s.Memsz = uint64(seg32.Memsz)
+			s.Offset = uint64(seg32.Offset)
+			s.Filesz = uint64(seg32.Filesz)
+			s.Maxprot = seg32.Maxprot
+			s.Prot = seg32.Prot
+			s.Nsect = seg32.Nsect
+			s.Flag = seg32.Flag
+			f.Loads[i] = s
 			for i := 0; i < int(s.Nsect); i++ {
-				var sh32 Section32;
+				var sh32 Section32
 				if err := binary.Read(b, bo, &sh32); err != nil {
 					return nil, err
 				}
-				sh := new(Section);
-				sh.Name = cstring(&sh32.Name);
-				sh.Seg = cstring(&sh32.Seg);
-				sh.Addr = uint64(sh32.Addr);
-				sh.Size = uint64(sh32.Size);
-				sh.Offset = sh32.Offset;
-				sh.Align = sh32.Align;
-				sh.Reloff = sh32.Reloff;
-				sh.Nreloc = sh32.Nreloc;
-				sh.Flags = sh32.Flags;
-				f.pushSection(sh, r);
+				sh := new(Section)
+				sh.Name = cstring(&sh32.Name)
+				sh.Seg = cstring(&sh32.Seg)
+				sh.Addr = uint64(sh32.Addr)
+				sh.Size = uint64(sh32.Size)
+				sh.Offset = sh32.Offset
+				sh.Align = sh32.Align
+				sh.Reloff = sh32.Reloff
+				sh.Nreloc = sh32.Nreloc
+				sh.Flags = sh32.Flags
+				f.pushSection(sh, r)
 			}
 
 		case LoadCmdSegment64:
-			var seg64 Segment64;
-			b := bytes.NewBuffer(cmddat);
+			var seg64 Segment64
+			b := bytes.NewBuffer(cmddat)
 			if err := binary.Read(b, bo, &seg64); err != nil {
 				return nil, err
 			}
-			s = new(Segment);
-			s.LoadBytes = cmddat;
-			s.Cmd = cmd;
-			s.Len = siz;
-			s.Name = cstring(&seg64.Name);
-			s.Addr = seg64.Addr;
-			s.Memsz = seg64.Memsz;
-			s.Offset = seg64.Offset;
-			s.Filesz = seg64.Filesz;
-			s.Maxprot = seg64.Maxprot;
-			s.Prot = seg64.Prot;
-			s.Nsect = seg64.Nsect;
-			s.Flag = seg64.Flag;
-			f.Loads[i] = s;
+			s = new(Segment)
+			s.LoadBytes = cmddat
+			s.Cmd = cmd
+			s.Len = siz
+			s.Name = cstring(&seg64.Name)
+			s.Addr = seg64.Addr
+			s.Memsz = seg64.Memsz
+			s.Offset = seg64.Offset
+			s.Filesz = seg64.Filesz
+			s.Maxprot = seg64.Maxprot
+			s.Prot = seg64.Prot
+			s.Nsect = seg64.Nsect
+			s.Flag = seg64.Flag
+			f.Loads[i] = s
 			for i := 0; i < int(s.Nsect); i++ {
-				var sh64 Section64;
+				var sh64 Section64
 				if err := binary.Read(b, bo, &sh64); err != nil {
 					return nil, err
 				}
-				sh := new(Section);
-				sh.Name = cstring(&sh64.Name);
-				sh.Seg = cstring(&sh64.Seg);
-				sh.Addr = sh64.Addr;
-				sh.Size = sh64.Size;
-				sh.Offset = sh64.Offset;
-				sh.Align = sh64.Align;
-				sh.Reloff = sh64.Reloff;
-				sh.Nreloc = sh64.Nreloc;
-				sh.Flags = sh64.Flags;
-				f.pushSection(sh, r);
+				sh := new(Section)
+				sh.Name = cstring(&sh64.Name)
+				sh.Seg = cstring(&sh64.Seg)
+				sh.Addr = sh64.Addr
+				sh.Size = sh64.Size
+				sh.Offset = sh64.Offset
+				sh.Align = sh64.Align
+				sh.Reloff = sh64.Reloff
+				sh.Nreloc = sh64.Nreloc
+				sh.Flags = sh64.Flags
+				f.pushSection(sh, r)
 			}
 		}
 		if s != nil {
-			s.sr = io.NewSectionReader(r, int64(s.Offset), int64(s.Filesz));
-			s.ReaderAt = s.sr;
+			s.sr = io.NewSectionReader(r, int64(s.Offset), int64(s.Filesz))
+			s.ReaderAt = s.sr
 		}
 	}
-	return f, nil;
+	return f, nil
 }
 
 func (f *File) pushSection(sh *Section, r io.ReaderAt) {
-	n := len(f.Sections);
+	n := len(f.Sections)
 	if n >= cap(f.Sections) {
-		m := (n + 1) * 2;
-		new := make([]*Section, n, m);
+		m := (n + 1) * 2
+		new := make([]*Section, n, m)
 		for i, sh := range f.Sections {
 			new[i] = sh
 		}
-		f.Sections = new;
+		f.Sections = new
 	}
-	f.Sections = f.Sections[0 : n+1];
-	f.Sections[n] = sh;
-	sh.sr = io.NewSectionReader(r, int64(sh.Offset), int64(sh.Size));
-	sh.ReaderAt = sh.sr;
+	f.Sections = f.Sections[0 : n+1]
+	f.Sections[n] = sh
+	sh.sr = io.NewSectionReader(r, int64(sh.Offset), int64(sh.Size))
+	sh.ReaderAt = sh.sr
 }
 
 func cstring(b []byte) string {
-	var i int;
+	var i int
 	for i = 0; i < len(b) && b[i] != 0; i++ {
 	}
-	return string(b[0:i]);
+	return string(b[0:i])
 }
 
 // Segment returns the first Segment with the given name, or nil if no such segment exists.
@@ -329,7 +329,7 @@ func (f *File) Segment(name string) *Segment {
 			return s
 		}
 	}
-	return nil;
+	return nil
 }
 
 // Section returns the first section with the given name, or nil if no such
@@ -340,7 +340,7 @@ func (f *File) Section(name string) *Section {
 			return s
 		}
 	}
-	return nil;
+	return nil
 }
 
 // DWARF returns the DWARF debug information for the Mach-O file.
@@ -348,21 +348,21 @@ func (f *File) DWARF() (*dwarf.Data, os.Error) {
 	// There are many other DWARF sections, but these
 	// are the required ones, and the debug/dwarf package
 	// does not use the others, so don't bother loading them.
-	var names = [...]string{"abbrev", "info", "str"};
-	var dat [len(names)][]byte;
+	var names = [...]string{"abbrev", "info", "str"}
+	var dat [len(names)][]byte
 	for i, name := range names {
-		name = "__debug_" + name;
-		s := f.Section(name);
+		name = "__debug_" + name
+		s := f.Section(name)
 		if s == nil {
 			return nil, os.NewError("missing Mach-O section " + name)
 		}
-		b, err := s.Data();
+		b, err := s.Data()
 		if err != nil && uint64(len(b)) < s.Size {
 			return nil, err
 		}
-		dat[i] = b;
+		dat[i] = b
 	}
 
-	abbrev, info, str := dat[0], dat[1], dat[2];
-	return dwarf.New(abbrev, nil, nil, info, nil, nil, nil, str);
+	abbrev, info, str := dat[0], dat[1], dat[2]
+	return dwarf.New(abbrev, nil, nil, info, nil, nil, nil, str)
 }
diff --git a/src/pkg/debug/macho/file_test.go b/src/pkg/debug/macho/file_test.go
index e1d75da15f..d69e49cbfe 100644
--- a/src/pkg/debug/macho/file_test.go
+++ b/src/pkg/debug/macho/file_test.go
@@ -5,15 +5,15 @@
 package macho
 
 import (
-	"reflect";
-	"testing";
+	"reflect"
+	"testing"
 )
 
 type fileTest struct {
-	file		string;
-	hdr		FileHeader;
-	segments	[]*SegmentHeader;
-	sections	[]*SectionHeader;
+	file     string
+	hdr      FileHeader
+	segments []*SegmentHeader
+	sections []*SectionHeader
 }
 
 var fileTests = []fileTest{
@@ -100,41 +100,41 @@ var fileTests = []fileTest{
 
 func TestOpen(t *testing.T) {
 	for i := range fileTests {
-		tt := &fileTests[i];
+		tt := &fileTests[i]
 
-		f, err := Open(tt.file);
+		f, err := Open(tt.file)
 		if err != nil {
-			t.Error(err);
-			continue;
+			t.Error(err)
+			continue
 		}
 		if !reflect.DeepEqual(f.FileHeader, tt.hdr) {
-			t.Errorf("open %s:\n\thave %#v\n\twant %#v\n", tt.file, f.FileHeader, tt.hdr);
-			continue;
+			t.Errorf("open %s:\n\thave %#v\n\twant %#v\n", tt.file, f.FileHeader, tt.hdr)
+			continue
 		}
 		for i, l := range f.Loads {
 			if i >= len(tt.segments) {
 				break
 			}
-			sh := tt.segments[i];
-			s, ok := l.(*Segment);
+			sh := tt.segments[i]
+			s, ok := l.(*Segment)
 			if sh == nil {
 				if ok {
 					t.Errorf("open %s, section %d: skipping %#v\n", tt.file, i, &s.SegmentHeader)
 				}
-				continue;
+				continue
 			}
 			if !ok {
-				t.Errorf("open %s, section %d: not *Segment\n", tt.file, i);
-				continue;
+				t.Errorf("open %s, section %d: not *Segment\n", tt.file, i)
+				continue
 			}
-			have := &s.SegmentHeader;
-			want := sh;
+			have := &s.SegmentHeader
+			want := sh
 			if !reflect.DeepEqual(have, want) {
 				t.Errorf("open %s, segment %d:\n\thave %#v\n\twant %#v\n", tt.file, i, have, want)
 			}
 		}
-		tn := len(tt.segments);
-		fn := len(f.Loads);
+		tn := len(tt.segments)
+		fn := len(f.Loads)
 		if tn != fn {
 			t.Errorf("open %s: len(Loads) = %d, want %d", tt.file, fn, tn)
 		}
@@ -143,14 +143,14 @@ func TestOpen(t *testing.T) {
 			if i >= len(tt.sections) {
 				break
 			}
-			have := &sh.SectionHeader;
-			want := tt.sections[i];
+			have := &sh.SectionHeader
+			want := tt.sections[i]
 			if !reflect.DeepEqual(have, want) {
 				t.Errorf("open %s, section %d:\n\thave %#v\n\twant %#v\n", tt.file, i, have, want)
 			}
 		}
-		tn = len(tt.sections);
-		fn = len(f.Sections);
+		tn = len(tt.sections)
+		fn = len(f.Sections)
 		if tn != fn {
 			t.Errorf("open %s: len(Sections) = %d, want %d", tt.file, fn, tn)
 		}
diff --git a/src/pkg/debug/macho/macho.go b/src/pkg/debug/macho/macho.go
index abc59c8a6d..41962d5624 100644
--- a/src/pkg/debug/macho/macho.go
+++ b/src/pkg/debug/macho/macho.go
@@ -11,39 +11,39 @@ import "strconv"
 
 // A FileHeader represents a Mach-O file header.
 type FileHeader struct {
-	Magic	uint32;
-	Cpu	Cpu;
-	SubCpu	uint32;
-	Type	Type;
-	Ncmd	uint32;
-	Cmdsz	uint32;
-	Flags	uint32;
+	Magic  uint32
+	Cpu    Cpu
+	SubCpu uint32
+	Type   Type
+	Ncmd   uint32
+	Cmdsz  uint32
+	Flags  uint32
 }
 
 const (
-	fileHeaderSize32	= 7 * 4;
-	fileHeaderSize64	= 8 * 4;
+	fileHeaderSize32 = 7 * 4
+	fileHeaderSize64 = 8 * 4
 )
 
 const (
-	Magic32	uint32	= 0xfeedface;
-	Magic64	uint32	= 0xfeedfacf;
+	Magic32 uint32 = 0xfeedface
+	Magic64 uint32 = 0xfeedfacf
 )
 
 // A Type is a Mach-O file type, either an object or an executable.
 type Type uint32
 
 const (
-	TypeObj		Type	= 1;
-	TypeExec	Type	= 2;
+	TypeObj  Type = 1
+	TypeExec Type = 2
 )
 
 // A Cpu is a Mach-O cpu type.
 type Cpu uint32
 
 const (
-	Cpu386		Cpu	= 7;
-	CpuAmd64	Cpu	= Cpu386 + 1<<24;
+	Cpu386   Cpu = 7
+	CpuAmd64 Cpu = Cpu386 + 1<<24
 )
 
 var cpuStrings = []intName{
@@ -51,17 +51,17 @@ var cpuStrings = []intName{
 	intName{uint32(CpuAmd64), "CpuAmd64"},
 }
 
-func (i Cpu) String() string	{ return stringName(uint32(i), cpuStrings, false) }
-func (i Cpu) GoString() string	{ return stringName(uint32(i), cpuStrings, true) }
+func (i Cpu) String() string   { return stringName(uint32(i), cpuStrings, false) }
+func (i Cpu) GoString() string { return stringName(uint32(i), cpuStrings, true) }
 
 // A LoadCmd is a Mach-O load command.
 type LoadCmd uint32
 
 const (
-	LoadCmdSegment		LoadCmd	= 1;
-	LoadCmdSegment64	LoadCmd	= 25;
-	LoadCmdThread		LoadCmd	= 4;
-	LoadCmdUnixThread	LoadCmd	= 5;	// thread+stack
+	LoadCmdSegment    LoadCmd = 1
+	LoadCmdSegment64  LoadCmd = 25
+	LoadCmdThread     LoadCmd = 4
+	LoadCmdUnixThread LoadCmd = 5 // thread+stack
 )
 
 var cmdStrings = []intName{
@@ -71,126 +71,126 @@ var cmdStrings = []intName{
 	intName{uint32(LoadCmdUnixThread), "LoadCmdUnixThread"},
 }
 
-func (i LoadCmd) String() string	{ return stringName(uint32(i), cmdStrings, false) }
-func (i LoadCmd) GoString() string	{ return stringName(uint32(i), cmdStrings, true) }
+func (i LoadCmd) String() string   { return stringName(uint32(i), cmdStrings, false) }
+func (i LoadCmd) GoString() string { return stringName(uint32(i), cmdStrings, true) }
 
 // A Segment64 is a 64-bit Mach-O segment load command.
 type Segment64 struct {
-	Cmd	LoadCmd;
-	Len	uint32;
-	Name	[16]byte;
-	Addr	uint64;
-	Memsz	uint64;
-	Offset	uint64;
-	Filesz	uint64;
-	Maxprot	uint32;
-	Prot	uint32;
-	Nsect	uint32;
-	Flag	uint32;
+	Cmd     LoadCmd
+	Len     uint32
+	Name    [16]byte
+	Addr    uint64
+	Memsz   uint64
+	Offset  uint64
+	Filesz  uint64
+	Maxprot uint32
+	Prot    uint32
+	Nsect   uint32
+	Flag    uint32
 }
 
 // A Segment32 is a 32-bit Mach-O segment load command.
 type Segment32 struct {
-	Cmd	LoadCmd;
-	Len	uint32;
-	Name	[16]byte;
-	Addr	uint32;
-	Memsz	uint32;
-	Offset	uint32;
-	Filesz	uint32;
-	Maxprot	uint32;
-	Prot	uint32;
-	Nsect	uint32;
-	Flag	uint32;
+	Cmd     LoadCmd
+	Len     uint32
+	Name    [16]byte
+	Addr    uint32
+	Memsz   uint32
+	Offset  uint32
+	Filesz  uint32
+	Maxprot uint32
+	Prot    uint32
+	Nsect   uint32
+	Flag    uint32
 }
 
 // A Section32 is a 32-bit Mach-O section header.
 type Section32 struct {
-	Name		[16]byte;
-	Seg		[16]byte;
-	Addr		uint32;
-	Size		uint32;
-	Offset		uint32;
-	Align		uint32;
-	Reloff		uint32;
-	Nreloc		uint32;
-	Flags		uint32;
-	Reserve1	uint32;
-	Reserve2	uint32;
+	Name     [16]byte
+	Seg      [16]byte
+	Addr     uint32
+	Size     uint32
+	Offset   uint32
+	Align    uint32
+	Reloff   uint32
+	Nreloc   uint32
+	Flags    uint32
+	Reserve1 uint32
+	Reserve2 uint32
 }
 
 // A Section32 is a 64-bit Mach-O section header.
 type Section64 struct {
-	Name		[16]byte;
-	Seg		[16]byte;
-	Addr		uint64;
-	Size		uint64;
-	Offset		uint32;
-	Align		uint32;
-	Reloff		uint32;
-	Nreloc		uint32;
-	Flags		uint32;
-	Reserve1	uint32;
-	Reserve2	uint32;
-	Reserve3	uint32;
+	Name     [16]byte
+	Seg      [16]byte
+	Addr     uint64
+	Size     uint64
+	Offset   uint32
+	Align    uint32
+	Reloff   uint32
+	Nreloc   uint32
+	Flags    uint32
+	Reserve1 uint32
+	Reserve2 uint32
+	Reserve3 uint32
 }
 
 // A Thread is a Mach-O thread state command.
 type Thread struct {
-	Cmd	LoadCmd;
-	Len	uint32;
-	Type	uint32;
-	Data	[]uint32;
+	Cmd  LoadCmd
+	Len  uint32
+	Type uint32
+	Data []uint32
 }
 
 // Regs386 is the Mach-O 386 register structure.
 type Regs386 struct {
-	AX	uint32;
-	BX	uint32;
-	CX	uint32;
-	DX	uint32;
-	DI	uint32;
-	SI	uint32;
-	BP	uint32;
-	SP	uint32;
-	SS	uint32;
-	FLAGS	uint32;
-	IP	uint32;
-	CS	uint32;
-	DS	uint32;
-	ES	uint32;
-	FS	uint32;
-	GS	uint32;
+	AX    uint32
+	BX    uint32
+	CX    uint32
+	DX    uint32
+	DI    uint32
+	SI    uint32
+	BP    uint32
+	SP    uint32
+	SS    uint32
+	FLAGS uint32
+	IP    uint32
+	CS    uint32
+	DS    uint32
+	ES    uint32
+	FS    uint32
+	GS    uint32
 }
 
 // RegsAMD64 is the Mach-O AMD64 register structure.
 type RegsAMD64 struct {
-	AX	uint64;
-	BX	uint64;
-	CX	uint64;
-	DX	uint64;
-	DI	uint64;
-	SI	uint64;
-	BP	uint64;
-	SP	uint64;
-	R8	uint64;
-	R9	uint64;
-	R10	uint64;
-	R11	uint64;
-	R12	uint64;
-	R13	uint64;
-	R14	uint64;
-	R15	uint64;
-	IP	uint64;
-	FLAGS	uint64;
-	CS	uint64;
-	FS	uint64;
-	GS	uint64;
+	AX    uint64
+	BX    uint64
+	CX    uint64
+	DX    uint64
+	DI    uint64
+	SI    uint64
+	BP    uint64
+	SP    uint64
+	R8    uint64
+	R9    uint64
+	R10   uint64
+	R11   uint64
+	R12   uint64
+	R13   uint64
+	R14   uint64
+	R15   uint64
+	IP    uint64
+	FLAGS uint64
+	CS    uint64
+	FS    uint64
+	GS    uint64
 }
 
 type intName struct {
-	i	uint32;
-	s	string;
+	i uint32
+	s string
 }
 
 func stringName(i uint32, names []intName, goSyntax bool) string {
@@ -199,14 +199,14 @@ func stringName(i uint32, names []intName, goSyntax bool) string {
 			if goSyntax {
 				return "macho." + n.s
 			}
-			return n.s;
+			return n.s
 		}
 	}
-	return strconv.Uitoa64(uint64(i));
+	return strconv.Uitoa64(uint64(i))
 }
 
 func flagName(i uint32, names []intName, goSyntax bool) string {
-	s := "";
+	s := ""
 	for _, n := range names {
 		if n.i&i == n.i {
 			if len(s) > 0 {
@@ -215,8 +215,8 @@ func flagName(i uint32, names []intName, goSyntax bool) string {
 			if goSyntax {
 				s += "macho."
 			}
-			s += n.s;
-			i -= n.i;
+			s += n.s
+			i -= n.i
 		}
 	}
 	if len(s) == 0 {
@@ -225,5 +225,5 @@ func flagName(i uint32, names []intName, goSyntax bool) string {
 	if i != 0 {
 		s += "+0x" + strconv.Uitob64(uint64(i), 16)
 	}
-	return s;
+	return s
 }
diff --git a/src/pkg/debug/proc/proc.go b/src/pkg/debug/proc/proc.go
index 7f8e778c6f..d5341a7458 100644
--- a/src/pkg/debug/proc/proc.go
+++ b/src/pkg/debug/proc/proc.go
@@ -13,22 +13,22 @@ package proc
 // and proc_darwin.go do, because deps.bash only looks at
 // this file.
 import (
-	_ "container/vector";
-	_ "fmt";
-	_ "io";
-	"os";
-	_ "runtime";
-	"strconv";
-	_ "strings";
-	_ "sync";
-	_ "syscall";
+	_ "container/vector"
+	_ "fmt"
+	_ "io"
+	"os"
+	_ "runtime"
+	"strconv"
+	_ "strings"
+	_ "sync"
+	_ "syscall"
 )
 
 type Word uint64
 
 // A Cause explains why a thread is stopped.
 type Cause interface {
-	String() string;
+	String() string
 }
 
 // Regs is a set of named machine registers, including a program
@@ -42,33 +42,33 @@ type Cause interface {
 // other per-register information like how to print it.
 type Regs interface {
 	// PC returns the value of the program counter.
-	PC() Word;
+	PC() Word
 
 	// SetPC sets the program counter to val.
-	SetPC(val Word) os.Error;
+	SetPC(val Word) os.Error
 
 	// Link returns the link register, if any.
-	Link() Word;
+	Link() Word
 
 	// SetLink sets the link register to val.
-	SetLink(val Word) os.Error;
+	SetLink(val Word) os.Error
 
 	// SP returns the value of the stack pointer.
-	SP() Word;
+	SP() Word
 
 	// SetSP sets the stack pointer register to val.
-	SetSP(val Word) os.Error;
+	SetSP(val Word) os.Error
 
 	// Names returns the names of all of the registers.
-	Names() []string;
+	Names() []string
 
 	// Get returns the value of a register, where i corresponds to
 	// the index of the register's name in the array returned by
 	// Names.
-	Get(i int) Word;
+	Get(i int) Word
 
 	// Set sets the value of a register.
-	Set(i int, val Word) os.Error;
+	Set(i int, val Word) os.Error
 }
 
 // Thread is a thread in the process being traced.
@@ -78,15 +78,15 @@ type Thread interface {
 	// breakpoint, this will step over the breakpoint.
 	//
 	// XXX What if it's stopped because of a signal?
-	Step() os.Error;
+	Step() os.Error
 
 	// Stopped returns the reason that this thread is stopped.  It
 	// is an error is the thread not stopped.
-	Stopped() (Cause, os.Error);
+	Stopped() (Cause, os.Error)
 
 	// Regs retrieves the current register values from this
 	// thread.  The thread must be stopped.
-	Regs() (Regs, os.Error);
+	Regs() (Regs, os.Error)
 
 	// Peek reads len(out) bytes from the address addr in this
 	// thread into out.  The thread must be stopped.  It returns
@@ -95,7 +95,7 @@ type Thread interface {
 	// could be short and an error will be returned.  If this does
 	// encounter unmapped memory, it will read up to the byte
 	// preceding the unmapped area.
-	Peek(addr Word, out []byte) (int, os.Error);
+	Peek(addr Word, out []byte) (int, os.Error)
 
 	// Poke writes b to the address addr in this thread.  The
 	// thread must be stopped.  It returns the number of bytes
@@ -104,7 +104,7 @@ type Thread interface {
 	// short and an error will be returned.  If this does
 	// encounter unmapped memory, it will write up to the byte
 	// preceding the unmapped area.
-	Poke(addr Word, b []byte) (int, os.Error);
+	Poke(addr Word, b []byte) (int, os.Error)
 }
 
 // Process is a process being traced.  It consists of a set of
@@ -112,37 +112,37 @@ type Thread interface {
 // process's state extends to all of its threads.
 type Process interface {
 	// Threads returns an array of all threads in this process.
-	Threads() []Thread;
+	Threads() []Thread
 
 	// AddBreakpoint creates a new breakpoint at program counter
 	// pc.  Breakpoints can only be created when the process is
 	// stopped.  It is an error if a breakpoint already exists at
 	// pc.
-	AddBreakpoint(pc Word) os.Error;
+	AddBreakpoint(pc Word) os.Error
 
 	// RemoveBreakpoint removes the breakpoint at the program
 	// counter pc.  It is an error if no breakpoint exists at pc.
-	RemoveBreakpoint(pc Word) os.Error;
+	RemoveBreakpoint(pc Word) os.Error
 
 	// Stop stops all running threads in this process before
 	// returning.
-	Stop() os.Error;
+	Stop() os.Error
 
 	// Continue resumes execution of all threads in this process.
 	// Any thread that is stopped on a breakpoint will be stepped
 	// over that breakpoint.  Any thread that is stopped because
 	// of a signal (other than SIGSTOP or SIGTRAP) will receive
 	// the pending signal.
-	Continue() os.Error;
+	Continue() os.Error
 
 	// WaitStop waits until all threads in process p are stopped
 	// as a result of some thread hitting a breakpoint, receiving
 	// a signal, creating a new thread, or exiting.
-	WaitStop() os.Error;
+	WaitStop() os.Error
 
 	// Detach detaches from this process.  All stopped threads
 	// will be resumed.
-	Detach() os.Error;
+	Detach() os.Error
 }
 
 // Stopped is a stop cause used for threads that are stopped either by
@@ -151,14 +151,14 @@ type Process interface {
 // stop.
 type Stopped struct{}
 
-func (c Stopped) String() string	{ return "stopped" }
+func (c Stopped) String() string { return "stopped" }
 
 // Breakpoint is a stop cause resulting from a thread reaching a set
 // breakpoint.
 type Breakpoint Word
 
 // PC returns the program counter that the program is stopped at.
-func (c Breakpoint) PC() Word	{ return Word(c) }
+func (c Breakpoint) PC() Word { return Word(c) }
 
 func (c Breakpoint) String() string {
 	return "breakpoint at 0x" + strconv.Uitob64(uint64(c.PC()), 16)
@@ -169,47 +169,47 @@ func (c Breakpoint) String() string {
 type Signal string
 
 // Signal returns the signal being delivered to the thread.
-func (c Signal) Name() string	{ return string(c) }
+func (c Signal) Name() string { return string(c) }
 
-func (c Signal) String() string	{ return c.Name() }
+func (c Signal) String() string { return c.Name() }
 
 // ThreadCreate is a stop cause returned from an existing thread when
 // it creates a new thread.  The new thread exists in a primordial
 // form at this point and will begin executing in earnest when the
 // process is continued.
 type ThreadCreate struct {
-	thread Thread;
+	thread Thread
 }
 
-func (c *ThreadCreate) NewThread() Thread	{ return c.thread }
+func (c *ThreadCreate) NewThread() Thread { return c.thread }
 
-func (c *ThreadCreate) String() string	{ return "thread create" }
+func (c *ThreadCreate) String() string { return "thread create" }
 
 // ThreadExit is a stop cause resulting from a thread exiting.  When
 // this cause first arises, the thread will still be in the list of
 // process threads and its registers and memory will still be
 // accessible.
 type ThreadExit struct {
-	exitStatus	int;
-	signal		string;
+	exitStatus int
+	signal     string
 }
 
 // Exited returns true if the thread exited normally.
-func (c *ThreadExit) Exited() bool	{ return c.exitStatus != -1 }
+func (c *ThreadExit) Exited() bool { return c.exitStatus != -1 }
 
 // ExitStatus returns the exit status of the thread if it exited
 // normally or -1 otherwise.
-func (c *ThreadExit) ExitStatus() int	{ return c.exitStatus }
+func (c *ThreadExit) ExitStatus() int { return c.exitStatus }
 
 // Signaled returns true if the thread was terminated by a signal.
-func (c *ThreadExit) Signaled() bool	{ return c.exitStatus == -1 }
+func (c *ThreadExit) Signaled() bool { return c.exitStatus == -1 }
 
 // StopSignal returns the signal that terminated the thread, or "" if
 // it was not terminated by a signal.
-func (c *ThreadExit) StopSignal() string	{ return c.signal }
+func (c *ThreadExit) StopSignal() string { return c.signal }
 
 func (c *ThreadExit) String() string {
-	res := "thread exited ";
+	res := "thread exited "
 	switch {
 	case c.Exited():
 		res += "with status " + strconv.Itoa(c.ExitStatus())
@@ -218,5 +218,5 @@ func (c *ThreadExit) String() string {
 	default:
 		res += "from unknown cause"
 	}
-	return res;
+	return res
 }
diff --git a/src/pkg/debug/proc/proc_linux.go b/src/pkg/debug/proc/proc_linux.go
index b7192580d7..7273e97d84 100644
--- a/src/pkg/debug/proc/proc_linux.go
+++ b/src/pkg/debug/proc/proc_linux.go
@@ -7,15 +7,15 @@ package proc
 // TODO(rsc): Imports here after to be in proc.go too in order
 // for deps.bash to get the right answer.
 import (
-	"container/vector";
-	"fmt";
-	"io/ioutil";
-	"os";
-	"runtime";
-	"strconv";
-	"strings";
-	"sync";
-	"syscall";
+	"container/vector"
+	"fmt"
+	"io/ioutil"
+	"os"
+	"runtime"
+	"strconv"
+	"strings"
+	"sync"
+	"syscall"
 )
 
 // This is an implementation of the process tracing interface using
@@ -35,9 +35,9 @@ import (
 // as well as experimentation and examination of gdb's behavior.
 
 const (
-	trace		= false;
-	traceIP		= false;
-	traceMem	= false;
+	trace    = false
+	traceIP  = false
+	traceMem = false
 )
 
 /*
@@ -63,17 +63,17 @@ const (
 type threadState string
 
 const (
-	running			threadState	= "Running";
-	singleStepping		threadState	= "SingleStepping";	// Transient
-	stopping		threadState	= "Stopping";		// Transient
-	stopped			threadState	= "Stopped";
-	stoppedBreakpoint	threadState	= "StoppedBreakpoint";
-	stoppedSignal		threadState	= "StoppedSignal";
-	stoppedThreadCreate	threadState	= "StoppedThreadCreate";
-	stoppedExiting		threadState	= "StoppedExiting";
-	exiting			threadState	= "Exiting";	// Transient (except main thread)
-	exited			threadState	= "Exited";
-	detached		threadState	= "Detached";
+	running             threadState = "Running"
+	singleStepping      threadState = "SingleStepping" // Transient
+	stopping            threadState = "Stopping"       // Transient
+	stopped             threadState = "Stopped"
+	stoppedBreakpoint   threadState = "StoppedBreakpoint"
+	stoppedSignal       threadState = "StoppedSignal"
+	stoppedThreadCreate threadState = "StoppedThreadCreate"
+	stoppedExiting      threadState = "StoppedExiting"
+	exiting             threadState = "Exiting" // Transient (except main thread)
+	exited              threadState = "Exited"
+	detached            threadState = "Detached"
 )
 
 func (ts threadState) isRunning() bool {
@@ -84,11 +84,11 @@ func (ts threadState) isStopped() bool {
 	return ts == stopped || ts == stoppedBreakpoint || ts == stoppedSignal || ts == stoppedThreadCreate || ts == stoppedExiting
 }
 
-func (ts threadState) isZombie() bool	{ return ts == exiting }
+func (ts threadState) isZombie() bool { return ts == exiting }
 
-func (ts threadState) isTerminal() bool	{ return ts == exited || ts == detached }
+func (ts threadState) isTerminal() bool { return ts == exited || ts == detached }
 
-func (ts threadState) String() string	{ return string(ts) }
+func (ts threadState) String() string { return string(ts) }
 
 /*
  * Basic types
@@ -98,15 +98,15 @@ func (ts threadState) String() string	{ return string(ts) }
 // including its program counter, the overwritten text if the
 // breakpoint is installed.
 type breakpoint struct {
-	pc	uintptr;
-	olddata	[]byte;
+	pc      uintptr
+	olddata []byte
 }
 
 func (bp *breakpoint) String() string {
 	if bp == nil {
 		return "<nil>"
 	}
-	return fmt.Sprintf("%#x", bp.pc);
+	return fmt.Sprintf("%#x", bp.pc)
 }
 
 // bpinst386 is the breakpoint instruction used on 386 and amd64.
@@ -114,15 +114,15 @@ var bpinst386 = []byte{0xcc}
 
 // A debugEvent represents a reason a thread stopped or a wait error.
 type debugEvent struct {
-	*os.Waitmsg;
-	t	*thread;
-	err	os.Error;
+	*os.Waitmsg
+	t   *thread
+	err os.Error
 }
 
 // A debugReq is a request to execute a closure in the monitor thread.
 type debugReq struct {
-	f	func() os.Error;
-	res	chan os.Error;
+	f   func() os.Error
+	res chan os.Error
 }
 
 // A transitionHandler specifies a function to be called when a thread
@@ -131,8 +131,8 @@ type debugReq struct {
 // invokes a handler, it removes the handler from the handler queue.
 // The handler should re-add itself if needed.
 type transitionHandler struct {
-	handle	func(*thread, threadState, threadState);
-	onErr	func(os.Error);
+	handle func(*thread, threadState, threadState)
+	onErr  func(os.Error)
 }
 
 // A process is a Linux process, which consists of a set of threads.
@@ -146,36 +146,36 @@ type transitionHandler struct {
 // returns false, the monitor is not running (the ready channel has
 // been closed), and the reason it is not running will be stored in err.
 type process struct {
-	pid			int;
-	threads			map[int]*thread;
-	breakpoints		map[uintptr]*breakpoint;
-	ready			chan bool;
-	debugEvents		chan *debugEvent;
-	debugReqs		chan *debugReq;
-	stopReq			chan os.Error;
-	transitionHandlers	*vector.Vector;
-	err			os.Error;
+	pid                int
+	threads            map[int]*thread
+	breakpoints        map[uintptr]*breakpoint
+	ready              chan bool
+	debugEvents        chan *debugEvent
+	debugReqs          chan *debugReq
+	stopReq            chan os.Error
+	transitionHandlers *vector.Vector
+	err                os.Error
 }
 
 // A thread represents a Linux thread in another process that is being
 // debugged.  Each running thread has an associated goroutine that
 // waits for thread updates and sends them to the process monitor.
 type thread struct {
-	tid	int;
-	proc	*process;
+	tid  int
+	proc *process
 	// Whether to ignore the next SIGSTOP received by wait.
-	ignoreNextSigstop	bool;
+	ignoreNextSigstop bool
 
 	// Thread state.  Only modified via setState.
-	state	threadState;
+	state threadState
 	// If state == StoppedBreakpoint
-	breakpoint	*breakpoint;
+	breakpoint *breakpoint
 	// If state == StoppedSignal or state == Exited
-	signal	int;
+	signal int
 	// If state == StoppedThreadCreate
-	newThread	*thread;
+	newThread *thread
 	// If state == Exited
-	exitStatus	int;
+	exitStatus int
 }
 
 /*
@@ -183,9 +183,9 @@ type thread struct {
  */
 
 type badState struct {
-	thread	*thread;
-	message	string;
-	state	threadState;
+	thread  *thread
+	message string
+	state   threadState
 }
 
 func (e *badState) String() string {
@@ -200,12 +200,12 @@ func (e breakpointExistsError) String() string {
 
 type noBreakpointError Word
 
-func (e noBreakpointError) String() string	{ return fmt.Sprintf("no breakpoint at PC %#x", e) }
+func (e noBreakpointError) String() string { return fmt.Sprintf("no breakpoint at PC %#x", e) }
 
 type newThreadError struct {
-	*os.Waitmsg;
-	wantPid	int;
-	wantSig	int;
+	*os.Waitmsg
+	wantPid int
+	wantSig int
 }
 
 func (e *newThreadError) String() string {
@@ -214,66 +214,66 @@ func (e *newThreadError) String() string {
 
 type ProcessExited struct{}
 
-func (p ProcessExited) String() string	{ return "process exited" }
+func (p ProcessExited) String() string { return "process exited" }
 
 /*
  * Ptrace wrappers
  */
 
 func (t *thread) ptracePeekText(addr uintptr, out []byte) (int, os.Error) {
-	c, err := syscall.PtracePeekText(t.tid, addr, out);
+	c, err := syscall.PtracePeekText(t.tid, addr, out)
 	if traceMem {
 		fmt.Printf("peek(%#x) => %v, %v\n", addr, out, err)
 	}
-	return c, os.NewSyscallError("ptrace(PEEKTEXT)", err);
+	return c, os.NewSyscallError("ptrace(PEEKTEXT)", err)
 }
 
 func (t *thread) ptracePokeText(addr uintptr, out []byte) (int, os.Error) {
-	c, err := syscall.PtracePokeText(t.tid, addr, out);
+	c, err := syscall.PtracePokeText(t.tid, addr, out)
 	if traceMem {
 		fmt.Printf("poke(%#x, %v) => %v\n", addr, out, err)
 	}
-	return c, os.NewSyscallError("ptrace(POKETEXT)", err);
+	return c, os.NewSyscallError("ptrace(POKETEXT)", err)
 }
 
 func (t *thread) ptraceGetRegs(regs *syscall.PtraceRegs) os.Error {
-	err := syscall.PtraceGetRegs(t.tid, regs);
-	return os.NewSyscallError("ptrace(GETREGS)", err);
+	err := syscall.PtraceGetRegs(t.tid, regs)
+	return os.NewSyscallError("ptrace(GETREGS)", err)
 }
 
 func (t *thread) ptraceSetRegs(regs *syscall.PtraceRegs) os.Error {
-	err := syscall.PtraceSetRegs(t.tid, regs);
-	return os.NewSyscallError("ptrace(SETREGS)", err);
+	err := syscall.PtraceSetRegs(t.tid, regs)
+	return os.NewSyscallError("ptrace(SETREGS)", err)
 }
 
 func (t *thread) ptraceSetOptions(options int) os.Error {
-	err := syscall.PtraceSetOptions(t.tid, options);
-	return os.NewSyscallError("ptrace(SETOPTIONS)", err);
+	err := syscall.PtraceSetOptions(t.tid, options)
+	return os.NewSyscallError("ptrace(SETOPTIONS)", err)
 }
 
 func (t *thread) ptraceGetEventMsg() (uint, os.Error) {
-	msg, err := syscall.PtraceGetEventMsg(t.tid);
-	return msg, os.NewSyscallError("ptrace(GETEVENTMSG)", err);
+	msg, err := syscall.PtraceGetEventMsg(t.tid)
+	return msg, os.NewSyscallError("ptrace(GETEVENTMSG)", err)
 }
 
 func (t *thread) ptraceCont() os.Error {
-	err := syscall.PtraceCont(t.tid, 0);
-	return os.NewSyscallError("ptrace(CONT)", err);
+	err := syscall.PtraceCont(t.tid, 0)
+	return os.NewSyscallError("ptrace(CONT)", err)
 }
 
 func (t *thread) ptraceContWithSignal(sig int) os.Error {
-	err := syscall.PtraceCont(t.tid, sig);
-	return os.NewSyscallError("ptrace(CONT)", err);
+	err := syscall.PtraceCont(t.tid, sig)
+	return os.NewSyscallError("ptrace(CONT)", err)
 }
 
 func (t *thread) ptraceStep() os.Error {
-	err := syscall.PtraceSingleStep(t.tid);
-	return os.NewSyscallError("ptrace(SINGLESTEP)", err);
+	err := syscall.PtraceSingleStep(t.tid)
+	return os.NewSyscallError("ptrace(SINGLESTEP)", err)
 }
 
 func (t *thread) ptraceDetach() os.Error {
-	err := syscall.PtraceDetach(t.tid);
-	return os.NewSyscallError("ptrace(DETACH)", err);
+	err := syscall.PtraceDetach(t.tid)
+	return os.NewSyscallError("ptrace(DETACH)", err)
 }
 
 /*
@@ -286,38 +286,38 @@ func (t *thread) logTrace(format string, args ...) {
 	if !trace {
 		return
 	}
-	logLock.Lock();
-	defer logLock.Unlock();
-	fmt.Fprintf(os.Stderr, "Thread %d", t.tid);
+	logLock.Lock()
+	defer logLock.Unlock()
+	fmt.Fprintf(os.Stderr, "Thread %d", t.tid)
 	if traceIP {
-		var regs syscall.PtraceRegs;
-		err := t.ptraceGetRegs(&regs);
+		var regs syscall.PtraceRegs
+		err := t.ptraceGetRegs(&regs)
 		if err == nil {
 			fmt.Fprintf(os.Stderr, "@%x", regs.PC())
 		}
 	}
-	fmt.Fprint(os.Stderr, ": ");
-	fmt.Fprintf(os.Stderr, format, args);
-	fmt.Fprint(os.Stderr, "\n");
+	fmt.Fprint(os.Stderr, ": ")
+	fmt.Fprintf(os.Stderr, format, args)
+	fmt.Fprint(os.Stderr, "\n")
 }
 
 func (t *thread) warn(format string, args ...) {
-	logLock.Lock();
-	defer logLock.Unlock();
-	fmt.Fprintf(os.Stderr, "Thread %d: WARNING ", t.tid);
-	fmt.Fprintf(os.Stderr, format, args);
-	fmt.Fprint(os.Stderr, "\n");
+	logLock.Lock()
+	defer logLock.Unlock()
+	fmt.Fprintf(os.Stderr, "Thread %d: WARNING ", t.tid)
+	fmt.Fprintf(os.Stderr, format, args)
+	fmt.Fprint(os.Stderr, "\n")
 }
 
 func (p *process) logTrace(format string, args ...) {
 	if !trace {
 		return
 	}
-	logLock.Lock();
-	defer logLock.Unlock();
-	fmt.Fprintf(os.Stderr, "Process %d: ", p.pid);
-	fmt.Fprintf(os.Stderr, format, args);
-	fmt.Fprint(os.Stderr, "\n");
+	logLock.Lock()
+	defer logLock.Unlock()
+	fmt.Fprintf(os.Stderr, "Process %d: ", p.pid)
+	fmt.Fprintf(os.Stderr, format, args)
+	fmt.Fprint(os.Stderr, "\n")
 }
 
 /*
@@ -334,7 +334,7 @@ func (p *process) someStoppedThread() *thread {
 			return t
 		}
 	}
-	return nil;
+	return nil
 }
 
 // someRunningThread returns a running thread from the process.
@@ -347,7 +347,7 @@ func (p *process) someRunningThread() *thread {
 			return t
 		}
 	}
-	return nil;
+	return nil
 }
 
 /*
@@ -358,32 +358,32 @@ func (p *process) someRunningThread() *thread {
 //
 // Must be called from the monitor thread.
 func (p *process) installBreakpoints() os.Error {
-	n := 0;
-	main := p.someStoppedThread();
+	n := 0
+	main := p.someStoppedThread()
 	for _, b := range p.breakpoints {
 		if b.olddata != nil {
 			continue
 		}
 
-		b.olddata = make([]byte, len(bpinst386));
-		_, err := main.ptracePeekText(uintptr(b.pc), b.olddata);
+		b.olddata = make([]byte, len(bpinst386))
+		_, err := main.ptracePeekText(uintptr(b.pc), b.olddata)
 		if err != nil {
-			b.olddata = nil;
-			return err;
+			b.olddata = nil
+			return err
 		}
 
-		_, err = main.ptracePokeText(uintptr(b.pc), bpinst386);
+		_, err = main.ptracePokeText(uintptr(b.pc), bpinst386)
 		if err != nil {
-			b.olddata = nil;
-			return err;
+			b.olddata = nil
+			return err
 		}
-		n++;
+		n++
 	}
 	if n > 0 {
 		p.logTrace("installed %d/%d breakpoints", n, len(p.breakpoints))
 	}
 
-	return nil;
+	return nil
 }
 
 // uninstallBreakpoints removes the installed breakpoints from p.
@@ -393,25 +393,25 @@ func (p *process) uninstallBreakpoints() os.Error {
 	if len(p.threads) == 0 {
 		return nil
 	}
-	n := 0;
-	main := p.someStoppedThread();
+	n := 0
+	main := p.someStoppedThread()
 	for _, b := range p.breakpoints {
 		if b.olddata == nil {
 			continue
 		}
 
-		_, err := main.ptracePokeText(uintptr(b.pc), b.olddata);
+		_, err := main.ptracePokeText(uintptr(b.pc), b.olddata)
 		if err != nil {
 			return err
 		}
-		b.olddata = nil;
-		n++;
+		b.olddata = nil
+		n++
 	}
 	if n > 0 {
 		p.logTrace("uninstalled %d/%d breakpoints", n, len(p.breakpoints))
 	}
 
-	return nil;
+	return nil
 }
 
 /*
@@ -425,17 +425,17 @@ func (p *process) uninstallBreakpoints() os.Error {
 // event.
 func (t *thread) wait() {
 	for {
-		var ev debugEvent;
-		ev.t = t;
-		t.logTrace("beginning wait");
-		ev.Waitmsg, ev.err = os.Wait(t.tid, syscall.WALL);
+		var ev debugEvent
+		ev.t = t
+		t.logTrace("beginning wait")
+		ev.Waitmsg, ev.err = os.Wait(t.tid, syscall.WALL)
 		if ev.err == nil && ev.Pid != t.tid {
 			panic("Wait returned pid ", ev.Pid, " wanted ", t.tid)
 		}
 		if ev.StopSignal() == syscall.SIGSTOP && t.ignoreNextSigstop {
 			// Spurious SIGSTOP.  See Thread.Stop().
-			t.ignoreNextSigstop = false;
-			err := t.ptraceCont();
+			t.ignoreNextSigstop = false
+			err := t.ptraceCont()
 			if err == nil {
 				continue
 			}
@@ -447,8 +447,8 @@ func (t *thread) wait() {
 			// The monitor exited
 			break
 		}
-		t.proc.debugEvents <- &ev;
-		break;
+		t.proc.debugEvents <- &ev
+		break
 	}
 }
 
@@ -457,9 +457,9 @@ func (t *thread) wait() {
 //
 // Must be called from the monitor thread.
 func (t *thread) setState(newState threadState) {
-	oldState := t.state;
-	t.state = newState;
-	t.logTrace("state %v -> %v", oldState, newState);
+	oldState := t.state
+	t.state = newState
+	t.logTrace("state %v -> %v", oldState, newState)
 
 	if !oldState.isRunning() && (newState.isRunning() || newState.isZombie()) {
 		// Start waiting on this thread
@@ -467,23 +467,23 @@ func (t *thread) setState(newState threadState) {
 	}
 
 	// Invoke state change handlers
-	handlers := t.proc.transitionHandlers;
+	handlers := t.proc.transitionHandlers
 	if handlers.Len() == 0 {
 		return
 	}
 
-	t.proc.transitionHandlers = new(vector.Vector);
+	t.proc.transitionHandlers = new(vector.Vector)
 	for _, h := range handlers.Data() {
-		h := h.(*transitionHandler);
-		h.handle(t, oldState, newState);
+		h := h.(*transitionHandler)
+		h.handle(t, oldState, newState)
 	}
 }
 
 // sendSigstop sends a SIGSTOP to this thread.
 func (t *thread) sendSigstop() os.Error {
-	t.logTrace("sending SIGSTOP");
-	err := syscall.Tgkill(t.proc.pid, t.tid, syscall.SIGSTOP);
-	return os.NewSyscallError("tgkill", err);
+	t.logTrace("sending SIGSTOP")
+	err := syscall.Tgkill(t.proc.pid, t.tid, syscall.SIGSTOP)
+	return os.NewSyscallError("tgkill", err)
 }
 
 // stopAsync sends SIGSTOP to all threads in state 'running'.
@@ -492,14 +492,14 @@ func (t *thread) sendSigstop() os.Error {
 func (p *process) stopAsync() os.Error {
 	for _, t := range p.threads {
 		if t.state == running {
-			err := t.sendSigstop();
+			err := t.sendSigstop()
 			if err != nil {
 				return err
 			}
-			t.setState(stopping);
+			t.setState(stopping)
 		}
 	}
-	return nil;
+	return nil
 }
 
 // doTrap handles SIGTRAP debug events with a cause of 0.  These can
@@ -508,7 +508,7 @@ func (p *process) stopAsync() os.Error {
 //
 // TODO(austin) I think we also get this on an execve syscall.
 func (ev *debugEvent) doTrap() (threadState, os.Error) {
-	t := ev.t;
+	t := ev.t
 
 	if t.state == singleStepping {
 		return stopped, nil
@@ -517,13 +517,13 @@ func (ev *debugEvent) doTrap() (threadState, os.Error) {
 	// Hit a breakpoint.  Linux leaves the program counter after
 	// the breakpoint.  If this is an installed breakpoint, we
 	// need to back the PC up to the breakpoint PC.
-	var regs syscall.PtraceRegs;
-	err := t.ptraceGetRegs(&regs);
+	var regs syscall.PtraceRegs
+	err := t.ptraceGetRegs(&regs)
 	if err != nil {
 		return stopped, err
 	}
 
-	b, ok := t.proc.breakpoints[uintptr(regs.PC())-uintptr(len(bpinst386))];
+	b, ok := t.proc.breakpoints[uintptr(regs.PC())-uintptr(len(bpinst386))]
 	if !ok {
 		// We must have hit a breakpoint that was actually in
 		// the program.  Leave the IP where it is so we don't
@@ -532,38 +532,38 @@ func (ev *debugEvent) doTrap() (threadState, os.Error) {
 		return stoppedSignal, nil
 	}
 
-	t.breakpoint = b;
-	t.logTrace("at breakpoint %v, backing up PC from %#x", b, regs.PC());
+	t.breakpoint = b
+	t.logTrace("at breakpoint %v, backing up PC from %#x", b, regs.PC())
 
-	regs.SetPC(uint64(b.pc));
-	err = t.ptraceSetRegs(&regs);
+	regs.SetPC(uint64(b.pc))
+	err = t.ptraceSetRegs(&regs)
 	if err != nil {
 		return stopped, err
 	}
-	return stoppedBreakpoint, nil;
+	return stoppedBreakpoint, nil
 }
 
 // doPtraceClone handles SIGTRAP debug events with a PTRACE_EVENT_CLONE
 // cause.  It initializes the new thread, adds it to the process, and
 // returns the appropriate thread state for the existing thread.
 func (ev *debugEvent) doPtraceClone() (threadState, os.Error) {
-	t := ev.t;
+	t := ev.t
 
 	// Get the TID of the new thread
-	tid, err := t.ptraceGetEventMsg();
+	tid, err := t.ptraceGetEventMsg()
 	if err != nil {
 		return stopped, err
 	}
 
-	nt, err := t.proc.newThread(int(tid), syscall.SIGSTOP, true);
+	nt, err := t.proc.newThread(int(tid), syscall.SIGSTOP, true)
 	if err != nil {
 		return stopped, err
 	}
 
 	// Remember the thread
-	t.newThread = nt;
+	t.newThread = nt
 
-	return stoppedThreadCreate, nil;
+	return stoppedThreadCreate, nil
 }
 
 // doPtraceExit handles SIGTRAP debug events with a PTRACE_EVENT_EXIT
@@ -571,15 +571,15 @@ func (ev *debugEvent) doPtraceClone() (threadState, os.Error) {
 // the process.  A later WIFEXITED debug event will remove it from the
 // process.
 func (ev *debugEvent) doPtraceExit() (threadState, os.Error) {
-	t := ev.t;
+	t := ev.t
 
 	// Get exit status
-	exitStatus, err := t.ptraceGetEventMsg();
+	exitStatus, err := t.ptraceGetEventMsg()
 	if err != nil {
 		return stopped, err
 	}
-	ws := syscall.WaitStatus(exitStatus);
-	t.logTrace("exited with %v", ws);
+	ws := syscall.WaitStatus(exitStatus)
+	t.logTrace("exited with %v", ws)
 	switch {
 	case ws.Exited():
 		t.exitStatus = ws.ExitStatus()
@@ -589,7 +589,7 @@ func (ev *debugEvent) doPtraceExit() (threadState, os.Error) {
 
 	// We still need to continue this thread and wait on this
 	// thread's WIFEXITED event.  We'll delete it then.
-	return stoppedExiting, nil;
+	return stoppedExiting, nil
 }
 
 // process handles a debug event.  It modifies any thread or process
@@ -600,20 +600,20 @@ func (ev *debugEvent) process() os.Error {
 		return ev.err
 	}
 
-	t := ev.t;
-	t.exitStatus = -1;
-	t.signal = -1;
+	t := ev.t
+	t.exitStatus = -1
+	t.signal = -1
 
 	// Decode wait status.
-	var state threadState;
+	var state threadState
 	switch {
 	case ev.Stopped():
-		state = stoppedSignal;
-		t.signal = ev.StopSignal();
-		t.logTrace("stopped with %v", ev);
+		state = stoppedSignal
+		t.signal = ev.StopSignal()
+		t.logTrace("stopped with %v", ev)
 		if ev.StopSignal() == syscall.SIGTRAP {
 			// What caused the debug trap?
-			var err os.Error;
+			var err os.Error
 			switch cause := ev.TrapCause(); cause {
 			case 0:
 				// Breakpoint or single stepping
@@ -630,25 +630,25 @@ func (ev *debugEvent) process() os.Error {
 			}
 
 			if err != nil {
-				t.setState(stopped);
-				t.warn("failed to handle trap %v: %v", ev, err);
+				t.setState(stopped)
+				t.warn("failed to handle trap %v: %v", ev, err)
 			}
 		}
 
 	case ev.Exited():
-		state = exited;
-		t.proc.threads[t.tid] = nil, false;
-		t.logTrace("exited %v", ev);
+		state = exited
+		t.proc.threads[t.tid] = nil, false
+		t.logTrace("exited %v", ev)
 		// We should have gotten the exit status in
 		// PTRACE_EVENT_EXIT, but just in case.
-		t.exitStatus = ev.ExitStatus();
+		t.exitStatus = ev.ExitStatus()
 
 	case ev.Signaled():
-		state = exited;
-		t.proc.threads[t.tid] = nil, false;
-		t.logTrace("signaled %v", ev);
+		state = exited
+		t.proc.threads[t.tid] = nil, false
+		t.logTrace("signaled %v", ev)
 		// Again, this should be redundant.
-		t.signal = ev.Signal();
+		t.signal = ev.Signal()
 
 	default:
 		panic(fmt.Sprintf("Unexpected wait status %v", ev.Waitmsg))
@@ -666,14 +666,14 @@ func (ev *debugEvent) process() os.Error {
 	// TODO(austin) If we're in state stopping and get a SIGSTOP,
 	// set state stopped instead of stoppedSignal.
 
-	t.setState(state);
+	t.setState(state)
 
 	if t.proc.someRunningThread() == nil {
 		// Nothing is running, uninstall breakpoints
 		return t.proc.uninstallBreakpoints()
 	}
 	// Stop any other running threads
-	return t.proc.stopAsync();
+	return t.proc.stopAsync()
 }
 
 // onStop adds a handler for state transitions from running to
@@ -686,15 +686,15 @@ func (t *thread) onStop(handle func(), onErr func(os.Error)) {
 	// stepping all threads during a continue.  Maybe move
 	// transitionHandlers to the thread, or have both per-thread
 	// and per-process transition handlers.
-	h := &transitionHandler{nil, onErr};
+	h := &transitionHandler{nil, onErr}
 	h.handle = func(st *thread, old, new threadState) {
 		if t == st && old.isRunning() && !new.isRunning() {
 			handle()
 		} else {
 			t.proc.transitionHandlers.Push(h)
 		}
-	};
-	t.proc.transitionHandlers.Push(h);
+	}
+	t.proc.transitionHandlers.Push(h)
 }
 
 /*
@@ -704,17 +704,17 @@ func (t *thread) onStop(handle func(), onErr func(os.Error)) {
 // monitor handles debug events and debug requests for p, exiting when
 // there are no threads left in p.
 func (p *process) monitor() {
-	var err os.Error;
+	var err os.Error
 
 	// Linux requires that all ptrace calls come from the thread
 	// that originally attached.  Prevent the Go scheduler from
 	// migrating us to other OS threads.
-	runtime.LockOSThread();
-	defer runtime.UnlockOSThread();
+	runtime.LockOSThread()
+	defer runtime.UnlockOSThread()
 
-	hadThreads := false;
+	hadThreads := false
 	for err == nil {
-		p.ready <- true;
+		p.ready <- true
 		select {
 		case event := <-p.debugEvents:
 			err = event.process()
@@ -728,8 +728,8 @@ func (p *process) monitor() {
 
 		if len(p.threads) == 0 {
 			if err == nil && hadThreads {
-				p.logTrace("no more threads; monitor exiting");
-				err = ProcessExited{};
+				p.logTrace("no more threads; monitor exiting")
+				err = ProcessExited{}
 			}
 		} else {
 			hadThreads = true
@@ -739,13 +739,13 @@ func (p *process) monitor() {
 	// Abort waiting handlers
 	// TODO(austin) How do I stop the wait threads?
 	for _, h := range p.transitionHandlers.Data() {
-		h := h.(*transitionHandler);
-		h.onErr(err);
+		h := h.(*transitionHandler)
+		h.onErr(err)
 	}
 
 	// Indicate that the monitor cannot receive any more messages
-	p.err = err;
-	close(p.ready);
+	p.err = err
+	close(p.ready)
 }
 
 // do executes f in the monitor thread (and, thus, atomically with
@@ -756,9 +756,9 @@ func (p *process) do(f func() os.Error) os.Error {
 	if !<-p.ready {
 		return p.err
 	}
-	req := &debugReq{f, make(chan os.Error)};
-	p.debugReqs <- req;
-	return <-req.res;
+	req := &debugReq{f, make(chan os.Error)}
+	p.debugReqs <- req
+	return <-req.res
 }
 
 // stopMonitor stops the monitor with the given error.  If the monitor
@@ -777,14 +777,14 @@ func (p *process) stopMonitor(err os.Error) {
  */
 
 func (t *thread) Regs() (Regs, os.Error) {
-	var regs syscall.PtraceRegs;
+	var regs syscall.PtraceRegs
 
 	err := t.proc.do(func() os.Error {
 		if !t.state.isStopped() {
 			return &badState{t, "cannot get registers", t.state}
 		}
-		return t.ptraceGetRegs(&regs);
-	});
+		return t.ptraceGetRegs(&regs)
+	})
 	if err != nil {
 		return nil, err
 	}
@@ -794,42 +794,42 @@ func (t *thread) Regs() (Regs, os.Error) {
 			if !t.state.isStopped() {
 				return &badState{t, "cannot get registers", t.state}
 			}
-			return t.ptraceSetRegs(r);
+			return t.ptraceSetRegs(r)
 		})
-	};
-	return newRegs(&regs, setter), nil;
+	}
+	return newRegs(&regs, setter), nil
 }
 
 func (t *thread) Peek(addr Word, out []byte) (int, os.Error) {
-	var c int;
+	var c int
 
 	err := t.proc.do(func() os.Error {
 		if !t.state.isStopped() {
 			return &badState{t, "cannot peek text", t.state}
 		}
 
-		var err os.Error;
-		c, err = t.ptracePeekText(uintptr(addr), out);
-		return err;
-	});
+		var err os.Error
+		c, err = t.ptracePeekText(uintptr(addr), out)
+		return err
+	})
 
-	return c, err;
+	return c, err
 }
 
 func (t *thread) Poke(addr Word, out []byte) (int, os.Error) {
-	var c int;
+	var c int
 
 	err := t.proc.do(func() os.Error {
 		if !t.state.isStopped() {
 			return &badState{t, "cannot poke text", t.state}
 		}
 
-		var err os.Error;
-		c, err = t.ptracePokeText(uintptr(addr), out);
-		return err;
-	});
+		var err os.Error
+		c, err = t.ptracePokeText(uintptr(addr), out)
+		return err
+	})
 
-	return c, err;
+	return c, err
 }
 
 // stepAsync starts this thread single stepping.  When the single step
@@ -841,30 +841,30 @@ func (t *thread) stepAsync(ready chan os.Error) os.Error {
 	if err := t.ptraceStep(); err != nil {
 		return err
 	}
-	t.setState(singleStepping);
+	t.setState(singleStepping)
 	t.onStop(func() { ready <- nil },
-		func(err os.Error) { ready <- err });
-	return nil;
+		func(err os.Error) { ready <- err })
+	return nil
 }
 
 func (t *thread) Step() os.Error {
-	t.logTrace("Step {");
-	defer t.logTrace("}");
+	t.logTrace("Step {")
+	defer t.logTrace("}")
 
-	ready := make(chan os.Error);
+	ready := make(chan os.Error)
 
 	err := t.proc.do(func() os.Error {
 		if !t.state.isStopped() {
 			return &badState{t, "cannot single step", t.state}
 		}
-		return t.stepAsync(ready);
-	});
+		return t.stepAsync(ready)
+	})
 	if err != nil {
 		return err
 	}
 
-	err = <-ready;
-	return err;
+	err = <-ready
+	return err
 }
 
 // TODO(austin) We should probably get this via C's strsignal.
@@ -884,11 +884,11 @@ func sigName(signal int) string {
 	if signal < 0 || signal >= len(sigNames) {
 		return "<invalid>"
 	}
-	return sigNames[signal];
+	return sigNames[signal]
 }
 
 func (t *thread) Stopped() (Cause, os.Error) {
-	var c Cause;
+	var c Cause
 	err := t.proc.do(func() os.Error {
 		switch t.state {
 		case stopped:
@@ -913,35 +913,35 @@ func (t *thread) Stopped() (Cause, os.Error) {
 		default:
 			return &badState{t, "cannot get stop cause", t.state}
 		}
-		return nil;
-	});
+		return nil
+	})
 	if err != nil {
 		return nil, err
 	}
 
-	return c, nil;
+	return c, nil
 }
 
 func (p *process) Threads() []Thread {
-	var res []Thread;
+	var res []Thread
 
 	p.do(func() os.Error {
-		res = make([]Thread, len(p.threads));
-		i := 0;
+		res = make([]Thread, len(p.threads))
+		i := 0
 		for _, t := range p.threads {
 			// Exclude zombie threads.
-			st := t.state;
+			st := t.state
 			if st == exiting || st == exited || st == detached {
 				continue
 			}
 
-			res[i] = t;
-			i++;
+			res[i] = t
+			i++
 		}
-		res = res[0:i];
-		return nil;
-	});
-	return res;
+		res = res[0:i]
+		return nil
+	})
+	return res
 }
 
 func (p *process) AddBreakpoint(pc Word) os.Error {
@@ -952,8 +952,8 @@ func (p *process) AddBreakpoint(pc Word) os.Error {
 		if _, ok := p.breakpoints[uintptr(pc)]; ok {
 			return breakpointExistsError(pc)
 		}
-		p.breakpoints[uintptr(pc)] = &breakpoint{pc: uintptr(pc)};
-		return nil;
+		p.breakpoints[uintptr(pc)] = &breakpoint{pc: uintptr(pc)}
+		return nil
 	})
 }
 
@@ -965,22 +965,22 @@ func (p *process) RemoveBreakpoint(pc Word) os.Error {
 		if _, ok := p.breakpoints[uintptr(pc)]; !ok {
 			return noBreakpointError(pc)
 		}
-		p.breakpoints[uintptr(pc)] = nil, false;
-		return nil;
+		p.breakpoints[uintptr(pc)] = nil, false
+		return nil
 	})
 }
 
 func (p *process) Continue() os.Error {
 	// Single step any threads that are stopped at breakpoints so
 	// we can reinstall breakpoints.
-	var ready chan os.Error;
-	count := 0;
+	var ready chan os.Error
+	count := 0
 
 	err := p.do(func() os.Error {
 		// We make the ready channel big enough to hold all
 		// ready message so we don't jam up the monitor if we
 		// stop listening (e.g., if there's an error).
-		ready = make(chan os.Error, len(p.threads));
+		ready = make(chan os.Error, len(p.threads))
 
 		for _, t := range p.threads {
 			if !t.state.isStopped() {
@@ -992,34 +992,34 @@ func (p *process) Continue() os.Error {
 			// it could have been stopped at a breakpoint
 			// for some other reason, or the breakpoint
 			// could have been added since it was stopped.
-			var regs syscall.PtraceRegs;
-			err := t.ptraceGetRegs(&regs);
+			var regs syscall.PtraceRegs
+			err := t.ptraceGetRegs(&regs)
 			if err != nil {
 				return err
 			}
 			if b, ok := p.breakpoints[uintptr(regs.PC())]; ok {
-				t.logTrace("stepping over breakpoint %v", b);
+				t.logTrace("stepping over breakpoint %v", b)
 				if err := t.stepAsync(ready); err != nil {
 					return err
 				}
-				count++;
+				count++
 			}
 		}
-		return nil;
-	});
+		return nil
+	})
 	if err != nil {
-		p.stopMonitor(err);
-		return err;
+		p.stopMonitor(err)
+		return err
 	}
 
 	// Wait for single stepping threads
 	for count > 0 {
-		err = <-ready;
+		err = <-ready
 		if err != nil {
-			p.stopMonitor(err);
-			return err;
+			p.stopMonitor(err)
+			return err
 		}
-		count--;
+		count--
 	}
 
 	// Continue all threads
@@ -1029,18 +1029,18 @@ func (p *process) Continue() os.Error {
 		}
 
 		for _, t := range p.threads {
-			var err os.Error;
+			var err os.Error
 			switch {
 			case !t.state.isStopped():
 				continue
 
 			case t.state == stoppedSignal && t.signal != syscall.SIGSTOP && t.signal != syscall.SIGTRAP:
-				t.logTrace("continuing with signal %d", t.signal);
-				err = t.ptraceContWithSignal(t.signal);
+				t.logTrace("continuing with signal %d", t.signal)
+				err = t.ptraceContWithSignal(t.signal)
 
 			default:
-				t.logTrace("continuing");
-				err = t.ptraceCont();
+				t.logTrace("continuing")
+				err = t.ptraceCont()
 			}
 			if err != nil {
 				return err
@@ -1051,59 +1051,59 @@ func (p *process) Continue() os.Error {
 				t.setState(running)
 			}
 		}
-		return nil;
-	});
+		return nil
+	})
 	if err != nil {
 		// TODO(austin) Do we need to stop the monitor with
 		// this error atomically with the do-routine above?
-		p.stopMonitor(err);
-		return err;
+		p.stopMonitor(err)
+		return err
 	}
 
-	return nil;
+	return nil
 }
 
 func (p *process) WaitStop() os.Error {
 	// We need a non-blocking ready channel for the case where all
 	// threads are already stopped.
-	ready := make(chan os.Error, 1);
+	ready := make(chan os.Error, 1)
 
 	err := p.do(func() os.Error {
 		// Are all of the threads already stopped?
 		if p.someRunningThread() == nil {
-			ready <- nil;
-			return nil;
+			ready <- nil
+			return nil
 		}
 
 		// Monitor state transitions
-		h := &transitionHandler{};
+		h := &transitionHandler{}
 		h.handle = func(st *thread, old, new threadState) {
 			if !new.isRunning() {
 				if p.someRunningThread() == nil {
-					ready <- nil;
-					return;
+					ready <- nil
+					return
 				}
 			}
-			p.transitionHandlers.Push(h);
-		};
-		h.onErr = func(err os.Error) { ready <- err };
-		p.transitionHandlers.Push(h);
-		return nil;
-	});
+			p.transitionHandlers.Push(h)
+		}
+		h.onErr = func(err os.Error) { ready <- err }
+		p.transitionHandlers.Push(h)
+		return nil
+	})
 	if err != nil {
 		return err
 	}
 
-	return <-ready;
+	return <-ready
 }
 
 func (p *process) Stop() os.Error {
-	err := p.do(func() os.Error { return p.stopAsync() });
+	err := p.do(func() os.Error { return p.stopAsync() })
 	if err != nil {
 		return err
 	}
 
-	return p.WaitStop();
+	return p.WaitStop()
 }
 
 func (p *process) Detach() os.Error {
@@ -1123,13 +1123,13 @@ func (p *process) Detach() os.Error {
 					return err
 				}
 			}
-			t.setState(detached);
-			p.threads[pid] = nil, false;
+			t.setState(detached)
+			p.threads[pid] = nil, false
 		}
-		return nil;
-	});
+		return nil
+	})
 	// TODO(austin) Wait for monitor thread to exit?
-	return err;
+	return err
 }
 
 // newThread creates a new thread object and waits for its initial
@@ -1138,11 +1138,11 @@ func (p *process) Detach() os.Error {
 //
 // Must be run from the monitor thread.
 func (p *process) newThread(tid int, signal int, cloned bool) (*thread, os.Error) {
-	t := &thread{tid: tid, proc: p, state: stopped};
+	t := &thread{tid: tid, proc: p, state: stopped}
 
 	// Get the signal from the thread
 	// TODO(austin) Thread might already be stopped if we're attaching.
-	w, err := os.Wait(tid, syscall.WALL);
+	w, err := os.Wait(tid, syscall.WALL)
 	if err != nil {
 		return nil, err
 	}
@@ -1151,59 +1151,59 @@ func (p *process) newThread(tid int, signal int, cloned bool) (*thread, os.Error
 	}
 
 	if !cloned {
-		err = t.ptraceSetOptions(syscall.PTRACE_O_TRACECLONE | syscall.PTRACE_O_TRACEEXIT);
+		err = t.ptraceSetOptions(syscall.PTRACE_O_TRACECLONE | syscall.PTRACE_O_TRACEEXIT)
 		if err != nil {
 			return nil, err
 		}
 	}
 
-	p.threads[tid] = t;
+	p.threads[tid] = t
 
-	return t, nil;
+	return t, nil
 }
 
 // attachThread attaches a running thread to the process.
 //
 // Must NOT be run from the monitor thread.
 func (p *process) attachThread(tid int) (*thread, os.Error) {
-	p.logTrace("attaching to thread %d", tid);
-	var thr *thread;
+	p.logTrace("attaching to thread %d", tid)
+	var thr *thread
 	err := p.do(func() os.Error {
-		errno := syscall.PtraceAttach(tid);
+		errno := syscall.PtraceAttach(tid)
 		if errno != 0 {
 			return os.NewSyscallError("ptrace(ATTACH)", errno)
 		}
 
-		var err os.Error;
-		thr, err = p.newThread(tid, syscall.SIGSTOP, false);
-		return err;
-	});
-	return thr, err;
+		var err os.Error
+		thr, err = p.newThread(tid, syscall.SIGSTOP, false)
+		return err
+	})
+	return thr, err
 }
 
 // attachAllThreads attaches to all threads in a process.
 func (p *process) attachAllThreads() os.Error {
-	taskPath := "/proc/" + strconv.Itoa(p.pid) + "/task";
-	taskDir, err := os.Open(taskPath, os.O_RDONLY, 0);
+	taskPath := "/proc/" + strconv.Itoa(p.pid) + "/task"
+	taskDir, err := os.Open(taskPath, os.O_RDONLY, 0)
 	if err != nil {
 		return err
 	}
-	defer taskDir.Close();
+	defer taskDir.Close()
 
 	// We stop threads as we attach to them; however, because new
 	// threads can appear while we're looping over all of them, we
 	// have to repeatly scan until we know we're attached to all
 	// of them.
 	for again := true; again; {
-		again = false;
+		again = false
 
-		tids, err := taskDir.Readdirnames(-1);
+		tids, err := taskDir.Readdirnames(-1)
 		if err != nil {
 			return err
 		}
 
 		for _, tidStr := range tids {
-			tid, err := strconv.Atoi(tidStr);
+			tid, err := strconv.Atoi(tidStr)
 			if err != nil {
 				return err
 			}
@@ -1211,39 +1211,39 @@ func (p *process) attachAllThreads() os.Error {
 				continue
 			}
 
-			_, err = p.attachThread(tid);
+			_, err = p.attachThread(tid)
 			if err != nil {
 				// There could have been a race, or
 				// this process could be a zobmie.
-				statFile, err2 := ioutil.ReadFile(taskPath + "/" + tidStr + "/stat");
+				statFile, err2 := ioutil.ReadFile(taskPath + "/" + tidStr + "/stat")
 				if err2 != nil {
 					switch err2 := err2.(type) {
 					case *os.PathError:
 						if err2.Error == os.ENOENT {
 							// Raced with thread exit
-							p.logTrace("raced with thread %d exit", tid);
-							continue;
+							p.logTrace("raced with thread %d exit", tid)
+							continue
 						}
 					}
 					// Return the original error
-					return err;
+					return err
 				}
 
-				statParts := strings.Split(string(statFile), " ", 4);
+				statParts := strings.Split(string(statFile), " ", 4)
 				if len(statParts) > 2 && statParts[2] == "Z" {
 					// tid is a zombie
-					p.logTrace("thread %d is a zombie", tid);
-					continue;
+					p.logTrace("thread %d is a zombie", tid)
+					continue
 				}
 
 				// Return the original error
-				return err;
+				return err
 			}
-			again = true;
+			again = true
 		}
 	}
 
-	return nil;
+	return nil
 }
 
 // newProcess creates a new process object and starts its monitor thread.
@@ -1257,37 +1257,37 @@ func newProcess(pid int) *process {
 		debugReqs: make(chan *debugReq),
 		stopReq: make(chan os.Error),
 		transitionHandlers: new(vector.Vector),
-	};
+	}
 
-	go p.monitor();
+	go p.monitor()
 
-	return p;
+	return p
 }
 
 // Attach attaches to process pid and stops all of its threads.
 func Attach(pid int) (Process, os.Error) {
-	p := newProcess(pid);
+	p := newProcess(pid)
 
 	// Attach to all threads
-	err := p.attachAllThreads();
+	err := p.attachAllThreads()
 	if err != nil {
-		p.Detach();
+		p.Detach()
 		// TODO(austin) Detach stopped the monitor already
 		//p.stopMonitor(err);
-		return nil, err;
+		return nil, err
 	}
 
-	return p, nil;
+	return p, nil
 }
 
 // ForkExec forks the current process and execs argv0, stopping the
 // new process after the exec syscall.  See os.ForkExec for additional
 // details.
 func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*os.File) (Process, os.Error) {
-	p := newProcess(-1);
+	p := newProcess(-1)
 
 	// Create array of integer (system) fds.
-	intfd := make([]int, len(fd));
+	intfd := make([]int, len(fd))
 	for i, f := range fd {
 		if f == nil {
 			intfd[i] = -1
@@ -1298,20 +1298,20 @@ func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*os.F
 
 	// Fork from the monitor thread so we get the right tracer pid.
 	err := p.do(func() os.Error {
-		pid, errno := syscall.PtraceForkExec(argv0, argv, envv, dir, intfd);
+		pid, errno := syscall.PtraceForkExec(argv0, argv, envv, dir, intfd)
 		if errno != 0 {
 			return &os.PathError{"fork/exec", argv0, os.Errno(errno)}
 		}
-		p.pid = pid;
+		p.pid = pid
 
 		// The process will raise SIGTRAP when it reaches execve.
-		_, err := p.newThread(pid, syscall.SIGTRAP, false);
-		return err;
-	});
+		_, err := p.newThread(pid, syscall.SIGTRAP, false)
+		return err
+	})
 	if err != nil {
-		p.stopMonitor(err);
-		return nil, err;
+		p.stopMonitor(err)
+		return nil, err
 	}
 
-	return p, nil;
+	return p, nil
 }
diff --git a/src/pkg/debug/proc/proc_nacl.go b/src/pkg/debug/proc/proc_nacl.go
index c4f6067393..be26bbf18b 100644
--- a/src/pkg/debug/proc/proc_nacl.go
+++ b/src/pkg/debug/proc/proc_nacl.go
@@ -5,8 +5,8 @@
 package proc
 
 import (
-	"os";
-	"syscall";
+	"os"
+	"syscall"
 )
 
 // Process tracing is not supported on Native Client.
diff --git a/src/pkg/debug/proc/regs_linux_386.go b/src/pkg/debug/proc/regs_linux_386.go
index abeb45f4b8..7c5478d86f 100644
--- a/src/pkg/debug/proc/regs_linux_386.go
+++ b/src/pkg/debug/proc/regs_linux_386.go
@@ -5,14 +5,14 @@
 package proc
 
 import (
-	"os";
-	"strconv";
-	"syscall";
+	"os"
+	"strconv"
+	"syscall"
 )
 
 type _386Regs struct {
-	syscall.PtraceRegs;
-	setter	func(*syscall.PtraceRegs) os.Error;
+	syscall.PtraceRegs
+	setter func(*syscall.PtraceRegs) os.Error
 }
 
 var names = [...]string{
@@ -34,11 +34,11 @@ var names = [...]string{
 	"gs",
 }
 
-func (r *_386Regs) PC() Word	{ return Word(r.Eip) }
+func (r *_386Regs) PC() Word { return Word(r.Eip) }
 
 func (r *_386Regs) SetPC(val Word) os.Error {
-	r.Eip = int32(val);
-	return r.setter(&r.PtraceRegs);
+	r.Eip = int32(val)
+	return r.setter(&r.PtraceRegs)
 }
 
 func (r *_386Regs) Link() Word {
@@ -46,16 +46,16 @@ func (r *_386Regs) Link() Word {
 	panic("No link register")
 }
 
-func (r *_386Regs) SetLink(val Word) os.Error	{ panic("No link register") }
+func (r *_386Regs) SetLink(val Word) os.Error { panic("No link register") }
 
-func (r *_386Regs) SP() Word	{ return Word(r.Esp) }
+func (r *_386Regs) SP() Word { return Word(r.Esp) }
 
 func (r *_386Regs) SetSP(val Word) os.Error {
-	r.Esp = int32(val);
-	return r.setter(&r.PtraceRegs);
+	r.Esp = int32(val)
+	return r.setter(&r.PtraceRegs)
 }
 
-func (r *_386Regs) Names() []string	{ return &names }
+func (r *_386Regs) Names() []string { return &names }
 
 func (r *_386Regs) Get(i int) Word {
 	switch i {
@@ -92,7 +92,7 @@ func (r *_386Regs) Get(i int) Word {
 	case 15:
 		return Word(r.Gs)
 	}
-	panic("invalid register index ", strconv.Itoa(i));
+	panic("invalid register index ", strconv.Itoa(i))
 }
 
 func (r *_386Regs) Set(i int, val Word) os.Error {
@@ -132,12 +132,12 @@ func (r *_386Regs) Set(i int, val Word) os.Error {
 	default:
 		panic("invalid register index ", strconv.Itoa(i))
 	}
-	return r.setter(&r.PtraceRegs);
+	return r.setter(&r.PtraceRegs)
 }
 
 func newRegs(regs *syscall.PtraceRegs, setter func(*syscall.PtraceRegs) os.Error) Regs {
-	res := _386Regs{};
-	res.PtraceRegs = *regs;
-	res.setter = setter;
-	return &res;
+	res := _386Regs{}
+	res.PtraceRegs = *regs
+	res.setter = setter
+	return &res
 }
diff --git a/src/pkg/debug/proc/regs_linux_amd64.go b/src/pkg/debug/proc/regs_linux_amd64.go
index 63083a948f..b070b77140 100644
--- a/src/pkg/debug/proc/regs_linux_amd64.go
+++ b/src/pkg/debug/proc/regs_linux_amd64.go
@@ -5,14 +5,14 @@
 package proc
 
 import (
-	"os";
-	"strconv";
-	"syscall";
+	"os"
+	"strconv"
+	"syscall"
 )
 
 type amd64Regs struct {
-	syscall.PtraceRegs;
-	setter	func(*syscall.PtraceRegs) os.Error;
+	syscall.PtraceRegs
+	setter func(*syscall.PtraceRegs) os.Error
 }
 
 var names = [...]string{
@@ -48,11 +48,11 @@ var names = [...]string{
 	//"gs_base",
 }
 
-func (r *amd64Regs) PC() Word	{ return Word(r.Rip) }
+func (r *amd64Regs) PC() Word { return Word(r.Rip) }
 
 func (r *amd64Regs) SetPC(val Word) os.Error {
-	r.Rip = uint64(val);
-	return r.setter(&r.PtraceRegs);
+	r.Rip = uint64(val)
+	return r.setter(&r.PtraceRegs)
 }
 
 func (r *amd64Regs) Link() Word {
@@ -64,14 +64,14 @@ func (r *amd64Regs) SetLink(val Word) os.Error {
 	panic("No link register")
 }
 
-func (r *amd64Regs) SP() Word	{ return Word(r.Rsp) }
+func (r *amd64Regs) SP() Word { return Word(r.Rsp) }
 
 func (r *amd64Regs) SetSP(val Word) os.Error {
-	r.Rsp = uint64(val);
-	return r.setter(&r.PtraceRegs);
+	r.Rsp = uint64(val)
+	return r.setter(&r.PtraceRegs)
 }
 
-func (r *amd64Regs) Names() []string	{ return &names }
+func (r *amd64Regs) Names() []string { return &names }
 
 func (r *amd64Regs) Get(i int) Word {
 	switch i {
@@ -124,7 +124,7 @@ func (r *amd64Regs) Get(i int) Word {
 	case 23:
 		return Word(r.Gs)
 	}
-	panic("invalid register index ", strconv.Itoa(i));
+	panic("invalid register index ", strconv.Itoa(i))
 }
 
 func (r *amd64Regs) Set(i int, val Word) os.Error {
@@ -180,12 +180,12 @@ func (r *amd64Regs) Set(i int, val Word) os.Error {
 	default:
 		panic("invalid register index ", strconv.Itoa(i))
 	}
-	return r.setter(&r.PtraceRegs);
+	return r.setter(&r.PtraceRegs)
 }
 
 func newRegs(regs *syscall.PtraceRegs, setter func(*syscall.PtraceRegs) os.Error) Regs {
-	res := amd64Regs{};
-	res.PtraceRegs = *regs;
-	res.setter = setter;
-	return &res;
+	res := amd64Regs{}
+	res.PtraceRegs = *regs
+	res.setter = setter
+	return &res
 }
diff --git a/src/pkg/debug/proc/regs_linux_arm.go b/src/pkg/debug/proc/regs_linux_arm.go
index e58ab388bd..ec78cbcf25 100644
--- a/src/pkg/debug/proc/regs_linux_arm.go
+++ b/src/pkg/debug/proc/regs_linux_arm.go
@@ -5,35 +5,35 @@
 package proc
 
 import (
-	"os";
-	"syscall";
+	"os"
+	"syscall"
 )
 
 // TODO(kaib): add support
 
 type armRegs struct{}
 
-func (r *armRegs) PC() Word	{ return Word(0) }
+func (r *armRegs) PC() Word { return Word(0) }
 
-func (r *armRegs) SetPC(val Word) os.Error	{ return nil }
+func (r *armRegs) SetPC(val Word) os.Error { return nil }
 
-func (r *armRegs) Link() Word	{ return Word(0) }
+func (r *armRegs) Link() Word { return Word(0) }
 
-func (r *armRegs) SetLink(val Word) os.Error	{ return nil }
+func (r *armRegs) SetLink(val Word) os.Error { return nil }
 
-func (r *armRegs) SP() Word	{ return Word(0) }
+func (r *armRegs) SP() Word { return Word(0) }
 
-func (r *armRegs) SetSP(val Word) os.Error	{ return nil }
+func (r *armRegs) SetSP(val Word) os.Error { return nil }
 
-func (r *armRegs) Names() []string	{ return nil }
+func (r *armRegs) Names() []string { return nil }
 
-func (r *armRegs) Get(i int) Word	{ return Word(0) }
+func (r *armRegs) Get(i int) Word { return Word(0) }
 
 func (r *armRegs) Set(i int, val Word) os.Error {
 	return nil
 }
 
 func newRegs(regs *syscall.PtraceRegs, setter func(*syscall.PtraceRegs) os.Error) Regs {
-	res := armRegs{};
-	return &res;
+	res := armRegs{}
+	return &res
 }
diff --git a/src/pkg/ebnf/ebnf.go b/src/pkg/ebnf/ebnf.go
index 08f3b8c7fd..898a481735 100644
--- a/src/pkg/ebnf/ebnf.go
+++ b/src/pkg/ebnf/ebnf.go
@@ -23,12 +23,12 @@
 package ebnf
 
 import (
-	"container/vector";
-	"go/scanner";
-	"go/token";
-	"os";
-	"unicode";
-	"utf8";
+	"container/vector"
+	"go/scanner"
+	"go/token"
+	"os"
+	"unicode"
+	"utf8"
 )
 
 
@@ -37,115 +37,115 @@ import (
 
 type (
 	// An Expression node represents a production expression.
-	Expression	interface {
+	Expression interface {
 		// Pos is the position of the first character of the syntactic construct
-		Pos() token.Position;
-	};
+		Pos() token.Position
+	}
 
 	// An Alternative node represents a non-empty list of alternative expressions.
-	Alternative	[]Expression;	// x | y | z
+	Alternative []Expression // x | y | z
 
 	// A Sequence node represents a non-empty list of sequential expressions.
-	Sequence	[]Expression;	// x y z
+	Sequence []Expression // x y z
 
 	// A Name node represents a production name.
-	Name	struct {
-		token.Position;
-		String	string;
-	};
+	Name struct {
+		token.Position
+		String string
+	}
 
 	// A Token node represents a literal.
-	Token	struct {
-		token.Position;
-		String	string;
-	};
+	Token struct {
+		token.Position
+		String string
+	}
 
 	// A List node represents a range of characters.
-	Range	struct {
-		Begin, End *Token;	// begin ... end
-	};
+	Range struct {
+		Begin, End *Token // begin ... end
+	}
 
 	// A Group node represents a grouped expression.
-	Group	struct {
-		token.Position;
-		Body	Expression;	// (body)
-	};
+	Group struct {
+		token.Position
+		Body Expression // (body)
+	}
 
 	// An Option node represents an optional expression.
-	Option	struct {
-		token.Position;
-		Body	Expression;	// [body]
-	};
+	Option struct {
+		token.Position
+		Body Expression // [body]
+	}
 
 	// A Repetition node represents a repeated expression.
-	Repetition	struct {
-		token.Position;
-		Body	Expression;	// {body}
-	};
+	Repetition struct {
+		token.Position
+		Body Expression // {body}
+	}
 
 	// A Production node represents an EBNF production.
-	Production	struct {
-		Name	*Name;
-		Expr	Expression;
-	};
+	Production struct {
+		Name *Name
+		Expr Expression
+	}
 
 	// A Grammar is a set of EBNF productions. The map
 	// is indexed by production name.
 	//
-	Grammar	map[string]*Production;
+	Grammar map[string]*Production
 )
 
 
 func (x Alternative) Pos() token.Position {
-	return x[0].Pos()	// the parser always generates non-empty Alternative
+	return x[0].Pos() // the parser always generates non-empty Alternative
 }
 
 
 func (x Sequence) Pos() token.Position {
-	return x[0].Pos()	// the parser always generates non-empty Sequences
+	return x[0].Pos() // the parser always generates non-empty Sequences
 }
 
 
-func (x Range) Pos() token.Position	{ return x.Begin.Pos() }
+func (x Range) Pos() token.Position { return x.Begin.Pos() }
 
 
-func (p *Production) Pos() token.Position	{ return p.Name.Pos() }
+func (p *Production) Pos() token.Position { return p.Name.Pos() }
 
 
 // ----------------------------------------------------------------------------
 // Grammar verification
 
 func isLexical(name string) bool {
-	ch, _ := utf8.DecodeRuneInString(name);
-	return !unicode.IsUpper(ch);
+	ch, _ := utf8.DecodeRuneInString(name)
+	return !unicode.IsUpper(ch)
 }
 
 
 type verifier struct {
-	scanner.ErrorVector;
-	worklist	vector.Vector;
-	reached		Grammar;	// set of productions reached from (and including) the root production
-	grammar		Grammar;
+	scanner.ErrorVector
+	worklist vector.Vector
+	reached  Grammar // set of productions reached from (and including) the root production
+	grammar  Grammar
 }
 
 
 func (v *verifier) push(prod *Production) {
-	name := prod.Name.String;
+	name := prod.Name.String
 	if _, found := v.reached[name]; !found {
-		v.worklist.Push(prod);
-		v.reached[name] = prod;
+		v.worklist.Push(prod)
+		v.reached[name] = prod
 	}
 }
 
 
 func (v *verifier) verifyChar(x *Token) int {
-	s := x.String;
+	s := x.String
 	if utf8.RuneCountInString(s) != 1 {
-		v.Error(x.Pos(), "single char expected, found "+s);
-		return 0;
+		v.Error(x.Pos(), "single char expected, found "+s)
+		return 0
 	}
-	ch, _ := utf8.DecodeRuneInString(s);
-	return ch;
+	ch, _ := utf8.DecodeRuneInString(s)
+	return ch
 }
 
 
@@ -177,8 +177,8 @@ func (v *verifier) verifyExpr(expr Expression, lexical bool) {
 	case *Token:
 		// nothing to do for now
 	case *Range:
-		i := v.verifyChar(x.Begin);
-		j := v.verifyChar(x.End);
+		i := v.verifyChar(x.Begin)
+		j := v.verifyChar(x.End)
 		if i >= j {
 			v.Error(x.Pos(), "decreasing character range")
 		}
@@ -196,24 +196,24 @@ func (v *verifier) verifyExpr(expr Expression, lexical bool) {
 
 func (v *verifier) verify(grammar Grammar, start string) {
 	// find root production
-	root, found := grammar[start];
+	root, found := grammar[start]
 	if !found {
-		var noPos token.Position;
-		v.Error(noPos, "no start production "+start);
-		return;
+		var noPos token.Position
+		v.Error(noPos, "no start production "+start)
+		return
 	}
 
 	// initialize verifier
-	v.ErrorVector.Reset();
-	v.worklist.Resize(0, 0);
-	v.reached = make(Grammar);
-	v.grammar = grammar;
+	v.ErrorVector.Reset()
+	v.worklist.Resize(0, 0)
+	v.reached = make(Grammar)
+	v.grammar = grammar
 
 	// work through the worklist
-	v.push(root);
+	v.push(root)
 	for v.worklist.Len() > 0 {
-		prod := v.worklist.Pop().(*Production);
-		v.verifyExpr(prod.Expr, isLexical(prod.Name.String));
+		prod := v.worklist.Pop().(*Production)
+		v.verifyExpr(prod.Expr, isLexical(prod.Name.String))
 	}
 
 	// check if all productions were reached
@@ -233,7 +233,7 @@ func (v *verifier) verify(grammar Grammar, start string) {
 //	- lexical productions refer only to other lexical productions
 //
 func Verify(grammar Grammar, start string) os.Error {
-	var v verifier;
-	v.verify(grammar, start);
-	return v.GetError(scanner.Sorted);
+	var v verifier
+	v.verify(grammar, start)
+	return v.GetError(scanner.Sorted)
 }
diff --git a/src/pkg/ebnf/ebnf_test.go b/src/pkg/ebnf/ebnf_test.go
index a487bdc2cf..e6f670530d 100644
--- a/src/pkg/ebnf/ebnf_test.go
+++ b/src/pkg/ebnf/ebnf_test.go
@@ -5,9 +5,9 @@
 package ebnf
 
 import (
-	"io/ioutil";
-	"strings";
-	"testing";
+	"io/ioutil"
+	"strings"
+	"testing"
 )
 
 
@@ -41,7 +41,7 @@ var grammars = []string{
 
 
 func check(t *testing.T, filename string, src []byte) {
-	grammar, err := Parse(filename, src);
+	grammar, err := Parse(filename, src)
 	if err != nil {
 		t.Errorf("Parse(%s) failed: %v", src, err)
 	}
@@ -65,10 +65,10 @@ var files = []string{
 
 func TestFiles(t *testing.T) {
 	for _, filename := range files {
-		src, err := ioutil.ReadFile(filename);
+		src, err := ioutil.ReadFile(filename)
 		if err != nil {
 			t.Fatal(err)
 		}
-		check(t, filename, src);
+		check(t, filename, src)
 	}
 }
diff --git a/src/pkg/ebnf/parser.go b/src/pkg/ebnf/parser.go
index 5193f8b261..6495878794 100644
--- a/src/pkg/ebnf/parser.go
+++ b/src/pkg/ebnf/parser.go
@@ -5,25 +5,25 @@
 package ebnf
 
 import (
-	"container/vector";
-	"go/scanner";
-	"go/token";
-	"os";
-	"strconv";
+	"container/vector"
+	"go/scanner"
+	"go/token"
+	"os"
+	"strconv"
 )
 
 
 type parser struct {
-	scanner.ErrorVector;
-	scanner	scanner.Scanner;
-	pos	token.Position;	// token position
-	tok	token.Token;	// one token look-ahead
-	lit	[]byte;		// token literal
+	scanner.ErrorVector
+	scanner scanner.Scanner
+	pos     token.Position // token position
+	tok     token.Token    // one token look-ahead
+	lit     []byte         // token literal
 }
 
 
 func (p *parser) next() {
-	p.pos, p.tok, p.lit = p.scanner.Scan();
+	p.pos, p.tok, p.lit = p.scanner.Scan()
 	if p.tok.IsKeyword() {
 		// TODO Should keyword mapping always happen outside scanner?
 		//      Or should there be a flag to scanner to enable keyword mapping?
@@ -33,90 +33,90 @@ func (p *parser) next() {
 
 
 func (p *parser) errorExpected(pos token.Position, msg string) {
-	msg = "expected " + msg;
+	msg = "expected " + msg
 	if pos.Offset == p.pos.Offset {
 		// the error happened at the current position;
 		// make the error message more specific
-		msg += ", found '" + p.tok.String() + "'";
+		msg += ", found '" + p.tok.String() + "'"
 		if p.tok.IsLiteral() {
 			msg += " " + string(p.lit)
 		}
 	}
-	p.Error(pos, msg);
+	p.Error(pos, msg)
 }
 
 
 func (p *parser) expect(tok token.Token) token.Position {
-	pos := p.pos;
+	pos := p.pos
 	if p.tok != tok {
 		p.errorExpected(pos, "'"+tok.String()+"'")
 	}
-	p.next();	// make progress in any case
-	return pos;
+	p.next() // make progress in any case
+	return pos
 }
 
 
 func (p *parser) parseIdentifier() *Name {
-	pos := p.pos;
-	name := string(p.lit);
-	p.expect(token.IDENT);
-	return &Name{pos, name};
+	pos := p.pos
+	name := string(p.lit)
+	p.expect(token.IDENT)
+	return &Name{pos, name}
 }
 
 
 func (p *parser) parseToken() *Token {
-	pos := p.pos;
-	value := "";
+	pos := p.pos
+	value := ""
 	if p.tok == token.STRING {
-		value, _ = strconv.Unquote(string(p.lit));
+		value, _ = strconv.Unquote(string(p.lit))
 		// Unquote may fail with an error, but only if the scanner found
 		// an illegal string in the first place. In this case the error
 		// has already been reported.
-		p.next();
+		p.next()
 	} else {
 		p.expect(token.STRING)
 	}
-	return &Token{pos, value};
+	return &Token{pos, value}
 }
 
 
 func (p *parser) parseTerm() (x Expression) {
-	pos := p.pos;
+	pos := p.pos
 
 	switch p.tok {
 	case token.IDENT:
 		x = p.parseIdentifier()
 
 	case token.STRING:
-		tok := p.parseToken();
-		x = tok;
+		tok := p.parseToken()
+		x = tok
 		if p.tok == token.ELLIPSIS {
-			p.next();
-			x = &Range{tok, p.parseToken()};
+			p.next()
+			x = &Range{tok, p.parseToken()}
 		}
 
 	case token.LPAREN:
-		p.next();
-		x = &Group{pos, p.parseExpression()};
-		p.expect(token.RPAREN);
+		p.next()
+		x = &Group{pos, p.parseExpression()}
+		p.expect(token.RPAREN)
 
 	case token.LBRACK:
-		p.next();
-		x = &Option{pos, p.parseExpression()};
-		p.expect(token.RBRACK);
+		p.next()
+		x = &Option{pos, p.parseExpression()}
+		p.expect(token.RBRACK)
 
 	case token.LBRACE:
-		p.next();
-		x = &Repetition{pos, p.parseExpression()};
-		p.expect(token.RBRACE);
+		p.next()
+		x = &Repetition{pos, p.parseExpression()}
+		p.expect(token.RBRACE)
 	}
 
-	return x;
+	return x
 }
 
 
 func (p *parser) parseSequence() Expression {
-	var list vector.Vector;
+	var list vector.Vector
 
 	for x := p.parseTerm(); x != nil; x = p.parseTerm() {
 		list.Push(x)
@@ -131,26 +131,26 @@ func (p *parser) parseSequence() Expression {
 	}
 
 	// convert list into a sequence
-	seq := make(Sequence, list.Len());
+	seq := make(Sequence, list.Len())
 	for i := 0; i < list.Len(); i++ {
 		seq[i] = list.At(i).(Expression)
 	}
-	return seq;
+	return seq
 }
 
 
 func (p *parser) parseExpression() Expression {
-	var list vector.Vector;
+	var list vector.Vector
 
 	for {
-		x := p.parseSequence();
+		x := p.parseSequence()
 		if x != nil {
 			list.Push(x)
 		}
 		if p.tok != token.OR {
 			break
 		}
-		p.next();
+		p.next()
 	}
 
 	// no need for an Alternative node if list.Len() < 2
@@ -162,33 +162,33 @@ func (p *parser) parseExpression() Expression {
 	}
 
 	// convert list into an Alternative node
-	alt := make(Alternative, list.Len());
+	alt := make(Alternative, list.Len())
 	for i := 0; i < list.Len(); i++ {
 		alt[i] = list.At(i).(Expression)
 	}
-	return alt;
+	return alt
 }
 
 
 func (p *parser) parseProduction() *Production {
-	name := p.parseIdentifier();
-	p.expect(token.ASSIGN);
-	expr := p.parseExpression();
-	p.expect(token.PERIOD);
-	return &Production{name, expr};
+	name := p.parseIdentifier()
+	p.expect(token.ASSIGN)
+	expr := p.parseExpression()
+	p.expect(token.PERIOD)
+	return &Production{name, expr}
 }
 
 
 func (p *parser) parse(filename string, src []byte) Grammar {
 	// initialize parser
-	p.ErrorVector.Reset();
-	p.scanner.Init(filename, src, p, 0);
-	p.next();	// initializes pos, tok, lit
+	p.ErrorVector.Reset()
+	p.scanner.Init(filename, src, p, 0)
+	p.next() // initializes pos, tok, lit
 
-	grammar := make(Grammar);
+	grammar := make(Grammar)
 	for p.tok != token.EOF {
-		prod := p.parseProduction();
-		name := prod.Name.String;
+		prod := p.parseProduction()
+		name := prod.Name.String
 		if _, found := grammar[name]; !found {
 			grammar[name] = prod
 		} else {
@@ -196,7 +196,7 @@ func (p *parser) parse(filename string, src []byte) Grammar {
 		}
 	}
 
-	return grammar;
+	return grammar
 }
 
 
@@ -206,7 +206,7 @@ func (p *parser) parse(filename string, src []byte) Grammar {
 // more than once.
 //
 func Parse(filename string, src []byte) (Grammar, os.Error) {
-	var p parser;
-	grammar := p.parse(filename, src);
-	return grammar, p.GetError(scanner.Sorted);
+	var p parser
+	grammar := p.parse(filename, src)
+	return grammar, p.GetError(scanner.Sorted)
 }
diff --git a/src/pkg/encoding/ascii85/ascii85.go b/src/pkg/encoding/ascii85/ascii85.go
index ac446baf82..67d6ef7edf 100644
--- a/src/pkg/encoding/ascii85/ascii85.go
+++ b/src/pkg/encoding/ascii85/ascii85.go
@@ -7,9 +7,9 @@
 package ascii85
 
 import (
-	"io";
-	"os";
-	"strconv";
+	"io"
+	"os"
+	"strconv"
 )
 
 /*
@@ -30,74 +30,74 @@ func Encode(dst, src []byte) int {
 		return 0
 	}
 
-	n := 0;
+	n := 0
 	for len(src) > 0 {
-		dst[0] = 0;
-		dst[1] = 0;
-		dst[2] = 0;
-		dst[3] = 0;
-		dst[4] = 0;
+		dst[0] = 0
+		dst[1] = 0
+		dst[2] = 0
+		dst[3] = 0
+		dst[4] = 0
 
 		// Unpack 4 bytes into uint32 to repack into base 85 5-byte.
-		var v uint32;
+		var v uint32
 		switch len(src) {
 		default:
-			v |= uint32(src[3]);
-			fallthrough;
+			v |= uint32(src[3])
+			fallthrough
 		case 3:
-			v |= uint32(src[2]) << 8;
-			fallthrough;
+			v |= uint32(src[2]) << 8
+			fallthrough
 		case 2:
-			v |= uint32(src[1]) << 16;
-			fallthrough;
+			v |= uint32(src[1]) << 16
+			fallthrough
 		case 1:
 			v |= uint32(src[0]) << 24
 		}
 
 		// Special case: zero (!!!!!) shortens to z.
 		if v == 0 && len(src) >= 4 {
-			dst[0] = 'z';
-			dst = dst[1:];
-			n++;
-			continue;
+			dst[0] = 'z'
+			dst = dst[1:]
+			n++
+			continue
 		}
 
 		// Otherwise, 5 base 85 digits starting at !.
 		for i := 4; i >= 0; i-- {
-			dst[i] = '!' + byte(v%85);
-			v /= 85;
+			dst[i] = '!' + byte(v%85)
+			v /= 85
 		}
 
 		// If src was short, discard the low destination bytes.
-		m := 5;
+		m := 5
 		if len(src) < 4 {
-			m -= 4 - len(src);
-			src = nil;
+			m -= 4 - len(src)
+			src = nil
 		} else {
 			src = src[4:]
 		}
-		dst = dst[m:];
-		n += m;
+		dst = dst[m:]
+		n += m
 	}
-	return n;
+	return n
 }
 
 // MaxEncodedLen returns the maximum length of an encoding of n source bytes.
-func MaxEncodedLen(n int) int	{ return (n + 3) / 4 * 5 }
+func MaxEncodedLen(n int) int { return (n + 3) / 4 * 5 }
 
 // NewEncoder returns a new ascii85 stream encoder.  Data written to
 // the returned writer will be encoded and then written to w.
 // Ascii85 encodings operate in 32-bit blocks; when finished
 // writing, the caller must Close the returned encoder to flush any
 // trailing partial block.
-func NewEncoder(w io.Writer) io.WriteCloser	{ return &encoder{w: w} }
+func NewEncoder(w io.Writer) io.WriteCloser { return &encoder{w: w} }
 
 type encoder struct {
-	err	os.Error;
-	w	io.Writer;
-	buf	[4]byte;	// buffered data waiting to be encoded
-	nbuf	int;		// number of bytes in buf
-	out	[1024]byte;	// output buffer
+	err  os.Error
+	w    io.Writer
+	buf  [4]byte    // buffered data waiting to be encoded
+	nbuf int        // number of bytes in buf
+	out  [1024]byte // output buffer
 }
 
 func (e *encoder) Write(p []byte) (n int, err os.Error) {
@@ -107,47 +107,47 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 
 	// Leading fringe.
 	if e.nbuf > 0 {
-		var i int;
+		var i int
 		for i = 0; i < len(p) && e.nbuf < 4; i++ {
-			e.buf[e.nbuf] = p[i];
-			e.nbuf++;
+			e.buf[e.nbuf] = p[i]
+			e.nbuf++
 		}
-		n += i;
-		p = p[i:];
+		n += i
+		p = p[i:]
 		if e.nbuf < 4 {
 			return
 		}
-		nout := Encode(&e.out, &e.buf);
+		nout := Encode(&e.out, &e.buf)
 		if _, e.err = e.w.Write(e.out[0:nout]); e.err != nil {
 			return n, e.err
 		}
-		e.nbuf = 0;
+		e.nbuf = 0
 	}
 
 	// Large interior chunks.
 	for len(p) >= 4 {
-		nn := len(e.out) / 5 * 4;
+		nn := len(e.out) / 5 * 4
 		if nn > len(p) {
 			nn = len(p)
 		}
-		nn -= nn % 4;
+		nn -= nn % 4
 		if nn > 0 {
-			nout := Encode(&e.out, p[0:nn]);
+			nout := Encode(&e.out, p[0:nn])
 			if _, e.err = e.w.Write(e.out[0:nout]); e.err != nil {
 				return n, e.err
 			}
 		}
-		n += nn;
-		p = p[nn:];
+		n += nn
+		p = p[nn:]
 	}
 
 	// Trailing fringe.
 	for i := 0; i < len(p); i++ {
 		e.buf[i] = p[i]
 	}
-	e.nbuf = len(p);
-	n += len(p);
-	return;
+	e.nbuf = len(p)
+	n += len(p)
+	return
 }
 
 // Close flushes any pending output from the encoder.
@@ -155,11 +155,11 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 func (e *encoder) Close() os.Error {
 	// If there's anything left in the buffer, flush it out
 	if e.err == nil && e.nbuf > 0 {
-		nout := Encode(&e.out, e.buf[0:e.nbuf]);
-		e.nbuf = 0;
-		_, e.err = e.w.Write(e.out[0:nout]);
+		nout := Encode(&e.out, e.buf[0:e.nbuf])
+		e.nbuf = 0
+		_, e.err = e.w.Write(e.out[0:nout])
 	}
-	return e.err;
+	return e.err
 }
 
 /*
@@ -187,8 +187,8 @@ func (e CorruptInputError) String() string {
 // NewDecoder wraps an io.Reader interface around Decode.
 //
 func Decode(dst, src []byte, flush bool) (ndst, nsrc int, err os.Error) {
-	var v uint32;
-	var nb int;
+	var v uint32
+	var nb int
 	for i, b := range src {
 		if len(dst)-ndst < 4 {
 			return
@@ -197,27 +197,27 @@ func Decode(dst, src []byte, flush bool) (ndst, nsrc int, err os.Error) {
 		case b <= ' ':
 			continue
 		case b == 'z' && nb == 0:
-			nb = 5;
-			v = 0;
+			nb = 5
+			v = 0
 		case '!' <= b && b <= 'u':
-			v = v*85 + uint32(b-'!');
-			nb++;
+			v = v*85 + uint32(b-'!')
+			nb++
 		default:
 			return 0, 0, CorruptInputError(i)
 		}
 		if nb == 5 {
-			nsrc = i + 1;
-			dst[ndst] = byte(v >> 24);
-			dst[ndst+1] = byte(v >> 16);
-			dst[ndst+2] = byte(v >> 8);
-			dst[ndst+3] = byte(v);
-			ndst += 4;
-			nb = 0;
-			v = 0;
+			nsrc = i + 1
+			dst[ndst] = byte(v >> 24)
+			dst[ndst+1] = byte(v >> 16)
+			dst[ndst+2] = byte(v >> 8)
+			dst[ndst+3] = byte(v)
+			ndst += 4
+			nb = 0
+			v = 0
 		}
 	}
 	if flush {
-		nsrc = len(src);
+		nsrc = len(src)
 		if nb > 0 {
 			// The number of output bytes in the last fragment
 			// is the number of leftover input bytes - 1:
@@ -233,27 +233,27 @@ func Decode(dst, src []byte, flush bool) (ndst, nsrc int, err os.Error) {
 				v = v*85 + 84
 			}
 			for i := 0; i < nb-1; i++ {
-				dst[ndst] = byte(v >> 24);
-				v <<= 8;
-				ndst++;
+				dst[ndst] = byte(v >> 24)
+				v <<= 8
+				ndst++
 			}
 		}
 	}
-	return;
+	return
 }
 
 // NewDecoder constructs a new ascii85 stream decoder.
-func NewDecoder(r io.Reader) io.Reader	{ return &decoder{r: r} }
+func NewDecoder(r io.Reader) io.Reader { return &decoder{r: r} }
 
 type decoder struct {
-	err	os.Error;
-	readErr	os.Error;
-	r	io.Reader;
-	end	bool;		// saw end of message
-	buf	[1024]byte;	// leftover input
-	nbuf	int;
-	out	[]byte;	// leftover decoded output
-	outbuf	[1024]byte;
+	err     os.Error
+	readErr os.Error
+	r       io.Reader
+	end     bool       // saw end of message
+	buf     [1024]byte // leftover input
+	nbuf    int
+	out     []byte // leftover decoded output
+	outbuf  [1024]byte
 }
 
 func (d *decoder) Read(p []byte) (n int, err os.Error) {
@@ -267,19 +267,19 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 	for {
 		// Copy leftover output from last decode.
 		if len(d.out) > 0 {
-			n = copy(p, d.out);
-			d.out = d.out[n:];
-			return;
+			n = copy(p, d.out)
+			d.out = d.out[n:]
+			return
 		}
 
 		// Decode leftover input from last read.
-		var nn, nsrc, ndst int;
+		var nn, nsrc, ndst int
 		if d.nbuf > 0 {
-			ndst, nsrc, d.err = Decode(&d.outbuf, d.buf[0:d.nbuf], d.readErr != nil);
+			ndst, nsrc, d.err = Decode(&d.outbuf, d.buf[0:d.nbuf], d.readErr != nil)
 			if ndst > 0 {
-				d.out = d.outbuf[0:ndst];
-				d.nbuf = copy(&d.buf, d.buf[nsrc:d.nbuf]);
-				continue;	// copy out and return
+				d.out = d.outbuf[0:ndst]
+				d.nbuf = copy(&d.buf, d.buf[nsrc:d.nbuf])
+				continue // copy out and return
 			}
 		}
 
@@ -288,13 +288,13 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 			return 0, d.err
 		}
 		if d.readErr != nil {
-			d.err = d.readErr;
-			return 0, d.err;
+			d.err = d.readErr
+			return 0, d.err
 		}
 
 		// Read more data.
-		nn, d.readErr = d.r.Read(d.buf[d.nbuf:]);
-		d.nbuf += nn;
+		nn, d.readErr = d.r.Read(d.buf[d.nbuf:])
+		d.nbuf += nn
 	}
-	panic("unreachable");
+	panic("unreachable")
 }
diff --git a/src/pkg/encoding/ascii85/ascii85_test.go b/src/pkg/encoding/ascii85/ascii85_test.go
index 5ac49c675c..7eb245ee26 100644
--- a/src/pkg/encoding/ascii85/ascii85_test.go
+++ b/src/pkg/encoding/ascii85/ascii85_test.go
@@ -5,16 +5,16 @@
 package ascii85
 
 import (
-	"bytes";
-	"io/ioutil";
-	"os";
-	"reflect";
-	"strings";
-	"testing";
+	"bytes"
+	"io/ioutil"
+	"os"
+	"reflect"
+	"strings"
+	"testing"
 )
 
 type testpair struct {
-	decoded, encoded string;
+	decoded, encoded string
 }
 
 var pairs = []testpair{
@@ -35,88 +35,88 @@ var pairs = []testpair{
 var bigtest = pairs[len(pairs)-1]
 
 func testEqual(t *testing.T, msg string, args ...) bool {
-	v := reflect.NewValue(args).(*reflect.StructValue);
-	v1 := v.Field(v.NumField() - 2);
-	v2 := v.Field(v.NumField() - 1);
+	v := reflect.NewValue(args).(*reflect.StructValue)
+	v1 := v.Field(v.NumField() - 2)
+	v2 := v.Field(v.NumField() - 1)
 	if v1.Interface() != v2.Interface() {
-		t.Errorf(msg, args);
-		return false;
+		t.Errorf(msg, args)
+		return false
 	}
-	return true;
+	return true
 }
 
 func strip85(s string) string {
-	t := make([]byte, len(s));
-	w := 0;
+	t := make([]byte, len(s))
+	w := 0
 	for r := 0; r < len(s); r++ {
-		c := s[r];
+		c := s[r]
 		if c > ' ' {
-			t[w] = c;
-			w++;
+			t[w] = c
+			w++
 		}
 	}
-	return string(t[0:w]);
+	return string(t[0:w])
 }
 
 func TestEncode(t *testing.T) {
 	for _, p := range pairs {
-		buf := make([]byte, MaxEncodedLen(len(p.decoded)));
-		n := Encode(buf, strings.Bytes(p.decoded));
-		buf = buf[0:n];
-		testEqual(t, "Encode(%q) = %q, want %q", p.decoded, strip85(string(buf)), strip85(p.encoded));
+		buf := make([]byte, MaxEncodedLen(len(p.decoded)))
+		n := Encode(buf, strings.Bytes(p.decoded))
+		buf = buf[0:n]
+		testEqual(t, "Encode(%q) = %q, want %q", p.decoded, strip85(string(buf)), strip85(p.encoded))
 	}
 }
 
 func TestEncoder(t *testing.T) {
 	for _, p := range pairs {
-		bb := &bytes.Buffer{};
-		encoder := NewEncoder(bb);
-		encoder.Write(strings.Bytes(p.decoded));
-		encoder.Close();
-		testEqual(t, "Encode(%q) = %q, want %q", p.decoded, strip85(bb.String()), strip85(p.encoded));
+		bb := &bytes.Buffer{}
+		encoder := NewEncoder(bb)
+		encoder.Write(strings.Bytes(p.decoded))
+		encoder.Close()
+		testEqual(t, "Encode(%q) = %q, want %q", p.decoded, strip85(bb.String()), strip85(p.encoded))
 	}
 }
 
 func TestEncoderBuffering(t *testing.T) {
-	input := strings.Bytes(bigtest.decoded);
+	input := strings.Bytes(bigtest.decoded)
 	for bs := 1; bs <= 12; bs++ {
-		bb := &bytes.Buffer{};
-		encoder := NewEncoder(bb);
+		bb := &bytes.Buffer{}
+		encoder := NewEncoder(bb)
 		for pos := 0; pos < len(input); pos += bs {
-			end := pos + bs;
+			end := pos + bs
 			if end > len(input) {
 				end = len(input)
 			}
-			n, err := encoder.Write(input[pos:end]);
-			testEqual(t, "Write(%q) gave error %v, want %v", input[pos:end], err, os.Error(nil));
-			testEqual(t, "Write(%q) gave length %v, want %v", input[pos:end], n, end-pos);
+			n, err := encoder.Write(input[pos:end])
+			testEqual(t, "Write(%q) gave error %v, want %v", input[pos:end], err, os.Error(nil))
+			testEqual(t, "Write(%q) gave length %v, want %v", input[pos:end], n, end-pos)
 		}
-		err := encoder.Close();
-		testEqual(t, "Close gave error %v, want %v", err, os.Error(nil));
-		testEqual(t, "Encoding/%d of %q = %q, want %q", bs, bigtest.decoded, strip85(bb.String()), strip85(bigtest.encoded));
+		err := encoder.Close()
+		testEqual(t, "Close gave error %v, want %v", err, os.Error(nil))
+		testEqual(t, "Encoding/%d of %q = %q, want %q", bs, bigtest.decoded, strip85(bb.String()), strip85(bigtest.encoded))
 	}
 }
 
 func TestDecode(t *testing.T) {
 	for _, p := range pairs {
-		dbuf := make([]byte, 4*len(p.encoded));
-		ndst, nsrc, err := Decode(dbuf, strings.Bytes(p.encoded), true);
-		testEqual(t, "Decode(%q) = error %v, want %v", p.encoded, err, os.Error(nil));
-		testEqual(t, "Decode(%q) = nsrc %v, want %v", p.encoded, nsrc, len(p.encoded));
-		testEqual(t, "Decode(%q) = ndst %v, want %v", p.encoded, ndst, len(p.decoded));
-		testEqual(t, "Decode(%q) = %q, want %q", p.encoded, string(dbuf[0:ndst]), p.decoded);
+		dbuf := make([]byte, 4*len(p.encoded))
+		ndst, nsrc, err := Decode(dbuf, strings.Bytes(p.encoded), true)
+		testEqual(t, "Decode(%q) = error %v, want %v", p.encoded, err, os.Error(nil))
+		testEqual(t, "Decode(%q) = nsrc %v, want %v", p.encoded, nsrc, len(p.encoded))
+		testEqual(t, "Decode(%q) = ndst %v, want %v", p.encoded, ndst, len(p.decoded))
+		testEqual(t, "Decode(%q) = %q, want %q", p.encoded, string(dbuf[0:ndst]), p.decoded)
 	}
 }
 
 func TestDecoder(t *testing.T) {
 	for _, p := range pairs {
-		decoder := NewDecoder(bytes.NewBufferString(p.encoded));
-		dbuf, err := ioutil.ReadAll(decoder);
+		decoder := NewDecoder(bytes.NewBufferString(p.encoded))
+		dbuf, err := ioutil.ReadAll(decoder)
 		if err != nil {
 			t.Fatal("Read failed", err)
 		}
-		testEqual(t, "Read from %q = length %v, want %v", p.encoded, len(dbuf), len(p.decoded));
-		testEqual(t, "Decoding of %q = %q, want %q", p.encoded, string(dbuf), p.decoded);
+		testEqual(t, "Read from %q = length %v, want %v", p.encoded, len(dbuf), len(p.decoded))
+		testEqual(t, "Decoding of %q = %q, want %q", p.encoded, string(dbuf), p.decoded)
 		if err != nil {
 			testEqual(t, "Read from %q = %v, want %v", p.encoded, err, os.EOF)
 		}
@@ -125,31 +125,31 @@ func TestDecoder(t *testing.T) {
 
 func TestDecoderBuffering(t *testing.T) {
 	for bs := 1; bs <= 12; bs++ {
-		decoder := NewDecoder(bytes.NewBufferString(bigtest.encoded));
-		buf := make([]byte, len(bigtest.decoded)+12);
-		var total int;
+		decoder := NewDecoder(bytes.NewBufferString(bigtest.encoded))
+		buf := make([]byte, len(bigtest.decoded)+12)
+		var total int
 		for total = 0; total < len(bigtest.decoded); {
-			n, err := decoder.Read(buf[total : total+bs]);
-			testEqual(t, "Read from %q at pos %d = %d, %v, want _, %v", bigtest.encoded, total, n, err, os.Error(nil));
-			total += n;
+			n, err := decoder.Read(buf[total : total+bs])
+			testEqual(t, "Read from %q at pos %d = %d, %v, want _, %v", bigtest.encoded, total, n, err, os.Error(nil))
+			total += n
 		}
-		testEqual(t, "Decoding/%d of %q = %q, want %q", bs, bigtest.encoded, string(buf[0:total]), bigtest.decoded);
+		testEqual(t, "Decoding/%d of %q = %q, want %q", bs, bigtest.encoded, string(buf[0:total]), bigtest.decoded)
 	}
 }
 
 func TestDecodeCorrupt(t *testing.T) {
 	type corrupt struct {
-		e	string;
-		p	int;
+		e string
+		p int
 	}
 	examples := []corrupt{
 		corrupt{"v", 0},
 		corrupt{"!z!!!!!!!!!", 1},
-	};
+	}
 
 	for _, e := range examples {
-		dbuf := make([]byte, 4*len(e.e));
-		_, _, err := Decode(dbuf, strings.Bytes(e.e), true);
+		dbuf := make([]byte, 4*len(e.e))
+		_, _, err := Decode(dbuf, strings.Bytes(e.e), true)
 		switch err := err.(type) {
 		case CorruptInputError:
 			testEqual(t, "Corruption in %q at offset %v, want %v", e.e, int(err), e.p)
@@ -160,34 +160,34 @@ func TestDecodeCorrupt(t *testing.T) {
 }
 
 func TestBig(t *testing.T) {
-	n := 3*1000 + 1;
-	raw := make([]byte, n);
-	const alpha = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
+	n := 3*1000 + 1
+	raw := make([]byte, n)
+	const alpha = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
 	for i := 0; i < n; i++ {
 		raw[i] = alpha[i%len(alpha)]
 	}
-	encoded := new(bytes.Buffer);
-	w := NewEncoder(encoded);
-	nn, err := w.Write(raw);
+	encoded := new(bytes.Buffer)
+	w := NewEncoder(encoded)
+	nn, err := w.Write(raw)
 	if nn != n || err != nil {
 		t.Fatalf("Encoder.Write(raw) = %d, %v want %d, nil", nn, err, n)
 	}
-	err = w.Close();
+	err = w.Close()
 	if err != nil {
 		t.Fatalf("Encoder.Close() = %v want nil", err)
 	}
-	decoded, err := ioutil.ReadAll(NewDecoder(encoded));
+	decoded, err := ioutil.ReadAll(NewDecoder(encoded))
 	if err != nil {
 		t.Fatalf("io.ReadAll(NewDecoder(...)): %v", err)
 	}
 
 	if !bytes.Equal(raw, decoded) {
-		var i int;
+		var i int
 		for i = 0; i < len(decoded) && i < len(raw); i++ {
 			if decoded[i] != raw[i] {
 				break
 			}
 		}
-		t.Errorf("Decode(Encode(%d-byte string)) failed at offset %d", n, i);
+		t.Errorf("Decode(Encode(%d-byte string)) failed at offset %d", n, i)
 	}
 }
diff --git a/src/pkg/encoding/base64/base64.go b/src/pkg/encoding/base64/base64.go
index e7b7f4da40..d4429094a2 100644
--- a/src/pkg/encoding/base64/base64.go
+++ b/src/pkg/encoding/base64/base64.go
@@ -6,9 +6,9 @@
 package base64
 
 import (
-	"io";
-	"os";
-	"strconv";
+	"io"
+	"os"
+	"strconv"
 )
 
 /*
@@ -21,8 +21,8 @@ import (
 // (RFC 1421).  RFC 4648 also defines an alternate encoding, which is
 // the standard encoding with - and _ substituted for + and /.
 type Encoding struct {
-	encode		string;
-	decodeMap	[256]byte;
+	encode    string
+	decodeMap [256]byte
 }
 
 const encodeStd = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
@@ -31,15 +31,15 @@ const encodeURL = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678
 // NewEncoding returns a new Encoding defined by the given alphabet,
 // which must be a 64-byte string.
 func NewEncoding(encoder string) *Encoding {
-	e := new(Encoding);
-	e.encode = encoder;
+	e := new(Encoding)
+	e.encode = encoder
 	for i := 0; i < len(e.decodeMap); i++ {
 		e.decodeMap[i] = 0xFF
 	}
 	for i := 0; i < len(encoder); i++ {
 		e.decodeMap[encoder[i]] = byte(i)
 	}
-	return e;
+	return e
 }
 
 // StdEncoding is the standard base64 encoding, as defined in
@@ -66,25 +66,25 @@ func (enc *Encoding) Encode(dst, src []byte) {
 	}
 
 	for len(src) > 0 {
-		dst[0] = 0;
-		dst[1] = 0;
-		dst[2] = 0;
-		dst[3] = 0;
+		dst[0] = 0
+		dst[1] = 0
+		dst[2] = 0
+		dst[3] = 0
 
 		// Unpack 4x 6-bit source blocks into a 4 byte
 		// destination quantum
 		switch len(src) {
 		default:
-			dst[3] |= src[2] & 0x3F;
-			dst[2] |= src[2] >> 6;
-			fallthrough;
+			dst[3] |= src[2] & 0x3F
+			dst[2] |= src[2] >> 6
+			fallthrough
 		case 2:
-			dst[2] |= (src[1] << 2) & 0x3F;
-			dst[1] |= src[1] >> 4;
-			fallthrough;
+			dst[2] |= (src[1] << 2) & 0x3F
+			dst[1] |= src[1] >> 4
+			fallthrough
 		case 1:
-			dst[1] |= (src[0] << 4) & 0x3F;
-			dst[0] |= src[0] >> 2;
+			dst[1] |= (src[0] << 4) & 0x3F
+			dst[0] |= src[0] >> 2
 		}
 
 		// Encode 6-bit blocks using the base64 alphabet
@@ -94,25 +94,25 @@ func (enc *Encoding) Encode(dst, src []byte) {
 
 		// Pad the final quantum
 		if len(src) < 3 {
-			dst[3] = '=';
+			dst[3] = '='
 			if len(src) < 2 {
 				dst[2] = '='
 			}
-			break;
+			break
 		}
 
-		src = src[3:];
-		dst = dst[4:];
+		src = src[3:]
+		dst = dst[4:]
 	}
 }
 
 type encoder struct {
-	err	os.Error;
-	enc	*Encoding;
-	w	io.Writer;
-	buf	[3]byte;	// buffered data waiting to be encoded
-	nbuf	int;		// number of bytes in buf
-	out	[1024]byte;	// output buffer
+	err  os.Error
+	enc  *Encoding
+	w    io.Writer
+	buf  [3]byte    // buffered data waiting to be encoded
+	nbuf int        // number of bytes in buf
+	out  [1024]byte // output buffer
 }
 
 func (e *encoder) Write(p []byte) (n int, err os.Error) {
@@ -122,47 +122,47 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 
 	// Leading fringe.
 	if e.nbuf > 0 {
-		var i int;
+		var i int
 		for i = 0; i < len(p) && e.nbuf < 3; i++ {
-			e.buf[e.nbuf] = p[i];
-			e.nbuf++;
+			e.buf[e.nbuf] = p[i]
+			e.nbuf++
 		}
-		n += i;
-		p = p[i:];
+		n += i
+		p = p[i:]
 		if e.nbuf < 3 {
 			return
 		}
-		e.enc.Encode(&e.out, &e.buf);
+		e.enc.Encode(&e.out, &e.buf)
 		if _, e.err = e.w.Write(e.out[0:4]); e.err != nil {
 			return n, e.err
 		}
-		e.nbuf = 0;
+		e.nbuf = 0
 	}
 
 	// Large interior chunks.
 	for len(p) >= 3 {
-		nn := len(e.out) / 4 * 3;
+		nn := len(e.out) / 4 * 3
 		if nn > len(p) {
 			nn = len(p)
 		}
-		nn -= nn % 3;
+		nn -= nn % 3
 		if nn > 0 {
-			e.enc.Encode(&e.out, p[0:nn]);
+			e.enc.Encode(&e.out, p[0:nn])
 			if _, e.err = e.w.Write(e.out[0 : nn/3*4]); e.err != nil {
 				return n, e.err
 			}
 		}
-		n += nn;
-		p = p[nn:];
+		n += nn
+		p = p[nn:]
 	}
 
 	// Trailing fringe.
 	for i := 0; i < len(p); i++ {
 		e.buf[i] = p[i]
 	}
-	e.nbuf = len(p);
-	n += len(p);
-	return;
+	e.nbuf = len(p)
+	n += len(p)
+	return
 }
 
 // Close flushes any pending output from the encoder.
@@ -170,11 +170,11 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 func (e *encoder) Close() os.Error {
 	// If there's anything left in the buffer, flush it out
 	if e.err == nil && e.nbuf > 0 {
-		e.enc.Encode(&e.out, e.buf[0:e.nbuf]);
-		e.nbuf = 0;
-		_, e.err = e.w.Write(e.out[0:4]);
+		e.enc.Encode(&e.out, e.buf[0:e.nbuf])
+		e.nbuf = 0
+		_, e.err = e.w.Write(e.out[0:4])
 	}
-	return e.err;
+	return e.err
 }
 
 // NewEncoder returns a new base64 stream encoder.  Data written to
@@ -188,7 +188,7 @@ func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser {
 
 // EncodedLen returns the length in bytes of the base64 encoding
 // of an input buffer of length n.
-func (enc *Encoding) EncodedLen(n int) int	{ return (n + 2) / 3 * 4 }
+func (enc *Encoding) EncodedLen(n int) int { return (n + 2) / 3 * 4 }
 
 /*
  * Decoder
@@ -207,23 +207,23 @@ func (e CorruptInputError) String() string {
 func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err os.Error) {
 	for i := 0; i < len(src)/4 && !end; i++ {
 		// Decode quantum using the base64 alphabet
-		var dbuf [4]byte;
-		dlen := 4;
+		var dbuf [4]byte
+		dlen := 4
 
 	dbufloop:
 		for j := 0; j < 4; j++ {
-			in := src[i*4+j];
+			in := src[i*4+j]
 			if in == '=' && j >= 2 && i == len(src)/4-1 {
 				// We've reached the end and there's
 				// padding
 				if src[i*4+3] != '=' {
 					return n, false, CorruptInputError(i*4 + 2)
 				}
-				dlen = j;
-				end = true;
-				break dbufloop;
+				dlen = j
+				end = true
+				break dbufloop
 			}
-			dbuf[j] = enc.decodeMap[in];
+			dbuf[j] = enc.decodeMap[in]
 			if dbuf[j] == 0xFF {
 				return n, false, CorruptInputError(i*4 + j)
 			}
@@ -233,18 +233,18 @@ func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err os.Error) {
 		// quantum
 		switch dlen {
 		case 4:
-			dst[i*3+2] = dbuf[2]<<6 | dbuf[3];
-			fallthrough;
+			dst[i*3+2] = dbuf[2]<<6 | dbuf[3]
+			fallthrough
 		case 3:
-			dst[i*3+1] = dbuf[1]<<4 | dbuf[2]>>2;
-			fallthrough;
+			dst[i*3+1] = dbuf[1]<<4 | dbuf[2]>>2
+			fallthrough
 		case 2:
 			dst[i*3+0] = dbuf[0]<<2 | dbuf[1]>>4
 		}
-		n += dlen - 1;
+		n += dlen - 1
 	}
 
-	return n, end, nil;
+	return n, end, nil
 }
 
 // Decode decodes src using the encoding enc.  It writes at most
@@ -256,19 +256,19 @@ func (enc *Encoding) Decode(dst, src []byte) (n int, err os.Error) {
 		return 0, CorruptInputError(len(src) / 4 * 4)
 	}
 
-	n, _, err = enc.decode(dst, src);
-	return;
+	n, _, err = enc.decode(dst, src)
+	return
 }
 
 type decoder struct {
-	err	os.Error;
-	enc	*Encoding;
-	r	io.Reader;
-	end	bool;		// saw end of message
-	buf	[1024]byte;	// leftover input
-	nbuf	int;
-	out	[]byte;	// leftover decoded output
-	outbuf	[1024 / 4 * 3]byte;
+	err    os.Error
+	enc    *Encoding
+	r      io.Reader
+	end    bool       // saw end of message
+	buf    [1024]byte // leftover input
+	nbuf   int
+	out    []byte // leftover decoded output
+	outbuf [1024 / 4 * 3]byte
 }
 
 func (d *decoder) Read(p []byte) (n int, err os.Error) {
@@ -278,37 +278,37 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 
 	// Use leftover decoded output from last read.
 	if len(d.out) > 0 {
-		n = copy(p, d.out);
-		d.out = d.out[n:];
-		return n, nil;
+		n = copy(p, d.out)
+		d.out = d.out[n:]
+		return n, nil
 	}
 
 	// Read a chunk.
-	nn := len(p) / 3 * 4;
+	nn := len(p) / 3 * 4
 	if nn < 4 {
 		nn = 4
 	}
 	if nn > len(d.buf) {
 		nn = len(d.buf)
 	}
-	nn, d.err = io.ReadAtLeast(d.r, d.buf[d.nbuf:nn], 4-d.nbuf);
-	d.nbuf += nn;
+	nn, d.err = io.ReadAtLeast(d.r, d.buf[d.nbuf:nn], 4-d.nbuf)
+	d.nbuf += nn
 	if d.nbuf < 4 {
 		return 0, d.err
 	}
 
 	// Decode chunk into p, or d.out and then p if p is too small.
-	nr := d.nbuf / 4 * 4;
-	nw := d.nbuf / 4 * 3;
+	nr := d.nbuf / 4 * 4
+	nw := d.nbuf / 4 * 3
 	if nw > len(p) {
-		nw, d.end, d.err = d.enc.decode(&d.outbuf, d.buf[0:nr]);
-		d.out = d.outbuf[0:nw];
-		n = copy(p, d.out);
-		d.out = d.out[n:];
+		nw, d.end, d.err = d.enc.decode(&d.outbuf, d.buf[0:nr])
+		d.out = d.outbuf[0:nw]
+		n = copy(p, d.out)
+		d.out = d.out[n:]
 	} else {
 		n, d.end, d.err = d.enc.decode(p, d.buf[0:nr])
 	}
-	d.nbuf -= nr;
+	d.nbuf -= nr
 	for i := 0; i < d.nbuf; i++ {
 		d.buf[i] = d.buf[i+nr]
 	}
@@ -316,7 +316,7 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 	if d.err == nil {
 		d.err = err
 	}
-	return n, d.err;
+	return n, d.err
 }
 
 // NewDecoder constructs a new base64 stream decoder.
@@ -326,4 +326,4 @@ func NewDecoder(enc *Encoding, r io.Reader) io.Reader {
 
 // DecodeLen returns the maximum length in bytes of the decoded data
 // corresponding to n bytes of base64-encoded data.
-func (enc *Encoding) DecodedLen(n int) int	{ return n / 4 * 3 }
+func (enc *Encoding) DecodedLen(n int) int { return n / 4 * 3 }
diff --git a/src/pkg/encoding/base64/base64_test.go b/src/pkg/encoding/base64/base64_test.go
index 3153a73470..fe66cff7e6 100644
--- a/src/pkg/encoding/base64/base64_test.go
+++ b/src/pkg/encoding/base64/base64_test.go
@@ -5,16 +5,16 @@
 package base64
 
 import (
-	"bytes";
-	"io/ioutil";
-	"os";
-	"reflect";
-	"strings";
-	"testing";
+	"bytes"
+	"io/ioutil"
+	"os"
+	"reflect"
+	"strings"
+	"testing"
 )
 
 type testpair struct {
-	decoded, encoded string;
+	decoded, encoded string
 }
 
 var pairs = []testpair{
@@ -49,102 +49,102 @@ var bigtest = testpair{
 }
 
 func testEqual(t *testing.T, msg string, args ...) bool {
-	v := reflect.NewValue(args).(*reflect.StructValue);
-	v1 := v.Field(v.NumField() - 2);
-	v2 := v.Field(v.NumField() - 1);
+	v := reflect.NewValue(args).(*reflect.StructValue)
+	v1 := v.Field(v.NumField() - 2)
+	v2 := v.Field(v.NumField() - 1)
 	if v1.Interface() != v2.Interface() {
-		t.Errorf(msg, args);
-		return false;
+		t.Errorf(msg, args)
+		return false
 	}
-	return true;
+	return true
 }
 
 func TestEncode(t *testing.T) {
 	for _, p := range pairs {
-		buf := make([]byte, StdEncoding.EncodedLen(len(p.decoded)));
-		StdEncoding.Encode(buf, strings.Bytes(p.decoded));
-		testEqual(t, "Encode(%q) = %q, want %q", p.decoded, string(buf), p.encoded);
+		buf := make([]byte, StdEncoding.EncodedLen(len(p.decoded)))
+		StdEncoding.Encode(buf, strings.Bytes(p.decoded))
+		testEqual(t, "Encode(%q) = %q, want %q", p.decoded, string(buf), p.encoded)
 	}
 }
 
 func TestEncoder(t *testing.T) {
 	for _, p := range pairs {
-		bb := &bytes.Buffer{};
-		encoder := NewEncoder(StdEncoding, bb);
-		encoder.Write(strings.Bytes(p.decoded));
-		encoder.Close();
-		testEqual(t, "Encode(%q) = %q, want %q", p.decoded, bb.String(), p.encoded);
+		bb := &bytes.Buffer{}
+		encoder := NewEncoder(StdEncoding, bb)
+		encoder.Write(strings.Bytes(p.decoded))
+		encoder.Close()
+		testEqual(t, "Encode(%q) = %q, want %q", p.decoded, bb.String(), p.encoded)
 	}
 }
 
 func TestEncoderBuffering(t *testing.T) {
-	input := strings.Bytes(bigtest.decoded);
+	input := strings.Bytes(bigtest.decoded)
 	for bs := 1; bs <= 12; bs++ {
-		bb := &bytes.Buffer{};
-		encoder := NewEncoder(StdEncoding, bb);
+		bb := &bytes.Buffer{}
+		encoder := NewEncoder(StdEncoding, bb)
 		for pos := 0; pos < len(input); pos += bs {
-			end := pos + bs;
+			end := pos + bs
 			if end > len(input) {
 				end = len(input)
 			}
-			n, err := encoder.Write(input[pos:end]);
-			testEqual(t, "Write(%q) gave error %v, want %v", input[pos:end], err, os.Error(nil));
-			testEqual(t, "Write(%q) gave length %v, want %v", input[pos:end], n, end-pos);
+			n, err := encoder.Write(input[pos:end])
+			testEqual(t, "Write(%q) gave error %v, want %v", input[pos:end], err, os.Error(nil))
+			testEqual(t, "Write(%q) gave length %v, want %v", input[pos:end], n, end-pos)
 		}
-		err := encoder.Close();
-		testEqual(t, "Close gave error %v, want %v", err, os.Error(nil));
-		testEqual(t, "Encoding/%d of %q = %q, want %q", bs, bigtest.decoded, bb.String(), bigtest.encoded);
+		err := encoder.Close()
+		testEqual(t, "Close gave error %v, want %v", err, os.Error(nil))
+		testEqual(t, "Encoding/%d of %q = %q, want %q", bs, bigtest.decoded, bb.String(), bigtest.encoded)
 	}
 }
 
 func TestDecode(t *testing.T) {
 	for _, p := range pairs {
-		dbuf := make([]byte, StdEncoding.DecodedLen(len(p.encoded)));
-		count, end, err := StdEncoding.decode(dbuf, strings.Bytes(p.encoded));
-		testEqual(t, "Decode(%q) = error %v, want %v", p.encoded, err, os.Error(nil));
-		testEqual(t, "Decode(%q) = length %v, want %v", p.encoded, count, len(p.decoded));
+		dbuf := make([]byte, StdEncoding.DecodedLen(len(p.encoded)))
+		count, end, err := StdEncoding.decode(dbuf, strings.Bytes(p.encoded))
+		testEqual(t, "Decode(%q) = error %v, want %v", p.encoded, err, os.Error(nil))
+		testEqual(t, "Decode(%q) = length %v, want %v", p.encoded, count, len(p.decoded))
 		if len(p.encoded) > 0 {
 			testEqual(t, "Decode(%q) = end %v, want %v", p.encoded, end, (p.encoded[len(p.encoded)-1] == '='))
 		}
-		testEqual(t, "Decode(%q) = %q, want %q", p.encoded, string(dbuf[0:count]), p.decoded);
+		testEqual(t, "Decode(%q) = %q, want %q", p.encoded, string(dbuf[0:count]), p.decoded)
 	}
 }
 
 func TestDecoder(t *testing.T) {
 	for _, p := range pairs {
-		decoder := NewDecoder(StdEncoding, bytes.NewBufferString(p.encoded));
-		dbuf := make([]byte, StdEncoding.DecodedLen(len(p.encoded)));
-		count, err := decoder.Read(dbuf);
+		decoder := NewDecoder(StdEncoding, bytes.NewBufferString(p.encoded))
+		dbuf := make([]byte, StdEncoding.DecodedLen(len(p.encoded)))
+		count, err := decoder.Read(dbuf)
 		if err != nil && err != os.EOF {
 			t.Fatal("Read failed", err)
 		}
-		testEqual(t, "Read from %q = length %v, want %v", p.encoded, count, len(p.decoded));
-		testEqual(t, "Decoding of %q = %q, want %q", p.encoded, string(dbuf[0:count]), p.decoded);
+		testEqual(t, "Read from %q = length %v, want %v", p.encoded, count, len(p.decoded))
+		testEqual(t, "Decoding of %q = %q, want %q", p.encoded, string(dbuf[0:count]), p.decoded)
 		if err != os.EOF {
 			count, err = decoder.Read(dbuf)
 		}
-		testEqual(t, "Read from %q = %v, want %v", p.encoded, err, os.EOF);
+		testEqual(t, "Read from %q = %v, want %v", p.encoded, err, os.EOF)
 	}
 }
 
 func TestDecoderBuffering(t *testing.T) {
 	for bs := 1; bs <= 12; bs++ {
-		decoder := NewDecoder(StdEncoding, bytes.NewBufferString(bigtest.encoded));
-		buf := make([]byte, len(bigtest.decoded)+12);
-		var total int;
+		decoder := NewDecoder(StdEncoding, bytes.NewBufferString(bigtest.encoded))
+		buf := make([]byte, len(bigtest.decoded)+12)
+		var total int
 		for total = 0; total < len(bigtest.decoded); {
-			n, err := decoder.Read(buf[total : total+bs]);
-			testEqual(t, "Read from %q at pos %d = %d, %v, want _, %v", bigtest.encoded, total, n, err, os.Error(nil));
-			total += n;
+			n, err := decoder.Read(buf[total : total+bs])
+			testEqual(t, "Read from %q at pos %d = %d, %v, want _, %v", bigtest.encoded, total, n, err, os.Error(nil))
+			total += n
 		}
-		testEqual(t, "Decoding/%d of %q = %q, want %q", bs, bigtest.encoded, string(buf[0:total]), bigtest.decoded);
+		testEqual(t, "Decoding/%d of %q = %q, want %q", bs, bigtest.encoded, string(buf[0:total]), bigtest.decoded)
 	}
 }
 
 func TestDecodeCorrupt(t *testing.T) {
 	type corrupt struct {
-		e	string;
-		p	int;
+		e string
+		p int
 	}
 	examples := []corrupt{
 		corrupt{"!!!!", 0},
@@ -153,11 +153,11 @@ func TestDecodeCorrupt(t *testing.T) {
 		corrupt{"AAA=AAAA", 3},
 		corrupt{"AAAAA", 4},
 		corrupt{"AAAAAA", 4},
-	};
+	}
 
 	for _, e := range examples {
-		dbuf := make([]byte, StdEncoding.DecodedLen(len(e.e)));
-		_, err := StdEncoding.Decode(dbuf, strings.Bytes(e.e));
+		dbuf := make([]byte, StdEncoding.DecodedLen(len(e.e)))
+		_, err := StdEncoding.Decode(dbuf, strings.Bytes(e.e))
 		switch err := err.(type) {
 		case CorruptInputError:
 			testEqual(t, "Corruption in %q at offset %v, want %v", e.e, int(err), e.p)
@@ -168,34 +168,34 @@ func TestDecodeCorrupt(t *testing.T) {
 }
 
 func TestBig(t *testing.T) {
-	n := 3*1000 + 1;
-	raw := make([]byte, n);
-	const alpha = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
+	n := 3*1000 + 1
+	raw := make([]byte, n)
+	const alpha = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
 	for i := 0; i < n; i++ {
 		raw[i] = alpha[i%len(alpha)]
 	}
-	encoded := new(bytes.Buffer);
-	w := NewEncoder(StdEncoding, encoded);
-	nn, err := w.Write(raw);
+	encoded := new(bytes.Buffer)
+	w := NewEncoder(StdEncoding, encoded)
+	nn, err := w.Write(raw)
 	if nn != n || err != nil {
 		t.Fatalf("Encoder.Write(raw) = %d, %v want %d, nil", nn, err, n)
 	}
-	err = w.Close();
+	err = w.Close()
 	if err != nil {
 		t.Fatalf("Encoder.Close() = %v want nil", err)
 	}
-	decoded, err := ioutil.ReadAll(NewDecoder(StdEncoding, encoded));
+	decoded, err := ioutil.ReadAll(NewDecoder(StdEncoding, encoded))
 	if err != nil {
 		t.Fatalf("ioutil.ReadAll(NewDecoder(...)): %v", err)
 	}
 
 	if !bytes.Equal(raw, decoded) {
-		var i int;
+		var i int
 		for i = 0; i < len(decoded) && i < len(raw); i++ {
 			if decoded[i] != raw[i] {
 				break
 			}
 		}
-		t.Errorf("Decode(Encode(%d-byte string)) failed at offset %d", n, i);
+		t.Errorf("Decode(Encode(%d-byte string)) failed at offset %d", n, i)
 	}
 }
diff --git a/src/pkg/encoding/binary/binary.go b/src/pkg/encoding/binary/binary.go
index 419ec03a51..36f2366d64 100644
--- a/src/pkg/encoding/binary/binary.go
+++ b/src/pkg/encoding/binary/binary.go
@@ -7,22 +7,22 @@
 package binary
 
 import (
-	"math";
-	"io";
-	"os";
-	"reflect";
+	"math"
+	"io"
+	"os"
+	"reflect"
 )
 
 // A ByteOrder specifies how to convert byte sequences into
 // 16-, 32-, or 64-bit unsigned integers.
 type ByteOrder interface {
-	Uint16(b []byte) uint16;
-	Uint32(b []byte) uint32;
-	Uint64(b []byte) uint64;
-	PutUint16([]byte, uint16);
-	PutUint32([]byte, uint32);
-	PutUint64([]byte, uint64);
-	String() string;
+	Uint16(b []byte) uint16
+	Uint32(b []byte) uint32
+	Uint64(b []byte) uint64
+	PutUint16([]byte, uint16)
+	PutUint32([]byte, uint32)
+	PutUint64([]byte, uint64)
+	String() string
 }
 
 // This is byte instead of struct{} so that it can be compared,
@@ -34,11 +34,11 @@ var BigEndian ByteOrder = bigEndian(0)
 
 type littleEndian unused
 
-func (littleEndian) Uint16(b []byte) uint16	{ return uint16(b[0]) | uint16(b[1])<<8 }
+func (littleEndian) Uint16(b []byte) uint16 { return uint16(b[0]) | uint16(b[1])<<8 }
 
 func (littleEndian) PutUint16(b []byte, v uint16) {
-	b[0] = byte(v);
-	b[1] = byte(v >> 8);
+	b[0] = byte(v)
+	b[1] = byte(v >> 8)
 }
 
 func (littleEndian) Uint32(b []byte) uint32 {
@@ -46,10 +46,10 @@ func (littleEndian) Uint32(b []byte) uint32 {
 }
 
 func (littleEndian) PutUint32(b []byte, v uint32) {
-	b[0] = byte(v);
-	b[1] = byte(v >> 8);
-	b[2] = byte(v >> 16);
-	b[3] = byte(v >> 24);
+	b[0] = byte(v)
+	b[1] = byte(v >> 8)
+	b[2] = byte(v >> 16)
+	b[3] = byte(v >> 24)
 }
 
 func (littleEndian) Uint64(b []byte) uint64 {
@@ -58,27 +58,27 @@ func (littleEndian) Uint64(b []byte) uint64 {
 }
 
 func (littleEndian) PutUint64(b []byte, v uint64) {
-	b[0] = byte(v);
-	b[1] = byte(v >> 8);
-	b[2] = byte(v >> 16);
-	b[3] = byte(v >> 24);
-	b[4] = byte(v >> 32);
-	b[5] = byte(v >> 40);
-	b[6] = byte(v >> 48);
-	b[7] = byte(v >> 56);
+	b[0] = byte(v)
+	b[1] = byte(v >> 8)
+	b[2] = byte(v >> 16)
+	b[3] = byte(v >> 24)
+	b[4] = byte(v >> 32)
+	b[5] = byte(v >> 40)
+	b[6] = byte(v >> 48)
+	b[7] = byte(v >> 56)
 }
 
-func (littleEndian) String() string	{ return "LittleEndian" }
+func (littleEndian) String() string { return "LittleEndian" }
 
-func (littleEndian) GoString() string	{ return "binary.LittleEndian" }
+func (littleEndian) GoString() string { return "binary.LittleEndian" }
 
 type bigEndian unused
 
-func (bigEndian) Uint16(b []byte) uint16	{ return uint16(b[1]) | uint16(b[0])<<8 }
+func (bigEndian) Uint16(b []byte) uint16 { return uint16(b[1]) | uint16(b[0])<<8 }
 
 func (bigEndian) PutUint16(b []byte, v uint16) {
-	b[0] = byte(v >> 8);
-	b[1] = byte(v);
+	b[0] = byte(v >> 8)
+	b[1] = byte(v)
 }
 
 func (bigEndian) Uint32(b []byte) uint32 {
@@ -86,10 +86,10 @@ func (bigEndian) Uint32(b []byte) uint32 {
 }
 
 func (bigEndian) PutUint32(b []byte, v uint32) {
-	b[0] = byte(v >> 24);
-	b[1] = byte(v >> 16);
-	b[2] = byte(v >> 8);
-	b[3] = byte(v);
+	b[0] = byte(v >> 24)
+	b[1] = byte(v >> 16)
+	b[2] = byte(v >> 8)
+	b[3] = byte(v)
 }
 
 func (bigEndian) Uint64(b []byte) uint64 {
@@ -98,19 +98,19 @@ func (bigEndian) Uint64(b []byte) uint64 {
 }
 
 func (bigEndian) PutUint64(b []byte, v uint64) {
-	b[0] = byte(v >> 56);
-	b[1] = byte(v >> 48);
-	b[2] = byte(v >> 40);
-	b[3] = byte(v >> 32);
-	b[4] = byte(v >> 24);
-	b[5] = byte(v >> 16);
-	b[6] = byte(v >> 8);
-	b[7] = byte(v);
+	b[0] = byte(v >> 56)
+	b[1] = byte(v >> 48)
+	b[2] = byte(v >> 40)
+	b[3] = byte(v >> 32)
+	b[4] = byte(v >> 24)
+	b[5] = byte(v >> 16)
+	b[6] = byte(v >> 8)
+	b[7] = byte(v)
 }
 
-func (bigEndian) String() string	{ return "BigEndian" }
+func (bigEndian) String() string { return "BigEndian" }
 
-func (bigEndian) GoString() string	{ return "binary.BigEndian" }
+func (bigEndian) GoString() string { return "binary.BigEndian" }
 
 // Read reads structured binary data from r into data.
 // Data must be a pointer to a fixed-size value or a slice
@@ -121,7 +121,7 @@ func (bigEndian) GoString() string	{ return "binary.BigEndian" }
 // r are decoded using the specified byte order and written
 // to successive fields of the data.
 func Read(r io.Reader, order ByteOrder, data interface{}) os.Error {
-	var v reflect.Value;
+	var v reflect.Value
 	switch d := reflect.NewValue(data).(type) {
 	case *reflect.PtrValue:
 		v = d.Elem()
@@ -130,16 +130,16 @@ func Read(r io.Reader, order ByteOrder, data interface{}) os.Error {
 	default:
 		return os.NewError("binary.Read: invalid type " + v.Type().String())
 	}
-	size := TotalSize(v);
+	size := TotalSize(v)
 	if size < 0 {
 		return os.NewError("binary.Read: invalid type " + v.Type().String())
 	}
-	d := &decoder{order: order, buf: make([]byte, size)};
+	d := &decoder{order: order, buf: make([]byte, size)}
 	if _, err := io.ReadFull(r, d.buf); err != nil {
 		return err
 	}
-	d.value(v);
-	return nil;
+	d.value(v)
+	return nil
 }
 
 // Write writes the binary representation of data into w.
@@ -151,48 +151,48 @@ func Read(r io.Reader, order ByteOrder, data interface{}) os.Error {
 // w are encoded using the specified byte order and read
 // from successive fields of the data.
 func Write(w io.Writer, order ByteOrder, data interface{}) os.Error {
-	v := reflect.Indirect(reflect.NewValue(data));
-	size := TotalSize(v);
+	v := reflect.Indirect(reflect.NewValue(data))
+	size := TotalSize(v)
 	if size < 0 {
 		return os.NewError("binary.Write: invalid type " + v.Type().String())
 	}
-	buf := make([]byte, size);
-	e := &encoder{order: order, buf: buf};
-	e.value(v);
-	_, err := w.Write(buf);
-	return err;
+	buf := make([]byte, size)
+	e := &encoder{order: order, buf: buf}
+	e.value(v)
+	_, err := w.Write(buf)
+	return err
 }
 
 func TotalSize(v reflect.Value) int {
 	if sv, ok := v.(*reflect.SliceValue); ok {
-		elem := sizeof(v.Type().(*reflect.SliceType).Elem());
+		elem := sizeof(v.Type().(*reflect.SliceType).Elem())
 		if elem < 0 {
 			return -1
 		}
-		return sv.Len() * elem;
+		return sv.Len() * elem
 	}
-	return sizeof(v.Type());
+	return sizeof(v.Type())
 }
 
 func sizeof(v reflect.Type) int {
 	switch t := v.(type) {
 	case *reflect.ArrayType:
-		n := sizeof(t.Elem());
+		n := sizeof(t.Elem())
 		if n < 0 {
 			return -1
 		}
-		return t.Len() * n;
+		return t.Len() * n
 
 	case *reflect.StructType:
-		sum := 0;
+		sum := 0
 		for i, n := 0, t.NumField(); i < n; i++ {
-			s := sizeof(t.Field(i).Type);
+			s := sizeof(t.Field(i).Type)
 			if s < 0 {
 				return -1
 			}
-			sum += s;
+			sum += s
 		}
-		return sum;
+		return sum
 
 	case *reflect.Uint8Type:
 		return 1
@@ -215,94 +215,94 @@ func sizeof(v reflect.Type) int {
 	case *reflect.Float64Type:
 		return 8
 	}
-	return -1;
+	return -1
 }
 
 type decoder struct {
-	order	ByteOrder;
-	buf	[]byte;
+	order ByteOrder
+	buf   []byte
 }
 
 type encoder struct {
-	order	ByteOrder;
-	buf	[]byte;
+	order ByteOrder
+	buf   []byte
 }
 
 func (d *decoder) uint8() uint8 {
-	x := d.buf[0];
-	d.buf = d.buf[1:];
-	return x;
+	x := d.buf[0]
+	d.buf = d.buf[1:]
+	return x
 }
 
 func (e *encoder) uint8(x uint8) {
-	e.buf[0] = x;
-	e.buf = e.buf[1:];
+	e.buf[0] = x
+	e.buf = e.buf[1:]
 }
 
 func (d *decoder) uint16() uint16 {
-	x := d.order.Uint16(d.buf[0:2]);
-	d.buf = d.buf[2:];
-	return x;
+	x := d.order.Uint16(d.buf[0:2])
+	d.buf = d.buf[2:]
+	return x
 }
 
 func (e *encoder) uint16(x uint16) {
-	e.order.PutUint16(e.buf[0:2], x);
-	e.buf = e.buf[2:];
+	e.order.PutUint16(e.buf[0:2], x)
+	e.buf = e.buf[2:]
 }
 
 func (d *decoder) uint32() uint32 {
-	x := d.order.Uint32(d.buf[0:4]);
-	d.buf = d.buf[4:];
-	return x;
+	x := d.order.Uint32(d.buf[0:4])
+	d.buf = d.buf[4:]
+	return x
 }
 
 func (e *encoder) uint32(x uint32) {
-	e.order.PutUint32(e.buf[0:4], x);
-	e.buf = e.buf[4:];
+	e.order.PutUint32(e.buf[0:4], x)
+	e.buf = e.buf[4:]
 }
 
 func (d *decoder) uint64() uint64 {
-	x := d.order.Uint64(d.buf[0:8]);
-	d.buf = d.buf[8:];
-	return x;
+	x := d.order.Uint64(d.buf[0:8])
+	d.buf = d.buf[8:]
+	return x
 }
 
 func (e *encoder) uint64(x uint64) {
-	e.order.PutUint64(e.buf[0:8], x);
-	e.buf = e.buf[8:];
+	e.order.PutUint64(e.buf[0:8], x)
+	e.buf = e.buf[8:]
 }
 
-func (d *decoder) int8() int8	{ return int8(d.uint8()) }
+func (d *decoder) int8() int8 { return int8(d.uint8()) }
 
-func (e *encoder) int8(x int8)	{ e.uint8(uint8(x)) }
+func (e *encoder) int8(x int8) { e.uint8(uint8(x)) }
 
-func (d *decoder) int16() int16	{ return int16(d.uint16()) }
+func (d *decoder) int16() int16 { return int16(d.uint16()) }
 
-func (e *encoder) int16(x int16)	{ e.uint16(uint16(x)) }
+func (e *encoder) int16(x int16) { e.uint16(uint16(x)) }
 
-func (d *decoder) int32() int32	{ return int32(d.uint32()) }
+func (d *decoder) int32() int32 { return int32(d.uint32()) }
 
-func (e *encoder) int32(x int32)	{ e.uint32(uint32(x)) }
+func (e *encoder) int32(x int32) { e.uint32(uint32(x)) }
 
-func (d *decoder) int64() int64	{ return int64(d.uint64()) }
+func (d *decoder) int64() int64 { return int64(d.uint64()) }
 
-func (e *encoder) int64(x int64)	{ e.uint64(uint64(x)) }
+func (e *encoder) int64(x int64) { e.uint64(uint64(x)) }
 
 func (d *decoder) value(v reflect.Value) {
 	switch v := v.(type) {
 	case *reflect.ArrayValue:
-		l := v.Len();
+		l := v.Len()
 		for i := 0; i < l; i++ {
 			d.value(v.Elem(i))
 		}
 	case *reflect.StructValue:
-		l := v.NumField();
+		l := v.NumField()
 		for i := 0; i < l; i++ {
 			d.value(v.Field(i))
 		}
 
 	case *reflect.SliceValue:
-		l := v.Len();
+		l := v.Len()
 		for i := 0; i < l; i++ {
 			d.value(v.Elem(i))
 		}
@@ -333,17 +333,17 @@ func (d *decoder) value(v reflect.Value) {
 func (e *encoder) value(v reflect.Value) {
 	switch v := v.(type) {
 	case *reflect.ArrayValue:
-		l := v.Len();
+		l := v.Len()
 		for i := 0; i < l; i++ {
 			e.value(v.Elem(i))
 		}
 	case *reflect.StructValue:
-		l := v.NumField();
+		l := v.NumField()
 		for i := 0; i < l; i++ {
 			e.value(v.Field(i))
 		}
 	case *reflect.SliceValue:
-		l := v.Len();
+		l := v.Len()
 		for i := 0; i < l; i++ {
 			e.value(v.Elem(i))
 		}
diff --git a/src/pkg/encoding/binary/binary_test.go b/src/pkg/encoding/binary/binary_test.go
index 33e6b0bea6..12d192d1ed 100644
--- a/src/pkg/encoding/binary/binary_test.go
+++ b/src/pkg/encoding/binary/binary_test.go
@@ -5,24 +5,24 @@
 package binary
 
 import (
-	"os";
-	"bytes";
-	"math";
-	"reflect";
-	"testing";
+	"os"
+	"bytes"
+	"math"
+	"reflect"
+	"testing"
 )
 
 type Struct struct {
-	Int8	int8;
-	Int16	int16;
-	Int32	int32;
-	Int64	int64;
-	Uint8	uint8;
-	Uint16	uint16;
-	Uint32	uint32;
-	Uint64	uint64;
-	Float64	float64;
-	Array	[4]uint8;
+	Int8    int8
+	Int16   int16
+	Int32   int32
+	Int64   int64
+	Uint8   uint8
+	Uint16  uint16
+	Uint32  uint32
+	Uint64  uint64
+	Float64 float64
+	Array   [4]uint8
 }
 
 var s = Struct{
@@ -69,8 +69,8 @@ var res = []int32{0x01020304, 0x05060708}
 
 func checkResult(t *testing.T, dir string, order, err os.Error, have, want interface{}) {
 	if err != nil {
-		t.Errorf("%v %v: %v", dir, order, err);
-		return;
+		t.Errorf("%v %v: %v", dir, order, err)
+		return
 	}
 	if !reflect.DeepEqual(have, want) {
 		t.Errorf("%v %v:\n\thave %+v\n\twant %+v", dir, order, have, want)
@@ -78,37 +78,37 @@ func checkResult(t *testing.T, dir string, order, err os.Error, have, want inter
 }
 
 func testRead(t *testing.T, order ByteOrder, b []byte, s1 interface{}) {
-	var s2 Struct;
-	err := Read(bytes.NewBuffer(b), order, &s2);
-	checkResult(t, "Read", order, err, s2, s1);
+	var s2 Struct
+	err := Read(bytes.NewBuffer(b), order, &s2)
+	checkResult(t, "Read", order, err, s2, s1)
 }
 
 func testWrite(t *testing.T, order ByteOrder, b []byte, s1 interface{}) {
-	buf := new(bytes.Buffer);
-	err := Write(buf, order, s1);
-	checkResult(t, "Write", order, err, buf.Bytes(), b);
+	buf := new(bytes.Buffer)
+	err := Write(buf, order, s1)
+	checkResult(t, "Write", order, err, buf.Bytes(), b)
 }
 
-func TestBigEndianRead(t *testing.T)	{ testRead(t, BigEndian, big, s) }
+func TestBigEndianRead(t *testing.T) { testRead(t, BigEndian, big, s) }
 
-func TestLittleEndianRead(t *testing.T)	{ testRead(t, LittleEndian, little, s) }
+func TestLittleEndianRead(t *testing.T) { testRead(t, LittleEndian, little, s) }
 
-func TestBigEndianWrite(t *testing.T)	{ testWrite(t, BigEndian, big, s) }
+func TestBigEndianWrite(t *testing.T) { testWrite(t, BigEndian, big, s) }
 
-func TestLittleEndianWrite(t *testing.T)	{ testWrite(t, LittleEndian, little, s) }
+func TestLittleEndianWrite(t *testing.T) { testWrite(t, LittleEndian, little, s) }
 
-func TestBigEndianPtrWrite(t *testing.T)	{ testWrite(t, BigEndian, big, &s) }
+func TestBigEndianPtrWrite(t *testing.T) { testWrite(t, BigEndian, big, &s) }
 
-func TestLittleEndianPtrWrite(t *testing.T)	{ testWrite(t, LittleEndian, little, &s) }
+func TestLittleEndianPtrWrite(t *testing.T) { testWrite(t, LittleEndian, little, &s) }
 
 func TestReadSlice(t *testing.T) {
-	slice := make([]int32, 2);
-	err := Read(bytes.NewBuffer(src), BigEndian, slice);
-	checkResult(t, "ReadSlice", BigEndian, err, slice, res);
+	slice := make([]int32, 2)
+	err := Read(bytes.NewBuffer(src), BigEndian, slice)
+	checkResult(t, "ReadSlice", BigEndian, err, slice, res)
 }
 
 func TestWriteSlice(t *testing.T) {
-	buf := new(bytes.Buffer);
-	err := Write(buf, BigEndian, res);
-	checkResult(t, "WriteSlice", BigEndian, err, buf.Bytes(), src);
+	buf := new(bytes.Buffer)
+	err := Write(buf, BigEndian, res)
+	checkResult(t, "WriteSlice", BigEndian, err, buf.Bytes(), src)
 }
diff --git a/src/pkg/encoding/git85/git.go b/src/pkg/encoding/git85/git.go
index 1e52997929..25a3deac00 100644
--- a/src/pkg/encoding/git85/git.go
+++ b/src/pkg/encoding/git85/git.go
@@ -7,10 +7,10 @@
 package git85
 
 import (
-	"bytes";
-	"io";
-	"os";
-	"strconv";
+	"bytes"
+	"io"
+	"os"
+	"strconv"
 )
 
 type CorruptInputError int64
@@ -49,9 +49,9 @@ var decode = [256]uint8{
 // The encoding splits src into chunks of at most 52 bytes
 // and encodes each chunk on its own line.
 func Encode(dst, src []byte) int {
-	ndst := 0;
+	ndst := 0
 	for len(src) > 0 {
-		n := len(src);
+		n := len(src)
 		if n > 52 {
 			n = 52
 		}
@@ -60,23 +60,23 @@ func Encode(dst, src []byte) int {
 		} else {
 			dst[ndst] = byte('a' + n - 26 - 1)
 		}
-		ndst++;
+		ndst++
 		for i := 0; i < n; i += 4 {
-			var v uint32;
+			var v uint32
 			for j := 0; j < 4 && i+j < n; j++ {
 				v |= uint32(src[i+j]) << uint(24-j*8)
 			}
 			for j := 4; j >= 0; j-- {
-				dst[ndst+j] = encode[v%85];
-				v /= 85;
+				dst[ndst+j] = encode[v%85]
+				v /= 85
 			}
-			ndst += 5;
+			ndst += 5
 		}
-		dst[ndst] = '\n';
-		ndst++;
-		src = src[n:];
+		dst[ndst] = '\n'
+		ndst++
+		src = src[n:]
 	}
-	return ndst;
+	return ndst
 }
 
 // EncodedLen returns the length of an encoding of n source bytes.
@@ -86,7 +86,7 @@ func EncodedLen(n int) int {
 	}
 	// 5 bytes per 4 bytes of input, rounded up.
 	// 2 extra bytes for each line of 52 src bytes, rounded up.
-	return (n+3)/4*5 + (n+51)/52*2;
+	return (n+3)/4*5 + (n+51)/52*2
 }
 
 var newline = []byte{'\n'}
@@ -97,10 +97,10 @@ var newline = []byte{'\n'}
 // If Decode encounters invalid input, it returns a CorruptInputError.
 //
 func Decode(dst, src []byte) (n int, err os.Error) {
-	ndst := 0;
-	nsrc := 0;
+	ndst := 0
+	nsrc := 0
 	for nsrc < len(src) {
-		var l int;
+		var l int
 		switch ch := int(src[nsrc]); {
 		case 'A' <= ch && ch <= 'Z':
 			l = ch - 'A' + 1
@@ -112,24 +112,24 @@ func Decode(dst, src []byte) (n int, err os.Error) {
 		if nsrc+1+l > len(src) {
 			return ndst, CorruptInputError(nsrc)
 		}
-		el := (l + 3) / 4 * 5;	// encoded len
+		el := (l + 3) / 4 * 5 // encoded len
 		if nsrc+1+el+1 > len(src) || src[nsrc+1+el] != '\n' {
 			return ndst, CorruptInputError(nsrc)
 		}
-		line := src[nsrc+1 : nsrc+1+el];
+		line := src[nsrc+1 : nsrc+1+el]
 		for i := 0; i < el; i += 5 {
-			var v uint32;
+			var v uint32
 			for j := 0; j < 5; j++ {
-				ch := decode[line[i+j]];
+				ch := decode[line[i+j]]
 				if ch == 0 {
 					return ndst, CorruptInputError(nsrc + 1 + i + j)
 				}
-				v = v*85 + uint32(ch-1);
+				v = v*85 + uint32(ch-1)
 			}
 			for j := 0; j < 4; j++ {
-				dst[ndst] = byte(v >> 24);
-				v <<= 8;
-				ndst++;
+				dst[ndst] = byte(v >> 24)
+				v <<= 8
+				ndst++
 			}
 		}
 		// Last fragment may have run too far (but there was room in dst).
@@ -137,27 +137,27 @@ func Decode(dst, src []byte) (n int, err os.Error) {
 		if l%4 != 0 {
 			ndst -= 4 - l%4
 		}
-		nsrc += 1 + el + 1;
+		nsrc += 1 + el + 1
 	}
-	return ndst, nil;
+	return ndst, nil
 }
 
-func MaxDecodedLen(n int) int	{ return n / 5 * 4 }
+func MaxDecodedLen(n int) int { return n / 5 * 4 }
 
 // NewEncoder returns a new Git base85 stream encoder.  Data written to
 // the returned writer will be encoded and then written to w.
 // The Git encoding operates on 52-byte blocks; when finished
 // writing, the caller must Close the returned encoder to flush any
 // partially written blocks.
-func NewEncoder(w io.Writer) io.WriteCloser	{ return &encoder{w: w} }
+func NewEncoder(w io.Writer) io.WriteCloser { return &encoder{w: w} }
 
 type encoder struct {
-	w	io.Writer;
-	err	os.Error;
-	buf	[52]byte;
-	nbuf	int;
-	out	[1024]byte;
-	nout	int;
+	w    io.Writer
+	err  os.Error
+	buf  [52]byte
+	nbuf int
+	out  [1024]byte
+	nout int
 }
 
 func (e *encoder) Write(p []byte) (n int, err os.Error) {
@@ -167,70 +167,70 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 
 	// Leading fringe.
 	if e.nbuf > 0 {
-		var i int;
+		var i int
 		for i = 0; i < len(p) && e.nbuf < 52; i++ {
-			e.buf[e.nbuf] = p[i];
-			e.nbuf++;
+			e.buf[e.nbuf] = p[i]
+			e.nbuf++
 		}
-		n += i;
-		p = p[i:];
+		n += i
+		p = p[i:]
 		if e.nbuf < 52 {
 			return
 		}
-		nout := Encode(&e.out, &e.buf);
+		nout := Encode(&e.out, &e.buf)
 		if _, e.err = e.w.Write(e.out[0:nout]); e.err != nil {
 			return n, e.err
 		}
-		e.nbuf = 0;
+		e.nbuf = 0
 	}
 
 	// Large interior chunks.
 	for len(p) >= 52 {
-		nn := len(e.out) / (1 + 52/4*5 + 1) * 52;
+		nn := len(e.out) / (1 + 52/4*5 + 1) * 52
 		if nn > len(p) {
 			nn = len(p) / 52 * 52
 		}
 		if nn > 0 {
-			nout := Encode(&e.out, p[0:nn]);
+			nout := Encode(&e.out, p[0:nn])
 			if _, e.err = e.w.Write(e.out[0:nout]); e.err != nil {
 				return n, e.err
 			}
 		}
-		n += nn;
-		p = p[nn:];
+		n += nn
+		p = p[nn:]
 	}
 
 	// Trailing fringe.
 	for i := 0; i < len(p); i++ {
 		e.buf[i] = p[i]
 	}
-	e.nbuf = len(p);
-	n += len(p);
-	return;
+	e.nbuf = len(p)
+	n += len(p)
+	return
 }
 
 func (e *encoder) Close() os.Error {
 	// If there's anything left in the buffer, flush it out
 	if e.err == nil && e.nbuf > 0 {
-		nout := Encode(&e.out, e.buf[0:e.nbuf]);
-		e.nbuf = 0;
-		_, e.err = e.w.Write(e.out[0:nout]);
+		nout := Encode(&e.out, e.buf[0:e.nbuf])
+		e.nbuf = 0
+		_, e.err = e.w.Write(e.out[0:nout])
 	}
-	return e.err;
+	return e.err
 }
 
 // NewDecoder returns a new Git base85 stream decoder.
-func NewDecoder(r io.Reader) io.Reader	{ return &decoder{r: r} }
+func NewDecoder(r io.Reader) io.Reader { return &decoder{r: r} }
 
 type decoder struct {
-	r	io.Reader;
-	err	os.Error;
-	readErr	os.Error;
-	buf	[1024]byte;
-	nbuf	int;
-	out	[]byte;
-	outbuf	[1024]byte;
-	off	int64;
+	r       io.Reader
+	err     os.Error
+	readErr os.Error
+	buf     [1024]byte
+	nbuf    int
+	out     []byte
+	outbuf  [1024]byte
+	off     int64
 }
 
 func (d *decoder) Read(p []byte) (n int, err os.Error) {
@@ -241,9 +241,9 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 	for {
 		// Copy leftover output from last decode.
 		if len(d.out) > 0 {
-			n = copy(p, d.out);
-			d.out = d.out[n:];
-			return;
+			n = copy(p, d.out)
+			d.out = d.out[n:]
+			return
 		}
 
 		// Out of decoded output.  Check errors.
@@ -251,27 +251,27 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 			return 0, d.err
 		}
 		if d.readErr != nil {
-			d.err = d.readErr;
-			return 0, d.err;
+			d.err = d.readErr
+			return 0, d.err
 		}
 
 		// Read and decode more input.
-		var nn int;
-		nn, d.readErr = d.r.Read(d.buf[d.nbuf:]);
-		d.nbuf += nn;
+		var nn int
+		nn, d.readErr = d.r.Read(d.buf[d.nbuf:])
+		d.nbuf += nn
 
 		// Send complete lines to Decode.
-		nl := bytes.LastIndex(d.buf[0:d.nbuf], newline);
+		nl := bytes.LastIndex(d.buf[0:d.nbuf], newline)
 		if nl < 0 {
 			continue
 		}
-		nn, d.err = Decode(&d.outbuf, d.buf[0:nl+1]);
+		nn, d.err = Decode(&d.outbuf, d.buf[0:nl+1])
 		if e, ok := d.err.(CorruptInputError); ok {
 			d.err = CorruptInputError(int64(e) + d.off)
 		}
-		d.out = d.outbuf[0:nn];
-		d.nbuf = copy(&d.buf, d.buf[nl+1:d.nbuf]);
-		d.off += int64(nl + 1);
+		d.out = d.outbuf[0:nn]
+		d.nbuf = copy(&d.buf, d.buf[nl+1:d.nbuf])
+		d.off += int64(nl + 1)
 	}
-	panic("unreacahable");
+	panic("unreacahable")
 }
diff --git a/src/pkg/encoding/git85/git_test.go b/src/pkg/encoding/git85/git_test.go
index 564b4915be..4a42282fe4 100644
--- a/src/pkg/encoding/git85/git_test.go
+++ b/src/pkg/encoding/git85/git_test.go
@@ -5,36 +5,36 @@
 package git85
 
 import (
-	"bytes";
-	"io/ioutil";
-	"os";
-	"reflect";
-	"strings";
-	"testing";
+	"bytes"
+	"io/ioutil"
+	"os"
+	"reflect"
+	"strings"
+	"testing"
 )
 
 type testpair struct {
-	decoded, encoded string;
+	decoded, encoded string
 }
 
 func testEqual(t *testing.T, msg string, args ...) bool {
-	v := reflect.NewValue(args).(*reflect.StructValue);
-	v1 := v.Field(v.NumField() - 2);
-	v2 := v.Field(v.NumField() - 1);
+	v := reflect.NewValue(args).(*reflect.StructValue)
+	v1 := v.Field(v.NumField() - 2)
+	v2 := v.Field(v.NumField() - 1)
 	if v1.Interface() != v2.Interface() {
-		t.Errorf(msg, args);
-		return false;
+		t.Errorf(msg, args)
+		return false
 	}
-	return true;
+	return true
 }
 
 func TestGitTable(t *testing.T) {
-	var saw [256]bool;
+	var saw [256]bool
 	for i, c := range encode {
 		if decode[c] != uint8(i+1) {
 			t.Errorf("decode['%c'] = %d, want %d", c, decode[c], i+1)
 		}
-		saw[c] = true;
+		saw[c] = true
 	}
 	for i, b := range saw {
 		if !b && decode[i] != 0 {
@@ -64,65 +64,65 @@ var gitBigtest = gitPairs[len(gitPairs)-1]
 
 func TestEncode(t *testing.T) {
 	for _, p := range gitPairs {
-		buf := make([]byte, EncodedLen(len(p.decoded)));
-		n := Encode(buf, strings.Bytes(p.decoded));
+		buf := make([]byte, EncodedLen(len(p.decoded)))
+		n := Encode(buf, strings.Bytes(p.decoded))
 		if n != len(buf) {
 			t.Errorf("EncodedLen does not agree with Encode")
 		}
-		buf = buf[0:n];
-		testEqual(t, "Encode(%q) = %q, want %q", p.decoded, string(buf), p.encoded);
+		buf = buf[0:n]
+		testEqual(t, "Encode(%q) = %q, want %q", p.decoded, string(buf), p.encoded)
 	}
 }
 
 func TestEncoder(t *testing.T) {
 	for _, p := range gitPairs {
-		bb := &bytes.Buffer{};
-		encoder := NewEncoder(bb);
-		encoder.Write(strings.Bytes(p.decoded));
-		encoder.Close();
-		testEqual(t, "Encode(%q) = %q, want %q", p.decoded, bb.String(), p.encoded);
+		bb := &bytes.Buffer{}
+		encoder := NewEncoder(bb)
+		encoder.Write(strings.Bytes(p.decoded))
+		encoder.Close()
+		testEqual(t, "Encode(%q) = %q, want %q", p.decoded, bb.String(), p.encoded)
 	}
 }
 
 func TestEncoderBuffering(t *testing.T) {
-	input := strings.Bytes(gitBigtest.decoded);
+	input := strings.Bytes(gitBigtest.decoded)
 	for bs := 1; bs <= 12; bs++ {
-		bb := &bytes.Buffer{};
-		encoder := NewEncoder(bb);
+		bb := &bytes.Buffer{}
+		encoder := NewEncoder(bb)
 		for pos := 0; pos < len(input); pos += bs {
-			end := pos + bs;
+			end := pos + bs
 			if end > len(input) {
 				end = len(input)
 			}
-			n, err := encoder.Write(input[pos:end]);
-			testEqual(t, "Write(%q) gave error %v, want %v", input[pos:end], err, os.Error(nil));
-			testEqual(t, "Write(%q) gave length %v, want %v", input[pos:end], n, end-pos);
+			n, err := encoder.Write(input[pos:end])
+			testEqual(t, "Write(%q) gave error %v, want %v", input[pos:end], err, os.Error(nil))
+			testEqual(t, "Write(%q) gave length %v, want %v", input[pos:end], n, end-pos)
 		}
-		err := encoder.Close();
-		testEqual(t, "Close gave error %v, want %v", err, os.Error(nil));
-		testEqual(t, "Encoding/%d of %q = %q, want %q", bs, gitBigtest.decoded, bb.String(), gitBigtest.encoded);
+		err := encoder.Close()
+		testEqual(t, "Close gave error %v, want %v", err, os.Error(nil))
+		testEqual(t, "Encoding/%d of %q = %q, want %q", bs, gitBigtest.decoded, bb.String(), gitBigtest.encoded)
 	}
 }
 
 func TestDecode(t *testing.T) {
 	for _, p := range gitPairs {
-		dbuf := make([]byte, 4*len(p.encoded));
-		ndst, err := Decode(dbuf, strings.Bytes(p.encoded));
-		testEqual(t, "Decode(%q) = error %v, want %v", p.encoded, err, os.Error(nil));
-		testEqual(t, "Decode(%q) = ndst %v, want %v", p.encoded, ndst, len(p.decoded));
-		testEqual(t, "Decode(%q) = %q, want %q", p.encoded, string(dbuf[0:ndst]), p.decoded);
+		dbuf := make([]byte, 4*len(p.encoded))
+		ndst, err := Decode(dbuf, strings.Bytes(p.encoded))
+		testEqual(t, "Decode(%q) = error %v, want %v", p.encoded, err, os.Error(nil))
+		testEqual(t, "Decode(%q) = ndst %v, want %v", p.encoded, ndst, len(p.decoded))
+		testEqual(t, "Decode(%q) = %q, want %q", p.encoded, string(dbuf[0:ndst]), p.decoded)
 	}
 }
 
 func TestDecoder(t *testing.T) {
 	for _, p := range gitPairs {
-		decoder := NewDecoder(bytes.NewBufferString(p.encoded));
-		dbuf, err := ioutil.ReadAll(decoder);
+		decoder := NewDecoder(bytes.NewBufferString(p.encoded))
+		dbuf, err := ioutil.ReadAll(decoder)
 		if err != nil {
 			t.Fatal("Read failed", err)
 		}
-		testEqual(t, "Read from %q = length %v, want %v", p.encoded, len(dbuf), len(p.decoded));
-		testEqual(t, "Decoding of %q = %q, want %q", p.encoded, string(dbuf), p.decoded);
+		testEqual(t, "Read from %q = length %v, want %v", p.encoded, len(dbuf), len(p.decoded))
+		testEqual(t, "Decoding of %q = %q, want %q", p.encoded, string(dbuf), p.decoded)
 		if err != nil {
 			testEqual(t, "Read from %q = %v, want %v", p.encoded, err, os.EOF)
 		}
@@ -131,31 +131,31 @@ func TestDecoder(t *testing.T) {
 
 func TestDecoderBuffering(t *testing.T) {
 	for bs := 1; bs <= 12; bs++ {
-		decoder := NewDecoder(bytes.NewBufferString(gitBigtest.encoded));
-		buf := make([]byte, len(gitBigtest.decoded)+12);
-		var total int;
+		decoder := NewDecoder(bytes.NewBufferString(gitBigtest.encoded))
+		buf := make([]byte, len(gitBigtest.decoded)+12)
+		var total int
 		for total = 0; total < len(gitBigtest.decoded); {
-			n, err := decoder.Read(buf[total : total+bs]);
-			testEqual(t, "Read from %q at pos %d = %d, %v, want _, %v", gitBigtest.encoded, total, n, err, os.Error(nil));
-			total += n;
+			n, err := decoder.Read(buf[total : total+bs])
+			testEqual(t, "Read from %q at pos %d = %d, %v, want _, %v", gitBigtest.encoded, total, n, err, os.Error(nil))
+			total += n
 		}
-		testEqual(t, "Decoding/%d of %q = %q, want %q", bs, gitBigtest.encoded, string(buf[0:total]), gitBigtest.decoded);
+		testEqual(t, "Decoding/%d of %q = %q, want %q", bs, gitBigtest.encoded, string(buf[0:total]), gitBigtest.decoded)
 	}
 }
 
 func TestDecodeCorrupt(t *testing.T) {
 	type corrupt struct {
-		e	string;
-		p	int;
+		e string
+		p int
 	}
 	examples := []corrupt{
 		corrupt{"v", 0},
 		corrupt{"!z!!!!!!!!!", 0},
-	};
+	}
 
 	for _, e := range examples {
-		dbuf := make([]byte, 2*len(e.e));
-		_, err := Decode(dbuf, strings.Bytes(e.e));
+		dbuf := make([]byte, 2*len(e.e))
+		_, err := Decode(dbuf, strings.Bytes(e.e))
 		switch err := err.(type) {
 		case CorruptInputError:
 			testEqual(t, "Corruption in %q at offset %v, want %v", e.e, int(err), e.p)
@@ -166,34 +166,34 @@ func TestDecodeCorrupt(t *testing.T) {
 }
 
 func TestGitBig(t *testing.T) {
-	n := 3*1000 + 1;
-	raw := make([]byte, n);
-	const alpha = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
+	n := 3*1000 + 1
+	raw := make([]byte, n)
+	const alpha = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
 	for i := 0; i < n; i++ {
 		raw[i] = alpha[i%len(alpha)]
 	}
-	encoded := new(bytes.Buffer);
-	w := NewEncoder(encoded);
-	nn, err := w.Write(raw);
+	encoded := new(bytes.Buffer)
+	w := NewEncoder(encoded)
+	nn, err := w.Write(raw)
 	if nn != n || err != nil {
 		t.Fatalf("Encoder.Write(raw) = %d, %v want %d, nil", nn, err, n)
 	}
-	err = w.Close();
+	err = w.Close()
 	if err != nil {
 		t.Fatalf("Encoder.Close() = %v want nil", err)
 	}
-	decoded, err := ioutil.ReadAll(NewDecoder(encoded));
+	decoded, err := ioutil.ReadAll(NewDecoder(encoded))
 	if err != nil {
 		t.Fatalf("ioutil.ReadAll(NewDecoder(...)): %v", err)
 	}
 
 	if !bytes.Equal(raw, decoded) {
-		var i int;
+		var i int
 		for i = 0; i < len(decoded) && i < len(raw); i++ {
 			if decoded[i] != raw[i] {
 				break
 			}
 		}
-		t.Errorf("Decode(Encode(%d-byte string)) failed at offset %d", n, i);
+		t.Errorf("Decode(Encode(%d-byte string)) failed at offset %d", n, i)
 	}
 }
diff --git a/src/pkg/encoding/hex/hex.go b/src/pkg/encoding/hex/hex.go
index 17c4ae842e..8a9271c237 100644
--- a/src/pkg/encoding/hex/hex.go
+++ b/src/pkg/encoding/hex/hex.go
@@ -6,15 +6,15 @@
 package hex
 
 import (
-	"os";
-	"strconv";
-	"strings";
+	"os"
+	"strconv"
+	"strings"
 )
 
 const hextable = "0123456789abcdef"
 
 // EncodedLen returns the length of an encoding of n source bytes.
-func EncodedLen(n int) int	{ return n * 2 }
+func EncodedLen(n int) int { return n * 2 }
 
 // Encode encodes src into EncodedLen(len(src))
 // bytes of dst.  As a convenience, it returns the number
@@ -22,17 +22,17 @@ func EncodedLen(n int) int	{ return n * 2 }
 // Encode implements hexadecimal encoding.
 func Encode(dst, src []byte) int {
 	for i, v := range src {
-		dst[i*2] = hextable[v>>4];
-		dst[i*2+1] = hextable[v&0x0f];
+		dst[i*2] = hextable[v>>4]
+		dst[i*2+1] = hextable[v&0x0f]
 	}
 
-	return len(src) * 2;
+	return len(src) * 2
 }
 
 // OddLengthInputError results from decoding an odd length slice.
 type OddLengthInputError struct{}
 
-func (OddLengthInputError) String() string	{ return "odd length hex string" }
+func (OddLengthInputError) String() string { return "odd length hex string" }
 
 // InvalidHexCharError results from finding an invalid character in a hex string.
 type InvalidHexCharError byte
@@ -42,7 +42,7 @@ func (e InvalidHexCharError) String() string {
 }
 
 
-func DecodedLen(x int) int	{ return x / 2 }
+func DecodedLen(x int) int { return x / 2 }
 
 // Decode decodes src into DecodedLen(len(src)) bytes, returning the actual
 // number of bytes written to dst.
@@ -55,18 +55,18 @@ func Decode(dst, src []byte) (int, os.Error) {
 	}
 
 	for i := 0; i < len(src)/2; i++ {
-		a, ok := fromHexChar(src[i*2]);
+		a, ok := fromHexChar(src[i*2])
 		if !ok {
 			return 0, InvalidHexCharError(src[i*2])
 		}
-		b, ok := fromHexChar(src[i*2+1]);
+		b, ok := fromHexChar(src[i*2+1])
 		if !ok {
 			return 0, InvalidHexCharError(src[i*2+1])
 		}
-		dst[i] = (a << 4) | b;
+		dst[i] = (a << 4) | b
 	}
 
-	return len(src) / 2, nil;
+	return len(src) / 2, nil
 }
 
 // fromHexChar converts a hex character into its value and a success flag.
@@ -80,23 +80,23 @@ func fromHexChar(c byte) (byte, bool) {
 		return c - 'A' + 10, true
 	}
 
-	return 0, false;
+	return 0, false
 }
 
 // EncodeToString returns the hexadecimal encoding of src.
 func EncodeToString(src []byte) string {
-	dst := make([]byte, EncodedLen(len(src)));
-	Encode(dst, src);
-	return string(dst);
+	dst := make([]byte, EncodedLen(len(src)))
+	Encode(dst, src)
+	return string(dst)
 }
 
 // DecodeString returns the bytes represented by the hexadecimal string s.
 func DecodeString(s string) ([]byte, os.Error) {
-	src := strings.Bytes(s);
-	dst := make([]byte, DecodedLen(len(src)));
-	_, err := Decode(dst, src);
+	src := strings.Bytes(s)
+	dst := make([]byte, DecodedLen(len(src)))
+	_, err := Decode(dst, src)
 	if err != nil {
 		return nil, err
 	}
-	return dst, nil;
+	return dst, nil
 }
diff --git a/src/pkg/encoding/hex/hex_test.go b/src/pkg/encoding/hex/hex_test.go
index e409dbd1e5..d741e595a1 100644
--- a/src/pkg/encoding/hex/hex_test.go
+++ b/src/pkg/encoding/hex/hex_test.go
@@ -5,12 +5,12 @@
 package hex
 
 import (
-	"bytes";
-	"testing";
+	"bytes"
+	"testing"
 )
 
 type encodeTest struct {
-	in, out []byte;
+	in, out []byte
 }
 
 var encodeTests = []encodeTest{
@@ -38,8 +38,8 @@ var encodeTests = []encodeTest{
 
 func TestEncode(t *testing.T) {
 	for i, test := range encodeTests {
-		dst := make([]byte, EncodedLen(len(test.in)));
-		n := Encode(dst, test.in);
+		dst := make([]byte, EncodedLen(len(test.in)))
+		n := Encode(dst, test.in)
 		if n != len(dst) {
 			t.Errorf("#%d: bad return value: got: %d want: %d", i, n, len(dst))
 		}
@@ -50,8 +50,8 @@ func TestEncode(t *testing.T) {
 }
 
 type decodeTest struct {
-	in, out	[]byte;
-	ok	bool;
+	in, out []byte
+	ok      bool
 }
 
 var decodeTests = []decodeTest{
@@ -84,8 +84,8 @@ var decodeTests = []decodeTest{
 
 func TestDecode(t *testing.T) {
 	for i, test := range decodeTests {
-		dst := make([]byte, DecodedLen(len(test.in)));
-		n, err := Decode(dst, test.in);
+		dst := make([]byte, DecodedLen(len(test.in)))
+		n, err := Decode(dst, test.in)
 		if err == nil && n != len(dst) {
 			t.Errorf("#%d: bad return value: got:%d want:%d", i, n, len(dst))
 		}
@@ -99,8 +99,8 @@ func TestDecode(t *testing.T) {
 }
 
 type encodeStringTest struct {
-	in	[]byte;
-	out	string;
+	in  []byte
+	out string
 }
 
 var encodeStringTests = []encodeStringTest{
@@ -112,7 +112,7 @@ var encodeStringTests = []encodeStringTest{
 
 func TestEncodeToString(t *testing.T) {
 	for i, test := range encodeStringTests {
-		s := EncodeToString(test.in);
+		s := EncodeToString(test.in)
 		if s != test.out {
 			t.Errorf("#%d got:%s want:%s", i, s, test.out)
 		}
@@ -120,9 +120,9 @@ func TestEncodeToString(t *testing.T) {
 }
 
 type decodeStringTest struct {
-	in	string;
-	out	[]byte;
-	ok	bool;
+	in  string
+	out []byte
+	ok  bool
 }
 
 var decodeStringTests = []decodeStringTest{
@@ -136,7 +136,7 @@ var decodeStringTests = []decodeStringTest{
 
 func TestDecodeString(t *testing.T) {
 	for i, test := range decodeStringTests {
-		dst, err := DecodeString(test.in);
+		dst, err := DecodeString(test.in)
 		if test.ok != (err == nil) {
 			t.Errorf("#%d: unexpected err value: %s", i, err)
 		}
diff --git a/src/pkg/encoding/pem/pem.go b/src/pkg/encoding/pem/pem.go
index 7828d87c1c..168a47168d 100644
--- a/src/pkg/encoding/pem/pem.go
+++ b/src/pkg/encoding/pem/pem.go
@@ -8,9 +8,9 @@
 package pem
 
 import (
-	"bytes";
-	"encoding/base64";
-	"strings";
+	"bytes"
+	"encoding/base64"
+	"strings"
 )
 
 // A Block represents a PEM encoded structure.
@@ -22,9 +22,9 @@ import (
 //    -----END Type-----
 // where Headers is a possibly empty sequence of Key: Value lines.
 type Block struct {
-	Type	string;			// The type, taken from the preamble (i.e. "RSA PRIVATE KEY").
-	Headers	map[string]string;	// Optional headers.
-	Bytes	[]byte;			// The decoded bytes of the contents. Typically a DER encoded ASN.1 structure.
+	Type    string            // The type, taken from the preamble (i.e. "RSA PRIVATE KEY").
+	Headers map[string]string // Optional headers.
+	Bytes   []byte            // The decoded bytes of the contents. Typically a DER encoded ASN.1 structure.
 }
 
 // getLine results the first \r\n or \n delineated line from the given byte
@@ -32,35 +32,35 @@ type Block struct {
 // array (also not including the new line bytes) is also returned and this will
 // always be smaller than the original argument.
 func getLine(data []byte) (line, rest []byte) {
-	i := bytes.Index(data, []byte{'\n'});
-	var j int;
+	i := bytes.Index(data, []byte{'\n'})
+	var j int
 	if i < 0 {
-		i = len(data);
-		j = i;
+		i = len(data)
+		j = i
 	} else {
-		j = i + 1;
+		j = i + 1
 		if i > 0 && data[i-1] == '\r' {
 			i--
 		}
 	}
-	return data[0:i], data[j:];
+	return data[0:i], data[j:]
 }
 
 // removeWhitespace returns a copy of its input with all spaces, tab and
 // newline characters removed.
 func removeWhitespace(data []byte) []byte {
-	result := make([]byte, len(data));
-	n := 0;
+	result := make([]byte, len(data))
+	n := 0
 
 	for _, b := range data {
 		if b == ' ' || b == '\t' || b == '\r' || b == '\n' {
 			continue
 		}
-		result[n] = b;
-		n++;
+		result[n] = b
+		n++
 	}
 
-	return result[0:n];
+	return result[0:n]
 }
 
 var pemStart = strings.Bytes("\n-----BEGIN ")
@@ -74,7 +74,7 @@ var pemEndOfLine = strings.Bytes("-----")
 func Decode(data []byte) (p *Block, rest []byte) {
 	// pemStart begins with a newline. However, at the very beginning of
 	// the byte array, we'll accept the start string without it.
-	rest = data;
+	rest = data
 	if bytes.HasPrefix(data, pemStart[1:]) {
 		rest = rest[len(pemStart)-1 : len(data)]
 	} else if i := bytes.Index(data, pemStart); i >= 0 {
@@ -83,16 +83,16 @@ func Decode(data []byte) (p *Block, rest []byte) {
 		return nil, data
 	}
 
-	typeLine, rest := getLine(rest);
+	typeLine, rest := getLine(rest)
 	if !bytes.HasSuffix(typeLine, pemEndOfLine) {
 		goto Error
 	}
-	typeLine = typeLine[0 : len(typeLine)-len(pemEndOfLine)];
+	typeLine = typeLine[0 : len(typeLine)-len(pemEndOfLine)]
 
 	p = &Block{
 		Headers: make(map[string]string),
 		Type: string(typeLine),
-	};
+	}
 
 	for {
 		// This loop terminates because getLine's second result is
@@ -100,37 +100,37 @@ func Decode(data []byte) (p *Block, rest []byte) {
 		if len(rest) == 0 {
 			return nil, data
 		}
-		line, next := getLine(rest);
+		line, next := getLine(rest)
 
-		i := bytes.Index(line, []byte{':'});
+		i := bytes.Index(line, []byte{':'})
 		if i == -1 {
 			break
 		}
 
 		// TODO(agl): need to cope with values that spread across lines.
-		key, val := line[0:i], line[i+1:];
-		key = bytes.TrimSpace(key);
-		val = bytes.TrimSpace(val);
-		p.Headers[string(key)] = string(val);
-		rest = next;
+		key, val := line[0:i], line[i+1:]
+		key = bytes.TrimSpace(key)
+		val = bytes.TrimSpace(val)
+		p.Headers[string(key)] = string(val)
+		rest = next
 	}
 
-	i := bytes.Index(rest, pemEnd);
+	i := bytes.Index(rest, pemEnd)
 	if i < 0 {
 		goto Error
 	}
-	base64Data := removeWhitespace(rest[0:i]);
+	base64Data := removeWhitespace(rest[0:i])
 
-	p.Bytes = make([]byte, base64.StdEncoding.DecodedLen(len(base64Data)));
-	n, err := base64.StdEncoding.Decode(p.Bytes, base64Data);
+	p.Bytes = make([]byte, base64.StdEncoding.DecodedLen(len(base64Data)))
+	n, err := base64.StdEncoding.Decode(p.Bytes, base64Data)
 	if err != nil {
 		goto Error
 	}
-	p.Bytes = p.Bytes[0:n];
+	p.Bytes = p.Bytes[0:n]
 
-	_, rest = getLine(rest[i+len(pemEnd):]);
+	_, rest = getLine(rest[i+len(pemEnd):])
 
-	return;
+	return
 
 Error:
 	// If we get here then we have rejected a likely looking, but
@@ -153,9 +153,9 @@ Error:
 	//
 	// we've failed to parse using the first BEGIN line
 	// and now will try again, using the second BEGIN line.
-	p, rest = Decode(rest);
+	p, rest = Decode(rest)
 	if p == nil {
 		rest = data
 	}
-	return;
+	return
 }
diff --git a/src/pkg/encoding/pem/pem_test.go b/src/pkg/encoding/pem/pem_test.go
index 262dadd373..47b96e97f4 100644
--- a/src/pkg/encoding/pem/pem_test.go
+++ b/src/pkg/encoding/pem/pem_test.go
@@ -5,13 +5,13 @@
 package pem
 
 import (
-	"testing";
-	"strings";
-	"reflect";
+	"testing"
+	"strings"
+	"reflect"
 )
 
 type GetLineTest struct {
-	in, out1, out2 string;
+	in, out1, out2 string
 }
 
 var getLineTests = []GetLineTest{
@@ -27,7 +27,7 @@ var getLineTests = []GetLineTest{
 
 func TestGetLine(t *testing.T) {
 	for i, test := range getLineTests {
-		x, y := getLine(strings.Bytes(test.in));
+		x, y := getLine(strings.Bytes(test.in))
 		if string(x) != test.out1 || string(y) != test.out2 {
 			t.Errorf("#%d got:%+v,%+v want:%s,%s", i, x, y, test.out1, test.out2)
 		}
@@ -35,15 +35,15 @@ func TestGetLine(t *testing.T) {
 }
 
 func TestDecode(t *testing.T) {
-	result, remainder := Decode(strings.Bytes(pemData));
+	result, remainder := Decode(strings.Bytes(pemData))
 	if !reflect.DeepEqual(result, certificate) {
 		t.Errorf("#0 got:%#v want:%#v", result, certificate)
 	}
-	result, remainder = Decode(remainder);
+	result, remainder = Decode(remainder)
 	if !reflect.DeepEqual(result, privateKey) {
 		t.Errorf("#1 got:%#v want:%#v", result, privateKey)
 	}
-	result, _ = Decode(strings.Bytes(pemPrivateKey));
+	result, _ = Decode(strings.Bytes(pemPrivateKey))
 	if !reflect.DeepEqual(result, privateKey2) {
 		t.Errorf("#2 got:%#v want:%#v", result, privateKey2)
 	}
diff --git a/src/pkg/exec/exec.go b/src/pkg/exec/exec.go
index 8a19f0e8fa..8e959e03a3 100644
--- a/src/pkg/exec/exec.go
+++ b/src/pkg/exec/exec.go
@@ -6,16 +6,16 @@
 package exec
 
 import (
-	"os";
-	"strings";
+	"os"
+	"strings"
 )
 
 // Arguments to Run.
 const (
-	DevNull	= iota;
-	PassThrough;
-	Pipe;
-	MergeWithStdout;
+	DevNull = iota
+	PassThrough
+	Pipe
+	MergeWithStdout
 )
 
 // A Cmd represents a running command.
@@ -24,10 +24,10 @@ const (
 // or else nil, depending on the arguments to Run.
 // Pid is the running command's operating system process ID.
 type Cmd struct {
-	Stdin	*os.File;
-	Stdout	*os.File;
-	Stderr	*os.File;
-	Pid	int;
+	Stdin  *os.File
+	Stdout *os.File
+	Stderr *os.File
+	Pid    int
 }
 
 // Given mode (DevNull, etc), return file for child
@@ -35,12 +35,12 @@ type Cmd struct {
 func modeToFiles(mode, fd int) (*os.File, *os.File, os.Error) {
 	switch mode {
 	case DevNull:
-		rw := os.O_WRONLY;
+		rw := os.O_WRONLY
 		if fd == 0 {
 			rw = os.O_RDONLY
 		}
-		f, err := os.Open("/dev/null", rw, 0);
-		return f, nil, err;
+		f, err := os.Open("/dev/null", rw, 0)
+		return f, nil, err
 	case PassThrough:
 		switch fd {
 		case 0:
@@ -51,16 +51,16 @@ func modeToFiles(mode, fd int) (*os.File, *os.File, os.Error) {
 			return os.Stderr, nil, nil
 		}
 	case Pipe:
-		r, w, err := os.Pipe();
+		r, w, err := os.Pipe()
 		if err != nil {
 			return nil, nil, err
 		}
 		if fd == 0 {
 			return r, w, nil
 		}
-		return w, r, nil;
+		return w, r, nil
 	}
-	return nil, nil, os.EINVAL;
+	return nil, nil, os.EINVAL
 }
 
 // Run starts the binary prog running with
@@ -79,8 +79,8 @@ func modeToFiles(mode, fd int) (*os.File, *os.File, os.Error) {
 // of the returned Cmd is the other end of the pipe.
 // Otherwise the field in Cmd is nil.
 func Run(argv0 string, argv, envv []string, stdin, stdout, stderr int) (p *Cmd, err os.Error) {
-	p = new(Cmd);
-	var fd [3]*os.File;
+	p = new(Cmd)
+	var fd [3]*os.File
 
 	if fd[0], p.Stdin, err = modeToFiles(stdin, 0); err != nil {
 		goto Error
@@ -95,7 +95,7 @@ func Run(argv0 string, argv, envv []string, stdin, stdout, stderr int) (p *Cmd,
 	}
 
 	// Run command.
-	p.Pid, err = os.ForkExec(argv0, argv, envv, "", &fd);
+	p.Pid, err = os.ForkExec(argv0, argv, envv, "", &fd)
 	if err != nil {
 		goto Error
 	}
@@ -108,7 +108,7 @@ func Run(argv0 string, argv, envv []string, stdin, stdout, stderr int) (p *Cmd,
 	if fd[2] != os.Stderr && fd[2] != fd[1] {
 		fd[2].Close()
 	}
-	return p, nil;
+	return p, nil
 
 Error:
 	if fd[0] != os.Stdin && fd[0] != nil {
@@ -129,7 +129,7 @@ Error:
 	if p.Stderr != nil {
 		p.Stderr.Close()
 	}
-	return nil, err;
+	return nil, err
 }
 
 // Wait waits for the running command p,
@@ -142,11 +142,11 @@ func (p *Cmd) Wait(options int) (*os.Waitmsg, os.Error) {
 	if p.Pid <= 0 {
 		return nil, os.ErrorString("exec: invalid use of Cmd.Wait")
 	}
-	w, err := os.Wait(p.Pid, options);
+	w, err := os.Wait(p.Pid, options)
 	if w != nil && (w.Exited() || w.Signaled()) {
 		p.Pid = -1
 	}
-	return w, err;
+	return w, err
 }
 
 // Close waits for the running command p to exit,
@@ -157,14 +157,14 @@ func (p *Cmd) Close() os.Error {
 		// Loop on interrupt, but
 		// ignore other errors -- maybe
 		// caller has already waited for pid.
-		_, err := p.Wait(0);
+		_, err := p.Wait(0)
 		for err == os.EINTR {
 			_, err = p.Wait(0)
 		}
 	}
 
 	// Close the FDs that are still open.
-	var err os.Error;
+	var err os.Error
 	if p.Stdin != nil && p.Stdin.Fd() >= 0 {
 		if err1 := p.Stdin.Close(); err1 != nil {
 			err = err1
@@ -180,15 +180,15 @@ func (p *Cmd) Close() os.Error {
 			err = err1
 		}
 	}
-	return err;
+	return err
 }
 
 func canExec(file string) bool {
-	d, err := os.Stat(file);
+	d, err := os.Stat(file)
 	if err != nil {
 		return false
 	}
-	return d.IsRegular() && d.Permission()&0111 != 0;
+	return d.IsRegular() && d.Permission()&0111 != 0
 }
 
 // LookPath searches for an executable binary named file
@@ -205,9 +205,9 @@ func LookPath(file string) (string, os.Error) {
 		if canExec(file) {
 			return file, nil
 		}
-		return "", os.ENOENT;
+		return "", os.ENOENT
 	}
-	pathenv := os.Getenv("PATH");
+	pathenv := os.Getenv("PATH")
 	for _, dir := range strings.Split(pathenv, ":", 0) {
 		if dir == "" {
 			// Unix shell semantics: path element "" means "."
@@ -217,5 +217,5 @@ func LookPath(file string) (string, os.Error) {
 			return dir + "/" + file, nil
 		}
 	}
-	return "", os.ENOENT;
+	return "", os.ENOENT
 }
diff --git a/src/pkg/exec/exec_test.go b/src/pkg/exec/exec_test.go
index 5a997fd199..9c4d2ee319 100644
--- a/src/pkg/exec/exec_test.go
+++ b/src/pkg/exec/exec_test.go
@@ -5,20 +5,20 @@
 package exec
 
 import (
-	"io";
-	"io/ioutil";
-	"testing";
+	"io"
+	"io/ioutil"
+	"testing"
 )
 
 func TestRunCat(t *testing.T) {
 	cmd, err := Run("/bin/cat", []string{"cat"}, nil,
-		Pipe, Pipe, DevNull);
+		Pipe, Pipe, DevNull)
 	if err != nil {
 		t.Fatalf("opencmd /bin/cat: %v", err)
 	}
-	io.WriteString(cmd.Stdin, "hello, world\n");
-	cmd.Stdin.Close();
-	buf, err := ioutil.ReadAll(cmd.Stdout);
+	io.WriteString(cmd.Stdin, "hello, world\n")
+	cmd.Stdin.Close()
+	buf, err := ioutil.ReadAll(cmd.Stdout)
 	if err != nil {
 		t.Fatalf("reading from /bin/cat: %v", err)
 	}
@@ -32,11 +32,11 @@ func TestRunCat(t *testing.T) {
 
 func TestRunEcho(t *testing.T) {
 	cmd, err := Run("/bin/echo", []string{"echo", "hello", "world"}, nil,
-		DevNull, Pipe, DevNull);
+		DevNull, Pipe, DevNull)
 	if err != nil {
 		t.Fatalf("opencmd /bin/echo: %v", err)
 	}
-	buf, err := ioutil.ReadAll(cmd.Stdout);
+	buf, err := ioutil.ReadAll(cmd.Stdout)
 	if err != nil {
 		t.Fatalf("reading from /bin/echo: %v", err)
 	}
diff --git a/src/pkg/exp/4s/4s.go b/src/pkg/exp/4s/4s.go
index ffd9d53705..271af78e27 100644
--- a/src/pkg/exp/4s/4s.go
+++ b/src/pkg/exp/4s/4s.go
@@ -10,11 +10,11 @@
 package main
 
 import (
-	"exp/nacl/av";
-	"exp/nacl/srpc";
-	"log";
-	"runtime";
-	"os";
+	"exp/nacl/av"
+	"exp/nacl/srpc"
+	"log"
+	"runtime"
+	"os"
 )
 
 var sndc chan []uint16
@@ -22,57 +22,57 @@ var sndc chan []uint16
 func main() {
 	// Native Client requires that some calls are issued
 	// consistently by the same OS thread.
-	runtime.LockOSThread();
+	runtime.LockOSThread()
 
 	if srpc.Enabled() {
 		go srpc.ServeRuntime()
 	}
 
-	args := os.Args;
-	p := pieces4;
+	args := os.Args
+	p := pieces4
 	if len(args) > 1 && args[1] == "-5" {
 		p = pieces5
 	}
-	dx, dy := 500, 500;
-	w, err := av.Init(av.SubsystemVideo|av.SubsystemAudio, dx, dy);
+	dx, dy := 500, 500
+	w, err := av.Init(av.SubsystemVideo|av.SubsystemAudio, dx, dy)
 	if err != nil {
 		log.Exit(err)
 	}
 
-	sndc = make(chan []uint16, 10);
-	go audioServer();
-	Play(p, w);
+	sndc = make(chan []uint16, 10)
+	go audioServer()
+	Play(p, w)
 }
 
 func audioServer() {
 	// Native Client requires that all audio calls
 	// original from a single OS thread.
-	runtime.LockOSThread();
+	runtime.LockOSThread()
 
-	n, err := av.AudioStream(nil);
+	n, err := av.AudioStream(nil)
 	if err != nil {
 		log.Exit(err)
 	}
 	for {
-		b := <-sndc;
+		b := <-sndc
 		for len(b)*2 >= n {
-			var a []uint16;
-			a, b = b[0:n/2], b[n/2:];
-			n, err = av.AudioStream(a);
+			var a []uint16
+			a, b = b[0:n/2], b[n/2:]
+			n, err = av.AudioStream(a)
 			if err != nil {
 				log.Exit(err)
 			}
-			println(n, len(b)*2);
+			println(n, len(b)*2)
 		}
-		a := make([]uint16, n/2);
+		a := make([]uint16, n/2)
 		for i := range b {
 			a[i] = b[i]
 		}
-		n, err = av.AudioStream(a);
+		n, err = av.AudioStream(a)
 	}
 }
 
-func PlaySound(b []uint16)	{ sndc <- b }
+func PlaySound(b []uint16) { sndc <- b }
 
 var whoosh = []uint16{
 // Insert your favorite sound samples here.
diff --git a/src/pkg/exp/4s/5s.go b/src/pkg/exp/4s/5s.go
index 08899193ee..efeb6f1163 100644
--- a/src/pkg/exp/4s/5s.go
+++ b/src/pkg/exp/4s/5s.go
@@ -6,4 +6,4 @@
 
 package main
 
-func init()	{ pieces4 = pieces5 }
+func init() { pieces4 = pieces5 }
diff --git a/src/pkg/exp/4s/xs.go b/src/pkg/exp/4s/xs.go
index ae994d2c36..94a6f8597b 100644
--- a/src/pkg/exp/4s/xs.go
+++ b/src/pkg/exp/4s/xs.go
@@ -15,12 +15,12 @@
 package main
 
 import (
-	"exp/draw";
-	"image";
-	"log";
-	"os";
-	"rand";
-	"time";
+	"exp/draw"
+	"image"
+	"log"
+	"os"
+	"rand"
+	"time"
 )
 
 /*
@@ -38,57 +38,57 @@ Cursor whitearrow = {
 */
 
 const (
-	CNone	= 0;
-	CBounds	= 1;
-	CPiece	= 2;
-	NX	= 10;
-	NY	= 20;
+	CNone   = 0
+	CBounds = 1
+	CPiece  = 2
+	NX      = 10
+	NY      = 20
 
-	NCOL	= 10;
+	NCOL = 10
 
-	MAXN	= 5;
+	MAXN = 5
 )
 
 var (
-	N				int;
-	display				draw.Context;
-	screen				draw.Image;
-	screenr				draw.Rectangle;
-	board				[NY][NX]byte;
-	rboard				draw.Rectangle;
-	pscore				draw.Point;
-	scoresz				draw.Point;
-	pcsz				= 32;
-	pos				draw.Point;
-	bbr, bb2r			draw.Rectangle;
-	bb, bbmask, bb2, bb2mask	*image.RGBA;
-	whitemask			image.Image;
-	br, br2				draw.Rectangle;
-	points				int;
-	dt				int;
-	DY				int;
-	DMOUSE				int;
-	lastmx				int;
-	mouse				draw.Mouse;
-	newscreen			bool;
-	timerc				<-chan int64;
-	suspc				chan bool;
-	mousec				chan draw.Mouse;
-	resizec				<-chan bool;
-	kbdc				chan int;
-	suspended			bool;
-	tsleep				int;
-	piece				*Piece;
-	pieces				[]Piece;
+	N                        int
+	display                  draw.Context
+	screen                   draw.Image
+	screenr                  draw.Rectangle
+	board                    [NY][NX]byte
+	rboard                   draw.Rectangle
+	pscore                   draw.Point
+	scoresz                  draw.Point
+	pcsz                     = 32
+	pos                      draw.Point
+	bbr, bb2r                draw.Rectangle
+	bb, bbmask, bb2, bb2mask *image.RGBA
+	whitemask                image.Image
+	br, br2                  draw.Rectangle
+	points                   int
+	dt                       int
+	DY                       int
+	DMOUSE                   int
+	lastmx                   int
+	mouse                    draw.Mouse
+	newscreen                bool
+	timerc                   <-chan int64
+	suspc                    chan bool
+	mousec                   chan draw.Mouse
+	resizec                  <-chan bool
+	kbdc                     chan int
+	suspended                bool
+	tsleep                   int
+	piece                    *Piece
+	pieces                   []Piece
 )
 
 type Piece struct {
-	rot	int;
-	tx	int;
-	sz	draw.Point;
-	d	[]draw.Point;
-	left	*Piece;
-	right	*Piece;
+	rot   int
+	tx    int
+	sz    draw.Point
+	d     []draw.Point
+	left  *Piece
+	right *Piece
 }
 
 var txbits = [NCOL][32]byte{
@@ -145,16 +145,16 @@ var txbits = [NCOL][32]byte{
 }
 
 var txpix = [NCOL]draw.Color{
-	draw.Yellow,		/* yellow */
-	draw.Cyan,		/* cyan */
-	draw.Green,		/* lime green */
-	draw.GreyBlue,		/* slate */
-	draw.Red,		/* red */
-	draw.GreyGreen,		/* olive green */
-	draw.Blue,		/* blue */
-	draw.Color(0xFF55AAFF),	/* pink */
-	draw.Color(0xFFAAFFFF),	/* lavender */
-	draw.Color(0xBB005DFF),	/* maroon */
+	draw.Yellow,            /* yellow */
+	draw.Cyan,              /* cyan */
+	draw.Green,             /* lime green */
+	draw.GreyBlue,          /* slate */
+	draw.Red,               /* red */
+	draw.GreyGreen,         /* olive green */
+	draw.Blue,              /* blue */
+	draw.Color(0xFF55AAFF), /* pink */
+	draw.Color(0xFFAAFFFF), /* lavender */
+	draw.Color(0xBB005DFF), /* maroon */
 }
 
 func movemouse() int {
@@ -165,7 +165,7 @@ func movemouse() int {
 
 func warp(p draw.Point, x int) int {
 	if !suspended && piece != nil {
-		x = pos.X + piece.sz.X*pcsz/2;
+		x = pos.X + piece.sz.X*pcsz/2
 		if p.Y < rboard.Min.Y {
 			p.Y = rboard.Min.Y
 		}
@@ -174,12 +174,12 @@ func warp(p draw.Point, x int) int {
 		}
 		//moveto(mousectl, draw.Pt(x, p.Y));
 	}
-	return x;
+	return x
 }
 
 func initPieces() {
 	for i := range pieces {
-		p := &pieces[i];
+		p := &pieces[i]
 		if p.rot == 3 {
 			p.right = &pieces[i-3]
 		} else {
@@ -194,27 +194,27 @@ func initPieces() {
 }
 
 func collide(pt draw.Point, p *Piece) bool {
-	pt.X = (pt.X - rboard.Min.X) / pcsz;
-	pt.Y = (pt.Y - rboard.Min.Y) / pcsz;
+	pt.X = (pt.X - rboard.Min.X) / pcsz
+	pt.Y = (pt.Y - rboard.Min.Y) / pcsz
 	for _, q := range p.d {
-		pt.X += q.X;
-		pt.Y += q.Y;
+		pt.X += q.X
+		pt.Y += q.Y
 		if pt.X < 0 || pt.X >= NX || pt.Y < 0 || pt.Y >= NY {
-			return true;
-			continue;
+			return true
+			continue
 		}
 		if board[pt.Y][pt.X] != 0 {
 			return true
 		}
 	}
-	return false;
+	return false
 }
 
 func collider(pt, pmax draw.Point) bool {
-	pi := (pt.X - rboard.Min.X) / pcsz;
-	pj := (pt.Y - rboard.Min.Y) / pcsz;
-	n := pmax.X / pcsz;
-	m := pmax.Y/pcsz + 1;
+	pi := (pt.X - rboard.Min.X) / pcsz
+	pj := (pt.Y - rboard.Min.Y) / pcsz
+	n := pmax.X / pcsz
+	m := pmax.Y/pcsz + 1
 	for i := pi; i < pi+n && i < NX; i++ {
 		for j := pj; j < pj+m && j < NY; j++ {
 			if board[j][i] != 0 {
@@ -222,34 +222,34 @@ func collider(pt, pmax draw.Point) bool {
 			}
 		}
 	}
-	return false;
+	return false
 }
 
 func setpiece(p *Piece) {
-	draw.Draw(bb, bbr, draw.White, nil, draw.ZP);
-	draw.Draw(bbmask, bbr, draw.Transparent, nil, draw.ZP);
-	br = draw.Rect(0, 0, 0, 0);
-	br2 = br;
-	piece = p;
+	draw.Draw(bb, bbr, draw.White, nil, draw.ZP)
+	draw.Draw(bbmask, bbr, draw.Transparent, nil, draw.ZP)
+	br = draw.Rect(0, 0, 0, 0)
+	br2 = br
+	piece = p
 	if p == nil {
 		return
 	}
-	var op draw.Point;
-	var r draw.Rectangle;
-	r.Min = bbr.Min;
+	var op draw.Point
+	var r draw.Rectangle
+	r.Min = bbr.Min
 	for i, pt := range p.d {
-		r.Min.X += pt.X * pcsz;
-		r.Min.Y += pt.Y * pcsz;
-		r.Max.X = r.Min.X + pcsz;
-		r.Max.Y = r.Min.Y + pcsz;
+		r.Min.X += pt.X * pcsz
+		r.Min.Y += pt.Y * pcsz
+		r.Max.X = r.Min.X + pcsz
+		r.Max.Y = r.Min.Y + pcsz
 		if i == 0 {
-			draw.Draw(bb, r, draw.Black, nil, draw.ZP);
-			draw.Draw(bb, r.Inset(1), txpix[piece.tx], nil, draw.ZP);
-			draw.Draw(bbmask, r, draw.Opaque, nil, draw.ZP);
-			op = r.Min;
+			draw.Draw(bb, r, draw.Black, nil, draw.ZP)
+			draw.Draw(bb, r.Inset(1), txpix[piece.tx], nil, draw.ZP)
+			draw.Draw(bbmask, r, draw.Opaque, nil, draw.ZP)
+			op = r.Min
 		} else {
-			draw.Draw(bb, r, bb, nil, op);
-			draw.Draw(bbmask, r, bbmask, nil, op);
+			draw.Draw(bb, r, bb, nil, op)
+			draw.Draw(bbmask, r, bbmask, nil, op)
 		}
 		if br.Max.X < r.Max.X {
 			br.Max.X = r.Max.X
@@ -258,66 +258,66 @@ func setpiece(p *Piece) {
 			br.Max.Y = r.Max.Y
 		}
 	}
-	br.Max = br.Max.Sub(bbr.Min);
-	delta := draw.Pt(0, DY);
-	br2.Max = br.Max.Add(delta);
-	r = br.Add(bb2r.Min);
-	r2 := br2.Add(bb2r.Min);
-	draw.Draw(bb2, r2, draw.White, nil, draw.ZP);
-	draw.Draw(bb2, r.Add(delta), bb, nil, bbr.Min);
-	draw.Draw(bb2mask, r2, draw.Transparent, nil, draw.ZP);
-	draw.Draw(bb2mask, r, draw.Opaque, bbmask, bbr.Min);
-	draw.Draw(bb2mask, r.Add(delta), draw.Opaque, bbmask, bbr.Min);
+	br.Max = br.Max.Sub(bbr.Min)
+	delta := draw.Pt(0, DY)
+	br2.Max = br.Max.Add(delta)
+	r = br.Add(bb2r.Min)
+	r2 := br2.Add(bb2r.Min)
+	draw.Draw(bb2, r2, draw.White, nil, draw.ZP)
+	draw.Draw(bb2, r.Add(delta), bb, nil, bbr.Min)
+	draw.Draw(bb2mask, r2, draw.Transparent, nil, draw.ZP)
+	draw.Draw(bb2mask, r, draw.Opaque, bbmask, bbr.Min)
+	draw.Draw(bb2mask, r.Add(delta), draw.Opaque, bbmask, bbr.Min)
 }
 
 func drawpiece() {
-	draw.Draw(screen, br.Add(pos), bb, bbmask, bbr.Min);
+	draw.Draw(screen, br.Add(pos), bb, bbmask, bbr.Min)
 	if suspended {
 		draw.Draw(screen, br.Add(pos), draw.White, whitemask, draw.ZP)
 	}
 }
 
 func undrawpiece() {
-	var mask image.Image;
+	var mask image.Image
 	if collider(pos, br.Max) {
 		mask = bbmask
 	}
-	draw.Draw(screen, br.Add(pos), draw.White, mask, bbr.Min);
+	draw.Draw(screen, br.Add(pos), draw.White, mask, bbr.Min)
 }
 
 func rest() {
-	pt := pos.Sub(rboard.Min).Div(pcsz);
+	pt := pos.Sub(rboard.Min).Div(pcsz)
 	for _, p := range piece.d {
-		pt.X += p.X;
-		pt.Y += p.Y;
-		board[pt.Y][pt.X] = byte(piece.tx + 16);
+		pt.X += p.X
+		pt.Y += p.Y
+		board[pt.Y][pt.X] = byte(piece.tx + 16)
 	}
 }
 
 func canfit(p *Piece) bool {
-	var dx = [...]int{0, -1, 1, -2, 2, -3, 3, 4, -4};
-	j := N + 1;
+	var dx = [...]int{0, -1, 1, -2, 2, -3, 3, 4, -4}
+	j := N + 1
 	if j >= 4 {
-		j = p.sz.X;
+		j = p.sz.X
 		if j < p.sz.Y {
 			j = p.sz.Y
 		}
-		j = 2*j - 1;
+		j = 2*j - 1
 	}
 	for i := 0; i < j; i++ {
-		var z draw.Point;
-		z.X = pos.X + dx[i]*pcsz;
-		z.Y = pos.Y;
+		var z draw.Point
+		z.X = pos.X + dx[i]*pcsz
+		z.Y = pos.Y
 		if !collide(z, p) {
-			z.Y = pos.Y + pcsz - 1;
+			z.Y = pos.Y + pcsz - 1
 			if !collide(z, p) {
-				undrawpiece();
-				pos.X = z.X;
-				return true;
+				undrawpiece()
+				pos.X = z.X
+				return true
 			}
 		}
 	}
-	return false;
+	return false
 }
 
 func score(p int) {
@@ -328,18 +328,18 @@ func score(p int) {
 }
 
 func drawsq(b draw.Image, p draw.Point, ptx int) {
-	var r draw.Rectangle;
-	r.Min = p;
-	r.Max.X = r.Min.X + pcsz;
-	r.Max.Y = r.Min.Y + pcsz;
-	draw.Draw(b, r, draw.Black, nil, draw.ZP);
-	draw.Draw(b, r.Inset(1), txpix[ptx], nil, draw.ZP);
+	var r draw.Rectangle
+	r.Min = p
+	r.Max.X = r.Min.X + pcsz
+	r.Max.Y = r.Min.Y + pcsz
+	draw.Draw(b, r, draw.Black, nil, draw.ZP)
+	draw.Draw(b, r.Inset(1), txpix[ptx], nil, draw.ZP)
 }
 
 func drawboard() {
-	draw.Border(screen, rboard.Inset(-2), 2, draw.Black, draw.ZP);
+	draw.Border(screen, rboard.Inset(-2), 2, draw.Black, draw.ZP)
 	draw.Draw(screen, draw.Rect(rboard.Min.X, rboard.Min.Y-2, rboard.Max.X, rboard.Min.Y),
-		draw.White, nil, draw.ZP);
+		draw.White, nil, draw.ZP)
 	for i := 0; i < NY; i++ {
 		for j := 0; j < NX; j++ {
 			if board[i][j] != 0 {
@@ -347,7 +347,7 @@ func drawboard() {
 			}
 		}
 	}
-	score(0);
+	score(0)
 	if suspended {
 		draw.Draw(screen, screenr, draw.White, whitemask, draw.ZP)
 	}
@@ -355,34 +355,34 @@ func drawboard() {
 
 func choosepiece() {
 	for {
-		i := rand.Intn(len(pieces));
-		setpiece(&pieces[i]);
-		pos = rboard.Min;
-		pos.X += rand.Intn(NX) * pcsz;
+		i := rand.Intn(len(pieces))
+		setpiece(&pieces[i])
+		pos = rboard.Min
+		pos.X += rand.Intn(NX) * pcsz
 		if !collide(draw.Pt(pos.X, pos.Y+pcsz-DY), piece) {
 			break
 		}
 	}
-	drawpiece();
-	display.FlushImage();
+	drawpiece()
+	display.FlushImage()
 }
 
 func movepiece() bool {
-	var mask image.Image;
+	var mask image.Image
 	if collide(draw.Pt(pos.X, pos.Y+pcsz), piece) {
 		return false
 	}
 	if collider(pos, br2.Max) {
 		mask = bb2mask
 	}
-	draw.Draw(screen, br2.Add(pos), bb2, mask, bb2r.Min);
-	pos.Y += DY;
-	display.FlushImage();
-	return true;
+	draw.Draw(screen, br2.Add(pos), bb2, mask, bb2r.Min)
+	pos.Y += DY
+	display.FlushImage()
+	return true
 }
 
 func suspend(s bool) {
-	suspended = s;
+	suspended = s
 	/*
 		if suspended {
 			setcursor(mousectl, &whitearrow);
@@ -393,26 +393,26 @@ func suspend(s bool) {
 	if !suspended {
 		drawpiece()
 	}
-	drawboard();
-	display.FlushImage();
+	drawboard()
+	display.FlushImage()
 }
 
 func pause(t int) {
-	display.FlushImage();
+	display.FlushImage()
 	for {
 		select {
 		case s := <-suspc:
 			if !suspended && s {
 				suspend(true)
 			} else if suspended && !s {
-				suspend(false);
-				lastmx = warp(mouse.Point, lastmx);
+				suspend(false)
+				lastmx = warp(mouse.Point, lastmx)
 			}
 		case <-timerc:
 			if suspended {
 				break
 			}
-			t -= tsleep;
+			t -= tsleep
 			if t < 0 {
 				return
 			}
@@ -425,93 +425,93 @@ func pause(t int) {
 }
 
 func horiz() bool {
-	var lev [MAXN]int;
-	h := 0;
+	var lev [MAXN]int
+	h := 0
 	for i := 0; i < NY; i++ {
 		for j := 0; board[i][j] != 0; j++ {
 			if j == NX-1 {
-				lev[h] = i;
-				h++;
-				break;
+				lev[h] = i
+				h++
+				break
 			}
 		}
 	}
 	if h == 0 {
 		return false
 	}
-	r := rboard;
-	newscreen = false;
+	r := rboard
+	newscreen = false
 	for j := 0; j < h; j++ {
-		r.Min.Y = rboard.Min.Y + lev[j]*pcsz;
-		r.Max.Y = r.Min.Y + pcsz;
-		draw.Draw(screen, r, draw.White, whitemask, draw.ZP);
-		display.FlushImage();
+		r.Min.Y = rboard.Min.Y + lev[j]*pcsz
+		r.Max.Y = r.Min.Y + pcsz
+		draw.Draw(screen, r, draw.White, whitemask, draw.ZP)
+		display.FlushImage()
 	}
-	PlaySound(whoosh);
+	PlaySound(whoosh)
 	for i := 0; i < 3; i++ {
-		pause(250);
+		pause(250)
 		if newscreen {
-			drawboard();
-			break;
+			drawboard()
+			break
 		}
 		for j := 0; j < h; j++ {
-			r.Min.Y = rboard.Min.Y + lev[j]*pcsz;
-			r.Max.Y = r.Min.Y + pcsz;
-			draw.Draw(screen, r, draw.White, whitemask, draw.ZP);
+			r.Min.Y = rboard.Min.Y + lev[j]*pcsz
+			r.Max.Y = r.Min.Y + pcsz
+			draw.Draw(screen, r, draw.White, whitemask, draw.ZP)
 		}
-		display.FlushImage();
+		display.FlushImage()
 	}
-	r = rboard;
+	r = rboard
 	for j := 0; j < h; j++ {
-		i := NY - lev[j] - 1;
-		score(250 + 10*i*i);
-		r.Min.Y = rboard.Min.Y;
-		r.Max.Y = rboard.Min.Y + lev[j]*pcsz;
-		draw.Draw(screen, r.Add(draw.Pt(0, pcsz)), screen, nil, r.Min);
-		r.Max.Y = rboard.Min.Y + pcsz;
-		draw.Draw(screen, r, draw.White, nil, draw.ZP);
+		i := NY - lev[j] - 1
+		score(250 + 10*i*i)
+		r.Min.Y = rboard.Min.Y
+		r.Max.Y = rboard.Min.Y + lev[j]*pcsz
+		draw.Draw(screen, r.Add(draw.Pt(0, pcsz)), screen, nil, r.Min)
+		r.Max.Y = rboard.Min.Y + pcsz
+		draw.Draw(screen, r, draw.White, nil, draw.ZP)
 		for k := lev[j] - 1; k >= 0; k-- {
 			board[k+1] = board[k]
 		}
-		board[0] = [NX]byte{};
+		board[0] = [NX]byte{}
 	}
-	display.FlushImage();
-	return true;
+	display.FlushImage()
+	return true
 }
 
 func mright() {
 	if !collide(draw.Pt(pos.X+pcsz, pos.Y), piece) &&
 		!collide(draw.Pt(pos.X+pcsz, pos.Y+pcsz-DY), piece) {
-		undrawpiece();
-		pos.X += pcsz;
-		drawpiece();
-		display.FlushImage();
+		undrawpiece()
+		pos.X += pcsz
+		drawpiece()
+		display.FlushImage()
 	}
 }
 
 func mleft() {
 	if !collide(draw.Pt(pos.X-pcsz, pos.Y), piece) &&
 		!collide(draw.Pt(pos.X-pcsz, pos.Y+pcsz-DY), piece) {
-		undrawpiece();
-		pos.X -= pcsz;
-		drawpiece();
-		display.FlushImage();
+		undrawpiece()
+		pos.X -= pcsz
+		drawpiece()
+		display.FlushImage()
 	}
 }
 
 func rright() {
 	if canfit(piece.right) {
-		setpiece(piece.right);
-		drawpiece();
-		display.FlushImage();
+		setpiece(piece.right)
+		drawpiece()
+		display.FlushImage()
 	}
 }
 
 func rleft() {
 	if canfit(piece.left) {
-		setpiece(piece.left);
-		drawpiece();
-		display.FlushImage();
+		setpiece(piece.left)
+		drawpiece()
+		display.FlushImage()
 	}
 }
 
@@ -519,47 +519,47 @@ var fusst = 0
 
 func drop(f bool) bool {
 	if f {
-		score(5 * (rboard.Max.Y - pos.Y) / pcsz);
+		score(5 * (rboard.Max.Y - pos.Y) / pcsz)
 		for movepiece() {
 		}
 	}
-	fusst = 0;
-	rest();
+	fusst = 0
+	rest()
 	if pos.Y == rboard.Min.Y && !horiz() {
 		return true
 	}
-	horiz();
-	setpiece(nil);
-	pause(1500);
-	choosepiece();
-	lastmx = warp(mouse.Point, lastmx);
-	return false;
+	horiz()
+	setpiece(nil)
+	pause(1500)
+	choosepiece()
+	lastmx = warp(mouse.Point, lastmx)
+	return false
 }
 
 func play() {
-	var om draw.Mouse;
-	dt = 64;
-	lastmx = -1;
-	lastmx = movemouse();
-	choosepiece();
-	lastmx = warp(mouse.Point, lastmx);
+	var om draw.Mouse
+	dt = 64
+	lastmx = -1
+	lastmx = movemouse()
+	choosepiece()
+	lastmx = warp(mouse.Point, lastmx)
 	for {
 		select {
 		case mouse = <-mousec:
 			if suspended {
-				om = mouse;
-				break;
+				om = mouse
+				break
 			}
 			if lastmx < 0 {
 				lastmx = mouse.X
 			}
 			if mouse.X > lastmx+DMOUSE {
-				mright();
-				lastmx = mouse.X;
+				mright()
+				lastmx = mouse.X
 			}
 			if mouse.X < lastmx-DMOUSE {
-				mleft();
-				lastmx = mouse.X;
+				mleft()
+				lastmx = mouse.X
 			}
 			if mouse.Buttons&^om.Buttons&1 == 1 {
 				rleft()
@@ -572,14 +572,14 @@ func play() {
 			if mouse.Buttons&^om.Buttons&4 == 4 {
 				rright()
 			}
-			om = mouse;
+			om = mouse
 
 		case s := <-suspc:
 			if !suspended && s {
 				suspend(true)
 			} else if suspended && !s {
-				suspend(false);
-				lastmx = warp(mouse.Point, lastmx);
+				suspend(false)
+				lastmx = warp(mouse.Point, lastmx)
 			}
 
 		case <-resizec:
@@ -608,25 +608,25 @@ func play() {
 			if suspended {
 				break
 			}
-			dt -= tsleep;
+			dt -= tsleep
 			if dt < 0 {
-				i := 1;
-				dt = 16 * (points + rand.Intn(10000) - 5000) / 10000;
+				i := 1
+				dt = 16 * (points + rand.Intn(10000) - 5000) / 10000
 				if dt >= 32 {
-					i += (dt - 32) / 16;
-					dt = 32;
+					i += (dt - 32) / 16
+					dt = 32
 				}
-				dt = 52 - dt;
+				dt = 52 - dt
 				for ; i > 0; i-- {
 					if movepiece() {
 						continue
 					}
-					fusst++;
+					fusst++
 					if fusst == 40 {
 						if drop(false) {
 							return
 						}
-						break;
+						break
 					}
 				}
 			}
@@ -635,10 +635,10 @@ func play() {
 }
 
 func suspproc() {
-	mc := display.MouseChan();
-	kc := display.KeyboardChan();
+	mc := display.MouseChan()
+	kc := display.KeyboardChan()
 
-	s := false;
+	s := false
 	for {
 		select {
 		case mouse = <-mc:
@@ -649,14 +649,14 @@ func suspproc() {
 				os.Exit(0)
 			default:
 				if s {
-					s = false;
-					suspc <- s;
-					break;
+					s = false
+					suspc <- s
+					break
 				}
 				switch r {
 				case 'z', 'Z', 'p', 'P', 0x1B:
-					s = true;
-					suspc <- s;
+					s = true
+					suspc <- s
 				default:
 					kbdc <- r
 				}
@@ -669,74 +669,74 @@ func redraw(new bool) {
 	//	if new && getwindow(display, Refmesg) < 0 {
 	//		sysfatal("can't reattach to window");
 	//	}
-	r := draw.Rect(0, 0, screen.Width(), screen.Height());
-	pos.X = (pos.X - rboard.Min.X) / pcsz;
-	pos.Y = (pos.Y - rboard.Min.Y) / pcsz;
-	dx := r.Max.X - r.Min.X;
-	dy := r.Max.Y - r.Min.Y - 2*32;
-	DY = dx / NX;
+	r := draw.Rect(0, 0, screen.Width(), screen.Height())
+	pos.X = (pos.X - rboard.Min.X) / pcsz
+	pos.Y = (pos.Y - rboard.Min.Y) / pcsz
+	dx := r.Max.X - r.Min.X
+	dy := r.Max.Y - r.Min.Y - 2*32
+	DY = dx / NX
 	if DY > dy/NY {
 		DY = dy / NY
 	}
-	DY /= 8;
+	DY /= 8
 	if DY > 4 {
 		DY = 4
 	}
-	pcsz = DY * 8;
-	DMOUSE = pcsz / 3;
+	pcsz = DY * 8
+	DMOUSE = pcsz / 3
 	if pcsz < 8 {
 		log.Exitf("screen too small: %d", pcsz)
 	}
-	rboard = screenr;
-	rboard.Min.X += (dx - pcsz*NX) / 2;
-	rboard.Min.Y += (dy-pcsz*NY)/2 + 32;
-	rboard.Max.X = rboard.Min.X + NX*pcsz;
-	rboard.Max.Y = rboard.Min.Y + NY*pcsz;
-	pscore.X = rboard.Min.X + 8;
-	pscore.Y = rboard.Min.Y - 32;
+	rboard = screenr
+	rboard.Min.X += (dx - pcsz*NX) / 2
+	rboard.Min.Y += (dy-pcsz*NY)/2 + 32
+	rboard.Max.X = rboard.Min.X + NX*pcsz
+	rboard.Max.Y = rboard.Min.Y + NY*pcsz
+	pscore.X = rboard.Min.X + 8
+	pscore.Y = rboard.Min.Y - 32
 	//	scoresz = stringsize(font, "000000");
-	pos.X = pos.X*pcsz + rboard.Min.X;
-	pos.Y = pos.Y*pcsz + rboard.Min.Y;
-	bbr = draw.Rect(0, 0, N*pcsz, N*pcsz);
-	bb = image.NewRGBA(bbr.Max.X, bbr.Max.Y);
-	bbmask = image.NewRGBA(bbr.Max.X, bbr.Max.Y);	// actually just a bitmap
-	bb2r = draw.Rect(0, 0, N*pcsz, N*pcsz+DY);
-	bb2 = image.NewRGBA(bb2r.Dx(), bb2r.Dy());
-	bb2mask = image.NewRGBA(bb2r.Dx(), bb2r.Dy());	// actually just a bitmap
-	draw.Draw(screen, screenr, draw.White, nil, draw.ZP);
-	drawboard();
-	setpiece(piece);
+	pos.X = pos.X*pcsz + rboard.Min.X
+	pos.Y = pos.Y*pcsz + rboard.Min.Y
+	bbr = draw.Rect(0, 0, N*pcsz, N*pcsz)
+	bb = image.NewRGBA(bbr.Max.X, bbr.Max.Y)
+	bbmask = image.NewRGBA(bbr.Max.X, bbr.Max.Y) // actually just a bitmap
+	bb2r = draw.Rect(0, 0, N*pcsz, N*pcsz+DY)
+	bb2 = image.NewRGBA(bb2r.Dx(), bb2r.Dy())
+	bb2mask = image.NewRGBA(bb2r.Dx(), bb2r.Dy()) // actually just a bitmap
+	draw.Draw(screen, screenr, draw.White, nil, draw.ZP)
+	drawboard()
+	setpiece(piece)
 	if piece != nil {
 		drawpiece()
 	}
-	lastmx = movemouse();
-	newscreen = true;
-	display.FlushImage();
+	lastmx = movemouse()
+	newscreen = true
+	display.FlushImage()
 }
 
 func quitter(c <-chan bool) {
-	<-c;
-	os.Exit(0);
+	<-c
+	os.Exit(0)
 }
 
 func Play(pp []Piece, ctxt draw.Context) {
-	display = ctxt;
-	screen = ctxt.Screen();
-	screenr = draw.Rect(0, 0, screen.Width(), screen.Height());
-	pieces = pp;
-	N = len(pieces[0].d);
-	initPieces();
-	rand.Seed(int64(time.Nanoseconds() % (1e9 - 1)));
-	whitemask = draw.White.SetAlpha(0x7F);
-	tsleep = 50;
-	timerc = time.Tick(int64(tsleep/2) * 1e6);
-	suspc = make(chan bool);
-	mousec = make(chan draw.Mouse);
-	resizec = ctxt.ResizeChan();
-	kbdc = make(chan int);
-	go quitter(ctxt.QuitChan());
-	go suspproc();
-	points = 0;
-	redraw(false);
-	play();
+	display = ctxt
+	screen = ctxt.Screen()
+	screenr = draw.Rect(0, 0, screen.Width(), screen.Height())
+	pieces = pp
+	N = len(pieces[0].d)
+	initPieces()
+	rand.Seed(int64(time.Nanoseconds() % (1e9 - 1)))
+	whitemask = draw.White.SetAlpha(0x7F)
+	tsleep = 50
+	timerc = time.Tick(int64(tsleep/2) * 1e6)
+	suspc = make(chan bool)
+	mousec = make(chan draw.Mouse)
+	resizec = ctxt.ResizeChan()
+	kbdc = make(chan int)
+	go quitter(ctxt.QuitChan())
+	go suspproc()
+	points = 0
+	redraw(false)
+	play()
 }
diff --git a/src/pkg/exp/datafmt/datafmt.go b/src/pkg/exp/datafmt/datafmt.go
index 4ed9695abe..0a2354286b 100644
--- a/src/pkg/exp/datafmt/datafmt.go
+++ b/src/pkg/exp/datafmt/datafmt.go
@@ -202,13 +202,13 @@
 package datafmt
 
 import (
-	"bytes";
-	"fmt";
-	"go/token";
-	"io";
-	"os";
-	"reflect";
-	"runtime";
+	"bytes"
+	"fmt"
+	"go/token"
+	"io"
+	"os"
+	"reflect"
+	"runtime"
 )
 
 
@@ -238,35 +238,35 @@ type FormatterMap map[string]Formatter
 // A parsed format expression is built from the following nodes.
 //
 type (
-	expr	interface{};
+	expr interface{}
 
-	alternatives	[]expr;	// x | y | z
+	alternatives []expr // x | y | z
 
-	sequence	[]expr;	// x y z
+	sequence []expr // x y z
 
-	literal	[][]byte;	// a list of string segments, possibly starting with '%'
+	literal [][]byte // a list of string segments, possibly starting with '%'
 
-	field	struct {
-		fieldName	string;	// including "@", "*"
-		ruleName	string;	// "" if no rule name specified
-	};
+	field struct {
+		fieldName string // including "@", "*"
+		ruleName  string // "" if no rule name specified
+	}
 
-	group	struct {
-		indent, body expr;	// (indent >> body)
-	};
+	group struct {
+		indent, body expr // (indent >> body)
+	}
 
-	option	struct {
-		body expr;	// [body]
-	};
+	option struct {
+		body expr // [body]
+	}
 
-	repetition	struct {
-		body, separator expr;	// {body / separator}
-	};
+	repetition struct {
+		body, separator expr // {body / separator}
+	}
 
-	custom	struct {
-		ruleName	string;
-		fun		Formatter;
-	};
+	custom struct {
+		ruleName string
+		fun      Formatter
+	}
 )
 
 
@@ -290,7 +290,7 @@ type Format map[string]expr
 // the receiver, and thus can be very light-weight.
 //
 type Environment interface {
-	Copy() Environment;
+	Copy() Environment
 }
 
 
@@ -298,24 +298,24 @@ type Environment interface {
 // It is provided as argument to custom formatters.
 //
 type State struct {
-	fmt		Format;		// format in use
-	env		Environment;	// user-supplied environment
-	errors		chan os.Error;	// not chan *Error (errors <- nil would be wrong!)
-	hasOutput	bool;		// true after the first literal has been written
-	indent		bytes.Buffer;	// current indentation
-	output		bytes.Buffer;	// format output
-	linePos		token.Position;	// position of line beginning (Column == 0)
-	default_	expr;		// possibly nil
-	separator	expr;		// possibly nil
+	fmt       Format         // format in use
+	env       Environment    // user-supplied environment
+	errors    chan os.Error  // not chan *Error (errors <- nil would be wrong!)
+	hasOutput bool           // true after the first literal has been written
+	indent    bytes.Buffer   // current indentation
+	output    bytes.Buffer   // format output
+	linePos   token.Position // position of line beginning (Column == 0)
+	default_  expr           // possibly nil
+	separator expr           // possibly nil
 }
 
 
 func newState(fmt Format, env Environment, errors chan os.Error) *State {
-	s := new(State);
-	s.fmt = fmt;
-	s.env = env;
-	s.errors = errors;
-	s.linePos = token.Position{Line: 1};
+	s := new(State)
+	s.fmt = fmt
+	s.env = env
+	s.errors = errors
+	s.linePos = token.Position{Line: 1}
 
 	// if we have a default rule, cache it's expression for fast access
 	if x, found := fmt["default"]; found {
@@ -327,26 +327,26 @@ func newState(fmt Format, env Environment, errors chan os.Error) *State {
 		s.separator = x
 	}
 
-	return s;
+	return s
 }
 
 
 // Env returns the environment passed to Format.Apply.
-func (s *State) Env() interface{}	{ return s.env }
+func (s *State) Env() interface{} { return s.env }
 
 
 // LinePos returns the position of the current line beginning
 // in the state's output buffer. Line numbers start at 1.
 //
-func (s *State) LinePos() token.Position	{ return s.linePos }
+func (s *State) LinePos() token.Position { return s.linePos }
 
 
 // Pos returns the position of the next byte to be written to the
 // output buffer. Line numbers start at 1.
 //
 func (s *State) Pos() token.Position {
-	offs := s.output.Len();
-	return token.Position{Line: s.linePos.Line, Column: offs - s.linePos.Offset, Offset: offs};
+	offs := s.output.Len()
+	return token.Position{Line: s.linePos.Line, Column: offs - s.linePos.Offset, Offset: offs}
 }
 
 
@@ -354,50 +354,50 @@ func (s *State) Pos() token.Position {
 // string after each newline or form feed character. It cannot return an error.
 //
 func (s *State) Write(data []byte) (int, os.Error) {
-	n := 0;
-	i0 := 0;
+	n := 0
+	i0 := 0
 	for i, ch := range data {
 		if ch == '\n' || ch == '\f' {
 			// write text segment and indentation
-			n1, _ := s.output.Write(data[i0 : i+1]);
-			n2, _ := s.output.Write(s.indent.Bytes());
-			n += n1 + n2;
-			i0 = i + 1;
-			s.linePos.Offset = s.output.Len();
-			s.linePos.Line++;
+			n1, _ := s.output.Write(data[i0 : i+1])
+			n2, _ := s.output.Write(s.indent.Bytes())
+			n += n1 + n2
+			i0 = i + 1
+			s.linePos.Offset = s.output.Len()
+			s.linePos.Line++
 		}
 	}
-	n3, _ := s.output.Write(data[i0:]);
-	return n + n3, nil;
+	n3, _ := s.output.Write(data[i0:])
+	return n + n3, nil
 }
 
 
 type checkpoint struct {
-	env		Environment;
-	hasOutput	bool;
-	outputLen	int;
-	linePos		token.Position;
+	env       Environment
+	hasOutput bool
+	outputLen int
+	linePos   token.Position
 }
 
 
 func (s *State) save() checkpoint {
-	saved := checkpoint{nil, s.hasOutput, s.output.Len(), s.linePos};
+	saved := checkpoint{nil, s.hasOutput, s.output.Len(), s.linePos}
 	if s.env != nil {
 		saved.env = s.env.Copy()
 	}
-	return saved;
+	return saved
 }
 
 
 func (s *State) restore(m checkpoint) {
-	s.env = m.env;
-	s.output.Truncate(m.outputLen);
+	s.env = m.env
+	s.output.Truncate(m.outputLen)
 }
 
 
 func (s *State) error(msg string) {
-	s.errors <- os.NewError(msg);
-	runtime.Goexit();
+	s.errors <- os.NewError(msg)
+	runtime.Goexit()
 }
 
 
@@ -426,7 +426,7 @@ func typename(typ reflect.Type) string {
 	case *reflect.PtrType:
 		return "ptr"
 	}
-	return typ.String();
+	return typ.String()
 }
 
 func (s *State) getFormat(name string) expr {
@@ -438,8 +438,8 @@ func (s *State) getFormat(name string) expr {
 		return s.default_
 	}
 
-	s.error(fmt.Sprintf("no format rule for type: '%s'", name));
-	return nil;
+	s.error(fmt.Sprintf("no format rule for type: '%s'", name))
+	return nil
 }
 
 
@@ -459,42 +459,42 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {
 	case alternatives:
 		// append the result of the first alternative that evaluates to
 		// a non-nil []byte to the state's output
-		mark := s.save();
+		mark := s.save()
 		for _, x := range t {
 			if s.eval(x, value, index) {
 				return true
 			}
-			s.restore(mark);
+			s.restore(mark)
 		}
-		return false;
+		return false
 
 	case sequence:
 		// append the result of all operands to the state's output
 		// unless a nil result is encountered
-		mark := s.save();
+		mark := s.save()
 		for _, x := range t {
 			if !s.eval(x, value, index) {
-				s.restore(mark);
-				return false;
+				s.restore(mark)
+				return false
 			}
 		}
-		return true;
+		return true
 
 	case literal:
 		// write separator, if any
 		if s.hasOutput {
 			// not the first literal
 			if s.separator != nil {
-				sep := s.separator;	// save current separator
-				s.separator = nil;	// and disable it (avoid recursion)
-				mark := s.save();
+				sep := s.separator // save current separator
+				s.separator = nil  // and disable it (avoid recursion)
+				mark := s.save()
 				if !s.eval(sep, value, index) {
 					s.restore(mark)
 				}
-				s.separator = sep;	// enable it again
+				s.separator = sep // enable it again
 			}
 		}
-		s.hasOutput = true;
+		s.hasOutput = true
 		// write literal segments
 		for _, lit := range t {
 			if len(lit) > 1 && lit[0] == '%' {
@@ -511,7 +511,7 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {
 				s.Write(lit)
 			}
 		}
-		return true;	// a literal never evaluates to nil
+		return true // a literal never evaluates to nil
 
 	case *field:
 		// determine field value
@@ -526,13 +526,13 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {
 				if v.Len() <= index {
 					return false
 				}
-				value = v.Elem(index);
+				value = v.Elem(index)
 
 			case *reflect.SliceValue:
 				if v.IsNil() || v.Len() <= index {
 					return false
 				}
-				value = v.Elem(index);
+				value = v.Elem(index)
 
 			case *reflect.MapValue:
 				s.error("reflection support for maps incomplete")
@@ -541,13 +541,13 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {
 				if v.IsNil() {
 					return false
 				}
-				value = v.Elem();
+				value = v.Elem()
 
 			case *reflect.InterfaceValue:
 				if v.IsNil() {
 					return false
 				}
-				value = v.Elem();
+				value = v.Elem()
 
 			case *reflect.ChanValue:
 				s.error("reflection support for chans incomplete")
@@ -561,98 +561,98 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {
 
 		default:
 			// value is value of named field
-			var field reflect.Value;
+			var field reflect.Value
 			if sval, ok := value.(*reflect.StructValue); ok {
-				field = sval.FieldByName(t.fieldName);
+				field = sval.FieldByName(t.fieldName)
 				if field == nil {
 					// TODO consider just returning false in this case
 					s.error(fmt.Sprintf("error: no field `%s` in `%s`", t.fieldName, value.Type()))
 				}
 			}
-			value = field;
+			value = field
 		}
 
 		// determine rule
-		ruleName := t.ruleName;
+		ruleName := t.ruleName
 		if ruleName == "" {
 			// no alternate rule name, value type determines rule
 			ruleName = typename(value.Type())
 		}
-		fexpr = s.getFormat(ruleName);
+		fexpr = s.getFormat(ruleName)
 
-		mark := s.save();
+		mark := s.save()
 		if !s.eval(fexpr, value, index) {
-			s.restore(mark);
-			return false;
+			s.restore(mark)
+			return false
 		}
-		return true;
+		return true
 
 	case *group:
 		// remember current indentation
-		indentLen := s.indent.Len();
+		indentLen := s.indent.Len()
 
 		// update current indentation
-		mark := s.save();
-		s.eval(t.indent, value, index);
+		mark := s.save()
+		s.eval(t.indent, value, index)
 		// if the indentation evaluates to nil, the state's output buffer
 		// didn't change - either way it's ok to append the difference to
 		// the current identation
-		s.indent.Write(s.output.Bytes()[mark.outputLen:s.output.Len()]);
-		s.restore(mark);
+		s.indent.Write(s.output.Bytes()[mark.outputLen:s.output.Len()])
+		s.restore(mark)
 
 		// format group body
-		mark = s.save();
-		b := true;
+		mark = s.save()
+		b := true
 		if !s.eval(t.body, value, index) {
-			s.restore(mark);
-			b = false;
+			s.restore(mark)
+			b = false
 		}
 
 		// reset indentation
-		s.indent.Truncate(indentLen);
-		return b;
+		s.indent.Truncate(indentLen)
+		return b
 
 	case *option:
 		// evaluate the body and append the result to the state's output
 		// buffer unless the result is nil
-		mark := s.save();
-		if !s.eval(t.body, value, 0) {	// TODO is 0 index correct?
+		mark := s.save()
+		if !s.eval(t.body, value, 0) { // TODO is 0 index correct?
 			s.restore(mark)
 		}
-		return true;	// an option never evaluates to nil
+		return true // an option never evaluates to nil
 
 	case *repetition:
 		// evaluate the body and append the result to the state's output
 		// buffer until a result is nil
 		for i := 0; ; i++ {
-			mark := s.save();
+			mark := s.save()
 			// write separator, if any
 			if i > 0 && t.separator != nil {
 				// nil result from separator is ignored
-				mark := s.save();
+				mark := s.save()
 				if !s.eval(t.separator, value, i) {
 					s.restore(mark)
 				}
 			}
 			if !s.eval(t.body, value, i) {
-				s.restore(mark);
-				break;
+				s.restore(mark)
+				break
 			}
 		}
-		return true;	// a repetition never evaluates to nil
+		return true // a repetition never evaluates to nil
 
 	case *custom:
 		// invoke the custom formatter to obtain the result
-		mark := s.save();
+		mark := s.save()
 		if !t.fun(s, value.Interface(), t.ruleName) {
-			s.restore(mark);
-			return false;
+			s.restore(mark)
+			return false
 		}
-		return true;
+		return true
 	}
 
-	panic("unreachable");
-	return false;
+	panic("unreachable")
+	return false
 }
 
 
@@ -668,23 +668,23 @@ func (f Format) Eval(env Environment, args ...) ([]byte, os.Error) {
 		return nil, os.NewError("format is nil")
 	}
 
-	errors := make(chan os.Error);
-	s := newState(f, env, errors);
+	errors := make(chan os.Error)
+	s := newState(f, env, errors)
 
 	go func() {
-		value := reflect.NewValue(args).(*reflect.StructValue);
+		value := reflect.NewValue(args).(*reflect.StructValue)
 		for i := 0; i < value.NumField(); i++ {
-			fld := value.Field(i);
-			mark := s.save();
-			if !s.eval(s.getFormat(typename(fld.Type())), fld, 0) {	// TODO is 0 index correct?
+			fld := value.Field(i)
+			mark := s.save()
+			if !s.eval(s.getFormat(typename(fld.Type())), fld, 0) { // TODO is 0 index correct?
 				s.restore(mark)
 			}
 		}
-		errors <- nil;	// no errors
-	}();
+		errors <- nil // no errors
+	}()
 
-	err := <-errors;
-	return s.output.Bytes(), err;
+	err := <-errors
+	return s.output.Bytes(), err
 }
 
 
@@ -696,12 +696,12 @@ func (f Format) Eval(env Environment, args ...) ([]byte, os.Error) {
 // written and an os.Error, if any.
 //
 func (f Format) Fprint(w io.Writer, env Environment, args ...) (int, os.Error) {
-	data, err := f.Eval(env, args);
+	data, err := f.Eval(env, args)
 	if err != nil {
 		// TODO should we print partial result in case of error?
 		return 0, err
 	}
-	return w.Write(data);
+	return w.Write(data)
 }
 
 
@@ -720,10 +720,10 @@ func (f Format) Print(args ...) (int, os.Error) {
 // partially formatted result followed by an error message.
 //
 func (f Format) Sprint(args ...) string {
-	var buf bytes.Buffer;
-	_, err := f.Fprint(&buf, nil, args);
+	var buf bytes.Buffer
+	_, err := f.Fprint(&buf, nil, args)
 	if err != nil {
 		fmt.Fprintf(&buf, "--- Sprint(%s) failed: %v", fmt.Sprint(args), err)
 	}
-	return buf.String();
+	return buf.String()
 }
diff --git a/src/pkg/exp/datafmt/datafmt_test.go b/src/pkg/exp/datafmt/datafmt_test.go
index 61c0a972d4..d1c6222a0d 100644
--- a/src/pkg/exp/datafmt/datafmt_test.go
+++ b/src/pkg/exp/datafmt/datafmt_test.go
@@ -5,27 +5,27 @@
 package datafmt
 
 import (
-	"fmt";
-	"strings";
-	"testing";
+	"fmt"
+	"strings"
+	"testing"
 )
 
 
 func parse(t *testing.T, form string, fmap FormatterMap) Format {
-	f, err := Parse("", strings.Bytes(form), fmap);
+	f, err := Parse("", strings.Bytes(form), fmap)
 	if err != nil {
-		t.Errorf("Parse(%s): %v", form, err);
-		return nil;
+		t.Errorf("Parse(%s): %v", form, err)
+		return nil
 	}
-	return f;
+	return f
 }
 
 
 func verify(t *testing.T, f Format, expected string, args ...) {
 	if f == nil {
-		return	// allow other tests to run
+		return // allow other tests to run
 	}
-	result := f.Sprint(args);
+	result := f.Sprint(args)
 	if result != expected {
 		t.Errorf(
 			"result  : `%s`\nexpected: `%s`\n\n",
@@ -37,54 +37,54 @@ func verify(t *testing.T, f Format, expected string, args ...) {
 func formatter(s *State, value interface{}, rule_name string) bool {
 	switch rule_name {
 	case "/":
-		fmt.Fprintf(s, "%d %d %d", s.Pos().Line, s.LinePos().Column, s.Pos().Column);
-		return true;
+		fmt.Fprintf(s, "%d %d %d", s.Pos().Line, s.LinePos().Column, s.Pos().Column)
+		return true
 	case "blank":
-		s.Write([]byte{' '});
-		return true;
+		s.Write([]byte{' '})
+		return true
 	case "int":
 		if value.(int)&1 == 0 {
 			fmt.Fprint(s, "even ")
 		} else {
 			fmt.Fprint(s, "odd ")
 		}
-		return true;
+		return true
 	case "nil":
 		return false
 	case "testing.T":
-		s.Write(strings.Bytes("testing.T"));
-		return true;
+		s.Write(strings.Bytes("testing.T"))
+		return true
 	}
-	panic("unreachable");
-	return false;
+	panic("unreachable")
+	return false
 }
 
 
 func TestCustomFormatters(t *testing.T) {
-	fmap0 := FormatterMap{"/": formatter};
-	fmap1 := FormatterMap{"int": formatter, "blank": formatter, "nil": formatter};
-	fmap2 := FormatterMap{"testing.T": formatter};
+	fmap0 := FormatterMap{"/": formatter}
+	fmap1 := FormatterMap{"int": formatter, "blank": formatter, "nil": formatter}
+	fmap2 := FormatterMap{"testing.T": formatter}
 
-	f := parse(t, `int=`, fmap0);
-	verify(t, f, ``, 1, 2, 3);
+	f := parse(t, `int=`, fmap0)
+	verify(t, f, ``, 1, 2, 3)
 
-	f = parse(t, `int="#"`, nil);
-	verify(t, f, `###`, 1, 2, 3);
+	f = parse(t, `int="#"`, nil)
+	verify(t, f, `###`, 1, 2, 3)
 
-	f = parse(t, `int="#";string="%s"`, fmap0);
-	verify(t, f, "#1 0 1#1 0 7#1 0 13\n2 0 0foo2 0 8\n", 1, 2, 3, "\n", "foo", "\n");
+	f = parse(t, `int="#";string="%s"`, fmap0)
+	verify(t, f, "#1 0 1#1 0 7#1 0 13\n2 0 0foo2 0 8\n", 1, 2, 3, "\n", "foo", "\n")
 
-	f = parse(t, ``, fmap1);
-	verify(t, f, `even odd even odd `, 0, 1, 2, 3);
+	f = parse(t, ``, fmap1)
+	verify(t, f, `even odd even odd `, 0, 1, 2, 3)
 
-	f = parse(t, `/ =@:blank; float="#"`, fmap1);
-	verify(t, f, `# # #`, 0.0, 1.0, 2.0);
+	f = parse(t, `/ =@:blank; float="#"`, fmap1)
+	verify(t, f, `# # #`, 0.0, 1.0, 2.0)
 
-	f = parse(t, `float=@:nil`, fmap1);
-	verify(t, f, ``, 0.0, 1.0, 2.0);
+	f = parse(t, `float=@:nil`, fmap1)
+	verify(t, f, ``, 0.0, 1.0, 2.0)
 
-	f = parse(t, `testing "testing"; ptr=*`, fmap2);
-	verify(t, f, `testing.T`, t);
+	f = parse(t, `testing "testing"; ptr=*`, fmap2)
+	verify(t, f, `testing.T`, t)
 
 	// TODO needs more tests
 }
@@ -94,11 +94,11 @@ func TestCustomFormatters(t *testing.T) {
 // Formatting of basic and simple composite types
 
 func check(t *testing.T, form, expected string, args ...) {
-	f := parse(t, form, nil);
+	f := parse(t, form, nil)
 	if f == nil {
-		return	// allow other tests to run
+		return // allow other tests to run
 	}
-	result := f.Sprint(args);
+	result := f.Sprint(args)
 	if result != expected {
 		t.Errorf(
 			"format  : %s\nresult  : `%s`\nexpected: `%s`\n\n",
@@ -108,120 +108,120 @@ func check(t *testing.T, form, expected string, args ...) {
 
 
 func TestBasicTypes(t *testing.T) {
-	check(t, ``, ``);
-	check(t, `bool=":%v"`, `:true:false`, true, false);
-	check(t, `int="%b %d %o 0x%x"`, `101010 42 52 0x2a`, 42);
-
-	check(t, `int="%"`, `%`, 42);
-	check(t, `int="%%"`, `%`, 42);
-	check(t, `int="**%%**"`, `**%**`, 42);
-	check(t, `int="%%%%%%"`, `%%%`, 42);
-	check(t, `int="%%%d%%"`, `%42%`, 42);
-
-	const i = -42;
-	const is = `-42`;
-	check(t, `int  ="%d"`, is, i);
-	check(t, `int8 ="%d"`, is, int8(i));
-	check(t, `int16="%d"`, is, int16(i));
-	check(t, `int32="%d"`, is, int32(i));
-	check(t, `int64="%d"`, is, int64(i));
-
-	const u = 42;
-	const us = `42`;
-	check(t, `uint  ="%d"`, us, uint(u));
-	check(t, `uint8 ="%d"`, us, uint8(u));
-	check(t, `uint16="%d"`, us, uint16(u));
-	check(t, `uint32="%d"`, us, uint32(u));
-	check(t, `uint64="%d"`, us, uint64(u));
-
-	const f = 3.141592;
-	const fs = `3.141592`;
-	check(t, `float  ="%g"`, fs, f);
-	check(t, `float32="%g"`, fs, float32(f));
-	check(t, `float64="%g"`, fs, float64(f));
+	check(t, ``, ``)
+	check(t, `bool=":%v"`, `:true:false`, true, false)
+	check(t, `int="%b %d %o 0x%x"`, `101010 42 52 0x2a`, 42)
+
+	check(t, `int="%"`, `%`, 42)
+	check(t, `int="%%"`, `%`, 42)
+	check(t, `int="**%%**"`, `**%**`, 42)
+	check(t, `int="%%%%%%"`, `%%%`, 42)
+	check(t, `int="%%%d%%"`, `%42%`, 42)
+
+	const i = -42
+	const is = `-42`
+	check(t, `int  ="%d"`, is, i)
+	check(t, `int8 ="%d"`, is, int8(i))
+	check(t, `int16="%d"`, is, int16(i))
+	check(t, `int32="%d"`, is, int32(i))
+	check(t, `int64="%d"`, is, int64(i))
+
+	const u = 42
+	const us = `42`
+	check(t, `uint  ="%d"`, us, uint(u))
+	check(t, `uint8 ="%d"`, us, uint8(u))
+	check(t, `uint16="%d"`, us, uint16(u))
+	check(t, `uint32="%d"`, us, uint32(u))
+	check(t, `uint64="%d"`, us, uint64(u))
+
+	const f = 3.141592
+	const fs = `3.141592`
+	check(t, `float  ="%g"`, fs, f)
+	check(t, `float32="%g"`, fs, float32(f))
+	check(t, `float64="%g"`, fs, float64(f))
 }
 
 
 func TestArrayTypes(t *testing.T) {
-	var a0 [10]int;
-	check(t, `array="array";`, `array`, a0);
+	var a0 [10]int
+	check(t, `array="array";`, `array`, a0)
 
-	a1 := [...]int{1, 2, 3};
-	check(t, `array="array";`, `array`, a1);
-	check(t, `array={*}; int="%d";`, `123`, a1);
-	check(t, `array={* / ", "}; int="%d";`, `1, 2, 3`, a1);
-	check(t, `array={* / *}; int="%d";`, `12233`, a1);
+	a1 := [...]int{1, 2, 3}
+	check(t, `array="array";`, `array`, a1)
+	check(t, `array={*}; int="%d";`, `123`, a1)
+	check(t, `array={* / ", "}; int="%d";`, `1, 2, 3`, a1)
+	check(t, `array={* / *}; int="%d";`, `12233`, a1)
 
-	a2 := []interface{}{42, "foo", 3.14};
-	check(t, `array={* / ", "}; interface=*; string="bar"; default="%v";`, `42, bar, 3.14`, a2);
+	a2 := []interface{}{42, "foo", 3.14}
+	check(t, `array={* / ", "}; interface=*; string="bar"; default="%v";`, `42, bar, 3.14`, a2)
 }
 
 
 func TestChanTypes(t *testing.T) {
-	var c0 chan int;
-	check(t, `chan="chan"`, `chan`, c0);
+	var c0 chan int
+	check(t, `chan="chan"`, `chan`, c0)
 
-	c1 := make(chan int);
-	go func() { c1 <- 42 }();
-	check(t, `chan="chan"`, `chan`, c1);
+	c1 := make(chan int)
+	go func() { c1 <- 42 }()
+	check(t, `chan="chan"`, `chan`, c1)
 	// check(t, `chan=*`, `42`, c1);  // reflection support for chans incomplete
 }
 
 
 func TestFuncTypes(t *testing.T) {
-	var f0 func() int;
-	check(t, `func="func"`, `func`, f0);
+	var f0 func() int
+	check(t, `func="func"`, `func`, f0)
 
-	f1 := func() int { return 42 };
-	check(t, `func="func"`, `func`, f1);
+	f1 := func() int { return 42 }
+	check(t, `func="func"`, `func`, f1)
 	// check(t, `func=*`, `42`, f1);  // reflection support for funcs incomplete
 }
 
 
 func TestInterfaceTypes(t *testing.T) {
 	var i0 interface{}
-	check(t, `interface="interface"`, `interface`, i0);
+	check(t, `interface="interface"`, `interface`, i0)
 
-	i0 = "foo";
-	check(t, `interface="interface"`, `interface`, i0);
-	check(t, `interface=*; string="%s"`, `foo`, i0);
+	i0 = "foo"
+	check(t, `interface="interface"`, `interface`, i0)
+	check(t, `interface=*; string="%s"`, `foo`, i0)
 }
 
 
 func TestMapTypes(t *testing.T) {
-	var m0 map[string]int;
-	check(t, `map="map"`, `map`, m0);
+	var m0 map[string]int
+	check(t, `map="map"`, `map`, m0)
 
-	m1 := map[string]int{};
-	check(t, `map="map"`, `map`, m1);
+	m1 := map[string]int{}
+	check(t, `map="map"`, `map`, m1)
 	// check(t, `map=*`, ``, m1);  // reflection support for maps incomplete
 }
 
 
 func TestPointerTypes(t *testing.T) {
-	var p0 *int;
-	check(t, `ptr="ptr"`, `ptr`, p0);
-	check(t, `ptr=*`, ``, p0);
-	check(t, `ptr=*|"nil"`, `nil`, p0);
-
-	x := 99991;
-	p1 := &x;
-	check(t, `ptr="ptr"`, `ptr`, p1);
-	check(t, `ptr=*; int="%d"`, `99991`, p1);
+	var p0 *int
+	check(t, `ptr="ptr"`, `ptr`, p0)
+	check(t, `ptr=*`, ``, p0)
+	check(t, `ptr=*|"nil"`, `nil`, p0)
+
+	x := 99991
+	p1 := &x
+	check(t, `ptr="ptr"`, `ptr`, p1)
+	check(t, `ptr=*; int="%d"`, `99991`, p1)
 }
 
 
 func TestDefaultRule(t *testing.T) {
-	check(t, `default="%v"`, `42foo3.14`, 42, "foo", 3.14);
-	check(t, `default="%v"; int="%x"`, `abcdef`, 10, 11, 12, 13, 14, 15);
-	check(t, `default="%v"; int="%x"`, `ab**ef`, 10, 11, "**", 14, 15);
-	check(t, `default="%x"; int=@:default`, `abcdef`, 10, 11, 12, 13, 14, 15);
+	check(t, `default="%v"`, `42foo3.14`, 42, "foo", 3.14)
+	check(t, `default="%v"; int="%x"`, `abcdef`, 10, 11, 12, 13, 14, 15)
+	check(t, `default="%v"; int="%x"`, `ab**ef`, 10, 11, "**", 14, 15)
+	check(t, `default="%x"; int=@:default`, `abcdef`, 10, 11, 12, 13, 14, 15)
 }
 
 
 func TestGlobalSeparatorRule(t *testing.T) {
-	check(t, `int="%d"; / ="-"`, `1-2-3-4`, 1, 2, 3, 4);
-	check(t, `int="%x%x"; / ="*"`, `aa*aa`, 10, 10);
+	check(t, `int="%d"; / ="-"`, `1-2-3-4`, 1, 2, 3, 4)
+	check(t, `int="%x%x"; / ="*"`, `aa*aa`, 10, 10)
 }
 
 
@@ -229,22 +229,22 @@ func TestGlobalSeparatorRule(t *testing.T) {
 // Formatting of a struct
 
 type T1 struct {
-	a int;
+	a int
 }
 
 const F1 = `datafmt "datafmt";` +
 	`int = "%d";` +
 	`datafmt.T1 = "<" a ">";`
 
-func TestStruct1(t *testing.T)	{ check(t, F1, "<42>", T1{42}) }
+func TestStruct1(t *testing.T) { check(t, F1, "<42>", T1{42}) }
 
 
 // ----------------------------------------------------------------------------
 // Formatting of a struct with an optional field (ptr)
 
 type T2 struct {
-	s	string;
-	p	*T1;
+	s string
+	p *T1
 }
 
 const F2a = F1 +
@@ -258,9 +258,9 @@ const F2b = F1 +
 	`datafmt.T2 = s ("-" p "-" | "empty");`
 
 func TestStruct2(t *testing.T) {
-	check(t, F2a, "foo", T2{"foo", nil});
-	check(t, F2a, "bar-<17>-", T2{"bar", &T1{17}});
-	check(t, F2b, "fooempty", T2{"foo", nil});
+	check(t, F2a, "foo", T2{"foo", nil})
+	check(t, F2a, "bar-<17>-", T2{"bar", &T1{17}})
+	check(t, F2b, "fooempty", T2{"foo", nil})
 }
 
 
@@ -268,8 +268,8 @@ func TestStruct2(t *testing.T) {
 // Formatting of a struct with a repetitive field (slice)
 
 type T3 struct {
-	s	string;
-	a	[]int;
+	s string
+	a []int
 }
 
 const F3a = `datafmt "datafmt";` +
@@ -286,10 +286,10 @@ const F3b = `datafmt "datafmt";` +
 	`datafmt.T3 = s [a:empty ": " {a / "-"}]`
 
 func TestStruct3(t *testing.T) {
-	check(t, F3a, "foo", T3{"foo", nil});
-	check(t, F3a, "foo 00, 11, 22", T3{"foo", []int{0, 1, 2}});
-	check(t, F3b, "bar", T3{"bar", nil});
-	check(t, F3b, "bal: 2-3-5", T3{"bal", []int{2, 3, 5}});
+	check(t, F3a, "foo", T3{"foo", nil})
+	check(t, F3a, "foo 00, 11, 22", T3{"foo", []int{0, 1, 2}})
+	check(t, F3b, "bar", T3{"bar", nil})
+	check(t, F3b, "bal: 2-3-5", T3{"bal", []int{2, 3, 5}})
 }
 
 
@@ -297,8 +297,8 @@ func TestStruct3(t *testing.T) {
 // Formatting of a struct with alternative field
 
 type T4 struct {
-	x	*int;
-	a	[]int;
+	x *int
+	a []int
 }
 
 const F4a = `datafmt "datafmt";` +
@@ -318,11 +318,11 @@ const F4b = `datafmt "datafmt";` +
 	`datafmt.T4 = "<" (a:empty {a / ", "} | "-") ">" `
 
 func TestStruct4(t *testing.T) {
-	x := 7;
-	check(t, F4a, "<->", T4{nil, nil});
-	check(t, F4a, "<7>", T4{&x, nil});
-	check(t, F4b, "<->", T4{nil, nil});
-	check(t, F4b, "<2, 3, 7>", T4{nil, []int{2, 3, 7}});
+	x := 7
+	check(t, F4a, "<->", T4{nil, nil})
+	check(t, F4a, "<7>", T4{&x, nil})
+	check(t, F4b, "<->", T4{nil, nil})
+	check(t, F4b, "<2, 3, 7>", T4{nil, []int{2, 3, 7}})
 }
 
 
@@ -330,8 +330,8 @@ func TestStruct4(t *testing.T) {
 // Formatting a struct (documentation example)
 
 type Point struct {
-	name	string;
-	x, y	int;
+	name string
+	x, y int
 }
 
 const FPoint = `datafmt "datafmt";` +
@@ -341,8 +341,8 @@ const FPoint = `datafmt "datafmt";` +
 	`datafmt.Point = name "{" x ", " y:hexInt "}";`
 
 func TestStructPoint(t *testing.T) {
-	p := Point{"foo", 3, 15};
-	check(t, FPoint, "---foo---{3, 0xf}", p);
+	p := Point{"foo", 3, 15}
+	check(t, FPoint, "---foo---{3, 0xf}", p)
 }
 
 
@@ -352,7 +352,7 @@ func TestStructPoint(t *testing.T) {
 const FSlice = `int = "%b";` +
 	`array = { * / ", " }`
 
-func TestSlice(t *testing.T)	{ check(t, FSlice, "10, 11, 101, 111", []int{2, 3, 5, 7}) }
+func TestSlice(t *testing.T) { check(t, FSlice, "10, 11, 101, 111", []int{2, 3, 5, 7}) }
 
 
 // TODO add more tests
diff --git a/src/pkg/exp/datafmt/parser.go b/src/pkg/exp/datafmt/parser.go
index c8144d9f2f..6537716745 100644
--- a/src/pkg/exp/datafmt/parser.go
+++ b/src/pkg/exp/datafmt/parser.go
@@ -5,83 +5,83 @@
 package datafmt
 
 import (
-	"container/vector";
-	"go/scanner";
-	"go/token";
-	"os";
-	"strconv";
-	"strings";
+	"container/vector"
+	"go/scanner"
+	"go/token"
+	"os"
+	"strconv"
+	"strings"
 )
 
 // ----------------------------------------------------------------------------
 // Parsing
 
 type parser struct {
-	scanner.ErrorVector;
-	scanner	scanner.Scanner;
-	pos	token.Position;	// token position
-	tok	token.Token;	// one token look-ahead
-	lit	[]byte;		// token literal
-
-	packs	map[string]string;	// PackageName -> ImportPath
-	rules	map[string]expr;	// RuleName -> Expression
+	scanner.ErrorVector
+	scanner scanner.Scanner
+	pos     token.Position // token position
+	tok     token.Token    // one token look-ahead
+	lit     []byte         // token literal
+
+	packs map[string]string // PackageName -> ImportPath
+	rules map[string]expr   // RuleName -> Expression
 }
 
 
 func (p *parser) next() {
-	p.pos, p.tok, p.lit = p.scanner.Scan();
+	p.pos, p.tok, p.lit = p.scanner.Scan()
 	switch p.tok {
 	case token.CHAN, token.FUNC, token.INTERFACE, token.MAP, token.STRUCT:
 		// Go keywords for composite types are type names
 		// returned by reflect. Accept them as identifiers.
-		p.tok = token.IDENT	// p.lit is already set correctly
+		p.tok = token.IDENT // p.lit is already set correctly
 	}
 }
 
 
 func (p *parser) init(filename string, src []byte) {
-	p.ErrorVector.Reset();
-	p.scanner.Init(filename, src, p, scanner.AllowIllegalChars);	// return '@' as token.ILLEGAL w/o error message
-	p.next();							// initializes pos, tok, lit
-	p.packs = make(map[string]string);
-	p.rules = make(map[string]expr);
+	p.ErrorVector.Reset()
+	p.scanner.Init(filename, src, p, scanner.AllowIllegalChars) // return '@' as token.ILLEGAL w/o error message
+	p.next()                                                    // initializes pos, tok, lit
+	p.packs = make(map[string]string)
+	p.rules = make(map[string]expr)
 }
 
 
 func (p *parser) errorExpected(pos token.Position, msg string) {
-	msg = "expected " + msg;
+	msg = "expected " + msg
 	if pos.Offset == p.pos.Offset {
 		// the error happened at the current position;
 		// make the error message more specific
-		msg += ", found '" + p.tok.String() + "'";
+		msg += ", found '" + p.tok.String() + "'"
 		if p.tok.IsLiteral() {
 			msg += " " + string(p.lit)
 		}
 	}
-	p.Error(pos, msg);
+	p.Error(pos, msg)
 }
 
 
 func (p *parser) expect(tok token.Token) token.Position {
-	pos := p.pos;
+	pos := p.pos
 	if p.tok != tok {
 		p.errorExpected(pos, "'"+tok.String()+"'")
 	}
-	p.next();	// make progress in any case
-	return pos;
+	p.next() // make progress in any case
+	return pos
 }
 
 
 func (p *parser) parseIdentifier() string {
-	name := string(p.lit);
-	p.expect(token.IDENT);
-	return name;
+	name := string(p.lit)
+	p.expect(token.IDENT)
+	return name
 }
 
 
 func (p *parser) parseTypeName() (string, bool) {
-	pos := p.pos;
-	name, isIdent := p.parseIdentifier(), true;
+	pos := p.pos
+	name, isIdent := p.parseIdentifier(), true
 	if p.tok == token.PERIOD {
 		// got a package name, lookup package
 		if importPath, found := p.packs[name]; found {
@@ -89,10 +89,10 @@ func (p *parser) parseTypeName() (string, bool) {
 		} else {
 			p.Error(pos, "package not declared: "+name)
 		}
-		p.next();
-		name, isIdent = name+"."+p.parseIdentifier(), false;
+		p.next()
+		name, isIdent = name+"."+p.parseIdentifier(), false
 	}
-	return name, isIdent;
+	return name, isIdent
 }
 
 
@@ -102,99 +102,99 @@ func (p *parser) parseTypeName() (string, bool) {
 // single identifier only (and thus could be a package name).
 //
 func (p *parser) parseRuleName() (string, bool) {
-	name, isIdent := "", false;
+	name, isIdent := "", false
 	switch p.tok {
 	case token.IDENT:
 		name, isIdent = p.parseTypeName()
 	case token.DEFAULT:
-		name = "default";
-		p.next();
+		name = "default"
+		p.next()
 	case token.QUO:
-		name = "/";
-		p.next();
+		name = "/"
+		p.next()
 	default:
-		p.errorExpected(p.pos, "rule name");
-		p.next();	// make progress in any case
+		p.errorExpected(p.pos, "rule name")
+		p.next() // make progress in any case
 	}
-	return name, isIdent;
+	return name, isIdent
 }
 
 
 func (p *parser) parseString() string {
-	s := "";
+	s := ""
 	if p.tok == token.STRING {
-		s, _ = strconv.Unquote(string(p.lit));
+		s, _ = strconv.Unquote(string(p.lit))
 		// Unquote may fail with an error, but only if the scanner found
 		// an illegal string in the first place. In this case the error
 		// has already been reported.
-		p.next();
-		return s;
+		p.next()
+		return s
 	} else {
 		p.expect(token.STRING)
 	}
-	return s;
+	return s
 }
 
 
 func (p *parser) parseLiteral() literal {
-	s := strings.Bytes(p.parseString());
+	s := strings.Bytes(p.parseString())
 
 	// A string literal may contain %-format specifiers. To simplify
 	// and speed up printing of the literal, split it into segments
 	// that start with "%" possibly followed by a last segment that
 	// starts with some other character.
-	var list vector.Vector;
-	i0 := 0;
+	var list vector.Vector
+	i0 := 0
 	for i := 0; i < len(s); i++ {
 		if s[i] == '%' && i+1 < len(s) {
 			// the next segment starts with a % format
 			if i0 < i {
 				// the current segment is not empty, split it off
-				list.Push(s[i0:i]);
-				i0 = i;
+				list.Push(s[i0:i])
+				i0 = i
 			}
-			i++;	// skip %; let loop skip over char after %
+			i++ // skip %; let loop skip over char after %
 		}
 	}
 	// the final segment may start with any character
 	// (it is empty iff the string is empty)
-	list.Push(s[i0:]);
+	list.Push(s[i0:])
 
 	// convert list into a literal
-	lit := make(literal, list.Len());
+	lit := make(literal, list.Len())
 	for i := 0; i < list.Len(); i++ {
 		lit[i] = list.At(i).([]byte)
 	}
 
-	return lit;
+	return lit
 }
 
 
 func (p *parser) parseField() expr {
-	var fname string;
+	var fname string
 	switch p.tok {
 	case token.ILLEGAL:
 		if string(p.lit) != "@" {
 			return nil
 		}
-		fname = "@";
-		p.next();
+		fname = "@"
+		p.next()
 	case token.MUL:
-		fname = "*";
-		p.next();
+		fname = "*"
+		p.next()
 	case token.IDENT:
 		fname = p.parseIdentifier()
 	default:
 		return nil
 	}
 
-	var ruleName string;
+	var ruleName string
 	if p.tok == token.COLON {
-		p.next();
-		ruleName, _ = p.parseRuleName();
+		p.next()
+		ruleName, _ = p.parseRuleName()
 	}
 
-	return &field{fname, ruleName};
+	return &field{fname, ruleName}
 }
 
 
@@ -204,40 +204,40 @@ func (p *parser) parseOperand() (x expr) {
 		x = p.parseLiteral()
 
 	case token.LPAREN:
-		p.next();
-		x = p.parseExpression();
+		p.next()
+		x = p.parseExpression()
 		if p.tok == token.SHR {
-			p.next();
-			x = &group{x, p.parseExpression()};
+			p.next()
+			x = &group{x, p.parseExpression()}
 		}
-		p.expect(token.RPAREN);
+		p.expect(token.RPAREN)
 
 	case token.LBRACK:
-		p.next();
-		x = &option{p.parseExpression()};
-		p.expect(token.RBRACK);
+		p.next()
+		x = &option{p.parseExpression()}
+		p.expect(token.RBRACK)
 
 	case token.LBRACE:
-		p.next();
-		x = p.parseExpression();
-		var div expr;
+		p.next()
+		x = p.parseExpression()
+		var div expr
 		if p.tok == token.QUO {
-			p.next();
-			div = p.parseExpression();
+			p.next()
+			div = p.parseExpression()
 		}
-		x = &repetition{x, div};
-		p.expect(token.RBRACE);
+		x = &repetition{x, div}
+		p.expect(token.RBRACE)
 
 	default:
-		x = p.parseField()	// may be nil
+		x = p.parseField() // may be nil
 	}
 
-	return x;
+	return x
 }
 
 
 func (p *parser) parseSequence() expr {
-	var list vector.Vector;
+	var list vector.Vector
 
 	for x := p.parseOperand(); x != nil; x = p.parseOperand() {
 		list.Push(x)
@@ -252,26 +252,26 @@ func (p *parser) parseSequence() expr {
 	}
 
 	// convert list into a sequence
-	seq := make(sequence, list.Len());
+	seq := make(sequence, list.Len())
 	for i := 0; i < list.Len(); i++ {
 		seq[i] = list.At(i).(expr)
 	}
-	return seq;
+	return seq
 }
 
 
 func (p *parser) parseExpression() expr {
-	var list vector.Vector;
+	var list vector.Vector
 
 	for {
-		x := p.parseSequence();
+		x := p.parseSequence()
 		if x != nil {
 			list.Push(x)
 		}
 		if p.tok != token.OR {
 			break
 		}
-		p.next();
+		p.next()
 	}
 
 	// no need for an alternatives if list.Len() < 2
@@ -283,23 +283,23 @@ func (p *parser) parseExpression() expr {
 	}
 
 	// convert list into a alternatives
-	alt := make(alternatives, list.Len());
+	alt := make(alternatives, list.Len())
 	for i := 0; i < list.Len(); i++ {
 		alt[i] = list.At(i).(expr)
 	}
-	return alt;
+	return alt
 }
 
 
 func (p *parser) parseFormat() {
 	for p.tok != token.EOF {
-		pos := p.pos;
+		pos := p.pos
 
-		name, isIdent := p.parseRuleName();
+		name, isIdent := p.parseRuleName()
 		switch p.tok {
 		case token.STRING:
 			// package declaration
-			importPath := p.parseString();
+			importPath := p.parseString()
 
 			// add package declaration
 			if !isIdent {
@@ -312,8 +312,8 @@ func (p *parser) parseFormat() {
 
 		case token.ASSIGN:
 			// format rule
-			p.next();
-			x := p.parseExpression();
+			p.next()
+			x := p.parseExpression()
 
 			// add rule
 			if _, found := p.rules[name]; !found {
@@ -323,8 +323,8 @@ func (p *parser) parseFormat() {
 			}
 
 		default:
-			p.errorExpected(p.pos, "package declaration or format rule");
-			p.next();	// make progress in any case
+			p.errorExpected(p.pos, "package declaration or format rule")
+			p.next() // make progress in any case
 		}
 
 		if p.tok == token.SEMICOLON {
@@ -333,23 +333,23 @@ func (p *parser) parseFormat() {
 			break
 		}
 	}
-	p.expect(token.EOF);
+	p.expect(token.EOF)
 }
 
 
 func remap(p *parser, name string) string {
-	i := strings.Index(name, ".");
+	i := strings.Index(name, ".")
 	if i >= 0 {
-		packageName, suffix := name[0:i], name[i:];
+		packageName, suffix := name[0:i], name[i:]
 		// lookup package
 		if importPath, found := p.packs[packageName]; found {
 			name = importPath + suffix
 		} else {
-			var invalidPos token.Position;
-			p.Error(invalidPos, "package not declared: "+packageName);
+			var invalidPos token.Position
+			p.Error(invalidPos, "package not declared: "+packageName)
 		}
 	}
-	return name;
+	return name
 }
 
 
@@ -360,20 +360,20 @@ func remap(p *parser, name string) string {
 //
 func Parse(filename string, src []byte, fmap FormatterMap) (Format, os.Error) {
 	// parse source
-	var p parser;
-	p.init(filename, src);
-	p.parseFormat();
+	var p parser
+	p.init(filename, src)
+	p.parseFormat()
 
 	// add custom formatters, if any
 	for name, form := range fmap {
-		name = remap(&p, name);
+		name = remap(&p, name)
 		if _, found := p.rules[name]; !found {
 			p.rules[name] = &custom{name, form}
 		} else {
-			var invalidPos token.Position;
-			p.Error(invalidPos, "formatter already declared: "+name);
+			var invalidPos token.Position
+			p.Error(invalidPos, "formatter already declared: "+name)
 		}
 	}
 
-	return p.rules, p.GetError(scanner.NoMultiples);
+	return p.rules, p.GetError(scanner.NoMultiples)
 }
diff --git a/src/pkg/exp/draw/arith.go b/src/pkg/exp/draw/arith.go
index 59830bba5a..6ed1c4a5a5 100644
--- a/src/pkg/exp/draw/arith.go
+++ b/src/pkg/exp/draw/arith.go
@@ -6,7 +6,7 @@ package draw
 
 // A Point is an X, Y coordinate pair.
 type Point struct {
-	X, Y int;
+	X, Y int
 }
 
 // ZP is the zero Point.
@@ -14,35 +14,35 @@ var ZP Point
 
 // A Rectangle contains the Points with Min.X <= X < Max.X, Min.Y <= Y < Max.Y.
 type Rectangle struct {
-	Min, Max Point;
+	Min, Max Point
 }
 
 // ZR is the zero Rectangle.
 var ZR Rectangle
 
 // Pt is shorthand for Point{X, Y}.
-func Pt(X, Y int) Point	{ return Point{X, Y} }
+func Pt(X, Y int) Point { return Point{X, Y} }
 
 // Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}.
-func Rect(x0, y0, x1, y1 int) Rectangle	{ return Rectangle{Point{x0, y0}, Point{x1, y1}} }
+func Rect(x0, y0, x1, y1 int) Rectangle { return Rectangle{Point{x0, y0}, Point{x1, y1}} }
 
 // Rpt is shorthand for Rectangle{min, max}.
-func Rpt(min, max Point) Rectangle	{ return Rectangle{min, max} }
+func Rpt(min, max Point) Rectangle { return Rectangle{min, max} }
 
 // Add returns the sum of p and q: Pt(p.X+q.X, p.Y+q.Y).
-func (p Point) Add(q Point) Point	{ return Point{p.X + q.X, p.Y + q.Y} }
+func (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} }
 
 // Sub returns the difference of p and q: Pt(p.X-q.X, p.Y-q.Y).
-func (p Point) Sub(q Point) Point	{ return Point{p.X - q.X, p.Y - q.Y} }
+func (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} }
 
 // Mul returns p scaled by k: Pt(p.X*k p.Y*k).
-func (p Point) Mul(k int) Point	{ return Point{p.X * k, p.Y * k} }
+func (p Point) Mul(k int) Point { return Point{p.X * k, p.Y * k} }
 
 // Div returns p divided by k: Pt(p.X/k, p.Y/k).
-func (p Point) Div(k int) Point	{ return Point{p.X / k, p.Y / k} }
+func (p Point) Div(k int) Point { return Point{p.X / k, p.Y / k} }
 
 // Eq returns true if p and q are equal.
-func (p Point) Eq(q Point) bool	{ return p.X == q.X && p.Y == q.Y }
+func (p Point) Eq(q Point) bool { return p.X == q.X && p.Y == q.Y }
 
 // Inset returns the rectangle r inset by n: Rect(r.Min.X+n, r.Min.Y+n, r.Max.X-n, r.Max.Y-n).
 func (r Rectangle) Inset(n int) Rectangle {
@@ -50,10 +50,10 @@ func (r Rectangle) Inset(n int) Rectangle {
 }
 
 // Add returns the rectangle r translated by p: Rpt(r.Min.Add(p), r.Max.Add(p)).
-func (r Rectangle) Add(p Point) Rectangle	{ return Rectangle{r.Min.Add(p), r.Max.Add(p)} }
+func (r Rectangle) Add(p Point) Rectangle { return Rectangle{r.Min.Add(p), r.Max.Add(p)} }
 
 // Sub returns the rectangle r translated by -p: Rpt(r.Min.Sub(p), r.Max.Sub(p)).
-func (r Rectangle) Sub(p Point) Rectangle	{ return Rectangle{r.Min.Sub(p), r.Max.Sub(p)} }
+func (r Rectangle) Sub(p Point) Rectangle { return Rectangle{r.Min.Sub(p), r.Max.Sub(p)} }
 
 // Canon returns a canonical version of r: the returned rectangle
 // has Min.X <= Max.X and Min.Y <= Max.Y.
@@ -64,7 +64,7 @@ func (r Rectangle) Canon() Rectangle {
 	if r.Max.Y < r.Min.Y {
 		r.Max.Y = r.Min.Y
 	}
-	return r;
+	return r
 }
 
 // Overlaps returns true if r and r1 cross; that is, it returns true if they share any point.
@@ -74,7 +74,7 @@ func (r Rectangle) Overlaps(r1 Rectangle) bool {
 }
 
 // Empty retruns true if r contains no points.
-func (r Rectangle) Empty() bool	{ return r.Max.X <= r.Min.X || r.Max.Y <= r.Min.Y }
+func (r Rectangle) Empty() bool { return r.Max.X <= r.Min.X || r.Max.Y <= r.Min.Y }
 
 // InRect returns true if all the points in r are also in r1.
 func (r Rectangle) In(r1 Rectangle) bool {
@@ -85,7 +85,7 @@ func (r Rectangle) In(r1 Rectangle) bool {
 		return false
 	}
 	return r1.Min.X <= r.Min.X && r.Max.X <= r1.Max.X &&
-		r1.Min.Y <= r.Min.Y && r.Max.Y <= r1.Max.Y;
+		r1.Min.Y <= r.Min.Y && r.Max.Y <= r1.Max.Y
 }
 
 // Combine returns the smallest rectangle containing all points from r and from r1.
@@ -108,7 +108,7 @@ func (r Rectangle) Combine(r1 Rectangle) Rectangle {
 	if r.Max.Y < r1.Max.Y {
 		r.Max.Y = r1.Max.Y
 	}
-	return r;
+	return r
 }
 
 // Clip returns the largest rectangle containing only points shared by r and r1.
@@ -131,11 +131,11 @@ func (r Rectangle) Clip(r1 Rectangle) Rectangle {
 	if r.Max.Y > r1.Max.Y {
 		r.Max.Y = r1.Max.Y
 	}
-	return r;
+	return r
 }
 
 // Dx returns the width of the rectangle r: r.Max.X - r.Min.X.
-func (r Rectangle) Dx() int	{ return r.Max.X - r.Min.X }
+func (r Rectangle) Dx() int { return r.Max.X - r.Min.X }
 
 // Dy returns the width of the rectangle r: r.Max.Y - r.Min.Y.
-func (r Rectangle) Dy() int	{ return r.Max.Y - r.Min.Y }
+func (r Rectangle) Dy() int { return r.Max.Y - r.Min.Y }
diff --git a/src/pkg/exp/draw/color.go b/src/pkg/exp/draw/color.go
index 1ebb3a21b0..f0e7597092 100644
--- a/src/pkg/exp/draw/color.go
+++ b/src/pkg/exp/draw/color.go
@@ -19,91 +19,91 @@ var _ image.Color = Black
 var _ image.Image = Black
 
 var (
-	Opaque		Color	= 0xFFFFFFFF;
-	Transparent	Color	= 0x00000000;
-	Black		Color	= 0x000000FF;
-	White		Color	= 0xFFFFFFFF;
-	Red		Color	= 0xFF0000FF;
-	Green		Color	= 0x00FF00FF;
-	Blue		Color	= 0x0000FFFF;
-	Cyan		Color	= 0x00FFFFFF;
-	Magenta		Color	= 0xFF00FFFF;
-	Yellow		Color	= 0xFFFF00FF;
-	PaleYellow	Color	= 0xFFFFAAFF;
-	DarkYellow	Color	= 0xEEEE9EFF;
-	DarkGreen	Color	= 0x448844FF;
-	PaleGreen	Color	= 0xAAFFAAFF;
-	MedGreen	Color	= 0x88CC88FF;
-	DarkBlue	Color	= 0x000055FF;
-	PaleBlueGreen	Color	= 0xAAFFFFFF;
-	PaleBlue	Color	= 0x0000BBFF;
-	BlueGreen	Color	= 0x008888FF;
-	GreyGreen	Color	= 0x55AAAAFF;
-	PaleGreyGreen	Color	= 0x9EEEEEFF;
-	YellowGreen	Color	= 0x99994CFF;
-	MedBlue		Color	= 0x000099FF;
-	GreyBlue	Color	= 0x005DBBFF;
-	PaleGreyBlue	Color	= 0x4993DDFF;
-	PurpleBlue	Color	= 0x8888CCFF;
+	Opaque        Color = 0xFFFFFFFF
+	Transparent   Color = 0x00000000
+	Black         Color = 0x000000FF
+	White         Color = 0xFFFFFFFF
+	Red           Color = 0xFF0000FF
+	Green         Color = 0x00FF00FF
+	Blue          Color = 0x0000FFFF
+	Cyan          Color = 0x00FFFFFF
+	Magenta       Color = 0xFF00FFFF
+	Yellow        Color = 0xFFFF00FF
+	PaleYellow    Color = 0xFFFFAAFF
+	DarkYellow    Color = 0xEEEE9EFF
+	DarkGreen     Color = 0x448844FF
+	PaleGreen     Color = 0xAAFFAAFF
+	MedGreen      Color = 0x88CC88FF
+	DarkBlue      Color = 0x000055FF
+	PaleBlueGreen Color = 0xAAFFFFFF
+	PaleBlue      Color = 0x0000BBFF
+	BlueGreen     Color = 0x008888FF
+	GreyGreen     Color = 0x55AAAAFF
+	PaleGreyGreen Color = 0x9EEEEEFF
+	YellowGreen   Color = 0x99994CFF
+	MedBlue       Color = 0x000099FF
+	GreyBlue      Color = 0x005DBBFF
+	PaleGreyBlue  Color = 0x4993DDFF
+	PurpleBlue    Color = 0x8888CCFF
 )
 
 func (c Color) RGBA() (r, g, b, a uint32) {
-	x := uint32(c);
-	r, g, b, a = x>>24, (x>>16)&0xFF, (x>>8)&0xFF, x&0xFF;
-	r |= r << 8;
-	r |= r << 16;
-	g |= g << 8;
-	g |= g << 16;
-	b |= b << 8;
-	b |= b << 16;
-	a |= a << 8;
-	a |= a << 16;
-	return;
+	x := uint32(c)
+	r, g, b, a = x>>24, (x>>16)&0xFF, (x>>8)&0xFF, x&0xFF
+	r |= r << 8
+	r |= r << 16
+	g |= g << 8
+	g |= g << 16
+	b |= b << 8
+	b |= b << 16
+	a |= a << 8
+	a |= a << 16
+	return
 }
 
 // SetAlpha returns the color obtained by changing
 // c's alpha value to a and scaling r, g, and b appropriately.
 func (c Color) SetAlpha(a uint8) Color {
-	r, g, b, oa := c>>24, (c>>16)&0xFF, (c>>8)&0xFF, c&0xFF;
+	r, g, b, oa := c>>24, (c>>16)&0xFF, (c>>8)&0xFF, c&0xFF
 	if oa == 0 {
 		return 0
 	}
-	r = r * Color(a) / oa;
+	r = r * Color(a) / oa
 	if r < 0 {
 		r = 0
 	}
 	if r > 0xFF {
 		r = 0xFF
 	}
-	g = g * Color(a) / oa;
+	g = g * Color(a) / oa
 	if g < 0 {
 		g = 0
 	}
 	if g > 0xFF {
 		g = 0xFF
 	}
-	b = b * Color(a) / oa;
+	b = b * Color(a) / oa
 	if b < 0 {
 		b = 0
 	}
 	if b > 0xFF {
 		b = 0xFF
 	}
-	return r<<24 | g<<16 | b<<8 | Color(a);
+	return r<<24 | g<<16 | b<<8 | Color(a)
 }
 
-func (c Color) Width() int	{ return 1e9 }
+func (c Color) Width() int { return 1e9 }
 
-func (c Color) Height() int	{ return 1e9 }
+func (c Color) Height() int { return 1e9 }
 
-func (c Color) At(x, y int) image.Color	{ return c }
+func (c Color) At(x, y int) image.Color { return c }
 
 func toColor(color image.Color) image.Color {
 	if c, ok := color.(Color); ok {
 		return c
 	}
-	r, g, b, a := color.RGBA();
-	return Color(r>>24<<24 | g>>24<<16 | b>>24<<8 | a>>24);
+	r, g, b, a := color.RGBA()
+	return Color(r>>24<<24 | g>>24<<16 | b>>24<<8 | a>>24)
 }
 
-func (c Color) ColorModel() image.ColorModel	{ return image.ColorModelFunc(toColor) }
+func (c Color) ColorModel() image.ColorModel { return image.ColorModelFunc(toColor) }
diff --git a/src/pkg/exp/draw/draw.go b/src/pkg/exp/draw/draw.go
index d01cdcc163..59adf1f6ac 100644
--- a/src/pkg/exp/draw/draw.go
+++ b/src/pkg/exp/draw/draw.go
@@ -14,8 +14,8 @@ import "image"
 
 // A draw.Image is an image.Image with a Set method to change a single pixel.
 type Image interface {
-	image.Image;
-	Set(x, y int, c image.Color);
+	image.Image
+	Set(x, y int, c image.Color)
 }
 
 // Draw aligns r.Min in dst with pt in src and mask
@@ -27,7 +27,7 @@ type Image interface {
 func Draw(dst Image, r Rectangle, src, mask image.Image, pt Point) {
 	// Plenty of room for optimizations here.
 
-	dx, dy := src.Width(), src.Height();
+	dx, dy := src.Width(), src.Height()
 	if mask != nil {
 		if dx > mask.Width() {
 			dx = mask.Width()
@@ -36,8 +36,8 @@ func Draw(dst Image, r Rectangle, src, mask image.Image, pt Point) {
 			dy = mask.Width()
 		}
 	}
-	dx -= pt.X;
-	dy -= pt.Y;
+	dx -= pt.X
+	dy -= pt.Y
 	if r.Dx() > dx {
 		r.Max.X = r.Min.X + dx
 	}
@@ -45,57 +45,57 @@ func Draw(dst Image, r Rectangle, src, mask image.Image, pt Point) {
 		r.Max.Y = r.Min.Y + dy
 	}
 
-	x0, x1, dx := r.Min.X, r.Max.X, 1;
-	y0, y1, dy := r.Min.Y, r.Max.Y, 1;
+	x0, x1, dx := r.Min.X, r.Max.X, 1
+	y0, y1, dy := r.Min.Y, r.Max.Y, 1
 	if image.Image(dst) == src && r.Overlaps(r.Add(pt.Sub(r.Min))) {
 		// Rectangles overlap: process backward?
 		if pt.Y < r.Min.Y || pt.Y == r.Min.Y && pt.X < r.Min.X {
-			x0, x1, dx = x1-1, x0-1, -1;
-			y0, y1, dy = y1-1, y0-1, -1;
+			x0, x1, dx = x1-1, x0-1, -1
+			y0, y1, dy = y1-1, y0-1, -1
 		}
 	}
 
-	var out *image.RGBA64Color;
+	var out *image.RGBA64Color
 	for y := y0; y != y1; y += dy {
 		for x := x0; x != x1; x += dx {
-			sx := pt.X + x - r.Min.X;
-			sy := pt.Y + y - r.Min.Y;
+			sx := pt.X + x - r.Min.X
+			sy := pt.Y + y - r.Min.Y
 			if mask == nil {
-				dst.Set(x, y, src.At(sx, sy));
-				continue;
+				dst.Set(x, y, src.At(sx, sy))
+				continue
 			}
-			_, _, _, ma := mask.At(sx, sy).RGBA();
+			_, _, _, ma := mask.At(sx, sy).RGBA()
 			switch ma {
 			case 0:
 				continue
 			case 0xFFFFFFFF:
 				dst.Set(x, y, src.At(sx, sy))
 			default:
-				dr, dg, db, da := dst.At(x, y).RGBA();
-				dr >>= 16;
-				dg >>= 16;
-				db >>= 16;
-				da >>= 16;
-				sr, sg, sb, sa := src.At(sx, sy).RGBA();
-				sr >>= 16;
-				sg >>= 16;
-				sb >>= 16;
-				sa >>= 16;
-				ma >>= 16;
-				const M = 1<<16 - 1;
-				a := sa * ma / M;
-				dr = (dr*(M-a) + sr*ma) / M;
-				dg = (dg*(M-a) + sg*ma) / M;
-				db = (db*(M-a) + sb*ma) / M;
-				da = (da*(M-a) + sa*ma) / M;
+				dr, dg, db, da := dst.At(x, y).RGBA()
+				dr >>= 16
+				dg >>= 16
+				db >>= 16
+				da >>= 16
+				sr, sg, sb, sa := src.At(sx, sy).RGBA()
+				sr >>= 16
+				sg >>= 16
+				sb >>= 16
+				sa >>= 16
+				ma >>= 16
+				const M = 1<<16 - 1
+				a := sa * ma / M
+				dr = (dr*(M-a) + sr*ma) / M
+				dg = (dg*(M-a) + sg*ma) / M
+				db = (db*(M-a) + sb*ma) / M
+				da = (da*(M-a) + sa*ma) / M
 				if out == nil {
 					out = new(image.RGBA64Color)
 				}
-				out.R = uint16(dr);
-				out.G = uint16(dg);
-				out.B = uint16(db);
-				out.A = uint16(da);
-				dst.Set(x, y, out);
+				out.R = uint16(dr)
+				out.G = uint16(dg)
+				out.B = uint16(db)
+				out.A = uint16(da)
+				dst.Set(x, y, out)
 			}
 		}
 	}
@@ -106,20 +106,20 @@ func Draw(dst Image, r Rectangle, src, mask image.Image, pt Point) {
 // operation ``src over dst.''  If w is positive, the border extends w pixels inside r.
 // If w is negative, the border extends w pixels outside r.
 func Border(dst Image, r Rectangle, w int, src image.Image, sp Point) {
-	i := w;
+	i := w
 	if i > 0 {
 		// inside r
-		Draw(dst, Rect(r.Min.X, r.Min.Y, r.Max.X, r.Min.Y+i), src, nil, sp);				// top
-		Draw(dst, Rect(r.Min.X, r.Min.Y+i, r.Min.X+i, r.Max.Y-i), src, nil, sp.Add(Pt(0, i)));		// left
-		Draw(dst, Rect(r.Max.X-i, r.Min.Y+i, r.Max.X, r.Max.Y-i), src, nil, sp.Add(Pt(r.Dx()-i, i)));	// right
-		Draw(dst, Rect(r.Min.X, r.Max.Y-i, r.Max.X, r.Max.Y), src, nil, sp.Add(Pt(0, r.Dy()-i)));	// bottom
-		return;
+		Draw(dst, Rect(r.Min.X, r.Min.Y, r.Max.X, r.Min.Y+i), src, nil, sp)                          // top
+		Draw(dst, Rect(r.Min.X, r.Min.Y+i, r.Min.X+i, r.Max.Y-i), src, nil, sp.Add(Pt(0, i)))        // left
+		Draw(dst, Rect(r.Max.X-i, r.Min.Y+i, r.Max.X, r.Max.Y-i), src, nil, sp.Add(Pt(r.Dx()-i, i))) // right
+		Draw(dst, Rect(r.Min.X, r.Max.Y-i, r.Max.X, r.Max.Y), src, nil, sp.Add(Pt(0, r.Dy()-i)))     // bottom
+		return
 	}
 
 	// outside r;
-	i = -i;
-	Draw(dst, Rect(r.Min.X-i, r.Min.Y-i, r.Max.X+i, r.Min.Y), src, nil, sp.Add(Pt(-i, -i)));	// top
-	Draw(dst, Rect(r.Min.X-i, r.Min.Y, r.Min.X, r.Max.Y), src, nil, sp.Add(Pt(-i, 0)));		// left
-	Draw(dst, Rect(r.Max.X, r.Min.Y, r.Max.X+i, r.Max.Y), src, nil, sp.Add(Pt(r.Dx(), 0)));		// right
-	Draw(dst, Rect(r.Min.X-i, r.Max.Y, r.Max.X+i, r.Max.Y+i), src, nil, sp.Add(Pt(-i, 0)));		// bottom
+	i = -i
+	Draw(dst, Rect(r.Min.X-i, r.Min.Y-i, r.Max.X+i, r.Min.Y), src, nil, sp.Add(Pt(-i, -i))) // top
+	Draw(dst, Rect(r.Min.X-i, r.Min.Y, r.Min.X, r.Max.Y), src, nil, sp.Add(Pt(-i, 0)))      // left
+	Draw(dst, Rect(r.Max.X, r.Min.Y, r.Max.X+i, r.Max.Y), src, nil, sp.Add(Pt(r.Dx(), 0)))  // right
+	Draw(dst, Rect(r.Min.X-i, r.Max.Y, r.Max.X+i, r.Max.Y+i), src, nil, sp.Add(Pt(-i, 0)))  // bottom
 }
diff --git a/src/pkg/exp/draw/event.go b/src/pkg/exp/draw/event.go
index 8a148bd48d..155922d1c2 100644
--- a/src/pkg/exp/draw/event.go
+++ b/src/pkg/exp/draw/event.go
@@ -7,10 +7,10 @@ package draw
 // A Context represents a single graphics window.
 type Context interface {
 	// Screen returns an editable Image of window.
-	Screen() Image;
+	Screen() Image
 
 	// FlushImage flushes changes made to Screen() back to screen.
-	FlushImage();
+	FlushImage()
 
 	// KeyboardChan returns a channel carrying keystrokes.
 	// An event is sent each time a key is pressed or released.
@@ -18,29 +18,29 @@ type Context interface {
 	// The value -k represents key k being released.
 	// The specific set of key values is not specified,
 	// but ordinary character represent themselves.
-	KeyboardChan() <-chan int;
+	KeyboardChan() <-chan int
 
 	// MouseChan returns a channel carrying mouse events.
 	// A new event is sent each time the mouse moves or a
 	// button is pressed or released.
-	MouseChan() <-chan Mouse;
+	MouseChan() <-chan Mouse
 
 	// ResizeChan returns a channel carrying resize events.
 	// An event is sent each time the window is resized;
 	// the client should respond by calling Screen() to obtain
 	// the new screen image.
 	// The value sent on the channel is always ``true'' and can be ignored.
-	ResizeChan() <-chan bool;
+	ResizeChan() <-chan bool
 
 	// QuitChan returns a channel carrying quit requests.
 	// After reading a value from the quit channel, the application
 	// should exit.
-	QuitChan() <-chan bool;
+	QuitChan() <-chan bool
 }
 
 // A Mouse represents the state of the mouse.
 type Mouse struct {
-	Buttons	int;	// bit mask of buttons: 1<<0 is left, 1<<1 middle, 1<<2 right
-	Point;		// location of cursor
-	Nsec	int64;	// time stamp
+	Buttons int   // bit mask of buttons: 1<<0 is left, 1<<1 middle, 1<<2 right
+	Point         // location of cursor
+	Nsec    int64 // time stamp
 }
diff --git a/src/pkg/exp/draw/x11/auth.go b/src/pkg/exp/draw/x11/auth.go
index 8a90bf3642..82dd58c28a 100644
--- a/src/pkg/exp/draw/x11/auth.go
+++ b/src/pkg/exp/draw/x11/auth.go
@@ -5,92 +5,92 @@
 package x11
 
 import (
-	"bufio";
-	"io";
-	"os";
+	"bufio"
+	"io"
+	"os"
 )
 
 // Reads the DISPLAY environment variable, and returns the "12" in ":12.0".
 func getDisplay() string {
-	d := os.Getenv("DISPLAY");
+	d := os.Getenv("DISPLAY")
 	if len(d) < 1 || d[0] != ':' {
 		return ""
 	}
-	i := 1;
+	i := 1
 	for ; i < len(d); i++ {
 		if d[i] < '0' || d[i] > '9' {
 			break
 		}
 	}
-	return d[1:i];
+	return d[1:i]
 }
 
 // Reads a big-endian uint16 from r, using b as a scratch buffer.
 func readU16BE(r io.Reader, b []byte) (uint16, os.Error) {
-	_, err := io.ReadFull(r, b[0:2]);
+	_, err := io.ReadFull(r, b[0:2])
 	if err != nil {
 		return 0, err
 	}
-	return uint16(b[0])<<8 + uint16(b[1]), nil;
+	return uint16(b[0])<<8 + uint16(b[1]), nil
 }
 
 // Reads a length-prefixed string from r, using b as a scratch buffer.
 func readStr(r io.Reader, b []byte) (s string, err os.Error) {
-	n, err := readU16BE(r, b);
+	n, err := readU16BE(r, b)
 	if err != nil {
 		return
 	}
 	if int(n) > len(b) {
 		return s, os.NewError("Xauthority entry too long for buffer")
 	}
-	_, err = io.ReadFull(r, b[0:n]);
+	_, err = io.ReadFull(r, b[0:n])
 	if err != nil {
 		return
 	}
-	return string(b[0:n]), nil;
+	return string(b[0:n]), nil
 }
 
 // Reads the ~/.Xauthority file and returns the name/data pair for the DISPLAY.
 // b is a scratch buffer to use, and should be at least 256 bytes long (i.e. it should be able to hold a hostname).
 func readAuth(b []byte) (name, data string, err os.Error) {
 	// As per /usr/include/X11/Xauth.h.
-	const familyLocal = 256;
+	const familyLocal = 256
 
-	home := os.Getenv("HOME");
+	home := os.Getenv("HOME")
 	if len(home) == 0 {
-		err = os.NewError("unknown HOME");
-		return;
+		err = os.NewError("unknown HOME")
+		return
 	}
-	r, err := os.Open(home+"/.Xauthority", os.O_RDONLY, 0444);
+	r, err := os.Open(home+"/.Xauthority", os.O_RDONLY, 0444)
 	if err != nil {
 		return
 	}
-	defer r.Close();
-	br := bufio.NewReader(r);
+	defer r.Close()
+	br := bufio.NewReader(r)
 
-	hostname, err := os.Hostname();
+	hostname, err := os.Hostname()
 	if err != nil {
 		return
 	}
-	display := getDisplay();
+	display := getDisplay()
 	for {
-		family, err := readU16BE(br, b[0:2]);
+		family, err := readU16BE(br, b[0:2])
 		if err != nil {
 			return
 		}
-		addr, err := readStr(br, b[0:]);
+		addr, err := readStr(br, b[0:])
 		if err != nil {
 			return
 		}
-		disp, err := readStr(br, b[0:]);
+		disp, err := readStr(br, b[0:])
 		if err != nil {
 			return
 		}
-		name0, err := readStr(br, b[0:]);
+		name0, err := readStr(br, b[0:])
 		if err != nil {
 			return
 		}
-		data0, err := readStr(br, b[0:]);
+		data0, err := readStr(br, b[0:])
 		if err != nil {
 			return
 		}
@@ -98,5 +98,5 @@ func readAuth(b []byte) (name, data string, err os.Error) {
 			return name0, data0, nil
 		}
 	}
-	panic("unreachable");
+	panic("unreachable")
 }
diff --git a/src/pkg/exp/draw/x11/conn.go b/src/pkg/exp/draw/x11/conn.go
index cb764d11c1..f7eb740e11 100644
--- a/src/pkg/exp/draw/x11/conn.go
+++ b/src/pkg/exp/draw/x11/conn.go
@@ -11,51 +11,51 @@ package x11
 // BUG(nigeltao): This is a toy library and not ready for production use.
 
 import (
-	"bufio";
-	"exp/draw";
-	"image";
-	"io";
-	"net";
-	"os";
+	"bufio"
+	"exp/draw"
+	"image"
+	"io"
+	"net"
+	"os"
 )
 
-type resID uint32	// X resource IDs.
+type resID uint32 // X resource IDs.
 
 // TODO(nigeltao): Handle window resizes.
 const (
-	windowHeight	= 600;
-	windowWidth	= 800;
+	windowHeight = 600
+	windowWidth  = 800
 )
 
 type conn struct {
 	// TODO(nigeltao): Figure out which goroutine should be responsible for closing c,
 	// or if there is a race condition if one goroutine calls c.Close whilst another one
 	// is reading from r, or writing to w.
-	c	io.Closer;
-	r	*bufio.Reader;
-	w	*bufio.Writer;
+	c io.Closer
+	r *bufio.Reader
+	w *bufio.Writer
 
-	gc, window, root, visual	resID;
+	gc, window, root, visual resID
 
-	img		*image.RGBA;
-	kbd		chan int;
-	mouse		chan draw.Mouse;
-	resize		chan bool;
-	quit		chan bool;
-	mouseState	draw.Mouse;
+	img        *image.RGBA
+	kbd        chan int
+	mouse      chan draw.Mouse
+	resize     chan bool
+	quit       chan bool
+	mouseState draw.Mouse
 
-	buf	[256]byte;	// General purpose scratch buffer.
+	buf [256]byte // General purpose scratch buffer.
 
-	flush		chan bool;
-	flushBuf0	[24]byte;
-	flushBuf1	[4 * 1024]byte;
+	flush     chan bool
+	flushBuf0 [24]byte
+	flushBuf1 [4 * 1024]byte
 }
 
 // flusher runs in its own goroutine, serving both FlushImage calls directly from the exp/draw client
 // and indirectly from X expose events. It paints c.img to the X server via PutImage requests.
 func (c *conn) flusher() {
 	for {
-		_ = <-c.flush;
+		_ = <-c.flush
 		if closed(c.flush) {
 			return
 		}
@@ -65,57 +65,57 @@ func (c *conn) flusher() {
 		// the entire image in one X request. This approach could easily be optimized (or the
 		// X protocol may have an escape sequence to delimit very large requests).
 		// TODO(nigeltao): See what XCB's xcb_put_image does in this situation.
-		w, h := c.img.Width(), c.img.Height();
-		units := 6 + w;
+		w, h := c.img.Width(), c.img.Height()
+		units := 6 + w
 		if units > 0xffff || h > 0xffff {
 			// This window is too large for X.
-			close(c.flush);
-			return;
+			close(c.flush)
+			return
 		}
 
-		c.flushBuf0[0] = 0x48;	// PutImage opcode.
-		c.flushBuf0[1] = 0x02;	// XCB_IMAGE_FORMAT_Z_PIXMAP.
-		c.flushBuf0[2] = uint8(units);
-		c.flushBuf0[3] = uint8(units >> 8);
-		setU32LE(c.flushBuf0[4:8], uint32(c.window));
-		setU32LE(c.flushBuf0[8:12], uint32(c.gc));
-		setU32LE(c.flushBuf0[12:16], 1<<16|uint32(w));
-		c.flushBuf0[21] = 0x18;	// depth = 24 bits.
+		c.flushBuf0[0] = 0x48 // PutImage opcode.
+		c.flushBuf0[1] = 0x02 // XCB_IMAGE_FORMAT_Z_PIXMAP.
+		c.flushBuf0[2] = uint8(units)
+		c.flushBuf0[3] = uint8(units >> 8)
+		setU32LE(c.flushBuf0[4:8], uint32(c.window))
+		setU32LE(c.flushBuf0[8:12], uint32(c.gc))
+		setU32LE(c.flushBuf0[12:16], 1<<16|uint32(w))
+		c.flushBuf0[21] = 0x18 // depth = 24 bits.
 
 		for y := 0; y < h; y++ {
-			setU32LE(c.flushBuf0[16:20], uint32(y<<16));
-			_, err := c.w.Write(c.flushBuf0[0:24]);
+			setU32LE(c.flushBuf0[16:20], uint32(y<<16))
+			_, err := c.w.Write(c.flushBuf0[0:24])
 			if err != nil {
-				close(c.flush);
-				return;
+				close(c.flush)
+				return
 			}
 			for x := 0; x < w; {
-				nx := w - x;
+				nx := w - x
 				if nx > len(c.flushBuf1)/4 {
 					nx = len(c.flushBuf1) / 4
 				}
 				for i := 0; i < nx; i++ {
-					r, g, b, _ := c.img.At(x, y).RGBA();
-					c.flushBuf1[4*i+0] = uint8(b >> 24);
-					c.flushBuf1[4*i+1] = uint8(g >> 24);
-					c.flushBuf1[4*i+2] = uint8(r >> 24);
-					x++;
+					r, g, b, _ := c.img.At(x, y).RGBA()
+					c.flushBuf1[4*i+0] = uint8(b >> 24)
+					c.flushBuf1[4*i+1] = uint8(g >> 24)
+					c.flushBuf1[4*i+2] = uint8(r >> 24)
+					x++
 				}
-				_, err := c.w.Write(c.flushBuf1[0 : 4*nx]);
+				_, err := c.w.Write(c.flushBuf1[0 : 4*nx])
 				if err != nil {
-					close(c.flush);
-					return;
+					close(c.flush)
+					return
 				}
 			}
 		}
 		if c.w.Flush() != nil {
-			close(c.flush);
-			return;
+			close(c.flush)
+			return
 		}
 	}
 }
 
-func (c *conn) Screen() draw.Image	{ return c.img }
+func (c *conn) Screen() draw.Image { return c.img }
 
 func (c *conn) FlushImage() {
 	// We do the send (the <- operator) in an expression context, rather than in
@@ -124,19 +124,19 @@ func (c *conn) FlushImage() {
 	_ = c.flush <- false
 }
 
-func (c *conn) KeyboardChan() <-chan int	{ return c.kbd }
+func (c *conn) KeyboardChan() <-chan int { return c.kbd }
 
-func (c *conn) MouseChan() <-chan draw.Mouse	{ return c.mouse }
+func (c *conn) MouseChan() <-chan draw.Mouse { return c.mouse }
 
-func (c *conn) ResizeChan() <-chan bool	{ return c.resize }
+func (c *conn) ResizeChan() <-chan bool { return c.resize }
 
-func (c *conn) QuitChan() <-chan bool	{ return c.quit }
+func (c *conn) QuitChan() <-chan bool { return c.quit }
 
 // pumper runs in its own goroutine, reading X events and demuxing them over the kbd / mouse / resize / quit chans.
 func (c *conn) pumper() {
 	for {
 		// X events are always 32 bytes long.
-		_, err := io.ReadFull(c.r, c.buf[0:32]);
+		_, err := io.ReadFull(c.r, c.buf[0:32])
 		if err != nil {
 			// TODO(nigeltao): should draw.Context expose err?
 			// TODO(nigeltao): should we do c.quit<-true? Should c.quit be a buffered channel?
@@ -145,12 +145,12 @@ func (c *conn) pumper() {
 			break
 		}
 		switch c.buf[0] {
-		case 0x02, 0x03:	// Key press, key release.
+		case 0x02, 0x03: // Key press, key release.
 			// BUG(nigeltao): Keycode to keysym mapping is not implemented.
 
 			// The keycode is in c.buf[1], but as keymaps aren't implemented yet, we'll use the
 			// space character as a placeholder.
-			keysym := int(' ');
+			keysym := int(' ')
 			// TODO(nigeltao): Should we send KeyboardChan ints for Shift/Ctrl/Alt? Should Shift-A send
 			// the same int down the channel as the sent on just the A key?
 			// TODO(nigeltao): How should IME events (e.g. key presses that should generate CJK text) work? Or
@@ -158,29 +158,29 @@ func (c *conn) pumper() {
 			if c.buf[0] == 0x03 {
 				keysym = -keysym
 			}
-			c.kbd <- keysym;
-		case 0x04, 0x05:	// Button press, button release.
-			mask := 1 << (c.buf[1] - 1);
+			c.kbd <- keysym
+		case 0x04, 0x05: // Button press, button release.
+			mask := 1 << (c.buf[1] - 1)
 			if c.buf[0] == 0x04 {
 				c.mouseState.Buttons |= mask
 			} else {
 				c.mouseState.Buttons &^= mask
 			}
 			// TODO(nigeltao): update mouseState's timestamp.
-			c.mouse <- c.mouseState;
-		case 0x06:	// Motion notify.
-			c.mouseState.Point.X = int(c.buf[25])<<8 | int(c.buf[24]);
-			c.mouseState.Point.Y = int(c.buf[27])<<8 | int(c.buf[26]);
+			c.mouse <- c.mouseState
+		case 0x06: // Motion notify.
+			c.mouseState.Point.X = int(c.buf[25])<<8 | int(c.buf[24])
+			c.mouseState.Point.Y = int(c.buf[27])<<8 | int(c.buf[26])
 			// TODO(nigeltao): update mouseState's timestamp.
-			c.mouse <- c.mouseState;
-		case 0x0c:	// Expose.
+			c.mouse <- c.mouseState
+		case 0x0c: // Expose.
 			// A single user action could trigger multiple expose events (e.g. if moving another
 			// window with XShape'd rounded corners over our window). In that case, the X server
 			// will send a count (in bytes 16-17) of the number of additional expose events coming.
 			// We could parse each event for the (x, y, width, height) and maintain a minimal dirty
 			// rectangle, but for now, the simplest approach is to paint the entire window, when
 			// receiving the final event in the series.
-			count := int(c.buf[17])<<8 | int(c.buf[16]);
+			count := int(c.buf[17])<<8 | int(c.buf[16])
 			if count == 0 {
 				// TODO(nigeltao): Should we ignore the very first expose event? A freshly mapped window
 				// will trigger expose, but until the first c.FlushImage call, there's probably nothing to
@@ -192,14 +192,14 @@ func (c *conn) pumper() {
 			// What about EnterNotify (0x07) and LeaveNotify (0x08)?
 		}
 	}
-	close(c.flush);
+	close(c.flush)
 	// TODO(nigeltao): Is this the right place for c.c.Close()?
 	// TODO(nigeltao): Should we explicitly close our kbd/mouse/resize/quit chans?
 }
 
 // Authenticate ourselves with the X server.
 func (c *conn) authenticate() os.Error {
-	key, value, err := readAuth(c.buf[0:]);
+	key, value, err := readAuth(c.buf[0:])
 	if err != nil {
 		return err
 	}
@@ -210,69 +210,69 @@ func (c *conn) authenticate() os.Error {
 	// 0x006c means little-endian. 0x000b, 0x0000 means X major version 11, minor version 0.
 	// 0x0012 and 0x0010 means the auth key and value have lenths 18 and 16.
 	// The final 0x0000 is padding, so that the string length is a multiple of 4.
-	_, err = io.WriteString(c.w, "\x6c\x00\x0b\x00\x00\x00\x12\x00\x10\x00\x00\x00");
+	_, err = io.WriteString(c.w, "\x6c\x00\x0b\x00\x00\x00\x12\x00\x10\x00\x00\x00")
 	if err != nil {
 		return err
 	}
-	_, err = io.WriteString(c.w, key);
+	_, err = io.WriteString(c.w, key)
 	if err != nil {
 		return err
 	}
 	// Again, the 0x0000 is padding.
-	_, err = io.WriteString(c.w, "\x00\x00");
+	_, err = io.WriteString(c.w, "\x00\x00")
 	if err != nil {
 		return err
 	}
-	_, err = io.WriteString(c.w, value);
+	_, err = io.WriteString(c.w, value)
 	if err != nil {
 		return err
 	}
-	err = c.w.Flush();
+	err = c.w.Flush()
 	if err != nil {
 		return err
 	}
-	return nil;
+	return nil
 }
 
 // Reads a uint8 from r, using b as a scratch buffer.
 func readU8(r io.Reader, b []byte) (uint8, os.Error) {
-	_, err := io.ReadFull(r, b[0:1]);
+	_, err := io.ReadFull(r, b[0:1])
 	if err != nil {
 		return 0, err
 	}
-	return uint8(b[0]), nil;
+	return uint8(b[0]), nil
 }
 
 // Reads a little-endian uint16 from r, using b as a scratch buffer.
 func readU16LE(r io.Reader, b []byte) (uint16, os.Error) {
-	_, err := io.ReadFull(r, b[0:2]);
+	_, err := io.ReadFull(r, b[0:2])
 	if err != nil {
 		return 0, err
 	}
-	return uint16(b[0]) | uint16(b[1])<<8, nil;
+	return uint16(b[0]) | uint16(b[1])<<8, nil
 }
 
 // Reads a little-endian uint32 from r, using b as a scratch buffer.
 func readU32LE(r io.Reader, b []byte) (uint32, os.Error) {
-	_, err := io.ReadFull(r, b[0:4]);
+	_, err := io.ReadFull(r, b[0:4])
 	if err != nil {
 		return 0, err
 	}
-	return uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24, nil;
+	return uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24, nil
 }
 
 // Sets b[0:4] to be the big-endian representation of u.
 func setU32LE(b []byte, u uint32) {
-	b[0] = byte((u >> 0) & 0xff);
-	b[1] = byte((u >> 8) & 0xff);
-	b[2] = byte((u >> 16) & 0xff);
-	b[3] = byte((u >> 24) & 0xff);
+	b[0] = byte((u >> 0) & 0xff)
+	b[1] = byte((u >> 8) & 0xff)
+	b[2] = byte((u >> 16) & 0xff)
+	b[3] = byte((u >> 24) & 0xff)
 }
 
 // Check that we have an agreeable X pixmap Format.
 func checkPixmapFormats(r io.Reader, b []byte, n int) (agree bool, err os.Error) {
 	for i := 0; i < n; i++ {
-		_, err = io.ReadFull(r, b[0:8]);
+		_, err = io.ReadFull(r, b[0:8])
 		if err != nil {
 			return
 		}
@@ -281,35 +281,35 @@ func checkPixmapFormats(r io.Reader, b []byte, n int) (agree bool, err os.Error)
 			agree = true
 		}
 	}
-	return;
+	return
 }
 
 // Check that we have an agreeable X Depth (i.e. one that has an agreeable X VisualType).
 func checkDepths(r io.Reader, b []byte, n int, visual uint32) (agree bool, err os.Error) {
 	for i := 0; i < n; i++ {
-		depth, err := readU16LE(r, b);
+		depth, err := readU16LE(r, b)
 		if err != nil {
 			return
 		}
-		depth &= 0xff;
-		visualsLen, err := readU16LE(r, b);
+		depth &= 0xff
+		visualsLen, err := readU16LE(r, b)
 		if err != nil {
 			return
 		}
 		// Ignore 4 bytes of padding.
-		_, err = io.ReadFull(r, b[0:4]);
+		_, err = io.ReadFull(r, b[0:4])
 		if err != nil {
 			return
 		}
 		for j := 0; j < int(visualsLen); j++ {
 			// Read 24 bytes: visual(4), class(1), bits per rgb value(1), colormap entries(2),
 			// red mask(4), green mask(4), blue mask(4), padding(4).
-			v, err := readU32LE(r, b);
-			_, err = readU32LE(r, b);
-			rm, err := readU32LE(r, b);
-			gm, err := readU32LE(r, b);
-			bm, err := readU32LE(r, b);
-			_, err = readU32LE(r, b);
+			v, err := readU32LE(r, b)
+			_, err = readU32LE(r, b)
+			rm, err := readU32LE(r, b)
+			gm, err := readU32LE(r, b)
+			bm, err := readU32LE(r, b)
+			_, err = readU32LE(r, b)
 			if err != nil {
 				return
 			}
@@ -318,47 +318,47 @@ func checkDepths(r io.Reader, b []byte, n int, visual uint32) (agree bool, err o
 			}
 		}
 	}
-	return;
+	return
 }
 
 // Check that we have an agreeable X Screen.
 func checkScreens(r io.Reader, b []byte, n int) (root, visual uint32, err os.Error) {
 	for i := 0; i < n; i++ {
-		root0, err := readU32LE(r, b);
+		root0, err := readU32LE(r, b)
 		if err != nil {
 			return
 		}
 		// Ignore the next 7x4 bytes, which is: colormap, whitepixel, blackpixel, current input masks,
 		// width and height (pixels), width and height (mm), min and max installed maps.
-		_, err = io.ReadFull(r, b[0:28]);
+		_, err = io.ReadFull(r, b[0:28])
 		if err != nil {
 			return
 		}
-		visual0, err := readU32LE(r, b);
+		visual0, err := readU32LE(r, b)
 		if err != nil {
 			return
 		}
 		// Next 4 bytes: backing stores, save unders, root depth, allowed depths length.
-		x, err := readU32LE(r, b);
+		x, err := readU32LE(r, b)
 		if err != nil {
 			return
 		}
-		nDepths := int(x >> 24);
-		agree, err := checkDepths(r, b, nDepths, visual0);
+		nDepths := int(x >> 24)
+		agree, err := checkDepths(r, b, nDepths, visual0)
 		if err != nil {
 			return
 		}
 		if agree && root == 0 {
-			root = root0;
-			visual = visual0;
+			root = root0
+			visual = visual0
 		}
 	}
-	return;
+	return
 }
 
 // Perform the protocol handshake with the X server, and ensure that the server provides a compatible Screen, Depth, etcetera.
 func (c *conn) handshake() os.Error {
-	_, err := io.ReadFull(c.r, c.buf[0:8]);
+	_, err := io.ReadFull(c.r, c.buf[0:8])
 	if err != nil {
 		return err
 	}
@@ -367,17 +367,17 @@ func (c *conn) handshake() os.Error {
 		return os.NewError("unsupported X version")
 	}
 	// Ignore the release number.
-	_, err = io.ReadFull(c.r, c.buf[0:4]);
+	_, err = io.ReadFull(c.r, c.buf[0:4])
 	if err != nil {
 		return err
 	}
 	// Read the resource ID base.
-	resourceIdBase, err := readU32LE(c.r, c.buf[0:4]);
+	resourceIdBase, err := readU32LE(c.r, c.buf[0:4])
 	if err != nil {
 		return err
 	}
 	// Read the resource ID mask.
-	resourceIdMask, err := readU32LE(c.r, c.buf[0:4]);
+	resourceIdMask, err := readU32LE(c.r, c.buf[0:4])
 	if err != nil {
 		return err
 	}
@@ -385,12 +385,12 @@ func (c *conn) handshake() os.Error {
 		return os.NewError("X resource ID mask is too small")
 	}
 	// Ignore the motion buffer size.
-	_, err = io.ReadFull(c.r, c.buf[0:4]);
+	_, err = io.ReadFull(c.r, c.buf[0:4])
 	if err != nil {
 		return err
 	}
 	// Read the vendor length.
-	vendorLen, err := readU16LE(c.r, c.buf[0:2]);
+	vendorLen, err := readU16LE(c.r, c.buf[0:2])
 	if err != nil {
 		return err
 	}
@@ -400,7 +400,7 @@ func (c *conn) handshake() os.Error {
 		return os.NewError("unsupported X vendor")
 	}
 	// Read the maximum request length.
-	maxReqLen, err := readU16LE(c.r, c.buf[0:2]);
+	maxReqLen, err := readU16LE(c.r, c.buf[0:2])
 	if err != nil {
 		return err
 	}
@@ -408,24 +408,24 @@ func (c *conn) handshake() os.Error {
 		return os.NewError("unsupported X maximum request length")
 	}
 	// Read the roots length.
-	rootsLen, err := readU8(c.r, c.buf[0:1]);
+	rootsLen, err := readU8(c.r, c.buf[0:1])
 	if err != nil {
 		return err
 	}
 	// Read the pixmap formats length.
-	pixmapFormatsLen, err := readU8(c.r, c.buf[0:1]);
+	pixmapFormatsLen, err := readU8(c.r, c.buf[0:1])
 	if err != nil {
 		return err
 	}
 	// Ignore some things that we don't care about (totalling 30 bytes):
 	// imageByteOrder(1), bitmapFormatBitOrder(1), bitmapFormatScanlineUnit(1) bitmapFormatScanlinePad(1),
 	// minKeycode(1), maxKeycode(1), padding(4), vendor(20, hard-coded above).
-	_, err = io.ReadFull(c.r, c.buf[0:30]);
+	_, err = io.ReadFull(c.r, c.buf[0:30])
 	if err != nil {
 		return err
 	}
 	// Check that we have an agreeable pixmap format.
-	agree, err := checkPixmapFormats(c.r, c.buf[0:8], int(pixmapFormatsLen));
+	agree, err := checkPixmapFormats(c.r, c.buf[0:8], int(pixmapFormatsLen))
 	if err != nil {
 		return err
 	}
@@ -433,83 +433,83 @@ func (c *conn) handshake() os.Error {
 		return os.NewError("unsupported X pixmap formats")
 	}
 	// Check that we have an agreeable screen.
-	root, visual, err := checkScreens(c.r, c.buf[0:24], int(rootsLen));
+	root, visual, err := checkScreens(c.r, c.buf[0:24], int(rootsLen))
 	if err != nil {
 		return err
 	}
 	if root == 0 || visual == 0 {
 		return os.NewError("unsupported X screen")
 	}
-	c.gc = resID(resourceIdBase);
-	c.window = resID(resourceIdBase + 1);
-	c.root = resID(root);
-	c.visual = resID(visual);
-	return nil;
+	c.gc = resID(resourceIdBase)
+	c.window = resID(resourceIdBase + 1)
+	c.root = resID(root)
+	c.visual = resID(visual)
+	return nil
 }
 
 // Returns a new draw.Context, backed by a newly created and mapped X11 window.
 func NewWindow() (draw.Context, os.Error) {
-	display := getDisplay();
+	display := getDisplay()
 	if len(display) == 0 {
 		return nil, os.NewError("unsupported DISPLAY")
 	}
-	s, err := net.Dial("unix", "", "/tmp/.X11-unix/X"+display);
+	s, err := net.Dial("unix", "", "/tmp/.X11-unix/X"+display)
 	if err != nil {
 		return nil, err
 	}
-	c := new(conn);
-	c.c = s;
-	c.r = bufio.NewReader(s);
-	c.w = bufio.NewWriter(s);
-	err = c.authenticate();
+	c := new(conn)
+	c.c = s
+	c.r = bufio.NewReader(s)
+	c.w = bufio.NewWriter(s)
+	err = c.authenticate()
 	if err != nil {
 		return nil, err
 	}
-	err = c.handshake();
+	err = c.handshake()
 	if err != nil {
 		return nil, err
 	}
 
 	// Now that we're connected, show a window, via three X protocol messages.
 	// First, create a graphics context (GC).
-	setU32LE(c.buf[0:4], 0x00060037);	// 0x37 is the CreateGC opcode, and the message is 6 x 4 bytes long.
-	setU32LE(c.buf[4:8], uint32(c.gc));
-	setU32LE(c.buf[8:12], uint32(c.root));
-	setU32LE(c.buf[12:16], 0x00010004);	// Bit 2 is XCB_GC_FOREGROUND, bit 16 is XCB_GC_GRAPHICS_EXPOSURES.
-	setU32LE(c.buf[16:20], 0x00000000);	// The Foreground is black.
-	setU32LE(c.buf[20:24], 0x00000000);	// GraphicsExposures' value is unused.
+	setU32LE(c.buf[0:4], 0x00060037) // 0x37 is the CreateGC opcode, and the message is 6 x 4 bytes long.
+	setU32LE(c.buf[4:8], uint32(c.gc))
+	setU32LE(c.buf[8:12], uint32(c.root))
+	setU32LE(c.buf[12:16], 0x00010004) // Bit 2 is XCB_GC_FOREGROUND, bit 16 is XCB_GC_GRAPHICS_EXPOSURES.
+	setU32LE(c.buf[16:20], 0x00000000) // The Foreground is black.
+	setU32LE(c.buf[20:24], 0x00000000) // GraphicsExposures' value is unused.
 	// Second, create the window.
-	setU32LE(c.buf[24:28], 0x000a0001);	// 0x01 is the CreateWindow opcode, and the message is 10 x 4 bytes long.
-	setU32LE(c.buf[28:32], uint32(c.window));
-	setU32LE(c.buf[32:36], uint32(c.root));
-	setU32LE(c.buf[36:40], 0x00000000);	// Initial (x, y) is (0, 0).
-	setU32LE(c.buf[40:44], windowHeight<<16|windowWidth);
-	setU32LE(c.buf[44:48], 0x00010000);	// Border width is 0, XCB_WINDOW_CLASS_INPUT_OUTPUT is 1.
-	setU32LE(c.buf[48:52], uint32(c.visual));
-	setU32LE(c.buf[52:56], 0x00000802);	// Bit 1 is XCB_CW_BACK_PIXEL, bit 11 is XCB_CW_EVENT_MASK.
-	setU32LE(c.buf[56:60], 0x00000000);	// The Back-Pixel is black.
-	setU32LE(c.buf[60:64], 0x0000804f);	// Key/button press and release, pointer motion, and expose event masks.
+	setU32LE(c.buf[24:28], 0x000a0001) // 0x01 is the CreateWindow opcode, and the message is 10 x 4 bytes long.
+	setU32LE(c.buf[28:32], uint32(c.window))
+	setU32LE(c.buf[32:36], uint32(c.root))
+	setU32LE(c.buf[36:40], 0x00000000) // Initial (x, y) is (0, 0).
+	setU32LE(c.buf[40:44], windowHeight<<16|windowWidth)
+	setU32LE(c.buf[44:48], 0x00010000) // Border width is 0, XCB_WINDOW_CLASS_INPUT_OUTPUT is 1.
+	setU32LE(c.buf[48:52], uint32(c.visual))
+	setU32LE(c.buf[52:56], 0x00000802) // Bit 1 is XCB_CW_BACK_PIXEL, bit 11 is XCB_CW_EVENT_MASK.
+	setU32LE(c.buf[56:60], 0x00000000) // The Back-Pixel is black.
+	setU32LE(c.buf[60:64], 0x0000804f) // Key/button press and release, pointer motion, and expose event masks.
 	// Third, map the window.
-	setU32LE(c.buf[64:68], 0x00020008);	// 0x08 is the MapWindow opcode, and the message is 2 x 4 bytes long.
-	setU32LE(c.buf[68:72], uint32(c.window));
+	setU32LE(c.buf[64:68], 0x00020008) // 0x08 is the MapWindow opcode, and the message is 2 x 4 bytes long.
+	setU32LE(c.buf[68:72], uint32(c.window))
 	// Write the bytes.
-	_, err = c.w.Write(c.buf[0:72]);
+	_, err = c.w.Write(c.buf[0:72])
 	if err != nil {
 		return nil, err
 	}
-	err = c.w.Flush();
+	err = c.w.Flush()
 	if err != nil {
 		return nil, err
 	}
 
-	c.img = image.NewRGBA(windowWidth, windowHeight);
+	c.img = image.NewRGBA(windowWidth, windowHeight)
 	// TODO(nigeltao): Should these channels be buffered?
-	c.kbd = make(chan int);
-	c.mouse = make(chan draw.Mouse);
-	c.resize = make(chan bool);
-	c.quit = make(chan bool);
-	c.flush = make(chan bool, 1);
-	go c.flusher();
-	go c.pumper();
-	return c, nil;
+	c.kbd = make(chan int)
+	c.mouse = make(chan draw.Mouse)
+	c.resize = make(chan bool)
+	c.quit = make(chan bool)
+	c.flush = make(chan bool, 1)
+	go c.flusher()
+	go c.pumper()
+	return c, nil
 }
diff --git a/src/pkg/exp/eval/abort.go b/src/pkg/exp/eval/abort.go
index fd16d7eaab..bfa89fa299 100644
--- a/src/pkg/exp/eval/abort.go
+++ b/src/pkg/exp/eval/abort.go
@@ -5,9 +5,9 @@
 package eval
 
 import (
-	"fmt";
-	"os";
-	"runtime";
+	"fmt"
+	"os"
+	"runtime"
 )
 
 // Abort aborts the thread's current computation,
@@ -16,46 +16,46 @@ func (t *Thread) Abort(err os.Error) {
 	if t.abort == nil {
 		panicln("abort:", err.String())
 	}
-	t.abort <- err;
-	runtime.Goexit();
+	t.abort <- err
+	runtime.Goexit()
 }
 
 // Try executes a computation; if the computation
 // Aborts, Try returns the error passed to abort.
 func (t *Thread) Try(f func(t *Thread)) os.Error {
-	oc := t.abort;
-	c := make(chan os.Error);
-	t.abort = c;
+	oc := t.abort
+	c := make(chan os.Error)
+	t.abort = c
 	go func() {
-		f(t);
-		c <- nil;
-	}();
-	err := <-c;
-	t.abort = oc;
-	return err;
+		f(t)
+		c <- nil
+	}()
+	err := <-c
+	t.abort = oc
+	return err
 }
 
 type DivByZeroError struct{}
 
-func (DivByZeroError) String() string	{ return "divide by zero" }
+func (DivByZeroError) String() string { return "divide by zero" }
 
 type NilPointerError struct{}
 
-func (NilPointerError) String() string	{ return "nil pointer dereference" }
+func (NilPointerError) String() string { return "nil pointer dereference" }
 
 type IndexError struct {
-	Idx, Len int64;
+	Idx, Len int64
 }
 
 func (e IndexError) String() string {
 	if e.Idx < 0 {
 		return fmt.Sprintf("negative index: %d", e.Idx)
 	}
-	return fmt.Sprintf("index %d exceeds length %d", e.Idx, e.Len);
+	return fmt.Sprintf("index %d exceeds length %d", e.Idx, e.Len)
 }
 
 type SliceError struct {
-	Lo, Hi, Cap int64;
+	Lo, Hi, Cap int64
 }
 
 func (e SliceError) String() string {
@@ -63,13 +63,13 @@ func (e SliceError) String() string {
 }
 
 type KeyError struct {
-	Key interface{};
+	Key interface{}
 }
 
-func (e KeyError) String() string	{ return fmt.Sprintf("key '%v' not found in map", e.Key) }
+func (e KeyError) String() string { return fmt.Sprintf("key '%v' not found in map", e.Key) }
 
 type NegativeLengthError struct {
-	Len int64;
+	Len int64
 }
 
 func (e NegativeLengthError) String() string {
@@ -77,7 +77,7 @@ func (e NegativeLengthError) String() string {
 }
 
 type NegativeCapacityError struct {
-	Len int64;
+	Len int64
 }
 
 func (e NegativeCapacityError) String() string {
diff --git a/src/pkg/exp/eval/bridge.go b/src/pkg/exp/eval/bridge.go
index fed27930f5..43a6fd30d6 100644
--- a/src/pkg/exp/eval/bridge.go
+++ b/src/pkg/exp/eval/bridge.go
@@ -5,9 +5,9 @@
 package eval
 
 import (
-	"log";
-	"go/token";
-	"reflect";
+	"log"
+	"go/token"
+	"reflect"
 )
 
 /*
@@ -15,8 +15,8 @@ import (
  */
 
 var (
-	evalTypes	= make(map[reflect.Type]Type);
-	nativeTypes	= make(map[Type]reflect.Type);
+	evalTypes   = make(map[reflect.Type]Type)
+	nativeTypes = make(map[Type]reflect.Type)
 )
 
 // TypeFromNative converts a regular Go type into a the corresponding
@@ -26,14 +26,14 @@ func TypeFromNative(t reflect.Type) Type {
 		return et
 	}
 
-	var nt *NamedType;
+	var nt *NamedType
 	if t.Name() != "" {
-		name := t.PkgPath() + "ยท" + t.Name();
-		nt = &NamedType{token.Position{}, name, nil, true, make(map[string]Method)};
-		evalTypes[t] = nt;
+		name := t.PkgPath() + "ยท" + t.Name()
+		nt = &NamedType{token.Position{}, name, nil, true, make(map[string]Method)}
+		evalTypes[t] = nt
 	}
 
-	var et Type;
+	var et Type
 	switch t := t.(type) {
 	case *reflect.BoolType:
 		et = BoolType
@@ -73,24 +73,24 @@ func TypeFromNative(t reflect.Type) Type {
 	case *reflect.ChanType:
 		log.Crashf("%T not implemented", t)
 	case *reflect.FuncType:
-		nin := t.NumIn();
+		nin := t.NumIn()
 		// Variadic functions have DotDotDotType at the end
-		varidic := false;
+		varidic := false
 		if nin > 0 {
 			if _, ok := t.In(nin - 1).(*reflect.DotDotDotType); ok {
-				varidic = true;
-				nin--;
+				varidic = true
+				nin--
 			}
 		}
-		in := make([]Type, nin);
+		in := make([]Type, nin)
 		for i := range in {
 			in[i] = TypeFromNative(t.In(i))
 		}
-		out := make([]Type, t.NumOut());
+		out := make([]Type, t.NumOut())
 		for i := range out {
 			out[i] = TypeFromNative(t.Out(i))
 		}
-		et = NewFuncType(in, varidic, out);
+		et = NewFuncType(in, varidic, out)
 	case *reflect.InterfaceType:
 		log.Crashf("%T not implemented", t)
 	case *reflect.MapType:
@@ -100,16 +100,16 @@ func TypeFromNative(t reflect.Type) Type {
 	case *reflect.SliceType:
 		et = NewSliceType(TypeFromNative(t.Elem()))
 	case *reflect.StructType:
-		n := t.NumField();
-		fields := make([]StructField, n);
+		n := t.NumField()
+		fields := make([]StructField, n)
 		for i := 0; i < n; i++ {
-			sf := t.Field(i);
+			sf := t.Field(i)
 			// TODO(austin) What to do about private fields?
-			fields[i].Name = sf.Name;
-			fields[i].Type = TypeFromNative(sf.Type);
-			fields[i].Anonymous = sf.Anonymous;
+			fields[i].Name = sf.Name
+			fields[i].Type = TypeFromNative(sf.Type)
+			fields[i].Anonymous = sf.Anonymous
 		}
-		et = NewStructType(fields);
+		et = NewStructType(fields)
 	case *reflect.UnsafePointerType:
 		log.Crashf("%T not implemented", t)
 	default:
@@ -118,35 +118,35 @@ func TypeFromNative(t reflect.Type) Type {
 
 	if nt != nil {
 		if _, ok := et.(*NamedType); !ok {
-			nt.Complete(et);
-			et = nt;
+			nt.Complete(et)
+			et = nt
 		}
 	}
 
-	nativeTypes[et] = t;
-	evalTypes[t] = et;
+	nativeTypes[et] = t
+	evalTypes[t] = et
 
-	return et;
+	return et
 }
 
 // TypeOfNative returns the interpreter Type of a regular Go value.
-func TypeOfNative(v interface{}) Type	{ return TypeFromNative(reflect.Typeof(v)) }
+func TypeOfNative(v interface{}) Type { return TypeFromNative(reflect.Typeof(v)) }
 
 /*
  * Function bridging
  */
 
 type nativeFunc struct {
-	fn	func(*Thread, []Value, []Value);
-	in, out	int;
+	fn      func(*Thread, []Value, []Value)
+	in, out int
 }
 
 func (f *nativeFunc) NewFrame() *Frame {
-	vars := make([]Value, f.in+f.out);
-	return &Frame{nil, vars};
+	vars := make([]Value, f.in+f.out)
+	return &Frame{nil, vars}
 }
 
-func (f *nativeFunc) Call(t *Thread)	{ f.fn(t, t.f.Vars[0:f.in], t.f.Vars[f.in:f.in+f.out]) }
+func (f *nativeFunc) Call(t *Thread) { f.fn(t, t.f.Vars[0:f.in], t.f.Vars[f.in:f.in+f.out]) }
 
 // FuncFromNative creates an interpreter function from a native
 // function that takes its in and out arguments as slices of
@@ -161,6 +161,6 @@ func FuncFromNative(fn func(*Thread, []Value, []Value), t *FuncType) FuncValue {
 // the type will be given as a nil pointer to a function with the
 // desired signature.
 func FuncFromNativeTyped(fn func(*Thread, []Value, []Value), t interface{}) (*FuncType, FuncValue) {
-	ft := TypeOfNative(t).(*FuncType);
-	return ft, FuncFromNative(fn, ft);
+	ft := TypeOfNative(t).(*FuncType)
+	return ft, FuncFromNative(fn, ft)
 }
diff --git a/src/pkg/exp/eval/compiler.go b/src/pkg/exp/eval/compiler.go
index f349b836f2..6bde3b5672 100644
--- a/src/pkg/exp/eval/compiler.go
+++ b/src/pkg/exp/eval/compiler.go
@@ -5,14 +5,14 @@
 package eval
 
 import (
-	"fmt";
-	"go/scanner";
-	"go/token";
+	"fmt"
+	"go/scanner"
+	"go/token"
 )
 
 
 type positioned interface {
-	Pos() token.Position;
+	Pos() token.Position
 }
 
 
@@ -22,28 +22,28 @@ type positioned interface {
 // TODO(austin) This might actually represent package level, in which
 // case it should be package compiler.
 type compiler struct {
-	errors		scanner.ErrorHandler;
-	numErrors	int;
-	silentErrors	int;
+	errors       scanner.ErrorHandler
+	numErrors    int
+	silentErrors int
 }
 
 func (a *compiler) diagAt(pos positioned, format string, args ...) {
-	a.errors.Error(pos.Pos(), fmt.Sprintf(format, args));
-	a.numErrors++;
+	a.errors.Error(pos.Pos(), fmt.Sprintf(format, args))
+	a.numErrors++
 }
 
-func (a *compiler) numError() int	{ return a.numErrors + a.silentErrors }
+func (a *compiler) numError() int { return a.numErrors + a.silentErrors }
 
 // The universal scope
 func newUniverse() *Scope {
-	sc := &Scope{nil, 0};
+	sc := &Scope{nil, 0}
 	sc.block = &block{
 		offset: 0,
 		scope: sc,
 		global: true,
 		defs: make(map[string]Def),
-	};
-	return sc;
+	}
+	return sc
 }
 
 var universe *Scope = newUniverse()
@@ -51,46 +51,46 @@ var universe *Scope = newUniverse()
 
 // TODO(austin) These can all go in stmt.go now
 type label struct {
-	name	string;
-	desc	string;
+	name string
+	desc string
 	// The PC goto statements should jump to, or nil if this label
 	// cannot be goto'd (such as an anonymous for loop label).
-	gotoPC	*uint;
+	gotoPC *uint
 	// The PC break statements should jump to, or nil if a break
 	// statement is invalid.
-	breakPC	*uint;
+	breakPC *uint
 	// The PC continue statements should jump to, or nil if a
 	// continue statement is invalid.
-	continuePC	*uint;
+	continuePC *uint
 	// The position where this label was resolved.  If it has not
 	// been resolved yet, an invalid position.
-	resolved	token.Position;
+	resolved token.Position
 	// The position where this label was first jumped to.
-	used	token.Position;
+	used token.Position
 }
 
 // A funcCompiler captures information used throughout the compilation
 // of a single function body.
 type funcCompiler struct {
-	*compiler;
-	fnType	*FuncType;
+	*compiler
+	fnType *FuncType
 	// Whether the out variables are named.  This affects what
 	// kinds of return statements are legal.
-	outVarsNamed	bool;
-	*codeBuf;
-	flow	*flowBuf;
-	labels	map[string]*label;
+	outVarsNamed bool
+	*codeBuf
+	flow   *flowBuf
+	labels map[string]*label
 }
 
 // A blockCompiler captures information used throughout the compilation
 // of a single block within a function.
 type blockCompiler struct {
-	*funcCompiler;
-	block	*block;
+	*funcCompiler
+	block *block
 	// The label of this block, used for finding break and
 	// continue labels.
-	label	*label;
+	label *label
 	// The blockCompiler for the block enclosing this one, or nil
 	// for a function-level block.
-	parent	*blockCompiler;
+	parent *blockCompiler
 }
diff --git a/src/pkg/exp/eval/eval_test.go b/src/pkg/exp/eval/eval_test.go
index afd91bfb2c..93a643b5aa 100644
--- a/src/pkg/exp/eval/eval_test.go
+++ b/src/pkg/exp/eval/eval_test.go
@@ -5,19 +5,19 @@
 package eval
 
 import (
-	"bignum";
-	"flag";
-	"fmt";
-	"log";
-	"os";
-	"reflect";
-	"testing";
+	"bignum"
+	"flag"
+	"fmt"
+	"log"
+	"os"
+	"reflect"
+	"testing"
 )
 
 // Print each statement or expression before parsing it
 var noisy = false
 
-func init()	{ flag.BoolVar(&noisy, "noisy", false, "chatter during eval tests") }
+func init() { flag.BoolVar(&noisy, "noisy", false, "chatter during eval tests") }
 
 /*
  * Generic statement/expression test framework
@@ -26,60 +26,60 @@ func init()	{ flag.BoolVar(&noisy, "noisy", false, "chatter during eval tests")
 type test []job
 
 type job struct {
-	code	string;
-	cerr	string;
-	rterr	string;
-	val	Value;
-	noval	bool;
+	code  string
+	cerr  string
+	rterr string
+	val   Value
+	noval bool
 }
 
 func runTests(t *testing.T, baseName string, tests []test) {
 	for i, test := range tests {
-		name := fmt.Sprintf("%s[%d]", baseName, i);
-		test.run(t, name);
+		name := fmt.Sprintf("%s[%d]", baseName, i)
+		test.run(t, name)
 	}
 }
 
 func (a test) run(t *testing.T, name string) {
-	w := newTestWorld();
+	w := newTestWorld()
 	for _, j := range a {
-		src := j.code;
+		src := j.code
 		if noisy {
 			println("code:", src)
 		}
 
-		code, err := w.Compile(src);
+		code, err := w.Compile(src)
 		if err != nil {
 			if j.cerr == "" {
-				t.Errorf("%s: Compile %s: %v", name, src, err);
-				break;
+				t.Errorf("%s: Compile %s: %v", name, src, err)
+				break
 			}
 			if !match(t, err, j.cerr) {
-				t.Errorf("%s: Compile %s = error %s; want %v", name, src, err, j.cerr);
-				break;
+				t.Errorf("%s: Compile %s = error %s; want %v", name, src, err, j.cerr)
+				break
 			}
-			continue;
+			continue
 		}
 		if j.cerr != "" {
-			t.Errorf("%s: Compile %s succeeded; want %s", name, src, j.cerr);
-			break;
+			t.Errorf("%s: Compile %s succeeded; want %s", name, src, j.cerr)
+			break
 		}
 
-		val, err := code.Run();
+		val, err := code.Run()
 		if err != nil {
 			if j.rterr == "" {
-				t.Errorf("%s: Run %s: %v", name, src, err);
-				break;
+				t.Errorf("%s: Run %s: %v", name, src, err)
+				break
 			}
 			if !match(t, err, j.rterr) {
-				t.Errorf("%s: Run %s = error %s; want %v", name, src, err, j.rterr);
-				break;
+				t.Errorf("%s: Run %s = error %s; want %v", name, src, err, j.rterr)
+				break
 			}
-			continue;
+			continue
 		}
 		if j.rterr != "" {
-			t.Errorf("%s: Run %s succeeded; want %s", name, src, j.rterr);
-			break;
+			t.Errorf("%s: Run %s succeeded; want %s", name, src, j.rterr)
+			break
 		}
 
 		if !j.noval && !reflect.DeepEqual(val, j.val) {
@@ -89,11 +89,11 @@ func (a test) run(t *testing.T, name string) {
 }
 
 func match(t *testing.T, err os.Error, pat string) bool {
-	ok, errstr := testing.MatchString(pat, err.String());
+	ok, errstr := testing.MatchString(pat, err.String())
 	if errstr != "" {
 		t.Fatalf("compile regexp %s: %v", pat, errstr)
 	}
-	return ok;
+	return ok
 }
 
 
@@ -102,10 +102,10 @@ func match(t *testing.T, err os.Error, pat string) bool {
  */
 
 // Expression compile error
-func CErr(expr string, cerr string) test	{ return test([]job{job{code: expr, cerr: cerr}}) }
+func CErr(expr string, cerr string) test { return test([]job{job{code: expr, cerr: cerr}}) }
 
 // Expression runtime error
-func RErr(expr string, rterr string) test	{ return test([]job{job{code: expr, rterr: rterr}}) }
+func RErr(expr string, rterr string) test { return test([]job{job{code: expr, rterr: rterr}}) }
 
 // Expression value
 func Val(expr string, val interface{}) test {
@@ -113,7 +113,7 @@ func Val(expr string, val interface{}) test {
 }
 
 // Statement runs without error
-func Run(stmts string) test	{ return test([]job{job{code: stmts, noval: true}}) }
+func Run(stmts string) test { return test([]job{job{code: stmts, noval: true}}) }
 
 // Two statements without error.
 // TODO(rsc): Should be possible with Run but the parser
@@ -148,55 +148,55 @@ type vstruct []interface{}
 type varray []interface{}
 
 type vslice struct {
-	arr		varray;
-	len, cap	int;
+	arr      varray
+	len, cap int
 }
 
 func toValue(val interface{}) Value {
 	switch val := val.(type) {
 	case bool:
-		r := boolV(val);
-		return &r;
+		r := boolV(val)
+		return &r
 	case uint8:
-		r := uint8V(val);
-		return &r;
+		r := uint8V(val)
+		return &r
 	case uint:
-		r := uintV(val);
-		return &r;
+		r := uintV(val)
+		return &r
 	case int:
-		r := intV(val);
-		return &r;
+		r := intV(val)
+		return &r
 	case *bignum.Integer:
 		return &idealIntV{val}
 	case float:
-		r := floatV(val);
-		return &r;
+		r := floatV(val)
+		return &r
 	case *bignum.Rational:
 		return &idealFloatV{val}
 	case string:
-		r := stringV(val);
-		return &r;
+		r := stringV(val)
+		return &r
 	case vstruct:
-		elems := make([]Value, len(val));
+		elems := make([]Value, len(val))
 		for i, e := range val {
 			elems[i] = toValue(e)
 		}
-		r := structV(elems);
-		return &r;
+		r := structV(elems)
+		return &r
 	case varray:
-		elems := make([]Value, len(val));
+		elems := make([]Value, len(val))
 		for i, e := range val {
 			elems[i] = toValue(e)
 		}
-		r := arrayV(elems);
-		return &r;
+		r := arrayV(elems)
+		return &r
 	case vslice:
 		return &sliceV{Slice{toValue(val.arr).(ArrayValue), int64(val.len), int64(val.cap)}}
 	case Func:
 		return &funcV{val}
 	}
-	log.Crashf("toValue(%T) not implemented", val);
-	panic();
+	log.Crashf("toValue(%T) not implemented", val)
+	panic()
 }
 
 /*
@@ -205,50 +205,50 @@ func toValue(val interface{}) Value {
 
 type testFunc struct{}
 
-func (*testFunc) NewFrame() *Frame	{ return &Frame{nil, &[2]Value{}} }
+func (*testFunc) NewFrame() *Frame { return &Frame{nil, &[2]Value{}} }
 
 func (*testFunc) Call(t *Thread) {
-	n := t.f.Vars[0].(IntValue).Get(t);
+	n := t.f.Vars[0].(IntValue).Get(t)
 
-	res := n + 1;
+	res := n + 1
 
-	t.f.Vars[1].(IntValue).Set(t, res);
+	t.f.Vars[1].(IntValue).Set(t, res)
 }
 
 type oneTwoFunc struct{}
 
-func (*oneTwoFunc) NewFrame() *Frame	{ return &Frame{nil, &[2]Value{}} }
+func (*oneTwoFunc) NewFrame() *Frame { return &Frame{nil, &[2]Value{}} }
 
 func (*oneTwoFunc) Call(t *Thread) {
-	t.f.Vars[0].(IntValue).Set(t, 1);
-	t.f.Vars[1].(IntValue).Set(t, 2);
+	t.f.Vars[0].(IntValue).Set(t, 1)
+	t.f.Vars[1].(IntValue).Set(t, 2)
 }
 
 type voidFunc struct{}
 
-func (*voidFunc) NewFrame() *Frame	{ return &Frame{nil, []Value{}} }
+func (*voidFunc) NewFrame() *Frame { return &Frame{nil, []Value{}} }
 
-func (*voidFunc) Call(t *Thread)	{}
+func (*voidFunc) Call(t *Thread) {}
 
 func newTestWorld() *World {
-	w := NewWorld();
-
-	def := func(name string, t Type, val interface{}) { w.DefineVar(name, t, toValue(val)) };
-
-	w.DefineConst("c", IdealIntType, toValue(bignum.Int(1)));
-	def("i", IntType, 1);
-	def("i2", IntType, 2);
-	def("u", UintType, uint(1));
-	def("f", FloatType, 1.0);
-	def("s", StringType, "abc");
-	def("t", NewStructType([]StructField{StructField{"a", IntType, false}}), vstruct{1});
-	def("ai", NewArrayType(2, IntType), varray{1, 2});
-	def("aai", NewArrayType(2, NewArrayType(2, IntType)), varray{varray{1, 2}, varray{3, 4}});
-	def("aai2", NewArrayType(2, NewArrayType(2, IntType)), varray{varray{5, 6}, varray{7, 8}});
-	def("fn", NewFuncType([]Type{IntType}, false, []Type{IntType}), &testFunc{});
-	def("oneTwo", NewFuncType([]Type{}, false, []Type{IntType, IntType}), &oneTwoFunc{});
-	def("void", NewFuncType([]Type{}, false, []Type{}), &voidFunc{});
-	def("sli", NewSliceType(IntType), vslice{varray{1, 2, 3}, 2, 3});
-
-	return w;
+	w := NewWorld()
+
+	def := func(name string, t Type, val interface{}) { w.DefineVar(name, t, toValue(val)) }
+
+	w.DefineConst("c", IdealIntType, toValue(bignum.Int(1)))
+	def("i", IntType, 1)
+	def("i2", IntType, 2)
+	def("u", UintType, uint(1))
+	def("f", FloatType, 1.0)
+	def("s", StringType, "abc")
+	def("t", NewStructType([]StructField{StructField{"a", IntType, false}}), vstruct{1})
+	def("ai", NewArrayType(2, IntType), varray{1, 2})
+	def("aai", NewArrayType(2, NewArrayType(2, IntType)), varray{varray{1, 2}, varray{3, 4}})
+	def("aai2", NewArrayType(2, NewArrayType(2, IntType)), varray{varray{5, 6}, varray{7, 8}})
+	def("fn", NewFuncType([]Type{IntType}, false, []Type{IntType}), &testFunc{})
+	def("oneTwo", NewFuncType([]Type{}, false, []Type{IntType, IntType}), &oneTwoFunc{})
+	def("void", NewFuncType([]Type{}, false, []Type{}), &voidFunc{})
+	def("sli", NewSliceType(IntType), vslice{varray{1, 2, 3}, 2, 3})
+
+	return w
 }
diff --git a/src/pkg/exp/eval/expr.go b/src/pkg/exp/eval/expr.go
index 1f1bf06343..8e161e5225 100644
--- a/src/pkg/exp/eval/expr.go
+++ b/src/pkg/exp/eval/expr.go
@@ -5,53 +5,53 @@
 package eval
 
 import (
-	"bignum";
-	"go/ast";
-	"go/token";
-	"log";
-	"strconv";
-	"strings";
-	"os";
+	"bignum"
+	"go/ast"
+	"go/token"
+	"log"
+	"strconv"
+	"strings"
+	"os"
 )
 
 // An expr is the result of compiling an expression.  It stores the
 // type of the expression and its evaluator function.
 type expr struct {
-	*exprInfo;
-	t	Type;
+	*exprInfo
+	t Type
 
 	// Evaluate this node as the given type.
-	eval	interface{};
+	eval interface{}
 
 	// Map index expressions permit special forms of assignment,
 	// for which we need to know the Map and key.
-	evalMapValue	func(t *Thread) (Map, interface{});
+	evalMapValue func(t *Thread) (Map, interface{})
 
 	// Evaluate to the "address of" this value; that is, the
 	// settable Value object.  nil for expressions whose address
 	// cannot be taken.
-	evalAddr	func(t *Thread) Value;
+	evalAddr func(t *Thread) Value
 
 	// Execute this expression as a statement.  Only expressions
 	// that are valid expression statements should set this.
-	exec	func(t *Thread);
+	exec func(t *Thread)
 
 	// If this expression is a type, this is its compiled type.
 	// This is only permitted in the function position of a call
 	// expression.  In this case, t should be nil.
-	valType	Type;
+	valType Type
 
 	// A short string describing this expression for error
 	// messages.
-	desc	string;
+	desc string
 }
 
 // exprInfo stores information needed to compile any expression node.
 // Each expr also stores its exprInfo so further expressions can be
 // compiled from it.
 type exprInfo struct {
-	*compiler;
-	pos	token.Position;
+	*compiler
+	pos token.Position
 }
 
 func (a *exprInfo) newExpr(t Type, desc string) *expr {
@@ -84,7 +84,7 @@ func (a *expr) convertTo(t Type) *expr {
 		log.Crashf("attempted to convert from %v, expected ideal", a.t)
 	}
 
-	var rat *bignum.Rational;
+	var rat *bignum.Rational
 
 	// XXX(Spec)  The spec says "It is erroneous".
 	//
@@ -94,14 +94,14 @@ func (a *expr) convertTo(t Type) *expr {
 	// by the type of the variable.
 	switch a.t {
 	case IdealFloatType:
-		rat = a.asIdealFloat()();
+		rat = a.asIdealFloat()()
 		if t.isInteger() && !rat.IsInt() {
-			a.diag("constant %v truncated to integer", ratToString(rat));
-			return nil;
+			a.diag("constant %v truncated to integer", ratToString(rat))
+			return nil
 		}
 	case IdealIntType:
-		i := a.asIdealInt()();
-		rat = bignum.MakeRat(i, bignum.Nat(1));
+		i := a.asIdealInt()()
+		rat = bignum.MakeRat(i, bignum.Nat(1))
 	default:
 		log.Crashf("unexpected ideal type %v", a.t)
 	}
@@ -109,43 +109,43 @@ func (a *expr) convertTo(t Type) *expr {
 	// Check bounds
 	if t, ok := t.lit().(BoundedType); ok {
 		if rat.Cmp(t.minVal()) < 0 {
-			a.diag("constant %v underflows %v", ratToString(rat), t);
-			return nil;
+			a.diag("constant %v underflows %v", ratToString(rat), t)
+			return nil
 		}
 		if rat.Cmp(t.maxVal()) > 0 {
-			a.diag("constant %v overflows %v", ratToString(rat), t);
-			return nil;
+			a.diag("constant %v overflows %v", ratToString(rat), t)
+			return nil
 		}
 	}
 
 	// Convert rat to type t.
-	res := a.newExpr(t, a.desc);
+	res := a.newExpr(t, a.desc)
 	switch t := t.lit().(type) {
 	case *uintType:
-		n, d := rat.Value();
-		f := n.Quo(bignum.MakeInt(false, d));
-		v := f.Abs().Value();
-		res.eval = func(*Thread) uint64 { return v };
+		n, d := rat.Value()
+		f := n.Quo(bignum.MakeInt(false, d))
+		v := f.Abs().Value()
+		res.eval = func(*Thread) uint64 { return v }
 	case *intType:
-		n, d := rat.Value();
-		f := n.Quo(bignum.MakeInt(false, d));
-		v := f.Value();
-		res.eval = func(*Thread) int64 { return v };
+		n, d := rat.Value()
+		f := n.Quo(bignum.MakeInt(false, d))
+		v := f.Value()
+		res.eval = func(*Thread) int64 { return v }
 	case *idealIntType:
-		n, d := rat.Value();
-		f := n.Quo(bignum.MakeInt(false, d));
-		res.eval = func() *bignum.Integer { return f };
+		n, d := rat.Value()
+		f := n.Quo(bignum.MakeInt(false, d))
+		res.eval = func() *bignum.Integer { return f }
 	case *floatType:
-		n, d := rat.Value();
-		v := float64(n.Value()) / float64(d.Value());
-		res.eval = func(*Thread) float64 { return v };
+		n, d := rat.Value()
+		v := float64(n.Value()) / float64(d.Value())
+		res.eval = func(*Thread) float64 { return v }
 	case *idealFloatType:
 		res.eval = func() *bignum.Rational { return rat }
 	default:
 		log.Crashf("cannot convert to type %T", t)
 	}
 
-	return res;
+	return res
 }
 
 // convertToInt converts this expression to an integer, if possible,
@@ -156,35 +156,35 @@ func (a *expr) convertTo(t Type) *expr {
 func (a *expr) convertToInt(max int64, negErr string, errOp string) *expr {
 	switch a.t.lit().(type) {
 	case *idealIntType:
-		val := a.asIdealInt()();
+		val := a.asIdealInt()()
 		if negErr != "" && val.IsNeg() {
-			a.diag("negative %s: %s", negErr, val);
-			return nil;
+			a.diag("negative %s: %s", negErr, val)
+			return nil
 		}
-		bound := max;
+		bound := max
 		if negErr == "slice" {
 			bound++
 		}
 		if max != -1 && val.Cmp(bignum.Int(bound)) >= 0 {
-			a.diag("index %s exceeds length %d", val, max);
-			return nil;
+			a.diag("index %s exceeds length %d", val, max)
+			return nil
 		}
-		return a.convertTo(IntType);
+		return a.convertTo(IntType)
 
 	case *uintType:
 		// Convert to int
-		na := a.newExpr(IntType, a.desc);
-		af := a.asUint();
-		na.eval = func(t *Thread) int64 { return int64(af(t)) };
-		return na;
+		na := a.newExpr(IntType, a.desc)
+		af := a.asUint()
+		na.eval = func(t *Thread) int64 { return int64(af(t)) }
+		return na
 
 	case *intType:
 		// Good as is
 		return a
 	}
 
-	a.diag("illegal operand type for %s\n\t%v", errOp, a.t);
-	return nil;
+	a.diag("illegal operand type for %s\n\t%v", errOp, a.t)
+	return nil
 }
 
 // derefArray returns an expression of array type if the given
@@ -193,14 +193,14 @@ func (a *expr) convertToInt(max int64, negErr string, errOp string) *expr {
 func (a *expr) derefArray() *expr {
 	if pt, ok := a.t.lit().(*PtrType); ok {
 		if _, ok := pt.Elem.lit().(*ArrayType); ok {
-			deref := a.compileStarExpr(a);
+			deref := a.compileStarExpr(a)
 			if deref == nil {
 				log.Crashf("failed to dereference *array")
 			}
-			return deref;
+			return deref
 		}
 	}
-	return a;
+	return a
 }
 
 /*
@@ -221,25 +221,25 @@ func (a *expr) derefArray() *expr {
 //    Assigning a single expression with multi-valued type to a
 //    multi-valued type.
 type assignCompiler struct {
-	*compiler;
-	pos	token.Position;
+	*compiler
+	pos token.Position
 	// The RHS expressions.  This may include nil's for
 	// expressions that failed to compile.
-	rs	[]*expr;
+	rs []*expr
 	// The (possibly unary) MultiType of the RHS.
-	rmt	*MultiType;
+	rmt *MultiType
 	// Whether this is an unpack assignment (case 3).
-	isUnpack	bool;
+	isUnpack bool
 	// Whether map special assignment forms are allowed.
-	allowMap	bool;
+	allowMap bool
 	// Whether this is a "r, ok = a[x]" assignment.
-	isMapUnpack	bool;
+	isMapUnpack bool
 	// The operation name to use in error messages, such as
 	// "assignment" or "function call".
-	errOp	string;
+	errOp string
 	// The name to use for positions in error messages, such as
 	// "argument".
-	errPosName	string;
+	errPosName string
 }
 
 // Type check the RHS of an assignment, returning a new assignCompiler
@@ -254,48 +254,48 @@ func (a *compiler) checkAssign(pos token.Position, rs []*expr, errOp, errPosName
 		rs: rs,
 		errOp: errOp,
 		errPosName: errPosName,
-	};
+	}
 
 	// Is this an unpack?
 	if len(rs) == 1 && rs[0] != nil {
 		if rmt, isUnpack := rs[0].t.(*MultiType); isUnpack {
-			c.rmt = rmt;
-			c.isUnpack = true;
-			return c, true;
+			c.rmt = rmt
+			c.isUnpack = true
+			return c, true
 		}
 	}
 
 	// Create MultiType for RHS and check that all RHS expressions
 	// are single-valued.
-	rts := make([]Type, len(rs));
-	ok := true;
+	rts := make([]Type, len(rs))
+	ok := true
 	for i, r := range rs {
 		if r == nil {
-			ok = false;
-			continue;
+			ok = false
+			continue
 		}
 
 		if _, isMT := r.t.(*MultiType); isMT {
-			r.diag("multi-valued expression not allowed in %s", errOp);
-			ok = false;
-			continue;
+			r.diag("multi-valued expression not allowed in %s", errOp)
+			ok = false
+			continue
 		}
 
-		rts[i] = r.t;
+		rts[i] = r.t
 	}
 
-	c.rmt = NewMultiType(rts);
-	return c, ok;
+	c.rmt = NewMultiType(rts)
+	return c, ok
 }
 
 func (a *assignCompiler) allowMapForms(nls int) {
-	a.allowMap = true;
+	a.allowMap = true
 
 	// Update unpacking info if this is r, ok = a[x]
 	if nls == 2 && len(a.rs) == 1 && a.rs[0] != nil && a.rs[0].evalMapValue != nil {
-		a.isUnpack = true;
-		a.rmt = NewMultiType([]Type{a.rs[0].t, BoolType});
-		a.isMapUnpack = true;
+		a.isUnpack = true
+		a.rmt = NewMultiType([]Type{a.rs[0].t, BoolType})
+		a.isMapUnpack = true
 	}
 }
 
@@ -304,8 +304,8 @@ func (a *assignCompiler) allowMapForms(nls int) {
 // evaluate the RHS expressions.  The l-value must have exactly the
 // type given by lt.  Returns nil if type checking fails.
 func (a *assignCompiler) compile(b *block, lt Type) (func(Value, *Thread)) {
-	lmt, isMT := lt.(*MultiType);
-	rmt, isUnpack := a.rmt, a.isUnpack;
+	lmt, isMT := lt.(*MultiType)
+	rmt, isUnpack := a.rmt, a.isUnpack
 
 	// Create unary MultiType for single LHS
 	if !isMT {
@@ -313,61 +313,61 @@ func (a *assignCompiler) compile(b *block, lt Type) (func(Value, *Thread)) {
 	}
 
 	// Check that the assignment count matches
-	lcount := len(lmt.Elems);
-	rcount := len(rmt.Elems);
+	lcount := len(lmt.Elems)
+	rcount := len(rmt.Elems)
 	if lcount != rcount {
-		msg := "not enough";
-		pos := a.pos;
+		msg := "not enough"
+		pos := a.pos
 		if rcount > lcount {
-			msg = "too many";
+			msg = "too many"
 			if lcount > 0 {
 				pos = a.rs[lcount-1].pos
 			}
 		}
-		a.diagAt(&pos, "%s %ss for %s\n\t%s\n\t%s", msg, a.errPosName, a.errOp, lt, rmt);
-		return nil;
+		a.diagAt(&pos, "%s %ss for %s\n\t%s\n\t%s", msg, a.errPosName, a.errOp, lt, rmt)
+		return nil
 	}
 
-	bad := false;
+	bad := false
 
 	// If this is an unpack, create a temporary to store the
 	// multi-value and replace the RHS with expressions to pull
 	// out values from the temporary.  Technically, this is only
 	// necessary when we need to perform assignment conversions.
-	var effect func(*Thread);
+	var effect func(*Thread)
 	if isUnpack {
 		// This leaks a slot, but is definitely safe.
-		temp := b.DefineTemp(a.rmt);
-		tempIdx := temp.Index;
+		temp := b.DefineTemp(a.rmt)
+		tempIdx := temp.Index
 		if tempIdx < 0 {
 			panicln("tempidx", tempIdx)
 		}
 		if a.isMapUnpack {
-			rf := a.rs[0].evalMapValue;
-			vt := a.rmt.Elems[0];
+			rf := a.rs[0].evalMapValue
+			vt := a.rmt.Elems[0]
 			effect = func(t *Thread) {
-				m, k := rf(t);
-				v := m.Elem(t, k);
-				found := boolV(true);
+				m, k := rf(t)
+				v := m.Elem(t, k)
+				found := boolV(true)
 				if v == nil {
-					found = boolV(false);
-					v = vt.Zero();
+					found = boolV(false)
+					v = vt.Zero()
 				}
-				t.f.Vars[tempIdx] = multiV([]Value{v, &found});
-			};
+				t.f.Vars[tempIdx] = multiV([]Value{v, &found})
+			}
 		} else {
-			rf := a.rs[0].asMulti();
-			effect = func(t *Thread) { t.f.Vars[tempIdx] = multiV(rf(t)) };
+			rf := a.rs[0].asMulti()
+			effect = func(t *Thread) { t.f.Vars[tempIdx] = multiV(rf(t)) }
 		}
-		orig := a.rs[0];
-		a.rs = make([]*expr, len(a.rmt.Elems));
+		orig := a.rs[0]
+		a.rs = make([]*expr, len(a.rmt.Elems))
 		for i, t := range a.rmt.Elems {
 			if t.isIdeal() {
 				log.Crashf("Right side of unpack contains ideal: %s", rmt)
 			}
-			a.rs[i] = orig.newExpr(t, orig.desc);
-			index := i;
-			a.rs[i].genValue(func(t *Thread) Value { return t.f.Vars[tempIdx].(multiV)[index] });
+			a.rs[i] = orig.newExpr(t, orig.desc)
+			index := i
+			a.rs[i].genValue(func(t *Thread) Value { return t.f.Vars[tempIdx].(multiV)[index] })
 		}
 	}
 	// Now len(a.rs) == len(a.rmt) and we've reduced any unpacking
@@ -378,18 +378,18 @@ func (a *assignCompiler) compile(b *block, lt Type) (func(Value, *Thread)) {
 	// Values of any type may always be assigned to variables of
 	// compatible static type.
 	for i, lt := range lmt.Elems {
-		rt := rmt.Elems[i];
+		rt := rmt.Elems[i]
 
 		// When [an ideal is] (used in an expression) assigned
 		// to a variable or typed constant, the destination
 		// must be able to represent the assigned value.
 		if rt.isIdeal() {
-			a.rs[i] = a.rs[i].convertTo(lmt.Elems[i]);
+			a.rs[i] = a.rs[i].convertTo(lmt.Elems[i])
 			if a.rs[i] == nil {
-				bad = true;
-				continue;
+				bad = true
+				continue
 			}
-			rt = a.rs[i].t;
+			rt = a.rs[i].t
 		}
 
 		// A pointer p to an array can be assigned to a slice
@@ -399,11 +399,11 @@ func (a *assignCompiler) compile(b *block, lt Type) (func(Value, *Thread)) {
 			if at, ok := rpt.Elem.lit().(*ArrayType); ok {
 				if lst, ok := lt.lit().(*SliceType); ok {
 					if lst.Elem.compat(at.Elem, false) && (rt.lit() == Type(rt) || lt.lit() == Type(lt)) {
-						rf := a.rs[i].asPtr();
-						a.rs[i] = a.rs[i].newExpr(lt, a.rs[i].desc);
-						len := at.Len;
-						a.rs[i].eval = func(t *Thread) Slice { return Slice{rf(t).(ArrayValue), len, len} };
-						rt = a.rs[i].t;
+						rf := a.rs[i].asPtr()
+						a.rs[i] = a.rs[i].newExpr(lt, a.rs[i].desc)
+						len := at.Len
+						a.rs[i].eval = func(t *Thread) Slice { return Slice{rf(t).(ArrayValue), len, len} }
+						rt = a.rs[i].t
 					}
 				}
 			}
@@ -415,7 +415,7 @@ func (a *assignCompiler) compile(b *block, lt Type) (func(Value, *Thread)) {
 			} else {
 				a.rs[i].diag("illegal operand types in %s %d of %s\n\t%v\n\t%v", a.errPosName, i+1, a.errOp, lt, rt)
 			}
-			bad = true;
+			bad = true
 		}
 	}
 	if bad {
@@ -428,7 +428,7 @@ func (a *assignCompiler) compile(b *block, lt Type) (func(Value, *Thread)) {
 		return genAssign(lt, a.rs[0])
 	}
 	// Case 2 or 3
-	as := make([]func(lv Value, t *Thread), len(a.rs));
+	as := make([]func(lv Value, t *Thread), len(a.rs))
 	for i, r := range a.rs {
 		as[i] = genAssign(lmt.Elems[i], r)
 	}
@@ -436,22 +436,22 @@ func (a *assignCompiler) compile(b *block, lt Type) (func(Value, *Thread)) {
 		if effect != nil {
 			effect(t)
 		}
-		lmv := lv.(multiV);
+		lmv := lv.(multiV)
 		for i, a := range as {
 			a(lmv[i], t)
 		}
-	};
+	}
 }
 
 // compileAssign compiles an assignment operation without the full
 // generality of an assignCompiler.  See assignCompiler for a
 // description of the arguments.
 func (a *compiler) compileAssign(pos token.Position, b *block, lt Type, rs []*expr, errOp, errPosName string) (func(Value, *Thread)) {
-	ac, ok := a.checkAssign(pos, rs, errOp, errPosName);
+	ac, ok := a.checkAssign(pos, rs, errOp, errPosName)
 	if !ok {
 		return nil
 	}
-	return ac.compile(b, lt);
+	return ac.compile(b, lt)
 }
 
 /*
@@ -462,11 +462,11 @@ func (a *compiler) compileAssign(pos token.Position, b *block, lt Type, rs []*ex
 // of a single expression.  It does not embed funcCompiler because
 // expressions can appear at top level.
 type exprCompiler struct {
-	*compiler;
+	*compiler
 	// The block this expression is being compiled in.
-	block	*block;
+	block *block
 	// Whether this expression is used in a constant context.
-	constant	bool;
+	constant bool
 }
 
 // compile compiles an expression AST.  callCtx should be true if this
@@ -474,7 +474,7 @@ type exprCompiler struct {
 // the returned expression to be a type or a built-in function (which
 // otherwise result in errors).
 func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {
-	ei := &exprInfo{a.compiler, x.Pos()};
+	ei := &exprInfo{a.compiler, x.Pos()}
 
 	switch x := x.(type) {
 	// Literals
@@ -496,21 +496,21 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {
 		goto notimpl
 
 	case *ast.FuncLit:
-		decl := ei.compileFuncType(a.block, x.Type);
+		decl := ei.compileFuncType(a.block, x.Type)
 		if decl == nil {
 			// TODO(austin) Try compiling the body,
 			// perhaps with dummy argument definitions
 			return nil
 		}
-		fn := ei.compileFunc(a.block, decl, x.Body);
+		fn := ei.compileFunc(a.block, decl, x.Body)
 		if fn == nil {
 			return nil
 		}
 		if a.constant {
-			a.diagAt(x, "function literal used in constant expression");
-			return nil;
+			a.diagAt(x, "function literal used in constant expression")
+			return nil
 		}
-		return ei.compileFuncLit(decl, fn);
+		return ei.compileFuncLit(decl, fn)
 
 	// Types
 	case *ast.ArrayType:
@@ -535,24 +535,24 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {
 	// Remaining expressions
 	case *ast.BadExpr:
 		// Error already reported by parser
-		a.silentErrors++;
-		return nil;
+		a.silentErrors++
+		return nil
 
 	case *ast.BinaryExpr:
-		l, r := a.compile(x.X, false), a.compile(x.Y, false);
+		l, r := a.compile(x.X, false), a.compile(x.Y, false)
 		if l == nil || r == nil {
 			return nil
 		}
-		return ei.compileBinaryExpr(x.Op, l, r);
+		return ei.compileBinaryExpr(x.Op, l, r)
 
 	case *ast.CallExpr:
-		l := a.compile(x.Fun, true);
-		args := make([]*expr, len(x.Args));
-		bad := false;
+		l := a.compile(x.Fun, true)
+		args := make([]*expr, len(x.Args))
+		bad := false
 		for i, arg := range x.Args {
 			if i == 0 && l != nil && (l.t == Type(makeType) || l.t == Type(newType)) {
-				argei := &exprInfo{a.compiler, arg.Pos()};
-				args[i] = argei.exprFromType(a.compileType(a.block, arg));
+				argei := &exprInfo{a.compiler, arg.Pos()}
+				args[i] = argei.exprFromType(a.compileType(a.block, arg))
 			} else {
 				args[i] = a.compile(arg, false)
 			}
@@ -564,13 +564,13 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {
 			return nil
 		}
 		if a.constant {
-			a.diagAt(x, "function call in constant context");
-			return nil;
+			a.diagAt(x, "function call in constant context")
+			return nil
 		}
 
 		if l.valType != nil {
-			a.diagAt(x, "type conversions not implemented");
-			return nil;
+			a.diagAt(x, "type conversions not implemented")
+			return nil
 		} else if ft, ok := l.t.(*FuncType); ok && ft.builtin != "" {
 			return ei.compileBuiltinCallExpr(a.block, ft, args)
 		} else {
@@ -581,25 +581,25 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {
 		return ei.compileIdent(a.block, a.constant, callCtx, x.Value)
 
 	case *ast.IndexExpr:
-		l, r := a.compile(x.X, false), a.compile(x.Index, false);
+		l, r := a.compile(x.X, false), a.compile(x.Index, false)
 		if l == nil || r == nil {
 			return nil
 		}
-		return ei.compileIndexExpr(l, r);
+		return ei.compileIndexExpr(l, r)
 
 	case *ast.SliceExpr:
-		end := x.End;
+		end := x.End
 		if end == nil {
 			// TODO: set end to len(x.X)
 			panic("unimplemented")
 		}
-		arr := a.compile(x.X, false);
-		lo := a.compile(x.Index, false);
-		hi := a.compile(end, false);
+		arr := a.compile(x.X, false)
+		lo := a.compile(x.Index, false)
+		hi := a.compile(end, false)
 		if arr == nil || lo == nil || hi == nil {
 			return nil
 		}
-		return ei.compileSliceExpr(arr, lo, hi);
+		return ei.compileSliceExpr(arr, lo, hi)
 
 	case *ast.KeyValueExpr:
 		goto notimpl
@@ -608,16 +608,16 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {
 		return a.compile(x.X, callCtx)
 
 	case *ast.SelectorExpr:
-		v := a.compile(x.X, false);
+		v := a.compile(x.X, false)
 		if v == nil {
 			return nil
 		}
-		return ei.compileSelectorExpr(v, x.Sel.Value);
+		return ei.compileSelectorExpr(v, x.Sel.Value)
 
 	case *ast.StarExpr:
 		// We pass down our call context because this could be
 		// a pointer type (and thus a type conversion)
-		v := a.compile(x.X, callCtx);
+		v := a.compile(x.X, callCtx)
 		if v == nil {
 			return nil
 		}
@@ -625,13 +625,13 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {
 			// Turns out this was a pointer type, not a dereference
 			return ei.exprFromType(NewPtrType(v.valType))
 		}
-		return ei.compileStarExpr(v);
+		return ei.compileStarExpr(v)
 
 	case *ast.StringList:
-		strings := make([]*expr, len(x.Strings));
-		bad := false;
+		strings := make([]*expr, len(x.Strings))
+		bad := false
 		for i, s := range x.Strings {
-			strings[i] = a.compile(s, false);
+			strings[i] = a.compile(s, false)
 			if strings[i] == nil {
 				bad = true
 			}
@@ -639,7 +639,7 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {
 		if bad {
 			return nil
 		}
-		return ei.compileStringList(strings);
+		return ei.compileStringList(strings)
 
 	case *ast.StructType:
 		goto notimpl
@@ -648,138 +648,138 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {
 		goto notimpl
 
 	case *ast.UnaryExpr:
-		v := a.compile(x.X, false);
+		v := a.compile(x.X, false)
 		if v == nil {
 			return nil
 		}
-		return ei.compileUnaryExpr(x.Op, v);
+		return ei.compileUnaryExpr(x.Op, v)
 	}
-	log.Crashf("unexpected ast node type %T", x);
-	panic();
+	log.Crashf("unexpected ast node type %T", x)
+	panic()
 
 typeexpr:
 	if !callCtx {
-		a.diagAt(x, "type used as expression");
-		return nil;
+		a.diagAt(x, "type used as expression")
+		return nil
 	}
-	return ei.exprFromType(a.compileType(a.block, x));
+	return ei.exprFromType(a.compileType(a.block, x))
 
 notimpl:
-	a.diagAt(x, "%T expression node not implemented", x);
-	return nil;
+	a.diagAt(x, "%T expression node not implemented", x)
+	return nil
 }
 
 func (a *exprInfo) exprFromType(t Type) *expr {
 	if t == nil {
 		return nil
 	}
-	expr := a.newExpr(nil, "type");
-	expr.valType = t;
-	return expr;
+	expr := a.newExpr(nil, "type")
+	expr.valType = t
+	return expr
 }
 
 func (a *exprInfo) compileIdent(b *block, constant bool, callCtx bool, name string) *expr {
-	bl, level, def := b.Lookup(name);
+	bl, level, def := b.Lookup(name)
 	if def == nil {
-		a.diag("%s: undefined", name);
-		return nil;
+		a.diag("%s: undefined", name)
+		return nil
 	}
 	switch def := def.(type) {
 	case *Constant:
-		expr := a.newExpr(def.Type, "constant");
+		expr := a.newExpr(def.Type, "constant")
 		if ft, ok := def.Type.(*FuncType); ok && ft.builtin != "" {
 			// XXX(Spec) I don't think anything says that
 			// built-in functions can't be used as values.
 			if !callCtx {
-				a.diag("built-in function %s cannot be used as a value", ft.builtin);
-				return nil;
+				a.diag("built-in function %s cannot be used as a value", ft.builtin)
+				return nil
 			}
 			// Otherwise, we leave the evaluators empty
 			// because this is handled specially
 		} else {
 			expr.genConstant(def.Value)
 		}
-		return expr;
+		return expr
 	case *Variable:
 		if constant {
-			a.diag("variable %s used in constant expression", name);
-			return nil;
+			a.diag("variable %s used in constant expression", name)
+			return nil
 		}
 		if bl.global {
 			return a.compileGlobalVariable(def)
 		}
-		return a.compileVariable(level, def);
+		return a.compileVariable(level, def)
 	case Type:
 		if callCtx {
 			return a.exprFromType(def)
 		}
-		a.diag("type %v used as expression", name);
-		return nil;
+		a.diag("type %v used as expression", name)
+		return nil
 	}
-	log.Crashf("name %s has unknown type %T", name, def);
-	panic();
+	log.Crashf("name %s has unknown type %T", name, def)
+	panic()
 }
 
 func (a *exprInfo) compileVariable(level int, v *Variable) *expr {
 	if v.Type == nil {
 		// Placeholder definition from an earlier error
-		a.silentErrors++;
-		return nil;
+		a.silentErrors++
+		return nil
 	}
-	expr := a.newExpr(v.Type, "variable");
-	expr.genIdentOp(level, v.Index);
-	return expr;
+	expr := a.newExpr(v.Type, "variable")
+	expr.genIdentOp(level, v.Index)
+	return expr
 }
 
 func (a *exprInfo) compileGlobalVariable(v *Variable) *expr {
 	if v.Type == nil {
 		// Placeholder definition from an earlier error
-		a.silentErrors++;
-		return nil;
+		a.silentErrors++
+		return nil
 	}
 	if v.Init == nil {
 		v.Init = v.Type.Zero()
 	}
-	expr := a.newExpr(v.Type, "variable");
-	val := v.Init;
-	expr.genValue(func(t *Thread) Value { return val });
-	return expr;
+	expr := a.newExpr(v.Type, "variable")
+	val := v.Init
+	expr.genValue(func(t *Thread) Value { return val })
+	return expr
 }
 
 func (a *exprInfo) compileIdealInt(i *bignum.Integer, desc string) *expr {
-	expr := a.newExpr(IdealIntType, desc);
-	expr.eval = func() *bignum.Integer { return i };
-	return expr;
+	expr := a.newExpr(IdealIntType, desc)
+	expr.eval = func() *bignum.Integer { return i }
+	return expr
 }
 
 func (a *exprInfo) compileIntLit(lit string) *expr {
-	i, _, _ := bignum.IntFromString(lit, 0);
-	return a.compileIdealInt(i, "integer literal");
+	i, _, _ := bignum.IntFromString(lit, 0)
+	return a.compileIdealInt(i, "integer literal")
 }
 
 func (a *exprInfo) compileCharLit(lit string) *expr {
 	if lit[0] != '\'' {
 		// Caught by parser
-		a.silentErrors++;
-		return nil;
+		a.silentErrors++
+		return nil
 	}
-	v, _, tail, err := strconv.UnquoteChar(lit[1:], '\'');
+	v, _, tail, err := strconv.UnquoteChar(lit[1:], '\'')
 	if err != nil || tail != "'" {
 		// Caught by parser
-		a.silentErrors++;
-		return nil;
+		a.silentErrors++
+		return nil
 	}
-	return a.compileIdealInt(bignum.Int(int64(v)), "character literal");
+	return a.compileIdealInt(bignum.Int(int64(v)), "character literal")
 }
 
 func (a *exprInfo) compileFloatLit(lit string) *expr {
-	f, _, n := bignum.RatFromString(lit, 0);
+	f, _, n := bignum.RatFromString(lit, 0)
 	if n != len(lit) {
 		log.Crashf("malformed float literal %s at %v passed parser", lit, a.pos)
 	}
-	expr := a.newExpr(IdealFloatType, "float literal");
-	expr.eval = func() *bignum.Rational { return f };
-	return expr;
+	expr := a.newExpr(IdealFloatType, "float literal")
+	expr.eval = func() *bignum.Rational { return f }
+	return expr
 }
 
 func (a *exprInfo) compileString(s string) *expr {
@@ -787,47 +787,47 @@ func (a *exprInfo) compileString(s string) *expr {
 	// compatible with type string.
 
 	// TODO(austin) Use unnamed string type.
-	expr := a.newExpr(StringType, "string literal");
-	expr.eval = func(*Thread) string { return s };
-	return expr;
+	expr := a.newExpr(StringType, "string literal")
+	expr.eval = func(*Thread) string { return s }
+	return expr
 }
 
 func (a *exprInfo) compileStringLit(lit string) *expr {
-	s, err := strconv.Unquote(lit);
+	s, err := strconv.Unquote(lit)
 	if err != nil {
-		a.diag("illegal string literal, %v", err);
-		return nil;
+		a.diag("illegal string literal, %v", err)
+		return nil
 	}
-	return a.compileString(s);
+	return a.compileString(s)
 }
 
 func (a *exprInfo) compileStringList(list []*expr) *expr {
-	ss := make([]string, len(list));
+	ss := make([]string, len(list))
 	for i, s := range list {
 		ss[i] = s.asString()(nil)
 	}
-	return a.compileString(strings.Join(ss, ""));
+	return a.compileString(strings.Join(ss, ""))
 }
 
 func (a *exprInfo) compileFuncLit(decl *FuncDecl, fn func(*Thread) Func) *expr {
-	expr := a.newExpr(decl.Type, "function literal");
-	expr.eval = fn;
-	return expr;
+	expr := a.newExpr(decl.Type, "function literal")
+	expr.eval = fn
+	return expr
 }
 
 func (a *exprInfo) compileSelectorExpr(v *expr, name string) *expr {
 	// mark marks a field that matches the selector name.  It
 	// tracks the best depth found so far and whether more than
 	// one field has been found at that depth.
-	bestDepth := -1;
-	ambig := false;
-	amberr := "";
+	bestDepth := -1
+	ambig := false
+	amberr := ""
 	mark := func(depth int, pathName string) {
 		switch {
 		case bestDepth == -1 || depth < bestDepth:
-			bestDepth = depth;
-			ambig = false;
-			amberr = "";
+			bestDepth = depth
+			ambig = false
+			amberr = ""
 
 		case depth == bestDepth:
 			ambig = true
@@ -835,10 +835,10 @@ func (a *exprInfo) compileSelectorExpr(v *expr, name string) *expr {
 		default:
 			log.Crashf("Marked field at depth %d, but already found one at depth %d", depth, bestDepth)
 		}
-		amberr += "\n\t" + pathName[1:];
-	};
+		amberr += "\n\t" + pathName[1:]
+	}
 
-	visited := make(map[Type]bool);
+	visited := make(map[Type]bool)
 
 	// find recursively searches for the named field, starting at
 	// type t.  If it finds the named field, it returns a function
@@ -850,7 +850,7 @@ func (a *exprInfo) compileSelectorExpr(v *expr, name string) *expr {
 	// TODO(austin) Now that the expression compiler works on
 	// semantic values instead of AST's, there should be a much
 	// better way of doing this.
-	var find func(Type, int, string) (func(*expr) *expr);
+	var find func(Type, int, string) (func(*expr) *expr)
 	find = func(t Type, depth int, pathName string) (func(*expr) *expr) {
 		// Don't bother looking if we've found something shallower
 		if bestDepth != -1 && bestDepth < depth {
@@ -861,37 +861,37 @@ func (a *exprInfo) compileSelectorExpr(v *expr, name string) *expr {
 		if _, ok := visited[t]; ok {
 			return nil
 		}
-		visited[t] = true;
+		visited[t] = true
 
 		// Implicit dereference
-		deref := false;
+		deref := false
 		if ti, ok := t.(*PtrType); ok {
-			deref = true;
-			t = ti.Elem;
+			deref = true
+			t = ti.Elem
 		}
 
 		// If it's a named type, look for methods
 		if ti, ok := t.(*NamedType); ok {
-			_, ok := ti.methods[name];
+			_, ok := ti.methods[name]
 			if ok {
-				mark(depth, pathName+"."+name);
-				log.Crash("Methods not implemented");
+				mark(depth, pathName+"."+name)
+				log.Crash("Methods not implemented")
 			}
-			t = ti.Def;
+			t = ti.Def
 		}
 
 		// If it's a struct type, check fields and embedded types
-		var builder func(*expr) *expr;
+		var builder func(*expr) *expr
 		if t, ok := t.(*StructType); ok {
 			for i, f := range t.Elems {
-				var sub func(*expr) *expr;
+				var sub func(*expr) *expr
 				switch {
 				case f.Name == name:
-					mark(depth, pathName+"."+name);
-					sub = func(e *expr) *expr { return e };
+					mark(depth, pathName+"."+name)
+					sub = func(e *expr) *expr { return e }
 
 				case f.Anonymous:
-					sub = find(f.Type, depth+1, pathName+"."+f.Name);
+					sub = find(f.Type, depth+1, pathName+"."+f.Name)
 					if sub == nil {
 						continue
 					}
@@ -902,48 +902,48 @@ func (a *exprInfo) compileSelectorExpr(v *expr, name string) *expr {
 
 				// We found something.  Create a
 				// builder for accessing this field.
-				ft := f.Type;
-				index := i;
+				ft := f.Type
+				index := i
 				builder = func(parent *expr) *expr {
 					if deref {
 						parent = a.compileStarExpr(parent)
 					}
-					expr := a.newExpr(ft, "selector expression");
-					pf := parent.asStruct();
-					evalAddr := func(t *Thread) Value { return pf(t).Field(t, index) };
-					expr.genValue(evalAddr);
-					return sub(expr);
-				};
+					expr := a.newExpr(ft, "selector expression")
+					pf := parent.asStruct()
+					evalAddr := func(t *Thread) Value { return pf(t).Field(t, index) }
+					expr.genValue(evalAddr)
+					return sub(expr)
+				}
 			}
 		}
 
-		return builder;
-	};
+		return builder
+	}
 
-	builder := find(v.t, 0, "");
+	builder := find(v.t, 0, "")
 	if builder == nil {
-		a.diag("type %v has no field or method %s", v.t, name);
-		return nil;
+		a.diag("type %v has no field or method %s", v.t, name)
+		return nil
 	}
 	if ambig {
-		a.diag("field %s is ambiguous in type %v%s", name, v.t, amberr);
-		return nil;
+		a.diag("field %s is ambiguous in type %v%s", name, v.t, amberr)
+		return nil
 	}
 
-	return builder(v);
+	return builder(v)
 }
 
 func (a *exprInfo) compileSliceExpr(arr, lo, hi *expr) *expr {
 	// Type check object
-	arr = arr.derefArray();
+	arr = arr.derefArray()
 
-	var at Type;
-	var maxIndex int64 = -1;
+	var at Type
+	var maxIndex int64 = -1
 
 	switch lt := arr.t.lit().(type) {
 	case *ArrayType:
-		at = NewSliceType(lt.Elem);
-		maxIndex = lt.Len;
+		at = NewSliceType(lt.Elem)
+		maxIndex = lt.Len
 
 	case *SliceType:
 		at = lt
@@ -952,105 +952,105 @@ func (a *exprInfo) compileSliceExpr(arr, lo, hi *expr) *expr {
 		at = lt
 
 	default:
-		a.diag("cannot slice %v", arr.t);
-		return nil;
+		a.diag("cannot slice %v", arr.t)
+		return nil
 	}
 
 	// Type check index and convert to int
 	// XXX(Spec) It's unclear if ideal floats with no
 	// fractional part are allowed here.  6g allows it.  I
 	// believe that's wrong.
-	lo = lo.convertToInt(maxIndex, "slice", "slice");
-	hi = hi.convertToInt(maxIndex, "slice", "slice");
+	lo = lo.convertToInt(maxIndex, "slice", "slice")
+	hi = hi.convertToInt(maxIndex, "slice", "slice")
 	if lo == nil || hi == nil {
 		return nil
 	}
 
-	expr := a.newExpr(at, "slice expression");
+	expr := a.newExpr(at, "slice expression")
 
 	// Compile
-	lof := lo.asInt();
-	hif := hi.asInt();
+	lof := lo.asInt()
+	hif := hi.asInt()
 	switch lt := arr.t.lit().(type) {
 	case *ArrayType:
-		arrf := arr.asArray();
-		bound := lt.Len;
+		arrf := arr.asArray()
+		bound := lt.Len
 		expr.eval = func(t *Thread) Slice {
-			arr, lo, hi := arrf(t), lof(t), hif(t);
+			arr, lo, hi := arrf(t), lof(t), hif(t)
 			if lo > hi || hi > bound || lo < 0 {
 				t.Abort(SliceError{lo, hi, bound})
 			}
-			return Slice{arr.Sub(lo, bound-lo), hi - lo, bound - lo};
-		};
+			return Slice{arr.Sub(lo, bound-lo), hi - lo, bound - lo}
+		}
 
 	case *SliceType:
-		arrf := arr.asSlice();
+		arrf := arr.asSlice()
 		expr.eval = func(t *Thread) Slice {
-			arr, lo, hi := arrf(t), lof(t), hif(t);
+			arr, lo, hi := arrf(t), lof(t), hif(t)
 			if lo > hi || hi > arr.Cap || lo < 0 {
 				t.Abort(SliceError{lo, hi, arr.Cap})
 			}
-			return Slice{arr.Base.Sub(lo, arr.Cap-lo), hi - lo, arr.Cap - lo};
-		};
+			return Slice{arr.Base.Sub(lo, arr.Cap-lo), hi - lo, arr.Cap - lo}
+		}
 
 	case *stringType:
-		arrf := arr.asString();
+		arrf := arr.asString()
 		// TODO(austin) This pulls over the whole string in a
 		// remote setting, instead of creating a substring backed
 		// by remote memory.
 		expr.eval = func(t *Thread) string {
-			arr, lo, hi := arrf(t), lof(t), hif(t);
+			arr, lo, hi := arrf(t), lof(t), hif(t)
 			if lo > hi || hi > int64(len(arr)) || lo < 0 {
 				t.Abort(SliceError{lo, hi, int64(len(arr))})
 			}
-			return arr[lo:hi];
-		};
+			return arr[lo:hi]
+		}
 
 	default:
 		log.Crashf("unexpected left operand type %T", arr.t.lit())
 	}
 
-	return expr;
+	return expr
 }
 
 func (a *exprInfo) compileIndexExpr(l, r *expr) *expr {
 	// Type check object
-	l = l.derefArray();
+	l = l.derefArray()
 
-	var at Type;
-	intIndex := false;
-	var maxIndex int64 = -1;
+	var at Type
+	intIndex := false
+	var maxIndex int64 = -1
 
 	switch lt := l.t.lit().(type) {
 	case *ArrayType:
-		at = lt.Elem;
-		intIndex = true;
-		maxIndex = lt.Len;
+		at = lt.Elem
+		intIndex = true
+		maxIndex = lt.Len
 
 	case *SliceType:
-		at = lt.Elem;
-		intIndex = true;
+		at = lt.Elem
+		intIndex = true
 
 	case *stringType:
-		at = Uint8Type;
-		intIndex = true;
+		at = Uint8Type
+		intIndex = true
 
 	case *MapType:
-		at = lt.Elem;
+		at = lt.Elem
 		if r.t.isIdeal() {
-			r = r.convertTo(lt.Key);
+			r = r.convertTo(lt.Key)
 			if r == nil {
 				return nil
 			}
 		}
 		if !lt.Key.compat(r.t, false) {
-			a.diag("cannot use %s as index into %s", r.t, lt);
-			return nil;
+			a.diag("cannot use %s as index into %s", r.t, lt)
+			return nil
 		}
 
 	default:
-		a.diag("cannot index into %v", l.t);
-		return nil;
+		a.diag("cannot index into %v", l.t)
+		return nil
 	}
 
 	// Type check index and convert to int if necessary
@@ -1058,83 +1058,83 @@ func (a *exprInfo) compileIndexExpr(l, r *expr) *expr {
 		// XXX(Spec) It's unclear if ideal floats with no
 		// fractional part are allowed here.  6g allows it.  I
 		// believe that's wrong.
-		r = r.convertToInt(maxIndex, "index", "index");
+		r = r.convertToInt(maxIndex, "index", "index")
 		if r == nil {
 			return nil
 		}
 	}
 
-	expr := a.newExpr(at, "index expression");
+	expr := a.newExpr(at, "index expression")
 
 	// Compile
 	switch lt := l.t.lit().(type) {
 	case *ArrayType:
-		lf := l.asArray();
-		rf := r.asInt();
-		bound := lt.Len;
+		lf := l.asArray()
+		rf := r.asInt()
+		bound := lt.Len
 		expr.genValue(func(t *Thread) Value {
-			l, r := lf(t), rf(t);
+			l, r := lf(t), rf(t)
 			if r < 0 || r >= bound {
 				t.Abort(IndexError{r, bound})
 			}
-			return l.Elem(t, r);
-		});
+			return l.Elem(t, r)
+		})
 
 	case *SliceType:
-		lf := l.asSlice();
-		rf := r.asInt();
+		lf := l.asSlice()
+		rf := r.asInt()
 		expr.genValue(func(t *Thread) Value {
-			l, r := lf(t), rf(t);
+			l, r := lf(t), rf(t)
 			if l.Base == nil {
 				t.Abort(NilPointerError{})
 			}
 			if r < 0 || r >= l.Len {
 				t.Abort(IndexError{r, l.Len})
 			}
-			return l.Base.Elem(t, r);
-		});
+			return l.Base.Elem(t, r)
+		})
 
 	case *stringType:
-		lf := l.asString();
-		rf := r.asInt();
+		lf := l.asString()
+		rf := r.asInt()
 		// TODO(austin) This pulls over the whole string in a
 		// remote setting, instead of just the one character.
 		expr.eval = func(t *Thread) uint64 {
-			l, r := lf(t), rf(t);
+			l, r := lf(t), rf(t)
 			if r < 0 || r >= int64(len(l)) {
 				t.Abort(IndexError{r, int64(len(l))})
 			}
-			return uint64(l[r]);
-		};
+			return uint64(l[r])
+		}
 
 	case *MapType:
-		lf := l.asMap();
-		rf := r.asInterface();
+		lf := l.asMap()
+		rf := r.asInterface()
 		expr.genValue(func(t *Thread) Value {
-			m := lf(t);
-			k := rf(t);
+			m := lf(t)
+			k := rf(t)
 			if m == nil {
 				t.Abort(NilPointerError{})
 			}
-			e := m.Elem(t, k);
+			e := m.Elem(t, k)
 			if e == nil {
 				t.Abort(KeyError{k})
 			}
-			return e;
-		});
+			return e
+		})
 		// genValue makes things addressable, but map values
 		// aren't addressable.
-		expr.evalAddr = nil;
+		expr.evalAddr = nil
 		expr.evalMapValue = func(t *Thread) (Map, interface{}) {
 			// TODO(austin) Key check?  nil check?
 			return lf(t), rf(t)
-		};
+		}
 
 	default:
 		log.Crashf("unexpected left operand type %T", l.t.lit())
 	}
 
-	return expr;
+	return expr
 }
 
 func (a *exprInfo) compileCallExpr(b *block, l *expr, as []*expr) *expr {
@@ -1148,10 +1148,10 @@ func (a *exprInfo) compileCallExpr(b *block, l *expr, as []*expr) *expr {
 	// type of that type is still whatever it's defined to.  Thus,
 	// in "type Foo int", Foo is still an integer type and in
 	// "type Foo func()", Foo is a function type.
-	lt, ok := l.t.lit().(*FuncType);
+	lt, ok := l.t.lit().(*FuncType)
 	if !ok {
-		a.diag("cannot call non-function type %v", l.t);
-		return nil;
+		a.diag("cannot call non-function type %v", l.t)
+		return nil
 	}
 
 	// The arguments must be single-valued expressions assignment
@@ -1159,14 +1159,14 @@ func (a *exprInfo) compileCallExpr(b *block, l *expr, as []*expr) *expr {
 	//
 	// XXX(Spec) The spec is wrong.  It can also be a single
 	// multi-valued expression.
-	nin := len(lt.In);
-	assign := a.compileAssign(a.pos, b, NewMultiType(lt.In), as, "function call", "argument");
+	nin := len(lt.In)
+	assign := a.compileAssign(a.pos, b, NewMultiType(lt.In), as, "function call", "argument")
 	if assign == nil {
 		return nil
 	}
 
-	var t Type;
-	nout := len(lt.Out);
+	var t Type
+	nout := len(lt.Out)
 	switch nout {
 	case 0:
 		t = EmptyType
@@ -1175,10 +1175,10 @@ func (a *exprInfo) compileCallExpr(b *block, l *expr, as []*expr) *expr {
 	default:
 		t = NewMultiType(lt.Out)
 	}
-	expr := a.newExpr(t, "function call");
+	expr := a.newExpr(t, "function call")
 
 	// Gather argument and out types to initialize frame variables
-	vts := make([]Type, nin+nout);
+	vts := make([]Type, nin+nout)
 	for i, t := range lt.In {
 		vts[i] = t
 	}
@@ -1187,103 +1187,103 @@ func (a *exprInfo) compileCallExpr(b *block, l *expr, as []*expr) *expr {
 	}
 
 	// Compile
-	lf := l.asFunc();
+	lf := l.asFunc()
 	call := func(t *Thread) []Value {
-		fun := lf(t);
-		fr := fun.NewFrame();
+		fun := lf(t)
+		fr := fun.NewFrame()
 		for i, t := range vts {
 			fr.Vars[i] = t.Zero()
 		}
-		assign(multiV(fr.Vars[0:nin]), t);
-		oldf := t.f;
-		t.f = fr;
-		fun.Call(t);
-		t.f = oldf;
-		return fr.Vars[nin : nin+nout];
-	};
-	expr.genFuncCall(call);
+		assign(multiV(fr.Vars[0:nin]), t)
+		oldf := t.f
+		t.f = fr
+		fun.Call(t)
+		t.f = oldf
+		return fr.Vars[nin : nin+nout]
+	}
+	expr.genFuncCall(call)
 
-	return expr;
+	return expr
 }
 
 func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *expr {
 	checkCount := func(min, max int) bool {
 		if len(as) < min {
-			a.diag("not enough arguments to %s", ft.builtin);
-			return false;
+			a.diag("not enough arguments to %s", ft.builtin)
+			return false
 		} else if len(as) > max {
-			a.diag("too many arguments to %s", ft.builtin);
-			return false;
+			a.diag("too many arguments to %s", ft.builtin)
+			return false
 		}
-		return true;
-	};
+		return true
+	}
 
 	switch ft {
 	case capType:
 		if !checkCount(1, 1) {
 			return nil
 		}
-		arg := as[0].derefArray();
-		expr := a.newExpr(IntType, "function call");
+		arg := as[0].derefArray()
+		expr := a.newExpr(IntType, "function call")
 		switch t := arg.t.lit().(type) {
 		case *ArrayType:
 			// TODO(austin) It would be nice if this could
 			// be a constant int.
-			v := t.Len;
-			expr.eval = func(t *Thread) int64 { return v };
+			v := t.Len
+			expr.eval = func(t *Thread) int64 { return v }
 
 		case *SliceType:
-			vf := arg.asSlice();
-			expr.eval = func(t *Thread) int64 { return vf(t).Cap };
+			vf := arg.asSlice()
+			expr.eval = func(t *Thread) int64 { return vf(t).Cap }
 
 		//case *ChanType:
 
 		default:
-			a.diag("illegal argument type for cap function\n\t%v", arg.t);
-			return nil;
+			a.diag("illegal argument type for cap function\n\t%v", arg.t)
+			return nil
 		}
-		return expr;
+		return expr
 
 	case lenType:
 		if !checkCount(1, 1) {
 			return nil
 		}
-		arg := as[0].derefArray();
-		expr := a.newExpr(IntType, "function call");
+		arg := as[0].derefArray()
+		expr := a.newExpr(IntType, "function call")
 		switch t := arg.t.lit().(type) {
 		case *stringType:
-			vf := arg.asString();
-			expr.eval = func(t *Thread) int64 { return int64(len(vf(t))) };
+			vf := arg.asString()
+			expr.eval = func(t *Thread) int64 { return int64(len(vf(t))) }
 
 		case *ArrayType:
 			// TODO(austin) It would be nice if this could
 			// be a constant int.
-			v := t.Len;
-			expr.eval = func(t *Thread) int64 { return v };
+			v := t.Len
+			expr.eval = func(t *Thread) int64 { return v }
 
 		case *SliceType:
-			vf := arg.asSlice();
-			expr.eval = func(t *Thread) int64 { return vf(t).Len };
+			vf := arg.asSlice()
+			expr.eval = func(t *Thread) int64 { return vf(t).Len }
 
 		case *MapType:
-			vf := arg.asMap();
+			vf := arg.asMap()
 			expr.eval = func(t *Thread) int64 {
 				// XXX(Spec) What's the len of an
 				// uninitialized map?
-				m := vf(t);
+				m := vf(t)
 				if m == nil {
 					return 0
 				}
-				return m.Len(t);
-			};
+				return m.Len(t)
+			}
 
 		//case *ChanType:
 
 		default:
-			a.diag("illegal argument type for len function\n\t%v", arg.t);
-			return nil;
+			a.diag("illegal argument type for len function\n\t%v", arg.t)
+			return nil
 		}
-		return expr;
+		return expr
 
 	case makeType:
 		if !checkCount(1, 3) {
@@ -1292,21 +1292,21 @@ func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *e
 		// XXX(Spec) What are the types of the
 		// arguments?  Do they have to be ints?  6g
 		// accepts any integral type.
-		var lenexpr, capexpr *expr;
-		var lenf, capf func(*Thread) int64;
+		var lenexpr, capexpr *expr
+		var lenf, capf func(*Thread) int64
 		if len(as) > 1 {
-			lenexpr = as[1].convertToInt(-1, "length", "make function");
+			lenexpr = as[1].convertToInt(-1, "length", "make function")
 			if lenexpr == nil {
 				return nil
 			}
-			lenf = lenexpr.asInt();
+			lenf = lenexpr.asInt()
 		}
 		if len(as) > 2 {
-			capexpr = as[2].convertToInt(-1, "capacity", "make function");
+			capexpr = as[2].convertToInt(-1, "capacity", "make function")
 			if capexpr == nil {
 				return nil
 			}
-			capf = capexpr.asInt();
+			capf = capexpr.asInt()
 		}
 
 		switch t := as[0].valType.lit().(type) {
@@ -1319,18 +1319,18 @@ func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *e
 			if !checkCount(2, 3) {
 				return nil
 			}
-			et := t.Elem;
-			expr := a.newExpr(t, "function call");
+			et := t.Elem
+			expr := a.newExpr(t, "function call")
 			expr.eval = func(t *Thread) Slice {
-				l := lenf(t);
+				l := lenf(t)
 				// XXX(Spec) What if len or cap is
 				// negative?  The runtime panics.
 				if l < 0 {
 					t.Abort(NegativeLengthError{l})
 				}
-				c := l;
+				c := l
 				if capf != nil {
-					c = capf(t);
+					c = capf(t)
 					if c < 0 {
 						t.Abort(NegativeCapacityError{c})
 					}
@@ -1341,13 +1341,13 @@ func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *e
 						c = l
 					}
 				}
-				base := arrayV(make([]Value, c));
+				base := arrayV(make([]Value, c))
 				for i := int64(0); i < c; i++ {
 					base[i] = et.Zero()
 				}
-				return Slice{&base, l, c};
-			};
-			return expr;
+				return Slice{&base, l, c}
+			}
+			return expr
 
 		case *MapType:
 			// A new, empty map value is made using the
@@ -1357,52 +1357,52 @@ func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *e
 			if !checkCount(1, 2) {
 				return nil
 			}
-			expr := a.newExpr(t, "function call");
+			expr := a.newExpr(t, "function call")
 			expr.eval = func(t *Thread) Map {
 				if lenf == nil {
 					return make(evalMap)
 				}
-				l := lenf(t);
-				return make(evalMap, l);
-			};
-			return expr;
+				l := lenf(t)
+				return make(evalMap, l)
+			}
+			return expr
 
 		//case *ChanType:
 
 		default:
-			a.diag("illegal argument type for make function\n\t%v", as[0].valType);
-			return nil;
+			a.diag("illegal argument type for make function\n\t%v", as[0].valType)
+			return nil
 		}
 
 	case closeType, closedType:
-		a.diag("built-in function %s not implemented", ft.builtin);
-		return nil;
+		a.diag("built-in function %s not implemented", ft.builtin)
+		return nil
 
 	case newType:
 		if !checkCount(1, 1) {
 			return nil
 		}
 
-		t := as[0].valType;
-		expr := a.newExpr(NewPtrType(t), "new");
-		expr.eval = func(*Thread) Value { return t.Zero() };
-		return expr;
+		t := as[0].valType
+		expr := a.newExpr(NewPtrType(t), "new")
+		expr.eval = func(*Thread) Value { return t.Zero() }
+		return expr
 
 	case panicType, paniclnType, printType, printlnType:
-		evals := make([]func(*Thread) interface{}, len(as));
+		evals := make([]func(*Thread) interface{}, len(as))
 		for i, x := range as {
 			evals[i] = x.asInterface()
 		}
-		spaces := ft == paniclnType || ft == printlnType;
-		newline := ft != printType;
+		spaces := ft == paniclnType || ft == printlnType
+		newline := ft != printType
 		printer := func(t *Thread) {
 			for i, eval := range evals {
 				if i > 0 && spaces {
 					print(" ")
 				}
-				v := eval(t);
+				v := eval(t)
 				type stringer interface {
-					String() string;
+					String() string
 				}
 				switch v1 := v.(type) {
 				case bool:
@@ -1424,67 +1424,67 @@ func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *e
 			if newline {
 				print("\n")
 			}
-		};
-		expr := a.newExpr(EmptyType, "print");
-		expr.exec = printer;
+		}
+		expr := a.newExpr(EmptyType, "print")
+		expr.exec = printer
 		if ft == panicType || ft == paniclnType {
 			expr.exec = func(t *Thread) {
-				printer(t);
-				t.Abort(os.NewError("panic"));
+				printer(t)
+				t.Abort(os.NewError("panic"))
 			}
 		}
-		return expr;
+		return expr
 	}
 
-	log.Crashf("unexpected built-in function '%s'", ft.builtin);
-	panic();
+	log.Crashf("unexpected built-in function '%s'", ft.builtin)
+	panic()
 }
 
 func (a *exprInfo) compileStarExpr(v *expr) *expr {
 	switch vt := v.t.lit().(type) {
 	case *PtrType:
-		expr := a.newExpr(vt.Elem, "indirect expression");
-		vf := v.asPtr();
+		expr := a.newExpr(vt.Elem, "indirect expression")
+		vf := v.asPtr()
 		expr.genValue(func(t *Thread) Value {
-			v := vf(t);
+			v := vf(t)
 			if v == nil {
 				t.Abort(NilPointerError{})
 			}
-			return v;
-		});
-		return expr;
+			return v
+		})
+		return expr
 	}
 
-	a.diagOpType(token.MUL, v.t);
-	return nil;
+	a.diagOpType(token.MUL, v.t)
+	return nil
 }
 
 var unaryOpDescs = make(map[token.Token]string)
 
 func (a *exprInfo) compileUnaryExpr(op token.Token, v *expr) *expr {
 	// Type check
-	var t Type;
+	var t Type
 	switch op {
 	case token.ADD, token.SUB:
 		if !v.t.isInteger() && !v.t.isFloat() {
-			a.diagOpType(op, v.t);
-			return nil;
+			a.diagOpType(op, v.t)
+			return nil
 		}
-		t = v.t;
+		t = v.t
 
 	case token.NOT:
 		if !v.t.isBoolean() {
-			a.diagOpType(op, v.t);
-			return nil;
+			a.diagOpType(op, v.t)
+			return nil
 		}
-		t = BoolType;
+		t = BoolType
 
 	case token.XOR:
 		if !v.t.isInteger() {
-			a.diagOpType(op, v.t);
-			return nil;
+			a.diagOpType(op, v.t)
+			return nil
 		}
-		t = v.t;
+		t = v.t
 
 	case token.AND:
 		// The unary prefix address-of operator & generates
@@ -1492,15 +1492,15 @@ func (a *exprInfo) compileUnaryExpr(op token.Token, v *expr) *expr {
 		// variable, pointer indirection, field selector, or
 		// array or slice indexing operation.
 		if v.evalAddr == nil {
-			a.diag("cannot take the address of %s", v.desc);
-			return nil;
+			a.diag("cannot take the address of %s", v.desc)
+			return nil
 		}
 
 		// TODO(austin) Implement "It is illegal to take the
 		// address of a function result variable" once I have
 		// function result variables.
 
-		t = NewPtrType(v.t);
+		t = NewPtrType(v.t)
 
 	case token.ARROW:
 		log.Crashf("Unary op %v not implemented", op)
@@ -1509,19 +1509,19 @@ func (a *exprInfo) compileUnaryExpr(op token.Token, v *expr) *expr {
 		log.Crashf("unknown unary operator %v", op)
 	}
 
-	desc, ok := unaryOpDescs[op];
+	desc, ok := unaryOpDescs[op]
 	if !ok {
-		desc = "unary " + op.String() + " expression";
-		unaryOpDescs[op] = desc;
+		desc = "unary " + op.String() + " expression"
+		unaryOpDescs[op] = desc
 	}
 
 	// Compile
-	expr := a.newExpr(t, desc);
+	expr := a.newExpr(t, desc)
 	switch op {
 	case token.ADD:
 		// Just compile it out
-		expr = v;
-		expr.desc = desc;
+		expr = v
+		expr.desc = desc
 
 	case token.SUB:
 		expr.genUnaryOpNeg(v)
@@ -1533,22 +1533,22 @@ func (a *exprInfo) compileUnaryExpr(op token.Token, v *expr) *expr {
 		expr.genUnaryOpXor(v)
 
 	case token.AND:
-		vf := v.evalAddr;
-		expr.eval = func(t *Thread) Value { return vf(t) };
+		vf := v.evalAddr
+		expr.eval = func(t *Thread) Value { return vf(t) }
 
 	default:
 		log.Crashf("Compilation of unary op %v not implemented", op)
 	}
 
-	return expr;
+	return expr
 }
 
 var binOpDescs = make(map[token.Token]string)
 
 func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 	// Save the original types of l.t and r.t for error messages.
-	origlt := l.t;
-	origrt := r.t;
+	origlt := l.t
+	origrt := r.t
 
 	// XXX(Spec) What is the exact definition of a "named type"?
 
@@ -1594,38 +1594,38 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 
 	// Useful type predicates
 	// TODO(austin) CL 33668 mandates identical types except for comparisons.
-	compat := func() bool { return l.t.compat(r.t, false) };
-	integers := func() bool { return l.t.isInteger() && r.t.isInteger() };
-	floats := func() bool { return l.t.isFloat() && r.t.isFloat() };
+	compat := func() bool { return l.t.compat(r.t, false) }
+	integers := func() bool { return l.t.isInteger() && r.t.isInteger() }
+	floats := func() bool { return l.t.isFloat() && r.t.isFloat() }
 	strings := func() bool {
 		// TODO(austin) Deal with named types
 		return l.t == StringType && r.t == StringType
-	};
-	booleans := func() bool { return l.t.isBoolean() && r.t.isBoolean() };
+	}
+	booleans := func() bool { return l.t.isBoolean() && r.t.isBoolean() }
 
 	// Type check
-	var t Type;
+	var t Type
 	switch op {
 	case token.ADD:
 		if !compat() || (!integers() && !floats() && !strings()) {
-			a.diagOpTypes(op, origlt, origrt);
-			return nil;
+			a.diagOpTypes(op, origlt, origrt)
+			return nil
 		}
-		t = l.t;
+		t = l.t
 
 	case token.SUB, token.MUL, token.QUO:
 		if !compat() || (!integers() && !floats()) {
-			a.diagOpTypes(op, origlt, origrt);
-			return nil;
+			a.diagOpTypes(op, origlt, origrt)
+			return nil
 		}
-		t = l.t;
+		t = l.t
 
 	case token.REM, token.AND, token.OR, token.XOR, token.AND_NOT:
 		if !compat() || !integers() {
-			a.diagOpTypes(op, origlt, origrt);
-			return nil;
+			a.diagOpTypes(op, origlt, origrt)
+			return nil
 		}
-		t = l.t;
+		t = l.t
 
 	case token.SHL, token.SHR:
 		// XXX(Spec) Is it okay for the right operand to be an
@@ -1636,8 +1636,8 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 		// (ยงArithmetic operators)" suggests so and 6g agrees.
 
 		if !l.t.isInteger() || !(r.t.isInteger() || r.t.isIdeal()) {
-			a.diagOpTypes(op, origlt, origrt);
-			return nil;
+			a.diagOpTypes(op, origlt, origrt)
+			return nil
 		}
 
 		// The right operand in a shift operation must be
@@ -1645,7 +1645,7 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 		// number that can be safely converted into an
 		// unsigned integer type.
 		if r.t.isIdeal() {
-			r2 := r.convertTo(UintType);
+			r2 := r.convertTo(UintType)
 			if r2 == nil {
 				return nil
 			}
@@ -1659,14 +1659,14 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 			// If both are ideal, but the right side isn't
 			// an ideal int, convert it to simplify things.
 			if l.t.isIdeal() && !r.t.isInteger() {
-				r = r.convertTo(IdealIntType);
+				r = r.convertTo(IdealIntType)
 				if r == nil {
 					log.Crashf("conversion to uintType succeeded, but conversion to idealIntType failed")
 				}
 			}
 		} else if _, ok := r.t.lit().(*uintType); !ok {
-			a.diag("right operand of shift must be unsigned");
-			return nil;
+			a.diag("right operand of shift must be unsigned")
+			return nil
 		}
 
 		if l.t.isIdeal() && !r.t.isIdeal() {
@@ -1675,7 +1675,7 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 			// converted to an int.  6g propagates the
 			// type down from assignments as a hint.
 
-			l = l.convertTo(IntType);
+			l = l.convertTo(IntType)
 			if l == nil {
 				return nil
 			}
@@ -1686,7 +1686,7 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 		// 2) int SHIFT uint
 		// 3) ideal int SHIFT ideal int
 
-		t = l.t;
+		t = l.t
 
 	case token.LOR, token.LAND:
 		if !booleans() {
@@ -1698,14 +1698,14 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 		// the type of the left operand, and NOT an unnamed
 		// boolean type.
 
-		t = BoolType;
+		t = BoolType
 
 	case token.ARROW:
 		// The operands in channel sends differ in type: one
 		// is always a channel and the other is a variable or
 		// value of the channel's element type.
-		log.Crash("Binary op <- not implemented");
-		t = BoolType;
+		log.Crash("Binary op <- not implemented")
+		t = BoolType
 
 	case token.LSS, token.GTR, token.LEQ, token.GEQ:
 		// XXX(Spec) It's really unclear what types which
@@ -1717,10 +1717,10 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 		// are some restrictions on when it applies to slices.
 
 		if !compat() || (!integers() && !floats() && !strings()) {
-			a.diagOpTypes(op, origlt, origrt);
-			return nil;
+			a.diagOpTypes(op, origlt, origrt)
+			return nil
 		}
-		t = BoolType;
+		t = BoolType
 
 	case token.EQL, token.NEQ:
 		// XXX(Spec) The rules for type checking comparison
@@ -1760,25 +1760,25 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 		// TODO(austin) Deal with remaining special cases
 
 		if !compat() {
-			a.diagOpTypes(op, origlt, origrt);
-			return nil;
+			a.diagOpTypes(op, origlt, origrt)
+			return nil
 		}
 		// Arrays and structs may not be compared to anything.
 		switch l.t.(type) {
 		case *ArrayType, *StructType:
-			a.diagOpTypes(op, origlt, origrt);
-			return nil;
+			a.diagOpTypes(op, origlt, origrt)
+			return nil
 		}
-		t = BoolType;
+		t = BoolType
 
 	default:
 		log.Crashf("unknown binary operator %v", op)
 	}
 
-	desc, ok := binOpDescs[op];
+	desc, ok := binOpDescs[op]
 	if !ok {
-		desc = op.String() + " expression";
-		binOpDescs[op] = desc;
+		desc = op.String() + " expression"
+		binOpDescs[op] = desc
 	}
 
 	// Check for ideal divide by zero
@@ -1787,14 +1787,14 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 		if r.t.isIdeal() {
 			if (r.t.isInteger() && r.asIdealInt()().IsZero()) ||
 				(r.t.isFloat() && r.asIdealFloat()().IsZero()) {
-				a.diag("divide by zero");
-				return nil;
+				a.diag("divide by zero")
+				return nil
 			}
 		}
 	}
 
 	// Compile
-	expr := a.newExpr(t, desc);
+	expr := a.newExpr(t, desc)
 	switch op {
 	case token.ADD:
 		expr.genBinOpAdd(l, r)
@@ -1825,26 +1825,26 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 
 	case token.SHL:
 		if l.t.isIdeal() {
-			lv := l.asIdealInt()();
-			rv := r.asIdealInt()();
-			const maxShift = 99999;
+			lv := l.asIdealInt()()
+			rv := r.asIdealInt()()
+			const maxShift = 99999
 			if rv.Cmp(bignum.Int(maxShift)) > 0 {
-				a.diag("left shift by %v; exceeds implementation limit of %v", rv, maxShift);
-				expr.t = nil;
-				return nil;
+				a.diag("left shift by %v; exceeds implementation limit of %v", rv, maxShift)
+				expr.t = nil
+				return nil
 			}
-			val := lv.Shl(uint(rv.Value()));
-			expr.eval = func() *bignum.Integer { return val };
+			val := lv.Shl(uint(rv.Value()))
+			expr.eval = func() *bignum.Integer { return val }
 		} else {
 			expr.genBinOpShl(l, r)
 		}
 
 	case token.SHR:
 		if l.t.isIdeal() {
-			lv := l.asIdealInt()();
-			rv := r.asIdealInt()();
-			val := lv.Shr(uint(rv.Value()));
-			expr.eval = func() *bignum.Integer { return val };
+			lv := l.asIdealInt()()
+			rv := r.asIdealInt()()
+			val := lv.Shr(uint(rv.Value()))
+			expr.eval = func() *bignum.Integer { return val }
 		} else {
 			expr.genBinOpShr(l, r)
 		}
@@ -1877,28 +1877,28 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 		log.Crashf("Compilation of binary op %v not implemented", op)
 	}
 
-	return expr;
+	return expr
 }
 
 // TODO(austin) This is a hack to eliminate a circular dependency
 // between type.go and expr.go
 func (a *compiler) compileArrayLen(b *block, expr ast.Expr) (int64, bool) {
-	lenExpr := a.compileExpr(b, true, expr);
+	lenExpr := a.compileExpr(b, true, expr)
 	if lenExpr == nil {
 		return 0, false
 	}
 
 	// XXX(Spec) Are ideal floats with no fractional part okay?
 	if lenExpr.t.isIdeal() {
-		lenExpr = lenExpr.convertTo(IntType);
+		lenExpr = lenExpr.convertTo(IntType)
 		if lenExpr == nil {
 			return 0, false
 		}
 	}
 
 	if !lenExpr.t.isInteger() {
-		a.diagAt(expr, "array size must be an integer");
-		return 0, false;
+		a.diagAt(expr, "array size must be an integer")
+		return 0, false
 	}
 
 	switch lenExpr.t.lit().(type) {
@@ -1907,18 +1907,18 @@ func (a *compiler) compileArrayLen(b *block, expr ast.Expr) (int64, bool) {
 	case *uintType:
 		return int64(lenExpr.asUint()(nil)), true
 	}
-	log.Crashf("unexpected integer type %T", lenExpr.t);
-	return 0, false;
+	log.Crashf("unexpected integer type %T", lenExpr.t)
+	return 0, false
 }
 
 func (a *compiler) compileExpr(b *block, constant bool, expr ast.Expr) *expr {
-	ec := &exprCompiler{a, b, constant};
-	nerr := a.numError();
-	e := ec.compile(expr, false);
+	ec := &exprCompiler{a, b, constant}
+	nerr := a.numError()
+	e := ec.compile(expr, false)
 	if e == nil && nerr == a.numError() {
 		log.Crashf("expression compilation failed without reporting errors")
 	}
-	return e;
+	return e
 }
 
 // extractEffect separates out any effects that the expression may
@@ -1931,21 +1931,21 @@ func (a *compiler) compileExpr(b *block, constant bool, expr ast.Expr) *expr {
 // results.
 func (a *expr) extractEffect(b *block, errOp string) (func(*Thread), *expr) {
 	// Create "&a" if a is addressable
-	rhs := a;
+	rhs := a
 	if a.evalAddr != nil {
 		rhs = a.compileUnaryExpr(token.AND, rhs)
 	}
 
 	// Create temp
-	ac, ok := a.checkAssign(a.pos, []*expr{rhs}, errOp, "");
+	ac, ok := a.checkAssign(a.pos, []*expr{rhs}, errOp, "")
 	if !ok {
 		return nil, nil
 	}
 	if len(ac.rmt.Elems) != 1 {
-		a.diag("multi-valued expression not allowed in %s", errOp);
-		return nil, nil;
+		a.diag("multi-valued expression not allowed in %s", errOp)
+		return nil, nil
 	}
-	tempType := ac.rmt.Elems[0];
+	tempType := ac.rmt.Elems[0]
 	if tempType.isIdeal() {
 		// It's too bad we have to duplicate this rule.
 		switch {
@@ -1957,30 +1957,30 @@ func (a *expr) extractEffect(b *block, errOp string) (func(*Thread), *expr) {
 			log.Crashf("unexpected ideal type %v", tempType)
 		}
 	}
-	temp := b.DefineTemp(tempType);
-	tempIdx := temp.Index;
+	temp := b.DefineTemp(tempType)
+	tempIdx := temp.Index
 
 	// Create "temp := rhs"
-	assign := ac.compile(b, tempType);
+	assign := ac.compile(b, tempType)
 	if assign == nil {
 		log.Crashf("compileAssign type check failed")
 	}
 
 	effect := func(t *Thread) {
-		tempVal := tempType.Zero();
-		t.f.Vars[tempIdx] = tempVal;
-		assign(tempVal, t);
-	};
+		tempVal := tempType.Zero()
+		t.f.Vars[tempIdx] = tempVal
+		assign(tempVal, t)
+	}
 
 	// Generate "temp" or "*temp"
-	getTemp := a.compileVariable(0, temp);
+	getTemp := a.compileVariable(0, temp)
 	if a.evalAddr == nil {
 		return effect, getTemp
 	}
 
-	deref := a.compileStarExpr(getTemp);
+	deref := a.compileStarExpr(getTemp)
 	if deref == nil {
 		return nil, nil
 	}
-	return effect, deref;
+	return effect, deref
 }
diff --git a/src/pkg/exp/eval/expr1.go b/src/pkg/exp/eval/expr1.go
index ed2081c719..a77e40fb0a 100644
--- a/src/pkg/exp/eval/expr1.go
+++ b/src/pkg/exp/eval/expr1.go
@@ -4,19 +4,19 @@
 package eval
 
 import (
-	"bignum";
-	"log";
+	"bignum"
+	"log"
 )
 
 /*
  * "As" functions.  These retrieve evaluator functions from an
  * expr, panicking if the requested evaluator has the wrong type.
  */
-func (a *expr) asBool() (func(*Thread) bool)	{ return a.eval.(func(*Thread) bool) }
+func (a *expr) asBool() (func(*Thread) bool) { return a.eval.(func(*Thread) bool) }
 func (a *expr) asUint() (func(*Thread) uint64) {
 	return a.eval.(func(*Thread) uint64)
 }
-func (a *expr) asInt() (func(*Thread) int64)	{ return a.eval.(func(*Thread) int64) }
+func (a *expr) asInt() (func(*Thread) int64) { return a.eval.(func(*Thread) int64) }
 func (a *expr) asIdealInt() (func() *bignum.Integer) {
 	return a.eval.(func() *bignum.Integer)
 }
@@ -35,12 +35,12 @@ func (a *expr) asArray() (func(*Thread) ArrayValue) {
 func (a *expr) asStruct() (func(*Thread) StructValue) {
 	return a.eval.(func(*Thread) StructValue)
 }
-func (a *expr) asPtr() (func(*Thread) Value)	{ return a.eval.(func(*Thread) Value) }
-func (a *expr) asFunc() (func(*Thread) Func)	{ return a.eval.(func(*Thread) Func) }
+func (a *expr) asPtr() (func(*Thread) Value) { return a.eval.(func(*Thread) Value) }
+func (a *expr) asFunc() (func(*Thread) Func) { return a.eval.(func(*Thread) Func) }
 func (a *expr) asSlice() (func(*Thread) Slice) {
 	return a.eval.(func(*Thread) Slice)
 }
-func (a *expr) asMap() (func(*Thread) Map)	{ return a.eval.(func(*Thread) Map) }
+func (a *expr) asMap() (func(*Thread) Map) { return a.eval.(func(*Thread) Map) }
 func (a *expr) asMulti() (func(*Thread) []Value) {
 	return a.eval.(func(*Thread) []Value)
 }
@@ -76,7 +76,7 @@ func (a *expr) asInterface() (func(*Thread) interface{}) {
 	default:
 		log.Crashf("unexpected expression node type %T at %v", a.eval, a.pos)
 	}
-	panic();
+	panic()
 }
 
 /*
@@ -92,13 +92,13 @@ func (a *expr) genConstant(v Value) {
 	case *intType:
 		a.eval = func(t *Thread) int64 { return v.(IntValue).Get(t) }
 	case *idealIntType:
-		val := v.(IdealIntValue).Get();
-		a.eval = func() *bignum.Integer { return val };
+		val := v.(IdealIntValue).Get()
+		a.eval = func() *bignum.Integer { return val }
 	case *floatType:
 		a.eval = func(t *Thread) float64 { return v.(FloatValue).Get(t) }
 	case *idealFloatType:
-		val := v.(IdealFloatValue).Get();
-		a.eval = func() *bignum.Rational { return val };
+		val := v.(IdealFloatValue).Get()
+		a.eval = func() *bignum.Rational { return val }
 	case *stringType:
 		a.eval = func(t *Thread) string { return v.(StringValue).Get(t) }
 	case *ArrayType:
@@ -119,7 +119,7 @@ func (a *expr) genConstant(v Value) {
 }
 
 func (a *expr) genIdentOp(level, index int) {
-	a.evalAddr = func(t *Thread) Value { return t.f.Get(level, index) };
+	a.evalAddr = func(t *Thread) Value { return t.f.Get(level, index) }
 	switch a.t.lit().(type) {
 	case *boolType:
 		a.eval = func(t *Thread) bool { return t.f.Get(level, index).(BoolValue).Get(t) }
@@ -149,7 +149,7 @@ func (a *expr) genIdentOp(level, index int) {
 }
 
 func (a *expr) genFuncCall(call func(t *Thread) []Value) {
-	a.exec = func(t *Thread) { call(t) };
+	a.exec = func(t *Thread) { call(t) }
 	switch a.t.lit().(type) {
 	case *boolType:
 		a.eval = func(t *Thread) bool { return call(t)[0].(BoolValue).Get(t) }
@@ -181,7 +181,7 @@ func (a *expr) genFuncCall(call func(t *Thread) []Value) {
 }
 
 func (a *expr) genValue(vf func(*Thread) Value) {
-	a.evalAddr = vf;
+	a.evalAddr = vf
 	switch a.t.lit().(type) {
 	case *boolType:
 		a.eval = func(t *Thread) bool { return vf(t).(BoolValue).Get(t) }
@@ -213,31 +213,31 @@ func (a *expr) genValue(vf func(*Thread) Value) {
 func (a *expr) genUnaryOpNeg(v *expr) {
 	switch a.t.lit().(type) {
 	case *uintType:
-		vf := v.asUint();
+		vf := v.asUint()
 		a.eval = func(t *Thread) uint64 {
-			v := vf(t);
-			return -v;
-		};
+			v := vf(t)
+			return -v
+		}
 	case *intType:
-		vf := v.asInt();
+		vf := v.asInt()
 		a.eval = func(t *Thread) int64 {
-			v := vf(t);
-			return -v;
-		};
+			v := vf(t)
+			return -v
+		}
 	case *idealIntType:
-		v := v.asIdealInt()();
-		val := v.Neg();
-		a.eval = func() *bignum.Integer { return val };
+		v := v.asIdealInt()()
+		val := v.Neg()
+		a.eval = func() *bignum.Integer { return val }
 	case *floatType:
-		vf := v.asFloat();
+		vf := v.asFloat()
 		a.eval = func(t *Thread) float64 {
-			v := vf(t);
-			return -v;
-		};
+			v := vf(t)
+			return -v
+		}
 	case *idealFloatType:
-		v := v.asIdealFloat()();
-		val := v.Neg();
-		a.eval = func() *bignum.Rational { return val };
+		v := v.asIdealFloat()()
+		val := v.Neg()
+		a.eval = func() *bignum.Rational { return val }
 	default:
 		log.Crashf("unexpected type %v at %v", a.t, a.pos)
 	}
@@ -246,11 +246,11 @@ func (a *expr) genUnaryOpNeg(v *expr) {
 func (a *expr) genUnaryOpNot(v *expr) {
 	switch a.t.lit().(type) {
 	case *boolType:
-		vf := v.asBool();
+		vf := v.asBool()
 		a.eval = func(t *Thread) bool {
-			v := vf(t);
-			return !v;
-		};
+			v := vf(t)
+			return !v
+		}
 	default:
 		log.Crashf("unexpected type %v at %v", a.t, a.pos)
 	}
@@ -259,169 +259,169 @@ func (a *expr) genUnaryOpNot(v *expr) {
 func (a *expr) genUnaryOpXor(v *expr) {
 	switch a.t.lit().(type) {
 	case *uintType:
-		vf := v.asUint();
+		vf := v.asUint()
 		a.eval = func(t *Thread) uint64 {
-			v := vf(t);
-			return ^v;
-		};
+			v := vf(t)
+			return ^v
+		}
 	case *intType:
-		vf := v.asInt();
+		vf := v.asInt()
 		a.eval = func(t *Thread) int64 {
-			v := vf(t);
-			return ^v;
-		};
+			v := vf(t)
+			return ^v
+		}
 	case *idealIntType:
-		v := v.asIdealInt()();
-		val := v.Neg().Sub(bignum.Int(1));
-		a.eval = func() *bignum.Integer { return val };
+		v := v.asIdealInt()()
+		val := v.Neg().Sub(bignum.Int(1))
+		a.eval = func() *bignum.Integer { return val }
 	default:
 		log.Crashf("unexpected type %v at %v", a.t, a.pos)
 	}
 }
 
 func (a *expr) genBinOpLogAnd(l, r *expr) {
-	lf := l.asBool();
-	rf := r.asBool();
-	a.eval = func(t *Thread) bool { return lf(t) && rf(t) };
+	lf := l.asBool()
+	rf := r.asBool()
+	a.eval = func(t *Thread) bool { return lf(t) && rf(t) }
 }
 
 func (a *expr) genBinOpLogOr(l, r *expr) {
-	lf := l.asBool();
-	rf := r.asBool();
-	a.eval = func(t *Thread) bool { return lf(t) || rf(t) };
+	lf := l.asBool()
+	rf := r.asBool()
+	a.eval = func(t *Thread) bool { return lf(t) || rf(t) }
 }
 
 func (a *expr) genBinOpAdd(l, r *expr) {
 	switch t := l.t.lit().(type) {
 	case *uintType:
-		lf := l.asUint();
-		rf := r.asUint();
+		lf := l.asUint()
+		rf := r.asUint()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l + r;
-				return uint64(uint8(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l + r
+				return uint64(uint8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l + r;
-				return uint64(uint16(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l + r
+				return uint64(uint16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l + r;
-				return uint64(uint32(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l + r
+				return uint64(uint32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l + r;
-				return uint64(uint64(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l + r
+				return uint64(uint64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l + r;
-				return uint64(uint(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l + r
+				return uint64(uint(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
-		lf := l.asInt();
-		rf := r.asInt();
+		lf := l.asInt()
+		rf := r.asInt()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l + r;
-				return int64(int8(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l + r
+				return int64(int8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l + r;
-				return int64(int16(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l + r
+				return int64(int16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l + r;
-				return int64(int32(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l + r
+				return int64(int32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l + r;
-				return int64(int64(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l + r
+				return int64(int64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l + r;
-				return int64(int(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l + r
+				return int64(int(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
-		l := l.asIdealInt()();
-		r := r.asIdealInt()();
-		val := l.Add(r);
-		a.eval = func() *bignum.Integer { return val };
+		l := l.asIdealInt()()
+		r := r.asIdealInt()()
+		val := l.Add(r)
+		a.eval = func() *bignum.Integer { return val }
 	case *floatType:
-		lf := l.asFloat();
-		rf := r.asFloat();
+		lf := l.asFloat()
+		rf := r.asFloat()
 		switch t.Bits {
 		case 32:
 			a.eval = func(t *Thread) float64 {
-				l, r := lf(t), rf(t);
-				var ret float64;
-				ret = l + r;
-				return float64(float32(ret));
+				l, r := lf(t), rf(t)
+				var ret float64
+				ret = l + r
+				return float64(float32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) float64 {
-				l, r := lf(t), rf(t);
-				var ret float64;
-				ret = l + r;
-				return float64(float64(ret));
+				l, r := lf(t), rf(t)
+				var ret float64
+				ret = l + r
+				return float64(float64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) float64 {
-				l, r := lf(t), rf(t);
-				var ret float64;
-				ret = l + r;
-				return float64(float(ret));
+				l, r := lf(t), rf(t)
+				var ret float64
+				ret = l + r
+				return float64(float(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealFloatType:
-		l := l.asIdealFloat()();
-		r := r.asIdealFloat()();
-		val := l.Add(r);
-		a.eval = func() *bignum.Rational { return val };
+		l := l.asIdealFloat()()
+		r := r.asIdealFloat()()
+		val := l.Add(r)
+		a.eval = func() *bignum.Rational { return val }
 	case *stringType:
-		lf := l.asString();
-		rf := r.asString();
+		lf := l.asString()
+		rf := r.asString()
 		a.eval = func(t *Thread) string {
-			l, r := lf(t), rf(t);
-			return l + r;
-		};
+			l, r := lf(t), rf(t)
+			return l + r
+		}
 	default:
 		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
@@ -430,127 +430,127 @@ func (a *expr) genBinOpAdd(l, r *expr) {
 func (a *expr) genBinOpSub(l, r *expr) {
 	switch t := l.t.lit().(type) {
 	case *uintType:
-		lf := l.asUint();
-		rf := r.asUint();
+		lf := l.asUint()
+		rf := r.asUint()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l - r;
-				return uint64(uint8(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l - r
+				return uint64(uint8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l - r;
-				return uint64(uint16(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l - r
+				return uint64(uint16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l - r;
-				return uint64(uint32(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l - r
+				return uint64(uint32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l - r;
-				return uint64(uint64(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l - r
+				return uint64(uint64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l - r;
-				return uint64(uint(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l - r
+				return uint64(uint(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
-		lf := l.asInt();
-		rf := r.asInt();
+		lf := l.asInt()
+		rf := r.asInt()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l - r;
-				return int64(int8(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l - r
+				return int64(int8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l - r;
-				return int64(int16(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l - r
+				return int64(int16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l - r;
-				return int64(int32(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l - r
+				return int64(int32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l - r;
-				return int64(int64(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l - r
+				return int64(int64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l - r;
-				return int64(int(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l - r
+				return int64(int(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
-		l := l.asIdealInt()();
-		r := r.asIdealInt()();
-		val := l.Sub(r);
-		a.eval = func() *bignum.Integer { return val };
+		l := l.asIdealInt()()
+		r := r.asIdealInt()()
+		val := l.Sub(r)
+		a.eval = func() *bignum.Integer { return val }
 	case *floatType:
-		lf := l.asFloat();
-		rf := r.asFloat();
+		lf := l.asFloat()
+		rf := r.asFloat()
 		switch t.Bits {
 		case 32:
 			a.eval = func(t *Thread) float64 {
-				l, r := lf(t), rf(t);
-				var ret float64;
-				ret = l - r;
-				return float64(float32(ret));
+				l, r := lf(t), rf(t)
+				var ret float64
+				ret = l - r
+				return float64(float32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) float64 {
-				l, r := lf(t), rf(t);
-				var ret float64;
-				ret = l - r;
-				return float64(float64(ret));
+				l, r := lf(t), rf(t)
+				var ret float64
+				ret = l - r
+				return float64(float64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) float64 {
-				l, r := lf(t), rf(t);
-				var ret float64;
-				ret = l - r;
-				return float64(float(ret));
+				l, r := lf(t), rf(t)
+				var ret float64
+				ret = l - r
+				return float64(float(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealFloatType:
-		l := l.asIdealFloat()();
-		r := r.asIdealFloat()();
-		val := l.Sub(r);
-		a.eval = func() *bignum.Rational { return val };
+		l := l.asIdealFloat()()
+		r := r.asIdealFloat()()
+		val := l.Sub(r)
+		a.eval = func() *bignum.Rational { return val }
 	default:
 		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
@@ -559,127 +559,127 @@ func (a *expr) genBinOpSub(l, r *expr) {
 func (a *expr) genBinOpMul(l, r *expr) {
 	switch t := l.t.lit().(type) {
 	case *uintType:
-		lf := l.asUint();
-		rf := r.asUint();
+		lf := l.asUint()
+		rf := r.asUint()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l * r;
-				return uint64(uint8(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l * r
+				return uint64(uint8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l * r;
-				return uint64(uint16(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l * r
+				return uint64(uint16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l * r;
-				return uint64(uint32(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l * r
+				return uint64(uint32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l * r;
-				return uint64(uint64(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l * r
+				return uint64(uint64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l * r;
-				return uint64(uint(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l * r
+				return uint64(uint(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
-		lf := l.asInt();
-		rf := r.asInt();
+		lf := l.asInt()
+		rf := r.asInt()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l * r;
-				return int64(int8(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l * r
+				return int64(int8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l * r;
-				return int64(int16(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l * r
+				return int64(int16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l * r;
-				return int64(int32(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l * r
+				return int64(int32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l * r;
-				return int64(int64(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l * r
+				return int64(int64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l * r;
-				return int64(int(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l * r
+				return int64(int(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
-		l := l.asIdealInt()();
-		r := r.asIdealInt()();
-		val := l.Mul(r);
-		a.eval = func() *bignum.Integer { return val };
+		l := l.asIdealInt()()
+		r := r.asIdealInt()()
+		val := l.Mul(r)
+		a.eval = func() *bignum.Integer { return val }
 	case *floatType:
-		lf := l.asFloat();
-		rf := r.asFloat();
+		lf := l.asFloat()
+		rf := r.asFloat()
 		switch t.Bits {
 		case 32:
 			a.eval = func(t *Thread) float64 {
-				l, r := lf(t), rf(t);
-				var ret float64;
-				ret = l * r;
-				return float64(float32(ret));
+				l, r := lf(t), rf(t)
+				var ret float64
+				ret = l * r
+				return float64(float32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) float64 {
-				l, r := lf(t), rf(t);
-				var ret float64;
-				ret = l * r;
-				return float64(float64(ret));
+				l, r := lf(t), rf(t)
+				var ret float64
+				ret = l * r
+				return float64(float64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) float64 {
-				l, r := lf(t), rf(t);
-				var ret float64;
-				ret = l * r;
-				return float64(float(ret));
+				l, r := lf(t), rf(t)
+				var ret float64
+				ret = l * r
+				return float64(float(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealFloatType:
-		l := l.asIdealFloat()();
-		r := r.asIdealFloat()();
-		val := l.Mul(r);
-		a.eval = func() *bignum.Rational { return val };
+		l := l.asIdealFloat()()
+		r := r.asIdealFloat()()
+		val := l.Mul(r)
+		a.eval = func() *bignum.Rational { return val }
 	default:
 		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
@@ -688,166 +688,166 @@ func (a *expr) genBinOpMul(l, r *expr) {
 func (a *expr) genBinOpQuo(l, r *expr) {
 	switch t := l.t.lit().(type) {
 	case *uintType:
-		lf := l.asUint();
-		rf := r.asUint();
+		lf := l.asUint()
+		rf := r.asUint()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
+				l, r := lf(t), rf(t)
+				var ret uint64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l / r;
-				return uint64(uint8(ret));
+				ret = l / r
+				return uint64(uint8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
+				l, r := lf(t), rf(t)
+				var ret uint64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l / r;
-				return uint64(uint16(ret));
+				ret = l / r
+				return uint64(uint16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
+				l, r := lf(t), rf(t)
+				var ret uint64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l / r;
-				return uint64(uint32(ret));
+				ret = l / r
+				return uint64(uint32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
+				l, r := lf(t), rf(t)
+				var ret uint64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l / r;
-				return uint64(uint64(ret));
+				ret = l / r
+				return uint64(uint64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
+				l, r := lf(t), rf(t)
+				var ret uint64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l / r;
-				return uint64(uint(ret));
+				ret = l / r
+				return uint64(uint(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
-		lf := l.asInt();
-		rf := r.asInt();
+		lf := l.asInt()
+		rf := r.asInt()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
+				l, r := lf(t), rf(t)
+				var ret int64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l / r;
-				return int64(int8(ret));
+				ret = l / r
+				return int64(int8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
+				l, r := lf(t), rf(t)
+				var ret int64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l / r;
-				return int64(int16(ret));
+				ret = l / r
+				return int64(int16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
+				l, r := lf(t), rf(t)
+				var ret int64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l / r;
-				return int64(int32(ret));
+				ret = l / r
+				return int64(int32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
+				l, r := lf(t), rf(t)
+				var ret int64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l / r;
-				return int64(int64(ret));
+				ret = l / r
+				return int64(int64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
+				l, r := lf(t), rf(t)
+				var ret int64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l / r;
-				return int64(int(ret));
+				ret = l / r
+				return int64(int(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
-		l := l.asIdealInt()();
-		r := r.asIdealInt()();
-		val := l.Quo(r);
-		a.eval = func() *bignum.Integer { return val };
+		l := l.asIdealInt()()
+		r := r.asIdealInt()()
+		val := l.Quo(r)
+		a.eval = func() *bignum.Integer { return val }
 	case *floatType:
-		lf := l.asFloat();
-		rf := r.asFloat();
+		lf := l.asFloat()
+		rf := r.asFloat()
 		switch t.Bits {
 		case 32:
 			a.eval = func(t *Thread) float64 {
-				l, r := lf(t), rf(t);
-				var ret float64;
+				l, r := lf(t), rf(t)
+				var ret float64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l / r;
-				return float64(float32(ret));
+				ret = l / r
+				return float64(float32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) float64 {
-				l, r := lf(t), rf(t);
-				var ret float64;
+				l, r := lf(t), rf(t)
+				var ret float64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l / r;
-				return float64(float64(ret));
+				ret = l / r
+				return float64(float64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) float64 {
-				l, r := lf(t), rf(t);
-				var ret float64;
+				l, r := lf(t), rf(t)
+				var ret float64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l / r;
-				return float64(float(ret));
+				ret = l / r
+				return float64(float(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealFloatType:
-		l := l.asIdealFloat()();
-		r := r.asIdealFloat()();
-		val := l.Quo(r);
-		a.eval = func() *bignum.Rational { return val };
+		l := l.asIdealFloat()()
+		r := r.asIdealFloat()()
+		val := l.Quo(r)
+		a.eval = func() *bignum.Rational { return val }
 	default:
 		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
@@ -856,124 +856,124 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 func (a *expr) genBinOpRem(l, r *expr) {
 	switch t := l.t.lit().(type) {
 	case *uintType:
-		lf := l.asUint();
-		rf := r.asUint();
+		lf := l.asUint()
+		rf := r.asUint()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
+				l, r := lf(t), rf(t)
+				var ret uint64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l % r;
-				return uint64(uint8(ret));
+				ret = l % r
+				return uint64(uint8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
+				l, r := lf(t), rf(t)
+				var ret uint64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l % r;
-				return uint64(uint16(ret));
+				ret = l % r
+				return uint64(uint16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
+				l, r := lf(t), rf(t)
+				var ret uint64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l % r;
-				return uint64(uint32(ret));
+				ret = l % r
+				return uint64(uint32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
+				l, r := lf(t), rf(t)
+				var ret uint64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l % r;
-				return uint64(uint64(ret));
+				ret = l % r
+				return uint64(uint64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
+				l, r := lf(t), rf(t)
+				var ret uint64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l % r;
-				return uint64(uint(ret));
+				ret = l % r
+				return uint64(uint(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
-		lf := l.asInt();
-		rf := r.asInt();
+		lf := l.asInt()
+		rf := r.asInt()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
+				l, r := lf(t), rf(t)
+				var ret int64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l % r;
-				return int64(int8(ret));
+				ret = l % r
+				return int64(int8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
+				l, r := lf(t), rf(t)
+				var ret int64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l % r;
-				return int64(int16(ret));
+				ret = l % r
+				return int64(int16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
+				l, r := lf(t), rf(t)
+				var ret int64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l % r;
-				return int64(int32(ret));
+				ret = l % r
+				return int64(int32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
+				l, r := lf(t), rf(t)
+				var ret int64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l % r;
-				return int64(int64(ret));
+				ret = l % r
+				return int64(int64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
+				l, r := lf(t), rf(t)
+				var ret int64
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l % r;
-				return int64(int(ret));
+				ret = l % r
+				return int64(int(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
-		l := l.asIdealInt()();
-		r := r.asIdealInt()();
-		val := l.Rem(r);
-		a.eval = func() *bignum.Integer { return val };
+		l := l.asIdealInt()()
+		r := r.asIdealInt()()
+		val := l.Rem(r)
+		a.eval = func() *bignum.Integer { return val }
 	default:
 		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
@@ -982,94 +982,94 @@ func (a *expr) genBinOpRem(l, r *expr) {
 func (a *expr) genBinOpAnd(l, r *expr) {
 	switch t := l.t.lit().(type) {
 	case *uintType:
-		lf := l.asUint();
-		rf := r.asUint();
+		lf := l.asUint()
+		rf := r.asUint()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l & r;
-				return uint64(uint8(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l & r
+				return uint64(uint8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l & r;
-				return uint64(uint16(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l & r
+				return uint64(uint16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l & r;
-				return uint64(uint32(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l & r
+				return uint64(uint32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l & r;
-				return uint64(uint64(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l & r
+				return uint64(uint64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l & r;
-				return uint64(uint(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l & r
+				return uint64(uint(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
-		lf := l.asInt();
-		rf := r.asInt();
+		lf := l.asInt()
+		rf := r.asInt()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l & r;
-				return int64(int8(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l & r
+				return int64(int8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l & r;
-				return int64(int16(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l & r
+				return int64(int16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l & r;
-				return int64(int32(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l & r
+				return int64(int32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l & r;
-				return int64(int64(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l & r
+				return int64(int64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l & r;
-				return int64(int(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l & r
+				return int64(int(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
-		l := l.asIdealInt()();
-		r := r.asIdealInt()();
-		val := l.And(r);
-		a.eval = func() *bignum.Integer { return val };
+		l := l.asIdealInt()()
+		r := r.asIdealInt()()
+		val := l.And(r)
+		a.eval = func() *bignum.Integer { return val }
 	default:
 		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
@@ -1078,94 +1078,94 @@ func (a *expr) genBinOpAnd(l, r *expr) {
 func (a *expr) genBinOpOr(l, r *expr) {
 	switch t := l.t.lit().(type) {
 	case *uintType:
-		lf := l.asUint();
-		rf := r.asUint();
+		lf := l.asUint()
+		rf := r.asUint()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l | r;
-				return uint64(uint8(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l | r
+				return uint64(uint8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l | r;
-				return uint64(uint16(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l | r
+				return uint64(uint16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l | r;
-				return uint64(uint32(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l | r
+				return uint64(uint32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l | r;
-				return uint64(uint64(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l | r
+				return uint64(uint64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l | r;
-				return uint64(uint(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l | r
+				return uint64(uint(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
-		lf := l.asInt();
-		rf := r.asInt();
+		lf := l.asInt()
+		rf := r.asInt()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l | r;
-				return int64(int8(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l | r
+				return int64(int8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l | r;
-				return int64(int16(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l | r
+				return int64(int16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l | r;
-				return int64(int32(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l | r
+				return int64(int32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l | r;
-				return int64(int64(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l | r
+				return int64(int64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l | r;
-				return int64(int(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l | r
+				return int64(int(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
-		l := l.asIdealInt()();
-		r := r.asIdealInt()();
-		val := l.Or(r);
-		a.eval = func() *bignum.Integer { return val };
+		l := l.asIdealInt()()
+		r := r.asIdealInt()()
+		val := l.Or(r)
+		a.eval = func() *bignum.Integer { return val }
 	default:
 		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
@@ -1174,94 +1174,94 @@ func (a *expr) genBinOpOr(l, r *expr) {
 func (a *expr) genBinOpXor(l, r *expr) {
 	switch t := l.t.lit().(type) {
 	case *uintType:
-		lf := l.asUint();
-		rf := r.asUint();
+		lf := l.asUint()
+		rf := r.asUint()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l ^ r;
-				return uint64(uint8(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l ^ r
+				return uint64(uint8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l ^ r;
-				return uint64(uint16(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l ^ r
+				return uint64(uint16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l ^ r;
-				return uint64(uint32(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l ^ r
+				return uint64(uint32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l ^ r;
-				return uint64(uint64(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l ^ r
+				return uint64(uint64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l ^ r;
-				return uint64(uint(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l ^ r
+				return uint64(uint(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
-		lf := l.asInt();
-		rf := r.asInt();
+		lf := l.asInt()
+		rf := r.asInt()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l ^ r;
-				return int64(int8(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l ^ r
+				return int64(int8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l ^ r;
-				return int64(int16(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l ^ r
+				return int64(int16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l ^ r;
-				return int64(int32(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l ^ r
+				return int64(int32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l ^ r;
-				return int64(int64(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l ^ r
+				return int64(int64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l ^ r;
-				return int64(int(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l ^ r
+				return int64(int(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
-		l := l.asIdealInt()();
-		r := r.asIdealInt()();
-		val := l.Xor(r);
-		a.eval = func() *bignum.Integer { return val };
+		l := l.asIdealInt()()
+		r := r.asIdealInt()()
+		val := l.Xor(r)
+		a.eval = func() *bignum.Integer { return val }
 	default:
 		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
@@ -1270,94 +1270,94 @@ func (a *expr) genBinOpXor(l, r *expr) {
 func (a *expr) genBinOpAndNot(l, r *expr) {
 	switch t := l.t.lit().(type) {
 	case *uintType:
-		lf := l.asUint();
-		rf := r.asUint();
+		lf := l.asUint()
+		rf := r.asUint()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l &^ r;
-				return uint64(uint8(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l &^ r
+				return uint64(uint8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l &^ r;
-				return uint64(uint16(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l &^ r
+				return uint64(uint16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l &^ r;
-				return uint64(uint32(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l &^ r
+				return uint64(uint32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l &^ r;
-				return uint64(uint64(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l &^ r
+				return uint64(uint64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l &^ r;
-				return uint64(uint(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l &^ r
+				return uint64(uint(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
-		lf := l.asInt();
-		rf := r.asInt();
+		lf := l.asInt()
+		rf := r.asInt()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l &^ r;
-				return int64(int8(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l &^ r
+				return int64(int8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l &^ r;
-				return int64(int16(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l &^ r
+				return int64(int16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l &^ r;
-				return int64(int32(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l &^ r
+				return int64(int32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l &^ r;
-				return int64(int64(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l &^ r
+				return int64(int64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l &^ r;
-				return int64(int(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l &^ r
+				return int64(int(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
-		l := l.asIdealInt()();
-		r := r.asIdealInt()();
-		val := l.AndNot(r);
-		a.eval = func() *bignum.Integer { return val };
+		l := l.asIdealInt()()
+		r := r.asIdealInt()()
+		val := l.AndNot(r)
+		a.eval = func() *bignum.Integer { return val }
 	default:
 		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
@@ -1366,85 +1366,85 @@ func (a *expr) genBinOpAndNot(l, r *expr) {
 func (a *expr) genBinOpShl(l, r *expr) {
 	switch t := l.t.lit().(type) {
 	case *uintType:
-		lf := l.asUint();
-		rf := r.asUint();
+		lf := l.asUint()
+		rf := r.asUint()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l << r;
-				return uint64(uint8(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l << r
+				return uint64(uint8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l << r;
-				return uint64(uint16(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l << r
+				return uint64(uint16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l << r;
-				return uint64(uint32(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l << r
+				return uint64(uint32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l << r;
-				return uint64(uint64(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l << r
+				return uint64(uint64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l << r;
-				return uint64(uint(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l << r
+				return uint64(uint(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
-		lf := l.asInt();
-		rf := r.asUint();
+		lf := l.asInt()
+		rf := r.asUint()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l << r;
-				return int64(int8(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l << r
+				return int64(int8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l << r;
-				return int64(int16(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l << r
+				return int64(int16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l << r;
-				return int64(int32(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l << r
+				return int64(int32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l << r;
-				return int64(int64(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l << r
+				return int64(int64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l << r;
-				return int64(int(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l << r
+				return int64(int(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
@@ -1457,85 +1457,85 @@ func (a *expr) genBinOpShl(l, r *expr) {
 func (a *expr) genBinOpShr(l, r *expr) {
 	switch t := l.t.lit().(type) {
 	case *uintType:
-		lf := l.asUint();
-		rf := r.asUint();
+		lf := l.asUint()
+		rf := r.asUint()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l >> r;
-				return uint64(uint8(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l >> r
+				return uint64(uint8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l >> r;
-				return uint64(uint16(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l >> r
+				return uint64(uint16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l >> r;
-				return uint64(uint32(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l >> r
+				return uint64(uint32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l >> r;
-				return uint64(uint64(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l >> r
+				return uint64(uint64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
-				l, r := lf(t), rf(t);
-				var ret uint64;
-				ret = l >> r;
-				return uint64(uint(ret));
+				l, r := lf(t), rf(t)
+				var ret uint64
+				ret = l >> r
+				return uint64(uint(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
-		lf := l.asInt();
-		rf := r.asUint();
+		lf := l.asInt()
+		rf := r.asUint()
 		switch t.Bits {
 		case 8:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l >> r;
-				return int64(int8(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l >> r
+				return int64(int8(ret))
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l >> r;
-				return int64(int16(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l >> r
+				return int64(int16(ret))
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l >> r;
-				return int64(int32(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l >> r
+				return int64(int32(ret))
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l >> r;
-				return int64(int64(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l >> r
+				return int64(int64(ret))
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
-				l, r := lf(t), rf(t);
-				var ret int64;
-				ret = l >> r;
-				return int64(int(ret));
+				l, r := lf(t), rf(t)
+				var ret int64
+				ret = l >> r
+				return int64(int(ret))
 			}
 		default:
 			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
@@ -1548,43 +1548,43 @@ func (a *expr) genBinOpShr(l, r *expr) {
 func (a *expr) genBinOpLss(l, r *expr) {
 	switch t := l.t.lit().(type) {
 	case *uintType:
-		lf := l.asUint();
-		rf := r.asUint();
+		lf := l.asUint()
+		rf := r.asUint()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l < r;
-		};
+			l, r := lf(t), rf(t)
+			return l < r
+		}
 	case *intType:
-		lf := l.asInt();
-		rf := r.asInt();
+		lf := l.asInt()
+		rf := r.asInt()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l < r;
-		};
+			l, r := lf(t), rf(t)
+			return l < r
+		}
 	case *idealIntType:
-		l := l.asIdealInt()();
-		r := r.asIdealInt()();
-		val := l.Cmp(r) < 0;
-		a.eval = func(t *Thread) bool { return val };
+		l := l.asIdealInt()()
+		r := r.asIdealInt()()
+		val := l.Cmp(r) < 0
+		a.eval = func(t *Thread) bool { return val }
 	case *floatType:
-		lf := l.asFloat();
-		rf := r.asFloat();
+		lf := l.asFloat()
+		rf := r.asFloat()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l < r;
-		};
+			l, r := lf(t), rf(t)
+			return l < r
+		}
 	case *idealFloatType:
-		l := l.asIdealFloat()();
-		r := r.asIdealFloat()();
-		val := l.Cmp(r) < 0;
-		a.eval = func(t *Thread) bool { return val };
+		l := l.asIdealFloat()()
+		r := r.asIdealFloat()()
+		val := l.Cmp(r) < 0
+		a.eval = func(t *Thread) bool { return val }
 	case *stringType:
-		lf := l.asString();
-		rf := r.asString();
+		lf := l.asString()
+		rf := r.asString()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l < r;
-		};
+			l, r := lf(t), rf(t)
+			return l < r
+		}
 	default:
 		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
@@ -1593,43 +1593,43 @@ func (a *expr) genBinOpLss(l, r *expr) {
 func (a *expr) genBinOpGtr(l, r *expr) {
 	switch t := l.t.lit().(type) {
 	case *uintType:
-		lf := l.asUint();
-		rf := r.asUint();
+		lf := l.asUint()
+		rf := r.asUint()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l > r;
-		};
+			l, r := lf(t), rf(t)
+			return l > r
+		}
 	case *intType:
-		lf := l.asInt();
-		rf := r.asInt();
+		lf := l.asInt()
+		rf := r.asInt()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l > r;
-		};
+			l, r := lf(t), rf(t)
+			return l > r
+		}
 	case *idealIntType:
-		l := l.asIdealInt()();
-		r := r.asIdealInt()();
-		val := l.Cmp(r) > 0;
-		a.eval = func(t *Thread) bool { return val };
+		l := l.asIdealInt()()
+		r := r.asIdealInt()()
+		val := l.Cmp(r) > 0
+		a.eval = func(t *Thread) bool { return val }
 	case *floatType:
-		lf := l.asFloat();
-		rf := r.asFloat();
+		lf := l.asFloat()
+		rf := r.asFloat()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l > r;
-		};
+			l, r := lf(t), rf(t)
+			return l > r
+		}
 	case *idealFloatType:
-		l := l.asIdealFloat()();
-		r := r.asIdealFloat()();
-		val := l.Cmp(r) > 0;
-		a.eval = func(t *Thread) bool { return val };
+		l := l.asIdealFloat()()
+		r := r.asIdealFloat()()
+		val := l.Cmp(r) > 0
+		a.eval = func(t *Thread) bool { return val }
 	case *stringType:
-		lf := l.asString();
-		rf := r.asString();
+		lf := l.asString()
+		rf := r.asString()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l > r;
-		};
+			l, r := lf(t), rf(t)
+			return l > r
+		}
 	default:
 		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
@@ -1638,43 +1638,43 @@ func (a *expr) genBinOpGtr(l, r *expr) {
 func (a *expr) genBinOpLeq(l, r *expr) {
 	switch t := l.t.lit().(type) {
 	case *uintType:
-		lf := l.asUint();
-		rf := r.asUint();
+		lf := l.asUint()
+		rf := r.asUint()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l <= r;
-		};
+			l, r := lf(t), rf(t)
+			return l <= r
+		}
 	case *intType:
-		lf := l.asInt();
-		rf := r.asInt();
+		lf := l.asInt()
+		rf := r.asInt()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l <= r;
-		};
+			l, r := lf(t), rf(t)
+			return l <= r
+		}
 	case *idealIntType:
-		l := l.asIdealInt()();
-		r := r.asIdealInt()();
-		val := l.Cmp(r) <= 0;
-		a.eval = func(t *Thread) bool { return val };
+		l := l.asIdealInt()()
+		r := r.asIdealInt()()
+		val := l.Cmp(r) <= 0
+		a.eval = func(t *Thread) bool { return val }
 	case *floatType:
-		lf := l.asFloat();
-		rf := r.asFloat();
+		lf := l.asFloat()
+		rf := r.asFloat()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l <= r;
-		};
+			l, r := lf(t), rf(t)
+			return l <= r
+		}
 	case *idealFloatType:
-		l := l.asIdealFloat()();
-		r := r.asIdealFloat()();
-		val := l.Cmp(r) <= 0;
-		a.eval = func(t *Thread) bool { return val };
+		l := l.asIdealFloat()()
+		r := r.asIdealFloat()()
+		val := l.Cmp(r) <= 0
+		a.eval = func(t *Thread) bool { return val }
 	case *stringType:
-		lf := l.asString();
-		rf := r.asString();
+		lf := l.asString()
+		rf := r.asString()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l <= r;
-		};
+			l, r := lf(t), rf(t)
+			return l <= r
+		}
 	default:
 		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
@@ -1683,43 +1683,43 @@ func (a *expr) genBinOpLeq(l, r *expr) {
 func (a *expr) genBinOpGeq(l, r *expr) {
 	switch t := l.t.lit().(type) {
 	case *uintType:
-		lf := l.asUint();
-		rf := r.asUint();
+		lf := l.asUint()
+		rf := r.asUint()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l >= r;
-		};
+			l, r := lf(t), rf(t)
+			return l >= r
+		}
 	case *intType:
-		lf := l.asInt();
-		rf := r.asInt();
+		lf := l.asInt()
+		rf := r.asInt()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l >= r;
-		};
+			l, r := lf(t), rf(t)
+			return l >= r
+		}
 	case *idealIntType:
-		l := l.asIdealInt()();
-		r := r.asIdealInt()();
-		val := l.Cmp(r) >= 0;
-		a.eval = func(t *Thread) bool { return val };
+		l := l.asIdealInt()()
+		r := r.asIdealInt()()
+		val := l.Cmp(r) >= 0
+		a.eval = func(t *Thread) bool { return val }
 	case *floatType:
-		lf := l.asFloat();
-		rf := r.asFloat();
+		lf := l.asFloat()
+		rf := r.asFloat()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l >= r;
-		};
+			l, r := lf(t), rf(t)
+			return l >= r
+		}
 	case *idealFloatType:
-		l := l.asIdealFloat()();
-		r := r.asIdealFloat()();
-		val := l.Cmp(r) >= 0;
-		a.eval = func(t *Thread) bool { return val };
+		l := l.asIdealFloat()()
+		r := r.asIdealFloat()()
+		val := l.Cmp(r) >= 0
+		a.eval = func(t *Thread) bool { return val }
 	case *stringType:
-		lf := l.asString();
-		rf := r.asString();
+		lf := l.asString()
+		rf := r.asString()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l >= r;
-		};
+			l, r := lf(t), rf(t)
+			return l >= r
+		}
 	default:
 		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
@@ -1728,71 +1728,71 @@ func (a *expr) genBinOpGeq(l, r *expr) {
 func (a *expr) genBinOpEql(l, r *expr) {
 	switch t := l.t.lit().(type) {
 	case *boolType:
-		lf := l.asBool();
-		rf := r.asBool();
+		lf := l.asBool()
+		rf := r.asBool()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l == r;
-		};
+			l, r := lf(t), rf(t)
+			return l == r
+		}
 	case *uintType:
-		lf := l.asUint();
-		rf := r.asUint();
+		lf := l.asUint()
+		rf := r.asUint()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l == r;
-		};
+			l, r := lf(t), rf(t)
+			return l == r
+		}
 	case *intType:
-		lf := l.asInt();
-		rf := r.asInt();
+		lf := l.asInt()
+		rf := r.asInt()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l == r;
-		};
+			l, r := lf(t), rf(t)
+			return l == r
+		}
 	case *idealIntType:
-		l := l.asIdealInt()();
-		r := r.asIdealInt()();
-		val := l.Cmp(r) == 0;
-		a.eval = func(t *Thread) bool { return val };
+		l := l.asIdealInt()()
+		r := r.asIdealInt()()
+		val := l.Cmp(r) == 0
+		a.eval = func(t *Thread) bool { return val }
 	case *floatType:
-		lf := l.asFloat();
-		rf := r.asFloat();
+		lf := l.asFloat()
+		rf := r.asFloat()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l == r;
-		};
+			l, r := lf(t), rf(t)
+			return l == r
+		}
 	case *idealFloatType:
-		l := l.asIdealFloat()();
-		r := r.asIdealFloat()();
-		val := l.Cmp(r) == 0;
-		a.eval = func(t *Thread) bool { return val };
+		l := l.asIdealFloat()()
+		r := r.asIdealFloat()()
+		val := l.Cmp(r) == 0
+		a.eval = func(t *Thread) bool { return val }
 	case *stringType:
-		lf := l.asString();
-		rf := r.asString();
+		lf := l.asString()
+		rf := r.asString()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l == r;
-		};
+			l, r := lf(t), rf(t)
+			return l == r
+		}
 	case *PtrType:
-		lf := l.asPtr();
-		rf := r.asPtr();
+		lf := l.asPtr()
+		rf := r.asPtr()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l == r;
-		};
+			l, r := lf(t), rf(t)
+			return l == r
+		}
 	case *FuncType:
-		lf := l.asFunc();
-		rf := r.asFunc();
+		lf := l.asFunc()
+		rf := r.asFunc()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l == r;
-		};
+			l, r := lf(t), rf(t)
+			return l == r
+		}
 	case *MapType:
-		lf := l.asMap();
-		rf := r.asMap();
+		lf := l.asMap()
+		rf := r.asMap()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l == r;
-		};
+			l, r := lf(t), rf(t)
+			return l == r
+		}
 	default:
 		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
@@ -1801,71 +1801,71 @@ func (a *expr) genBinOpEql(l, r *expr) {
 func (a *expr) genBinOpNeq(l, r *expr) {
 	switch t := l.t.lit().(type) {
 	case *boolType:
-		lf := l.asBool();
-		rf := r.asBool();
+		lf := l.asBool()
+		rf := r.asBool()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l != r;
-		};
+			l, r := lf(t), rf(t)
+			return l != r
+		}
 	case *uintType:
-		lf := l.asUint();
-		rf := r.asUint();
+		lf := l.asUint()
+		rf := r.asUint()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l != r;
-		};
+			l, r := lf(t), rf(t)
+			return l != r
+		}
 	case *intType:
-		lf := l.asInt();
-		rf := r.asInt();
+		lf := l.asInt()
+		rf := r.asInt()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l != r;
-		};
+			l, r := lf(t), rf(t)
+			return l != r
+		}
 	case *idealIntType:
-		l := l.asIdealInt()();
-		r := r.asIdealInt()();
-		val := l.Cmp(r) != 0;
-		a.eval = func(t *Thread) bool { return val };
+		l := l.asIdealInt()()
+		r := r.asIdealInt()()
+		val := l.Cmp(r) != 0
+		a.eval = func(t *Thread) bool { return val }
 	case *floatType:
-		lf := l.asFloat();
-		rf := r.asFloat();
+		lf := l.asFloat()
+		rf := r.asFloat()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l != r;
-		};
+			l, r := lf(t), rf(t)
+			return l != r
+		}
 	case *idealFloatType:
-		l := l.asIdealFloat()();
-		r := r.asIdealFloat()();
-		val := l.Cmp(r) != 0;
-		a.eval = func(t *Thread) bool { return val };
+		l := l.asIdealFloat()()
+		r := r.asIdealFloat()()
+		val := l.Cmp(r) != 0
+		a.eval = func(t *Thread) bool { return val }
 	case *stringType:
-		lf := l.asString();
-		rf := r.asString();
+		lf := l.asString()
+		rf := r.asString()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l != r;
-		};
+			l, r := lf(t), rf(t)
+			return l != r
+		}
 	case *PtrType:
-		lf := l.asPtr();
-		rf := r.asPtr();
+		lf := l.asPtr()
+		rf := r.asPtr()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l != r;
-		};
+			l, r := lf(t), rf(t)
+			return l != r
+		}
 	case *FuncType:
-		lf := l.asFunc();
-		rf := r.asFunc();
+		lf := l.asFunc()
+		rf := r.asFunc()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l != r;
-		};
+			l, r := lf(t), rf(t)
+			return l != r
+		}
 	case *MapType:
-		lf := l.asMap();
-		rf := r.asMap();
+		lf := l.asMap()
+		rf := r.asMap()
 		a.eval = func(t *Thread) bool {
-			l, r := lf(t), rf(t);
-			return l != r;
-		};
+			l, r := lf(t), rf(t)
+			return l != r
+		}
 	default:
 		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
@@ -1874,40 +1874,40 @@ func (a *expr) genBinOpNeq(l, r *expr) {
 func genAssign(lt Type, r *expr) (func(lv Value, t *Thread)) {
 	switch lt.lit().(type) {
 	case *boolType:
-		rf := r.asBool();
-		return func(lv Value, t *Thread) { lv.(BoolValue).Set(t, rf(t)) };
+		rf := r.asBool()
+		return func(lv Value, t *Thread) { lv.(BoolValue).Set(t, rf(t)) }
 	case *uintType:
-		rf := r.asUint();
-		return func(lv Value, t *Thread) { lv.(UintValue).Set(t, rf(t)) };
+		rf := r.asUint()
+		return func(lv Value, t *Thread) { lv.(UintValue).Set(t, rf(t)) }
 	case *intType:
-		rf := r.asInt();
-		return func(lv Value, t *Thread) { lv.(IntValue).Set(t, rf(t)) };
+		rf := r.asInt()
+		return func(lv Value, t *Thread) { lv.(IntValue).Set(t, rf(t)) }
 	case *floatType:
-		rf := r.asFloat();
-		return func(lv Value, t *Thread) { lv.(FloatValue).Set(t, rf(t)) };
+		rf := r.asFloat()
+		return func(lv Value, t *Thread) { lv.(FloatValue).Set(t, rf(t)) }
 	case *stringType:
-		rf := r.asString();
-		return func(lv Value, t *Thread) { lv.(StringValue).Set(t, rf(t)) };
+		rf := r.asString()
+		return func(lv Value, t *Thread) { lv.(StringValue).Set(t, rf(t)) }
 	case *ArrayType:
-		rf := r.asArray();
-		return func(lv Value, t *Thread) { lv.Assign(t, rf(t)) };
+		rf := r.asArray()
+		return func(lv Value, t *Thread) { lv.Assign(t, rf(t)) }
 	case *StructType:
-		rf := r.asStruct();
-		return func(lv Value, t *Thread) { lv.Assign(t, rf(t)) };
+		rf := r.asStruct()
+		return func(lv Value, t *Thread) { lv.Assign(t, rf(t)) }
 	case *PtrType:
-		rf := r.asPtr();
-		return func(lv Value, t *Thread) { lv.(PtrValue).Set(t, rf(t)) };
+		rf := r.asPtr()
+		return func(lv Value, t *Thread) { lv.(PtrValue).Set(t, rf(t)) }
 	case *FuncType:
-		rf := r.asFunc();
-		return func(lv Value, t *Thread) { lv.(FuncValue).Set(t, rf(t)) };
+		rf := r.asFunc()
+		return func(lv Value, t *Thread) { lv.(FuncValue).Set(t, rf(t)) }
 	case *SliceType:
-		rf := r.asSlice();
-		return func(lv Value, t *Thread) { lv.(SliceValue).Set(t, rf(t)) };
+		rf := r.asSlice()
+		return func(lv Value, t *Thread) { lv.(SliceValue).Set(t, rf(t)) }
 	case *MapType:
-		rf := r.asMap();
-		return func(lv Value, t *Thread) { lv.(MapValue).Set(t, rf(t)) };
+		rf := r.asMap()
+		return func(lv Value, t *Thread) { lv.(MapValue).Set(t, rf(t)) }
 	default:
 		log.Crashf("unexpected left operand type %v at %v", lt, r.pos)
 	}
-	panic();
+	panic()
 }
diff --git a/src/pkg/exp/eval/expr_test.go b/src/pkg/exp/eval/expr_test.go
index 4d3e2776a1..5cfbc82327 100644
--- a/src/pkg/exp/eval/expr_test.go
+++ b/src/pkg/exp/eval/expr_test.go
@@ -5,8 +5,8 @@
 package eval
 
 import (
-	"bignum";
-	"testing";
+	"bignum"
+	"testing"
 )
 
 var undefined = "undefined"
@@ -340,4 +340,4 @@ var exprTests = []test{
 	CErr("fn==oneTwo", opTypes),
 }
 
-func TestExpr(t *testing.T)	{ runTests(t, "exprTests", exprTests) }
+func TestExpr(t *testing.T) { runTests(t, "exprTests", exprTests) }
diff --git a/src/pkg/exp/eval/func.go b/src/pkg/exp/eval/func.go
index 9927066413..e672d0783e 100644
--- a/src/pkg/exp/eval/func.go
+++ b/src/pkg/exp/eval/func.go
@@ -11,25 +11,25 @@ import "os"
  */
 
 type Thread struct {
-	abort	chan os.Error;
-	pc	uint;
+	abort chan os.Error
+	pc    uint
 	// The execution frame of this function.  This remains the
 	// same throughout a function invocation.
-	f	*Frame;
+	f *Frame
 }
 
 type code []func(*Thread)
 
 func (i code) exec(t *Thread) {
-	opc := t.pc;
-	t.pc = 0;
-	l := uint(len(i));
+	opc := t.pc
+	t.pc = 0
+	l := uint(len(i))
 	for t.pc < l {
-		pc := t.pc;
-		t.pc++;
-		i[pc](t);
+		pc := t.pc
+		t.pc++
+		i[pc](t)
 	}
-	t.pc = opc;
+	t.pc = opc
 }
 
 /*
@@ -37,33 +37,33 @@ func (i code) exec(t *Thread) {
  */
 
 type codeBuf struct {
-	instrs code;
+	instrs code
 }
 
-func newCodeBuf() *codeBuf	{ return &codeBuf{make(code, 0, 16)} }
+func newCodeBuf() *codeBuf { return &codeBuf{make(code, 0, 16)} }
 
 func (b *codeBuf) push(instr func(*Thread)) {
-	n := len(b.instrs);
+	n := len(b.instrs)
 	if n >= cap(b.instrs) {
-		a := make(code, n, n*2);
+		a := make(code, n, n*2)
 		for i := range b.instrs {
 			a[i] = b.instrs[i]
 		}
-		b.instrs = a;
+		b.instrs = a
 	}
-	b.instrs = b.instrs[0 : n+1];
-	b.instrs[n] = instr;
+	b.instrs = b.instrs[0 : n+1]
+	b.instrs[n] = instr
 }
 
-func (b *codeBuf) nextPC() uint	{ return uint(len(b.instrs)) }
+func (b *codeBuf) nextPC() uint { return uint(len(b.instrs)) }
 
 func (b *codeBuf) get() code {
 	// Freeze this buffer into an array of exactly the right size
-	a := make(code, len(b.instrs));
+	a := make(code, len(b.instrs))
 	for i := range b.instrs {
 		a[i] = b.instrs[i]
 	}
-	return code(a);
+	return code(a)
 }
 
 /*
@@ -71,11 +71,11 @@ func (b *codeBuf) get() code {
  */
 
 type evalFunc struct {
-	outer		*Frame;
-	frameSize	int;
-	code		code;
+	outer     *Frame
+	frameSize int
+	code      code
 }
 
-func (f *evalFunc) NewFrame() *Frame	{ return f.outer.child(f.frameSize) }
+func (f *evalFunc) NewFrame() *Frame { return f.outer.child(f.frameSize) }
 
-func (f *evalFunc) Call(t *Thread)	{ f.code.exec(t) }
+func (f *evalFunc) Call(t *Thread) { f.code.exec(t) }
diff --git a/src/pkg/exp/eval/gen.go b/src/pkg/exp/eval/gen.go
index df49b21d36..2acc2c9561 100644
--- a/src/pkg/exp/eval/gen.go
+++ b/src/pkg/exp/eval/gen.go
@@ -7,58 +7,58 @@ package main
 // generate operator implementations
 
 import (
-	"log";
-	"os";
-	"template";
+	"log"
+	"os"
+	"template"
 )
 
 type Op struct {
-	Name		string;
-	Expr		string;
-	Body		string;	// overrides Expr
-	ConstExpr	string;
-	AsRightName	string;
-	ReturnType	string;
-	Types		[]*Type;
+	Name        string
+	Expr        string
+	Body        string // overrides Expr
+	ConstExpr   string
+	AsRightName string
+	ReturnType  string
+	Types       []*Type
 }
 
 type Size struct {
-	Bits	int;
-	Sized	string;
+	Bits  int
+	Sized string
 }
 
 type Type struct {
-	Repr		string;
-	Value		string;
-	Native		string;
-	As		string;
-	IsIdeal		bool;
-	HasAssign	bool;
-	Sizes		[]Size;
+	Repr      string
+	Value     string
+	Native    string
+	As        string
+	IsIdeal   bool
+	HasAssign bool
+	Sizes     []Size
 }
 
 var (
-	boolType	= &Type{Repr: "*boolType", Value: "BoolValue", Native: "bool", As: "asBool"};
-	uintType	= &Type{Repr: "*uintType", Value: "UintValue", Native: "uint64", As: "asUint",
+	boolType = &Type{Repr: "*boolType", Value: "BoolValue", Native: "bool", As: "asBool"}
+	uintType = &Type{Repr: "*uintType", Value: "UintValue", Native: "uint64", As: "asUint",
 		Sizes: []Size{Size{8, "uint8"}, Size{16, "uint16"}, Size{32, "uint32"}, Size{64, "uint64"}, Size{0, "uint"}},
-	};
-	intType	= &Type{Repr: "*intType", Value: "IntValue", Native: "int64", As: "asInt",
+	}
+	intType = &Type{Repr: "*intType", Value: "IntValue", Native: "int64", As: "asInt",
 		Sizes: []Size{Size{8, "int8"}, Size{16, "int16"}, Size{32, "int32"}, Size{64, "int64"}, Size{0, "int"}},
-	};
-	idealIntType	= &Type{Repr: "*idealIntType", Value: "IdealIntValue", Native: "*bignum.Integer", As: "asIdealInt", IsIdeal: true};
-	floatType	= &Type{Repr: "*floatType", Value: "FloatValue", Native: "float64", As: "asFloat",
+	}
+	idealIntType = &Type{Repr: "*idealIntType", Value: "IdealIntValue", Native: "*bignum.Integer", As: "asIdealInt", IsIdeal: true}
+	floatType    = &Type{Repr: "*floatType", Value: "FloatValue", Native: "float64", As: "asFloat",
 		Sizes: []Size{Size{32, "float32"}, Size{64, "float64"}, Size{0, "float"}},
-	};
-	idealFloatType	= &Type{Repr: "*idealFloatType", Value: "IdealFloatValue", Native: "*bignum.Rational", As: "asIdealFloat", IsIdeal: true};
-	stringType	= &Type{Repr: "*stringType", Value: "StringValue", Native: "string", As: "asString"};
-	arrayType	= &Type{Repr: "*ArrayType", Value: "ArrayValue", Native: "ArrayValue", As: "asArray", HasAssign: true};
-	structType	= &Type{Repr: "*StructType", Value: "StructValue", Native: "StructValue", As: "asStruct", HasAssign: true};
-	ptrType		= &Type{Repr: "*PtrType", Value: "PtrValue", Native: "Value", As: "asPtr"};
-	funcType	= &Type{Repr: "*FuncType", Value: "FuncValue", Native: "Func", As: "asFunc"};
-	sliceType	= &Type{Repr: "*SliceType", Value: "SliceValue", Native: "Slice", As: "asSlice"};
-	mapType		= &Type{Repr: "*MapType", Value: "MapValue", Native: "Map", As: "asMap"};
+	}
+	idealFloatType = &Type{Repr: "*idealFloatType", Value: "IdealFloatValue", Native: "*bignum.Rational", As: "asIdealFloat", IsIdeal: true}
+	stringType     = &Type{Repr: "*stringType", Value: "StringValue", Native: "string", As: "asString"}
+	arrayType      = &Type{Repr: "*ArrayType", Value: "ArrayValue", Native: "ArrayValue", As: "asArray", HasAssign: true}
+	structType     = &Type{Repr: "*StructType", Value: "StructValue", Native: "StructValue", As: "asStruct", HasAssign: true}
+	ptrType        = &Type{Repr: "*PtrType", Value: "PtrValue", Native: "Value", As: "asPtr"}
+	funcType       = &Type{Repr: "*FuncType", Value: "FuncValue", Native: "Func", As: "asFunc"}
+	sliceType      = &Type{Repr: "*SliceType", Value: "SliceValue", Native: "Slice", As: "asSlice"}
+	mapType        = &Type{Repr: "*MapType", Value: "MapValue", Native: "Map", As: "asMap"}
 
-	all	= []*Type{
+	all = []*Type{
 		boolType,
 		uintType,
 		intType,
@@ -72,13 +72,13 @@ var (
 		funcType,
 		sliceType,
 		mapType,
-	};
-	bools		= all[0:1];
-	integers	= all[1:4];
-	shiftable	= all[1:3];
-	numbers		= all[1:6];
-	addable		= all[1:7];
-	cmpable		= []*Type{
+	}
+	bools     = all[0:1]
+	integers  = all[1:4]
+	shiftable = all[1:3]
+	numbers   = all[1:6]
+	addable   = all[1:7]
+	cmpable   = []*Type{
 		boolType,
 		uintType,
 		intType,
@@ -89,7 +89,7 @@ var (
 		ptrType,
 		funcType,
 		mapType,
-	};
+	}
 )
 
 var unOps = []Op{
@@ -131,9 +131,9 @@ var binOps = []Op{
 }
 
 type Data struct {
-	UnaryOps	[]Op;
-	BinaryOps	[]Op;
-	Types		[]*Type;
+	UnaryOps  []Op
+	BinaryOps []Op
+	Types     []*Type
 }
 
 var data = Data{
@@ -362,13 +362,13 @@ func genAssign(lt Type, r *expr) (func(lv Value, t *Thread)) {
 `
 
 func main() {
-	t := template.New(nil);
-	t.SetDelims("ยซ", "ยป");
-	err := t.Parse(templateStr);
+	t := template.New(nil)
+	t.SetDelims("ยซ", "ยป")
+	err := t.Parse(templateStr)
 	if err != nil {
 		log.Exit(err)
 	}
-	err = t.Execute(data, os.Stdout);
+	err = t.Execute(data, os.Stdout)
 	if err != nil {
 		log.Exit(err)
 	}
diff --git a/src/pkg/exp/eval/main.go b/src/pkg/exp/eval/main.go
index 376af6b86d..e7c58ef5b6 100644
--- a/src/pkg/exp/eval/main.go
+++ b/src/pkg/exp/eval/main.go
@@ -5,32 +5,32 @@
 package main
 
 import (
-	"./_obj/eval";
-	"bufio";
-	"flag";
-	"go/parser";
-	"go/scanner";
-	"io";
-	"os";
+	"./_obj/eval"
+	"bufio"
+	"flag"
+	"go/parser"
+	"go/scanner"
+	"io"
+	"os"
 )
 
 var filename = flag.String("f", "", "file to run")
 
 func main() {
-	flag.Parse();
-	w := eval.NewWorld();
+	flag.Parse()
+	w := eval.NewWorld()
 	if *filename != "" {
-		data, err := ioutil.ReadFile(*filename);
+		data, err := ioutil.ReadFile(*filename)
 		if err != nil {
-			println(err.String());
-			os.Exit(1);
+			println(err.String())
+			os.Exit(1)
 		}
-		file, err := parser.ParseFile(*filename, data, 0);
+		file, err := parser.ParseFile(*filename, data, 0)
 		if err != nil {
-			println(err.String());
-			os.Exit(1);
+			println(err.String())
+			os.Exit(1)
 		}
-		code, err := w.CompileDeclList(file.Decls);
+		code, err := w.CompileDeclList(file.Decls)
 		if err != nil {
 			if list, ok := err.(scanner.ErrorList); ok {
 				for _, e := range list {
@@ -39,50 +39,50 @@ func main() {
 			} else {
 				println(err.String())
 			}
-			os.Exit(1);
+			os.Exit(1)
 		}
-		_, err := code.Run();
+		_, err := code.Run()
 		if err != nil {
-			println(err.String());
-			os.Exit(1);
+			println(err.String())
+			os.Exit(1)
 		}
-		code, err = w.Compile("init()");
+		code, err = w.Compile("init()")
 		if code != nil {
-			_, err := code.Run();
+			_, err := code.Run()
 			if err != nil {
-				println(err.String());
-				os.Exit(1);
+				println(err.String())
+				os.Exit(1)
 			}
 		}
-		code, err = w.Compile("main()");
+		code, err = w.Compile("main()")
 		if err != nil {
-			println(err.String());
-			os.Exit(1);
+			println(err.String())
+			os.Exit(1)
 		}
-		_, err = code.Run();
+		_, err = code.Run()
 		if err != nil {
-			println(err.String());
-			os.Exit(1);
+			println(err.String())
+			os.Exit(1)
 		}
-		os.Exit(0);
+		os.Exit(0)
 	}
 
-	r := bufio.NewReader(os.Stdin);
+	r := bufio.NewReader(os.Stdin)
 	for {
-		print("; ");
-		line, err := r.ReadString('\n');
+		print("; ")
+		line, err := r.ReadString('\n')
 		if err != nil {
 			break
 		}
-		code, err := w.Compile(line);
+		code, err := w.Compile(line)
 		if err != nil {
-			println(err.String());
-			continue;
+			println(err.String())
+			continue
 		}
-		v, err := code.Run();
+		v, err := code.Run()
 		if err != nil {
-			println(err.String());
-			continue;
+			println(err.String())
+			continue
 		}
 		if v != nil {
 			println(v.String())
diff --git a/src/pkg/exp/eval/scope.go b/src/pkg/exp/eval/scope.go
index 971b92d53c..84c4c92b8c 100644
--- a/src/pkg/exp/eval/scope.go
+++ b/src/pkg/exp/eval/scope.go
@@ -5,8 +5,8 @@
 package eval
 
 import (
-	"go/token";
-	"log";
+	"go/token"
+	"log"
 )
 
 /*
@@ -15,25 +15,25 @@ import (
 
 // A definition can be a *Variable, *Constant, or Type.
 type Def interface {
-	Pos() token.Position;
+	Pos() token.Position
 }
 
 type Variable struct {
-	token.Position;
+	token.Position
 	// Index of this variable in the Frame structure
-	Index	int;
+	Index int
 	// Static type of this variable
-	Type	Type;
+	Type Type
 	// Value of this variable.  This is only used by Scope.NewFrame;
 	// therefore, it is useful for global scopes but cannot be used
 	// in function scopes.
-	Init	Value;
+	Init Value
 }
 
 type Constant struct {
-	token.Position;
-	Type	Type;
-	Value	Value;
+	token.Position
+	Type  Type
+	Value Value
 }
 
 // A block represents a definition block in which a name may not be
@@ -41,35 +41,35 @@ type Constant struct {
 type block struct {
 	// The block enclosing this one, including blocks in other
 	// scopes.
-	outer	*block;
+	outer *block
 	// The nested block currently being compiled, or nil.
-	inner	*block;
+	inner *block
 	// The Scope containing this block.
-	scope	*Scope;
+	scope *Scope
 	// The Variables, Constants, and Types defined in this block.
-	defs	map[string]Def;
+	defs map[string]Def
 	// The index of the first variable defined in this block.
 	// This must be greater than the index of any variable defined
 	// in any parent of this block within the same Scope at the
 	// time this block is entered.
-	offset	int;
+	offset int
 	// The number of Variables defined in this block.
-	numVars	int;
+	numVars int
 	// If global, do not allocate new vars and consts in
 	// the frame; assume that the refs will be compiled in
 	// using defs[name].Init.
-	global	bool;
+	global bool
 }
 
 // A Scope is the compile-time analogue of a Frame, which captures
 // some subtree of blocks.
 type Scope struct {
 	// The root block of this scope.
-	*block;
+	*block
 	// The maximum number of variables required at any point in
 	// this Scope.  This determines the number of slots needed in
 	// Frame's created from this Scope at run-time.
-	maxVars	int;
+	maxVars int
 }
 
 func (b *block) enterChild() *block {
@@ -81,9 +81,9 @@ func (b *block) enterChild() *block {
 		scope: b.scope,
 		defs: make(map[string]Def),
 		offset: b.offset + b.numVars,
-	};
-	b.inner = sub;
-	return sub;
+	}
+	b.inner = sub
+	return sub
 }
 
 func (b *block) exit() {
@@ -98,66 +98,66 @@ func (b *block) exit() {
 			log.Crash("Exit of parent block without exit of child block")
 		}
 	}
-	b.outer.inner = nil;
+	b.outer.inner = nil
 }
 
 func (b *block) ChildScope() *Scope {
 	if b.inner != nil && b.inner.scope == b.scope {
 		log.Crash("Failed to exit child block before entering a child scope")
 	}
-	sub := b.enterChild();
-	sub.offset = 0;
-	sub.scope = &Scope{sub, 0};
-	return sub.scope;
+	sub := b.enterChild()
+	sub.offset = 0
+	sub.scope = &Scope{sub, 0}
+	return sub.scope
 }
 
 func (b *block) DefineVar(name string, pos token.Position, t Type) (*Variable, Def) {
 	if prev, ok := b.defs[name]; ok {
 		return nil, prev
 	}
-	v := b.defineSlot(t, false);
-	v.Position = pos;
-	b.defs[name] = v;
-	return v, nil;
+	v := b.defineSlot(t, false)
+	v.Position = pos
+	b.defs[name] = v
+	return v, nil
 }
 
-func (b *block) DefineTemp(t Type) *Variable	{ return b.defineSlot(t, true) }
+func (b *block) DefineTemp(t Type) *Variable { return b.defineSlot(t, true) }
 
 func (b *block) defineSlot(t Type, temp bool) *Variable {
 	if b.inner != nil && b.inner.scope == b.scope {
 		log.Crash("Failed to exit child block before defining variable")
 	}
-	index := -1;
+	index := -1
 	if !b.global || temp {
-		index = b.offset + b.numVars;
-		b.numVars++;
+		index = b.offset + b.numVars
+		b.numVars++
 		if index >= b.scope.maxVars {
 			b.scope.maxVars = index + 1
 		}
 	}
-	v := &Variable{token.Position{}, index, t, nil};
-	return v;
+	v := &Variable{token.Position{}, index, t, nil}
+	return v
 }
 
 func (b *block) DefineConst(name string, pos token.Position, t Type, v Value) (*Constant, Def) {
 	if prev, ok := b.defs[name]; ok {
 		return nil, prev
 	}
-	c := &Constant{pos, t, v};
-	b.defs[name] = c;
-	return c, nil;
+	c := &Constant{pos, t, v}
+	b.defs[name] = c
+	return c, nil
 }
 
 func (b *block) DefineType(name string, pos token.Position, t Type) Type {
 	if _, ok := b.defs[name]; ok {
 		return nil
 	}
-	nt := &NamedType{pos, name, nil, true, make(map[string]Method)};
+	nt := &NamedType{pos, name, nil, true, make(map[string]Method)}
 	if t != nil {
 		nt.Complete(t)
 	}
-	b.defs[name] = nt;
-	return nt;
+	b.defs[name] = nt
+	return nt
 }
 
 func (b *block) Lookup(name string) (bl *block, level int, def Def) {
@@ -168,27 +168,27 @@ func (b *block) Lookup(name string) (bl *block, level int, def Def) {
 		if b.outer != nil && b.scope != b.outer.scope {
 			level++
 		}
-		b = b.outer;
+		b = b.outer
 	}
-	return nil, 0, nil;
+	return nil, 0, nil
 }
 
-func (s *Scope) NewFrame(outer *Frame) *Frame	{ return outer.child(s.maxVars) }
+func (s *Scope) NewFrame(outer *Frame) *Frame { return outer.child(s.maxVars) }
 
 /*
  * Frames
  */
 
 type Frame struct {
-	Outer	*Frame;
-	Vars	[]Value;
+	Outer *Frame
+	Vars  []Value
 }
 
 func (f *Frame) Get(level int, index int) Value {
 	for ; level > 0; level-- {
 		f = f.Outer
 	}
-	return f.Vars[index];
+	return f.Vars[index]
 }
 
 func (f *Frame) child(numVars int) *Frame {
diff --git a/src/pkg/exp/eval/stmt.go b/src/pkg/exp/eval/stmt.go
index 60c6b9ee68..53757f7de2 100644
--- a/src/pkg/exp/eval/stmt.go
+++ b/src/pkg/exp/eval/stmt.go
@@ -5,15 +5,15 @@
 package eval
 
 import (
-	"bignum";
-	"log";
-	"go/ast";
-	"go/token";
+	"bignum"
+	"log"
+	"go/ast"
+	"go/token"
 )
 
 const (
-	returnPC	= ^uint(0);
-	badPC		= ^uint(1);
+	returnPC = ^uint(0)
+	badPC    = ^uint(1)
 )
 
 /*
@@ -21,10 +21,10 @@ const (
  */
 
 type stmtCompiler struct {
-	*blockCompiler;
-	pos	token.Position;
+	*blockCompiler
+	pos token.Position
 	// This statement's label, or nil if it is not labeled.
-	stmtLabel	*label;
+	stmtLabel *label
 }
 
 func (a *stmtCompiler) diag(format string, args ...) {
@@ -38,39 +38,39 @@ func (a *stmtCompiler) diag(format string, args ...) {
 type flowEnt struct {
 	// Whether this flow entry is conditional.  If true, flow can
 	// continue to the next PC.
-	cond	bool;
+	cond bool
 	// True if this will terminate flow (e.g., a return statement).
 	// cond must be false and jumps must be nil if this is true.
-	term	bool;
+	term bool
 	// PC's that can be reached from this flow entry.
-	jumps	[]*uint;
+	jumps []*uint
 	// Whether this flow entry has been visited by reachesEnd.
-	visited	bool;
+	visited bool
 }
 
 type flowBlock struct {
 	// If this is a goto, the target label.
-	target	string;
+	target string
 	// The inner-most block containing definitions.
-	block	*block;
+	block *block
 	// The numVars from each block leading to the root of the
 	// scope, starting at block.
-	numVars	[]int;
+	numVars []int
 }
 
 type flowBuf struct {
-	cb	*codeBuf;
+	cb *codeBuf
 	// ents is a map from PC's to flow entries.  Any PC missing
 	// from this map is assumed to reach only PC+1.
-	ents	map[uint]*flowEnt;
+	ents map[uint]*flowEnt
 	// gotos is a map from goto positions to information on the
 	// block at the point of the goto.
-	gotos	map[*token.Position]*flowBlock;
+	gotos map[*token.Position]*flowBlock
 	// labels is a map from label name to information on the block
 	// at the point of the label.  labels are tracked by name,
 	// since mutliple labels at the same PC can have different
 	// blocks.
-	labels	map[string]*flowBlock;
+	labels map[string]*flowBlock
 }
 
 func newFlowBuf(cb *codeBuf) *flowBuf {
@@ -80,16 +80,16 @@ func newFlowBuf(cb *codeBuf) *flowBuf {
 // put creates a flow control point for the next PC in the code buffer.
 // This should be done before pushing the instruction into the code buffer.
 func (f *flowBuf) put(cond bool, term bool, jumps []*uint) {
-	pc := f.cb.nextPC();
+	pc := f.cb.nextPC()
 	if ent, ok := f.ents[pc]; ok {
 		log.Crashf("Flow entry already exists at PC %d: %+v", pc, ent)
 	}
-	f.ents[pc] = &flowEnt{cond, term, jumps, false};
+	f.ents[pc] = &flowEnt{cond, term, jumps, false}
 }
 
 // putTerm creates a flow control point at the next PC that
 // unconditionally terminates execution.
-func (f *flowBuf) putTerm()	{ f.put(false, true, nil) }
+func (f *flowBuf) putTerm() { f.put(false, true, nil) }
 
 // put1 creates a flow control point at the next PC that jumps to one
 // PC and, if cond is true, can also continue to the PC following the
@@ -105,20 +105,20 @@ func newFlowBlock(target string, b *block) *flowBlock {
 	}
 
 	// Count parents leading to the root of the scope
-	n := 0;
+	n := 0
 	for bp := b; bp.scope == b.scope; bp = bp.outer {
 		n++
 	}
 
 	// Capture numVars from each block to the root of the scope
-	numVars := make([]int, n);
-	i := 0;
+	numVars := make([]int, n)
+	i := 0
 	for bp := b; i < n; bp = bp.outer {
-		numVars[i] = bp.numVars;
-		i++;
+		numVars[i] = bp.numVars
+		i++
 	}
 
-	return &flowBlock{target, b, numVars};
+	return &flowBlock{target, b, numVars}
 }
 
 // putGoto captures the block at a goto statement.  This should be
@@ -136,13 +136,13 @@ func (f *flowBuf) putLabel(name string, b *block) {
 // reached from the given program counter.  Error reporting is the
 // caller's responsibility.
 func (f *flowBuf) reachesEnd(pc uint) bool {
-	endPC := f.cb.nextPC();
+	endPC := f.cb.nextPC()
 	if pc > endPC {
 		log.Crashf("Reached bad PC %d past end PC %d", pc, endPC)
 	}
 
 	for ; pc < endPC; pc++ {
-		ent, ok := f.ents[pc];
+		ent, ok := f.ents[pc]
 		if !ok {
 			continue
 		}
@@ -150,7 +150,7 @@ func (f *flowBuf) reachesEnd(pc uint) bool {
 		if ent.visited {
 			return false
 		}
-		ent.visited = true;
+		ent.visited = true
 
 		if ent.term {
 			return false
@@ -168,9 +168,9 @@ func (f *flowBuf) reachesEnd(pc uint) bool {
 		if ent.cond {
 			continue
 		}
-		return false;
+		return false
 	}
-	return true;
+	return true
 }
 
 // gotosObeyScopes returns true if no goto statement causes any
@@ -178,28 +178,28 @@ func (f *flowBuf) reachesEnd(pc uint) bool {
 // the goto.  Reports any errors using the given compiler.
 func (f *flowBuf) gotosObeyScopes(a *compiler) {
 	for pos, src := range f.gotos {
-		tgt := f.labels[src.target];
+		tgt := f.labels[src.target]
 
 		// The target block must be a parent of this block
-		numVars := src.numVars;
-		b := src.block;
+		numVars := src.numVars
+		b := src.block
 		for len(numVars) > 0 && b != tgt.block {
-			b = b.outer;
-			numVars = numVars[1:];
+			b = b.outer
+			numVars = numVars[1:]
 		}
 		if b != tgt.block {
 			// We jumped into a deeper block
-			a.diagAt(pos, "goto causes variables to come into scope");
-			return;
+			a.diagAt(pos, "goto causes variables to come into scope")
+			return
 		}
 
 		// There must be no variables in the target block that
 		// did not exist at the jump
-		tgtNumVars := tgt.numVars;
+		tgtNumVars := tgt.numVars
 		for i := range numVars {
 			if tgtNumVars[i] > numVars[i] {
-				a.diagAt(pos, "goto causes variables to come into scope");
-				return;
+				a.diagAt(pos, "goto causes variables to come into scope")
+				return
 			}
 		}
 	}
@@ -210,25 +210,25 @@ func (f *flowBuf) gotosObeyScopes(a *compiler) {
  */
 
 func (a *stmtCompiler) defineVar(ident *ast.Ident, t Type) *Variable {
-	v, prev := a.block.DefineVar(ident.Value, ident.Pos(), t);
+	v, prev := a.block.DefineVar(ident.Value, ident.Pos(), t)
 	if prev != nil {
 		// TODO(austin) It's silly that we have to capture
 		// Pos() in a variable.
-		pos := prev.Pos();
+		pos := prev.Pos()
 		if pos.IsValid() {
 			a.diagAt(ident, "variable %s redeclared in this block\n\tprevious declaration at %s", ident.Value, &pos)
 		} else {
 			a.diagAt(ident, "variable %s redeclared in this block", ident.Value)
 		}
-		return nil;
+		return nil
 	}
 
 	// Initialize the variable
-	index := v.Index;
+	index := v.Index
 	if v.Index >= 0 {
 		a.push(func(v *Thread) { v.f.Vars[index] = t.Zero() })
 	}
-	return v;
+	return v
 }
 
 // TODO(austin) Move doAssign to here
@@ -242,7 +242,7 @@ func (a *stmtCompiler) compile(s ast.Stmt) {
 		log.Crash("Child scope still entered")
 	}
 
-	notimpl := false;
+	notimpl := false
 	switch s := s.(type) {
 	case *ast.BadStmt:
 		// Error already reported by parser.
@@ -340,30 +340,30 @@ func (a *stmtCompiler) compileDeclStmt(s *ast.DeclStmt) {
 	default:
 		log.Crashf("Unexpected Decl type %T", s.Decl)
 	}
-	a.compileDecl(s.Decl);
+	a.compileDecl(s.Decl)
 }
 
 func (a *stmtCompiler) compileVarDecl(decl *ast.GenDecl) {
 	for _, spec := range decl.Specs {
-		spec := spec.(*ast.ValueSpec);
+		spec := spec.(*ast.ValueSpec)
 		if spec.Values == nil {
 			// Declaration without assignment
 			if spec.Type == nil {
 				// Parser should have caught
 				log.Crash("Type and Values nil")
 			}
-			t := a.compileType(a.block, spec.Type);
+			t := a.compileType(a.block, spec.Type)
 			// Define placeholders even if type compile failed
 			for _, n := range spec.Names {
 				a.defineVar(n, t)
 			}
 		} else {
 			// Declaration with assignment
-			lhs := make([]ast.Expr, len(spec.Names));
+			lhs := make([]ast.Expr, len(spec.Names))
 			for i, n := range spec.Names {
 				lhs[i] = n
 			}
-			a.doAssign(lhs, spec.Values, decl.Tok, spec.Type);
+			a.doAssign(lhs, spec.Values, decl.Tok, spec.Type)
 		}
 	}
 }
@@ -375,27 +375,27 @@ func (a *stmtCompiler) compileDecl(decl ast.Decl) {
 		a.silentErrors++
 
 	case *ast.FuncDecl:
-		decl := a.compileFuncType(a.block, d.Type);
+		decl := a.compileFuncType(a.block, d.Type)
 		if decl == nil {
 			return
 		}
 		// Declare and initialize v before compiling func
 		// so that body can refer to itself.
-		c, prev := a.block.DefineConst(d.Name.Value, a.pos, decl.Type, decl.Type.Zero());
+		c, prev := a.block.DefineConst(d.Name.Value, a.pos, decl.Type, decl.Type.Zero())
 		if prev != nil {
-			pos := prev.Pos();
+			pos := prev.Pos()
 			if pos.IsValid() {
 				a.diagAt(d.Name, "identifier %s redeclared in this block\n\tprevious declaration at %s", d.Name.Value, &pos)
 			} else {
 				a.diagAt(d.Name, "identifier %s redeclared in this block", d.Name.Value)
 			}
 		}
-		fn := a.compileFunc(a.block, decl, d.Body);
+		fn := a.compileFunc(a.block, decl, d.Body)
 		if c == nil || fn == nil {
 			return
 		}
-		var zeroThread Thread;
-		c.Value.(FuncValue).Set(nil, fn(&zeroThread));
+		var zeroThread Thread
+		c.Value.(FuncValue).Set(nil, fn(&zeroThread))
 
 	case *ast.GenDecl:
 		switch d.Tok {
@@ -416,119 +416,119 @@ func (a *stmtCompiler) compileDecl(decl ast.Decl) {
 
 func (a *stmtCompiler) compileLabeledStmt(s *ast.LabeledStmt) {
 	// Define label
-	l, ok := a.labels[s.Label.Value];
+	l, ok := a.labels[s.Label.Value]
 	if ok {
 		if l.resolved.IsValid() {
 			a.diag("label %s redeclared in this block\n\tprevious declaration at %s", s.Label.Value, &l.resolved)
 		}
 	} else {
-		pc := badPC;
-		l = &label{name: s.Label.Value, gotoPC: &pc};
-		a.labels[l.name] = l;
+		pc := badPC
+		l = &label{name: s.Label.Value, gotoPC: &pc}
+		a.labels[l.name] = l
 	}
-	l.desc = "regular label";
-	l.resolved = s.Pos();
+	l.desc = "regular label"
+	l.resolved = s.Pos()
 
 	// Set goto PC
-	*l.gotoPC = a.nextPC();
+	*l.gotoPC = a.nextPC()
 
 	// Define flow entry so we can check for jumps over declarations.
-	a.flow.putLabel(l.name, a.block);
+	a.flow.putLabel(l.name, a.block)
 
 	// Compile the statement.  Reuse our stmtCompiler for simplicity.
-	sc := &stmtCompiler{a.blockCompiler, s.Stmt.Pos(), l};
-	sc.compile(s.Stmt);
+	sc := &stmtCompiler{a.blockCompiler, s.Stmt.Pos(), l}
+	sc.compile(s.Stmt)
 }
 
 func (a *stmtCompiler) compileExprStmt(s *ast.ExprStmt) {
-	bc := a.enterChild();
-	defer bc.exit();
+	bc := a.enterChild()
+	defer bc.exit()
 
-	e := a.compileExpr(bc.block, false, s.X);
+	e := a.compileExpr(bc.block, false, s.X)
 	if e == nil {
 		return
 	}
 
 	if e.exec == nil {
-		a.diag("%s cannot be used as expression statement", e.desc);
-		return;
+		a.diag("%s cannot be used as expression statement", e.desc)
+		return
 	}
 
-	a.push(e.exec);
+	a.push(e.exec)
 }
 
 func (a *stmtCompiler) compileIncDecStmt(s *ast.IncDecStmt) {
 	// Create temporary block for extractEffect
-	bc := a.enterChild();
-	defer bc.exit();
+	bc := a.enterChild()
+	defer bc.exit()
 
-	l := a.compileExpr(bc.block, false, s.X);
+	l := a.compileExpr(bc.block, false, s.X)
 	if l == nil {
 		return
 	}
 
 	if l.evalAddr == nil {
-		l.diag("cannot assign to %s", l.desc);
-		return;
+		l.diag("cannot assign to %s", l.desc)
+		return
 	}
 	if !(l.t.isInteger() || l.t.isFloat()) {
-		l.diagOpType(s.Tok, l.t);
-		return;
+		l.diagOpType(s.Tok, l.t)
+		return
 	}
 
-	var op token.Token;
-	var desc string;
+	var op token.Token
+	var desc string
 	switch s.Tok {
 	case token.INC:
-		op = token.ADD;
-		desc = "increment statement";
+		op = token.ADD
+		desc = "increment statement"
 	case token.DEC:
-		op = token.SUB;
-		desc = "decrement statement";
+		op = token.SUB
+		desc = "decrement statement"
 	default:
 		log.Crashf("Unexpected IncDec token %v", s.Tok)
 	}
 
-	effect, l := l.extractEffect(bc.block, desc);
+	effect, l := l.extractEffect(bc.block, desc)
 
-	one := l.newExpr(IdealIntType, "constant");
-	one.pos = s.Pos();
-	one.eval = func() *bignum.Integer { return bignum.Int(1) };
+	one := l.newExpr(IdealIntType, "constant")
+	one.pos = s.Pos()
+	one.eval = func() *bignum.Integer { return bignum.Int(1) }
 
-	binop := l.compileBinaryExpr(op, l, one);
+	binop := l.compileBinaryExpr(op, l, one)
 	if binop == nil {
 		return
 	}
 
-	assign := a.compileAssign(s.Pos(), bc.block, l.t, []*expr{binop}, "", "");
+	assign := a.compileAssign(s.Pos(), bc.block, l.t, []*expr{binop}, "", "")
 	if assign == nil {
 		log.Crashf("compileAssign type check failed")
 	}
 
-	lf := l.evalAddr;
+	lf := l.evalAddr
 	a.push(func(v *Thread) {
-		effect(v);
-		assign(lf(v), v);
-	});
+		effect(v)
+		assign(lf(v), v)
+	})
 }
 
 func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token, declTypeExpr ast.Expr) {
-	nerr := a.numError();
+	nerr := a.numError()
 
 	// Compile right side first so we have the types when
 	// compiling the left side and so we don't see definitions
 	// made on the left side.
-	rs := make([]*expr, len(rhs));
+	rs := make([]*expr, len(rhs))
 	for i, re := range rhs {
 		rs[i] = a.compileExpr(a.block, false, re)
 	}
 
-	errOp := "assignment";
+	errOp := "assignment"
 	if tok == token.DEFINE || tok == token.VAR {
 		errOp = "declaration"
 	}
-	ac, ok := a.checkAssign(a.pos, rs, errOp, "value");
-	ac.allowMapForms(len(lhs));
+	ac, ok := a.checkAssign(a.pos, rs, errOp, "value")
+	ac.allowMapForms(len(lhs))
 
 	// If this is a definition and the LHS is too big, we won't be
 	// able to produce the usual error message because we can't
@@ -538,35 +538,35 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,
 	}
 
 	// Compile left type if there is one
-	var declType Type;
+	var declType Type
 	if declTypeExpr != nil {
 		declType = a.compileType(a.block, declTypeExpr)
 	}
 
 	// Compile left side
-	ls := make([]*expr, len(lhs));
-	nDefs := 0;
+	ls := make([]*expr, len(lhs))
+	nDefs := 0
 	for i, le := range lhs {
 		// If this is a definition, get the identifier and its type
-		var ident *ast.Ident;
-		var lt Type;
+		var ident *ast.Ident
+		var lt Type
 		switch tok {
 		case token.DEFINE:
 			// Check that it's an identifier
-			ident, ok = le.(*ast.Ident);
+			ident, ok = le.(*ast.Ident)
 			if !ok {
-				a.diagAt(le, "left side of := must be a name");
+				a.diagAt(le, "left side of := must be a name")
 				// Suppress new defitions errors
-				nDefs++;
-				continue;
+				nDefs++
+				continue
 			}
 
 			// Is this simply an assignment?
 			if _, ok := a.block.defs[ident.Value]; ok {
-				ident = nil;
-				break;
+				ident = nil
+				break
 			}
-			nDefs++;
+			nDefs++
 
 		case token.VAR:
 			ident = le.(*ast.Ident)
@@ -623,7 +623,7 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,
 		}
 
 		// Compile LHS
-		ls[i] = a.compileExpr(a.block, false, le);
+		ls[i] = a.compileExpr(a.block, false, le)
 		if ls[i] == nil {
 			continue
 		}
@@ -635,23 +635,23 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,
 			// TODO(austin) Now that the expression
 			// compiler uses semantic values, this might
 			// be easier to implement as a function call.
-			sub := ls[i];
-			ls[i] = ls[i].newExpr(sub.t, sub.desc);
-			ls[i].evalMapValue = sub.evalMapValue;
-			mvf := sub.evalMapValue;
-			et := sub.t;
+			sub := ls[i]
+			ls[i] = ls[i].newExpr(sub.t, sub.desc)
+			ls[i].evalMapValue = sub.evalMapValue
+			mvf := sub.evalMapValue
+			et := sub.t
 			ls[i].evalAddr = func(t *Thread) Value {
-				m, k := mvf(t);
-				e := m.Elem(t, k);
+				m, k := mvf(t)
+				e := m.Elem(t, k)
 				if e == nil {
-					e = et.Zero();
-					m.SetElem(t, k, e);
+					e = et.Zero()
+					m.SetElem(t, k, e)
 				}
-				return e;
-			};
+				return e
+			}
 		} else if ls[i].evalAddr == nil {
-			ls[i].diag("cannot assign to %s", ls[i].desc);
-			continue;
+			ls[i].diag("cannot assign to %s", ls[i].desc)
+			continue
 		}
 	}
 
@@ -660,8 +660,8 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,
 	// with the same type, and at least one of the variables is
 	// new.
 	if tok == token.DEFINE && nDefs == 0 {
-		a.diag("at least one new variable must be declared");
-		return;
+		a.diag("at least one new variable must be declared")
+		return
 	}
 
 	// If there have been errors, our arrays are full of nil's so
@@ -672,27 +672,27 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,
 
 	// Check for 'a[x] = r, ok'
 	if len(ls) == 1 && len(rs) == 2 && ls[0].evalMapValue != nil {
-		a.diag("a[x] = r, ok form not implemented");
-		return;
+		a.diag("a[x] = r, ok form not implemented")
+		return
 	}
 
 	// Create assigner
-	var lt Type;
-	n := len(lhs);
+	var lt Type
+	n := len(lhs)
 	if n == 1 {
 		lt = ls[0].t
 	} else {
-		lts := make([]Type, len(ls));
+		lts := make([]Type, len(ls))
 		for i, l := range ls {
 			if l != nil {
 				lts[i] = l.t
 			}
 		}
-		lt = NewMultiType(lts);
+		lt = NewMultiType(lts)
 	}
-	bc := a.enterChild();
-	defer bc.exit();
-	assign := ac.compile(bc.block, lt);
+	bc := a.enterChild()
+	defer bc.exit()
+	assign := ac.compile(bc.block, lt)
 	if assign == nil {
 		return
 	}
@@ -700,38 +700,38 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,
 	// Compile
 	if n == 1 {
 		// Don't need temporaries and can avoid []Value.
-		lf := ls[0].evalAddr;
-		a.push(func(t *Thread) { assign(lf(t), t) });
+		lf := ls[0].evalAddr
+		a.push(func(t *Thread) { assign(lf(t), t) })
 	} else if tok == token.VAR || (tok == token.DEFINE && nDefs == n) {
 		// Don't need temporaries
-		lfs := make([]func(*Thread) Value, n);
+		lfs := make([]func(*Thread) Value, n)
 		for i, l := range ls {
 			lfs[i] = l.evalAddr
 		}
 		a.push(func(t *Thread) {
-			dest := make([]Value, n);
+			dest := make([]Value, n)
 			for i, lf := range lfs {
 				dest[i] = lf(t)
 			}
-			assign(multiV(dest), t);
-		});
+			assign(multiV(dest), t)
+		})
 	} else {
 		// Need temporaries
-		lmt := lt.(*MultiType);
-		lfs := make([]func(*Thread) Value, n);
+		lmt := lt.(*MultiType)
+		lfs := make([]func(*Thread) Value, n)
 		for i, l := range ls {
 			lfs[i] = l.evalAddr
 		}
 		a.push(func(t *Thread) {
-			temp := lmt.Zero().(multiV);
-			assign(temp, t);
+			temp := lmt.Zero().(multiV)
+			assign(temp, t)
 			// Copy to destination
 			for i := 0; i < n; i++ {
 				// TODO(austin) Need to evaluate LHS
 				// before RHS
 				lfs[i](t).Assign(t, temp[i])
 			}
-		});
+		})
 	}
 }
 
@@ -752,42 +752,42 @@ var assignOpToOp = map[token.Token]token.Token{
 
 func (a *stmtCompiler) doAssignOp(s *ast.AssignStmt) {
 	if len(s.Lhs) != 1 || len(s.Rhs) != 1 {
-		a.diag("tuple assignment cannot be combined with an arithmetic operation");
-		return;
+		a.diag("tuple assignment cannot be combined with an arithmetic operation")
+		return
 	}
 
 	// Create temporary block for extractEffect
-	bc := a.enterChild();
-	defer bc.exit();
+	bc := a.enterChild()
+	defer bc.exit()
 
-	l := a.compileExpr(bc.block, false, s.Lhs[0]);
-	r := a.compileExpr(bc.block, false, s.Rhs[0]);
+	l := a.compileExpr(bc.block, false, s.Lhs[0])
+	r := a.compileExpr(bc.block, false, s.Rhs[0])
 	if l == nil || r == nil {
 		return
 	}
 
 	if l.evalAddr == nil {
-		l.diag("cannot assign to %s", l.desc);
-		return;
+		l.diag("cannot assign to %s", l.desc)
+		return
 	}
 
-	effect, l := l.extractEffect(bc.block, "operator-assignment");
+	effect, l := l.extractEffect(bc.block, "operator-assignment")
 
-	binop := r.compileBinaryExpr(assignOpToOp[s.Tok], l, r);
+	binop := r.compileBinaryExpr(assignOpToOp[s.Tok], l, r)
 	if binop == nil {
 		return
 	}
 
-	assign := a.compileAssign(s.Pos(), bc.block, l.t, []*expr{binop}, "assignment", "value");
+	assign := a.compileAssign(s.Pos(), bc.block, l.t, []*expr{binop}, "assignment", "value")
 	if assign == nil {
 		log.Crashf("compileAssign type check failed")
 	}
 
-	lf := l.evalAddr;
+	lf := l.evalAddr
 	a.push(func(t *Thread) {
-		effect(t);
-		assign(lf(t), t);
-	});
+		effect(t)
+		assign(lf(t), t)
+	})
 }
 
 func (a *stmtCompiler) compileAssignStmt(s *ast.AssignStmt) {
@@ -802,25 +802,25 @@ func (a *stmtCompiler) compileAssignStmt(s *ast.AssignStmt) {
 
 func (a *stmtCompiler) compileReturnStmt(s *ast.ReturnStmt) {
 	if a.fnType == nil {
-		a.diag("cannot return at the top level");
-		return;
+		a.diag("cannot return at the top level")
+		return
 	}
 
 	if len(s.Results) == 0 && (len(a.fnType.Out) == 0 || a.outVarsNamed) {
 		// Simple case.  Simply exit from the function.
-		a.flow.putTerm();
-		a.push(func(v *Thread) { v.pc = returnPC });
-		return;
+		a.flow.putTerm()
+		a.push(func(v *Thread) { v.pc = returnPC })
+		return
 	}
 
-	bc := a.enterChild();
-	defer bc.exit();
+	bc := a.enterChild()
+	defer bc.exit()
 
 	// Compile expressions
-	bad := false;
-	rs := make([]*expr, len(s.Results));
+	bad := false
+	rs := make([]*expr, len(s.Results))
 	for i, re := range s.Results {
-		rs[i] = a.compileExpr(bc.block, false, re);
+		rs[i] = a.compileExpr(bc.block, false, re)
 		if rs[i] == nil {
 			bad = true
 		}
@@ -835,38 +835,38 @@ func (a *stmtCompiler) compileReturnStmt(s *ast.ReturnStmt) {
 	// is a single call to a multi-valued function, the values
 	// returned from the called function will be returned from
 	// this one.
-	assign := a.compileAssign(s.Pos(), bc.block, NewMultiType(a.fnType.Out), rs, "return", "value");
+	assign := a.compileAssign(s.Pos(), bc.block, NewMultiType(a.fnType.Out), rs, "return", "value")
 
 	// XXX(Spec) "The result types of the current function and the
 	// called function must match."  Match is fuzzy.  It should
 	// say that they must be assignment compatible.
 
 	// Compile
-	start := len(a.fnType.In);
-	nout := len(a.fnType.Out);
-	a.flow.putTerm();
+	start := len(a.fnType.In)
+	nout := len(a.fnType.Out)
+	a.flow.putTerm()
 	a.push(func(t *Thread) {
-		assign(multiV(t.f.Vars[start:start+nout]), t);
-		t.pc = returnPC;
-	});
+		assign(multiV(t.f.Vars[start:start+nout]), t)
+		t.pc = returnPC
+	})
 }
 
 func (a *stmtCompiler) findLexicalLabel(name *ast.Ident, pred func(*label) bool, errOp, errCtx string) *label {
-	bc := a.blockCompiler;
+	bc := a.blockCompiler
 	for ; bc != nil; bc = bc.parent {
 		if bc.label == nil {
 			continue
 		}
-		l := bc.label;
+		l := bc.label
 		if name == nil && pred(l) {
 			return l
 		}
 		if name != nil && l.name == name.Value {
 			if !pred(l) {
-				a.diag("cannot %s to %s %s", errOp, l.desc, l.name);
-				return nil;
+				a.diag("cannot %s to %s %s", errOp, l.desc, l.name)
+				return nil
 			}
-			return l;
+			return l
 		}
 	}
 	if name == nil {
@@ -874,54 +874,54 @@ func (a *stmtCompiler) findLexicalLabel(name *ast.Ident, pred func(*label) bool,
 	} else {
 		a.diag("%s label %s not defined", errOp, name.Value)
 	}
-	return nil;
+	return nil
 }
 
 func (a *stmtCompiler) compileBranchStmt(s *ast.BranchStmt) {
-	var pc *uint;
+	var pc *uint
 
 	switch s.Tok {
 	case token.BREAK:
-		l := a.findLexicalLabel(s.Label, func(l *label) bool { return l.breakPC != nil }, "break", "for loop, switch, or select");
+		l := a.findLexicalLabel(s.Label, func(l *label) bool { return l.breakPC != nil }, "break", "for loop, switch, or select")
 		if l == nil {
 			return
 		}
-		pc = l.breakPC;
+		pc = l.breakPC
 
 	case token.CONTINUE:
-		l := a.findLexicalLabel(s.Label, func(l *label) bool { return l.continuePC != nil }, "continue", "for loop");
+		l := a.findLexicalLabel(s.Label, func(l *label) bool { return l.continuePC != nil }, "continue", "for loop")
 		if l == nil {
 			return
 		}
-		pc = l.continuePC;
+		pc = l.continuePC
 
 	case token.GOTO:
-		l, ok := a.labels[s.Label.Value];
+		l, ok := a.labels[s.Label.Value]
 		if !ok {
-			pc := badPC;
-			l = &label{name: s.Label.Value, desc: "unresolved label", gotoPC: &pc, used: s.Pos()};
-			a.labels[l.name] = l;
+			pc := badPC
+			l = &label{name: s.Label.Value, desc: "unresolved label", gotoPC: &pc, used: s.Pos()}
+			a.labels[l.name] = l
 		}
 
-		pc = l.gotoPC;
-		a.flow.putGoto(s.Pos(), l.name, a.block);
+		pc = l.gotoPC
+		a.flow.putGoto(s.Pos(), l.name, a.block)
 
 	case token.FALLTHROUGH:
-		a.diag("fallthrough outside switch");
-		return;
+		a.diag("fallthrough outside switch")
+		return
 
 	default:
 		log.Crash("Unexpected branch token %v", s.Tok)
 	}
 
-	a.flow.put1(false, pc);
-	a.push(func(v *Thread) { v.pc = *pc });
+	a.flow.put1(false, pc)
+	a.push(func(v *Thread) { v.pc = *pc })
 }
 
 func (a *stmtCompiler) compileBlockStmt(s *ast.BlockStmt) {
-	bc := a.enterChild();
-	bc.compileStmts(s);
-	bc.exit();
+	bc := a.enterChild()
+	bc.compileStmts(s)
+	bc.exit()
 }
 
 func (a *stmtCompiler) compileIfStmt(s *ast.IfStmt) {
@@ -935,59 +935,59 @@ func (a *stmtCompiler) compileIfStmt(s *ast.IfStmt) {
 	// says when there's a non-block else clause, because that
 	// else claus has to execute in a scope that is *not* the
 	// surrounding scope.
-	bc := a.enterChild();
-	defer bc.exit();
+	bc := a.enterChild()
+	defer bc.exit()
 
 	// Compile init statement, if any
 	if s.Init != nil {
 		bc.compileStmt(s.Init)
 	}
 
-	elsePC := badPC;
-	endPC := badPC;
+	elsePC := badPC
+	endPC := badPC
 
 	// Compile condition, if any.  If there is no condition, we
 	// fall through to the body.
 	if s.Cond != nil {
-		e := bc.compileExpr(bc.block, false, s.Cond);
+		e := bc.compileExpr(bc.block, false, s.Cond)
 		switch {
 		case e == nil:
 			// Error reported by compileExpr
 		case !e.t.isBoolean():
 			e.diag("'if' condition must be boolean\n\t%v", e.t)
 		default:
-			eval := e.asBool();
-			a.flow.put1(true, &elsePC);
+			eval := e.asBool()
+			a.flow.put1(true, &elsePC)
 			a.push(func(t *Thread) {
 				if !eval(t) {
 					t.pc = elsePC
 				}
-			});
+			})
 		}
 	}
 
 	// Compile body
-	body := bc.enterChild();
-	body.compileStmts(s.Body);
-	body.exit();
+	body := bc.enterChild()
+	body.compileStmts(s.Body)
+	body.exit()
 
 	// Compile else
 	if s.Else != nil {
 		// Skip over else if we executed the body
-		a.flow.put1(false, &endPC);
-		a.push(func(v *Thread) { v.pc = endPC });
-		elsePC = a.nextPC();
-		bc.compileStmt(s.Else);
+		a.flow.put1(false, &endPC)
+		a.push(func(v *Thread) { v.pc = endPC })
+		elsePC = a.nextPC()
+		bc.compileStmt(s.Else)
 	} else {
 		elsePC = a.nextPC()
 	}
-	endPC = a.nextPC();
+	endPC = a.nextPC()
 }
 
 func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {
 	// Create implicit scope around switch
-	bc := a.enterChild();
-	defer bc.exit();
+	bc := a.enterChild()
+	defer bc.exit()
 
 	// Compile init statement, if any
 	if s.Init != nil {
@@ -995,46 +995,46 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {
 	}
 
 	// Compile condition, if any, and extract its effects
-	var cond *expr;
-	condbc := bc.enterChild();
+	var cond *expr
+	condbc := bc.enterChild()
 	if s.Tag != nil {
-		e := condbc.compileExpr(condbc.block, false, s.Tag);
+		e := condbc.compileExpr(condbc.block, false, s.Tag)
 		if e != nil {
-			var effect func(*Thread);
-			effect, cond = e.extractEffect(condbc.block, "switch");
-			a.push(effect);
+			var effect func(*Thread)
+			effect, cond = e.extractEffect(condbc.block, "switch")
+			a.push(effect)
 		}
 	}
 
 	// Count cases
-	ncases := 0;
-	hasDefault := false;
+	ncases := 0
+	hasDefault := false
 	for _, c := range s.Body.List {
-		clause, ok := c.(*ast.CaseClause);
+		clause, ok := c.(*ast.CaseClause)
 		if !ok {
-			a.diagAt(clause, "switch statement must contain case clauses");
-			continue;
+			a.diagAt(clause, "switch statement must contain case clauses")
+			continue
 		}
 		if clause.Values == nil {
 			if hasDefault {
 				a.diagAt(clause, "switch statement contains more than one default case")
 			}
-			hasDefault = true;
+			hasDefault = true
 		} else {
 			ncases += len(clause.Values)
 		}
 	}
 
 	// Compile case expressions
-	cases := make([]func(*Thread) bool, ncases);
-	i := 0;
+	cases := make([]func(*Thread) bool, ncases)
+	i := 0
 	for _, c := range s.Body.List {
-		clause, ok := c.(*ast.CaseClause);
+		clause, ok := c.(*ast.CaseClause)
 		if !ok {
 			continue
 		}
 		for _, v := range clause.Values {
-			e := condbc.compileExpr(condbc.block, false, v);
+			e := condbc.compileExpr(condbc.block, false, v)
 			switch {
 			case e == nil:
 				// Error reported by compileExpr
@@ -1045,45 +1045,45 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {
 			case cond != nil:
 				// Create comparison
 				// TOOD(austin) This produces bad error messages
-				compare := e.compileBinaryExpr(token.EQL, cond, e);
+				compare := e.compileBinaryExpr(token.EQL, cond, e)
 				if compare != nil {
 					cases[i] = compare.asBool()
 				}
 			}
-			i++;
+			i++
 		}
 	}
 
 	// Emit condition
-	casePCs := make([]*uint, ncases+1);
-	endPC := badPC;
+	casePCs := make([]*uint, ncases+1)
+	endPC := badPC
 
-	a.flow.put(false, false, casePCs);
+	a.flow.put(false, false, casePCs)
 	a.push(func(t *Thread) {
 		for i, c := range cases {
 			if c(t) {
-				t.pc = *casePCs[i];
-				return;
+				t.pc = *casePCs[i]
+				return
 			}
 		}
-		t.pc = *casePCs[ncases];
-	});
-	condbc.exit();
+		t.pc = *casePCs[ncases]
+	})
+	condbc.exit()
 
 	// Compile cases
-	i = 0;
+	i = 0
 	for _, c := range s.Body.List {
-		clause, ok := c.(*ast.CaseClause);
+		clause, ok := c.(*ast.CaseClause)
 		if !ok {
 			continue
 		}
 
 		// Save jump PC's
-		pc := a.nextPC();
+		pc := a.nextPC()
 		if clause.Values != nil {
 			for _ = range clause.Values {
-				casePCs[i] = &pc;
-				i++;
+				casePCs[i] = &pc
+				i++
 			}
 		} else {
 			// Default clause
@@ -1091,7 +1091,7 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {
 		}
 
 		// Compile body
-		fall := false;
+		fall := false
 		for j, s := range clause.Body {
 			if br, ok := s.(*ast.BranchStmt); ok && br.Tok == token.FALLTHROUGH {
 				// println("Found fallthrough");
@@ -1104,24 +1104,24 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {
 					// empty blocks to be empty
 					// statements.
 					if _, ok := s2.(*ast.EmptyStmt); !ok {
-						a.diagAt(s, "fallthrough statement must be final statement in case");
-						break;
+						a.diagAt(s, "fallthrough statement must be final statement in case")
+						break
 					}
 				}
-				fall = true;
+				fall = true
 			} else {
 				bc.compileStmt(s)
 			}
 		}
 		// Jump out of switch, unless there was a fallthrough
 		if !fall {
-			a.flow.put1(false, &endPC);
-			a.push(func(v *Thread) { v.pc = endPC });
+			a.flow.put1(false, &endPC)
+			a.push(func(v *Thread) { v.pc = endPC })
 		}
 	}
 
 	// Get end PC
-	endPC = a.nextPC();
+	endPC = a.nextPC()
 	if !hasDefault {
 		casePCs[ncases] = &endPC
 	}
@@ -1129,40 +1129,40 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {
 
 func (a *stmtCompiler) compileForStmt(s *ast.ForStmt) {
 	// Wrap the entire for in a block.
-	bc := a.enterChild();
-	defer bc.exit();
+	bc := a.enterChild()
+	defer bc.exit()
 
 	// Compile init statement, if any
 	if s.Init != nil {
 		bc.compileStmt(s.Init)
 	}
 
-	bodyPC := badPC;
-	postPC := badPC;
-	checkPC := badPC;
-	endPC := badPC;
+	bodyPC := badPC
+	postPC := badPC
+	checkPC := badPC
+	endPC := badPC
 
 	// Jump to condition check.  We generate slightly less code by
 	// placing the condition check after the body.
-	a.flow.put1(false, &checkPC);
-	a.push(func(v *Thread) { v.pc = checkPC });
+	a.flow.put1(false, &checkPC)
+	a.push(func(v *Thread) { v.pc = checkPC })
 
 	// Compile body
-	bodyPC = a.nextPC();
-	body := bc.enterChild();
+	bodyPC = a.nextPC()
+	body := bc.enterChild()
 	if a.stmtLabel != nil {
 		body.label = a.stmtLabel
 	} else {
 		body.label = &label{resolved: s.Pos()}
 	}
-	body.label.desc = "for loop";
-	body.label.breakPC = &endPC;
-	body.label.continuePC = &postPC;
-	body.compileStmts(s.Body);
-	body.exit();
+	body.label.desc = "for loop"
+	body.label.breakPC = &endPC
+	body.label.continuePC = &postPC
+	body.compileStmts(s.Body)
+	body.exit()
 
 	// Compile post, if any
-	postPC = a.nextPC();
+	postPC = a.nextPC()
 	if s.Post != nil {
 		// TODO(austin) Does the parser disallow short
 		// declarations in s.Post?
@@ -1170,30 +1170,30 @@ func (a *stmtCompiler) compileForStmt(s *ast.ForStmt) {
 	}
 
 	// Compile condition check, if any
-	checkPC = a.nextPC();
+	checkPC = a.nextPC()
 	if s.Cond == nil {
 		// If the condition is absent, it is equivalent to true.
-		a.flow.put1(false, &bodyPC);
-		a.push(func(v *Thread) { v.pc = bodyPC });
+		a.flow.put1(false, &bodyPC)
+		a.push(func(v *Thread) { v.pc = bodyPC })
 	} else {
-		e := bc.compileExpr(bc.block, false, s.Cond);
+		e := bc.compileExpr(bc.block, false, s.Cond)
 		switch {
 		case e == nil:
 			// Error reported by compileExpr
 		case !e.t.isBoolean():
 			a.diag("'for' condition must be boolean\n\t%v", e.t)
 		default:
-			eval := e.asBool();
-			a.flow.put1(true, &bodyPC);
+			eval := e.asBool()
+			a.flow.put1(true, &bodyPC)
 			a.push(func(t *Thread) {
 				if eval(t) {
 					t.pc = bodyPC
 				}
-			});
+			})
 		}
 	}
 
-	endPC = a.nextPC();
+	endPC = a.nextPC()
 }
 
 /*
@@ -1201,8 +1201,8 @@ func (a *stmtCompiler) compileForStmt(s *ast.ForStmt) {
  */
 
 func (a *blockCompiler) compileStmt(s ast.Stmt) {
-	sc := &stmtCompiler{a, s.Pos(), nil};
-	sc.compile(s);
+	sc := &stmtCompiler{a, s.Pos(), nil}
+	sc.compile(s)
 }
 
 func (a *blockCompiler) compileStmts(block *ast.BlockStmt) {
@@ -1212,15 +1212,15 @@ func (a *blockCompiler) compileStmts(block *ast.BlockStmt) {
 }
 
 func (a *blockCompiler) enterChild() *blockCompiler {
-	block := a.block.enterChild();
+	block := a.block.enterChild()
 	return &blockCompiler{
 		funcCompiler: a.funcCompiler,
 		block: block,
 		parent: a,
-	};
+	}
 }
 
-func (a *blockCompiler) exit()	{ a.block.exit() }
+func (a *blockCompiler) exit() { a.block.exit() }
 
 /*
  * Function compiler
@@ -1231,8 +1231,8 @@ func (a *compiler) compileFunc(b *block, decl *FuncDecl, body *ast.BlockStmt) (f
 	//
 	// The scope of a parameter or result is the body of the
 	// corresponding function.
-	bodyScope := b.ChildScope();
-	defer bodyScope.exit();
+	bodyScope := b.ChildScope()
+	defer bodyScope.exit()
 	for i, t := range decl.Type.In {
 		if decl.InNames[i] != nil {
 			bodyScope.DefineVar(decl.InNames[i].Value, decl.InNames[i].Pos(), t)
@@ -1249,7 +1249,7 @@ func (a *compiler) compileFunc(b *block, decl *FuncDecl, body *ast.BlockStmt) (f
 	}
 
 	// Create block context
-	cb := newCodeBuf();
+	cb := newCodeBuf()
 	fc := &funcCompiler{
 		compiler: a,
 		fnType: decl.Type,
@@ -1257,16 +1257,16 @@ func (a *compiler) compileFunc(b *block, decl *FuncDecl, body *ast.BlockStmt) (f
 		codeBuf: cb,
 		flow: newFlowBuf(cb),
 		labels: make(map[string]*label),
-	};
+	}
 	bc := &blockCompiler{
 		funcCompiler: fc,
 		block: bodyScope.block,
-	};
+	}
 
 	// Compile body
-	nerr := a.numError();
-	bc.compileStmts(body);
-	fc.checkLabels();
+	nerr := a.numError()
+	bc.compileStmts(body)
+	fc.checkLabels()
 	if nerr != a.numError() {
 		return nil
 	}
@@ -1275,19 +1275,19 @@ func (a *compiler) compileFunc(b *block, decl *FuncDecl, body *ast.BlockStmt) (f
 	// this if there were no errors compiling the body.
 	if len(decl.Type.Out) > 0 && fc.flow.reachesEnd(0) {
 		// XXX(Spec) Not specified.
-		a.diagAt(&body.Rbrace, "function ends without a return statement");
-		return nil;
+		a.diagAt(&body.Rbrace, "function ends without a return statement")
+		return nil
 	}
 
-	code := fc.get();
-	maxVars := bodyScope.maxVars;
-	return func(t *Thread) Func { return &evalFunc{t.f, maxVars, code} };
+	code := fc.get()
+	maxVars := bodyScope.maxVars
+	return func(t *Thread) Func { return &evalFunc{t.f, maxVars, code} }
 }
 
 // Checks that labels were resolved and that all jumps obey scoping
 // rules.  Reports an error and set fc.err if any check fails.
 func (a *funcCompiler) checkLabels() {
-	nerr := a.numError();
+	nerr := a.numError()
 	for _, l := range a.labels {
 		if !l.resolved.IsValid() {
 			a.diagAt(&l.used, "label %s not defined", l.name)
@@ -1301,5 +1301,5 @@ func (a *funcCompiler) checkLabels() {
 	// Executing the "goto" statement must not cause any variables
 	// to come into scope that were not already in scope at the
 	// point of the goto.
-	a.flow.gotosObeyScopes(a.compiler);
+	a.flow.gotosObeyScopes(a.compiler)
 }
diff --git a/src/pkg/exp/eval/stmt_test.go b/src/pkg/exp/eval/stmt_test.go
index 0adea1e626..57c3dd7e97 100644
--- a/src/pkg/exp/eval/stmt_test.go
+++ b/src/pkg/exp/eval/stmt_test.go
@@ -344,4 +344,4 @@ var stmtTests = []test{
 	Run2("func f1(){}", "f1()"),
 }
 
-func TestStmt(t *testing.T)	{ runTests(t, "stmtTests", stmtTests) }
+func TestStmt(t *testing.T) { runTests(t, "stmtTests", stmtTests) }
diff --git a/src/pkg/exp/eval/type.go b/src/pkg/exp/eval/type.go
index 84a5861781..d8f00e93cd 100644
--- a/src/pkg/exp/eval/type.go
+++ b/src/pkg/exp/eval/type.go
@@ -5,13 +5,13 @@
 package eval
 
 import (
-	"bignum";
-	"go/ast";
-	"go/token";
-	"log";
-	"reflect";
-	"sort";
-	"unsafe";	// For Sizeof
+	"bignum"
+	"go/ast"
+	"go/token"
+	"log"
+	"reflect"
+	"sort"
+	"unsafe" // For Sizeof
 )
 
 
@@ -36,33 +36,33 @@ type Type interface {
 	// compatible if their definitions are conversion compatible.
 	//
 	// TODO(austin) Deal with recursive types
-	compat(o Type, conv bool) bool;
+	compat(o Type, conv bool) bool
 	// lit returns this type's literal.  If this is a named type,
 	// this is the unnamed underlying type.  Otherwise, this is an
 	// identity operation.
-	lit() Type;
+	lit() Type
 	// isBoolean returns true if this is a boolean type.
-	isBoolean() bool;
+	isBoolean() bool
 	// isInteger returns true if this is an integer type.
-	isInteger() bool;
+	isInteger() bool
 	// isFloat returns true if this is a floating type.
-	isFloat() bool;
+	isFloat() bool
 	// isIdeal returns true if this is an ideal int or float.
-	isIdeal() bool;
+	isIdeal() bool
 	// Zero returns a new zero value of this type.
-	Zero() Value;
+	Zero() Value
 	// String returns the string representation of this type.
-	String() string;
+	String() string
 	// The position where this type was defined, if any.
-	Pos() token.Position;
+	Pos() token.Position
 }
 
 type BoundedType interface {
-	Type;
+	Type
 	// minVal returns the smallest value of this type.
-	minVal() *bignum.Rational;
+	minVal() *bignum.Rational
 	// maxVal returns the largest value of this type.
-	maxVal() *bignum.Rational;
+	maxVal() *bignum.Rational
 }
 
 var universePos = token.Position{"<universe>", 0, 0, 0}
@@ -72,30 +72,30 @@ var universePos = token.Position{"<universe>", 0, 0, 0}
  */
 
 type typeArrayMapEntry struct {
-	key	[]Type;
-	v	interface{};
-	next	*typeArrayMapEntry;
+	key  []Type
+	v    interface{}
+	next *typeArrayMapEntry
 }
 
 type typeArrayMap map[uintptr]*typeArrayMapEntry
 
 func hashTypeArray(key []Type) uintptr {
-	hash := uintptr(0);
+	hash := uintptr(0)
 	for _, t := range key {
-		hash = hash * 33;
+		hash = hash * 33
 		if t == nil {
 			continue
 		}
-		addr := reflect.NewValue(t).(*reflect.PtrValue).Get();
-		hash ^= addr;
+		addr := reflect.NewValue(t).(*reflect.PtrValue).Get()
+		hash ^= addr
 	}
-	return hash;
+	return hash
 }
 
-func newTypeArrayMap() typeArrayMap	{ return make(map[uintptr]*typeArrayMapEntry) }
+func newTypeArrayMap() typeArrayMap { return make(map[uintptr]*typeArrayMapEntry) }
 
 func (m typeArrayMap) Get(key []Type) interface{} {
-	ent, ok := m[hashTypeArray(key)];
+	ent, ok := m[hashTypeArray(key)]
 	if !ok {
 		return nil
 	}
@@ -111,19 +111,19 @@ nextEnt:
 			}
 		}
 		// Found it
-		return ent.v;
+		return ent.v
 	}
 
-	return nil;
+	return nil
 }
 
 func (m typeArrayMap) Put(key []Type, v interface{}) interface{} {
-	hash := hashTypeArray(key);
-	ent, _ := m[hash];
+	hash := hashTypeArray(key)
+	ent, _ := m[hash]
 
-	new := &typeArrayMapEntry{key, v, ent};
-	m[hash] = new;
-	return v;
+	new := &typeArrayMapEntry{key, v, ent}
+	m[hash] = new
+	return v
 }
 
 /*
@@ -132,34 +132,34 @@ func (m typeArrayMap) Put(key []Type, v interface{}) interface{} {
 
 type commonType struct{}
 
-func (commonType) isBoolean() bool	{ return false }
+func (commonType) isBoolean() bool { return false }
 
-func (commonType) isInteger() bool	{ return false }
+func (commonType) isInteger() bool { return false }
 
-func (commonType) isFloat() bool	{ return false }
+func (commonType) isFloat() bool { return false }
 
-func (commonType) isIdeal() bool	{ return false }
+func (commonType) isIdeal() bool { return false }
 
-func (commonType) Pos() token.Position	{ return token.Position{} }
+func (commonType) Pos() token.Position { return token.Position{} }
 
 /*
  * Bool
  */
 
 type boolType struct {
-	commonType;
+	commonType
 }
 
 var BoolType = universe.DefineType("bool", universePos, &boolType{})
 
 func (t *boolType) compat(o Type, conv bool) bool {
-	_, ok := o.lit().(*boolType);
-	return ok;
+	_, ok := o.lit().(*boolType)
+	return ok
 }
 
-func (t *boolType) lit() Type	{ return t }
+func (t *boolType) lit() Type { return t }
 
-func (t *boolType) isBoolean() bool	{ return true }
+func (t *boolType) isBoolean() bool { return true }
 
 func (boolType) String() string {
 	// Use angle brackets as a convention for printing the
@@ -169,8 +169,8 @@ func (boolType) String() string {
 }
 
 func (t *boolType) Zero() Value {
-	res := boolV(false);
-	return &res;
+	res := boolV(false)
+	return &res
 }
 
 /*
@@ -178,66 +178,66 @@ func (t *boolType) Zero() Value {
  */
 
 type uintType struct {
-	commonType;
+	commonType
 
 	// 0 for architecture-dependent types
-	Bits	uint;
+	Bits uint
 	// true for uintptr, false for all others
-	Ptr	bool;
-	name	string;
+	Ptr  bool
+	name string
 }
 
 var (
-	Uint8Type	= universe.DefineType("uint8", universePos, &uintType{commonType{}, 8, false, "uint8"});
-	Uint16Type	= universe.DefineType("uint16", universePos, &uintType{commonType{}, 16, false, "uint16"});
-	Uint32Type	= universe.DefineType("uint32", universePos, &uintType{commonType{}, 32, false, "uint32"});
-	Uint64Type	= universe.DefineType("uint64", universePos, &uintType{commonType{}, 64, false, "uint64"});
+	Uint8Type  = universe.DefineType("uint8", universePos, &uintType{commonType{}, 8, false, "uint8"})
+	Uint16Type = universe.DefineType("uint16", universePos, &uintType{commonType{}, 16, false, "uint16"})
+	Uint32Type = universe.DefineType("uint32", universePos, &uintType{commonType{}, 32, false, "uint32"})
+	Uint64Type = universe.DefineType("uint64", universePos, &uintType{commonType{}, 64, false, "uint64"})
 
-	UintType	= universe.DefineType("uint", universePos, &uintType{commonType{}, 0, false, "uint"});
-	UintptrType	= universe.DefineType("uintptr", universePos, &uintType{commonType{}, 0, true, "uintptr"});
+	UintType    = universe.DefineType("uint", universePos, &uintType{commonType{}, 0, false, "uint"})
+	UintptrType = universe.DefineType("uintptr", universePos, &uintType{commonType{}, 0, true, "uintptr"})
 )
 
 func (t *uintType) compat(o Type, conv bool) bool {
-	t2, ok := o.lit().(*uintType);
-	return ok && t == t2;
+	t2, ok := o.lit().(*uintType)
+	return ok && t == t2
 }
 
-func (t *uintType) lit() Type	{ return t }
+func (t *uintType) lit() Type { return t }
 
-func (t *uintType) isInteger() bool	{ return true }
+func (t *uintType) isInteger() bool { return true }
 
-func (t *uintType) String() string	{ return "<" + t.name + ">" }
+func (t *uintType) String() string { return "<" + t.name + ">" }
 
 func (t *uintType) Zero() Value {
 	switch t.Bits {
 	case 0:
 		if t.Ptr {
-			res := uintptrV(0);
-			return &res;
+			res := uintptrV(0)
+			return &res
 		} else {
-			res := uintV(0);
-			return &res;
+			res := uintV(0)
+			return &res
 		}
 	case 8:
-		res := uint8V(0);
-		return &res;
+		res := uint8V(0)
+		return &res
 	case 16:
-		res := uint16V(0);
-		return &res;
+		res := uint16V(0)
+		return &res
 	case 32:
-		res := uint32V(0);
-		return &res;
+		res := uint32V(0)
+		return &res
 	case 64:
-		res := uint64V(0);
-		return &res;
+		res := uint64V(0)
+		return &res
 	}
-	panic("unexpected uint bit count: ", t.Bits);
+	panic("unexpected uint bit count: ", t.Bits)
 }
 
-func (t *uintType) minVal() *bignum.Rational	{ return bignum.Rat(0, 1) }
+func (t *uintType) minVal() *bignum.Rational { return bignum.Rat(0, 1) }
 
 func (t *uintType) maxVal() *bignum.Rational {
-	bits := t.Bits;
+	bits := t.Bits
 	if bits == 0 {
 		if t.Ptr {
 			bits = uint(8 * unsafe.Sizeof(uintptr(0)))
@@ -245,7 +245,7 @@ func (t *uintType) maxVal() *bignum.Rational {
 			bits = uint(8 * unsafe.Sizeof(uint(0)))
 		}
 	}
-	return bignum.MakeRat(bignum.Int(1).Shl(bits).Add(bignum.Int(-1)), bignum.Nat(1));
+	return bignum.MakeRat(bignum.Int(1).Shl(bits).Add(bignum.Int(-1)), bignum.Nat(1))
 }
 
 /*
@@ -253,7 +253,7 @@ func (t *uintType) maxVal() *bignum.Rational {
  */
 
 type intType struct {
-	commonType;
+	commonType
 
 	// XXX(Spec) Numeric types: "There is also a set of
 	// architecture-independent basic numeric types whose size
@@ -261,66 +261,66 @@ type intType struct {
 	// architecture-dependent?
 
 	// 0 for architecture-dependent types
-	Bits	uint;
-	name	string;
+	Bits uint
+	name string
 }
 
 var (
-	Int8Type	= universe.DefineType("int8", universePos, &intType{commonType{}, 8, "int8"});
-	Int16Type	= universe.DefineType("int16", universePos, &intType{commonType{}, 16, "int16"});
-	Int32Type	= universe.DefineType("int32", universePos, &intType{commonType{}, 32, "int32"});
-	Int64Type	= universe.DefineType("int64", universePos, &intType{commonType{}, 64, "int64"});
+	Int8Type  = universe.DefineType("int8", universePos, &intType{commonType{}, 8, "int8"})
+	Int16Type = universe.DefineType("int16", universePos, &intType{commonType{}, 16, "int16"})
+	Int32Type = universe.DefineType("int32", universePos, &intType{commonType{}, 32, "int32"})
+	Int64Type = universe.DefineType("int64", universePos, &intType{commonType{}, 64, "int64"})
 
-	IntType	= universe.DefineType("int", universePos, &intType{commonType{}, 0, "int"});
+	IntType = universe.DefineType("int", universePos, &intType{commonType{}, 0, "int"})
 )
 
 func (t *intType) compat(o Type, conv bool) bool {
-	t2, ok := o.lit().(*intType);
-	return ok && t == t2;
+	t2, ok := o.lit().(*intType)
+	return ok && t == t2
 }
 
-func (t *intType) lit() Type	{ return t }
+func (t *intType) lit() Type { return t }
 
-func (t *intType) isInteger() bool	{ return true }
+func (t *intType) isInteger() bool { return true }
 
-func (t *intType) String() string	{ return "<" + t.name + ">" }
+func (t *intType) String() string { return "<" + t.name + ">" }
 
 func (t *intType) Zero() Value {
 	switch t.Bits {
 	case 8:
-		res := int8V(0);
-		return &res;
+		res := int8V(0)
+		return &res
 	case 16:
-		res := int16V(0);
-		return &res;
+		res := int16V(0)
+		return &res
 	case 32:
-		res := int32V(0);
-		return &res;
+		res := int32V(0)
+		return &res
 	case 64:
-		res := int64V(0);
-		return &res;
+		res := int64V(0)
+		return &res
 
 	case 0:
-		res := intV(0);
-		return &res;
+		res := intV(0)
+		return &res
 	}
-	panic("unexpected int bit count: ", t.Bits);
+	panic("unexpected int bit count: ", t.Bits)
 }
 
 func (t *intType) minVal() *bignum.Rational {
-	bits := t.Bits;
+	bits := t.Bits
 	if bits == 0 {
 		bits = uint(8 * unsafe.Sizeof(int(0)))
 	}
-	return bignum.MakeRat(bignum.Int(-1).Shl(bits-1), bignum.Nat(1));
+	return bignum.MakeRat(bignum.Int(-1).Shl(bits-1), bignum.Nat(1))
 }
 
 func (t *intType) maxVal() *bignum.Rational {
-	bits := t.Bits;
+	bits := t.Bits
 	if bits == 0 {
 		bits = uint(8 * unsafe.Sizeof(int(0)))
 	}
-	return bignum.MakeRat(bignum.Int(1).Shl(bits-1).Add(bignum.Int(-1)), bignum.Nat(1));
+	return bignum.MakeRat(bignum.Int(1).Shl(bits-1).Add(bignum.Int(-1)), bignum.Nat(1))
 }
 
 /*
@@ -328,69 +328,69 @@ func (t *intType) maxVal() *bignum.Rational {
  */
 
 type idealIntType struct {
-	commonType;
+	commonType
 }
 
 var IdealIntType Type = &idealIntType{}
 
 func (t *idealIntType) compat(o Type, conv bool) bool {
-	_, ok := o.lit().(*idealIntType);
-	return ok;
+	_, ok := o.lit().(*idealIntType)
+	return ok
 }
 
-func (t *idealIntType) lit() Type	{ return t }
+func (t *idealIntType) lit() Type { return t }
 
-func (t *idealIntType) isInteger() bool	{ return true }
+func (t *idealIntType) isInteger() bool { return true }
 
-func (t *idealIntType) isIdeal() bool	{ return true }
+func (t *idealIntType) isIdeal() bool { return true }
 
-func (t *idealIntType) String() string	{ return "ideal integer" }
+func (t *idealIntType) String() string { return "ideal integer" }
 
-func (t *idealIntType) Zero() Value	{ return &idealIntV{bignum.Int(0)} }
+func (t *idealIntType) Zero() Value { return &idealIntV{bignum.Int(0)} }
 
 /*
  * Float
  */
 
 type floatType struct {
-	commonType;
+	commonType
 
 	// 0 for architecture-dependent type
-	Bits	uint;
+	Bits uint
 
-	name	string;
+	name string
 }
 
 var (
-	Float32Type	= universe.DefineType("float32", universePos, &floatType{commonType{}, 32, "float32"});
-	Float64Type	= universe.DefineType("float64", universePos, &floatType{commonType{}, 64, "float64"});
-	FloatType	= universe.DefineType("float", universePos, &floatType{commonType{}, 0, "float"});
+	Float32Type = universe.DefineType("float32", universePos, &floatType{commonType{}, 32, "float32"})
+	Float64Type = universe.DefineType("float64", universePos, &floatType{commonType{}, 64, "float64"})
+	FloatType   = universe.DefineType("float", universePos, &floatType{commonType{}, 0, "float"})
 )
 
 func (t *floatType) compat(o Type, conv bool) bool {
-	t2, ok := o.lit().(*floatType);
-	return ok && t == t2;
+	t2, ok := o.lit().(*floatType)
+	return ok && t == t2
 }
 
-func (t *floatType) lit() Type	{ return t }
+func (t *floatType) lit() Type { return t }
 
-func (t *floatType) isFloat() bool	{ return true }
+func (t *floatType) isFloat() bool { return true }
 
-func (t *floatType) String() string	{ return "<" + t.name + ">" }
+func (t *floatType) String() string { return "<" + t.name + ">" }
 
 func (t *floatType) Zero() Value {
 	switch t.Bits {
 	case 32:
-		res := float32V(0);
-		return &res;
+		res := float32V(0)
+		return &res
 	case 64:
-		res := float64V(0);
-		return &res;
+		res := float64V(0)
+		return &res
 	case 0:
-		res := floatV(0);
-		return &res;
+		res := floatV(0)
+		return &res
 	}
-	panic("unexpected float bit count: ", t.Bits);
+	panic("unexpected float bit count: ", t.Bits)
 }
 
 var maxFloat32Val = bignum.MakeRat(bignum.Int(0xffffff).Shl(127-23), bignum.Nat(1))
@@ -399,7 +399,7 @@ var minFloat32Val = maxFloat32Val.Neg()
 var minFloat64Val = maxFloat64Val.Neg()
 
 func (t *floatType) minVal() *bignum.Rational {
-	bits := t.Bits;
+	bits := t.Bits
 	if bits == 0 {
 		bits = uint(8 * unsafe.Sizeof(float(0)))
 	}
@@ -409,12 +409,12 @@ func (t *floatType) minVal() *bignum.Rational {
 	case 64:
 		return minFloat64Val
 	}
-	log.Crashf("unexpected floating point bit count: %d", bits);
-	panic();
+	log.Crashf("unexpected floating point bit count: %d", bits)
+	panic()
 }
 
 func (t *floatType) maxVal() *bignum.Rational {
-	bits := t.Bits;
+	bits := t.Bits
 	if bits == 0 {
 		bits = uint(8 * unsafe.Sizeof(float(0)))
 	}
@@ -424,8 +424,8 @@ func (t *floatType) maxVal() *bignum.Rational {
 	case 64:
 		return maxFloat64Val
 	}
-	log.Crashf("unexpected floating point bit count: %d", bits);
-	panic();
+	log.Crashf("unexpected floating point bit count: %d", bits)
+	panic()
 }
 
 /*
@@ -433,48 +433,48 @@ func (t *floatType) maxVal() *bignum.Rational {
  */
 
 type idealFloatType struct {
-	commonType;
+	commonType
 }
 
 var IdealFloatType Type = &idealFloatType{}
 
 func (t *idealFloatType) compat(o Type, conv bool) bool {
-	_, ok := o.lit().(*idealFloatType);
-	return ok;
+	_, ok := o.lit().(*idealFloatType)
+	return ok
 }
 
-func (t *idealFloatType) lit() Type	{ return t }
+func (t *idealFloatType) lit() Type { return t }
 
-func (t *idealFloatType) isFloat() bool	{ return true }
+func (t *idealFloatType) isFloat() bool { return true }
 
-func (t *idealFloatType) isIdeal() bool	{ return true }
+func (t *idealFloatType) isIdeal() bool { return true }
 
-func (t *idealFloatType) String() string	{ return "ideal float" }
+func (t *idealFloatType) String() string { return "ideal float" }
 
-func (t *idealFloatType) Zero() Value	{ return &idealFloatV{bignum.Rat(1, 0)} }
+func (t *idealFloatType) Zero() Value { return &idealFloatV{bignum.Rat(1, 0)} }
 
 /*
  * String
  */
 
 type stringType struct {
-	commonType;
+	commonType
 }
 
 var StringType = universe.DefineType("string", universePos, &stringType{})
 
 func (t *stringType) compat(o Type, conv bool) bool {
-	_, ok := o.lit().(*stringType);
-	return ok;
+	_, ok := o.lit().(*stringType)
+	return ok
 }
 
-func (t *stringType) lit() Type	{ return t }
+func (t *stringType) lit() Type { return t }
 
-func (t *stringType) String() string	{ return "<string>" }
+func (t *stringType) String() string { return "<string>" }
 
 func (t *stringType) Zero() Value {
-	res := stringV("");
-	return &res;
+	res := stringV("")
+	return &res
 }
 
 /*
@@ -482,9 +482,9 @@ func (t *stringType) Zero() Value {
  */
 
 type ArrayType struct {
-	commonType;
-	Len	int64;
-	Elem	Type;
+	commonType
+	Len  int64
+	Elem Type
 }
 
 var arrayTypes = make(map[int64]map[Type]*ArrayType)
@@ -493,33 +493,33 @@ var arrayTypes = make(map[int64]map[Type]*ArrayType)
 // and the same array length.
 
 func NewArrayType(len int64, elem Type) *ArrayType {
-	ts, ok := arrayTypes[len];
+	ts, ok := arrayTypes[len]
 	if !ok {
-		ts = make(map[Type]*ArrayType);
-		arrayTypes[len] = ts;
+		ts = make(map[Type]*ArrayType)
+		arrayTypes[len] = ts
 	}
-	t, ok := ts[elem];
+	t, ok := ts[elem]
 	if !ok {
-		t = &ArrayType{commonType{}, len, elem};
-		ts[elem] = t;
+		t = &ArrayType{commonType{}, len, elem}
+		ts[elem] = t
 	}
-	return t;
+	return t
 }
 
 func (t *ArrayType) compat(o Type, conv bool) bool {
-	t2, ok := o.lit().(*ArrayType);
+	t2, ok := o.lit().(*ArrayType)
 	if !ok {
 		return false
 	}
-	return t.Len == t2.Len && t.Elem.compat(t2.Elem, conv);
+	return t.Len == t2.Len && t.Elem.compat(t2.Elem, conv)
 }
 
-func (t *ArrayType) lit() Type	{ return t }
+func (t *ArrayType) lit() Type { return t }
 
-func (t *ArrayType) String() string	{ return "[]" + t.Elem.String() }
+func (t *ArrayType) String() string { return "[]" + t.Elem.String() }
 
 func (t *ArrayType) Zero() Value {
-	res := arrayV(make([]Value, t.Len));
+	res := arrayV(make([]Value, t.Len))
 	// TODO(austin) It's unfortunate that each element is
 	// separately heap allocated.  We could add ZeroArray to
 	// everything, though that doesn't help with multidimensional
@@ -528,7 +528,7 @@ func (t *ArrayType) Zero() Value {
 	for i := int64(0); i < t.Len; i++ {
 		res[i] = t.Elem.Zero()
 	}
-	return &res;
+	return &res
 }
 
 /*
@@ -536,14 +536,14 @@ func (t *ArrayType) Zero() Value {
  */
 
 type StructField struct {
-	Name		string;
-	Type		Type;
-	Anonymous	bool;
+	Name      string
+	Type      Type
+	Anonymous bool
 }
 
 type StructType struct {
-	commonType;
-	Elems	[]StructField;
+	commonType
+	Elems []StructField
 }
 
 var structTypes = newTypeArrayMap()
@@ -555,18 +555,18 @@ var structTypes = newTypeArrayMap()
 
 func NewStructType(fields []StructField) *StructType {
 	// Start by looking up just the types
-	fts := make([]Type, len(fields));
+	fts := make([]Type, len(fields))
 	for i, f := range fields {
 		fts[i] = f.Type
 	}
-	tMapI := structTypes.Get(fts);
+	tMapI := structTypes.Get(fts)
 	if tMapI == nil {
 		tMapI = structTypes.Put(fts, make(map[string]*StructType))
 	}
-	tMap := tMapI.(map[string]*StructType);
+	tMap := tMapI.(map[string]*StructType)
 
 	// Construct key for field names
-	key := "";
+	key := ""
 	for _, f := range fields {
 		// XXX(Spec) It's not clear if struct { T } and struct
 		// { T T } are either identical or compatible.  The
@@ -579,7 +579,7 @@ func NewStructType(fields []StructField) *StructType {
 		if f.Anonymous {
 			key += "!"
 		}
-		key += f.Name + " ";
+		key += f.Name + " "
 	}
 
 	// XXX(Spec) Do the tags also have to be identical for the
@@ -587,17 +587,17 @@ func NewStructType(fields []StructField) *StructType {
 	// otherwise, this is the only case where two distinct type
 	// objects can represent identical types.
 
-	t, ok := tMap[key];
+	t, ok := tMap[key]
 	if !ok {
 		// Create new struct type
-		t = &StructType{commonType{}, fields};
-		tMap[key] = t;
+		t = &StructType{commonType{}, fields}
+		tMap[key] = t
 	}
-	return t;
+	return t
 }
 
 func (t *StructType) compat(o Type, conv bool) bool {
-	t2, ok := o.lit().(*StructType);
+	t2, ok := o.lit().(*StructType)
 	if !ok {
 		return false
 	}
@@ -605,7 +605,7 @@ func (t *StructType) compat(o Type, conv bool) bool {
 		return false
 	}
 	for i, e := range t.Elems {
-		e2 := t2.Elems[i];
+		e2 := t2.Elems[i]
 		// XXX(Spec) An anonymous and a non-anonymous field
 		// are neither identical nor compatible.
 		if e.Anonymous != e2.Anonymous ||
@@ -614,13 +614,13 @@ func (t *StructType) compat(o Type, conv bool) bool {
 			return false
 		}
 	}
-	return true;
+	return true
 }
 
-func (t *StructType) lit() Type	{ return t }
+func (t *StructType) lit() Type { return t }
 
 func (t *StructType) String() string {
-	s := "struct {";
+	s := "struct {"
 	for i, f := range t.Elems {
 		if i > 0 {
 			s += "; "
@@ -628,17 +628,17 @@ func (t *StructType) String() string {
 		if !f.Anonymous {
 			s += f.Name + " "
 		}
-		s += f.Type.String();
+		s += f.Type.String()
 	}
-	return s + "}";
+	return s + "}"
 }
 
 func (t *StructType) Zero() Value {
-	res := structV(make([]Value, len(t.Elems)));
+	res := structV(make([]Value, len(t.Elems)))
 	for i, f := range t.Elems {
 		res[i] = f.Type.Zero()
 	}
-	return &res;
+	return &res
 }
 
 /*
@@ -646,8 +646,8 @@ func (t *StructType) Zero() Value {
  */
 
 type PtrType struct {
-	commonType;
-	Elem	Type;
+	commonType
+	Elem Type
 }
 
 var ptrTypes = make(map[Type]*PtrType)
@@ -655,39 +655,39 @@ var ptrTypes = make(map[Type]*PtrType)
 // Two pointer types are identical if they have identical base types.
 
 func NewPtrType(elem Type) *PtrType {
-	t, ok := ptrTypes[elem];
+	t, ok := ptrTypes[elem]
 	if !ok {
-		t = &PtrType{commonType{}, elem};
-		ptrTypes[elem] = t;
+		t = &PtrType{commonType{}, elem}
+		ptrTypes[elem] = t
 	}
-	return t;
+	return t
 }
 
 func (t *PtrType) compat(o Type, conv bool) bool {
-	t2, ok := o.lit().(*PtrType);
+	t2, ok := o.lit().(*PtrType)
 	if !ok {
 		return false
 	}
-	return t.Elem.compat(t2.Elem, conv);
+	return t.Elem.compat(t2.Elem, conv)
 }
 
-func (t *PtrType) lit() Type	{ return t }
+func (t *PtrType) lit() Type { return t }
 
-func (t *PtrType) String() string	{ return "*" + t.Elem.String() }
+func (t *PtrType) String() string { return "*" + t.Elem.String() }
 
-func (t *PtrType) Zero() Value	{ return &ptrV{nil} }
+func (t *PtrType) Zero() Value { return &ptrV{nil} }
 
 /*
  * Function
  */
 
 type FuncType struct {
-	commonType;
+	commonType
 	// TODO(austin) Separate receiver Type for methods?
-	In		[]Type;
-	Variadic	bool;
-	Out		[]Type;
-	builtin		string;
+	In       []Type
+	Variadic bool
+	Out      []Type
+	builtin  string
 }
 
 var funcTypes = newTypeArrayMap()
@@ -695,16 +695,16 @@ var variadicFuncTypes = newTypeArrayMap()
 
 // Create singleton function types for magic built-in functions
 var (
-	capType		= &FuncType{builtin: "cap"};
-	closeType	= &FuncType{builtin: "close"};
-	closedType	= &FuncType{builtin: "closed"};
-	lenType		= &FuncType{builtin: "len"};
-	makeType	= &FuncType{builtin: "make"};
-	newType		= &FuncType{builtin: "new"};
-	panicType	= &FuncType{builtin: "panic"};
-	paniclnType	= &FuncType{builtin: "panicln"};
-	printType	= &FuncType{builtin: "print"};
-	printlnType	= &FuncType{builtin: "println"};
+	capType     = &FuncType{builtin: "cap"}
+	closeType   = &FuncType{builtin: "close"}
+	closedType  = &FuncType{builtin: "closed"}
+	lenType     = &FuncType{builtin: "len"}
+	makeType    = &FuncType{builtin: "make"}
+	newType     = &FuncType{builtin: "new"}
+	panicType   = &FuncType{builtin: "panic"}
+	paniclnType = &FuncType{builtin: "panicln"}
+	printType   = &FuncType{builtin: "print"}
+	printlnType = &FuncType{builtin: "println"}
 )
 
 // Two function types are identical if they have the same number of
@@ -713,29 +713,29 @@ var (
 // type. Parameter and result names are not required to match.
 
 func NewFuncType(in []Type, variadic bool, out []Type) *FuncType {
-	inMap := funcTypes;
+	inMap := funcTypes
 	if variadic {
 		inMap = variadicFuncTypes
 	}
 
-	outMapI := inMap.Get(in);
+	outMapI := inMap.Get(in)
 	if outMapI == nil {
 		outMapI = inMap.Put(in, newTypeArrayMap())
 	}
-	outMap := outMapI.(typeArrayMap);
+	outMap := outMapI.(typeArrayMap)
 
-	tI := outMap.Get(out);
+	tI := outMap.Get(out)
 	if tI != nil {
 		return tI.(*FuncType)
 	}
 
-	t := &FuncType{commonType{}, in, variadic, out, ""};
-	outMap.Put(out, t);
-	return t;
+	t := &FuncType{commonType{}, in, variadic, out, ""}
+	outMap.Put(out, t)
+	return t
 }
 
 func (t *FuncType) compat(o Type, conv bool) bool {
-	t2, ok := o.lit().(*FuncType);
+	t2, ok := o.lit().(*FuncType)
 	if !ok {
 		return false
 	}
@@ -752,13 +752,13 @@ func (t *FuncType) compat(o Type, conv bool) bool {
 			return false
 		}
 	}
-	return true;
+	return true
 }
 
-func (t *FuncType) lit() Type	{ return t }
+func (t *FuncType) lit() Type { return t }
 
 func typeListString(ts []Type, ns []*ast.Ident) string {
-	s := "";
+	s := ""
 	for i, t := range ts {
 		if i > 0 {
 			s += ", "
@@ -773,61 +773,61 @@ func typeListString(ts []Type, ns []*ast.Ident) string {
 			s += t.String()
 		}
 	}
-	return s;
+	return s
 }
 
 func (t *FuncType) String() string {
 	if t.builtin != "" {
 		return "built-in function " + t.builtin
 	}
-	args := typeListString(t.In, nil);
+	args := typeListString(t.In, nil)
 	if t.Variadic {
 		if len(args) > 0 {
 			args += ", "
 		}
-		args += "...";
+		args += "..."
 	}
-	s := "func(" + args + ")";
+	s := "func(" + args + ")"
 	if len(t.Out) > 0 {
 		s += " (" + typeListString(t.Out, nil) + ")"
 	}
-	return s;
+	return s
 }
 
-func (t *FuncType) Zero() Value	{ return &funcV{nil} }
+func (t *FuncType) Zero() Value { return &funcV{nil} }
 
 type FuncDecl struct {
-	Type	*FuncType;
-	Name	*ast.Ident;	// nil for function literals
+	Type *FuncType
+	Name *ast.Ident // nil for function literals
 	// InNames will be one longer than Type.In if this function is
 	// variadic.
-	InNames		[]*ast.Ident;
-	OutNames	[]*ast.Ident;
+	InNames  []*ast.Ident
+	OutNames []*ast.Ident
 }
 
 func (t *FuncDecl) String() string {
-	s := "func";
+	s := "func"
 	if t.Name != nil {
 		s += " " + t.Name.Value
 	}
-	s += funcTypeString(t.Type, t.InNames, t.OutNames);
-	return s;
+	s += funcTypeString(t.Type, t.InNames, t.OutNames)
+	return s
 }
 
 func funcTypeString(ft *FuncType, ins []*ast.Ident, outs []*ast.Ident) string {
-	s := "(";
-	s += typeListString(ft.In, ins);
+	s := "("
+	s += typeListString(ft.In, ins)
 	if ft.Variadic {
 		if len(ft.In) > 0 {
 			s += ", "
 		}
-		s += "...";
+		s += "..."
 	}
-	s += ")";
+	s += ")"
 	if len(ft.Out) > 0 {
 		s += " (" + typeListString(ft.Out, outs) + ")"
 	}
-	return s;
+	return s
 }
 
 /*
@@ -839,76 +839,76 @@ func funcTypeString(ft *FuncType, ins []*ast.Ident, outs []*ast.Ident) string {
 // interfaces are.
 
 type InterfaceType struct {
-	commonType;
+	commonType
 	// TODO(austin) This should be a map from names to
 	// *FuncType's.  We only need the sorted list for generating
 	// the type map key.  It's detrimental for everything else.
-	methods	[]IMethod;
+	methods []IMethod
 }
 
 type IMethod struct {
-	Name	string;
-	Type	*FuncType;
+	Name string
+	Type *FuncType
 }
 
 var interfaceTypes = newTypeArrayMap()
 
 func NewInterfaceType(methods []IMethod, embeds []*InterfaceType) *InterfaceType {
 	// Count methods of embedded interfaces
-	nMethods := len(methods);
+	nMethods := len(methods)
 	for _, e := range embeds {
 		nMethods += len(e.methods)
 	}
 
 	// Combine methods
-	allMethods := make([]IMethod, nMethods);
+	allMethods := make([]IMethod, nMethods)
 	for i, m := range methods {
 		allMethods[i] = m
 	}
-	n := len(methods);
+	n := len(methods)
 	for _, e := range embeds {
 		for _, m := range e.methods {
-			allMethods[n] = m;
-			n++;
+			allMethods[n] = m
+			n++
 		}
 	}
 
 	// Sort methods
-	sort.Sort(iMethodSorter(allMethods));
+	sort.Sort(iMethodSorter(allMethods))
 
-	mts := make([]Type, len(allMethods));
+	mts := make([]Type, len(allMethods))
 	for i, m := range methods {
 		mts[i] = m.Type
 	}
-	tMapI := interfaceTypes.Get(mts);
+	tMapI := interfaceTypes.Get(mts)
 	if tMapI == nil {
 		tMapI = interfaceTypes.Put(mts, make(map[string]*InterfaceType))
 	}
-	tMap := tMapI.(map[string]*InterfaceType);
+	tMap := tMapI.(map[string]*InterfaceType)
 
-	key := "";
+	key := ""
 	for _, m := range allMethods {
 		key += m.Name + " "
 	}
 
-	t, ok := tMap[key];
+	t, ok := tMap[key]
 	if !ok {
-		t = &InterfaceType{commonType{}, allMethods};
-		tMap[key] = t;
+		t = &InterfaceType{commonType{}, allMethods}
+		tMap[key] = t
 	}
-	return t;
+	return t
 }
 
 type iMethodSorter []IMethod
 
-func (s iMethodSorter) Less(a, b int) bool	{ return s[a].Name < s[b].Name }
+func (s iMethodSorter) Less(a, b int) bool { return s[a].Name < s[b].Name }
 
-func (s iMethodSorter) Swap(a, b int)	{ s[a], s[b] = s[b], s[a] }
+func (s iMethodSorter) Swap(a, b int) { s[a], s[b] = s[b], s[a] }
 
-func (s iMethodSorter) Len() int	{ return len(s) }
+func (s iMethodSorter) Len() int { return len(s) }
 
 func (t *InterfaceType) compat(o Type, conv bool) bool {
-	t2, ok := o.lit().(*InterfaceType);
+	t2, ok := o.lit().(*InterfaceType)
 	if !ok {
 		return false
 	}
@@ -916,27 +916,27 @@ func (t *InterfaceType) compat(o Type, conv bool) bool {
 		return false
 	}
 	for i, e := range t.methods {
-		e2 := t2.methods[i];
+		e2 := t2.methods[i]
 		if e.Name != e2.Name || !e.Type.compat(e2.Type, conv) {
 			return false
 		}
 	}
-	return true;
+	return true
 }
 
-func (t *InterfaceType) lit() Type	{ return t }
+func (t *InterfaceType) lit() Type { return t }
 
 func (t *InterfaceType) String() string {
 	// TODO(austin) Instead of showing embedded interfaces, this
 	// shows their methods.
-	s := "interface {";
+	s := "interface {"
 	for i, m := range t.methods {
 		if i > 0 {
 			s += "; "
 		}
-		s += m.Name + funcTypeString(m.Type, nil, nil);
+		s += m.Name + funcTypeString(m.Type, nil, nil)
 	}
-	return s + "}";
+	return s + "}"
 }
 
 // implementedBy tests if o implements t, returning nil, true if it does.
@@ -960,24 +960,24 @@ func (t *InterfaceType) implementedBy(o Type) (*IMethod, bool) {
 	switch o := o.(type) {
 	case *NamedType:
 		for _, tm := range t.methods {
-			sm, ok := o.methods[tm.Name];
+			sm, ok := o.methods[tm.Name]
 			if !ok || sm.decl.Type != tm.Type {
 				return &tm, false
 			}
 		}
-		return nil, true;
+		return nil, true
 
 	case *InterfaceType:
-		var ti, oi int;
+		var ti, oi int
 		for ti < len(t.methods) && oi < len(o.methods) {
-			tm, om := &t.methods[ti], &o.methods[oi];
+			tm, om := &t.methods[ti], &o.methods[oi]
 			switch {
 			case tm.Name == om.Name:
 				if tm.Type != om.Type {
 					return tm, false
 				}
-				ti++;
-				oi++;
+				ti++
+				oi++
 			case tm.Name > om.Name:
 				oi++
 			default:
@@ -987,21 +987,21 @@ func (t *InterfaceType) implementedBy(o Type) (*IMethod, bool) {
 		if ti < len(t.methods) {
 			return &t.methods[ti], false
 		}
-		return nil, true;
+		return nil, true
 	}
 
-	return &t.methods[0], false;
+	return &t.methods[0], false
 }
 
-func (t *InterfaceType) Zero() Value	{ return &interfaceV{} }
+func (t *InterfaceType) Zero() Value { return &interfaceV{} }
 
 /*
  * Slice
  */
 
 type SliceType struct {
-	commonType;
-	Elem	Type;
+	commonType
+	Elem Type
 }
 
 var sliceTypes = make(map[Type]*SliceType)
@@ -1009,25 +1009,25 @@ var sliceTypes = make(map[Type]*SliceType)
 // Two slice types are identical if they have identical element types.
 
 func NewSliceType(elem Type) *SliceType {
-	t, ok := sliceTypes[elem];
+	t, ok := sliceTypes[elem]
 	if !ok {
-		t = &SliceType{commonType{}, elem};
-		sliceTypes[elem] = t;
+		t = &SliceType{commonType{}, elem}
+		sliceTypes[elem] = t
 	}
-	return t;
+	return t
 }
 
 func (t *SliceType) compat(o Type, conv bool) bool {
-	t2, ok := o.lit().(*SliceType);
+	t2, ok := o.lit().(*SliceType)
 	if !ok {
 		return false
 	}
-	return t.Elem.compat(t2.Elem, conv);
+	return t.Elem.compat(t2.Elem, conv)
 }
 
-func (t *SliceType) lit() Type	{ return t }
+func (t *SliceType) lit() Type { return t }
 
-func (t *SliceType) String() string	{ return "[]" + t.Elem.String() }
+func (t *SliceType) String() string { return "[]" + t.Elem.String() }
 
 func (t *SliceType) Zero() Value {
 	// The value of an uninitialized slice is nil. The length and
@@ -1040,38 +1040,38 @@ func (t *SliceType) Zero() Value {
  */
 
 type MapType struct {
-	commonType;
-	Key	Type;
-	Elem	Type;
+	commonType
+	Key  Type
+	Elem Type
 }
 
 var mapTypes = make(map[Type]map[Type]*MapType)
 
 func NewMapType(key Type, elem Type) *MapType {
-	ts, ok := mapTypes[key];
+	ts, ok := mapTypes[key]
 	if !ok {
-		ts = make(map[Type]*MapType);
-		mapTypes[key] = ts;
+		ts = make(map[Type]*MapType)
+		mapTypes[key] = ts
 	}
-	t, ok := ts[elem];
+	t, ok := ts[elem]
 	if !ok {
-		t = &MapType{commonType{}, key, elem};
-		ts[elem] = t;
+		t = &MapType{commonType{}, key, elem}
+		ts[elem] = t
 	}
-	return t;
+	return t
 }
 
 func (t *MapType) compat(o Type, conv bool) bool {
-	t2, ok := o.lit().(*MapType);
+	t2, ok := o.lit().(*MapType)
 	if !ok {
 		return false
 	}
-	return t.Elem.compat(t2.Elem, conv) && t.Key.compat(t2.Key, conv);
+	return t.Elem.compat(t2.Elem, conv) && t.Key.compat(t2.Key, conv)
 }
 
-func (t *MapType) lit() Type	{ return t }
+func (t *MapType) lit() Type { return t }
 
-func (t *MapType) String() string	{ return "map[" + t.Key.String() + "] " + t.Elem.String() }
+func (t *MapType) String() string { return "map[" + t.Key.String() + "] " + t.Elem.String() }
 
 func (t *MapType) Zero() Value {
 	// The value of an uninitialized map is nil.
@@ -1089,20 +1089,20 @@ type ChanType struct {
  */
 
 type Method struct {
-	decl	*FuncDecl;
-	fn	Func;
+	decl *FuncDecl
+	fn   Func
 }
 
 type NamedType struct {
-	token.Position;
-	Name	string;
+	token.Position
+	Name string
 	// Underlying type.  If incomplete is true, this will be nil.
 	// If incomplete is false and this is still nil, then this is
 	// a placeholder type representing an error.
-	Def	Type;
+	Def Type
 	// True while this type is being defined.
-	incomplete	bool;
-	methods		map[string]Method;
+	incomplete bool
+	methods    map[string]Method
 }
 
 // TODO(austin) This is temporarily needed by the debugger's remote
@@ -1120,12 +1120,12 @@ func (t *NamedType) Complete(def Type) {
 	if ndef, ok := def.(*NamedType); ok {
 		def = ndef.Def
 	}
-	t.Def = def;
-	t.incomplete = false;
+	t.Def = def
+	t.incomplete = false
 }
 
 func (t *NamedType) compat(o Type, conv bool) bool {
-	t2, ok := o.(*NamedType);
+	t2, ok := o.(*NamedType)
 	if ok {
 		if conv {
 			// Two named types are conversion compatible
@@ -1141,22 +1141,22 @@ func (t *NamedType) compat(o Type, conv bool) bool {
 	}
 	// A named and an unnamed type are compatible if the
 	// respective type literals are compatible.
-	return o.compat(t.Def, conv);
+	return o.compat(t.Def, conv)
 }
 
-func (t *NamedType) lit() Type	{ return t.Def.lit() }
+func (t *NamedType) lit() Type { return t.Def.lit() }
 
-func (t *NamedType) isBoolean() bool	{ return t.Def.isBoolean() }
+func (t *NamedType) isBoolean() bool { return t.Def.isBoolean() }
 
-func (t *NamedType) isInteger() bool	{ return t.Def.isInteger() }
+func (t *NamedType) isInteger() bool { return t.Def.isInteger() }
 
-func (t *NamedType) isFloat() bool	{ return t.Def.isFloat() }
+func (t *NamedType) isFloat() bool { return t.Def.isFloat() }
 
-func (t *NamedType) isIdeal() bool	{ return false }
+func (t *NamedType) isIdeal() bool { return false }
 
-func (t *NamedType) String() string	{ return t.Name }
+func (t *NamedType) String() string { return t.Name }
 
-func (t *NamedType) Zero() Value	{ return t.Def.Zero() }
+func (t *NamedType) Zero() Value { return t.Def.Zero() }
 
 /*
  * Multi-valued type
@@ -1166,8 +1166,8 @@ func (t *NamedType) Zero() Value	{ return t.Def.Zero() }
 // to a tuple type.  It's not generally accessible within the
 // language.
 type MultiType struct {
-	commonType;
-	Elems	[]Type;
+	commonType
+	Elems []Type
 }
 
 var multiTypes = newTypeArrayMap()
@@ -1177,13 +1177,13 @@ func NewMultiType(elems []Type) *MultiType {
 		return t.(*MultiType)
 	}
 
-	t := &MultiType{commonType{}, elems};
-	multiTypes.Put(elems, t);
-	return t;
+	t := &MultiType{commonType{}, elems}
+	multiTypes.Put(elems, t)
+	return t
 }
 
 func (t *MultiType) compat(o Type, conv bool) bool {
-	t2, ok := o.lit().(*MultiType);
+	t2, ok := o.lit().(*MultiType)
 	if !ok {
 		return false
 	}
@@ -1195,26 +1195,26 @@ func (t *MultiType) compat(o Type, conv bool) bool {
 			return false
 		}
 	}
-	return true;
+	return true
 }
 
 var EmptyType Type = NewMultiType([]Type{})
 
-func (t *MultiType) lit() Type	{ return t }
+func (t *MultiType) lit() Type { return t }
 
 func (t *MultiType) String() string {
 	if len(t.Elems) == 0 {
 		return "<none>"
 	}
-	return typeListString(t.Elems, nil);
+	return typeListString(t.Elems, nil)
 }
 
 func (t *MultiType) Zero() Value {
-	res := make([]Value, len(t.Elems));
+	res := make([]Value, len(t.Elems))
 	for i, t := range t.Elems {
 		res[i] = t.Zero()
 	}
-	return multiV(res);
+	return multiV(res)
 }
 
 /*
@@ -1227,17 +1227,17 @@ func init() {
 
 	// Make byte an alias for the named type uint8.  Type aliases
 	// are otherwise impossible in Go, so just hack it here.
-	universe.defs["byte"] = universe.defs["uint8"];
+	universe.defs["byte"] = universe.defs["uint8"]
 
 	// Built-in functions
-	universe.DefineConst("cap", universePos, capType, nil);
-	universe.DefineConst("close", universePos, closeType, nil);
-	universe.DefineConst("closed", universePos, closedType, nil);
-	universe.DefineConst("len", universePos, lenType, nil);
-	universe.DefineConst("make", universePos, makeType, nil);
-	universe.DefineConst("new", universePos, newType, nil);
-	universe.DefineConst("panic", universePos, panicType, nil);
-	universe.DefineConst("panicln", universePos, paniclnType, nil);
-	universe.DefineConst("print", universePos, printType, nil);
-	universe.DefineConst("println", universePos, printlnType, nil);
+	universe.DefineConst("cap", universePos, capType, nil)
+	universe.DefineConst("close", universePos, closeType, nil)
+	universe.DefineConst("closed", universePos, closedType, nil)
+	universe.DefineConst("len", universePos, lenType, nil)
+	universe.DefineConst("make", universePos, makeType, nil)
+	universe.DefineConst("new", universePos, newType, nil)
+	universe.DefineConst("panic", universePos, panicType, nil)
+	universe.DefineConst("panicln", universePos, paniclnType, nil)
+	universe.DefineConst("print", universePos, printType, nil)
+	universe.DefineConst("println", universePos, printlnType, nil)
 }
diff --git a/src/pkg/exp/eval/typec.go b/src/pkg/exp/eval/typec.go
index a2823b40d2..b4bc09a823 100644
--- a/src/pkg/exp/eval/typec.go
+++ b/src/pkg/exp/eval/typec.go
@@ -5,9 +5,9 @@
 package eval
 
 import (
-	"go/ast";
-	"go/token";
-	"log";
+	"go/ast"
+	"go/token"
+	"log"
 )
 
 
@@ -16,78 +16,78 @@ import (
  */
 
 type typeCompiler struct {
-	*compiler;
-	block	*block;
+	*compiler
+	block *block
 	// Check to be performed after a type declaration is compiled.
 	//
 	// TODO(austin) This will probably have to change after we
 	// eliminate forward declarations.
-	lateCheck	func() bool;
+	lateCheck func() bool
 }
 
 func (a *typeCompiler) compileIdent(x *ast.Ident, allowRec bool) Type {
-	_, _, def := a.block.Lookup(x.Value);
+	_, _, def := a.block.Lookup(x.Value)
 	if def == nil {
-		a.diagAt(x, "%s: undefined", x.Value);
-		return nil;
+		a.diagAt(x, "%s: undefined", x.Value)
+		return nil
 	}
 	switch def := def.(type) {
 	case *Constant:
-		a.diagAt(x, "constant %v used as type", x.Value);
-		return nil;
+		a.diagAt(x, "constant %v used as type", x.Value)
+		return nil
 	case *Variable:
-		a.diagAt(x, "variable %v used as type", x.Value);
-		return nil;
+		a.diagAt(x, "variable %v used as type", x.Value)
+		return nil
 	case *NamedType:
 		if !allowRec && def.incomplete {
-			a.diagAt(x, "illegal recursive type");
-			return nil;
+			a.diagAt(x, "illegal recursive type")
+			return nil
 		}
 		if !def.incomplete && def.Def == nil {
 			// Placeholder type from an earlier error
 			return nil
 		}
-		return def;
+		return def
 	case Type:
 		return def
 	}
-	log.Crashf("name %s has unknown type %T", x.Value, def);
-	return nil;
+	log.Crashf("name %s has unknown type %T", x.Value, def)
+	return nil
 }
 
 func (a *typeCompiler) compileArrayType(x *ast.ArrayType, allowRec bool) Type {
 	// Compile element type
-	elem := a.compileType(x.Elt, allowRec);
+	elem := a.compileType(x.Elt, allowRec)
 
 	// Compile length expression
 	if x.Len == nil {
 		if elem == nil {
 			return nil
 		}
-		return NewSliceType(elem);
+		return NewSliceType(elem)
 	}
 
 	if _, ok := x.Len.(*ast.Ellipsis); ok {
-		a.diagAt(x.Len, "... array initailizers not implemented");
-		return nil;
+		a.diagAt(x.Len, "... array initailizers not implemented")
+		return nil
 	}
-	l, ok := a.compileArrayLen(a.block, x.Len);
+	l, ok := a.compileArrayLen(a.block, x.Len)
 	if !ok {
 		return nil
 	}
 	if l < 0 {
-		a.diagAt(x.Len, "array length must be non-negative");
-		return nil;
+		a.diagAt(x.Len, "array length must be non-negative")
+		return nil
 	}
 	if elem == nil {
 		return nil
 	}
 
-	return NewArrayType(l, elem);
+	return NewArrayType(l, elem)
 }
 
 func countFields(fs []*ast.Field) int {
-	n := 0;
+	n := 0
 	for _, f := range fs {
 		if f.Names == nil {
 			n++
@@ -95,42 +95,42 @@ func countFields(fs []*ast.Field) int {
 			n += len(f.Names)
 		}
 	}
-	return n;
+	return n
 }
 
 func (a *typeCompiler) compileFields(fs []*ast.Field, allowRec bool) ([]Type, []*ast.Ident, []token.Position, bool) {
-	n := countFields(fs);
-	ts := make([]Type, n);
-	ns := make([]*ast.Ident, n);
-	ps := make([]token.Position, n);
+	n := countFields(fs)
+	ts := make([]Type, n)
+	ns := make([]*ast.Ident, n)
+	ps := make([]token.Position, n)
 
-	bad := false;
-	i := 0;
+	bad := false
+	i := 0
 	for _, f := range fs {
-		t := a.compileType(f.Type, allowRec);
+		t := a.compileType(f.Type, allowRec)
 		if t == nil {
 			bad = true
 		}
 		if f.Names == nil {
-			ns[i] = nil;
-			ts[i] = t;
-			ps[i] = f.Type.Pos();
-			i++;
-			continue;
+			ns[i] = nil
+			ts[i] = t
+			ps[i] = f.Type.Pos()
+			i++
+			continue
 		}
 		for _, n := range f.Names {
-			ns[i] = n;
-			ts[i] = t;
-			ps[i] = n.Pos();
-			i++;
+			ns[i] = n
+			ts[i] = t
+			ps[i] = n.Pos()
+			i++
 		}
 	}
 
-	return ts, ns, ps, bad;
+	return ts, ns, ps, bad
 }
 
 func (a *typeCompiler) compileStructType(x *ast.StructType, allowRec bool) Type {
-	ts, names, poss, bad := a.compileFields(x.Fields, allowRec);
+	ts, names, poss, bad := a.compileFields(x.Fields, allowRec)
 
 	// XXX(Spec) The spec claims that field identifiers must be
 	// unique, but 6g only checks this when they are accessed.  I
@@ -141,11 +141,11 @@ func (a *typeCompiler) compileStructType(x *ast.StructType, allowRec bool) Type
 	// There's separate language in the spec about checking
 	// uniqueness of field names inherited from anonymous fields
 	// at use time.
-	fields := make([]StructField, len(ts));
-	nameSet := make(map[string]token.Position, len(ts));
+	fields := make([]StructField, len(ts))
+	nameSet := make(map[string]token.Position, len(ts))
 	for i := range fields {
 		// Compute field name and check anonymous fields
-		var name string;
+		var name string
 		if names[i] != nil {
 			name = names[i].Value
 		} else {
@@ -153,18 +153,18 @@ func (a *typeCompiler) compileStructType(x *ast.StructType, allowRec bool) Type
 				continue
 			}
 
-			var nt *NamedType;
+			var nt *NamedType
 			// [For anonymous fields,] the unqualified
 			// type name acts as the field identifier.
 			switch t := ts[i].(type) {
 			case *NamedType:
-				name = t.Name;
-				nt = t;
+				name = t.Name
+				nt = t
 			case *PtrType:
 				switch t := t.Elem.(type) {
 				case *NamedType:
-					name = t.Name;
-					nt = t;
+					name = t.Name
+					nt = t
 				}
 			}
 			// [An anonymous field] must be specified as a
@@ -172,50 +172,50 @@ func (a *typeCompiler) compileStructType(x *ast.StructType, allowRec bool) Type
 			// *T, and T itself, may not be a pointer or
 			// interface type.
 			if nt == nil {
-				a.diagAt(&poss[i], "embedded type must T or *T, where T is a named type");
-				bad = true;
-				continue;
+				a.diagAt(&poss[i], "embedded type must T or *T, where T is a named type")
+				bad = true
+				continue
 			}
 			// The check for embedded pointer types must
 			// be deferred because of things like
 			//  type T *struct { T }
-			lateCheck := a.lateCheck;
+			lateCheck := a.lateCheck
 			a.lateCheck = func() bool {
 				if _, ok := nt.lit().(*PtrType); ok {
-					a.diagAt(&poss[i], "embedded type %v is a pointer type", nt);
-					return false;
+					a.diagAt(&poss[i], "embedded type %v is a pointer type", nt)
+					return false
 				}
-				return lateCheck();
-			};
+				return lateCheck()
+			}
 		}
 
 		// Check name uniqueness
 		if prev, ok := nameSet[name]; ok {
-			a.diagAt(&poss[i], "field %s redeclared\n\tprevious declaration at %s", name, &prev);
-			bad = true;
-			continue;
+			a.diagAt(&poss[i], "field %s redeclared\n\tprevious declaration at %s", name, &prev)
+			bad = true
+			continue
 		}
-		nameSet[name] = poss[i];
+		nameSet[name] = poss[i]
 
 		// Create field
-		fields[i].Name = name;
-		fields[i].Type = ts[i];
-		fields[i].Anonymous = (names[i] == nil);
+		fields[i].Name = name
+		fields[i].Type = ts[i]
+		fields[i].Anonymous = (names[i] == nil)
 	}
 
 	if bad {
 		return nil
 	}
 
-	return NewStructType(fields);
+	return NewStructType(fields)
 }
 
 func (a *typeCompiler) compilePtrType(x *ast.StarExpr) Type {
-	elem := a.compileType(x.X, true);
+	elem := a.compileType(x.X, true)
 	if elem == nil {
 		return nil
 	}
-	return NewPtrType(elem);
+	return NewPtrType(elem)
 }
 
 func (a *typeCompiler) compileFuncType(x *ast.FuncType, allowRec bool) *FuncDecl {
@@ -224,56 +224,56 @@ func (a *typeCompiler) compileFuncType(x *ast.FuncType, allowRec bool) *FuncDecl
 	// The types of parameters and results must be complete.
 	//
 	// TODO(austin) It's not clear they actually have to be complete.
-	in, inNames, _, inBad := a.compileFields(x.Params, allowRec);
-	out, outNames, _, outBad := a.compileFields(x.Results, allowRec);
+	in, inNames, _, inBad := a.compileFields(x.Params, allowRec)
+	out, outNames, _, outBad := a.compileFields(x.Results, allowRec)
 
 	if inBad || outBad {
 		return nil
 	}
-	return &FuncDecl{NewFuncType(in, false, out), nil, inNames, outNames};
+	return &FuncDecl{NewFuncType(in, false, out), nil, inNames, outNames}
 }
 
 func (a *typeCompiler) compileInterfaceType(x *ast.InterfaceType, allowRec bool) *InterfaceType {
-	ts, names, poss, bad := a.compileFields(x.Methods, allowRec);
+	ts, names, poss, bad := a.compileFields(x.Methods, allowRec)
 
-	methods := make([]IMethod, len(ts));
-	nameSet := make(map[string]token.Position, len(ts));
-	embeds := make([]*InterfaceType, len(ts));
+	methods := make([]IMethod, len(ts))
+	nameSet := make(map[string]token.Position, len(ts))
+	embeds := make([]*InterfaceType, len(ts))
 
-	var nm, ne int;
+	var nm, ne int
 	for i := range ts {
 		if ts[i] == nil {
 			continue
 		}
 
 		if names[i] != nil {
-			name := names[i].Value;
-			methods[nm].Name = name;
-			methods[nm].Type = ts[i].(*FuncType);
-			nm++;
+			name := names[i].Value
+			methods[nm].Name = name
+			methods[nm].Type = ts[i].(*FuncType)
+			nm++
 			if prev, ok := nameSet[name]; ok {
-				a.diagAt(&poss[i], "method %s redeclared\n\tprevious declaration at %s", name, &prev);
-				bad = true;
-				continue;
+				a.diagAt(&poss[i], "method %s redeclared\n\tprevious declaration at %s", name, &prev)
+				bad = true
+				continue
 			}
-			nameSet[name] = poss[i];
+			nameSet[name] = poss[i]
 		} else {
 			// Embedded interface
-			it, ok := ts[i].lit().(*InterfaceType);
+			it, ok := ts[i].lit().(*InterfaceType)
 			if !ok {
-				a.diagAt(&poss[i], "embedded type must be an interface");
-				bad = true;
-				continue;
+				a.diagAt(&poss[i], "embedded type must be an interface")
+				bad = true
+				continue
 			}
-			embeds[ne] = it;
-			ne++;
+			embeds[ne] = it
+			ne++
 			for _, m := range it.methods {
 				if prev, ok := nameSet[m.Name]; ok {
-					a.diagAt(&poss[i], "method %s redeclared\n\tprevious declaration at %s", m.Name, &prev);
-					bad = true;
-					continue;
+					a.diagAt(&poss[i], "method %s redeclared\n\tprevious declaration at %s", m.Name, &prev)
+					bad = true
+					continue
 				}
-				nameSet[m.Name] = poss[i];
+				nameSet[m.Name] = poss[i]
 			}
 		}
 	}
@@ -282,15 +282,15 @@ func (a *typeCompiler) compileInterfaceType(x *ast.InterfaceType, allowRec bool)
 		return nil
 	}
 
-	methods = methods[0:nm];
-	embeds = embeds[0:ne];
+	methods = methods[0:nm]
+	embeds = embeds[0:ne]
 
-	return NewInterfaceType(methods, embeds);
+	return NewInterfaceType(methods, embeds)
 }
 
 func (a *typeCompiler) compileMapType(x *ast.MapType) Type {
-	key := a.compileType(x.Key, true);
-	val := a.compileType(x.Value, true);
+	key := a.compileType(x.Key, true)
+	val := a.compileType(x.Value, true)
 	if key == nil || val == nil {
 		return nil
 	}
@@ -298,24 +298,24 @@ func (a *typeCompiler) compileMapType(x *ast.MapType) Type {
 	// that can be map keys except for function types.
 	switch key.lit().(type) {
 	case *StructType:
-		a.diagAt(x, "map key cannot be a struct type");
-		return nil;
+		a.diagAt(x, "map key cannot be a struct type")
+		return nil
 	case *ArrayType:
-		a.diagAt(x, "map key cannot be an array type");
-		return nil;
+		a.diagAt(x, "map key cannot be an array type")
+		return nil
 	case *SliceType:
-		a.diagAt(x, "map key cannot be a slice type");
-		return nil;
+		a.diagAt(x, "map key cannot be a slice type")
+		return nil
 	}
-	return NewMapType(key, val);
+	return NewMapType(key, val)
 }
 
 func (a *typeCompiler) compileType(x ast.Expr, allowRec bool) Type {
 	switch x := x.(type) {
 	case *ast.BadExpr:
 		// Error already reported by parser
-		a.silentErrors++;
-		return nil;
+		a.silentErrors++
+		return nil
 
 	case *ast.Ident:
 		return a.compileIdent(x, allowRec)
@@ -330,11 +330,11 @@ func (a *typeCompiler) compileType(x ast.Expr, allowRec bool) Type {
 		return a.compilePtrType(x)
 
 	case *ast.FuncType:
-		fd := a.compileFuncType(x, allowRec);
+		fd := a.compileFuncType(x, allowRec)
 		if fd == nil {
 			return nil
 		}
-		return fd.Type;
+		return fd.Type
 
 	case *ast.InterfaceType:
 		return a.compileInterfaceType(x, allowRec)
@@ -349,44 +349,44 @@ func (a *typeCompiler) compileType(x ast.Expr, allowRec bool) Type {
 		return a.compileType(x.X, allowRec)
 
 	case *ast.Ellipsis:
-		a.diagAt(x, "illegal use of ellipsis");
-		return nil;
+		a.diagAt(x, "illegal use of ellipsis")
+		return nil
 	}
-	a.diagAt(x, "expression used as type");
-	return nil;
+	a.diagAt(x, "expression used as type")
+	return nil
 
 notimpl:
-	a.diagAt(x, "compileType: %T not implemented", x);
-	return nil;
+	a.diagAt(x, "compileType: %T not implemented", x)
+	return nil
 }
 
 /*
  * Type compiler interface
  */
 
-func noLateCheck() bool	{ return true }
+func noLateCheck() bool { return true }
 
 func (a *compiler) compileType(b *block, typ ast.Expr) Type {
-	tc := &typeCompiler{a, b, noLateCheck};
-	t := tc.compileType(typ, false);
+	tc := &typeCompiler{a, b, noLateCheck}
+	t := tc.compileType(typ, false)
 	if !tc.lateCheck() {
 		t = nil
 	}
-	return t;
+	return t
 }
 
 func (a *compiler) compileTypeDecl(b *block, decl *ast.GenDecl) bool {
-	ok := true;
+	ok := true
 	for _, spec := range decl.Specs {
-		spec := spec.(*ast.TypeSpec);
+		spec := spec.(*ast.TypeSpec)
 		// Create incomplete type for this type
-		nt := b.DefineType(spec.Name.Value, spec.Name.Pos(), nil);
+		nt := b.DefineType(spec.Name.Value, spec.Name.Pos(), nil)
 		if nt != nil {
 			nt.(*NamedType).incomplete = true
 		}
 		// Compile type
-		tc := &typeCompiler{a, b, noLateCheck};
-		t := tc.compileType(spec.Type, false);
+		tc := &typeCompiler{a, b, noLateCheck}
+		t := tc.compileType(spec.Type, false)
 		if t == nil {
 			// Create a placeholder type
 			ok = false
@@ -397,23 +397,23 @@ func (a *compiler) compileTypeDecl(b *block, decl *ast.GenDecl) bool {
 		}
 		// Perform late type checking with complete type
 		if !tc.lateCheck() {
-			ok = false;
+			ok = false
 			if nt != nil {
 				// Make the type a placeholder
 				nt.(*NamedType).Def = nil
 			}
 		}
 	}
-	return ok;
+	return ok
 }
 
 func (a *compiler) compileFuncType(b *block, typ *ast.FuncType) *FuncDecl {
-	tc := &typeCompiler{a, b, noLateCheck};
-	res := tc.compileFuncType(typ, false);
+	tc := &typeCompiler{a, b, noLateCheck}
+	res := tc.compileFuncType(typ, false)
 	if res != nil {
 		if !tc.lateCheck() {
 			res = nil
 		}
 	}
-	return res;
+	return res
 }
diff --git a/src/pkg/exp/eval/util.go b/src/pkg/exp/eval/util.go
index bee767d882..6508346dd9 100644
--- a/src/pkg/exp/eval/util.go
+++ b/src/pkg/exp/eval/util.go
@@ -5,35 +5,35 @@
 package eval
 
 import (
-	"bignum";
+	"bignum"
 )
 
 // TODO(austin): Maybe add to bignum in more general form
 func ratToString(rat *bignum.Rational) string {
-	n, dnat := rat.Value();
-	d := bignum.MakeInt(false, dnat);
-	w, frac := n.QuoRem(d);
-	out := w.String();
+	n, dnat := rat.Value()
+	d := bignum.MakeInt(false, dnat)
+	w, frac := n.QuoRem(d)
+	out := w.String()
 	if frac.IsZero() {
 		return out
 	}
 
-	r := frac.Abs();
-	r = r.Mul(bignum.Nat(1e6));
-	dec, tail := r.DivMod(dnat);
+	r := frac.Abs()
+	r = r.Mul(bignum.Nat(1e6))
+	dec, tail := r.DivMod(dnat)
 	// Round last digit
 	if tail.Cmp(dnat.Div(bignum.Nat(2))) >= 0 {
 		dec = dec.Add(bignum.Nat(1))
 	}
 	// Strip zeros
-	ten := bignum.Nat(10);
+	ten := bignum.Nat(10)
 	for !dec.IsZero() {
-		dec2, r2 := dec.DivMod(ten);
+		dec2, r2 := dec.DivMod(ten)
 		if !r2.IsZero() {
 			break
 		}
-		dec = dec2;
+		dec = dec2
 	}
-	out += "." + dec.String();
-	return out;
+	out += "." + dec.String()
+	return out
 }
diff --git a/src/pkg/exp/eval/value.go b/src/pkg/exp/eval/value.go
index 3f823bb3ed..1558d11ddb 100644
--- a/src/pkg/exp/eval/value.go
+++ b/src/pkg/exp/eval/value.go
@@ -5,134 +5,134 @@
 package eval
 
 import (
-	"bignum";
-	"fmt";
+	"bignum"
+	"fmt"
 )
 
 type Value interface {
-	String() string;
+	String() string
 	// Assign copies another value into this one.  It should
 	// assume that the other value satisfies the same specific
 	// value interface (BoolValue, etc.), but must not assume
 	// anything about its specific type.
-	Assign(t *Thread, o Value);
+	Assign(t *Thread, o Value)
 }
 
 type BoolValue interface {
-	Value;
-	Get(*Thread) bool;
-	Set(*Thread, bool);
+	Value
+	Get(*Thread) bool
+	Set(*Thread, bool)
 }
 
 type UintValue interface {
-	Value;
-	Get(*Thread) uint64;
-	Set(*Thread, uint64);
+	Value
+	Get(*Thread) uint64
+	Set(*Thread, uint64)
 }
 
 type IntValue interface {
-	Value;
-	Get(*Thread) int64;
-	Set(*Thread, int64);
+	Value
+	Get(*Thread) int64
+	Set(*Thread, int64)
 }
 
 // TODO(austin) IdealIntValue and IdealFloatValue should not exist
 // because ideals are not l-values.
 type IdealIntValue interface {
-	Value;
-	Get() *bignum.Integer;
+	Value
+	Get() *bignum.Integer
 }
 
 type FloatValue interface {
-	Value;
-	Get(*Thread) float64;
-	Set(*Thread, float64);
+	Value
+	Get(*Thread) float64
+	Set(*Thread, float64)
 }
 
 type IdealFloatValue interface {
-	Value;
-	Get() *bignum.Rational;
+	Value
+	Get() *bignum.Rational
 }
 
 type StringValue interface {
-	Value;
-	Get(*Thread) string;
-	Set(*Thread, string);
+	Value
+	Get(*Thread) string
+	Set(*Thread, string)
 }
 
 type ArrayValue interface {
-	Value;
+	Value
 	// TODO(austin) Get() is here for uniformity, but is
 	// completely useless.  If a lot of other types have similarly
 	// useless Get methods, just special-case these uses.
-	Get(*Thread) ArrayValue;
-	Elem(*Thread, int64) Value;
+	Get(*Thread) ArrayValue
+	Elem(*Thread, int64) Value
 	// Sub returns an ArrayValue backed by the same array that
 	// starts from element i and has length len.
-	Sub(i int64, len int64) ArrayValue;
+	Sub(i int64, len int64) ArrayValue
 }
 
 type StructValue interface {
-	Value;
+	Value
 	// TODO(austin) This is another useless Get()
-	Get(*Thread) StructValue;
-	Field(*Thread, int) Value;
+	Get(*Thread) StructValue
+	Field(*Thread, int) Value
 }
 
 type PtrValue interface {
-	Value;
-	Get(*Thread) Value;
-	Set(*Thread, Value);
+	Value
+	Get(*Thread) Value
+	Set(*Thread, Value)
 }
 
 type Func interface {
-	NewFrame() *Frame;
-	Call(*Thread);
+	NewFrame() *Frame
+	Call(*Thread)
 }
 
 type FuncValue interface {
-	Value;
-	Get(*Thread) Func;
-	Set(*Thread, Func);
+	Value
+	Get(*Thread) Func
+	Set(*Thread, Func)
 }
 
 type Interface struct {
-	Type	Type;
-	Value	Value;
+	Type  Type
+	Value Value
 }
 
 type InterfaceValue interface {
-	Value;
-	Get(*Thread) Interface;
-	Set(*Thread, Interface);
+	Value
+	Get(*Thread) Interface
+	Set(*Thread, Interface)
 }
 
 type Slice struct {
-	Base		ArrayValue;
-	Len, Cap	int64;
+	Base     ArrayValue
+	Len, Cap int64
 }
 
 type SliceValue interface {
-	Value;
-	Get(*Thread) Slice;
-	Set(*Thread, Slice);
+	Value
+	Get(*Thread) Slice
+	Set(*Thread, Slice)
 }
 
 type Map interface {
-	Len(*Thread) int64;
+	Len(*Thread) int64
 	// Retrieve an element from the map, returning nil if it does
 	// not exist.
-	Elem(t *Thread, key interface{}) Value;
+	Elem(t *Thread, key interface{}) Value
 	// Set an entry in the map.  If val is nil, delete the entry.
-	SetElem(t *Thread, key interface{}, val Value);
+	SetElem(t *Thread, key interface{}, val Value)
 	// TODO(austin)  Perhaps there should be an iterator interface instead.
-	Iter(func(key interface{}, val Value) bool);
+	Iter(func(key interface{}, val Value) bool)
 }
 
 type MapValue interface {
-	Value;
-	Get(*Thread) Map;
-	Set(*Thread, Map);
+	Value
+	Get(*Thread) Map
+	Set(*Thread, Map)
 }
 
 /*
@@ -141,13 +141,13 @@ type MapValue interface {
 
 type boolV bool
 
-func (v *boolV) String() string	{ return fmt.Sprint(*v) }
+func (v *boolV) String() string { return fmt.Sprint(*v) }
 
-func (v *boolV) Assign(t *Thread, o Value)	{ *v = boolV(o.(BoolValue).Get(t)) }
+func (v *boolV) Assign(t *Thread, o Value) { *v = boolV(o.(BoolValue).Get(t)) }
 
-func (v *boolV) Get(*Thread) bool	{ return bool(*v) }
+func (v *boolV) Get(*Thread) bool { return bool(*v) }
 
-func (v *boolV) Set(t *Thread, x bool)	{ *v = boolV(x) }
+func (v *boolV) Set(t *Thread, x bool) { *v = boolV(x) }
 
 /*
  * Uint
@@ -155,63 +155,63 @@ func (v *boolV) Set(t *Thread, x bool)	{ *v = boolV(x) }
 
 type uint8V uint8
 
-func (v *uint8V) String() string	{ return fmt.Sprint(*v) }
+func (v *uint8V) String() string { return fmt.Sprint(*v) }
 
-func (v *uint8V) Assign(t *Thread, o Value)	{ *v = uint8V(o.(UintValue).Get(t)) }
+func (v *uint8V) Assign(t *Thread, o Value) { *v = uint8V(o.(UintValue).Get(t)) }
 
-func (v *uint8V) Get(*Thread) uint64	{ return uint64(*v) }
+func (v *uint8V) Get(*Thread) uint64 { return uint64(*v) }
 
-func (v *uint8V) Set(t *Thread, x uint64)	{ *v = uint8V(x) }
+func (v *uint8V) Set(t *Thread, x uint64) { *v = uint8V(x) }
 
 type uint16V uint16
 
-func (v *uint16V) String() string	{ return fmt.Sprint(*v) }
+func (v *uint16V) String() string { return fmt.Sprint(*v) }
 
-func (v *uint16V) Assign(t *Thread, o Value)	{ *v = uint16V(o.(UintValue).Get(t)) }
+func (v *uint16V) Assign(t *Thread, o Value) { *v = uint16V(o.(UintValue).Get(t)) }
 
-func (v *uint16V) Get(*Thread) uint64	{ return uint64(*v) }
+func (v *uint16V) Get(*Thread) uint64 { return uint64(*v) }
 
-func (v *uint16V) Set(t *Thread, x uint64)	{ *v = uint16V(x) }
+func (v *uint16V) Set(t *Thread, x uint64) { *v = uint16V(x) }
 
 type uint32V uint32
 
-func (v *uint32V) String() string	{ return fmt.Sprint(*v) }
+func (v *uint32V) String() string { return fmt.Sprint(*v) }
 
-func (v *uint32V) Assign(t *Thread, o Value)	{ *v = uint32V(o.(UintValue).Get(t)) }
+func (v *uint32V) Assign(t *Thread, o Value) { *v = uint32V(o.(UintValue).Get(t)) }
 
-func (v *uint32V) Get(*Thread) uint64	{ return uint64(*v) }
+func (v *uint32V) Get(*Thread) uint64 { return uint64(*v) }
 
-func (v *uint32V) Set(t *Thread, x uint64)	{ *v = uint32V(x) }
+func (v *uint32V) Set(t *Thread, x uint64) { *v = uint32V(x) }
 
 type uint64V uint64
 
-func (v *uint64V) String() string	{ return fmt.Sprint(*v) }
+func (v *uint64V) String() string { return fmt.Sprint(*v) }
 
-func (v *uint64V) Assign(t *Thread, o Value)	{ *v = uint64V(o.(UintValue).Get(t)) }
+func (v *uint64V) Assign(t *Thread, o Value) { *v = uint64V(o.(UintValue).Get(t)) }
 
-func (v *uint64V) Get(*Thread) uint64	{ return uint64(*v) }
+func (v *uint64V) Get(*Thread) uint64 { return uint64(*v) }
 
-func (v *uint64V) Set(t *Thread, x uint64)	{ *v = uint64V(x) }
+func (v *uint64V) Set(t *Thread, x uint64) { *v = uint64V(x) }
 
 type uintV uint
 
-func (v *uintV) String() string	{ return fmt.Sprint(*v) }
+func (v *uintV) String() string { return fmt.Sprint(*v) }
 
-func (v *uintV) Assign(t *Thread, o Value)	{ *v = uintV(o.(UintValue).Get(t)) }
+func (v *uintV) Assign(t *Thread, o Value) { *v = uintV(o.(UintValue).Get(t)) }
 
-func (v *uintV) Get(*Thread) uint64	{ return uint64(*v) }
+func (v *uintV) Get(*Thread) uint64 { return uint64(*v) }
 
-func (v *uintV) Set(t *Thread, x uint64)	{ *v = uintV(x) }
+func (v *uintV) Set(t *Thread, x uint64) { *v = uintV(x) }
 
 type uintptrV uintptr
 
-func (v *uintptrV) String() string	{ return fmt.Sprint(*v) }
+func (v *uintptrV) String() string { return fmt.Sprint(*v) }
 
-func (v *uintptrV) Assign(t *Thread, o Value)	{ *v = uintptrV(o.(UintValue).Get(t)) }
+func (v *uintptrV) Assign(t *Thread, o Value) { *v = uintptrV(o.(UintValue).Get(t)) }
 
-func (v *uintptrV) Get(*Thread) uint64	{ return uint64(*v) }
+func (v *uintptrV) Get(*Thread) uint64 { return uint64(*v) }
 
-func (v *uintptrV) Set(t *Thread, x uint64)	{ *v = uintptrV(x) }
+func (v *uintptrV) Set(t *Thread, x uint64) { *v = uintptrV(x) }
 
 /*
  * Int
@@ -219,69 +219,69 @@ func (v *uintptrV) Set(t *Thread, x uint64)	{ *v = uintptrV(x) }
 
 type int8V int8
 
-func (v *int8V) String() string	{ return fmt.Sprint(*v) }
+func (v *int8V) String() string { return fmt.Sprint(*v) }
 
-func (v *int8V) Assign(t *Thread, o Value)	{ *v = int8V(o.(IntValue).Get(t)) }
+func (v *int8V) Assign(t *Thread, o Value) { *v = int8V(o.(IntValue).Get(t)) }
 
-func (v *int8V) Get(*Thread) int64	{ return int64(*v) }
+func (v *int8V) Get(*Thread) int64 { return int64(*v) }
 
-func (v *int8V) Set(t *Thread, x int64)	{ *v = int8V(x) }
+func (v *int8V) Set(t *Thread, x int64) { *v = int8V(x) }
 
 type int16V int16
 
-func (v *int16V) String() string	{ return fmt.Sprint(*v) }
+func (v *int16V) String() string { return fmt.Sprint(*v) }
 
-func (v *int16V) Assign(t *Thread, o Value)	{ *v = int16V(o.(IntValue).Get(t)) }
+func (v *int16V) Assign(t *Thread, o Value) { *v = int16V(o.(IntValue).Get(t)) }
 
-func (v *int16V) Get(*Thread) int64	{ return int64(*v) }
+func (v *int16V) Get(*Thread) int64 { return int64(*v) }
 
-func (v *int16V) Set(t *Thread, x int64)	{ *v = int16V(x) }
+func (v *int16V) Set(t *Thread, x int64) { *v = int16V(x) }
 
 type int32V int32
 
-func (v *int32V) String() string	{ return fmt.Sprint(*v) }
+func (v *int32V) String() string { return fmt.Sprint(*v) }
 
-func (v *int32V) Assign(t *Thread, o Value)	{ *v = int32V(o.(IntValue).Get(t)) }
+func (v *int32V) Assign(t *Thread, o Value) { *v = int32V(o.(IntValue).Get(t)) }
 
-func (v *int32V) Get(*Thread) int64	{ return int64(*v) }
+func (v *int32V) Get(*Thread) int64 { return int64(*v) }
 
-func (v *int32V) Set(t *Thread, x int64)	{ *v = int32V(x) }
+func (v *int32V) Set(t *Thread, x int64) { *v = int32V(x) }
 
 type int64V int64
 
-func (v *int64V) String() string	{ return fmt.Sprint(*v) }
+func (v *int64V) String() string { return fmt.Sprint(*v) }
 
-func (v *int64V) Assign(t *Thread, o Value)	{ *v = int64V(o.(IntValue).Get(t)) }
+func (v *int64V) Assign(t *Thread, o Value) { *v = int64V(o.(IntValue).Get(t)) }
 
-func (v *int64V) Get(*Thread) int64	{ return int64(*v) }
+func (v *int64V) Get(*Thread) int64 { return int64(*v) }
 
-func (v *int64V) Set(t *Thread, x int64)	{ *v = int64V(x) }
+func (v *int64V) Set(t *Thread, x int64) { *v = int64V(x) }
 
 type intV int
 
-func (v *intV) String() string	{ return fmt.Sprint(*v) }
+func (v *intV) String() string { return fmt.Sprint(*v) }
 
-func (v *intV) Assign(t *Thread, o Value)	{ *v = intV(o.(IntValue).Get(t)) }
+func (v *intV) Assign(t *Thread, o Value) { *v = intV(o.(IntValue).Get(t)) }
 
-func (v *intV) Get(*Thread) int64	{ return int64(*v) }
+func (v *intV) Get(*Thread) int64 { return int64(*v) }
 
-func (v *intV) Set(t *Thread, x int64)	{ *v = intV(x) }
+func (v *intV) Set(t *Thread, x int64) { *v = intV(x) }
 
 /*
  * Ideal int
  */
 
 type idealIntV struct {
-	V *bignum.Integer;
+	V *bignum.Integer
 }
 
-func (v *idealIntV) String() string	{ return v.V.String() }
+func (v *idealIntV) String() string { return v.V.String() }
 
 func (v *idealIntV) Assign(t *Thread, o Value) {
 	v.V = o.(IdealIntValue).Get()
 }
 
-func (v *idealIntV) Get() *bignum.Integer	{ return v.V }
+func (v *idealIntV) Get() *bignum.Integer { return v.V }
 
 /*
  * Float
@@ -289,49 +289,49 @@ func (v *idealIntV) Get() *bignum.Integer	{ return v.V }
 
 type float32V float32
 
-func (v *float32V) String() string	{ return fmt.Sprint(*v) }
+func (v *float32V) String() string { return fmt.Sprint(*v) }
 
-func (v *float32V) Assign(t *Thread, o Value)	{ *v = float32V(o.(FloatValue).Get(t)) }
+func (v *float32V) Assign(t *Thread, o Value) { *v = float32V(o.(FloatValue).Get(t)) }
 
-func (v *float32V) Get(*Thread) float64	{ return float64(*v) }
+func (v *float32V) Get(*Thread) float64 { return float64(*v) }
 
-func (v *float32V) Set(t *Thread, x float64)	{ *v = float32V(x) }
+func (v *float32V) Set(t *Thread, x float64) { *v = float32V(x) }
 
 type float64V float64
 
-func (v *float64V) String() string	{ return fmt.Sprint(*v) }
+func (v *float64V) String() string { return fmt.Sprint(*v) }
 
-func (v *float64V) Assign(t *Thread, o Value)	{ *v = float64V(o.(FloatValue).Get(t)) }
+func (v *float64V) Assign(t *Thread, o Value) { *v = float64V(o.(FloatValue).Get(t)) }
 
-func (v *float64V) Get(*Thread) float64	{ return float64(*v) }
+func (v *float64V) Get(*Thread) float64 { return float64(*v) }
 
-func (v *float64V) Set(t *Thread, x float64)	{ *v = float64V(x) }
+func (v *float64V) Set(t *Thread, x float64) { *v = float64V(x) }
 
 type floatV float
 
-func (v *floatV) String() string	{ return fmt.Sprint(*v) }
+func (v *floatV) String() string { return fmt.Sprint(*v) }
 
-func (v *floatV) Assign(t *Thread, o Value)	{ *v = floatV(o.(FloatValue).Get(t)) }
+func (v *floatV) Assign(t *Thread, o Value) { *v = floatV(o.(FloatValue).Get(t)) }
 
-func (v *floatV) Get(*Thread) float64	{ return float64(*v) }
+func (v *floatV) Get(*Thread) float64 { return float64(*v) }
 
-func (v *floatV) Set(t *Thread, x float64)	{ *v = floatV(x) }
+func (v *floatV) Set(t *Thread, x float64) { *v = floatV(x) }
 
 /*
  * Ideal float
  */
 
 type idealFloatV struct {
-	V *bignum.Rational;
+	V *bignum.Rational
 }
 
-func (v *idealFloatV) String() string	{ return ratToString(v.V) }
+func (v *idealFloatV) String() string { return ratToString(v.V) }
 
 func (v *idealFloatV) Assign(t *Thread, o Value) {
 	v.V = o.(IdealFloatValue).Get()
 }
 
-func (v *idealFloatV) Get() *bignum.Rational	{ return v.V }
+func (v *idealFloatV) Get() *bignum.Rational { return v.V }
 
 /*
  * String
@@ -339,13 +339,13 @@ func (v *idealFloatV) Get() *bignum.Rational	{ return v.V }
 
 type stringV string
 
-func (v *stringV) String() string	{ return fmt.Sprint(*v) }
+func (v *stringV) String() string { return fmt.Sprint(*v) }
 
-func (v *stringV) Assign(t *Thread, o Value)	{ *v = stringV(o.(StringValue).Get(t)) }
+func (v *stringV) Assign(t *Thread, o Value) { *v = stringV(o.(StringValue).Get(t)) }
 
-func (v *stringV) Get(*Thread) string	{ return string(*v) }
+func (v *stringV) Get(*Thread) string { return string(*v) }
 
-func (v *stringV) Set(t *Thread, x string)	{ *v = stringV(x) }
+func (v *stringV) Set(t *Thread, x string) { *v = stringV(x) }
 
 /*
  * Array
@@ -354,33 +354,33 @@ func (v *stringV) Set(t *Thread, x string)	{ *v = stringV(x) }
 type arrayV []Value
 
 func (v *arrayV) String() string {
-	res := "{";
+	res := "{"
 	for i, e := range *v {
 		if i > 0 {
 			res += ", "
 		}
-		res += e.String();
+		res += e.String()
 	}
-	return res + "}";
+	return res + "}"
 }
 
 func (v *arrayV) Assign(t *Thread, o Value) {
-	oa := o.(ArrayValue);
-	l := int64(len(*v));
+	oa := o.(ArrayValue)
+	l := int64(len(*v))
 	for i := int64(0); i < l; i++ {
 		(*v)[i].Assign(t, oa.Elem(t, i))
 	}
 }
 
-func (v *arrayV) Get(*Thread) ArrayValue	{ return v }
+func (v *arrayV) Get(*Thread) ArrayValue { return v }
 
 func (v *arrayV) Elem(t *Thread, i int64) Value {
 	return (*v)[i]
 }
 
 func (v *arrayV) Sub(i int64, len int64) ArrayValue {
-	res := (*v)[i : i+len];
-	return &res;
+	res := (*v)[i : i+len]
+	return &res
 }
 
 /*
@@ -392,25 +392,25 @@ type structV []Value
 // TODO(austin) Should these methods (and arrayV's) be on structV
 // instead of *structV?
 func (v *structV) String() string {
-	res := "{";
+	res := "{"
 	for i, v := range *v {
 		if i > 0 {
 			res += ", "
 		}
-		res += v.String();
+		res += v.String()
 	}
-	return res + "}";
+	return res + "}"
 }
 
 func (v *structV) Assign(t *Thread, o Value) {
-	oa := o.(StructValue);
-	l := len(*v);
+	oa := o.(StructValue)
+	l := len(*v)
 	for i := 0; i < l; i++ {
 		(*v)[i].Assign(t, oa.Field(t, i))
 	}
 }
 
-func (v *structV) Get(*Thread) StructValue	{ return v }
+func (v *structV) Get(*Thread) StructValue { return v }
 
 func (v *structV) Field(t *Thread, i int) Value {
 	return (*v)[i]
@@ -422,28 +422,28 @@ func (v *structV) Field(t *Thread, i int) Value {
 
 type ptrV struct {
 	// nil if the pointer is nil
-	target Value;
+	target Value
 }
 
 func (v *ptrV) String() string {
 	if v.target == nil {
 		return "<nil>"
 	}
-	return "&" + v.target.String();
+	return "&" + v.target.String()
 }
 
-func (v *ptrV) Assign(t *Thread, o Value)	{ v.target = o.(PtrValue).Get(t) }
+func (v *ptrV) Assign(t *Thread, o Value) { v.target = o.(PtrValue).Get(t) }
 
-func (v *ptrV) Get(*Thread) Value	{ return v.target }
+func (v *ptrV) Get(*Thread) Value { return v.target }
 
-func (v *ptrV) Set(t *Thread, x Value)	{ v.target = x }
+func (v *ptrV) Set(t *Thread, x Value) { v.target = x }
 
 /*
  * Functions
  */
 
 type funcV struct {
-	target Func;
+	target Func
 }
 
 func (v *funcV) String() string {
@@ -451,32 +451,32 @@ func (v *funcV) String() string {
 	return "func {...}"
 }
 
-func (v *funcV) Assign(t *Thread, o Value)	{ v.target = o.(FuncValue).Get(t) }
+func (v *funcV) Assign(t *Thread, o Value) { v.target = o.(FuncValue).Get(t) }
 
-func (v *funcV) Get(*Thread) Func	{ return v.target }
+func (v *funcV) Get(*Thread) Func { return v.target }
 
-func (v *funcV) Set(t *Thread, x Func)	{ v.target = x }
+func (v *funcV) Set(t *Thread, x Func) { v.target = x }
 
 /*
  * Interfaces
  */
 
 type interfaceV struct {
-	Interface;
+	Interface
 }
 
 func (v *interfaceV) String() string {
 	if v.Type == nil || v.Value == nil {
 		return "<nil>"
 	}
-	return v.Value.String();
+	return v.Value.String()
 }
 
 func (v *interfaceV) Assign(t *Thread, o Value) {
 	v.Interface = o.(InterfaceValue).Get(t)
 }
 
-func (v *interfaceV) Get(*Thread) Interface	{ return v.Interface }
+func (v *interfaceV) Get(*Thread) Interface { return v.Interface }
 
 func (v *interfaceV) Set(t *Thread, x Interface) {
 	v.Interface = x
@@ -487,62 +487,62 @@ func (v *interfaceV) Set(t *Thread, x Interface) {
  */
 
 type sliceV struct {
-	Slice;
+	Slice
 }
 
 func (v *sliceV) String() string {
 	if v.Base == nil {
 		return "<nil>"
 	}
-	return v.Base.Sub(0, v.Len).String();
+	return v.Base.Sub(0, v.Len).String()
 }
 
-func (v *sliceV) Assign(t *Thread, o Value)	{ v.Slice = o.(SliceValue).Get(t) }
+func (v *sliceV) Assign(t *Thread, o Value) { v.Slice = o.(SliceValue).Get(t) }
 
-func (v *sliceV) Get(*Thread) Slice	{ return v.Slice }
+func (v *sliceV) Get(*Thread) Slice { return v.Slice }
 
-func (v *sliceV) Set(t *Thread, x Slice)	{ v.Slice = x }
+func (v *sliceV) Set(t *Thread, x Slice) { v.Slice = x }
 
 /*
  * Maps
  */
 
 type mapV struct {
-	target Map;
+	target Map
 }
 
 func (v *mapV) String() string {
 	if v.target == nil {
 		return "<nil>"
 	}
-	res := "map[";
-	i := 0;
+	res := "map["
+	i := 0
 	v.target.Iter(func(key interface{}, val Value) bool {
 		if i > 0 {
 			res += ", "
 		}
-		i++;
-		res += fmt.Sprint(key) + ":" + val.String();
-		return true;
-	});
-	return res + "]";
+		i++
+		res += fmt.Sprint(key) + ":" + val.String()
+		return true
+	})
+	return res + "]"
 }
 
-func (v *mapV) Assign(t *Thread, o Value)	{ v.target = o.(MapValue).Get(t) }
+func (v *mapV) Assign(t *Thread, o Value) { v.target = o.(MapValue).Get(t) }
 
-func (v *mapV) Get(*Thread) Map	{ return v.target }
+func (v *mapV) Get(*Thread) Map { return v.target }
 
-func (v *mapV) Set(t *Thread, x Map)	{ v.target = x }
+func (v *mapV) Set(t *Thread, x Map) { v.target = x }
 
 type evalMap map[interface{}]Value
 
-func (m evalMap) Len(t *Thread) int64	{ return int64(len(m)) }
+func (m evalMap) Len(t *Thread) int64 { return int64(len(m)) }
 
 func (m evalMap) Elem(t *Thread, key interface{}) Value {
 	if v, ok := m[key]; ok {
 		return v
 	}
-	return nil;
+	return nil
 }
 
 func (m evalMap) SetElem(t *Thread, key interface{}, val Value) {
@@ -568,18 +568,18 @@ func (m evalMap) Iter(cb func(key interface{}, val Value) bool) {
 type multiV []Value
 
 func (v multiV) String() string {
-	res := "(";
+	res := "("
 	for i, v := range v {
 		if i > 0 {
 			res += ", "
 		}
-		res += v.String();
+		res += v.String()
 	}
-	return res + ")";
+	return res + ")"
 }
 
 func (v multiV) Assign(t *Thread, o Value) {
-	omv := o.(multiV);
+	omv := o.(multiV)
 	for i := range v {
 		v[i].Assign(t, omv[i])
 	}
@@ -592,10 +592,10 @@ func (v multiV) Assign(t *Thread, o Value) {
 // TODO(austin) Nothing complains if I accidentally define init with
 // arguments.  Is this intentional?
 func init() {
-	s := universe;
+	s := universe
 
-	true := boolV(true);
-	s.DefineConst("true", universePos, BoolType, &true);
-	false := boolV(false);
-	s.DefineConst("false", universePos, BoolType, &false);
+	true := boolV(true)
+	s.DefineConst("true", universePos, BoolType, &true)
+	false := boolV(false)
+	s.DefineConst("false", universePos, BoolType, &false)
 }
diff --git a/src/pkg/exp/eval/world.go b/src/pkg/exp/eval/world.go
index 184e737c65..c36081b263 100644
--- a/src/pkg/exp/eval/world.go
+++ b/src/pkg/exp/eval/world.go
@@ -8,37 +8,37 @@
 package eval
 
 import (
-	"go/ast";
-	parser "exp/parser";
-	"go/scanner";
-	"go/token";
-	"os";
+	"go/ast"
+	parser "exp/parser"
+	"go/scanner"
+	"go/token"
+	"os"
 )
 
 type World struct {
-	scope	*Scope;
-	frame	*Frame;
+	scope *Scope
+	frame *Frame
 }
 
 func NewWorld() *World {
-	w := new(World);
-	w.scope = universe.ChildScope();
-	w.scope.global = true;	// this block's vars allocate directly
-	return w;
+	w := new(World)
+	w.scope = universe.ChildScope()
+	w.scope.global = true // this block's vars allocate directly
+	return w
 }
 
 type Code interface {
 	// The type of the value Run returns, or nil if Run returns nil.
-	Type() Type;
+	Type() Type
 
 	// Run runs the code; if the code is a single expression
 	// with a value, it returns the value; otherwise it returns nil.
-	Run() (Value, os.Error);
+	Run() (Value, os.Error)
 }
 
 type stmtCode struct {
-	w	*World;
-	code	code;
+	w    *World
+	code code
 }
 
 func (w *World) CompileStmtList(stmts []ast.Stmt) (Code, os.Error) {
@@ -47,9 +47,9 @@ func (w *World) CompileStmtList(stmts []ast.Stmt) (Code, os.Error) {
 			return w.CompileExpr(s.X)
 		}
 	}
-	errors := new(scanner.ErrorVector);
-	cc := &compiler{errors, 0, 0};
-	cb := newCodeBuf();
+	errors := new(scanner.ErrorVector)
+	cc := &compiler{errors, 0, 0}
+	cb := newCodeBuf()
 	fc := &funcCompiler{
 		compiler: cc,
 		fnType: nil,
@@ -57,53 +57,53 @@ func (w *World) CompileStmtList(stmts []ast.Stmt) (Code, os.Error) {
 		codeBuf: cb,
 		flow: newFlowBuf(cb),
 		labels: make(map[string]*label),
-	};
+	}
 	bc := &blockCompiler{
 		funcCompiler: fc,
 		block: w.scope.block,
-	};
-	nerr := cc.numError();
+	}
+	nerr := cc.numError()
 	for _, stmt := range stmts {
 		bc.compileStmt(stmt)
 	}
-	fc.checkLabels();
+	fc.checkLabels()
 	if nerr != cc.numError() {
 		return nil, errors.GetError(scanner.Sorted)
 	}
-	return &stmtCode{w, fc.get()}, nil;
+	return &stmtCode{w, fc.get()}, nil
 }
 
 func (w *World) CompileDeclList(decls []ast.Decl) (Code, os.Error) {
-	stmts := make([]ast.Stmt, len(decls));
+	stmts := make([]ast.Stmt, len(decls))
 	for i, d := range decls {
 		stmts[i] = &ast.DeclStmt{d}
 	}
-	return w.CompileStmtList(stmts);
+	return w.CompileStmtList(stmts)
 }
 
-func (s *stmtCode) Type() Type	{ return nil }
+func (s *stmtCode) Type() Type { return nil }
 
 func (s *stmtCode) Run() (Value, os.Error) {
-	t := new(Thread);
-	t.f = s.w.scope.NewFrame(nil);
-	return nil, t.Try(func(t *Thread) { s.code.exec(t) });
+	t := new(Thread)
+	t.f = s.w.scope.NewFrame(nil)
+	return nil, t.Try(func(t *Thread) { s.code.exec(t) })
 }
 
 type exprCode struct {
-	w	*World;
-	e	*expr;
-	eval	func(Value, *Thread);
+	w    *World
+	e    *expr
+	eval func(Value, *Thread)
 }
 
 func (w *World) CompileExpr(e ast.Expr) (Code, os.Error) {
-	errors := new(scanner.ErrorVector);
-	cc := &compiler{errors, 0, 0};
+	errors := new(scanner.ErrorVector)
+	cc := &compiler{errors, 0, 0}
 
-	ec := cc.compileExpr(w.scope.block, false, e);
+	ec := cc.compileExpr(w.scope.block, false, e)
 	if ec == nil {
 		return nil, errors.GetError(scanner.Sorted)
 	}
-	var eval func(Value, *Thread);
+	var eval func(Value, *Thread)
 	switch t := ec.t.(type) {
 	case *idealIntType:
 		// nothing
@@ -113,36 +113,36 @@ func (w *World) CompileExpr(e ast.Expr) (Code, os.Error) {
 		if tm, ok := t.(*MultiType); ok && len(tm.Elems) == 0 {
 			return &stmtCode{w, code{ec.exec}}, nil
 		}
-		eval = genAssign(ec.t, ec);
+		eval = genAssign(ec.t, ec)
 	}
-	return &exprCode{w, ec, eval}, nil;
+	return &exprCode{w, ec, eval}, nil
 }
 
-func (e *exprCode) Type() Type	{ return e.e.t }
+func (e *exprCode) Type() Type { return e.e.t }
 
 func (e *exprCode) Run() (Value, os.Error) {
-	t := new(Thread);
-	t.f = e.w.scope.NewFrame(nil);
+	t := new(Thread)
+	t.f = e.w.scope.NewFrame(nil)
 	switch e.e.t.(type) {
 	case *idealIntType:
 		return &idealIntV{e.e.asIdealInt()()}, nil
 	case *idealFloatType:
 		return &idealFloatV{e.e.asIdealFloat()()}, nil
 	}
-	v := e.e.t.Zero();
-	eval := e.eval;
-	err := t.Try(func(t *Thread) { eval(v, t) });
-	return v, err;
+	v := e.e.t.Zero()
+	eval := e.eval
+	err := t.Try(func(t *Thread) { eval(v, t) })
+	return v, err
 }
 
 func (w *World) Compile(text string) (Code, os.Error) {
-	stmts, err := parser.ParseStmtList("input", text);
+	stmts, err := parser.ParseStmtList("input", text)
 	if err == nil {
 		return w.CompileStmtList(stmts)
 	}
 
 	// Otherwise try as DeclList.
-	decls, err1 := parser.ParseDeclList("input", text);
+	decls, err1 := parser.ParseDeclList("input", text)
 	if err1 == nil {
 		return w.CompileDeclList(decls)
 	}
@@ -150,36 +150,36 @@ func (w *World) Compile(text string) (Code, os.Error) {
 	// Have to pick an error.
 	// Parsing as statement list admits more forms,
 	// its error is more likely to be useful.
-	return nil, err;
+	return nil, err
 }
 
 type RedefinitionError struct {
-	Name	string;
-	Prev	Def;
+	Name string
+	Prev Def
 }
 
 func (e *RedefinitionError) String() string {
-	res := "identifier " + e.Name + " redeclared";
-	pos := e.Prev.Pos();
+	res := "identifier " + e.Name + " redeclared"
+	pos := e.Prev.Pos()
 	if pos.IsValid() {
 		res += "; previous declaration at " + pos.String()
 	}
-	return res;
+	return res
 }
 
 func (w *World) DefineConst(name string, t Type, val Value) os.Error {
-	_, prev := w.scope.DefineConst(name, token.Position{}, t, val);
+	_, prev := w.scope.DefineConst(name, token.Position{}, t, val)
 	if prev != nil {
 		return &RedefinitionError{name, prev}
 	}
-	return nil;
+	return nil
 }
 
 func (w *World) DefineVar(name string, t Type, val Value) os.Error {
-	v, prev := w.scope.DefineVar(name, token.Position{}, t);
+	v, prev := w.scope.DefineVar(name, token.Position{}, t)
 	if prev != nil {
 		return &RedefinitionError{name, prev}
 	}
-	v.Init = val;
-	return nil;
+	v.Init = val
+	return nil
 }
diff --git a/src/pkg/exp/exception/exception.go b/src/pkg/exp/exception/exception.go
index 45e0be3f1d..e34d0f0d76 100644
--- a/src/pkg/exp/exception/exception.go
+++ b/src/pkg/exp/exception/exception.go
@@ -11,8 +11,8 @@
 package exception
 
 import (
-	"fmt";
-	"runtime";
+	"fmt"
+	"runtime"
 )
 
 // A Handler function handles an arbitrary exception value x.
@@ -20,7 +20,7 @@ type Handler func(x interface{})
 
 // An Exception carries an exception value.
 type Exception struct {
-	Value interface{};	// Value may be the nil exception
+	Value interface{} // Value may be the nil exception
 }
 
 // Try invokes a function f with a Handler to throw exceptions.
@@ -51,18 +51,18 @@ type Exception struct {
 //	})
 //
 func Try(f func(throw Handler)) *Exception {
-	h := make(chan *Exception);
+	h := make(chan *Exception)
 
 	// execute try block
 	go func() {
 		f(func(x interface{}) {
-			h <- &Exception{x};
-			runtime.Goexit();
-		});
-		h <- nil;	// clean termination
-	}();
+			h <- &Exception{x}
+			runtime.Goexit()
+		})
+		h <- nil // clean termination
+	}()
 
-	return <-h;
+	return <-h
 }
 
 
@@ -79,5 +79,5 @@ func (x *Exception) String() string {
 	if x != nil {
 		return fmt.Sprintf("exception: %v", x.Value)
 	}
-	return "";
+	return ""
 }
diff --git a/src/pkg/exp/exception/exception_test.go b/src/pkg/exp/exception/exception_test.go
index 91f742ea03..b7b106d776 100644
--- a/src/pkg/exp/exception/exception_test.go
+++ b/src/pkg/exp/exception/exception_test.go
@@ -7,7 +7,7 @@ package exception
 import "testing"
 
 func TestNoException(t *testing.T) {
-	e := Try(func(throw Handler) {});
+	e := Try(func(throw Handler) {})
 	if e != nil {
 		t.Fatalf("no exception expected, found: %v", e)
 	}
@@ -15,7 +15,7 @@ func TestNoException(t *testing.T) {
 
 
 func TestNilException(t *testing.T) {
-	e := Try(func(throw Handler) { throw(nil) });
+	e := Try(func(throw Handler) { throw(nil) })
 	if e == nil {
 		t.Fatalf("exception expected", e)
 	}
@@ -26,19 +26,19 @@ func TestNilException(t *testing.T) {
 
 
 func TestTry(t *testing.T) {
-	s := 0;
+	s := 0
 	for i := 1; i <= 10; i++ {
 		e := Try(func(throw Handler) {
 			if i%3 == 0 {
-				throw(i);
-				panic("throw returned");
+				throw(i)
+				panic("throw returned")
 			}
-		});
+		})
 		if e != nil {
 			s += e.Value.(int)
 		}
 	}
-	result := 3 + 6 + 9;
+	result := 3 + 6 + 9
 	if s != result {
 		t.Fatalf("expected: %d, found: %d", result, s)
 	}
@@ -46,7 +46,7 @@ func TestTry(t *testing.T) {
 
 
 func TestCatch(t *testing.T) {
-	s := 0;
+	s := 0
 	for i := 1; i <= 10; i++ {
 		Try(func(throw Handler) {
 			if i%3 == 0 {
@@ -54,7 +54,7 @@ func TestCatch(t *testing.T) {
 			}
 		}).Catch(func(x interface{}) { s += x.(int) })
 	}
-	result := 3 + 6 + 9;
+	result := 3 + 6 + 9
 	if s != result {
 		t.Fatalf("expected: %d, found: %d", result, s)
 	}
diff --git a/src/pkg/exp/iterable/array.go b/src/pkg/exp/iterable/array.go
index 371508e5d2..b5c7b5c6ea 100644
--- a/src/pkg/exp/iterable/array.go
+++ b/src/pkg/exp/iterable/array.go
@@ -9,51 +9,51 @@ package iterable
 type ByteArray []byte
 
 func (a ByteArray) Iter() <-chan interface{} {
-	ch := make(chan interface{});
+	ch := make(chan interface{})
 	go func() {
 		for _, e := range a {
 			ch <- e
 		}
-		close(ch);
-	}();
-	return ch;
+		close(ch)
+	}()
+	return ch
 }
 
 type IntArray []int
 
 func (a IntArray) Iter() <-chan interface{} {
-	ch := make(chan interface{});
+	ch := make(chan interface{})
 	go func() {
 		for _, e := range a {
 			ch <- e
 		}
-		close(ch);
-	}();
-	return ch;
+		close(ch)
+	}()
+	return ch
 }
 
 type FloatArray []float
 
 func (a FloatArray) Iter() <-chan interface{} {
-	ch := make(chan interface{});
+	ch := make(chan interface{})
 	go func() {
 		for _, e := range a {
 			ch <- e
 		}
-		close(ch);
-	}();
-	return ch;
+		close(ch)
+	}()
+	return ch
 }
 
 type StringArray []string
 
 func (a StringArray) Iter() <-chan interface{} {
-	ch := make(chan interface{});
+	ch := make(chan interface{})
 	go func() {
 		for _, e := range a {
 			ch <- e
 		}
-		close(ch);
-	}();
-	return ch;
+		close(ch)
+	}()
+	return ch
 }
diff --git a/src/pkg/exp/iterable/iterable.go b/src/pkg/exp/iterable/iterable.go
index 764900c53c..b1ae0e90fe 100644
--- a/src/pkg/exp/iterable/iterable.go
+++ b/src/pkg/exp/iterable/iterable.go
@@ -9,13 +9,13 @@
 package iterable
 
 import (
-	"container/list";
-	"container/vector";
+	"container/list"
+	"container/vector"
 )
 
 type Iterable interface {
 	// Iter should return a fresh channel each time it is called.
-	Iter() <-chan interface{};
+	Iter() <-chan interface{}
 }
 
 func not(f func(interface{}) bool) (func(interface{}) bool) {
@@ -29,7 +29,7 @@ func All(iter Iterable, f func(interface{}) bool) bool {
 			return false
 		}
 	}
-	return true;
+	return true
 }
 
 // Any tests whether f is true for at least one element of iter.
@@ -39,18 +39,18 @@ func Any(iter Iterable, f func(interface{}) bool) bool {
 
 // Data returns a slice containing the elements of iter.
 func Data(iter Iterable) []interface{} {
-	vec := new(vector.Vector);
+	vec := new(vector.Vector)
 	for e := range iter.Iter() {
 		vec.Push(e)
 	}
-	return vec.Data();
+	return vec.Data()
 }
 
 // filteredIterable is a struct that implements Iterable with each element
 // passed through a filter.
 type filteredIterable struct {
-	it	Iterable;
-	f	func(interface{}) bool;
+	it Iterable
+	f  func(interface{}) bool
 }
 
 func (f *filteredIterable) iterate(out chan<- interface{}) {
@@ -59,13 +59,13 @@ func (f *filteredIterable) iterate(out chan<- interface{}) {
 			out <- e
 		}
 	}
-	close(out);
+	close(out)
 }
 
 func (f *filteredIterable) Iter() <-chan interface{} {
-	ch := make(chan interface{});
-	go f.iterate(ch);
-	return ch;
+	ch := make(chan interface{})
+	go f.iterate(ch)
+	return ch
 }
 
 // Filter returns an Iterable that returns the elements of iter that satisfy f.
@@ -79,7 +79,7 @@ func Find(iter Iterable, f func(interface{}) bool) interface{} {
 	for e := range Filter(iter, f).Iter() {
 		return e
 	}
-	return nil;
+	return nil
 }
 
 // Injector is a type representing a function that takes two arguments,
@@ -96,30 +96,30 @@ type Injector func(interface{}, interface{}) interface{}
 //                          func(ax interface {}, x interface {}) interface {} {
 //                            return ax.(int) + x.(int) }).(int)
 func Inject(iter Iterable, initial interface{}, f Injector) interface{} {
-	acc := initial;
+	acc := initial
 	for e := range iter.Iter() {
 		acc = f(acc, e)
 	}
-	return acc;
+	return acc
 }
 
 // mappedIterable is a helper struct that implements Iterable, returned by Map.
 type mappedIterable struct {
-	it	Iterable;
-	f	func(interface{}) interface{};
+	it Iterable
+	f  func(interface{}) interface{}
 }
 
 func (m *mappedIterable) iterate(out chan<- interface{}) {
 	for e := range m.it.Iter() {
 		out <- m.f(e)
 	}
-	close(out);
+	close(out)
 }
 
 func (m *mappedIterable) Iter() <-chan interface{} {
-	ch := make(chan interface{});
-	go m.iterate(ch);
-	return ch;
+	ch := make(chan interface{})
+	go m.iterate(ch)
+	return ch
 }
 
 // Map returns an Iterable that returns the result of applying f to each
@@ -139,13 +139,13 @@ type iterFunc func(chan<- interface{})
 
 // provide the Iterable interface
 func (v iterFunc) Iter() <-chan interface{} {
-	ch := make(chan interface{});
-	go v(ch);
-	return ch;
+	ch := make(chan interface{})
+	go v(ch)
+	return ch
 }
 
 // Take returns an Iterable that contains the first n elements of iter.
-func Take(iter Iterable, n int) Iterable	{ return Slice(iter, 0, n) }
+func Take(iter Iterable, n int) Iterable { return Slice(iter, 0, n) }
 
 // TakeWhile returns an Iterable that contains elements from iter while f is true.
 func TakeWhile(iter Iterable, f func(interface{}) bool) Iterable {
@@ -154,41 +154,41 @@ func TakeWhile(iter Iterable, f func(interface{}) bool) Iterable {
 			if !f(v) {
 				break
 			}
-			ch <- v;
+			ch <- v
 		}
-		close(ch);
+		close(ch)
 	})
 }
 
 // Drop returns an Iterable that returns each element of iter after the first n elements.
 func Drop(iter Iterable, n int) Iterable {
 	return iterFunc(func(ch chan<- interface{}) {
-		m := n;
+		m := n
 		for v := range iter.Iter() {
 			if m > 0 {
-				m--;
-				continue;
+				m--
+				continue
 			}
-			ch <- v;
+			ch <- v
 		}
-		close(ch);
+		close(ch)
 	})
 }
 
 // DropWhile returns an Iterable that returns each element of iter after the initial sequence for which f returns true.
 func DropWhile(iter Iterable, f func(interface{}) bool) Iterable {
 	return iterFunc(func(ch chan<- interface{}) {
-		drop := true;
+		drop := true
 		for v := range iter.Iter() {
 			if drop {
 				if f(v) {
 					continue
 				}
-				drop = false;
+				drop = false
 			}
-			ch <- v;
+			ch <- v
 		}
-		close(ch);
+		close(ch)
 	})
 }
 
@@ -211,7 +211,7 @@ func Chain(args []Iterable) Iterable {
 				ch <- v
 			}
 		}
-		close(ch);
+		close(ch)
 	})
 }
 
@@ -220,23 +220,23 @@ func Chain(args []Iterable) Iterable {
 // the lengths of the input Iterables.
 func Zip(args []Iterable) Iterable {
 	return iterFunc(func(ch chan<- interface{}) {
-		defer close(ch);
+		defer close(ch)
 		if len(args) == 0 {
 			return
 		}
-		iters := make([]<-chan interface{}, len(args));
+		iters := make([]<-chan interface{}, len(args))
 		for i := 0; i < len(iters); i++ {
 			iters[i] = args[i].Iter()
 		}
 		for {
-			out := make([]interface{}, len(args));
+			out := make([]interface{}, len(args))
 			for i, v := range iters {
-				out[i] = <-v;
+				out[i] = <-v
 				if closed(v) {
 					return
 				}
 			}
-			ch <- out;
+			ch <- out
 		}
 	})
 }
@@ -244,16 +244,16 @@ func Zip(args []Iterable) Iterable {
 // ZipWith returns an Iterable containing the result of executing f using arguments read from a and b.
 func ZipWith2(f func(c, d interface{}) interface{}, a, b Iterable) Iterable {
 	return Map(Zip([]Iterable{a, b}), func(a1 interface{}) interface{} {
-		arr := a1.([]interface{});
-		return f(arr[0], arr[1]);
+		arr := a1.([]interface{})
+		return f(arr[0], arr[1])
 	})
 }
 
 // ZipWith returns an Iterable containing the result of executing f using arguments read from a, b and c.
 func ZipWith3(f func(d, e, f interface{}) interface{}, a, b, c Iterable) Iterable {
 	return Map(Zip([]Iterable{a, b, c}), func(a1 interface{}) interface{} {
-		arr := a1.([]interface{});
-		return f(arr[0], arr[1], arr[2]);
+		arr := a1.([]interface{})
+		return f(arr[0], arr[1], arr[2])
 	})
 }
 
@@ -261,8 +261,8 @@ func ZipWith3(f func(d, e, f interface{}) interface{}, a, b, c Iterable) Iterabl
 // with indexes in [start, stop).
 func Slice(iter Iterable, start, stop int) Iterable {
 	return iterFunc(func(ch chan<- interface{}) {
-		defer close(ch);
-		i := 0;
+		defer close(ch)
+		i := 0
 		for v := range iter.Iter() {
 			switch {
 			case i >= stop:
@@ -270,7 +270,7 @@ func Slice(iter Iterable, start, stop int) Iterable {
 			case i >= start:
 				ch <- v
 			}
-			i++;
+			i++
 		}
 	})
 }
@@ -290,23 +290,23 @@ func RepeatTimes(v interface{}, n int) Iterable {
 		for i := 0; i < n; i++ {
 			ch <- v
 		}
-		close(ch);
+		close(ch)
 	})
 }
 
 // Group is the type for elements returned by the GroupBy function.
 type Group struct {
-	Key	interface{};	// key value for matching items
-	Vals	Iterable;	// Iterable for receiving values in the group
+	Key  interface{} // key value for matching items
+	Vals Iterable    // Iterable for receiving values in the group
 }
 
 // Key defines the interface required by the GroupBy function.
 type Grouper interface {
 	// Return the key for the given value
-	Key(interface{}) interface{};
+	Key(interface{}) interface{}
 
 	// Compute equality for the given keys
-	Equal(a, b interface{}) bool;
+	Equal(a, b interface{}) bool
 }
 
 // GroupBy combines sequences of logically identical values from iter using k
@@ -317,23 +317,23 @@ type Grouper interface {
 func GroupBy(iter Iterable, k Grouper) Iterable {
 	return iterFunc(func(ch chan<- interface{}) {
 		var curkey interface{}
-		var lst *list.List;
+		var lst *list.List
 		// Basic strategy is to read one group at a time into a list prior to emitting the Group value
 		for v := range iter.Iter() {
-			kv := k.Key(v);
+			kv := k.Key(v)
 			if lst == nil || !k.Equal(curkey, kv) {
 				if lst != nil {
 					ch <- Group{curkey, lst}
 				}
-				lst = list.New();
-				curkey = kv;
+				lst = list.New()
+				curkey = kv
 			}
-			lst.PushBack(v);
+			lst.PushBack(v)
 		}
 		if lst != nil {
 			ch <- Group{curkey, lst}
 		}
-		close(ch);
+		close(ch)
 	})
 }
 
diff --git a/src/pkg/exp/iterable/iterable_test.go b/src/pkg/exp/iterable/iterable_test.go
index 242a725a92..1d60d4b910 100644
--- a/src/pkg/exp/iterable/iterable_test.go
+++ b/src/pkg/exp/iterable/iterable_test.go
@@ -5,42 +5,42 @@
 package iterable
 
 import (
-	"container/vector";
-	"testing";
+	"container/vector"
+	"testing"
 )
 
 func TestArrayTypes(t *testing.T) {
 	// Test that conversion works correctly.
-	bytes := ByteArray([]byte{1, 2, 3});
+	bytes := ByteArray([]byte{1, 2, 3})
 	if x := Data(bytes)[1].(byte); x != 2 {
 		t.Error("Data(bytes)[1].(byte) = %v, want 2", x)
 	}
-	ints := IntArray([]int{1, 2, 3});
+	ints := IntArray([]int{1, 2, 3})
 	if x := Data(ints)[2].(int); x != 3 {
 		t.Error("Data(ints)[2].(int) = %v, want 3", x)
 	}
-	floats := FloatArray([]float{1, 2, 3});
+	floats := FloatArray([]float{1, 2, 3})
 	if x := Data(floats)[0].(float); x != 1 {
 		t.Error("Data(floats)[0].(float) = %v, want 1", x)
 	}
-	strings := StringArray([]string{"a", "b", "c"});
+	strings := StringArray([]string{"a", "b", "c"})
 	if x := Data(strings)[1].(string); x != "b" {
 		t.Error(`Data(strings)[1].(string) = %q, want "b"`, x)
 	}
 }
 
 var (
-	oneToFive	= IntArray{1, 2, 3, 4, 5};
-	sixToTen	= IntArray{6, 7, 8, 9, 10};
-	elevenToTwenty	= IntArray{11, 12, 13, 14, 15, 16, 17, 18, 19, 20};
+	oneToFive      = IntArray{1, 2, 3, 4, 5}
+	sixToTen       = IntArray{6, 7, 8, 9, 10}
+	elevenToTwenty = IntArray{11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
 )
 
-func isNegative(n interface{}) bool	{ return n.(int) < 0 }
-func isPositive(n interface{}) bool	{ return n.(int) > 0 }
-func isAbove3(n interface{}) bool	{ return n.(int) > 3 }
-func isEven(n interface{}) bool		{ return n.(int)%2 == 0 }
-func doubler(n interface{}) interface{}	{ return n.(int) * 2 }
-func addOne(n interface{}) interface{}	{ return n.(int) + 1 }
+func isNegative(n interface{}) bool     { return n.(int) < 0 }
+func isPositive(n interface{}) bool     { return n.(int) > 0 }
+func isAbove3(n interface{}) bool       { return n.(int) > 3 }
+func isEven(n interface{}) bool         { return n.(int)%2 == 0 }
+func doubler(n interface{}) interface{} { return n.(int) * 2 }
+func addOne(n interface{}) interface{}  { return n.(int) + 1 }
 func adder(acc interface{}, n interface{}) interface{} {
 	return acc.(int) + n.(int)
 }
@@ -49,13 +49,13 @@ func adder(acc interface{}, n interface{}) interface{} {
 type integerStream struct{}
 
 func (i integerStream) Iter() <-chan interface{} {
-	ch := make(chan interface{});
+	ch := make(chan interface{})
 	go func() {
 		for i := 0; ; i++ {
 			ch <- i
 		}
-	}();
-	return ch;
+	}()
+	return ch
 }
 
 func TestAll(t *testing.T) {
@@ -78,236 +78,236 @@ func TestAny(t *testing.T) {
 
 func assertArraysAreEqual(t *testing.T, res []interface{}, expected []int) {
 	if len(res) != len(expected) {
-		t.Errorf("len(res) = %v, want %v", len(res), len(expected));
-		goto missing;
+		t.Errorf("len(res) = %v, want %v", len(res), len(expected))
+		goto missing
 	}
 	for i := range res {
 		if v := res[i].(int); v != expected[i] {
-			t.Errorf("res[%v] = %v, want %v", i, v, expected[i]);
-			goto missing;
+			t.Errorf("res[%v] = %v, want %v", i, v, expected[i])
+			goto missing
 		}
 	}
-	return;
+	return
 missing:
-	t.Errorf("res = %v\nwant  %v", res, expected);
+	t.Errorf("res = %v\nwant  %v", res, expected)
 }
 
 func TestFilter(t *testing.T) {
-	ints := integerStream{};
-	moreInts := Filter(ints, isAbove3).Iter();
-	res := make([]interface{}, 3);
+	ints := integerStream{}
+	moreInts := Filter(ints, isAbove3).Iter()
+	res := make([]interface{}, 3)
 	for i := 0; i < 3; i++ {
 		res[i] = <-moreInts
 	}
-	assertArraysAreEqual(t, res, []int{4, 5, 6});
+	assertArraysAreEqual(t, res, []int{4, 5, 6})
 }
 
 func TestFind(t *testing.T) {
-	ints := integerStream{};
-	first := Find(ints, isAbove3);
+	ints := integerStream{}
+	first := Find(ints, isAbove3)
 	if first.(int) != 4 {
 		t.Errorf("Find(ints, isAbove3) = %v, want 4", first)
 	}
 }
 
 func TestInject(t *testing.T) {
-	res := Inject(oneToFive, 0, adder);
+	res := Inject(oneToFive, 0, adder)
 	if res.(int) != 15 {
 		t.Errorf("Inject(oneToFive, 0, adder) = %v, want 15", res)
 	}
 }
 
 func TestMap(t *testing.T) {
-	res := Data(Map(Map(oneToFive, doubler), addOne));
-	assertArraysAreEqual(t, res, []int{3, 5, 7, 9, 11});
+	res := Data(Map(Map(oneToFive, doubler), addOne))
+	assertArraysAreEqual(t, res, []int{3, 5, 7, 9, 11})
 }
 
 func TestPartition(t *testing.T) {
-	ti, fi := Partition(oneToFive, isEven);
-	assertArraysAreEqual(t, Data(ti), []int{2, 4});
-	assertArraysAreEqual(t, Data(fi), []int{1, 3, 5});
+	ti, fi := Partition(oneToFive, isEven)
+	assertArraysAreEqual(t, Data(ti), []int{2, 4})
+	assertArraysAreEqual(t, Data(fi), []int{1, 3, 5})
 }
 
 func TestTake(t *testing.T) {
-	res := Take(oneToFive, 2);
-	assertArraysAreEqual(t, Data(res), []int{1, 2});
-	assertArraysAreEqual(t, Data(res), []int{1, 2});	// second test to ensure that .Iter() returns a new channel
+	res := Take(oneToFive, 2)
+	assertArraysAreEqual(t, Data(res), []int{1, 2})
+	assertArraysAreEqual(t, Data(res), []int{1, 2}) // second test to ensure that .Iter() returns a new channel
 
 	// take none
-	res = Take(oneToFive, 0);
-	assertArraysAreEqual(t, Data(res), []int{});
+	res = Take(oneToFive, 0)
+	assertArraysAreEqual(t, Data(res), []int{})
 
 	// try to take more than available
-	res = Take(oneToFive, 20);
-	assertArraysAreEqual(t, Data(res), oneToFive);
+	res = Take(oneToFive, 20)
+	assertArraysAreEqual(t, Data(res), oneToFive)
 }
 
 func TestTakeWhile(t *testing.T) {
 	// take some
-	res := TakeWhile(oneToFive, func(v interface{}) bool { return v.(int) <= 3 });
-	assertArraysAreEqual(t, Data(res), []int{1, 2, 3});
-	assertArraysAreEqual(t, Data(res), []int{1, 2, 3});	// second test to ensure that .Iter() returns a new channel
+	res := TakeWhile(oneToFive, func(v interface{}) bool { return v.(int) <= 3 })
+	assertArraysAreEqual(t, Data(res), []int{1, 2, 3})
+	assertArraysAreEqual(t, Data(res), []int{1, 2, 3}) // second test to ensure that .Iter() returns a new channel
 
 	// take none
-	res = TakeWhile(oneToFive, func(v interface{}) bool { return v.(int) > 3000 });
-	assertArraysAreEqual(t, Data(res), []int{});
+	res = TakeWhile(oneToFive, func(v interface{}) bool { return v.(int) > 3000 })
+	assertArraysAreEqual(t, Data(res), []int{})
 
 	// take all
-	res = TakeWhile(oneToFive, func(v interface{}) bool { return v.(int) < 3000 });
-	assertArraysAreEqual(t, Data(res), oneToFive);
+	res = TakeWhile(oneToFive, func(v interface{}) bool { return v.(int) < 3000 })
+	assertArraysAreEqual(t, Data(res), oneToFive)
 }
 
 func TestDrop(t *testing.T) {
 	// drop none
-	res := Drop(oneToFive, 0);
-	assertArraysAreEqual(t, Data(res), oneToFive);
-	assertArraysAreEqual(t, Data(res), oneToFive);	// second test to ensure that .Iter() returns a new channel
+	res := Drop(oneToFive, 0)
+	assertArraysAreEqual(t, Data(res), oneToFive)
+	assertArraysAreEqual(t, Data(res), oneToFive) // second test to ensure that .Iter() returns a new channel
 
 	// drop some
-	res = Drop(oneToFive, 2);
-	assertArraysAreEqual(t, Data(res), []int{3, 4, 5});
-	assertArraysAreEqual(t, Data(res), []int{3, 4, 5});	// second test to ensure that .Iter() returns a new channel
+	res = Drop(oneToFive, 2)
+	assertArraysAreEqual(t, Data(res), []int{3, 4, 5})
+	assertArraysAreEqual(t, Data(res), []int{3, 4, 5}) // second test to ensure that .Iter() returns a new channel
 
 	// drop more than available
-	res = Drop(oneToFive, 88);
-	assertArraysAreEqual(t, Data(res), []int{});
+	res = Drop(oneToFive, 88)
+	assertArraysAreEqual(t, Data(res), []int{})
 }
 
 func TestDropWhile(t *testing.T) {
 	// drop some
-	res := DropWhile(oneToFive, func(v interface{}) bool { return v.(int) < 3 });
-	assertArraysAreEqual(t, Data(res), []int{3, 4, 5});
-	assertArraysAreEqual(t, Data(res), []int{3, 4, 5});	// second test to ensure that .Iter() returns a new channel
+	res := DropWhile(oneToFive, func(v interface{}) bool { return v.(int) < 3 })
+	assertArraysAreEqual(t, Data(res), []int{3, 4, 5})
+	assertArraysAreEqual(t, Data(res), []int{3, 4, 5}) // second test to ensure that .Iter() returns a new channel
 
 	// test case where all elements are dropped
-	res = DropWhile(oneToFive, func(v interface{}) bool { return v.(int) < 100 });
-	assertArraysAreEqual(t, Data(res), []int{});
+	res = DropWhile(oneToFive, func(v interface{}) bool { return v.(int) < 100 })
+	assertArraysAreEqual(t, Data(res), []int{})
 
 	// test case where none are dropped
-	res = DropWhile(oneToFive, func(v interface{}) bool { return v.(int) > 1000 });
-	assertArraysAreEqual(t, Data(res), oneToFive);
+	res = DropWhile(oneToFive, func(v interface{}) bool { return v.(int) > 1000 })
+	assertArraysAreEqual(t, Data(res), oneToFive)
 }
 
 func TestCycle(t *testing.T) {
-	res := Cycle(oneToFive);
-	exp := []int{1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4};
+	res := Cycle(oneToFive)
+	exp := []int{1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4}
 
 	// read the first nineteen values from the iterable
-	out := make([]interface{}, 19);
+	out := make([]interface{}, 19)
 	for i, it := 0, res.Iter(); i < 19; i++ {
 		out[i] = <-it
 	}
-	assertArraysAreEqual(t, out, exp);
+	assertArraysAreEqual(t, out, exp)
 
-	res2 := Cycle(sixToTen);
-	exp2 := []int{6, 7, 8, 9, 10, 6, 7, 8, 9, 10, 6, 7, 8, 9, 10, 6, 7, 8, 9};
+	res2 := Cycle(sixToTen)
+	exp2 := []int{6, 7, 8, 9, 10, 6, 7, 8, 9, 10, 6, 7, 8, 9, 10, 6, 7, 8, 9}
 	for i, it := 0, res2.Iter(); i < 19; i++ {
 		out[i] = <-it
 	}
-	assertArraysAreEqual(t, out, exp2);
+	assertArraysAreEqual(t, out, exp2)
 
 	// ensure first iterator was not harmed
 	for i, it := 0, res.Iter(); i < 19; i++ {
 		out[i] = <-it
 	}
-	assertArraysAreEqual(t, out, exp);
+	assertArraysAreEqual(t, out, exp)
 }
 
 func TestChain(t *testing.T) {
 
-	exp := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};
-	res := Chain([]Iterable{oneToFive, sixToTen, elevenToTwenty});
-	assertArraysAreEqual(t, Data(res), exp);
+	exp := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
+	res := Chain([]Iterable{oneToFive, sixToTen, elevenToTwenty})
+	assertArraysAreEqual(t, Data(res), exp)
 
 	// reusing the same iterator should produce the same result again
-	assertArraysAreEqual(t, Data(res), exp);
+	assertArraysAreEqual(t, Data(res), exp)
 
 	// test short read from Chain
-	i := 0;
-	out := make([]interface{}, 4);
+	i := 0
+	out := make([]interface{}, 4)
 	for v := range res.Iter() {
-		out[i] = v;
-		i++;
+		out[i] = v
+		i++
 		if i == len(out) {
 			break
 		}
 	}
-	assertArraysAreEqual(t, out, exp[0:4]);
+	assertArraysAreEqual(t, out, exp[0:4])
 
 	// test zero length array
-	res = Chain([]Iterable{});
-	assertArraysAreEqual(t, Data(res), []int{});
+	res = Chain([]Iterable{})
+	assertArraysAreEqual(t, Data(res), []int{})
 }
 
 func TestZipWith(t *testing.T) {
-	exp := []int{7, 9, 11, 13, 15};
+	exp := []int{7, 9, 11, 13, 15}
 
 	// f with 2 args and 1 return value
-	f := func(a, b interface{}) interface{} { return a.(int) + b.(int) };
-	res := ZipWith2(f, oneToFive, sixToTen);
-	assertArraysAreEqual(t, Data(res), exp);
+	f := func(a, b interface{}) interface{} { return a.(int) + b.(int) }
+	res := ZipWith2(f, oneToFive, sixToTen)
+	assertArraysAreEqual(t, Data(res), exp)
 
 	// test again to make sure returns new iter each time
-	assertArraysAreEqual(t, Data(res), exp);
+	assertArraysAreEqual(t, Data(res), exp)
 
 	// test a function with 3 args
-	f2 := func(a, b, c interface{}) interface{} { return a.(int) + b.(int) + c.(int) };
-	res = ZipWith3(f2, oneToFive, sixToTen, oneToFive);
-	exp = []int{8, 11, 14, 17, 20};
-	assertArraysAreEqual(t, Data(res), exp);
+	f2 := func(a, b, c interface{}) interface{} { return a.(int) + b.(int) + c.(int) }
+	res = ZipWith3(f2, oneToFive, sixToTen, oneToFive)
+	exp = []int{8, 11, 14, 17, 20}
+	assertArraysAreEqual(t, Data(res), exp)
 
 	// test a function with multiple values returned
-	f3 := func(a, b interface{}) interface{} { return ([]interface{}{a.(int) + 1, b.(int) + 1}) };
-	res = ZipWith2(f3, oneToFive, sixToTen);
+	f3 := func(a, b interface{}) interface{} { return ([]interface{}{a.(int) + 1, b.(int) + 1}) }
+	res = ZipWith2(f3, oneToFive, sixToTen)
 
-	exp2 := [][]int{[]int{2, 7}, []int{3, 8}, []int{4, 9}, []int{5, 10}, []int{6, 11}};
-	i := 0;
+	exp2 := [][]int{[]int{2, 7}, []int{3, 8}, []int{4, 9}, []int{5, 10}, []int{6, 11}}
+	i := 0
 	for v := range res.Iter() {
-		out := v.([]interface{});
-		assertArraysAreEqual(t, out, exp2[i]);
-		i++;
+		out := v.([]interface{})
+		assertArraysAreEqual(t, out, exp2[i])
+		i++
 	}
 
 	// test different length iterators--should stop after shortest is exhausted
-	res = ZipWith2(f, elevenToTwenty, oneToFive);
-	exp = []int{12, 14, 16, 18, 20};
-	assertArraysAreEqual(t, Data(res), exp);
+	res = ZipWith2(f, elevenToTwenty, oneToFive)
+	exp = []int{12, 14, 16, 18, 20}
+	assertArraysAreEqual(t, Data(res), exp)
 }
 
 func TestSlice(t *testing.T) {
-	out := Data(Slice(elevenToTwenty, 2, 6));
-	exp := []int{13, 14, 15, 16};
-	assertArraysAreEqual(t, out, exp);
+	out := Data(Slice(elevenToTwenty, 2, 6))
+	exp := []int{13, 14, 15, 16}
+	assertArraysAreEqual(t, out, exp)
 
 	// entire iterable
-	out = Data(Slice(elevenToTwenty, 0, len(elevenToTwenty)));
-	exp = []int{11, 12, 13, 14, 15, 16, 17, 18, 19, 20};
-	assertArraysAreEqual(t, out, exp);
+	out = Data(Slice(elevenToTwenty, 0, len(elevenToTwenty)))
+	exp = []int{11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
+	assertArraysAreEqual(t, out, exp)
 
 	// empty slice at offset 0
-	exp = []int{};
-	out = Data(Slice(elevenToTwenty, 0, 0));
-	assertArraysAreEqual(t, out, exp);
+	exp = []int{}
+	out = Data(Slice(elevenToTwenty, 0, 0))
+	assertArraysAreEqual(t, out, exp)
 
 	// slice upper bound exceeds length of iterable
-	exp = []int{1, 2, 3, 4, 5};
-	out = Data(Slice(oneToFive, 0, 88));
-	assertArraysAreEqual(t, out, exp);
+	exp = []int{1, 2, 3, 4, 5}
+	out = Data(Slice(oneToFive, 0, 88))
+	assertArraysAreEqual(t, out, exp)
 
 	// slice upper bounce is lower than lower bound
-	exp = []int{};
-	out = Data(Slice(oneToFive, 93, 4));
-	assertArraysAreEqual(t, out, exp);
+	exp = []int{}
+	out = Data(Slice(oneToFive, 93, 4))
+	assertArraysAreEqual(t, out, exp)
 
 	// slice lower bound is greater than len of iterable
-	exp = []int{};
-	out = Data(Slice(oneToFive, 93, 108));
-	assertArraysAreEqual(t, out, exp);
+	exp = []int{}
+	out = Data(Slice(oneToFive, 93, 108))
+	assertArraysAreEqual(t, out, exp)
 }
 
 func TestRepeat(t *testing.T) {
-	res := Repeat(42);
-	i := 0;
+	res := Repeat(42)
+	i := 0
 	for v := range res.Iter() {
 		if v.(int) != 42 {
 			t.Fatal("Repeat returned the wrong value")
@@ -315,25 +315,25 @@ func TestRepeat(t *testing.T) {
 		if i == 9 {
 			break
 		}
-		i++;
+		i++
 	}
 }
 
 func TestRepeatTimes(t *testing.T) {
-	res := RepeatTimes(84, 9);
-	exp := []int{84, 84, 84, 84, 84, 84, 84, 84, 84};
-	assertArraysAreEqual(t, Data(res), exp);
-	assertArraysAreEqual(t, Data(res), exp);	// second time to ensure new iter is returned
+	res := RepeatTimes(84, 9)
+	exp := []int{84, 84, 84, 84, 84, 84, 84, 84, 84}
+	assertArraysAreEqual(t, Data(res), exp)
+	assertArraysAreEqual(t, Data(res), exp) // second time to ensure new iter is returned
 
 	// 0 repeat
-	res = RepeatTimes(7, 0);
-	exp = []int{};
-	assertArraysAreEqual(t, Data(res), exp);
+	res = RepeatTimes(7, 0)
+	exp = []int{}
+	assertArraysAreEqual(t, Data(res), exp)
 
 	// negative repeat
-	res = RepeatTimes(7, -3);
-	exp = []int{};
-	assertArraysAreEqual(t, Data(res), exp);
+	res = RepeatTimes(7, -3)
+	exp = []int{}
+	assertArraysAreEqual(t, Data(res), exp)
 }
 
 // a type that implements Key for ints
@@ -342,20 +342,20 @@ type intkey struct{}
 func (v intkey) Key(a interface{}) interface{} {
 	return a
 }
-func (v intkey) Equal(a, b interface{}) bool	{ return a.(int) == b.(int) }
+func (v intkey) Equal(a, b interface{}) bool { return a.(int) == b.(int) }
 
 func TestGroupBy(t *testing.T) {
-	in := IntArray{1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5};
-	exp := [][]int{[]int{1}, []int{2, 2}, []int{3, 3, 3}, []int{4, 4, 4, 4}, []int{5, 5, 5, 5, 5}};
-	i := 0;
+	in := IntArray{1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5}
+	exp := [][]int{[]int{1}, []int{2, 2}, []int{3, 3, 3}, []int{4, 4, 4, 4}, []int{5, 5, 5, 5, 5}}
+	i := 0
 	for x := range GroupBy(in, intkey{}).Iter() {
-		gr := x.(Group);
+		gr := x.(Group)
 		if gr.Key.(int) != i+1 {
 			t.Fatal("group key wrong; expected", i+1, "but got", gr.Key.(int))
 		}
-		vals := Data(gr.Vals);
-		assertArraysAreEqual(t, vals, exp[i]);
-		i++;
+		vals := Data(gr.Vals)
+		assertArraysAreEqual(t, vals, exp[i])
+		i++
 	}
 	if i != 5 {
 		t.Fatal("did not return expected number of groups")
@@ -367,21 +367,21 @@ func TestGroupBy(t *testing.T) {
 	}
 
 	// test case with only uniques
-	var out vector.Vector;
+	var out vector.Vector
 	for x := range GroupBy(elevenToTwenty, intkey{}).Iter() {
 		out.Push(x.(Group).Key)
 	}
-	assertArraysAreEqual(t, out.Data(), elevenToTwenty);
+	assertArraysAreEqual(t, out.Data(), elevenToTwenty)
 }
 
 func TestUnique(t *testing.T) {
-	in := IntArray([]int{1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5});
-	exp := []int{1, 2, 3, 4, 5};
-	res := Unique(in, intkey{});
-	assertArraysAreEqual(t, Data(res), exp);
-	assertArraysAreEqual(t, Data(res), exp);	// second time to ensure new iter is returned
+	in := IntArray([]int{1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5})
+	exp := []int{1, 2, 3, 4, 5}
+	res := Unique(in, intkey{})
+	assertArraysAreEqual(t, Data(res), exp)
+	assertArraysAreEqual(t, Data(res), exp) // second time to ensure new iter is returned
 
 	// test case with only uniques
-	res = Unique(elevenToTwenty, intkey{});
-	assertArraysAreEqual(t, Data(res), elevenToTwenty);
+	res = Unique(elevenToTwenty, intkey{})
+	assertArraysAreEqual(t, Data(res), elevenToTwenty)
 }
diff --git a/src/pkg/exp/nacl/av/av.go b/src/pkg/exp/nacl/av/av.go
index 4c76aeb30a..0ed2757604 100644
--- a/src/pkg/exp/nacl/av/av.go
+++ b/src/pkg/exp/nacl/av/av.go
@@ -12,12 +12,12 @@
 package av
 
 import (
-	"exp/draw";
-	"exp/nacl/srpc";
-	"log";
-	"os";
-	"syscall";
-	"unsafe";
+	"exp/draw"
+	"exp/nacl/srpc"
+	"log"
+	"os"
+	"syscall"
+	"unsafe"
 )
 
 var srpcEnabled = srpc.Enabled()
@@ -26,44 +26,44 @@ var srpcEnabled = srpc.Enabled()
 
 // Subsystem values for Init.
 const (
-	SubsystemVideo	= 1 << iota;
-	SubsystemAudio;
-	SubsystemEmbed;
+	SubsystemVideo = 1 << iota
+	SubsystemAudio
+	SubsystemEmbed
 )
 //	SubsystemRawEvents;
 
 // Audio formats.
 const (
-	AudioFormatStereo44K	= iota;
-	AudioFormatStereo48K;
+	AudioFormatStereo44K = iota
+	AudioFormatStereo48K
 )
 
 // A Window represents a connection to the Native Client window.
 // It implements draw.Context.
 type Window struct {
-	Embedded	bool;	// running as part of a web page?
-	*Image;			// screen image
+	Embedded bool // running as part of a web page?
+	*Image        // screen image
 
-	mousec	chan draw.Mouse;
-	kbdc	chan int;
-	quitc	chan bool;
-	resizec	chan bool;
+	mousec  chan draw.Mouse
+	kbdc    chan int
+	quitc   chan bool
+	resizec chan bool
 }
 
 // *Window implements draw.Context
 var _ draw.Context = (*Window)(nil)
 
-func (w *Window) KeyboardChan() <-chan int	{ return w.kbdc }
+func (w *Window) KeyboardChan() <-chan int { return w.kbdc }
 
 func (w *Window) MouseChan() <-chan draw.Mouse {
 	return w.mousec
 }
 
-func (w *Window) QuitChan() <-chan bool	{ return w.quitc }
+func (w *Window) QuitChan() <-chan bool { return w.quitc }
 
-func (w *Window) ResizeChan() <-chan bool	{ return w.resizec }
+func (w *Window) ResizeChan() <-chan bool { return w.resizec }
 
-func (w *Window) Screen() draw.Image	{ return w.Image }
+func (w *Window) Screen() draw.Image { return w.Image }
 
 // Init initializes the Native Client subsystems specified by subsys.
 // Init must be called before using any of the other functions
@@ -77,18 +77,18 @@ func (w *Window) Screen() draw.Image	{ return w.Image }
 // If the SubsystemAudio flag is set, Init requests a connection to the
 // audio device carrying 44 kHz 16-bit stereo PCM audio samples.
 func Init(subsys int, dx, dy int) (*Window, os.Error) {
-	xsubsys := subsys;
+	xsubsys := subsys
 	if srpcEnabled {
-		waitBridge();
-		xsubsys &^= SubsystemVideo | SubsystemEmbed;
+		waitBridge()
+		xsubsys &^= SubsystemVideo | SubsystemEmbed
 	}
 
 	if xsubsys&SubsystemEmbed != 0 {
 		return nil, os.NewError("not embedded")
 	}
 
-	w := new(Window);
-	err := multimediaInit(xsubsys);
+	w := new(Window)
+	err := multimediaInit(xsubsys)
 	if err != nil {
 		return nil, err
 	}
@@ -97,33 +97,33 @@ func Init(subsys int, dx, dy int) (*Window, os.Error) {
 		if dx, dy, err = videoInit(dx, dy); err != nil {
 			return nil, err
 		}
-		w.Image = newImage(dx, dy, bridge.pixel);
-		w.resizec = make(chan bool, 64);
-		w.kbdc = make(chan int, 64);
-		w.mousec = make(chan draw.Mouse, 64);
-		w.quitc = make(chan bool);
+		w.Image = newImage(dx, dy, bridge.pixel)
+		w.resizec = make(chan bool, 64)
+		w.kbdc = make(chan int, 64)
+		w.mousec = make(chan draw.Mouse, 64)
+		w.quitc = make(chan bool)
 	}
 
 	if subsys&SubsystemAudio != 0 {
-		var n int;
+		var n int
 		if n, err = audioInit(AudioFormatStereo44K, 2048); err != nil {
 			return nil, err
 		}
-		println("audio", n);
+		println("audio", n)
 	}
 
 	if subsys&SubsystemVideo != 0 {
 		go w.readEvents()
 	}
 
-	return w, nil;
+	return w, nil
 }
 
 func (w *Window) FlushImage() {
 	if w.Image == nil {
 		return
 	}
-	videoUpdate(w.Image.Linear);
+	videoUpdate(w.Image.Linear)
 }
 
 func multimediaInit(subsys int) (err os.Error) {
@@ -132,45 +132,45 @@ func multimediaInit(subsys int) (err os.Error) {
 
 func videoInit(dx, dy int) (ndx, ndy int, err os.Error) {
 	if srpcEnabled {
-		bridge.share.ready = 1;
-		return int(bridge.share.width), int(bridge.share.height), nil;
+		bridge.share.ready = 1
+		return int(bridge.share.width), int(bridge.share.height), nil
 	}
 	if e := syscall.VideoInit(dx, dy); e != 0 {
 		return 0, 0, os.NewSyscallError("video_init", int(e))
 	}
-	return dx, dy, nil;
+	return dx, dy, nil
 }
 
 func videoUpdate(data []Color) (err os.Error) {
 	if srpcEnabled {
-		bridge.flushRPC.Call("upcall", nil);
-		return;
+		bridge.flushRPC.Call("upcall", nil)
+		return
 	}
-	return os.NewSyscallError("video_update", syscall.VideoUpdate((*uint32)(&data[0])));
+	return os.NewSyscallError("video_update", syscall.VideoUpdate((*uint32)(&data[0])))
 }
 
 var noEvents = os.NewError("no events")
 
 func videoPollEvent(ev []byte) (err os.Error) {
 	if srpcEnabled {
-		r := bridge.share.eq.ri;
+		r := bridge.share.eq.ri
 		if r == bridge.share.eq.wi {
 			return noEvents
 		}
-		copy(ev, &bridge.share.eq.event[r]);
-		bridge.share.eq.ri = (r + 1) % eqsize;
-		return nil;
+		copy(ev, &bridge.share.eq.event[r])
+		bridge.share.eq.ri = (r + 1) % eqsize
+		return nil
 	}
-	return os.NewSyscallError("video_poll_event", syscall.VideoPollEvent(&ev[0]));
+	return os.NewSyscallError("video_poll_event", syscall.VideoPollEvent(&ev[0]))
 }
 
 func audioInit(fmt int, want int) (got int, err os.Error) {
-	var x int;
-	e := syscall.AudioInit(fmt, want, &x);
+	var x int
+	e := syscall.AudioInit(fmt, want, &x)
 	if e == 0 {
 		return x, nil
 	}
-	return 0, os.NewSyscallError("audio_init", e);
+	return 0, os.NewSyscallError("audio_init", e)
 }
 
 var audioSize uintptr
@@ -185,8 +185,8 @@ var audioSize uintptr
 //
 func AudioStream(data []uint16) (nextSize int, err os.Error) {
 	if audioSize == 0 {
-		e := os.NewSyscallError("audio_stream", syscall.AudioStream(nil, &audioSize));
-		return int(audioSize), e;
+		e := os.NewSyscallError("audio_stream", syscall.AudioStream(nil, &audioSize))
+		return int(audioSize), e
 	}
 	if data == nil {
 		return int(audioSize), nil
@@ -194,19 +194,19 @@ func AudioStream(data []uint16) (nextSize int, err os.Error) {
 	if uintptr(len(data))*2 != audioSize {
 		log.Stdoutf("invalid audio size want %d got %d", audioSize, len(data))
 	}
-	e := os.NewSyscallError("audio_stream", syscall.AudioStream(&data[0], &audioSize));
-	return int(audioSize), e;
+	e := os.NewSyscallError("audio_stream", syscall.AudioStream(&data[0], &audioSize))
+	return int(audioSize), e
 }
 
 // Synchronization structure to wait for bridge to become ready.
 var bridge struct {
-	c		chan bool;
-	displayFd	int;
-	rpcFd		int;
-	share		*videoShare;
-	pixel		[]Color;
-	client		*srpc.Client;
-	flushRPC	*srpc.RPC;
+	c         chan bool
+	displayFd int
+	rpcFd     int
+	share     *videoShare
+	pixel     []Color
+	client    *srpc.Client
+	flushRPC  *srpc.RPC
 }
 
 // Wait for bridge to become ready.
@@ -214,29 +214,29 @@ var bridge struct {
 // so this blocks.  Once the bridge is ready, multimediaBridge.Run
 // will drop a value into the channel.  Then any calls
 // to waitBridge will finish, taking the value out and immediately putting it back.
-func waitBridge()	{ bridge.c <- <-bridge.c }
+func waitBridge() { bridge.c <- <-bridge.c }
 
 const eqsize = 64
 
 // Data structure shared with host via mmap.
 type videoShare struct {
-	revision	int32;	// definition below is rev 100 unless noted
-	mapSize		int32;
+	revision int32 // definition below is rev 100 unless noted
+	mapSize  int32
 
 	// event queue
-	eq	struct {
-		ri	uint32;	// read index [0,eqsize)
-		wi	uint32;	// write index [0,eqsize)
-		eof	int32;
-		event	[eqsize][64]byte;
-	};
+	eq struct {
+		ri    uint32 // read index [0,eqsize)
+		wi    uint32 // write index [0,eqsize)
+		eof   int32
+		event [eqsize][64]byte
+	}
 
 	// now unused
-	_, _, _, _	int32;
+	_, _, _, _ int32
 
 	// video backing store information
-	width, height, _, size	int32;
-	ready			int32;	// rev 0x101
+	width, height, _, size int32
+	ready                  int32 // rev 0x101
 }
 
 // The frame buffer data is videoShareSize bytes after
@@ -249,10 +249,10 @@ type multimediaBridge struct{}
 // one to mmap to get the display memory, and another to use for SRPCs back
 // to the main process.
 func (multimediaBridge) Run(arg, ret []interface{}, size []int) srpc.Errno {
-	bridge.displayFd = arg[0].(int);
-	bridge.rpcFd = arg[1].(int);
+	bridge.displayFd = arg[0].(int)
+	bridge.rpcFd = arg[1].(int)
 
-	var st syscall.Stat_t;
+	var st syscall.Stat_t
 	if errno := syscall.Fstat(bridge.displayFd, &st); errno != 0 {
 		log.Exitf("mmbridge stat display: %s", os.Errno(errno))
 	}
@@ -263,36 +263,36 @@ func (multimediaBridge) Run(arg, ret []interface{}, size []int) srpc.Errno {
 		syscall.PROT_READ|syscall.PROT_WRITE,
 		syscall.MAP_SHARED,
 		uintptr(bridge.displayFd),
-		0);
+		0)
 	if errno != 0 {
 		log.Exitf("mmap display: %s", os.Errno(errno))
 	}
 
-	bridge.share = (*videoShare)(unsafe.Pointer(addr));
+	bridge.share = (*videoShare)(unsafe.Pointer(addr))
 
 	// Overestimate frame buffer size
 	// (must use a compile-time constant)
 	// and then reslice.  256 megapixels (1 GB) should be enough.
-	fb := (*[256 * 1024 * 1024]Color)(unsafe.Pointer(addr + videoShareSize));
-	bridge.pixel = fb[0 : (st.Size-videoShareSize)/4];
+	fb := (*[256 * 1024 * 1024]Color)(unsafe.Pointer(addr + videoShareSize))
+	bridge.pixel = fb[0 : (st.Size-videoShareSize)/4]
 
 	// Configure RPC connection back to client.
-	var err os.Error;
-	bridge.client, err = srpc.NewClient(bridge.rpcFd);
+	var err os.Error
+	bridge.client, err = srpc.NewClient(bridge.rpcFd)
 	if err != nil {
 		log.Exitf("NewClient: %s", err)
 	}
-	bridge.flushRPC = bridge.client.NewRPC(nil);
+	bridge.flushRPC = bridge.client.NewRPC(nil)
 
 	// Notify waiters that the bridge is ready.
-	println("bridged", bridge.share.revision);
-	bridge.c <- true;
+	println("bridged", bridge.share.revision)
+	bridge.c <- true
 
-	return srpc.OK;
+	return srpc.OK
 }
 
 func init() {
-	bridge.c = make(chan bool, 1);
+	bridge.c = make(chan bool, 1)
 	if srpcEnabled {
 		srpc.Add("nacl_multimedia_bridge", "hh:", multimediaBridge{})
 	}
diff --git a/src/pkg/exp/nacl/av/event.go b/src/pkg/exp/nacl/av/event.go
index 32d9e98c5c..11405c9808 100644
--- a/src/pkg/exp/nacl/av/event.go
+++ b/src/pkg/exp/nacl/av/event.go
@@ -10,365 +10,365 @@
 package av
 
 import (
-	"encoding/binary";
-	"exp/draw";
-	"log";
-	"os";
-	"time";
+	"encoding/binary"
+	"exp/draw"
+	"log"
+	"os"
+	"time"
 )
 
 // An eventType identifies the type of a Native Client Event.
 type eventType uint8
 
 const (
-	eventActive	= 1 + iota;
-	eventExpose;
-	eventKeyDown;
-	eventKeyUp;
-	eventMouseMotion;
-	eventMouseButtonDown;
-	eventMouseButtonUp;
-	eventQuit;
-	eventUnsupported;
+	eventActive = 1 + iota
+	eventExpose
+	eventKeyDown
+	eventKeyUp
+	eventMouseMotion
+	eventMouseButtonDown
+	eventMouseButtonUp
+	eventQuit
+	eventUnsupported
 )
 
 // A key represents a key on a keyboard.
 type key uint16
 
 const (
-	keyUnknown	= 0;
-	keyFirst	= 0;
-	keyBackspace	= 8;
-	keyTab		= 9;
-	keyClear	= 12;
-	keyReturn	= 13;
-	keyPause	= 19;
-	keyEscape	= 27;
-	keySpace	= 32;
-	keyExclaim	= 33;
-	keyQuotedbl	= 34;
-	keyHash		= 35;
-	keyDollar	= 36;
-	keyAmpersand	= 38;
-	keyQuote	= 39;
-	keyLeftparen	= 40;
-	keyRightparen	= 41;
-	keyAsterisk	= 42;
-	keyPlus		= 43;
-	keyComma	= 44;
-	keyMinus	= 45;
-	keyPeriod	= 46;
-	keySlash	= 47;
-	key0		= 48;
-	key1		= 49;
-	key2		= 50;
-	key3		= 51;
-	key4		= 52;
-	key5		= 53;
-	key6		= 54;
-	key7		= 55;
-	key8		= 56;
-	key9		= 57;
-	keyColon	= 58;
-	keySemicolon	= 59;
-	keyLess		= 60;
-	keyEquals	= 61;
-	keyGreater	= 62;
-	keyQuestion	= 63;
-	keyAt		= 64;
-	keyLeftbracket	= 91;
-	keyBackslash	= 92;
-	keyRightbracket	= 93;
-	keyCaret	= 94;
-	keyUnderscore	= 95;
-	keyBackquote	= 96;
-	keyA		= 97;
-	keyB		= 98;
-	keyC		= 99;
-	keyD		= 100;
-	keyE		= 101;
-	keyF		= 102;
-	keyG		= 103;
-	keyH		= 104;
-	keyI		= 105;
-	keyJ		= 106;
-	keyK		= 107;
-	keyL		= 108;
-	keyM		= 109;
-	keyN		= 110;
-	keyO		= 111;
-	keyP		= 112;
-	keyQ		= 113;
-	keyR		= 114;
-	keyS		= 115;
-	keyT		= 116;
-	keyU		= 117;
-	keyV		= 118;
-	keyW		= 119;
-	keyX		= 120;
-	keyY		= 121;
-	keyZ		= 122;
-	keyDelete	= 127;
-	keyWorld0	= 160;
-	keyWorld1	= 161;
-	keyWorld2	= 162;
-	keyWorld3	= 163;
-	keyWorld4	= 164;
-	keyWorld5	= 165;
-	keyWorld6	= 166;
-	keyWorld7	= 167;
-	keyWorld8	= 168;
-	keyWorld9	= 169;
-	keyWorld10	= 170;
-	keyWorld11	= 171;
-	keyWorld12	= 172;
-	keyWorld13	= 173;
-	keyWorld14	= 174;
-	keyWorld15	= 175;
-	keyWorld16	= 176;
-	keyWorld17	= 177;
-	keyWorld18	= 178;
-	keyWorld19	= 179;
-	keyWorld20	= 180;
-	keyWorld21	= 181;
-	keyWorld22	= 182;
-	keyWorld23	= 183;
-	keyWorld24	= 184;
-	keyWorld25	= 185;
-	keyWorld26	= 186;
-	keyWorld27	= 187;
-	keyWorld28	= 188;
-	keyWorld29	= 189;
-	keyWorld30	= 190;
-	keyWorld31	= 191;
-	keyWorld32	= 192;
-	keyWorld33	= 193;
-	keyWorld34	= 194;
-	keyWorld35	= 195;
-	keyWorld36	= 196;
-	keyWorld37	= 197;
-	keyWorld38	= 198;
-	keyWorld39	= 199;
-	keyWorld40	= 200;
-	keyWorld41	= 201;
-	keyWorld42	= 202;
-	keyWorld43	= 203;
-	keyWorld44	= 204;
-	keyWorld45	= 205;
-	keyWorld46	= 206;
-	keyWorld47	= 207;
-	keyWorld48	= 208;
-	keyWorld49	= 209;
-	keyWorld50	= 210;
-	keyWorld51	= 211;
-	keyWorld52	= 212;
-	keyWorld53	= 213;
-	keyWorld54	= 214;
-	keyWorld55	= 215;
-	keyWorld56	= 216;
-	keyWorld57	= 217;
-	keyWorld58	= 218;
-	keyWorld59	= 219;
-	keyWorld60	= 220;
-	keyWorld61	= 221;
-	keyWorld62	= 222;
-	keyWorld63	= 223;
-	keyWorld64	= 224;
-	keyWorld65	= 225;
-	keyWorld66	= 226;
-	keyWorld67	= 227;
-	keyWorld68	= 228;
-	keyWorld69	= 229;
-	keyWorld70	= 230;
-	keyWorld71	= 231;
-	keyWorld72	= 232;
-	keyWorld73	= 233;
-	keyWorld74	= 234;
-	keyWorld75	= 235;
-	keyWorld76	= 236;
-	keyWorld77	= 237;
-	keyWorld78	= 238;
-	keyWorld79	= 239;
-	keyWorld80	= 240;
-	keyWorld81	= 241;
-	keyWorld82	= 242;
-	keyWorld83	= 243;
-	keyWorld84	= 244;
-	keyWorld85	= 245;
-	keyWorld86	= 246;
-	keyWorld87	= 247;
-	keyWorld88	= 248;
-	keyWorld89	= 249;
-	keyWorld90	= 250;
-	keyWorld91	= 251;
-	keyWorld92	= 252;
-	keyWorld93	= 253;
-	keyWorld94	= 254;
-	keyWorld95	= 255;
+	keyUnknown      = 0
+	keyFirst        = 0
+	keyBackspace    = 8
+	keyTab          = 9
+	keyClear        = 12
+	keyReturn       = 13
+	keyPause        = 19
+	keyEscape       = 27
+	keySpace        = 32
+	keyExclaim      = 33
+	keyQuotedbl     = 34
+	keyHash         = 35
+	keyDollar       = 36
+	keyAmpersand    = 38
+	keyQuote        = 39
+	keyLeftparen    = 40
+	keyRightparen   = 41
+	keyAsterisk     = 42
+	keyPlus         = 43
+	keyComma        = 44
+	keyMinus        = 45
+	keyPeriod       = 46
+	keySlash        = 47
+	key0            = 48
+	key1            = 49
+	key2            = 50
+	key3            = 51
+	key4            = 52
+	key5            = 53
+	key6            = 54
+	key7            = 55
+	key8            = 56
+	key9            = 57
+	keyColon        = 58
+	keySemicolon    = 59
+	keyLess         = 60
+	keyEquals       = 61
+	keyGreater      = 62
+	keyQuestion     = 63
+	keyAt           = 64
+	keyLeftbracket  = 91
+	keyBackslash    = 92
+	keyRightbracket = 93
+	keyCaret        = 94
+	keyUnderscore   = 95
+	keyBackquote    = 96
+	keyA            = 97
+	keyB            = 98
+	keyC            = 99
+	keyD            = 100
+	keyE            = 101
+	keyF            = 102
+	keyG            = 103
+	keyH            = 104
+	keyI            = 105
+	keyJ            = 106
+	keyK            = 107
+	keyL            = 108
+	keyM            = 109
+	keyN            = 110
+	keyO            = 111
+	keyP            = 112
+	keyQ            = 113
+	keyR            = 114
+	keyS            = 115
+	keyT            = 116
+	keyU            = 117
+	keyV            = 118
+	keyW            = 119
+	keyX            = 120
+	keyY            = 121
+	keyZ            = 122
+	keyDelete       = 127
+	keyWorld0       = 160
+	keyWorld1       = 161
+	keyWorld2       = 162
+	keyWorld3       = 163
+	keyWorld4       = 164
+	keyWorld5       = 165
+	keyWorld6       = 166
+	keyWorld7       = 167
+	keyWorld8       = 168
+	keyWorld9       = 169
+	keyWorld10      = 170
+	keyWorld11      = 171
+	keyWorld12      = 172
+	keyWorld13      = 173
+	keyWorld14      = 174
+	keyWorld15      = 175
+	keyWorld16      = 176
+	keyWorld17      = 177
+	keyWorld18      = 178
+	keyWorld19      = 179
+	keyWorld20      = 180
+	keyWorld21      = 181
+	keyWorld22      = 182
+	keyWorld23      = 183
+	keyWorld24      = 184
+	keyWorld25      = 185
+	keyWorld26      = 186
+	keyWorld27      = 187
+	keyWorld28      = 188
+	keyWorld29      = 189
+	keyWorld30      = 190
+	keyWorld31      = 191
+	keyWorld32      = 192
+	keyWorld33      = 193
+	keyWorld34      = 194
+	keyWorld35      = 195
+	keyWorld36      = 196
+	keyWorld37      = 197
+	keyWorld38      = 198
+	keyWorld39      = 199
+	keyWorld40      = 200
+	keyWorld41      = 201
+	keyWorld42      = 202
+	keyWorld43      = 203
+	keyWorld44      = 204
+	keyWorld45      = 205
+	keyWorld46      = 206
+	keyWorld47      = 207
+	keyWorld48      = 208
+	keyWorld49      = 209
+	keyWorld50      = 210
+	keyWorld51      = 211
+	keyWorld52      = 212
+	keyWorld53      = 213
+	keyWorld54      = 214
+	keyWorld55      = 215
+	keyWorld56      = 216
+	keyWorld57      = 217
+	keyWorld58      = 218
+	keyWorld59      = 219
+	keyWorld60      = 220
+	keyWorld61      = 221
+	keyWorld62      = 222
+	keyWorld63      = 223
+	keyWorld64      = 224
+	keyWorld65      = 225
+	keyWorld66      = 226
+	keyWorld67      = 227
+	keyWorld68      = 228
+	keyWorld69      = 229
+	keyWorld70      = 230
+	keyWorld71      = 231
+	keyWorld72      = 232
+	keyWorld73      = 233
+	keyWorld74      = 234
+	keyWorld75      = 235
+	keyWorld76      = 236
+	keyWorld77      = 237
+	keyWorld78      = 238
+	keyWorld79      = 239
+	keyWorld80      = 240
+	keyWorld81      = 241
+	keyWorld82      = 242
+	keyWorld83      = 243
+	keyWorld84      = 244
+	keyWorld85      = 245
+	keyWorld86      = 246
+	keyWorld87      = 247
+	keyWorld88      = 248
+	keyWorld89      = 249
+	keyWorld90      = 250
+	keyWorld91      = 251
+	keyWorld92      = 252
+	keyWorld93      = 253
+	keyWorld94      = 254
+	keyWorld95      = 255
 
 	// Numeric keypad
-	keyKp0		= 256;
-	keyKp1		= 257;
-	keyKp2		= 258;
-	keyKp3		= 259;
-	keyKp4		= 260;
-	keyKp5		= 261;
-	keyKp6		= 262;
-	keyKp7		= 263;
-	keyKp8		= 264;
-	keyKp9		= 265;
-	keyKpPeriod	= 266;
-	keyKpDivide	= 267;
-	keyKpMultiply	= 268;
-	keyKpMinus	= 269;
-	keyKpPlus	= 270;
-	keyKpEnter	= 271;
-	keyKpEquals	= 272;
+	keyKp0        = 256
+	keyKp1        = 257
+	keyKp2        = 258
+	keyKp3        = 259
+	keyKp4        = 260
+	keyKp5        = 261
+	keyKp6        = 262
+	keyKp7        = 263
+	keyKp8        = 264
+	keyKp9        = 265
+	keyKpPeriod   = 266
+	keyKpDivide   = 267
+	keyKpMultiply = 268
+	keyKpMinus    = 269
+	keyKpPlus     = 270
+	keyKpEnter    = 271
+	keyKpEquals   = 272
 
 	// Arrow & insert/delete pad
-	keyUp		= 273;
-	keyDown		= 274;
-	keyRight	= 275;
-	keyLeft		= 276;
-	keyInsert	= 277;
-	keyHome		= 278;
-	keyEnd		= 279;
-	keyPageup	= 280;
-	keyPagedown	= 281;
+	keyUp       = 273
+	keyDown     = 274
+	keyRight    = 275
+	keyLeft     = 276
+	keyInsert   = 277
+	keyHome     = 278
+	keyEnd      = 279
+	keyPageup   = 280
+	keyPagedown = 281
 
 	// Function keys
-	keyF1	= 282;
-	keyF2	= 283;
-	keyF3	= 284;
-	keyF4	= 285;
-	keyF5	= 286;
-	keyF6	= 287;
-	keyF7	= 288;
-	keyF8	= 289;
-	keyF9	= 290;
-	keyF10	= 291;
-	keyF11	= 292;
-	keyF12	= 293;
-	keyF13	= 294;
-	keyF14	= 295;
-	keyF15	= 296;
+	keyF1  = 282
+	keyF2  = 283
+	keyF3  = 284
+	keyF4  = 285
+	keyF5  = 286
+	keyF6  = 287
+	keyF7  = 288
+	keyF8  = 289
+	keyF9  = 290
+	keyF10 = 291
+	keyF11 = 292
+	keyF12 = 293
+	keyF13 = 294
+	keyF14 = 295
+	keyF15 = 296
 
 	// Modifier keys
-	keyNumlock	= 300;
-	keyCapslock	= 301;
-	keyScrollock	= 302;
-	keyRshift	= 303;
-	keyLshift	= 304;
-	keyRctrl	= 305;
-	keyLctrl	= 306;
-	keyRalt		= 307;
-	keyLalt		= 308;
-	keyRmeta	= 309;
-	keyLmeta	= 310;
-	keyLsuper	= 311;
-	keyRsuper	= 312;
-	keyMode		= 313;
-	keyCompose	= 314;
+	keyNumlock   = 300
+	keyCapslock  = 301
+	keyScrollock = 302
+	keyRshift    = 303
+	keyLshift    = 304
+	keyRctrl     = 305
+	keyLctrl     = 306
+	keyRalt      = 307
+	keyLalt      = 308
+	keyRmeta     = 309
+	keyLmeta     = 310
+	keyLsuper    = 311
+	keyRsuper    = 312
+	keyMode      = 313
+	keyCompose   = 314
 
 	// Misc keys
-	keyHelp		= 315;
-	keyPrint	= 316;
-	keySysreq	= 317;
-	keyBreak	= 318;
-	keyMenu		= 319;
-	keyPower	= 320;
-	keyEuro		= 321;
-	keyUndo		= 322;
+	keyHelp   = 315
+	keyPrint  = 316
+	keySysreq = 317
+	keyBreak  = 318
+	keyMenu   = 319
+	keyPower  = 320
+	keyEuro   = 321
+	keyUndo   = 322
 
 	// Add any other keys here
-	keyLast;
+	keyLast
 )
 
 // A keymod is a set of bit flags
 type keymod uint16
 
 const (
-	keymodNone	= 0x0000;
-	keymodLshift	= 0x0001;
-	keymodRshift	= 0x0002;
-	keymodLctrl	= 0x0040;
-	keymodRctrl	= 0x0080;
-	keymodLalt	= 0x0100;
-	keymodRalt	= 0x0200;
-	keymodLmeta	= 0x0400;
-	keymodRmeta	= 0x0800;
-	keymodNum	= 0x1000;
-	keymodCaps	= 0x2000;
-	keymodMode	= 0x4000;
-	keymodReserved	= 0x8000;
+	keymodNone     = 0x0000
+	keymodLshift   = 0x0001
+	keymodRshift   = 0x0002
+	keymodLctrl    = 0x0040
+	keymodRctrl    = 0x0080
+	keymodLalt     = 0x0100
+	keymodRalt     = 0x0200
+	keymodLmeta    = 0x0400
+	keymodRmeta    = 0x0800
+	keymodNum      = 0x1000
+	keymodCaps     = 0x2000
+	keymodMode     = 0x4000
+	keymodReserved = 0x8000
 )
 
 const (
-	mouseButtonLeft		= 1;
-	mouseButtonMiddle	= 2;
-	mouseButtonRight	= 3;
-	mouseScrollUp		= 4;
-	mouseScrollDown		= 5;
+	mouseButtonLeft   = 1
+	mouseButtonMiddle = 2
+	mouseButtonRight  = 3
+	mouseScrollUp     = 4
+	mouseScrollDown   = 5
 )
 
 const (
-	mouseStateLeftButtonPressed	= 1;
-	mouseStateMiddleButtonPressed	= 2;
-	mouseStateRightButtonPressed	= 4;
+	mouseStateLeftButtonPressed   = 1
+	mouseStateMiddleButtonPressed = 2
+	mouseStateRightButtonPressed  = 4
 )
 
 const (
-	activeMouse		= 1;	//  mouse leaving/entering
-	activeInputFocus	= 2;	// input focus lost/restored
-	activeApplication	= 4;	// application minimized/restored
+	activeMouse       = 1 //  mouse leaving/entering
+	activeInputFocus  = 2 // input focus lost/restored
+	activeApplication = 4 // application minimized/restored
 )
 
 const maxEventBytes = 64
 
 type activeEvent struct {
-	EventType	eventType;
-	Gain		uint8;
-	State		uint8;
+	EventType eventType
+	Gain      uint8
+	State     uint8
 }
 
 type exposeEvent struct {
-	EventType eventType;
+	EventType eventType
 }
 
 type keyboardEvent struct {
-	EventType	eventType;
-	Device		uint8;
-	State		uint8;
-	Pad		uint8;
-	ScanCode	uint8;
-	Pad1		uint8;
-	Key		key;
-	Mod		keymod;
-	Unicode		uint16;
+	EventType eventType
+	Device    uint8
+	State     uint8
+	Pad       uint8
+	ScanCode  uint8
+	Pad1      uint8
+	Key       key
+	Mod       keymod
+	Unicode   uint16
 }
 
 type mouseMotionEvent struct {
-	EventType	eventType;
-	Device		uint8;
-	Buttons		uint8;
-	Pad		uint8;
-	X		uint16;
-	Y		uint16;
-	Xrel		int16;
-	Yrel		int16;
+	EventType eventType
+	Device    uint8
+	Buttons   uint8
+	Pad       uint8
+	X         uint16
+	Y         uint16
+	Xrel      int16
+	Yrel      int16
 }
 
 type mouseButtonEvent struct {
-	EventType	eventType;
-	Device		uint8;
-	Button		uint8;
-	State		uint8;
-	X		uint16;
-	Y		uint16;
+	EventType eventType
+	Device    uint8
+	Button    uint8
+	State     uint8
+	X         uint16
+	Y         uint16
 }
 
 type quitEvent struct {
-	EventType eventType;
+	EventType eventType
 }
 
 type syncEvent struct{}
@@ -378,64 +378,64 @@ type event interface{}
 type reader []byte
 
 func (r *reader) Read(p []byte) (n int, err os.Error) {
-	b := *r;
+	b := *r
 	if len(b) == 0 && len(p) > 0 {
 		return 0, os.EOF
 	}
-	n = copy(p, b);
-	*r = b[n:];
-	return;
+	n = copy(p, b)
+	*r = b[n:]
+	return
 }
 
 func (w *Window) readEvents() {
-	buf := make([]byte, maxEventBytes);
-	clean := false;
+	buf := make([]byte, maxEventBytes)
+	clean := false
 	var (
-		ea	*activeEvent;
-		ee	*exposeEvent;
-		ke	*keyboardEvent;
-		mme	*mouseMotionEvent;
-		mbe	*mouseButtonEvent;
-		qe	*quitEvent;
+		ea  *activeEvent
+		ee  *exposeEvent
+		ke  *keyboardEvent
+		mme *mouseMotionEvent
+		mbe *mouseButtonEvent
+		qe  *quitEvent
 	)
-	var m draw.Mouse;
+	var m draw.Mouse
 	for {
 		if err := videoPollEvent(buf); err != nil {
 			if !clean {
 				clean = w.resizec <- false
 			}
-			time.Sleep(10e6);	// 10ms
-			continue;
+			time.Sleep(10e6) // 10ms
+			continue
 		}
-		clean = false;
-		var e event;
+		clean = false
+		var e event
 		switch buf[0] {
 		default:
-			log.Stdout("unsupported event type", buf[0]);
-			continue;
+			log.Stdout("unsupported event type", buf[0])
+			continue
 		case eventActive:
-			ea = new(activeEvent);
-			e = ea;
+			ea = new(activeEvent)
+			e = ea
 		case eventExpose:
-			ee = new(exposeEvent);
-			e = ee;
+			ee = new(exposeEvent)
+			e = ee
 		case eventKeyDown, eventKeyUp:
-			ke = new(keyboardEvent);
-			e = ke;
+			ke = new(keyboardEvent)
+			e = ke
 		case eventMouseMotion:
-			mme = new(mouseMotionEvent);
-			e = mme;
+			mme = new(mouseMotionEvent)
+			e = mme
 		case eventMouseButtonDown, eventMouseButtonUp:
-			mbe = new(mouseButtonEvent);
-			e = mbe;
+			mbe = new(mouseButtonEvent)
+			e = mbe
 		case eventQuit:
-			qe = new(quitEvent);
-			e = qe;
+			qe = new(quitEvent)
+			e = qe
 		}
-		r := reader(buf);
+		r := reader(buf)
 		if err := binary.Read(&r, binary.LittleEndian, e); err != nil {
-			log.Stdout("unpacking %T event: %s", e, err);
-			continue;
+			log.Stdout("unpacking %T event: %s", e, err)
+			continue
 		}
 		// log.Stdoutf("%#v\n", e);
 		switch buf[0] {
@@ -446,25 +446,25 @@ func (w *Window) readEvents() {
 		case eventKeyUp:
 			w.kbdc <- -int(ke.Key)
 		case eventMouseMotion:
-			m.X = int(mme.X);
-			m.Y = int(mme.Y);
-			m.Buttons = int(mme.Buttons);
-			m.Nsec = time.Nanoseconds();
-			_ = w.mousec <- m;
+			m.X = int(mme.X)
+			m.Y = int(mme.Y)
+			m.Buttons = int(mme.Buttons)
+			m.Nsec = time.Nanoseconds()
+			_ = w.mousec <- m
 		case eventMouseButtonDown:
-			m.X = int(mbe.X);
-			m.Y = int(mbe.Y);
+			m.X = int(mbe.X)
+			m.Y = int(mbe.Y)
 			// TODO(rsc): Remove uint cast once 8g bug is fixed.
-			m.Buttons |= 1 << uint(mbe.Button-1);
-			m.Nsec = time.Nanoseconds();
-			_ = w.mousec <- m;
+			m.Buttons |= 1 << uint(mbe.Button-1)
+			m.Nsec = time.Nanoseconds()
+			_ = w.mousec <- m
 		case eventMouseButtonUp:
-			m.X = int(mbe.X);
-			m.Y = int(mbe.Y);
+			m.X = int(mbe.X)
+			m.Y = int(mbe.Y)
 			// TODO(rsc): Remove uint cast once 8g bug is fixed.
-			m.Buttons &^= 1 << uint(mbe.Button-1);
-			m.Nsec = time.Nanoseconds();
-			_ = w.mousec <- m;
+			m.Buttons &^= 1 << uint(mbe.Button-1)
+			m.Nsec = time.Nanoseconds()
+			_ = w.mousec <- m
 		case eventQuit:
 			w.quitc <- true
 		}
diff --git a/src/pkg/exp/nacl/av/image.go b/src/pkg/exp/nacl/av/image.go
index 8e096d1655..f69f94a657 100644
--- a/src/pkg/exp/nacl/av/image.go
+++ b/src/pkg/exp/nacl/av/image.go
@@ -5,7 +5,7 @@
 package av
 
 import (
-	"image";
+	"image"
 )
 
 // Native Client image format:
@@ -16,41 +16,41 @@ import (
 // linear slice or as a two-dimensional slice of slices.
 // Image implements image.Image.
 type Image struct {
-	Linear	[]Color;
-	Pixel	[][]Color;
+	Linear []Color
+	Pixel  [][]Color
 }
 
 var _ image.Image = (*Image)(nil)
 
-func (m *Image) ColorModel() image.ColorModel	{ return ColorModel }
+func (m *Image) ColorModel() image.ColorModel { return ColorModel }
 
 func (m *Image) Width() int {
 	if len(m.Pixel) == 0 {
 		return 0
 	}
-	return len(m.Pixel[0]);
+	return len(m.Pixel[0])
 }
 
-func (m *Image) Height() int	{ return len(m.Pixel) }
+func (m *Image) Height() int { return len(m.Pixel) }
 
-func (m *Image) At(x, y int) image.Color	{ return m.Pixel[y][x] }
+func (m *Image) At(x, y int) image.Color { return m.Pixel[y][x] }
 
 func (m *Image) Set(x, y int, color image.Color) {
 	if c, ok := color.(Color); ok {
 		m.Pixel[y][x] = c
 	}
-	m.Pixel[y][x] = makeColor(color.RGBA());
+	m.Pixel[y][x] = makeColor(color.RGBA())
 }
 
 func newImage(dx, dy int, linear []Color) *Image {
 	if linear == nil {
 		linear = make([]Color, dx*dy)
 	}
-	pix := make([][]Color, dy);
+	pix := make([][]Color, dy)
 	for i := range pix {
 		pix[i] = linear[dx*i : dx*(i+1)]
 	}
-	return &Image{linear, pix};
+	return &Image{linear, pix}
 }
 
 // A Color represents a Native Client color value,
@@ -58,20 +58,20 @@ func newImage(dx, dy int, linear []Color) *Image {
 type Color uint32
 
 func (p Color) RGBA() (r, g, b, a uint32) {
-	x := uint32(p);
-	a = x >> 24;
-	a |= a << 8;
-	a |= a << 16;
-	r = (x >> 16) & 0xFF;
-	r |= r << 8;
-	r |= r << 16;
-	g = (x >> 8) & 0xFF;
-	g |= g << 8;
-	g |= g << 16;
-	b = x & 0xFF;
-	b |= b << 8;
-	b |= b << 16;
-	return;
+	x := uint32(p)
+	a = x >> 24
+	a |= a << 8
+	a |= a << 16
+	r = (x >> 16) & 0xFF
+	r |= r << 8
+	r |= r << 16
+	g = (x >> 8) & 0xFF
+	g |= g << 8
+	g |= g << 16
+	b = x & 0xFF
+	b |= b << 8
+	b |= b << 16
+	return
 }
 
 func makeColor(r, g, b, a uint32) Color {
@@ -82,7 +82,7 @@ func toColor(color image.Color) image.Color {
 	if c, ok := color.(Color); ok {
 		return c
 	}
-	return makeColor(color.RGBA());
+	return makeColor(color.RGBA())
 }
 
 // ColorModel is the color model corresponding to the Native Client Color.
diff --git a/src/pkg/exp/nacl/srpc/client.go b/src/pkg/exp/nacl/srpc/client.go
index d19b48888d..9e47376f81 100644
--- a/src/pkg/exp/nacl/srpc/client.go
+++ b/src/pkg/exp/nacl/srpc/client.go
@@ -6,48 +6,48 @@
 package srpc
 
 import (
-	"bytes";
-	"log";
-	"os";
-	"sync";
+	"bytes"
+	"log"
+	"os"
+	"sync"
 )
 
 // A Client represents the client side of an SRPC connection.
 type Client struct {
-	fd	int;	// fd to server
-	r	msgReceiver;
-	s	msgSender;
-	service	map[string]srv;	// services by name
-	out	chan *msg;	// send to out to write to connection
-
-	mu	sync.Mutex;	// protects pending, idGen
-	pending	map[uint64]*RPC;
-	idGen	uint64;	// generator for request IDs
+	fd      int // fd to server
+	r       msgReceiver
+	s       msgSender
+	service map[string]srv // services by name
+	out     chan *msg      // send to out to write to connection
+
+	mu      sync.Mutex // protects pending, idGen
+	pending map[uint64]*RPC
+	idGen   uint64 // generator for request IDs
 }
 
 // A srv is a single method that the server offers.
 type srv struct {
-	num	uint32;	// method number
-	fmt	string;	// argument format
+	num uint32 // method number
+	fmt string // argument format
 }
 
 // An RPC represents a single RPC issued by a client.
 type RPC struct {
-	Ret	[]interface{};	// Return values
-	Done	chan *RPC;	// Channel where notification of done arrives
-	Errno	Errno;		// Status code
-	c	*Client;
-	id	uint64;	// request id
+	Ret   []interface{} // Return values
+	Done  chan *RPC     // Channel where notification of done arrives
+	Errno Errno         // Status code
+	c     *Client
+	id    uint64 // request id
 }
 
 // NewClient allocates a new client using the file descriptor fd.
 func NewClient(fd int) (c *Client, err os.Error) {
-	c = new(Client);
-	c.fd = fd;
-	c.r.fd = fd;
-	c.s.fd = fd;
-	c.service = make(map[string]srv);
-	c.pending = make(map[uint64]*RPC);
+	c = new(Client)
+	c.fd = fd
+	c.r.fd = fd
+	c.s.fd = fd
+	c.service = make(map[string]srv)
+	c.pending = make(map[uint64]*RPC)
 
 	// service discovery request
 	m := &msg{
@@ -55,54 +55,54 @@ func NewClient(fd int) (c *Client, err os.Error) {
 		isReq: true,
 		Ret: []interface{}{[]byte(nil)},
 		Size: []int{4000},
-	};
-	m.packRequest();
-	c.s.send(m);
-	m, err = c.r.recv();
+	}
+	m.packRequest()
+	c.s.send(m)
+	m, err = c.r.recv()
 	if err != nil {
 		return nil, err
 	}
-	m.unpackResponse();
+	m.unpackResponse()
 	if m.status != OK {
-		log.Stderrf("NewClient service_discovery: %s", m.status);
-		return nil, m.status;
+		log.Stderrf("NewClient service_discovery: %s", m.status)
+		return nil, m.status
 	}
 	for n, line := range bytes.Split(m.Ret[0].([]byte), []byte{'\n'}, 0) {
-		i := bytes.Index(line, []byte{':'});
+		i := bytes.Index(line, []byte{':'})
 		if i < 0 {
 			continue
 		}
-		c.service[string(line[0:i])] = srv{uint32(n), string(line[i+1:])};
+		c.service[string(line[0:i])] = srv{uint32(n), string(line[i+1:])}
 	}
 
-	c.out = make(chan *msg);
-	go c.input();
-	go c.output();
-	return c, nil;
+	c.out = make(chan *msg)
+	go c.input()
+	go c.output()
+	return c, nil
 }
 
 func (c *Client) input() {
 	for {
-		m, err := c.r.recv();
+		m, err := c.r.recv()
 		if err != nil {
 			log.Exitf("client recv: %s", err)
 		}
 		if m.unpackResponse(); m.status != OK {
-			log.Stderrf("invalid message: %s", m.status);
-			continue;
+			log.Stderrf("invalid message: %s", m.status)
+			continue
 		}
-		c.mu.Lock();
-		rpc, ok := c.pending[m.requestId];
+		c.mu.Lock()
+		rpc, ok := c.pending[m.requestId]
 		if ok {
 			c.pending[m.requestId] = nil, false
 		}
-		c.mu.Unlock();
+		c.mu.Unlock()
 		if !ok {
-			log.Stderrf("unexpected response");
-			continue;
+			log.Stderrf("unexpected response")
+			continue
 		}
-		rpc.Ret = m.Ret;
-		rpc.Done <- rpc;
+		rpc.Ret = m.Ret
+		rpc.Done <- rpc
 	}
 }
 
@@ -117,11 +117,11 @@ func (c *Client) NewRPC(done chan *RPC) *RPC {
 	if done == nil {
 		done = make(chan *RPC)
 	}
-	c.mu.Lock();
-	id := c.idGen;
-	c.idGen++;
-	c.mu.Unlock();
-	return &RPC{nil, done, OK, c, id};
+	c.mu.Lock()
+	id := c.idGen
+	c.idGen++
+	c.mu.Unlock()
+	return &RPC{nil, done, OK, c, id}
 }
 
 // Start issues an RPC request for method name with the given arguments.
@@ -129,25 +129,25 @@ func (c *Client) NewRPC(done chan *RPC) *RPC {
 // To wait for the RPC to finish, receive from r.Done and then
 // inspect r.Ret and r.Errno.
 func (r *RPC) Start(name string, arg []interface{}) {
-	var m msg;
+	var m msg
 
-	r.Errno = OK;
-	r.c.mu.Lock();
-	srv, ok := r.c.service[name];
+	r.Errno = OK
+	r.c.mu.Lock()
+	srv, ok := r.c.service[name]
 	if !ok {
-		r.c.mu.Unlock();
-		r.Errno = ErrBadRPCNumber;
-		r.Done <- r;
-		return;
+		r.c.mu.Unlock()
+		r.Errno = ErrBadRPCNumber
+		r.Done <- r
+		return
 	}
-	r.c.pending[r.id] = r;
-	r.c.mu.Unlock();
+	r.c.pending[r.id] = r
+	r.c.mu.Unlock()
 
-	m.protocol = protocol;
-	m.requestId = r.id;
-	m.isReq = true;
-	m.rpcNumber = srv.num;
-	m.Arg = arg;
+	m.protocol = protocol
+	m.requestId = r.id
+	m.isReq = true
+	m.rpcNumber = srv.num
+	m.Arg = arg
 
 	// Fill in the return values and sizes to generate
 	// the right type chars.  We'll take most any size.
@@ -155,15 +155,15 @@ func (r *RPC) Start(name string, arg []interface{}) {
 	// Skip over input arguments.
 	// We could check them against arg, but the server
 	// will do that anyway.
-	i := 0;
+	i := 0
 	for srv.fmt[i] != ':' {
 		i++
 	}
-	fmt := srv.fmt[i+1:];
+	fmt := srv.fmt[i+1:]
 
 	// Now the return prototypes.
-	m.Ret = make([]interface{}, len(fmt)-i);
-	m.Size = make([]int, len(fmt)-i);
+	m.Ret = make([]interface{}, len(fmt)-i)
+	m.Size = make([]int, len(fmt)-i)
 	for i := 0; i < len(fmt); i++ {
 		switch fmt[i] {
 		default:
@@ -171,28 +171,28 @@ func (r *RPC) Start(name string, arg []interface{}) {
 		case 'b':
 			m.Ret[i] = false
 		case 'C':
-			m.Ret[i] = []byte(nil);
-			m.Size[i] = 1 << 30;
+			m.Ret[i] = []byte(nil)
+			m.Size[i] = 1 << 30
 		case 'd':
 			m.Ret[i] = float64(0)
 		case 'D':
-			m.Ret[i] = []float64(nil);
-			m.Size[i] = 1 << 30;
+			m.Ret[i] = []float64(nil)
+			m.Size[i] = 1 << 30
 		case 'h':
 			m.Ret[i] = int(-1)
 		case 'i':
 			m.Ret[i] = int32(0)
 		case 'I':
-			m.Ret[i] = []int32(nil);
-			m.Size[i] = 1 << 30;
+			m.Ret[i] = []int32(nil)
+			m.Size[i] = 1 << 30
 		case 's':
-			m.Ret[i] = "";
-			m.Size[i] = 1 << 30;
+			m.Ret[i] = ""
+			m.Size[i] = 1 << 30
 		}
 	}
 
-	m.packRequest();
-	r.c.out <- &m;
+	m.packRequest()
+	r.c.out <- &m
 }
 
 // Call is a convenient wrapper that starts the RPC request,
@@ -204,7 +204,7 @@ func (r *RPC) Start(name string, arg []interface{}) {
 //	return r.Ret, r.Errno;
 //
 func (r *RPC) Call(name string, arg []interface{}) (ret []interface{}, err Errno) {
-	r.Start(name, arg);
-	<-r.Done;
-	return r.Ret, r.Errno;
+	r.Start(name, arg)
+	<-r.Done
+	return r.Ret, r.Errno
 }
diff --git a/src/pkg/exp/nacl/srpc/msg.go b/src/pkg/exp/nacl/srpc/msg.go
index 54ba5a4e33..52f84b884f 100644
--- a/src/pkg/exp/nacl/srpc/msg.go
+++ b/src/pkg/exp/nacl/srpc/msg.go
@@ -7,30 +7,30 @@
 package srpc
 
 import (
-	"math";
-	"os";
-	"strconv";
-	"syscall";
-	"unsafe";
+	"math"
+	"os"
+	"strconv"
+	"syscall"
+	"unsafe"
 )
 
 // An Errno is an SRPC status code.
 type Errno uint32
 
 const (
-	OK	Errno	= 256 + iota;
-	ErrBreak;
-	ErrMessageTruncated;
-	ErrNoMemory;
-	ErrProtocolMismatch;
-	ErrBadRPCNumber;
-	ErrBadArgType;
-	ErrTooFewArgs;
-	ErrTooManyArgs;
-	ErrInArgTypeMismatch;
-	ErrOutArgTypeMismatch;
-	ErrInternalError;
-	ErrAppError;
+	OK Errno = 256 + iota
+	ErrBreak
+	ErrMessageTruncated
+	ErrNoMemory
+	ErrProtocolMismatch
+	ErrBadRPCNumber
+	ErrBadArgType
+	ErrTooFewArgs
+	ErrTooManyArgs
+	ErrInArgTypeMismatch
+	ErrOutArgTypeMismatch
+	ErrInternalError
+	ErrAppError
 )
 
 var errstr = [...]string{
@@ -53,7 +53,7 @@ func (e Errno) String() string {
 	if e < OK || int(e-OK) >= len(errstr) {
 		return "Errno(" + strconv.Itoa64(int64(e)) + ")"
 	}
-	return errstr[e-OK];
+	return errstr[e-OK]
 }
 
 // A *msgHdr is the data argument to the imc_recvmsg
@@ -61,56 +61,56 @@ func (e Errno) String() string {
 // counts trusted by the system calls, the data structure is unsafe
 // to expose to package clients.
 type msgHdr struct {
-	iov	*iov;
-	niov	int32;
-	desc	*int32;
-	ndesc	int32;
-	flags	uint32;
+	iov   *iov
+	niov  int32
+	desc  *int32
+	ndesc int32
+	flags uint32
 }
 
 // A single region for I/O.  Just as unsafe as msgHdr.
 type iov struct {
-	base	*byte;
-	len	int32;
+	base *byte
+	len  int32
 }
 
 // A msg is the Go representation of a message.
 type msg struct {
-	rdata	[]byte;		// data being consumed during message parsing
-	rdesc	[]int32;	// file descriptors being consumed during message parsing
-	wdata	[]byte;		// data being generated when replying
+	rdata []byte  // data being consumed during message parsing
+	rdesc []int32 // file descriptors being consumed during message parsing
+	wdata []byte  // data being generated when replying
 
 	// parsed version of message
-	protocol	uint32;
-	requestId	uint64;
-	isReq		bool;
-	rpcNumber	uint32;
-	gotHeader	bool;
-	status		Errno;		// error code sent in response
-	Arg		[]interface{};	// method arguments
-	Ret		[]interface{};	// method results
-	Size		[]int;		// max sizes for arrays in method results
-	fmt		string;		// accumulated format string of arg+":"+ret
+	protocol  uint32
+	requestId uint64
+	isReq     bool
+	rpcNumber uint32
+	gotHeader bool
+	status    Errno         // error code sent in response
+	Arg       []interface{} // method arguments
+	Ret       []interface{} // method results
+	Size      []int         // max sizes for arrays in method results
+	fmt       string        // accumulated format string of arg+":"+ret
 }
 
 // A msgReceiver receives messages from a file descriptor.
 type msgReceiver struct {
-	fd	int;
-	data	[128 * 1024]byte;
-	desc	[8]int32;
-	hdr	msgHdr;
-	iov	iov;
+	fd   int
+	data [128 * 1024]byte
+	desc [8]int32
+	hdr  msgHdr
+	iov  iov
 }
 
 func (r *msgReceiver) recv() (*msg, os.Error) {
 	// Init pointers to buffers where syscall recvmsg can write.
-	r.iov.base = &r.data[0];
-	r.iov.len = int32(len(r.data));
-	r.hdr.iov = &r.iov;
-	r.hdr.niov = 1;
-	r.hdr.desc = &r.desc[0];
-	r.hdr.ndesc = int32(len(r.desc));
-	n, _, e := syscall.Syscall(syscall.SYS_IMC_RECVMSG, uintptr(r.fd), uintptr(unsafe.Pointer(&r.hdr)), 0);
+	r.iov.base = &r.data[0]
+	r.iov.len = int32(len(r.data))
+	r.hdr.iov = &r.iov
+	r.hdr.niov = 1
+	r.hdr.desc = &r.desc[0]
+	r.hdr.ndesc = int32(len(r.desc))
+	n, _, e := syscall.Syscall(syscall.SYS_IMC_RECVMSG, uintptr(r.fd), uintptr(unsafe.Pointer(&r.hdr)), 0)
 	if e != 0 {
 		return nil, os.NewSyscallError("imc_recvmsg", int(e))
 	}
@@ -118,43 +118,43 @@ func (r *msgReceiver) recv() (*msg, os.Error) {
 	// Make a copy of the data so that the next recvmsg doesn't
 	// smash it.  The system call did not update r.iov.len.  Instead it
 	// returned the total byte count as n.
-	m := new(msg);
-	m.rdata = make([]byte, n);
-	copy(m.rdata, &r.data);
+	m := new(msg)
+	m.rdata = make([]byte, n)
+	copy(m.rdata, &r.data)
 
 	// Make a copy of the desc too.
 	// The system call *did* update r.hdr.ndesc.
 	if r.hdr.ndesc > 0 {
-		m.rdesc = make([]int32, r.hdr.ndesc);
+		m.rdesc = make([]int32, r.hdr.ndesc)
 		for i := range m.rdesc {
 			m.rdesc[i] = r.desc[i]
 		}
 	}
 
-	return m, nil;
+	return m, nil
 }
 
 // A msgSender sends messages on a file descriptor.
 type msgSender struct {
-	fd	int;
-	hdr	msgHdr;
-	iov	iov;
+	fd  int
+	hdr msgHdr
+	iov iov
 }
 
 func (s *msgSender) send(m *msg) os.Error {
 	if len(m.wdata) > 0 {
 		s.iov.base = &m.wdata[0]
 	}
-	s.iov.len = int32(len(m.wdata));
-	s.hdr.iov = &s.iov;
-	s.hdr.niov = 1;
-	s.hdr.desc = nil;
-	s.hdr.ndesc = 0;
-	_, _, e := syscall.Syscall(syscall.SYS_IMC_SENDMSG, uintptr(s.fd), uintptr(unsafe.Pointer(&s.hdr)), 0);
+	s.iov.len = int32(len(m.wdata))
+	s.hdr.iov = &s.iov
+	s.hdr.niov = 1
+	s.hdr.desc = nil
+	s.hdr.ndesc = 0
+	_, _, e := syscall.Syscall(syscall.SYS_IMC_SENDMSG, uintptr(s.fd), uintptr(unsafe.Pointer(&s.hdr)), 0)
 	if e != 0 {
 		return os.NewSyscallError("imc_sendmsg", int(e))
 	}
-	return nil;
+	return nil
 }
 
 // Reading from msg.rdata.
@@ -163,12 +163,12 @@ func (m *msg) uint8() uint8 {
 		return 0
 	}
 	if len(m.rdata) < 1 {
-		m.status = ErrMessageTruncated;
-		return 0;
+		m.status = ErrMessageTruncated
+		return 0
 	}
-	x := m.rdata[0];
-	m.rdata = m.rdata[1:];
-	return x;
+	x := m.rdata[0]
+	m.rdata = m.rdata[1:]
+	return x
 }
 
 func (m *msg) uint32() uint32 {
@@ -176,13 +176,13 @@ func (m *msg) uint32() uint32 {
 		return 0
 	}
 	if len(m.rdata) < 4 {
-		m.status = ErrMessageTruncated;
-		return 0;
+		m.status = ErrMessageTruncated
+		return 0
 	}
-	b := m.rdata[0:4];
-	x := uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24;
-	m.rdata = m.rdata[4:];
-	return x;
+	b := m.rdata[0:4]
+	x := uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24
+	m.rdata = m.rdata[4:]
+	return x
 }
 
 func (m *msg) uint64() uint64 {
@@ -190,14 +190,14 @@ func (m *msg) uint64() uint64 {
 		return 0
 	}
 	if len(m.rdata) < 8 {
-		m.status = ErrMessageTruncated;
-		return 0;
+		m.status = ErrMessageTruncated
+		return 0
 	}
-	b := m.rdata[0:8];
-	x := uint64(uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24);
-	x |= uint64(uint32(b[4])|uint32(b[5])<<8|uint32(b[6])<<16|uint32(b[7])<<24) << 32;
-	m.rdata = m.rdata[8:];
-	return x;
+	b := m.rdata[0:8]
+	x := uint64(uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24)
+	x |= uint64(uint32(b[4])|uint32(b[5])<<8|uint32(b[6])<<16|uint32(b[7])<<24) << 32
+	m.rdata = m.rdata[8:]
+	return x
 }
 
 func (m *msg) bytes(n int) []byte {
@@ -205,54 +205,54 @@ func (m *msg) bytes(n int) []byte {
 		return nil
 	}
 	if len(m.rdata) < n {
-		m.status = ErrMessageTruncated;
-		return nil;
+		m.status = ErrMessageTruncated
+		return nil
 	}
-	x := m.rdata[0:n];
-	m.rdata = m.rdata[n:];
-	return x;
+	x := m.rdata[0:n]
+	m.rdata = m.rdata[n:]
+	return x
 }
 
 // Writing to msg.wdata.
 func (m *msg) grow(n int) []byte {
-	i := len(m.wdata);
+	i := len(m.wdata)
 	if i+n > cap(m.wdata) {
-		a := make([]byte, i, (i+n)*2);
-		copy(a, m.wdata);
-		m.wdata = a;
+		a := make([]byte, i, (i+n)*2)
+		copy(a, m.wdata)
+		m.wdata = a
 	}
-	m.wdata = m.wdata[0 : i+n];
-	return m.wdata[i : i+n];
+	m.wdata = m.wdata[0 : i+n]
+	return m.wdata[i : i+n]
 }
 
-func (m *msg) wuint8(x uint8)	{ m.grow(1)[0] = x }
+func (m *msg) wuint8(x uint8) { m.grow(1)[0] = x }
 
 func (m *msg) wuint32(x uint32) {
-	b := m.grow(4);
-	b[0] = byte(x);
-	b[1] = byte(x >> 8);
-	b[2] = byte(x >> 16);
-	b[3] = byte(x >> 24);
+	b := m.grow(4)
+	b[0] = byte(x)
+	b[1] = byte(x >> 8)
+	b[2] = byte(x >> 16)
+	b[3] = byte(x >> 24)
 }
 
 func (m *msg) wuint64(x uint64) {
-	b := m.grow(8);
-	lo := uint32(x);
-	b[0] = byte(lo);
-	b[1] = byte(lo >> 8);
-	b[2] = byte(lo >> 16);
-	b[3] = byte(lo >> 24);
-	hi := uint32(x >> 32);
-	b[4] = byte(hi);
-	b[5] = byte(hi >> 8);
-	b[6] = byte(hi >> 16);
-	b[7] = byte(hi >> 24);
+	b := m.grow(8)
+	lo := uint32(x)
+	b[0] = byte(lo)
+	b[1] = byte(lo >> 8)
+	b[2] = byte(lo >> 16)
+	b[3] = byte(lo >> 24)
+	hi := uint32(x >> 32)
+	b[4] = byte(hi)
+	b[5] = byte(hi >> 8)
+	b[6] = byte(hi >> 16)
+	b[7] = byte(hi >> 24)
 }
 
-func (m *msg) wbytes(p []byte)	{ copy(m.grow(len(p)), p) }
+func (m *msg) wbytes(p []byte) { copy(m.grow(len(p)), p) }
 
 func (m *msg) wstring(s string) {
-	b := m.grow(len(s));
+	b := m.grow(len(s))
 	for i := range b {
 		b[i] = s[i]
 	}
@@ -298,14 +298,14 @@ func (m *msg) wstring(s string) {
 const protocol = 0xc0da0002
 
 func (m *msg) unpackHeader() {
-	m.protocol = m.uint32();
-	m.requestId = m.uint64();
-	m.isReq = m.uint8() != 0;
-	m.rpcNumber = m.uint32();
-	m.gotHeader = m.status == OK;	// signal that header parsed successfully
+	m.protocol = m.uint32()
+	m.requestId = m.uint64()
+	m.isReq = m.uint8() != 0
+	m.rpcNumber = m.uint32()
+	m.gotHeader = m.status == OK // signal that header parsed successfully
 	if m.gotHeader && !m.isReq {
-		status := Errno(m.uint32());
-		m.gotHeader = m.status == OK;	// still ok?
+		status := Errno(m.uint32())
+		m.gotHeader = m.status == OK // still ok?
 		if m.gotHeader {
 			m.status = status
 		}
@@ -313,14 +313,14 @@ func (m *msg) unpackHeader() {
 }
 
 func (m *msg) packHeader() {
-	m.wuint32(m.protocol);
-	m.wuint64(m.requestId);
+	m.wuint32(m.protocol)
+	m.wuint64(m.requestId)
 	if m.isReq {
 		m.wuint8(1)
 	} else {
 		m.wuint8(0)
 	}
-	m.wuint32(m.rpcNumber);
+	m.wuint32(m.rpcNumber)
 	if !m.isReq {
 		m.wuint32(uint32(m.status))
 	}
@@ -328,44 +328,44 @@ func (m *msg) packHeader() {
 
 func (m *msg) unpackValues(v []interface{}) {
 	for i := range v {
-		t := m.uint8();
-		m.fmt += string(t);
+		t := m.uint8()
+		m.fmt += string(t)
 		switch t {
 		default:
 			if m.status == OK {
 				m.status = ErrBadArgType
 			}
-			return;
-		case 'b':	// bool[1]
+			return
+		case 'b': // bool[1]
 			v[i] = m.uint8() > 0
-		case 'C':	// char array
+		case 'C': // char array
 			v[i] = m.bytes(int(m.uint32()))
-		case 'd':	// double
+		case 'd': // double
 			v[i] = math.Float64frombits(m.uint64())
-		case 'D':	// double array
-			a := make([]float64, int(m.uint32()));
+		case 'D': // double array
+			a := make([]float64, int(m.uint32()))
 			for j := range a {
 				a[j] = math.Float64frombits(m.uint64())
 			}
-			v[i] = a;
-		case 'h':	// file descriptor (handle)
+			v[i] = a
+		case 'h': // file descriptor (handle)
 			if len(m.rdesc) == 0 {
 				if m.status == OK {
 					m.status = ErrBadArgType
 				}
-				return;
+				return
 			}
-			v[i] = int(m.rdesc[0]);
-			m.rdesc = m.rdesc[1:];
-		case 'i':	// int
+			v[i] = int(m.rdesc[0])
+			m.rdesc = m.rdesc[1:]
+		case 'i': // int
 			v[i] = int32(m.uint32())
-		case 'I':	// int array
-			a := make([]int32, int(m.uint32()));
+		case 'I': // int array
+			a := make([]int32, int(m.uint32()))
 			for j := range a {
 				a[j] = int32(m.uint32())
 			}
-			v[i] = a;
-		case 's':	// string
+			v[i] = a
+		case 's': // string
 			v[i] = string(m.bytes(int(m.uint32())))
 		}
 	}
@@ -378,57 +378,57 @@ func (m *msg) packValues(v []interface{}) {
 			if m.status == OK {
 				m.status = ErrInternalError
 			}
-			return;
+			return
 		case bool:
-			m.wuint8('b');
+			m.wuint8('b')
 			if x {
 				m.wuint8(1)
 			} else {
 				m.wuint8(0)
 			}
 		case []byte:
-			m.wuint8('C');
-			m.wuint32(uint32(len(x)));
-			m.wbytes(x);
+			m.wuint8('C')
+			m.wuint32(uint32(len(x)))
+			m.wbytes(x)
 		case float64:
-			m.wuint8('d');
-			m.wuint64(math.Float64bits(x));
+			m.wuint8('d')
+			m.wuint64(math.Float64bits(x))
 		case []float64:
-			m.wuint8('D');
-			m.wuint32(uint32(len(x)));
+			m.wuint8('D')
+			m.wuint32(uint32(len(x)))
 			for _, f := range x {
 				m.wuint64(math.Float64bits(f))
 			}
 		case int32:
-			m.wuint8('i');
-			m.wuint32(uint32(x));
+			m.wuint8('i')
+			m.wuint32(uint32(x))
 		case []int32:
-			m.wuint8('I');
-			m.wuint32(uint32(len(x)));
+			m.wuint8('I')
+			m.wuint32(uint32(len(x)))
 			for _, i := range x {
 				m.wuint32(uint32(i))
 			}
 		case string:
-			m.wuint8('s');
-			m.wuint32(uint32(len(x)));
-			m.wstring(x);
+			m.wuint8('s')
+			m.wuint32(uint32(len(x)))
+			m.wstring(x)
 		}
 	}
 }
 
 func (m *msg) unpackRequest() {
-	m.status = OK;
+	m.status = OK
 	if m.unpackHeader(); m.status != OK {
 		return
 	}
 	if m.protocol != protocol || !m.isReq {
-		m.status = ErrProtocolMismatch;
-		return;
+		m.status = ErrProtocolMismatch
+		return
 	}
 
 	// type-tagged argument values
-	m.Arg = make([]interface{}, m.uint32());
-	m.unpackValues(m.Arg);
+	m.Arg = make([]interface{}, m.uint32())
+	m.unpackValues(m.Arg)
 	if m.status != OK {
 		return
 	}
@@ -436,91 +436,91 @@ func (m *msg) unpackRequest() {
 	// type-tagged expected return sizes.
 	// fill in zero values for each return value
 	// and save sizes.
-	m.fmt += ":";
-	m.Ret = make([]interface{}, m.uint32());
-	m.Size = make([]int, len(m.Ret));
+	m.fmt += ":"
+	m.Ret = make([]interface{}, m.uint32())
+	m.Size = make([]int, len(m.Ret))
 	for i := range m.Ret {
-		t := m.uint8();
-		m.fmt += string(t);
+		t := m.uint8()
+		m.fmt += string(t)
 		switch t {
 		default:
 			if m.status == OK {
 				m.status = ErrBadArgType
 			}
-			return;
-		case 'b':	// bool[1]
+			return
+		case 'b': // bool[1]
 			m.Ret[i] = false
-		case 'C':	// char array
-			m.Size[i] = int(m.uint32());
-			m.Ret[i] = []byte(nil);
-		case 'd':	// double
+		case 'C': // char array
+			m.Size[i] = int(m.uint32())
+			m.Ret[i] = []byte(nil)
+		case 'd': // double
 			m.Ret[i] = float64(0)
-		case 'D':	// double array
-			m.Size[i] = int(m.uint32());
-			m.Ret[i] = []float64(nil);
-		case 'h':	// file descriptor (handle)
+		case 'D': // double array
+			m.Size[i] = int(m.uint32())
+			m.Ret[i] = []float64(nil)
+		case 'h': // file descriptor (handle)
 			m.Ret[i] = int(-1)
-		case 'i':	// int
+		case 'i': // int
 			m.Ret[i] = int32(0)
-		case 'I':	// int array
-			m.Size[i] = int(m.uint32());
-			m.Ret[i] = []int32(nil);
-		case 's':	// string
-			m.Size[i] = int(m.uint32());
-			m.Ret[i] = "";
+		case 'I': // int array
+			m.Size[i] = int(m.uint32())
+			m.Ret[i] = []int32(nil)
+		case 's': // string
+			m.Size[i] = int(m.uint32())
+			m.Ret[i] = ""
 		}
 	}
 }
 
 func (m *msg) packRequest() {
-	m.packHeader();
-	m.wuint32(uint32(len(m.Arg)));
-	m.packValues(m.Arg);
-	m.wuint32(uint32(len(m.Ret)));
+	m.packHeader()
+	m.wuint32(uint32(len(m.Arg)))
+	m.packValues(m.Arg)
+	m.wuint32(uint32(len(m.Ret)))
 	for i, v := range m.Ret {
 		switch x := v.(type) {
 		case bool:
 			m.wuint8('b')
 		case []byte:
-			m.wuint8('C');
-			m.wuint32(uint32(m.Size[i]));
+			m.wuint8('C')
+			m.wuint32(uint32(m.Size[i]))
 		case float64:
 			m.wuint8('d')
 		case []float64:
-			m.wuint8('D');
-			m.wuint32(uint32(m.Size[i]));
+			m.wuint8('D')
+			m.wuint32(uint32(m.Size[i]))
 		case int:
 			m.wuint8('h')
 		case int32:
 			m.wuint8('i')
 		case []int32:
-			m.wuint8('I');
-			m.wuint32(uint32(m.Size[i]));
+			m.wuint8('I')
+			m.wuint32(uint32(m.Size[i]))
 		case string:
-			m.wuint8('s');
-			m.wuint32(uint32(m.Size[i]));
+			m.wuint8('s')
+			m.wuint32(uint32(m.Size[i]))
 		}
 	}
 }
 
 func (m *msg) unpackResponse() {
-	m.status = OK;
+	m.status = OK
 	if m.unpackHeader(); m.status != OK {
 		return
 	}
 	if m.protocol != protocol || m.isReq {
-		m.status = ErrProtocolMismatch;
-		return;
+		m.status = ErrProtocolMismatch
+		return
 	}
 
 	// type-tagged return values
-	m.fmt = "";
-	m.Ret = make([]interface{}, m.uint32());
-	m.unpackValues(m.Ret);
+	m.fmt = ""
+	m.Ret = make([]interface{}, m.uint32())
+	m.unpackValues(m.Ret)
 }
 
 func (m *msg) packResponse() {
-	m.packHeader();
-	m.wuint32(uint32(len(m.Ret)));
-	m.packValues(m.Ret);
+	m.packHeader()
+	m.wuint32(uint32(len(m.Ret)))
+	m.packValues(m.Ret)
 }
diff --git a/src/pkg/exp/nacl/srpc/server.go b/src/pkg/exp/nacl/srpc/server.go
index 56edfccd02..af2b855f51 100644
--- a/src/pkg/exp/nacl/srpc/server.go
+++ b/src/pkg/exp/nacl/srpc/server.go
@@ -7,10 +7,10 @@
 package srpc
 
 import (
-	"bytes";
-	"log";
-	"os";
-	"syscall";
+	"bytes"
+	"log"
+	"os"
+	"syscall"
 )
 
 // TODO(rsc): I'd prefer to make this
@@ -22,13 +22,13 @@ import (
 // It reads arguments from arg, checks size for array limits,
 // writes return values to ret, and returns an Errno status code.
 type Handler interface {
-	Run(arg, ret []interface{}, size []int) Errno;
+	Run(arg, ret []interface{}, size []int) Errno
 }
 
 type method struct {
-	name	string;
-	fmt	string;
-	handler	Handler;
+	name    string
+	fmt     string
+	handler Handler
 }
 
 var rpcMethod []method
@@ -53,80 +53,80 @@ var rpcMethod []method
 //	s	string
 //
 func Add(name, fmt string, handler Handler) {
-	n := len(rpcMethod);
+	n := len(rpcMethod)
 	if n >= cap(rpcMethod) {
-		a := make([]method, n, (n+4)*2);
+		a := make([]method, n, (n+4)*2)
 		for i := range a {
 			a[i] = rpcMethod[i]
 		}
-		rpcMethod = a;
+		rpcMethod = a
 	}
-	rpcMethod = rpcMethod[0 : n+1];
-	rpcMethod[n] = method{name, fmt, handler};
+	rpcMethod = rpcMethod[0 : n+1]
+	rpcMethod[n] = method{name, fmt, handler}
 }
 
 // Serve accepts new SRPC connections from the file descriptor fd
 // and answers RPCs issued on those connections.
 // It closes fd and returns an error if the imc_accept system call fails.
 func Serve(fd int) os.Error {
-	defer syscall.Close(fd);
+	defer syscall.Close(fd)
 
 	for {
-		cfd, _, e := syscall.Syscall(syscall.SYS_IMC_ACCEPT, uintptr(fd), 0, 0);
+		cfd, _, e := syscall.Syscall(syscall.SYS_IMC_ACCEPT, uintptr(fd), 0, 0)
 		if e != 0 {
 			return os.NewSyscallError("imc_accept", int(e))
 		}
-		go serveLoop(int(cfd));
+		go serveLoop(int(cfd))
 	}
-	panic("unreachable");
+	panic("unreachable")
 }
 
 func serveLoop(fd int) {
-	c := make(chan *msg);
-	go sendLoop(fd, c);
+	c := make(chan *msg)
+	go sendLoop(fd, c)
 
-	var r msgReceiver;
-	r.fd = fd;
+	var r msgReceiver
+	r.fd = fd
 	for {
-		m, err := r.recv();
+		m, err := r.recv()
 		if err != nil {
 			break
 		}
-		m.unpackRequest();
+		m.unpackRequest()
 		if !m.gotHeader {
-			log.Stderrf("cannot unpack header: %s", m.status);
-			continue;
+			log.Stderrf("cannot unpack header: %s", m.status)
+			continue
 		}
 		// log.Stdoutf("<- %#v", m);
-		m.isReq = false;	// set up for response
-		go serveMsg(m, c);
+		m.isReq = false // set up for response
+		go serveMsg(m, c)
 	}
-	close(c);
+	close(c)
 }
 
 func sendLoop(fd int, c <-chan *msg) {
-	var s msgSender;
-	s.fd = fd;
+	var s msgSender
+	s.fd = fd
 	for m := range c {
 		// log.Stdoutf("-> %#v", m);
-		m.packResponse();
-		s.send(m);
+		m.packResponse()
+		s.send(m)
 	}
-	syscall.Close(fd);
+	syscall.Close(fd)
 }
 
 func serveMsg(m *msg, c chan<- *msg) {
 	if m.status != OK {
-		c <- m;
-		return;
+		c <- m
+		return
 	}
 	if m.rpcNumber >= uint32(len(rpcMethod)) {
-		m.status = ErrBadRPCNumber;
-		c <- m;
-		return;
+		m.status = ErrBadRPCNumber
+		c <- m
+		return
 	}
 
-	meth := &rpcMethod[m.rpcNumber];
+	meth := &rpcMethod[m.rpcNumber]
 	if meth.fmt != m.fmt {
 		switch {
 		case len(m.fmt) < len(meth.fmt):
@@ -137,20 +137,20 @@ func serveMsg(m *msg, c chan<- *msg) {
 			// There's a type mismatch.
 			// It's an in-arg mismatch if the mismatch happens
 			// before the colon; otherwise it's an out-arg mismatch.
-			m.status = ErrInArgTypeMismatch;
+			m.status = ErrInArgTypeMismatch
 			for i := 0; i < len(m.fmt) && m.fmt[i] == meth.fmt[i]; i++ {
 				if m.fmt[i] == ':' {
-					m.status = ErrOutArgTypeMismatch;
-					break;
+					m.status = ErrOutArgTypeMismatch
+					break
 				}
 			}
 		}
-		c <- m;
-		return;
+		c <- m
+		return
 	}
 
-	m.status = meth.handler.Run(m.Arg, m.Ret, m.Size);
-	c <- m;
+	m.status = meth.handler.Run(m.Arg, m.Ret, m.Size)
+	c <- m
 }
 
 // ServeRuntime serves RPCs issued by the Native Client embedded runtime.
@@ -164,19 +164,19 @@ func ServeRuntime() os.Error {
 	// We are running embedded.
 	// The fd returned by getFd is a red herring.
 	// Accept connections on magic fd 3.
-	return Serve(3);
+	return Serve(3)
 }
 
 // getFd runs the srpc_get_fd system call.
 func getFd() (fd int, err os.Error) {
-	r1, _, e := syscall.Syscall(syscall.SYS_SRPC_GET_FD, 0, 0, 0);
-	return int(r1), os.NewSyscallError("srpc_get_fd", int(e));
+	r1, _, e := syscall.Syscall(syscall.SYS_SRPC_GET_FD, 0, 0, 0)
+	return int(r1), os.NewSyscallError("srpc_get_fd", int(e))
 }
 
 // Enabled returns true if SRPC is enabled in the Native Client runtime.
 func Enabled() bool {
-	_, err := getFd();
-	return err == nil;
+	_, err := getFd()
+	return err == nil
 }
 
 // Service #0, service_discovery, returns a list of the other services
@@ -184,18 +184,18 @@ func Enabled() bool {
 type serviceDiscovery struct{}
 
 func (serviceDiscovery) Run(arg, ret []interface{}, size []int) Errno {
-	var b bytes.Buffer;
+	var b bytes.Buffer
 	for _, m := range rpcMethod {
-		b.WriteString(m.name);
-		b.WriteByte(':');
-		b.WriteString(m.fmt);
-		b.WriteByte('\n');
+		b.WriteString(m.name)
+		b.WriteByte(':')
+		b.WriteString(m.fmt)
+		b.WriteByte('\n')
 	}
 	if b.Len() > size[0] {
 		return ErrNoMemory
 	}
-	ret[0] = b.Bytes();
-	return OK;
+	ret[0] = b.Bytes()
+	return OK
 }
 
-func init()	{ Add("service_discovery", ":C", serviceDiscovery{}) }
+func init() { Add("service_discovery", ":C", serviceDiscovery{}) }
diff --git a/src/pkg/exp/ogle/abort.go b/src/pkg/exp/ogle/abort.go
index 7773cac2b5..311a7b38e2 100644
--- a/src/pkg/exp/ogle/abort.go
+++ b/src/pkg/exp/ogle/abort.go
@@ -5,31 +5,31 @@
 package ogle
 
 import (
-	"os";
-	"runtime";
+	"os"
+	"runtime"
 )
 
 // An aborter aborts the thread's current computation, usually
 // passing the error to a waiting thread.
 type aborter interface {
-	Abort(err os.Error);
+	Abort(err os.Error)
 }
 
 type ogleAborter chan os.Error
 
 func (a ogleAborter) Abort(err os.Error) {
-	a <- err;
-	runtime.Goexit();
+	a <- err
+	runtime.Goexit()
 }
 
 // try executes a computation; if the computation Aborts, try returns
 // the error passed to abort.
 func try(f func(a aborter)) os.Error {
-	a := make(ogleAborter);
+	a := make(ogleAborter)
 	go func() {
-		f(a);
-		a <- nil;
-	}();
-	err := <-a;
-	return err;
+		f(a)
+		a <- nil
+	}()
+	err := <-a
+	return err
 }
diff --git a/src/pkg/exp/ogle/arch.go b/src/pkg/exp/ogle/arch.go
index 867ad4ca69..52b1c97572 100644
--- a/src/pkg/exp/ogle/arch.go
+++ b/src/pkg/exp/ogle/arch.go
@@ -5,66 +5,66 @@
 package ogle
 
 import (
-	"debug/proc";
-	"math";
+	"debug/proc"
+	"math"
 )
 
 type Arch interface {
 	// ToWord converts an array of up to 8 bytes in memory order
 	// to a word.
-	ToWord(data []byte) proc.Word;
+	ToWord(data []byte) proc.Word
 	// FromWord converts a word to an array of up to 8 bytes in
 	// memory order.
-	FromWord(v proc.Word, out []byte);
+	FromWord(v proc.Word, out []byte)
 	// ToFloat32 converts a word to a float.  The order of this
 	// word will be the order returned by ToWord on the memory
 	// representation of a float, and thus may require reversing.
-	ToFloat32(bits uint32) float32;
+	ToFloat32(bits uint32) float32
 	// FromFloat32 converts a float to a word.  This should return
 	// a word that can be passed to FromWord to get the memory
 	// representation of a float on this architecture.
-	FromFloat32(f float32) uint32;
+	FromFloat32(f float32) uint32
 	// ToFloat64 is to float64 as ToFloat32 is to float32.
-	ToFloat64(bits uint64) float64;
+	ToFloat64(bits uint64) float64
 	// FromFloat64 is to float64 as FromFloat32 is to float32.
-	FromFloat64(f float64) uint64;
+	FromFloat64(f float64) uint64
 
 	// IntSize returns the number of bytes in an 'int'.
-	IntSize() int;
+	IntSize() int
 	// PtrSize returns the number of bytes in a 'uintptr'.
-	PtrSize() int;
+	PtrSize() int
 	// FloatSize returns the number of bytes in a 'float'.
-	FloatSize() int;
+	FloatSize() int
 	// Align rounds offset up to the appropriate offset for a
 	// basic type with the given width.
-	Align(offset, width int) int;
+	Align(offset, width int) int
 
 	// G returns the current G pointer.
-	G(regs proc.Regs) proc.Word;
+	G(regs proc.Regs) proc.Word
 
 	// ClosureSize returns the number of bytes expected by
 	// ParseClosure.
-	ClosureSize() int;
+	ClosureSize() int
 	// ParseClosure takes ClosureSize bytes read from a return PC
 	// in a remote process, determines if the code is a closure,
 	// and returns the frame size of the closure if it is.
-	ParseClosure(data []byte) (frame int, ok bool);
+	ParseClosure(data []byte) (frame int, ok bool)
 }
 
 type ArchLSB struct{}
 
 func (ArchLSB) ToWord(data []byte) proc.Word {
-	var v proc.Word;
+	var v proc.Word
 	for i, b := range data {
 		v |= proc.Word(b) << (uint(i) * 8)
 	}
-	return v;
+	return v
 }
 
 func (ArchLSB) FromWord(v proc.Word, out []byte) {
 	for i := range out {
-		out[i] = byte(v);
-		v >>= 8;
+		out[i] = byte(v)
+		v >>= 8
 	}
 }
 
@@ -74,11 +74,11 @@ func (ArchLSB) ToFloat32(bits uint32) float32 {
 	return math.Float32frombits(bits)
 }
 
-func (ArchLSB) FromFloat32(f float32) uint32	{ return math.Float32bits(f) }
+func (ArchLSB) FromFloat32(f float32) uint32 { return math.Float32bits(f) }
 
-func (ArchLSB) ToFloat64(bits uint64) float64	{ return math.Float64frombits(bits) }
+func (ArchLSB) ToFloat64(bits uint64) float64 { return math.Float64frombits(bits) }
 
-func (ArchLSB) FromFloat64(f float64) uint64	{ return math.Float64bits(f) }
+func (ArchLSB) FromFloat64(f float64) uint64 { return math.Float64bits(f) }
 
 type ArchAlignedMultiple struct{}
 
@@ -87,39 +87,39 @@ func (ArchAlignedMultiple) Align(offset, width int) int {
 }
 
 type amd64 struct {
-	ArchLSB;
-	ArchAlignedMultiple;
-	gReg	int;
+	ArchLSB
+	ArchAlignedMultiple
+	gReg int
 }
 
-func (a *amd64) IntSize() int	{ return 4 }
+func (a *amd64) IntSize() int { return 4 }
 
-func (a *amd64) PtrSize() int	{ return 8 }
+func (a *amd64) PtrSize() int { return 8 }
 
-func (a *amd64) FloatSize() int	{ return 4 }
+func (a *amd64) FloatSize() int { return 4 }
 
 func (a *amd64) G(regs proc.Regs) proc.Word {
 	// See src/pkg/runtime/mkasmh
 	if a.gReg == -1 {
-		ns := regs.Names();
+		ns := regs.Names()
 		for i, n := range ns {
 			if n == "r15" {
-				a.gReg = i;
-				break;
+				a.gReg = i
+				break
 			}
 		}
 	}
 
-	return regs.Get(a.gReg);
+	return regs.Get(a.gReg)
 }
 
-func (a *amd64) ClosureSize() int	{ return 8 }
+func (a *amd64) ClosureSize() int { return 8 }
 
 func (a *amd64) ParseClosure(data []byte) (int, bool) {
 	if data[0] == 0x48 && data[1] == 0x81 && data[2] == 0xc4 && data[7] == 0xc3 {
 		return int(a.ToWord(data[3:7]) + 8), true
 	}
-	return 0, false;
+	return 0, false
 }
 
 var Amd64 = &amd64{gReg: -1}
diff --git a/src/pkg/exp/ogle/cmd.go b/src/pkg/exp/ogle/cmd.go
index 2e75fe519d..45b47ef5b8 100644
--- a/src/pkg/exp/ogle/cmd.go
+++ b/src/pkg/exp/ogle/cmd.go
@@ -6,52 +6,52 @@
 package ogle
 
 import (
-	"bufio";
-	"debug/elf";
-	"debug/proc";
-	"exp/eval";
-	"fmt";
-	"go/scanner";
-	"go/token";
-	"os";
-	"strconv";
-	"strings";
+	"bufio"
+	"debug/elf"
+	"debug/proc"
+	"exp/eval"
+	"fmt"
+	"go/scanner"
+	"go/token"
+	"os"
+	"strconv"
+	"strings"
 )
 
 var world *eval.World
 var curProc *Process
 
 func Main() {
-	world = eval.NewWorld();
-	defineFuncs();
-	r := bufio.NewReader(os.Stdin);
+	world = eval.NewWorld()
+	defineFuncs()
+	r := bufio.NewReader(os.Stdin)
 	for {
-		print("; ");
-		line, err := r.ReadSlice('\n');
+		print("; ")
+		line, err := r.ReadSlice('\n')
 		if err != nil {
 			break
 		}
 
 		// Try line as a command
-		cmd, rest := getCmd(line);
+		cmd, rest := getCmd(line)
 		if cmd != nil {
-			err := cmd.handler(rest);
+			err := cmd.handler(rest)
 			if err != nil {
 				scanner.PrintError(os.Stderr, err)
 			}
-			continue;
+			continue
 		}
 
 		// Try line as code
-		code, err := world.Compile(string(line));
+		code, err := world.Compile(string(line))
 		if err != nil {
-			scanner.PrintError(os.Stderr, err);
-			continue;
+			scanner.PrintError(os.Stderr, err)
+			continue
 		}
-		v, err := code.Run();
+		v, err := code.Run()
 		if err != nil {
-			fmt.Fprintf(os.Stderr, err.String());
-			continue;
+			fmt.Fprintf(os.Stderr, err.String())
+			continue
 		}
 		if v != nil {
 			println(v.String())
@@ -61,11 +61,11 @@ func Main() {
 
 // newScanner creates a new scanner that scans that given input bytes.
 func newScanner(input []byte) (*scanner.Scanner, *scanner.ErrorVector) {
-	sc := new(scanner.Scanner);
-	ev := new(scanner.ErrorVector);
-	sc.Init("input", input, ev, 0);
+	sc := new(scanner.Scanner)
+	ev := new(scanner.ErrorVector)
+	sc.Init("input", input, ev, 0)
 
-	return sc, ev;
+	return sc, ev
 }
 
 /*
@@ -75,12 +75,12 @@ func newScanner(input []byte) (*scanner.Scanner, *scanner.ErrorVector) {
 // A UsageError occurs when a command is called with illegal arguments.
 type UsageError string
 
-func (e UsageError) String() string	{ return string(e) }
+func (e UsageError) String() string { return string(e) }
 
 // A cmd represents a single command with a handler.
 type cmd struct {
-	cmd	string;
-	handler	func([]byte) os.Error;
+	cmd     string
+	handler func([]byte) os.Error
 }
 
 var cmds = []cmd{
@@ -92,19 +92,19 @@ var cmds = []cmd{
 // successful, it returns the command and the bytes remaining after
 // the command, which should be passed to the command.
 func getCmd(line []byte) (*cmd, []byte) {
-	sc, _ := newScanner(line);
-	pos, tok, lit := sc.Scan();
+	sc, _ := newScanner(line)
+	pos, tok, lit := sc.Scan()
 	if sc.ErrorCount != 0 || tok != token.IDENT {
 		return nil, nil
 	}
 
-	slit := string(lit);
+	slit := string(lit)
 	for i := range cmds {
 		if cmds[i].cmd == slit {
 			return &cmds[i], line[pos.Offset+len(lit):]
 		}
 	}
-	return nil, nil;
+	return nil, nil
 }
 
 // cmdLoad starts or attaches to a process.  Its form is similar to
@@ -124,7 +124,7 @@ func getCmd(line []byte) (*cmd, []byte) {
 //
 // load always sets the current process to the loaded process.
 func cmdLoad(args []byte) os.Error {
-	ident, path, err := parseLoad(args);
+	ident, path, err := parseLoad(args)
 	if err != nil {
 		return err
 	}
@@ -136,99 +136,99 @@ func cmdLoad(args []byte) os.Error {
 	}
 
 	// Parse argument and start or attach to process
-	var fname string;
-	var tproc proc.Process;
+	var fname string
+	var tproc proc.Process
 	if len(path) >= 4 && path[0:4] == "pid:" {
-		pid, err := strconv.Atoi(path[4:]);
+		pid, err := strconv.Atoi(path[4:])
 		if err != nil {
 			return err
 		}
-		fname, err = os.Readlink(fmt.Sprintf("/proc/%d/exe", pid));
+		fname, err = os.Readlink(fmt.Sprintf("/proc/%d/exe", pid))
 		if err != nil {
 			return err
 		}
-		tproc, err = proc.Attach(pid);
+		tproc, err = proc.Attach(pid)
 		if err != nil {
 			return err
 		}
-		println("Attached to", pid);
+		println("Attached to", pid)
 	} else {
-		parts := strings.Split(path, " ", 0);
+		parts := strings.Split(path, " ", 0)
 		if len(parts) == 0 {
 			fname = ""
 		} else {
 			fname = parts[0]
 		}
-		tproc, err = proc.ForkExec(fname, parts, os.Environ(), "", []*os.File{os.Stdin, os.Stdout, os.Stderr});
+		tproc, err = proc.ForkExec(fname, parts, os.Environ(), "", []*os.File{os.Stdin, os.Stdout, os.Stderr})
 		if err != nil {
 			return err
 		}
-		println("Started", path);
+		println("Started", path)
 		// TODO(austin) If we fail after this point, kill tproc
 		// before detaching.
 	}
 
 	// Get symbols
-	f, err := os.Open(fname, os.O_RDONLY, 0);
+	f, err := os.Open(fname, os.O_RDONLY, 0)
 	if err != nil {
-		tproc.Detach();
-		return err;
+		tproc.Detach()
+		return err
 	}
-	defer f.Close();
-	elf, err := elf.NewFile(f);
+	defer f.Close()
+	elf, err := elf.NewFile(f)
 	if err != nil {
-		tproc.Detach();
-		return err;
+		tproc.Detach()
+		return err
 	}
-	curProc, err = NewProcessElf(tproc, elf);
+	curProc, err = NewProcessElf(tproc, elf)
 	if err != nil {
-		tproc.Detach();
-		return err;
+		tproc.Detach()
+		return err
 	}
 
 	// Prepare new process
-	curProc.OnGoroutineCreate().AddHandler(EventPrint);
-	curProc.OnGoroutineExit().AddHandler(EventPrint);
+	curProc.OnGoroutineCreate().AddHandler(EventPrint)
+	curProc.OnGoroutineExit().AddHandler(EventPrint)
 
-	err = curProc.populateWorld(world);
+	err = curProc.populateWorld(world)
 	if err != nil {
-		tproc.Detach();
-		return err;
+		tproc.Detach()
+		return err
 	}
 
-	return nil;
+	return nil
 }
 
 func parseLoad(args []byte) (ident string, path string, err os.Error) {
-	err = UsageError("Usage: load [sym] \"path\"");
-	sc, ev := newScanner(args);
+	err = UsageError("Usage: load [sym] \"path\"")
+	sc, ev := newScanner(args)
 
-	var toks [4]token.Token;
-	var lits [4][]byte;
+	var toks [4]token.Token
+	var lits [4][]byte
 	for i := range toks {
 		_, toks[i], lits[i] = sc.Scan()
 	}
 	if sc.ErrorCount != 0 {
-		err = ev.GetError(scanner.NoMultiples);
-		return;
+		err = ev.GetError(scanner.NoMultiples)
+		return
 	}
 
-	i := 0;
+	i := 0
 	switch toks[i] {
 	case token.PERIOD, token.IDENT:
-		ident = string(lits[i]);
-		i++;
+		ident = string(lits[i])
+		i++
 	}
 
 	if toks[i] != token.STRING {
 		return
 	}
-	path, uerr := strconv.Unquote(string(lits[i]));
+	path, uerr := strconv.Unquote(string(lits[i]))
 	if uerr != nil {
-		err = uerr;
-		return;
+		err = uerr
+		return
 	}
-	i++;
+	i++
 
 	if toks[i] == token.SEMICOLON {
 		i++
@@ -237,13 +237,13 @@ func parseLoad(args []byte) (ident string, path string, err os.Error) {
 		return
 	}
 
-	return ident, path, nil;
+	return ident, path, nil
 }
 
 // cmdBt prints a backtrace for the current goroutine.  It takes no
 // arguments.
 func cmdBt(args []byte) os.Error {
-	err := parseNoArgs(args, "Usage: bt");
+	err := parseNoArgs(args, "Usage: bt")
 	if err != nil {
 		return err
 	}
@@ -252,10 +252,10 @@ func cmdBt(args []byte) os.Error {
 		return NoCurrentGoroutine{}
 	}
 
-	f := curProc.curGoroutine.frame;
+	f := curProc.curGoroutine.frame
 	if f == nil {
-		fmt.Println("No frames on stack");
-		return nil;
+		fmt.Println("No frames on stack")
+		return nil
 	}
 
 	for f.Inner() != nil {
@@ -268,8 +268,8 @@ func cmdBt(args []byte) os.Error {
 		} else {
 			fmt.Printf("   ")
 		}
-		fmt.Printf("%8x %v\n", f.pc, f);
-		f, err = f.Outer();
+		fmt.Printf("%8x %v\n", f.pc, f)
+		f, err = f.Outer()
 		if err != nil {
 			return err
 		}
@@ -278,20 +278,20 @@ func cmdBt(args []byte) os.Error {
 		}
 	}
 
-	fmt.Println("...");
-	return nil;
+	fmt.Println("...")
+	return nil
 }
 
 func parseNoArgs(args []byte, usage string) os.Error {
-	sc, ev := newScanner(args);
-	_, tok, _ := sc.Scan();
+	sc, ev := newScanner(args)
+	_, tok, _ := sc.Scan()
 	if sc.ErrorCount != 0 {
 		return ev.GetError(scanner.NoMultiples)
 	}
 	if tok != token.EOF {
 		return UsageError(usage)
 	}
-	return nil;
+	return nil
 }
 
 /*
@@ -300,12 +300,12 @@ func parseNoArgs(args []byte, usage string) os.Error {
 
 // defineFuncs populates world with the built-in functions.
 func defineFuncs() {
-	t, v := eval.FuncFromNativeTyped(fnOut, fnOutSig);
-	world.DefineConst("Out", t, v);
-	t, v = eval.FuncFromNativeTyped(fnContWait, fnContWaitSig);
-	world.DefineConst("ContWait", t, v);
-	t, v = eval.FuncFromNativeTyped(fnBpSet, fnBpSetSig);
-	world.DefineConst("BpSet", t, v);
+	t, v := eval.FuncFromNativeTyped(fnOut, fnOutSig)
+	world.DefineConst("Out", t, v)
+	t, v = eval.FuncFromNativeTyped(fnContWait, fnContWaitSig)
+	world.DefineConst("ContWait", t, v)
+	t, v = eval.FuncFromNativeTyped(fnBpSet, fnBpSetSig)
+	world.DefineConst("BpSet", t, v)
 }
 
 // printCurFrame prints the current stack frame, as it would appear in
@@ -314,47 +314,47 @@ func printCurFrame() {
 	if curProc == nil || curProc.curGoroutine == nil {
 		return
 	}
-	f := curProc.curGoroutine.frame;
+	f := curProc.curGoroutine.frame
 	if f == nil {
 		return
 	}
-	fmt.Printf("=> %8x %v\n", f.pc, f);
+	fmt.Printf("=> %8x %v\n", f.pc, f)
 }
 
 // fnOut moves the current frame to the caller of the current frame.
-func fnOutSig()	{}
+func fnOutSig() {}
 func fnOut(t *eval.Thread, args []eval.Value, res []eval.Value) {
 	if curProc == nil {
 		t.Abort(NoCurrentGoroutine{})
 	}
-	err := curProc.Out();
+	err := curProc.Out()
 	if err != nil {
 		t.Abort(err)
 	}
 	// TODO(austin) Only in the command form
-	printCurFrame();
+	printCurFrame()
 }
 
 // fnContWait continues the current process and waits for a stopping event.
-func fnContWaitSig()	{}
+func fnContWaitSig() {}
 func fnContWait(t *eval.Thread, args []eval.Value, res []eval.Value) {
 	if curProc == nil {
 		t.Abort(NoCurrentGoroutine{})
 	}
-	err := curProc.ContWait();
+	err := curProc.ContWait()
 	if err != nil {
 		t.Abort(err)
 	}
 	// TODO(austin) Only in the command form
-	ev := curProc.Event();
+	ev := curProc.Event()
 	if ev != nil {
 		fmt.Printf("%v\n", ev)
 	}
-	printCurFrame();
+	printCurFrame()
 }
 
 // fnBpSet sets a breakpoint at the entry to the named function.
-func fnBpSetSig(string)	{}
+func fnBpSetSig(string) {}
 func fnBpSet(t *eval.Thread, args []eval.Value, res []eval.Value) {
 	// TODO(austin) This probably shouldn't take a symbol name.
 	// Perhaps it should take an interface that provides PC's.
@@ -363,10 +363,10 @@ func fnBpSet(t *eval.Thread, args []eval.Value, res []eval.Value) {
 	if curProc == nil {
 		t.Abort(NoCurrentGoroutine{})
 	}
-	name := args[0].(eval.StringValue).Get(t);
-	fn := curProc.syms.LookupFunc(name);
+	name := args[0].(eval.StringValue).Get(t)
+	fn := curProc.syms.LookupFunc(name)
 	if fn == nil {
 		t.Abort(UsageError("no such function " + name))
 	}
-	curProc.OnBreakpoint(proc.Word(fn.Entry)).AddHandler(EventStop);
+	curProc.OnBreakpoint(proc.Word(fn.Entry)).AddHandler(EventStop)
 }
diff --git a/src/pkg/exp/ogle/event.go b/src/pkg/exp/ogle/event.go
index 18f547915f..d7092ded33 100644
--- a/src/pkg/exp/ogle/event.go
+++ b/src/pkg/exp/ogle/event.go
@@ -5,9 +5,9 @@
 package ogle
 
 import (
-	"debug/proc";
-	"fmt";
-	"os";
+	"debug/proc"
+	"fmt"
+	"os"
 )
 
 /*
@@ -32,19 +32,19 @@ type EventHandler func(e Event) (EventAction, os.Error)
 type EventAction int
 
 const (
-	EARemoveSelf	EventAction	= 0x100;
-	EADefault	EventAction	= iota;
-	EAStop;
-	EAContinue;
+	EARemoveSelf EventAction = 0x100
+	EADefault    EventAction = iota
+	EAStop
+	EAContinue
 )
 
 // A EventHook allows event handlers to be added and removed.
 type EventHook interface {
-	AddHandler(EventHandler);
-	RemoveHandler(EventHandler);
-	NumHandler() int;
-	handle(e Event) (EventAction, os.Error);
-	String() string;
+	AddHandler(EventHandler)
+	RemoveHandler(EventHandler)
+	NumHandler() int
+	handle(e Event) (EventAction, os.Error)
+	String() string
 }
 
 // EventHook is almost, but not quite, suitable for user-defined
@@ -53,26 +53,26 @@ type EventHook interface {
 // provide a public interface for posting events to hooks.
 
 type Event interface {
-	Process() *Process;
-	Goroutine() *Goroutine;
-	String() string;
+	Process() *Process
+	Goroutine() *Goroutine
+	String() string
 }
 
 type commonHook struct {
 	// Head of handler chain
-	head	*handler;
+	head *handler
 	// Number of non-internal handlers
-	len	int;
+	len int
 }
 
 type handler struct {
-	eh	EventHandler;
+	eh EventHandler
 	// True if this handler must be run before user-defined
 	// handlers in order to ensure correctness.
-	internal	bool;
+	internal bool
 	// True if this handler has been removed from the chain.
-	removed	bool;
-	next	*handler;
+	removed bool
+	next    *handler
 }
 
 func (h *commonHook) AddHandler(eh EventHandler) {
@@ -81,56 +81,56 @@ func (h *commonHook) AddHandler(eh EventHandler) {
 
 func (h *commonHook) addHandler(eh EventHandler, internal bool) {
 	// Ensure uniqueness of handlers
-	h.RemoveHandler(eh);
+	h.RemoveHandler(eh)
 
 	if !internal {
 		h.len++
 	}
 	// Add internal handlers to the beginning
 	if internal || h.head == nil {
-		h.head = &handler{eh, internal, false, h.head};
-		return;
+		h.head = &handler{eh, internal, false, h.head}
+		return
 	}
 	// Add handler after internal handlers
 	// TODO(austin) This should probably go on the end instead
-	prev := h.head;
+	prev := h.head
 	for prev.next != nil && prev.internal {
 		prev = prev.next
 	}
-	prev.next = &handler{eh, internal, false, prev.next};
+	prev.next = &handler{eh, internal, false, prev.next}
 }
 
 func (h *commonHook) RemoveHandler(eh EventHandler) {
-	plink := &h.head;
+	plink := &h.head
 	for l := *plink; l != nil; plink, l = &l.next, l.next {
 		if l.eh == eh {
 			if !l.internal {
 				h.len--
 			}
-			l.removed = true;
-			*plink = l.next;
-			break;
+			l.removed = true
+			*plink = l.next
+			break
 		}
 	}
 }
 
-func (h *commonHook) NumHandler() int	{ return h.len }
+func (h *commonHook) NumHandler() int { return h.len }
 
 func (h *commonHook) handle(e Event) (EventAction, os.Error) {
-	action := EADefault;
-	plink := &h.head;
+	action := EADefault
+	plink := &h.head
 	for l := *plink; l != nil; plink, l = &l.next, l.next {
 		if l.removed {
 			continue
 		}
-		a, err := l.eh(e);
+		a, err := l.eh(e)
 		if a&EARemoveSelf == EARemoveSelf {
 			if !l.internal {
 				h.len--
 			}
-			l.removed = true;
-			*plink = l.next;
-			a &^= EARemoveSelf;
+			l.removed = true
+			*plink = l.next
+			a &^= EARemoveSelf
 		}
 		if err != nil {
 			return EAStop, err
@@ -139,19 +139,19 @@ func (h *commonHook) handle(e Event) (EventAction, os.Error) {
 			action = a
 		}
 	}
-	return action, nil;
+	return action, nil
 }
 
 type commonEvent struct {
 	// The process of this event
-	p	*Process;
+	p *Process
 	// The goroutine of this event.
-	t	*Goroutine;
+	t *Goroutine
 }
 
-func (e *commonEvent) Process() *Process	{ return e.p }
+func (e *commonEvent) Process() *Process { return e.p }
 
-func (e *commonEvent) Goroutine() *Goroutine	{ return e.t }
+func (e *commonEvent) Goroutine() *Goroutine { return e.t }
 
 /*
  * Standard event handlers
@@ -161,8 +161,8 @@ func (e *commonEvent) Goroutine() *Goroutine	{ return e.t }
 // occur.  It will not cause the process to stop.
 func EventPrint(ev Event) (EventAction, os.Error) {
 	// TODO(austin) Include process name here?
-	fmt.Fprintf(os.Stderr, "*** %v\n", ev.String());
-	return EADefault, nil;
+	fmt.Fprintf(os.Stderr, "*** %v\n", ev.String())
+	return EADefault, nil
 }
 
 // EventStop is a standard event handler that causes the process to stop.
@@ -175,18 +175,18 @@ func EventStop(ev Event) (EventAction, os.Error) {
  */
 
 type breakpointHook struct {
-	commonHook;
-	p	*Process;
-	pc	proc.Word;
+	commonHook
+	p  *Process
+	pc proc.Word
 }
 
 // A Breakpoint event occurs when a process reaches a particular
 // program counter.  When this event is handled, the current goroutine
 // will be the goroutine that reached the program counter.
 type Breakpoint struct {
-	commonEvent;
-	osThread	proc.Thread;
-	pc		proc.Word;
+	commonEvent
+	osThread proc.Thread
+	pc       proc.Word
 }
 
 func (h *breakpointHook) AddHandler(eh EventHandler) {
@@ -200,20 +200,20 @@ func (h *breakpointHook) addHandler(eh EventHandler, internal bool) {
 	if cur, ok := h.p.breakpointHooks[h.pc]; ok {
 		h = cur
 	}
-	oldhead := h.head;
-	h.commonHook.addHandler(eh, internal);
+	oldhead := h.head
+	h.commonHook.addHandler(eh, internal)
 	if oldhead == nil && h.head != nil {
-		h.p.proc.AddBreakpoint(h.pc);
-		h.p.breakpointHooks[h.pc] = h;
+		h.p.proc.AddBreakpoint(h.pc)
+		h.p.breakpointHooks[h.pc] = h
 	}
 }
 
 func (h *breakpointHook) RemoveHandler(eh EventHandler) {
-	oldhead := h.head;
-	h.commonHook.RemoveHandler(eh);
+	oldhead := h.head
+	h.commonHook.RemoveHandler(eh)
 	if oldhead != nil && h.head == nil {
-		h.p.proc.RemoveBreakpoint(h.pc);
-		h.p.breakpointHooks[h.pc] = nil, false;
+		h.p.proc.RemoveBreakpoint(h.pc)
+		h.p.breakpointHooks[h.pc] = nil, false
 	}
 }
 
@@ -223,7 +223,7 @@ func (h *breakpointHook) String() string {
 	return fmt.Sprintf("breakpoint at %#x", h.pc)
 }
 
-func (b *Breakpoint) PC() proc.Word	{ return b.pc }
+func (b *Breakpoint) PC() proc.Word { return b.pc }
 
 func (b *Breakpoint) String() string {
 	// TODO(austin) Include process name and goroutine
@@ -236,40 +236,40 @@ func (b *Breakpoint) String() string {
  */
 
 type goroutineCreateHook struct {
-	commonHook;
+	commonHook
 }
 
-func (h *goroutineCreateHook) String() string	{ return "goroutine create" }
+func (h *goroutineCreateHook) String() string { return "goroutine create" }
 
 // A GoroutineCreate event occurs when a process creates a new
 // goroutine.  When this event is handled, the current goroutine will
 // be the newly created goroutine.
 type GoroutineCreate struct {
-	commonEvent;
-	parent	*Goroutine;
+	commonEvent
+	parent *Goroutine
 }
 
 // Parent returns the goroutine that created this goroutine.  May be
 // nil if this event is the creation of the first goroutine.
-func (e *GoroutineCreate) Parent() *Goroutine	{ return e.parent }
+func (e *GoroutineCreate) Parent() *Goroutine { return e.parent }
 
 func (e *GoroutineCreate) String() string {
 	// TODO(austin) Include process name
 	if e.parent == nil {
 		return fmt.Sprintf("%v created", e.t)
 	}
-	return fmt.Sprintf("%v created by %v", e.t, e.parent);
+	return fmt.Sprintf("%v created by %v", e.t, e.parent)
 }
 
 type goroutineExitHook struct {
-	commonHook;
+	commonHook
 }
 
-func (h *goroutineExitHook) String() string	{ return "goroutine exit" }
+func (h *goroutineExitHook) String() string { return "goroutine exit" }
 
 // A GoroutineExit event occurs when a Go goroutine exits.
 type GoroutineExit struct {
-	commonEvent;
+	commonEvent
 }
 
 func (e *GoroutineExit) String() string {
diff --git a/src/pkg/exp/ogle/frame.go b/src/pkg/exp/ogle/frame.go
index 6c93f27c71..1538362bad 100644
--- a/src/pkg/exp/ogle/frame.go
+++ b/src/pkg/exp/ogle/frame.go
@@ -5,10 +5,10 @@
 package ogle
 
 import (
-	"debug/gosym";
-	"debug/proc";
-	"fmt";
-	"os";
+	"debug/gosym"
+	"debug/proc"
+	"fmt"
+	"os"
 )
 
 // A Frame represents a single frame on a remote call stack.
@@ -16,30 +16,30 @@ type Frame struct {
 	// pc is the PC of the next instruction that will execute in
 	// this frame.  For lower frames, this is the instruction
 	// following the CALL instruction.
-	pc, sp, fp	proc.Word;
+	pc, sp, fp proc.Word
 	// The runtime.Stktop of the active stack segment
-	stk	remoteStruct;
+	stk remoteStruct
 	// The function this stack frame is in
-	fn	*gosym.Func;
+	fn *gosym.Func
 	// The path and line of the CALL or current instruction.  Note
 	// that this differs slightly from the meaning of Frame.pc.
-	path	string;
-	line	int;
+	path string
+	line int
 	// The inner and outer frames of this frame.  outer is filled
 	// in lazily.
-	inner, outer	*Frame;
+	inner, outer *Frame
 }
 
 // newFrame returns the top-most Frame of the given g's thread.
 func newFrame(g remoteStruct) (*Frame, os.Error) {
-	var f *Frame;
-	err := try(func(a aborter) { f = aNewFrame(a, g) });
-	return f, err;
+	var f *Frame
+	err := try(func(a aborter) { f = aNewFrame(a, g) })
+	return f, err
 }
 
 func aNewFrame(a aborter, g remoteStruct) *Frame {
-	p := g.r.p;
-	var pc, sp proc.Word;
+	p := g.r.p
+	var pc, sp proc.Word
 
 	// Is this G alive?
 	switch g.field(p.f.G.Status).(remoteInt).aGet(a) {
@@ -54,39 +54,39 @@ func aNewFrame(a aborter, g remoteStruct) *Frame {
 	// is difficult because the state isn't updated atomically
 	// with scheduling changes.
 	for _, t := range p.proc.Threads() {
-		regs, err := t.Regs();
+		regs, err := t.Regs()
 		if err != nil {
 			// TODO(austin) What to do?
 			continue
 		}
-		thisg := p.G(regs);
+		thisg := p.G(regs)
 		if thisg == g.addr().base {
 			// Found this G's OS thread
-			pc = regs.PC();
-			sp = regs.SP();
+			pc = regs.PC()
+			sp = regs.SP()
 
 			// If this thread crashed, try to recover it
 			if pc == 0 {
-				pc = p.peekUintptr(a, pc);
-				sp += 8;
+				pc = p.peekUintptr(a, pc)
+				sp += 8
 			}
 
-			break;
+			break
 		}
 	}
 
 	if pc == 0 && sp == 0 {
 		// G is not mapped to an OS thread.  Use the
 		// scheduler's stored PC and SP.
-		sched := g.field(p.f.G.Sched).(remoteStruct);
-		pc = proc.Word(sched.field(p.f.Gobuf.Pc).(remoteUint).aGet(a));
-		sp = proc.Word(sched.field(p.f.Gobuf.Sp).(remoteUint).aGet(a));
+		sched := g.field(p.f.G.Sched).(remoteStruct)
+		pc = proc.Word(sched.field(p.f.Gobuf.Pc).(remoteUint).aGet(a))
+		sp = proc.Word(sched.field(p.f.Gobuf.Sp).(remoteUint).aGet(a))
 	}
 
 	// Get Stktop
-	stk := g.field(p.f.G.Stackbase).(remotePtr).aGet(a).(remoteStruct);
+	stk := g.field(p.f.G.Stackbase).(remotePtr).aGet(a).(remoteStruct)
 
-	return prepareFrame(a, pc, sp, stk, nil);
+	return prepareFrame(a, pc, sp, stk, nil)
 }
 
 // prepareFrame creates a Frame from the PC and SP within that frame,
@@ -94,47 +94,47 @@ func aNewFrame(a aborter, g remoteStruct) *Frame {
 // traversing stack breaks and unwinding closures.
 func prepareFrame(a aborter, pc, sp proc.Word, stk remoteStruct, inner *Frame) *Frame {
 	// Based on src/pkg/runtime/amd64/traceback.c:traceback
-	p := stk.r.p;
-	top := inner == nil;
+	p := stk.r.p
+	top := inner == nil
 
 	// Get function
-	var path string;
-	var line int;
-	var fn *gosym.Func;
+	var path string
+	var line int
+	var fn *gosym.Func
 
 	for i := 0; i < 100; i++ {
 		// Traverse segmented stack breaks
 		if p.sys.lessstack != nil && pc == proc.Word(p.sys.lessstack.Value) {
 			// Get stk->gobuf.pc
-			pc = proc.Word(stk.field(p.f.Stktop.Gobuf).(remoteStruct).field(p.f.Gobuf.Pc).(remoteUint).aGet(a));
+			pc = proc.Word(stk.field(p.f.Stktop.Gobuf).(remoteStruct).field(p.f.Gobuf.Pc).(remoteUint).aGet(a))
 			// Get stk->gobuf.sp
-			sp = proc.Word(stk.field(p.f.Stktop.Gobuf).(remoteStruct).field(p.f.Gobuf.Sp).(remoteUint).aGet(a));
+			sp = proc.Word(stk.field(p.f.Stktop.Gobuf).(remoteStruct).field(p.f.Gobuf.Sp).(remoteUint).aGet(a))
 			// Get stk->stackbase
-			stk = stk.field(p.f.Stktop.Stackbase).(remotePtr).aGet(a).(remoteStruct);
-			continue;
+			stk = stk.field(p.f.Stktop.Stackbase).(remotePtr).aGet(a).(remoteStruct)
+			continue
 		}
 
 		// Get the PC of the call instruction
-		callpc := pc;
+		callpc := pc
 		if !top && (p.sys.goexit == nil || pc != proc.Word(p.sys.goexit.Value)) {
 			callpc--
 		}
 
 		// Look up function
-		path, line, fn = p.syms.PCToLine(uint64(callpc));
+		path, line, fn = p.syms.PCToLine(uint64(callpc))
 		if fn != nil {
 			break
 		}
 
 		// Closure?
-		var buf = make([]byte, p.ClosureSize());
+		var buf = make([]byte, p.ClosureSize())
 		if _, err := p.Peek(pc, buf); err != nil {
 			break
 		}
-		spdelta, ok := p.ParseClosure(buf);
+		spdelta, ok := p.ParseClosure(buf)
 		if ok {
-			sp += proc.Word(spdelta);
-			pc = p.peekUintptr(a, sp-proc.Word(p.PtrSize()));
+			sp += proc.Word(spdelta)
+			pc = p.peekUintptr(a, sp-proc.Word(p.PtrSize()))
 		}
 	}
 	if fn == nil {
@@ -142,7 +142,7 @@ func prepareFrame(a aborter, pc, sp proc.Word, stk remoteStruct, inner *Frame) *
 	}
 
 	// Compute frame pointer
-	var fp proc.Word;
+	var fp proc.Word
 	if fn.FrameSize < p.PtrSize() {
 		fp = sp + proc.Word(p.PtrSize())
 	} else {
@@ -160,15 +160,15 @@ func prepareFrame(a aborter, pc, sp proc.Word, stk remoteStruct, inner *Frame) *
 		fp -= proc.Word(fn.FrameSize - p.PtrSize())
 	}
 
-	return &Frame{pc, sp, fp, stk, fn, path, line, inner, nil};
+	return &Frame{pc, sp, fp, stk, fn, path, line, inner, nil}
 }
 
 // Outer returns the Frame that called this Frame, or nil if this is
 // the outermost frame.
 func (f *Frame) Outer() (*Frame, os.Error) {
-	var fr *Frame;
-	err := try(func(a aborter) { fr = f.aOuter(a) });
-	return fr, err;
+	var fr *Frame
+	err := try(func(a aborter) { fr = f.aOuter(a) })
+	return fr, err
 }
 
 func (f *Frame) aOuter(a aborter) *Frame {
@@ -177,9 +177,9 @@ func (f *Frame) aOuter(a aborter) *Frame {
 		return f.outer
 	}
 
-	p := f.stk.r.p;
+	p := f.stk.r.p
 
-	sp := f.fp;
+	sp := f.fp
 	if f.fn == p.sys.newproc && f.fn == p.sys.deferproc {
 		// TODO(rsc) The compiler inserts two push/pop's
 		// around calls to go and defer.  Russ says this
@@ -188,25 +188,25 @@ func (f *Frame) aOuter(a aborter) *Frame {
 		sp += proc.Word(2 * p.PtrSize())
 	}
 
-	pc := p.peekUintptr(a, f.fp-proc.Word(p.PtrSize()));
+	pc := p.peekUintptr(a, f.fp-proc.Word(p.PtrSize()))
 	if pc < 0x1000 {
 		return nil
 	}
 
 	// TODO(austin) Register this frame for shoot-down.
 
-	f.outer = prepareFrame(a, pc, sp, f.stk, f);
-	return f.outer;
+	f.outer = prepareFrame(a, pc, sp, f.stk, f)
+	return f.outer
 }
 
 // Inner returns the Frame called by this Frame, or nil if this is the
 // innermost frame.
-func (f *Frame) Inner() *Frame	{ return f.inner }
+func (f *Frame) Inner() *Frame { return f.inner }
 
 func (f *Frame) String() string {
-	res := f.fn.Name;
+	res := f.fn.Name
 	if f.pc > proc.Word(f.fn.Value) {
 		res += fmt.Sprintf("+%#x", f.pc-proc.Word(f.fn.Entry))
 	}
-	return res + fmt.Sprintf(" %s:%d", f.path, f.line);
+	return res + fmt.Sprintf(" %s:%d", f.path, f.line)
 }
diff --git a/src/pkg/exp/ogle/goroutine.go b/src/pkg/exp/ogle/goroutine.go
index 0c0075249a..5104ec6d47 100644
--- a/src/pkg/exp/ogle/goroutine.go
+++ b/src/pkg/exp/ogle/goroutine.go
@@ -5,17 +5,17 @@
 package ogle
 
 import (
-	"debug/proc";
-	"exp/eval";
-	"fmt";
-	"os";
+	"debug/proc"
+	"exp/eval"
+	"fmt"
+	"os"
 )
 
 // A Goroutine represents a goroutine in a remote process.
 type Goroutine struct {
-	g	remoteStruct;
-	frame	*Frame;
-	dead	bool;
+	g     remoteStruct
+	frame *Frame
+	dead  bool
 }
 
 func (t *Goroutine) String() string {
@@ -24,94 +24,94 @@ func (t *Goroutine) String() string {
 	}
 	// TODO(austin) Give threads friendly ID's, possibly including
 	// the name of the entry function.
-	return fmt.Sprintf("thread %#x", t.g.addr().base);
+	return fmt.Sprintf("thread %#x", t.g.addr().base)
 }
 
 // isG0 returns true if this thread if the internal idle thread
-func (t *Goroutine) isG0() bool	{ return t.g.addr().base == t.g.r.p.sys.g0.addr().base }
+func (t *Goroutine) isG0() bool { return t.g.addr().base == t.g.r.p.sys.g0.addr().base }
 
 func (t *Goroutine) resetFrame() (err os.Error) {
 	// TODO(austin) Reuse any live part of the current frame stack
 	// so existing references to Frame's keep working.
-	t.frame, err = newFrame(t.g);
-	return;
+	t.frame, err = newFrame(t.g)
+	return
 }
 
 // Out selects the caller frame of the current frame.
 func (t *Goroutine) Out() os.Error {
-	f, err := t.frame.Outer();
+	f, err := t.frame.Outer()
 	if f != nil {
 		t.frame = f
 	}
-	return err;
+	return err
 }
 
 // In selects the frame called by the current frame.
 func (t *Goroutine) In() os.Error {
-	f := t.frame.Inner();
+	f := t.frame.Inner()
 	if f != nil {
 		t.frame = f
 	}
-	return nil;
+	return nil
 }
 
 func readylockedBP(ev Event) (EventAction, os.Error) {
-	b := ev.(*Breakpoint);
-	p := b.Process();
+	b := ev.(*Breakpoint)
+	p := b.Process()
 
 	// The new g is the only argument to this function, so the
 	// stack will have the return address, then the G*.
-	regs, err := b.osThread.Regs();
+	regs, err := b.osThread.Regs()
 	if err != nil {
 		return EAStop, err
 	}
-	sp := regs.SP();
-	addr := sp + proc.Word(p.PtrSize());
-	arg := remotePtr{remote{addr, p}, p.runtime.G};
-	var gp eval.Value;
-	err = try(func(a aborter) { gp = arg.aGet(a) });
+	sp := regs.SP()
+	addr := sp + proc.Word(p.PtrSize())
+	arg := remotePtr{remote{addr, p}, p.runtime.G}
+	var gp eval.Value
+	err = try(func(a aborter) { gp = arg.aGet(a) })
 	if err != nil {
 		return EAStop, err
 	}
 	if gp == nil {
 		return EAStop, UnknownGoroutine{b.osThread, 0}
 	}
-	gs := gp.(remoteStruct);
-	g := &Goroutine{gs, nil, false};
-	p.goroutines[gs.addr().base] = g;
+	gs := gp.(remoteStruct)
+	g := &Goroutine{gs, nil, false}
+	p.goroutines[gs.addr().base] = g
 
 	// Enqueue goroutine creation event
-	parent := b.Goroutine();
+	parent := b.Goroutine()
 	if parent.isG0() {
 		parent = nil
 	}
-	p.postEvent(&GoroutineCreate{commonEvent{p, g}, parent});
+	p.postEvent(&GoroutineCreate{commonEvent{p, g}, parent})
 
 	// If we don't have any thread selected, select this one
 	if p.curGoroutine == nil {
 		p.curGoroutine = g
 	}
 
-	return EADefault, nil;
+	return EADefault, nil
 }
 
 func goexitBP(ev Event) (EventAction, os.Error) {
-	b := ev.(*Breakpoint);
-	p := b.Process();
+	b := ev.(*Breakpoint)
+	p := b.Process()
 
-	g := b.Goroutine();
-	g.dead = true;
+	g := b.Goroutine()
+	g.dead = true
 
-	addr := g.g.addr().base;
-	p.goroutines[addr] = nil, false;
+	addr := g.g.addr().base
+	p.goroutines[addr] = nil, false
 
 	// Enqueue thread exit event
-	p.postEvent(&GoroutineExit{commonEvent{p, g}});
+	p.postEvent(&GoroutineExit{commonEvent{p, g}})
 
 	// If we just exited our selected goroutine, selected another
 	if p.curGoroutine == g {
 		p.selectSomeGoroutine()
 	}
 
-	return EADefault, nil;
+	return EADefault, nil
 }
diff --git a/src/pkg/exp/ogle/main.go b/src/pkg/exp/ogle/main.go
index 39e0029781..1999ecccab 100644
--- a/src/pkg/exp/ogle/main.go
+++ b/src/pkg/exp/ogle/main.go
@@ -6,4 +6,4 @@ package main
 
 import "exp/ogle"
 
-func main()	{ ogle.Main() }
+func main() { ogle.Main() }
diff --git a/src/pkg/exp/ogle/process.go b/src/pkg/exp/ogle/process.go
index efe3c4da4a..63f42a9d4a 100644
--- a/src/pkg/exp/ogle/process.go
+++ b/src/pkg/exp/ogle/process.go
@@ -5,14 +5,14 @@
 package ogle
 
 import (
-	"debug/elf";
-	"debug/gosym";
-	"debug/proc";
-	"exp/eval";
-	"fmt";
-	"log";
-	"os";
-	"reflect";
+	"debug/elf"
+	"debug/gosym"
+	"debug/proc"
+	"exp/eval"
+	"fmt"
+	"log"
+	"os"
+	"reflect"
 )
 
 // A FormatError indicates a failure to process information in or
@@ -20,7 +20,7 @@ import (
 // in the object file or runtime structures.
 type FormatError string
 
-func (e FormatError) String() string	{ return string(e) }
+func (e FormatError) String() string { return string(e) }
 
 // An UnknownArchitecture occurs when trying to load an object file
 // that indicates an architecture not supported by the debugger.
@@ -34,13 +34,13 @@ func (e UnknownArchitecture) String() string {
 // memory or registers of a process that is not stopped.
 type ProcessNotStopped struct{}
 
-func (e ProcessNotStopped) String() string	{ return "process not stopped" }
+func (e ProcessNotStopped) String() string { return "process not stopped" }
 
 // An UnknownGoroutine error is an internal error representing an
 // unrecognized G structure pointer.
 type UnknownGoroutine struct {
-	OSThread	proc.Thread;
-	Goroutine	proc.Word;
+	OSThread  proc.Thread
+	Goroutine proc.Word
 }
 
 func (e UnknownGoroutine) String() string {
@@ -52,50 +52,50 @@ func (e UnknownGoroutine) String() string {
 // process).
 type NoCurrentGoroutine struct{}
 
-func (e NoCurrentGoroutine) String() string	{ return "no current goroutine" }
+func (e NoCurrentGoroutine) String() string { return "no current goroutine" }
 
 // A Process represents a remote attached process.
 type Process struct {
-	Arch;
-	proc	proc.Process;
+	Arch
+	proc proc.Process
 
 	// The symbol table of this process
-	syms	*gosym.Table;
+	syms *gosym.Table
 
 	// A possibly-stopped OS thread, or nil
-	threadCache	proc.Thread;
+	threadCache proc.Thread
 
 	// Types parsed from the remote process
-	types	map[proc.Word]*remoteType;
+	types map[proc.Word]*remoteType
 
 	// Types and values from the remote runtime package
-	runtime	runtimeValues;
+	runtime runtimeValues
 
 	// Runtime field indexes
-	f	runtimeIndexes;
+	f runtimeIndexes
 
 	// Globals from the sys package (or from no package)
-	sys	struct {
-		lessstack, goexit, newproc, deferproc, newprocreadylocked	*gosym.Func;
-		allg								remotePtr;
-		g0								remoteStruct;
-	};
+	sys struct {
+		lessstack, goexit, newproc, deferproc, newprocreadylocked *gosym.Func
+		allg                                                      remotePtr
+		g0                                                        remoteStruct
+	}
 
 	// Event queue
-	posted	[]Event;
-	pending	[]Event;
-	event	Event;
+	posted  []Event
+	pending []Event
+	event   Event
 
 	// Event hooks
-	breakpointHooks		map[proc.Word]*breakpointHook;
-	goroutineCreateHook	*goroutineCreateHook;
-	goroutineExitHook	*goroutineExitHook;
+	breakpointHooks     map[proc.Word]*breakpointHook
+	goroutineCreateHook *goroutineCreateHook
+	goroutineExitHook   *goroutineExitHook
 
 	// Current goroutine, or nil if there are no goroutines
-	curGoroutine	*Goroutine;
+	curGoroutine *Goroutine
 
 	// Goroutines by the address of their G structure
-	goroutines	map[proc.Word]*Goroutine;
+	goroutines map[proc.Word]*Goroutine
 }
 
 /*
@@ -114,10 +114,10 @@ func NewProcess(tproc proc.Process, arch Arch, syms *gosym.Table) (*Process, os.
 		goroutineCreateHook: new(goroutineCreateHook),
 		goroutineExitHook: new(goroutineExitHook),
 		goroutines: make(map[proc.Word]*Goroutine),
-	};
+	}
 
 	// Fill in remote runtime
-	p.bootstrap();
+	p.bootstrap()
 
 	switch {
 	case p.sys.allg.addr().base == 0:
@@ -131,127 +131,127 @@ func NewProcess(tproc proc.Process, arch Arch, syms *gosym.Table) (*Process, os.
 	}
 
 	// Get current goroutines
-	p.goroutines[p.sys.g0.addr().base] = &Goroutine{p.sys.g0, nil, false};
+	p.goroutines[p.sys.g0.addr().base] = &Goroutine{p.sys.g0, nil, false}
 	err := try(func(a aborter) {
-		g := p.sys.allg.aGet(a);
+		g := p.sys.allg.aGet(a)
 		for g != nil {
-			gs := g.(remoteStruct);
-			fmt.Printf("*** Found goroutine at %#x\n", gs.addr().base);
-			p.goroutines[gs.addr().base] = &Goroutine{gs, nil, false};
-			g = gs.field(p.f.G.Alllink).(remotePtr).aGet(a);
+			gs := g.(remoteStruct)
+			fmt.Printf("*** Found goroutine at %#x\n", gs.addr().base)
+			p.goroutines[gs.addr().base] = &Goroutine{gs, nil, false}
+			g = gs.field(p.f.G.Alllink).(remotePtr).aGet(a)
 		}
-	});
+	})
 	if err != nil {
 		return nil, err
 	}
 
 	// Create internal breakpoints to catch new and exited goroutines
-	p.OnBreakpoint(proc.Word(p.sys.newprocreadylocked.Entry)).(*breakpointHook).addHandler(readylockedBP, true);
-	p.OnBreakpoint(proc.Word(p.sys.goexit.Entry)).(*breakpointHook).addHandler(goexitBP, true);
+	p.OnBreakpoint(proc.Word(p.sys.newprocreadylocked.Entry)).(*breakpointHook).addHandler(readylockedBP, true)
+	p.OnBreakpoint(proc.Word(p.sys.goexit.Entry)).(*breakpointHook).addHandler(goexitBP, true)
 
 	// Select current frames
 	for _, g := range p.goroutines {
 		g.resetFrame()
 	}
 
-	p.selectSomeGoroutine();
+	p.selectSomeGoroutine()
 
-	return p, nil;
+	return p, nil
 }
 
 func elfGoSyms(f *elf.File) (*gosym.Table, os.Error) {
-	text := f.Section(".text");
-	symtab := f.Section(".gosymtab");
-	pclntab := f.Section(".gopclntab");
+	text := f.Section(".text")
+	symtab := f.Section(".gosymtab")
+	pclntab := f.Section(".gopclntab")
 	if text == nil || symtab == nil || pclntab == nil {
 		return nil, nil
 	}
 
-	symdat, err := symtab.Data();
+	symdat, err := symtab.Data()
 	if err != nil {
 		return nil, err
 	}
-	pclndat, err := pclntab.Data();
+	pclndat, err := pclntab.Data()
 	if err != nil {
 		return nil, err
 	}
 
-	pcln := gosym.NewLineTable(pclndat, text.Addr);
-	tab, err := gosym.NewTable(symdat, pcln);
+	pcln := gosym.NewLineTable(pclndat, text.Addr)
+	tab, err := gosym.NewTable(symdat, pcln)
 	if err != nil {
 		return nil, err
 	}
 
-	return tab, nil;
+	return tab, nil
 }
 
 // NewProcessElf constructs a new remote process around a traced
 // process and the process' ELF object.
 func NewProcessElf(tproc proc.Process, f *elf.File) (*Process, os.Error) {
-	syms, err := elfGoSyms(f);
+	syms, err := elfGoSyms(f)
 	if err != nil {
 		return nil, err
 	}
 	if syms == nil {
 		return nil, FormatError("Failed to find symbol table")
 	}
-	var arch Arch;
+	var arch Arch
 	switch f.Machine {
 	case elf.EM_X86_64:
 		arch = Amd64
 	default:
 		return nil, UnknownArchitecture(f.Machine)
 	}
-	return NewProcess(tproc, arch, syms);
+	return NewProcess(tproc, arch, syms)
 }
 
 // bootstrap constructs the runtime structure of a remote process.
 func (p *Process) bootstrap() {
 	// Manually construct runtime types
-	p.runtime.String = newManualType(eval.TypeOfNative(rt1String{}), p.Arch);
-	p.runtime.Slice = newManualType(eval.TypeOfNative(rt1Slice{}), p.Arch);
-	p.runtime.Eface = newManualType(eval.TypeOfNative(rt1Eface{}), p.Arch);
-
-	p.runtime.Type = newManualType(eval.TypeOfNative(rt1Type{}), p.Arch);
-	p.runtime.CommonType = newManualType(eval.TypeOfNative(rt1CommonType{}), p.Arch);
-	p.runtime.UncommonType = newManualType(eval.TypeOfNative(rt1UncommonType{}), p.Arch);
-	p.runtime.StructField = newManualType(eval.TypeOfNative(rt1StructField{}), p.Arch);
-	p.runtime.StructType = newManualType(eval.TypeOfNative(rt1StructType{}), p.Arch);
-	p.runtime.PtrType = newManualType(eval.TypeOfNative(rt1PtrType{}), p.Arch);
-	p.runtime.ArrayType = newManualType(eval.TypeOfNative(rt1ArrayType{}), p.Arch);
-	p.runtime.SliceType = newManualType(eval.TypeOfNative(rt1SliceType{}), p.Arch);
-
-	p.runtime.Stktop = newManualType(eval.TypeOfNative(rt1Stktop{}), p.Arch);
-	p.runtime.Gobuf = newManualType(eval.TypeOfNative(rt1Gobuf{}), p.Arch);
-	p.runtime.G = newManualType(eval.TypeOfNative(rt1G{}), p.Arch);
+	p.runtime.String = newManualType(eval.TypeOfNative(rt1String{}), p.Arch)
+	p.runtime.Slice = newManualType(eval.TypeOfNative(rt1Slice{}), p.Arch)
+	p.runtime.Eface = newManualType(eval.TypeOfNative(rt1Eface{}), p.Arch)
+
+	p.runtime.Type = newManualType(eval.TypeOfNative(rt1Type{}), p.Arch)
+	p.runtime.CommonType = newManualType(eval.TypeOfNative(rt1CommonType{}), p.Arch)
+	p.runtime.UncommonType = newManualType(eval.TypeOfNative(rt1UncommonType{}), p.Arch)
+	p.runtime.StructField = newManualType(eval.TypeOfNative(rt1StructField{}), p.Arch)
+	p.runtime.StructType = newManualType(eval.TypeOfNative(rt1StructType{}), p.Arch)
+	p.runtime.PtrType = newManualType(eval.TypeOfNative(rt1PtrType{}), p.Arch)
+	p.runtime.ArrayType = newManualType(eval.TypeOfNative(rt1ArrayType{}), p.Arch)
+	p.runtime.SliceType = newManualType(eval.TypeOfNative(rt1SliceType{}), p.Arch)
+
+	p.runtime.Stktop = newManualType(eval.TypeOfNative(rt1Stktop{}), p.Arch)
+	p.runtime.Gobuf = newManualType(eval.TypeOfNative(rt1Gobuf{}), p.Arch)
+	p.runtime.G = newManualType(eval.TypeOfNative(rt1G{}), p.Arch)
 
 	// Get addresses of type.*runtime.XType for discrimination.
-	rtv := reflect.Indirect(reflect.NewValue(&p.runtime)).(*reflect.StructValue);
-	rtvt := rtv.Type().(*reflect.StructType);
+	rtv := reflect.Indirect(reflect.NewValue(&p.runtime)).(*reflect.StructValue)
+	rtvt := rtv.Type().(*reflect.StructType)
 	for i := 0; i < rtv.NumField(); i++ {
-		n := rtvt.Field(i).Name;
+		n := rtvt.Field(i).Name
 		if n[0] != 'P' || n[1] < 'A' || n[1] > 'Z' {
 			continue
 		}
-		sym := p.syms.LookupSym("type.*runtime." + n[1:]);
+		sym := p.syms.LookupSym("type.*runtime." + n[1:])
 		if sym == nil {
 			continue
 		}
-		rtv.Field(i).(*reflect.Uint64Value).Set(sym.Value);
+		rtv.Field(i).(*reflect.Uint64Value).Set(sym.Value)
 	}
 
 	// Get runtime field indexes
-	fillRuntimeIndexes(&p.runtime, &p.f);
+	fillRuntimeIndexes(&p.runtime, &p.f)
 
 	// Fill G status
-	p.runtime.runtimeGStatus = rt1GStatus;
+	p.runtime.runtimeGStatus = rt1GStatus
 
 	// Get globals
-	p.sys.lessstack = p.syms.LookupFunc("sys.lessstack");
-	p.sys.goexit = p.syms.LookupFunc("goexit");
-	p.sys.newproc = p.syms.LookupFunc("sys.newproc");
-	p.sys.deferproc = p.syms.LookupFunc("sys.deferproc");
-	p.sys.newprocreadylocked = p.syms.LookupFunc("newprocreadylocked");
+	p.sys.lessstack = p.syms.LookupFunc("sys.lessstack")
+	p.sys.goexit = p.syms.LookupFunc("goexit")
+	p.sys.newproc = p.syms.LookupFunc("sys.newproc")
+	p.sys.deferproc = p.syms.LookupFunc("sys.deferproc")
+	p.sys.newprocreadylocked = p.syms.LookupFunc("newprocreadylocked")
 	if allg := p.syms.LookupSym("allg"); allg != nil {
 		p.sys.allg = remotePtr{remote{proc.Word(allg.Value), p}, p.runtime.G}
 	}
@@ -263,11 +263,11 @@ func (p *Process) bootstrap() {
 func (p *Process) selectSomeGoroutine() {
 	// Once we have friendly goroutine ID's, there might be a more
 	// reasonable behavior for this.
-	p.curGoroutine = nil;
+	p.curGoroutine = nil
 	for _, g := range p.goroutines {
 		if !g.isG0() && g.frame != nil {
-			p.curGoroutine = g;
-			return;
+			p.curGoroutine = g
+			return
 		}
 	}
 }
@@ -285,27 +285,27 @@ func (p *Process) someStoppedOSThread() proc.Thread {
 
 	for _, t := range p.proc.Threads() {
 		if _, err := t.Stopped(); err == nil {
-			p.threadCache = t;
-			return t;
+			p.threadCache = t
+			return t
 		}
 	}
-	return nil;
+	return nil
 }
 
 func (p *Process) Peek(addr proc.Word, out []byte) (int, os.Error) {
-	thr := p.someStoppedOSThread();
+	thr := p.someStoppedOSThread()
 	if thr == nil {
 		return 0, ProcessNotStopped{}
 	}
-	return thr.Peek(addr, out);
+	return thr.Peek(addr, out)
 }
 
 func (p *Process) Poke(addr proc.Word, b []byte) (int, os.Error) {
-	thr := p.someStoppedOSThread();
+	thr := p.someStoppedOSThread()
 	if thr == nil {
 		return 0, ProcessNotStopped{}
 	}
-	return thr.Poke(addr, b);
+	return thr.Poke(addr, b)
 }
 
 func (p *Process) peekUintptr(a aborter, addr proc.Word) proc.Word {
@@ -323,7 +323,7 @@ func (p *Process) OnBreakpoint(pc proc.Word) EventHook {
 		return bp
 	}
 	// The breakpoint will register itself when a handler is added
-	return &breakpointHook{commonHook{nil, 0}, p, pc};
+	return &breakpointHook{commonHook{nil, 0}, p, pc}
 }
 
 // OnGoroutineCreate returns the hook that is run when a goroutine is created.
@@ -332,27 +332,27 @@ func (p *Process) OnGoroutineCreate() EventHook {
 }
 
 // OnGoroutineExit returns the hook that is run when a goroutine exits.
-func (p *Process) OnGoroutineExit() EventHook	{ return p.goroutineExitHook }
+func (p *Process) OnGoroutineExit() EventHook { return p.goroutineExitHook }
 
 // osThreadToGoroutine looks up the goroutine running on an OS thread.
 func (p *Process) osThreadToGoroutine(t proc.Thread) (*Goroutine, os.Error) {
-	regs, err := t.Regs();
+	regs, err := t.Regs()
 	if err != nil {
 		return nil, err
 	}
-	g := p.G(regs);
-	gt, ok := p.goroutines[g];
+	g := p.G(regs)
+	gt, ok := p.goroutines[g]
 	if !ok {
 		return nil, UnknownGoroutine{t, g}
 	}
-	return gt, nil;
+	return gt, nil
 }
 
 // causesToEvents translates the stop causes of the underlying process
 // into an event queue.
 func (p *Process) causesToEvents() ([]Event, os.Error) {
 	// Count causes we're interested in
-	nev := 0;
+	nev := 0
 	for _, t := range p.proc.Threads() {
 		if c, err := t.Stopped(); err == nil {
 			switch c := c.(type) {
@@ -366,87 +366,87 @@ func (p *Process) causesToEvents() ([]Event, os.Error) {
 	}
 
 	// Translate causes to events
-	events := make([]Event, nev);
-	i := 0;
+	events := make([]Event, nev)
+	i := 0
 	for _, t := range p.proc.Threads() {
 		if c, err := t.Stopped(); err == nil {
 			switch c := c.(type) {
 			case proc.Breakpoint:
-				gt, err := p.osThreadToGoroutine(t);
+				gt, err := p.osThreadToGoroutine(t)
 				if err != nil {
 					return nil, err
 				}
-				events[i] = &Breakpoint{commonEvent{p, gt}, t, proc.Word(c)};
-				i++;
+				events[i] = &Breakpoint{commonEvent{p, gt}, t, proc.Word(c)}
+				i++
 			case proc.Signal:
 				// TODO(austin)
 			}
 		}
 	}
 
-	return events, nil;
+	return events, nil
 }
 
 // postEvent appends an event to the posted queue.  These events will
 // be processed before any currently pending events.
 func (p *Process) postEvent(ev Event) {
-	n := len(p.posted);
-	m := n * 2;
+	n := len(p.posted)
+	m := n * 2
 	if m == 0 {
 		m = 4
 	}
-	posted := make([]Event, n+1, m);
+	posted := make([]Event, n+1, m)
 	for i, p := range p.posted {
 		posted[i] = p
 	}
-	posted[n] = ev;
-	p.posted = posted;
+	posted[n] = ev
+	p.posted = posted
 }
 
 // processEvents processes events in the event queue until no events
 // remain, a handler returns EAStop, or a handler returns an error.
 // It returns either EAStop or EAContinue and possibly an error.
 func (p *Process) processEvents() (EventAction, os.Error) {
-	var ev Event;
+	var ev Event
 	for len(p.posted) > 0 {
-		ev, p.posted = p.posted[0], p.posted[1:];
-		action, err := p.processEvent(ev);
+		ev, p.posted = p.posted[0], p.posted[1:]
+		action, err := p.processEvent(ev)
 		if action == EAStop {
 			return action, err
 		}
 	}
 
 	for len(p.pending) > 0 {
-		ev, p.pending = p.pending[0], p.pending[1:];
-		action, err := p.processEvent(ev);
+		ev, p.pending = p.pending[0], p.pending[1:]
+		action, err := p.processEvent(ev)
 		if action == EAStop {
 			return action, err
 		}
 	}
 
-	return EAContinue, nil;
+	return EAContinue, nil
 }
 
 // processEvent processes a single event, without manipulating the
 // event queues.  It returns either EAStop or EAContinue and possibly
 // an error.
 func (p *Process) processEvent(ev Event) (EventAction, os.Error) {
-	p.event = ev;
+	p.event = ev
 
-	var action EventAction;
-	var err os.Error;
+	var action EventAction
+	var err os.Error
 	switch ev := p.event.(type) {
 	case *Breakpoint:
-		hook, ok := p.breakpointHooks[ev.pc];
+		hook, ok := p.breakpointHooks[ev.pc]
 		if !ok {
 			break
 		}
-		p.curGoroutine = ev.Goroutine();
-		action, err = hook.handle(ev);
+		p.curGoroutine = ev.Goroutine()
+		action, err = hook.handle(ev)
 
 	case *GoroutineCreate:
-		p.curGoroutine = ev.Goroutine();
-		action, err = p.goroutineCreateHook.handle(ev);
+		p.curGoroutine = ev.Goroutine()
+		action, err = p.goroutineCreateHook.handle(ev)
 
 	case *GoroutineExit:
 		action, err = p.goroutineExitHook.handle(ev)
@@ -460,14 +460,14 @@ func (p *Process) processEvent(ev Event) (EventAction, os.Error) {
 	} else if action == EAStop {
 		return EAStop, nil
 	}
-	return EAContinue, nil;
+	return EAContinue, nil
 }
 
 // Event returns the last event that caused the process to stop.  This
 // may return nil if the process has never been stopped by an event.
 //
 // TODO(austin) Return nil if the user calls p.Stop()?
-func (p *Process) Event() Event	{ return p.event }
+func (p *Process) Event() Event { return p.event }
 
 /*
  * Process control
@@ -489,29 +489,29 @@ func (p *Process) Event() Event	{ return p.event }
 // that stops the process.
 func (p *Process) ContWait() os.Error {
 	for {
-		a, err := p.processEvents();
+		a, err := p.processEvents()
 		if err != nil {
 			return err
 		} else if a == EAStop {
 			break
 		}
-		err = p.proc.Continue();
+		err = p.proc.Continue()
 		if err != nil {
 			return err
 		}
-		err = p.proc.WaitStop();
+		err = p.proc.WaitStop()
 		if err != nil {
 			return err
 		}
 		for _, g := range p.goroutines {
 			g.resetFrame()
 		}
-		p.pending, err = p.causesToEvents();
+		p.pending, err = p.causesToEvents()
 		if err != nil {
 			return err
 		}
 	}
-	return nil;
+	return nil
 }
 
 // Out selects the caller frame of the current frame.
@@ -519,7 +519,7 @@ func (p *Process) Out() os.Error {
 	if p.curGoroutine == nil {
 		return NoCurrentGoroutine{}
 	}
-	return p.curGoroutine.Out();
+	return p.curGoroutine.Out()
 }
 
 // In selects the frame called by the current frame.
@@ -527,5 +527,5 @@ func (p *Process) In() os.Error {
 	if p.curGoroutine == nil {
 		return NoCurrentGoroutine{}
 	}
-	return p.curGoroutine.In();
+	return p.curGoroutine.In()
 }
diff --git a/src/pkg/exp/ogle/rruntime.go b/src/pkg/exp/ogle/rruntime.go
index 1a78814765..b13344a5fd 100644
--- a/src/pkg/exp/ogle/rruntime.go
+++ b/src/pkg/exp/ogle/rruntime.go
@@ -5,9 +5,9 @@
 package ogle
 
 import (
-	"debug/proc";
-	"exp/eval";
-	"reflect";
+	"debug/proc"
+	"exp/eval"
+	"reflect"
 )
 
 // This file contains remote runtime definitions.  Using reflection,
@@ -31,19 +31,19 @@ import (
  */
 
 type rt1String struct {
-	str	uintptr;
-	len	int;
+	str uintptr
+	len int
 }
 
 type rt1Slice struct {
-	array	uintptr;
-	len	int;
-	cap	int;
+	array uintptr
+	len   int
+	cap   int
 }
 
 type rt1Eface struct {
-	typ	uintptr;
-	ptr	uintptr;
+	typ uintptr
+	ptr uintptr
 }
 
 /*
@@ -53,17 +53,17 @@ type rt1Eface struct {
  */
 
 type rt1UncommonType struct {
-	name	*string;
-	pkgPath	*string;
+	name    *string
+	pkgPath *string
 	//methods []method;
 }
 
 type rt1CommonType struct {
-	size			uintptr;
-	hash			uint32;
-	alg, align, fieldAlign	uint8;
-	string			*string;
-	uncommonType		*rt1UncommonType;
+	size                   uintptr
+	hash                   uint32
+	alg, align, fieldAlign uint8
+	string                 *string
+	uncommonType           *rt1UncommonType
 }
 
 type rt1Type struct {
@@ -71,37 +71,37 @@ type rt1Type struct {
 	// discriminator as an opaque pointer and taking advantage of
 	// the commonType prologue on all Type's makes type parsing
 	// much simpler.
-	typ	uintptr;
-	ptr	*rt1CommonType;
+	typ uintptr
+	ptr *rt1CommonType
 }
 
 type rt1StructField struct {
-	name	*string;
-	pkgPath	*string;
-	typ	*rt1Type;
-	tag	*string;
-	offset	uintptr;
+	name    *string
+	pkgPath *string
+	typ     *rt1Type
+	tag     *string
+	offset  uintptr
 }
 
 type rt1StructType struct {
-	rt1CommonType;
-	fields	[]rt1StructField;
+	rt1CommonType
+	fields []rt1StructField
 }
 
 type rt1PtrType struct {
-	rt1CommonType;
-	elem	*rt1Type;
+	rt1CommonType
+	elem *rt1Type
 }
 
 type rt1SliceType struct {
-	rt1CommonType;
-	elem	*rt1Type;
+	rt1CommonType
+	elem *rt1Type
 }
 
 type rt1ArrayType struct {
-	rt1CommonType;
-	elem	*rt1Type;
-	len	uintptr;
+	rt1CommonType
+	elem *rt1Type
+	len  uintptr
 }
 
 /*
@@ -113,30 +113,30 @@ type rt1ArrayType struct {
 // Fields beginning with _ are only for padding
 
 type rt1Stktop struct {
-	stackguard	uintptr;
-	stackbase	*rt1Stktop;
-	gobuf		rt1Gobuf;
-	_args		uint32;
-	_fp		uintptr;
+	stackguard uintptr
+	stackbase  *rt1Stktop
+	gobuf      rt1Gobuf
+	_args      uint32
+	_fp        uintptr
 }
 
 type rt1Gobuf struct {
-	sp	uintptr;
-	pc	uintptr;
-	g	*rt1G;
-	r0	uintptr;
+	sp uintptr
+	pc uintptr
+	g  *rt1G
+	r0 uintptr
 }
 
 type rt1G struct {
-	_stackguard	uintptr;
-	stackbase	*rt1Stktop;
-	_defer		uintptr;
-	sched		rt1Gobuf;
-	_stack0		uintptr;
-	_entry		uintptr;
-	alllink		*rt1G;
-	_param		uintptr;
-	status		int16;
+	_stackguard uintptr
+	stackbase   *rt1Stktop
+	_defer      uintptr
+	sched       rt1Gobuf
+	_stack0     uintptr
+	_entry      uintptr
+	alllink     *rt1G
+	_param      uintptr
+	status      int16
 	// Incomplete
 }
 
@@ -156,67 +156,67 @@ var rt1GStatus = runtimeGStatus{
 // exactly and the names of the index fields must be the capitalized
 // version of the names of the fields in the runtime structures above.
 type runtimeIndexes struct {
-	String	struct {
-		Str, Len int;
-	};
-	Slice	struct {
-		Array, Len, Cap int;
-	};
-	Eface	struct {
-		Typ, Ptr int;
-	};
+	String struct {
+		Str, Len int
+	}
+	Slice struct {
+		Array, Len, Cap int
+	}
+	Eface struct {
+		Typ, Ptr int
+	}
 
-	UncommonType	struct {
-		Name, PkgPath int;
-	};
-	CommonType	struct {
-		Size, Hash, Alg, Align, FieldAlign, String, UncommonType int;
-	};
-	Type	struct {
-		Typ, Ptr int;
-	};
-	StructField	struct {
-		Name, PkgPath, Typ, Tag, Offset int;
-	};
-	StructType	struct {
-		Fields int;
-	};
-	PtrType	struct {
-		Elem int;
-	};
-	SliceType	struct {
-		Elem int;
-	};
-	ArrayType	struct {
-		Elem, Len int;
-	};
+	UncommonType struct {
+		Name, PkgPath int
+	}
+	CommonType struct {
+		Size, Hash, Alg, Align, FieldAlign, String, UncommonType int
+	}
+	Type struct {
+		Typ, Ptr int
+	}
+	StructField struct {
+		Name, PkgPath, Typ, Tag, Offset int
+	}
+	StructType struct {
+		Fields int
+	}
+	PtrType struct {
+		Elem int
+	}
+	SliceType struct {
+		Elem int
+	}
+	ArrayType struct {
+		Elem, Len int
+	}
 
-	Stktop	struct {
-		Stackguard, Stackbase, Gobuf int;
-	};
-	Gobuf	struct {
-		Sp, Pc, G int;
-	};
-	G	struct {
-		Stackbase, Sched, Status, Alllink int;
-	};
+	Stktop struct {
+		Stackguard, Stackbase, Gobuf int
+	}
+	Gobuf struct {
+		Sp, Pc, G int
+	}
+	G struct {
+		Stackbase, Sched, Status, Alllink int
+	}
 }
 
 // Values of G status codes
 type runtimeGStatus struct {
-	Gidle, Grunnable, Grunning, Gsyscall, Gwaiting, Gmoribund, Gdead int64;
+	Gidle, Grunnable, Grunning, Gsyscall, Gwaiting, Gmoribund, Gdead int64
 }
 
 // runtimeValues stores the types and values that correspond to those
 // in the remote runtime package.
 type runtimeValues struct {
 	// Runtime data headers
-	String, Slice, Eface	*remoteType;
+	String, Slice, Eface *remoteType
 	// Runtime type structures
 	Type, CommonType, UncommonType, StructField, StructType, PtrType,
-		ArrayType, SliceType	*remoteType;
+		ArrayType, SliceType *remoteType
 	// Runtime scheduler structures
-	Stktop, Gobuf, G	*remoteType;
+	Stktop, Gobuf, G *remoteType
 	// Addresses of *runtime.XType types.  These are the
 	// discriminators on the runtime.Type interface.  We use local
 	// reflection to fill these in from the remote symbol table,
@@ -227,45 +227,45 @@ type runtimeValues struct {
 		PFloat32Type, PFloat64Type, PFloatType,
 		PArrayType, PStringType, PStructType, PPtrType, PFuncType,
 		PInterfaceType, PSliceType, PMapType, PChanType,
-		PDotDotDotType, PUnsafePointerType	proc.Word;
+		PDotDotDotType, PUnsafePointerType proc.Word
 	// G status values
-	runtimeGStatus;
+	runtimeGStatus
 }
 
 // fillRuntimeIndexes fills a runtimeIndexes structure will the field
 // indexes gathered from the remoteTypes recorded in a runtimeValues
 // structure.
 func fillRuntimeIndexes(runtime *runtimeValues, out *runtimeIndexes) {
-	outv := reflect.Indirect(reflect.NewValue(out)).(*reflect.StructValue);
-	outt := outv.Type().(*reflect.StructType);
-	runtimev := reflect.Indirect(reflect.NewValue(runtime)).(*reflect.StructValue);
+	outv := reflect.Indirect(reflect.NewValue(out)).(*reflect.StructValue)
+	outt := outv.Type().(*reflect.StructType)
+	runtimev := reflect.Indirect(reflect.NewValue(runtime)).(*reflect.StructValue)
 
 	// out contains fields corresponding to each runtime type
 	for i := 0; i < outt.NumField(); i++ {
 		// Find the interpreter type for this runtime type
-		name := outt.Field(i).Name;
-		et := runtimev.FieldByName(name).Interface().(*remoteType).Type.(*eval.StructType);
+		name := outt.Field(i).Name
+		et := runtimev.FieldByName(name).Interface().(*remoteType).Type.(*eval.StructType)
 
 		// Get the field indexes of the interpreter struct type
-		indexes := make(map[string]int, len(et.Elems));
+		indexes := make(map[string]int, len(et.Elems))
 		for j, f := range et.Elems {
 			if f.Anonymous {
 				continue
 			}
-			name := f.Name;
+			name := f.Name
 			if name[0] >= 'a' && name[0] <= 'z' {
 				name = string(name[0]+'A'-'a') + name[1:]
 			}
-			indexes[name] = j;
+			indexes[name] = j
 		}
 
 		// Fill this field of out
-		outStructv := outv.Field(i).(*reflect.StructValue);
-		outStructt := outStructv.Type().(*reflect.StructType);
+		outStructv := outv.Field(i).(*reflect.StructValue)
+		outStructt := outStructv.Type().(*reflect.StructType)
 		for j := 0; j < outStructt.NumField(); j++ {
-			f := outStructv.Field(j).(*reflect.IntValue);
-			name := outStructt.Field(j).Name;
-			f.Set(indexes[name]);
+			f := outStructv.Field(j).(*reflect.IntValue)
+			name := outStructt.Field(j).Name
+			f.Set(indexes[name])
 		}
 	}
 }
diff --git a/src/pkg/exp/ogle/rtype.go b/src/pkg/exp/ogle/rtype.go
index 8814792ef3..b20acbad5e 100644
--- a/src/pkg/exp/ogle/rtype.go
+++ b/src/pkg/exp/ogle/rtype.go
@@ -5,25 +5,25 @@
 package ogle
 
 import (
-	"debug/proc";
-	"exp/eval";
-	"fmt";
-	"log";
+	"debug/proc"
+	"exp/eval"
+	"fmt"
+	"log"
 )
 
 const debugParseRemoteType = false
 
 // A remoteType is the local representation of a type in a remote process.
 type remoteType struct {
-	eval.Type;
+	eval.Type
 	// The size of values of this type in bytes.
-	size	int;
+	size int
 	// The field alignment of this type.  Only used for
 	// manually-constructed types.
-	fieldAlign	int;
+	fieldAlign int
 	// The maker function to turn a remote address of a value of
 	// this type into an interpreter Value.
-	mk	maker;
+	mk maker
 }
 
 var manualTypes = make(map[Arch]map[eval.Type]*remoteType)
@@ -38,76 +38,76 @@ func newManualType(t eval.Type, arch Arch) *remoteType {
 	}
 
 	// Get the type map for this architecture
-	typeMap, _ := manualTypes[arch];
+	typeMap, _ := manualTypes[arch]
 	if typeMap == nil {
-		typeMap = make(map[eval.Type]*remoteType);
-		manualTypes[arch] = typeMap;
+		typeMap = make(map[eval.Type]*remoteType)
+		manualTypes[arch] = typeMap
 
 		// Construct basic types for this architecture
 		basicType := func(t eval.Type, mk maker, size int, fieldAlign int) {
-			t = t.(*eval.NamedType).Def;
+			t = t.(*eval.NamedType).Def
 			if fieldAlign == 0 {
 				fieldAlign = size
 			}
-			typeMap[t] = &remoteType{t, size, fieldAlign, mk};
-		};
-		basicType(eval.Uint8Type, mkUint8, 1, 0);
-		basicType(eval.Uint32Type, mkUint32, 4, 0);
-		basicType(eval.UintptrType, mkUintptr, arch.PtrSize(), 0);
-		basicType(eval.Int16Type, mkInt16, 2, 0);
-		basicType(eval.Int32Type, mkInt32, 4, 0);
-		basicType(eval.IntType, mkInt, arch.IntSize(), 0);
-		basicType(eval.StringType, mkString, arch.PtrSize()+arch.IntSize(), arch.PtrSize());
+			typeMap[t] = &remoteType{t, size, fieldAlign, mk}
+		}
+		basicType(eval.Uint8Type, mkUint8, 1, 0)
+		basicType(eval.Uint32Type, mkUint32, 4, 0)
+		basicType(eval.UintptrType, mkUintptr, arch.PtrSize(), 0)
+		basicType(eval.Int16Type, mkInt16, 2, 0)
+		basicType(eval.Int32Type, mkInt32, 4, 0)
+		basicType(eval.IntType, mkInt, arch.IntSize(), 0)
+		basicType(eval.StringType, mkString, arch.PtrSize()+arch.IntSize(), arch.PtrSize())
 	}
 
 	if rt, ok := typeMap[t]; ok {
 		return rt
 	}
 
-	var rt *remoteType;
+	var rt *remoteType
 	switch t := t.(type) {
 	case *eval.PtrType:
-		var elem *remoteType;
-		mk := func(r remote) eval.Value { return remotePtr{r, elem} };
-		rt = &remoteType{t, arch.PtrSize(), arch.PtrSize(), mk};
+		var elem *remoteType
+		mk := func(r remote) eval.Value { return remotePtr{r, elem} }
+		rt = &remoteType{t, arch.PtrSize(), arch.PtrSize(), mk}
 		// Construct the element type after registering the
 		// type to break cycles.
-		typeMap[eval.Type(t)] = rt;
-		elem = newManualType(t.Elem, arch);
+		typeMap[eval.Type(t)] = rt
+		elem = newManualType(t.Elem, arch)
 
 	case *eval.ArrayType:
-		elem := newManualType(t.Elem, arch);
-		mk := func(r remote) eval.Value { return remoteArray{r, t.Len, elem} };
-		rt = &remoteType{t, elem.size * int(t.Len), elem.fieldAlign, mk};
+		elem := newManualType(t.Elem, arch)
+		mk := func(r remote) eval.Value { return remoteArray{r, t.Len, elem} }
+		rt = &remoteType{t, elem.size * int(t.Len), elem.fieldAlign, mk}
 
 	case *eval.SliceType:
-		elem := newManualType(t.Elem, arch);
-		mk := func(r remote) eval.Value { return remoteSlice{r, elem} };
-		rt = &remoteType{t, arch.PtrSize() + 2*arch.IntSize(), arch.PtrSize(), mk};
+		elem := newManualType(t.Elem, arch)
+		mk := func(r remote) eval.Value { return remoteSlice{r, elem} }
+		rt = &remoteType{t, arch.PtrSize() + 2*arch.IntSize(), arch.PtrSize(), mk}
 
 	case *eval.StructType:
-		layout := make([]remoteStructField, len(t.Elems));
-		offset := 0;
-		fieldAlign := 0;
+		layout := make([]remoteStructField, len(t.Elems))
+		offset := 0
+		fieldAlign := 0
 		for i, f := range t.Elems {
-			elem := newManualType(f.Type, arch);
+			elem := newManualType(f.Type, arch)
 			if fieldAlign == 0 {
 				fieldAlign = elem.fieldAlign
 			}
-			offset = arch.Align(offset, elem.fieldAlign);
-			layout[i].offset = offset;
-			layout[i].fieldType = elem;
-			offset += elem.size;
+			offset = arch.Align(offset, elem.fieldAlign)
+			layout[i].offset = offset
+			layout[i].fieldType = elem
+			offset += elem.size
 		}
-		mk := func(r remote) eval.Value { return remoteStruct{r, layout} };
-		rt = &remoteType{t, offset, fieldAlign, mk};
+		mk := func(r remote) eval.Value { return remoteStruct{r, layout} }
+		rt = &remoteType{t, offset, fieldAlign, mk}
 
 	default:
 		log.Crashf("cannot manually construct type %T", t)
 	}
 
-	typeMap[t] = rt;
-	return rt;
+	typeMap[t] = rt
+	return rt
 }
 
 var prtIndent = ""
@@ -115,8 +115,8 @@ var prtIndent = ""
 // parseRemoteType parses a Type structure in a remote process to
 // construct the corresponding interpreter type and remote type.
 func parseRemoteType(a aborter, rs remoteStruct) *remoteType {
-	addr := rs.addr().base;
-	p := rs.addr().p;
+	addr := rs.addr().base
+	p := rs.addr().p
 
 	// We deal with circular types by discovering cycles at
 	// NamedTypes.  If a type cycles back to something other than
@@ -128,154 +128,154 @@ func parseRemoteType(a aborter, rs remoteStruct) *remoteType {
 	// first time we encounter the type and re-use that structure
 	// the second time we encounter it.
 
-	rt, ok := p.types[addr];
+	rt, ok := p.types[addr]
 	if ok && rt.Type != nil {
 		return rt
 	} else if !ok {
-		rt = &remoteType{};
-		p.types[addr] = rt;
+		rt = &remoteType{}
+		p.types[addr] = rt
 	}
 
 	if debugParseRemoteType {
-		sym := p.syms.SymByAddr(uint64(addr));
-		name := "<unknown>";
+		sym := p.syms.SymByAddr(uint64(addr))
+		name := "<unknown>"
 		if sym != nil {
 			name = sym.Name
 		}
-		log.Stderrf("%sParsing type at %#x (%s)", prtIndent, addr, name);
-		prtIndent += " ";
-		defer func() { prtIndent = prtIndent[0 : len(prtIndent)-1] }();
+		log.Stderrf("%sParsing type at %#x (%s)", prtIndent, addr, name)
+		prtIndent += " "
+		defer func() { prtIndent = prtIndent[0 : len(prtIndent)-1] }()
 	}
 
 	// Get Type header
-	itype := proc.Word(rs.field(p.f.Type.Typ).(remoteUint).aGet(a));
-	typ := rs.field(p.f.Type.Ptr).(remotePtr).aGet(a).(remoteStruct);
+	itype := proc.Word(rs.field(p.f.Type.Typ).(remoteUint).aGet(a))
+	typ := rs.field(p.f.Type.Ptr).(remotePtr).aGet(a).(remoteStruct)
 
 	// Is this a named type?
-	var nt *eval.NamedType;
-	uncommon := typ.field(p.f.CommonType.UncommonType).(remotePtr).aGet(a);
+	var nt *eval.NamedType
+	uncommon := typ.field(p.f.CommonType.UncommonType).(remotePtr).aGet(a)
 	if uncommon != nil {
-		name := uncommon.(remoteStruct).field(p.f.UncommonType.Name).(remotePtr).aGet(a);
+		name := uncommon.(remoteStruct).field(p.f.UncommonType.Name).(remotePtr).aGet(a)
 		if name != nil {
 			// TODO(austin) Declare type in appropriate remote package
-			nt = eval.NewNamedType(name.(remoteString).aGet(a));
-			rt.Type = nt;
+			nt = eval.NewNamedType(name.(remoteString).aGet(a))
+			rt.Type = nt
 		}
 	}
 
 	// Create type
-	var t eval.Type;
-	var mk maker;
+	var t eval.Type
+	var mk maker
 	switch itype {
 	case p.runtime.PBoolType:
-		t = eval.BoolType;
-		mk = mkBool;
+		t = eval.BoolType
+		mk = mkBool
 	case p.runtime.PUint8Type:
-		t = eval.Uint8Type;
-		mk = mkUint8;
+		t = eval.Uint8Type
+		mk = mkUint8
 	case p.runtime.PUint16Type:
-		t = eval.Uint16Type;
-		mk = mkUint16;
+		t = eval.Uint16Type
+		mk = mkUint16
 	case p.runtime.PUint32Type:
-		t = eval.Uint32Type;
-		mk = mkUint32;
+		t = eval.Uint32Type
+		mk = mkUint32
 	case p.runtime.PUint64Type:
-		t = eval.Uint64Type;
-		mk = mkUint64;
+		t = eval.Uint64Type
+		mk = mkUint64
 	case p.runtime.PUintType:
-		t = eval.UintType;
-		mk = mkUint;
+		t = eval.UintType
+		mk = mkUint
 	case p.runtime.PUintptrType:
-		t = eval.UintptrType;
-		mk = mkUintptr;
+		t = eval.UintptrType
+		mk = mkUintptr
 	case p.runtime.PInt8Type:
-		t = eval.Int8Type;
-		mk = mkInt8;
+		t = eval.Int8Type
+		mk = mkInt8
 	case p.runtime.PInt16Type:
-		t = eval.Int16Type;
-		mk = mkInt16;
+		t = eval.Int16Type
+		mk = mkInt16
 	case p.runtime.PInt32Type:
-		t = eval.Int32Type;
-		mk = mkInt32;
+		t = eval.Int32Type
+		mk = mkInt32
 	case p.runtime.PInt64Type:
-		t = eval.Int64Type;
-		mk = mkInt64;
+		t = eval.Int64Type
+		mk = mkInt64
 	case p.runtime.PIntType:
-		t = eval.IntType;
-		mk = mkInt;
+		t = eval.IntType
+		mk = mkInt
 	case p.runtime.PFloat32Type:
-		t = eval.Float32Type;
-		mk = mkFloat32;
+		t = eval.Float32Type
+		mk = mkFloat32
 	case p.runtime.PFloat64Type:
-		t = eval.Float64Type;
-		mk = mkFloat64;
+		t = eval.Float64Type
+		mk = mkFloat64
 	case p.runtime.PFloatType:
-		t = eval.FloatType;
-		mk = mkFloat;
+		t = eval.FloatType
+		mk = mkFloat
 	case p.runtime.PStringType:
-		t = eval.StringType;
-		mk = mkString;
+		t = eval.StringType
+		mk = mkString
 
 	case p.runtime.PArrayType:
 		// Cast to an ArrayType
-		typ := p.runtime.ArrayType.mk(typ.addr()).(remoteStruct);
-		len := int64(typ.field(p.f.ArrayType.Len).(remoteUint).aGet(a));
-		elem := parseRemoteType(a, typ.field(p.f.ArrayType.Elem).(remotePtr).aGet(a).(remoteStruct));
-		t = eval.NewArrayType(len, elem.Type);
-		mk = func(r remote) eval.Value { return remoteArray{r, len, elem} };
+		typ := p.runtime.ArrayType.mk(typ.addr()).(remoteStruct)
+		len := int64(typ.field(p.f.ArrayType.Len).(remoteUint).aGet(a))
+		elem := parseRemoteType(a, typ.field(p.f.ArrayType.Elem).(remotePtr).aGet(a).(remoteStruct))
+		t = eval.NewArrayType(len, elem.Type)
+		mk = func(r remote) eval.Value { return remoteArray{r, len, elem} }
 
 	case p.runtime.PStructType:
 		// Cast to a StructType
-		typ := p.runtime.StructType.mk(typ.addr()).(remoteStruct);
-		fs := typ.field(p.f.StructType.Fields).(remoteSlice).aGet(a);
+		typ := p.runtime.StructType.mk(typ.addr()).(remoteStruct)
+		fs := typ.field(p.f.StructType.Fields).(remoteSlice).aGet(a)
 
-		fields := make([]eval.StructField, fs.Len);
-		layout := make([]remoteStructField, fs.Len);
+		fields := make([]eval.StructField, fs.Len)
+		layout := make([]remoteStructField, fs.Len)
 		for i := range fields {
-			f := fs.Base.(remoteArray).elem(int64(i)).(remoteStruct);
-			elemrs := f.field(p.f.StructField.Typ).(remotePtr).aGet(a).(remoteStruct);
-			elem := parseRemoteType(a, elemrs);
-			fields[i].Type = elem.Type;
-			name := f.field(p.f.StructField.Name).(remotePtr).aGet(a);
+			f := fs.Base.(remoteArray).elem(int64(i)).(remoteStruct)
+			elemrs := f.field(p.f.StructField.Typ).(remotePtr).aGet(a).(remoteStruct)
+			elem := parseRemoteType(a, elemrs)
+			fields[i].Type = elem.Type
+			name := f.field(p.f.StructField.Name).(remotePtr).aGet(a)
 			if name == nil {
 				fields[i].Anonymous = true
 			} else {
 				fields[i].Name = name.(remoteString).aGet(a)
 			}
-			layout[i].offset = int(f.field(p.f.StructField.Offset).(remoteUint).aGet(a));
-			layout[i].fieldType = elem;
+			layout[i].offset = int(f.field(p.f.StructField.Offset).(remoteUint).aGet(a))
+			layout[i].fieldType = elem
 		}
 
-		t = eval.NewStructType(fields);
-		mk = func(r remote) eval.Value { return remoteStruct{r, layout} };
+		t = eval.NewStructType(fields)
+		mk = func(r remote) eval.Value { return remoteStruct{r, layout} }
 
 	case p.runtime.PPtrType:
 		// Cast to a PtrType
-		typ := p.runtime.PtrType.mk(typ.addr()).(remoteStruct);
-		elem := parseRemoteType(a, typ.field(p.f.PtrType.Elem).(remotePtr).aGet(a).(remoteStruct));
-		t = eval.NewPtrType(elem.Type);
-		mk = func(r remote) eval.Value { return remotePtr{r, elem} };
+		typ := p.runtime.PtrType.mk(typ.addr()).(remoteStruct)
+		elem := parseRemoteType(a, typ.field(p.f.PtrType.Elem).(remotePtr).aGet(a).(remoteStruct))
+		t = eval.NewPtrType(elem.Type)
+		mk = func(r remote) eval.Value { return remotePtr{r, elem} }
 
 	case p.runtime.PSliceType:
 		// Cast to a SliceType
-		typ := p.runtime.SliceType.mk(typ.addr()).(remoteStruct);
-		elem := parseRemoteType(a, typ.field(p.f.SliceType.Elem).(remotePtr).aGet(a).(remoteStruct));
-		t = eval.NewSliceType(elem.Type);
-		mk = func(r remote) eval.Value { return remoteSlice{r, elem} };
+		typ := p.runtime.SliceType.mk(typ.addr()).(remoteStruct)
+		elem := parseRemoteType(a, typ.field(p.f.SliceType.Elem).(remotePtr).aGet(a).(remoteStruct))
+		t = eval.NewSliceType(elem.Type)
+		mk = func(r remote) eval.Value { return remoteSlice{r, elem} }
 
 	case p.runtime.PMapType, p.runtime.PChanType, p.runtime.PFuncType, p.runtime.PInterfaceType, p.runtime.PUnsafePointerType, p.runtime.PDotDotDotType:
 		// TODO(austin)
-		t = eval.UintptrType;
-		mk = mkUintptr;
+		t = eval.UintptrType
+		mk = mkUintptr
 
 	default:
-		sym := p.syms.SymByAddr(uint64(itype));
-		name := "<unknown symbol>";
+		sym := p.syms.SymByAddr(uint64(itype))
+		name := "<unknown symbol>"
 		if sym != nil {
 			name = sym.Name
 		}
-		err := fmt.Sprintf("runtime type at %#x has unexpected type %#x (%s)", addr, itype, name);
-		a.Abort(FormatError(err));
+		err := fmt.Sprintf("runtime type at %#x has unexpected type %#x (%s)", addr, itype, name)
+		a.Abort(FormatError(err))
 	}
 
 	// Fill in the remote type
@@ -284,8 +284,8 @@ func parseRemoteType(a aborter, rs remoteStruct) *remoteType {
 	} else {
 		rt.Type = t
 	}
-	rt.size = int(typ.field(p.f.CommonType.Size).(remoteUint).aGet(a));
-	rt.mk = mk;
+	rt.size = int(typ.field(p.f.CommonType.Size).(remoteUint).aGet(a))
+	rt.mk = mk
 
-	return rt;
+	return rt
 }
diff --git a/src/pkg/exp/ogle/rvalue.go b/src/pkg/exp/ogle/rvalue.go
index ac5ec2be39..ba915ed5cb 100644
--- a/src/pkg/exp/ogle/rvalue.go
+++ b/src/pkg/exp/ogle/rvalue.go
@@ -5,9 +5,9 @@
 package ogle
 
 import (
-	"debug/proc";
-	"exp/eval";
-	"fmt";
+	"debug/proc"
+	"exp/eval"
+	"fmt"
 )
 
 // A RemoteMismatchError occurs when an operation that requires two
@@ -16,26 +16,26 @@ import (
 // point to something in another process.
 type RemoteMismatchError string
 
-func (e RemoteMismatchError) String() string	{ return string(e) }
+func (e RemoteMismatchError) String() string { return string(e) }
 
 // A ReadOnlyError occurs when attempting to set or assign to a
 // read-only value.
 type ReadOnlyError string
 
-func (e ReadOnlyError) String() string	{ return string(e) }
+func (e ReadOnlyError) String() string { return string(e) }
 
 // A maker is a function that converts a remote address into an
 // interpreter Value.
 type maker func(remote) eval.Value
 
 type remoteValue interface {
-	addr() remote;
+	addr() remote
 }
 
 // remote represents an address in a remote process.
 type remote struct {
-	base	proc.Word;
-	p	*Process;
+	base proc.Word
+	p    *Process
 }
 
 func (v remote) Get(a aborter, size int) uint64 {
@@ -55,34 +55,34 @@ func (v remote) Get(a aborter, size int) uint64 {
 	//
 	// TODO(austin) We need to prevent the remote garbage
 	// collector from collecting objects out from under us.
-	var arr [8]byte;
-	buf := arr[0:size];
-	_, err := v.p.Peek(v.base, buf);
+	var arr [8]byte
+	buf := arr[0:size]
+	_, err := v.p.Peek(v.base, buf)
 	if err != nil {
 		a.Abort(err)
 	}
-	return uint64(v.p.ToWord(buf));
+	return uint64(v.p.ToWord(buf))
 }
 
 func (v remote) Set(a aborter, size int, x uint64) {
-	var arr [8]byte;
-	buf := arr[0:size];
-	v.p.FromWord(proc.Word(x), buf);
-	_, err := v.p.Poke(v.base, buf);
+	var arr [8]byte
+	buf := arr[0:size]
+	v.p.FromWord(proc.Word(x), buf)
+	_, err := v.p.Poke(v.base, buf)
 	if err != nil {
 		a.Abort(err)
 	}
 }
 
-func (v remote) plus(x proc.Word) remote	{ return remote{v.base + x, v.p} }
+func (v remote) plus(x proc.Word) remote { return remote{v.base + x, v.p} }
 
 func tryRVString(f func(a aborter) string) string {
-	var s string;
-	err := try(func(a aborter) { s = f(a) });
+	var s string
+	err := try(func(a aborter) { s = f(a) })
 	if err != nil {
 		return fmt.Sprintf("<error: %v>", err)
 	}
-	return s;
+	return s
 }
 
 /*
@@ -90,7 +90,7 @@ func tryRVString(f func(a aborter) string) string {
  */
 
 type remoteBool struct {
-	r remote;
+	r remote
 }
 
 func (v remoteBool) String() string {
@@ -101,9 +101,9 @@ func (v remoteBool) Assign(t *eval.Thread, o eval.Value) {
 	v.Set(t, o.(eval.BoolValue).Get(t))
 }
 
-func (v remoteBool) Get(t *eval.Thread) bool	{ return v.aGet(t) }
+func (v remoteBool) Get(t *eval.Thread) bool { return v.aGet(t) }
 
-func (v remoteBool) aGet(a aborter) bool	{ return v.r.Get(a, 1) != 0 }
+func (v remoteBool) aGet(a aborter) bool { return v.r.Get(a, 1) != 0 }
 
 func (v remoteBool) Set(t *eval.Thread, x bool) {
 	v.aSet(t, x)
@@ -117,17 +117,17 @@ func (v remoteBool) aSet(a aborter, x bool) {
 	}
 }
 
-func (v remoteBool) addr() remote	{ return v.r }
+func (v remoteBool) addr() remote { return v.r }
 
-func mkBool(r remote) eval.Value	{ return remoteBool{r} }
+func mkBool(r remote) eval.Value { return remoteBool{r} }
 
 /*
  * Uint
  */
 
 type remoteUint struct {
-	r	remote;
-	size	int;
+	r    remote
+	size int
 }
 
 func (v remoteUint) String() string {
@@ -142,35 +142,35 @@ func (v remoteUint) Get(t *eval.Thread) uint64 {
 	return v.aGet(t)
 }
 
-func (v remoteUint) aGet(a aborter) uint64	{ return v.r.Get(a, v.size) }
+func (v remoteUint) aGet(a aborter) uint64 { return v.r.Get(a, v.size) }
 
 func (v remoteUint) Set(t *eval.Thread, x uint64) {
 	v.aSet(t, x)
 }
 
-func (v remoteUint) aSet(a aborter, x uint64)	{ v.r.Set(a, v.size, x) }
+func (v remoteUint) aSet(a aborter, x uint64) { v.r.Set(a, v.size, x) }
 
-func (v remoteUint) addr() remote	{ return v.r }
+func (v remoteUint) addr() remote { return v.r }
 
-func mkUint8(r remote) eval.Value	{ return remoteUint{r, 1} }
+func mkUint8(r remote) eval.Value { return remoteUint{r, 1} }
 
-func mkUint16(r remote) eval.Value	{ return remoteUint{r, 2} }
+func mkUint16(r remote) eval.Value { return remoteUint{r, 2} }
 
-func mkUint32(r remote) eval.Value	{ return remoteUint{r, 4} }
+func mkUint32(r remote) eval.Value { return remoteUint{r, 4} }
 
-func mkUint64(r remote) eval.Value	{ return remoteUint{r, 8} }
+func mkUint64(r remote) eval.Value { return remoteUint{r, 8} }
 
-func mkUint(r remote) eval.Value	{ return remoteUint{r, r.p.IntSize()} }
+func mkUint(r remote) eval.Value { return remoteUint{r, r.p.IntSize()} }
 
-func mkUintptr(r remote) eval.Value	{ return remoteUint{r, r.p.PtrSize()} }
+func mkUintptr(r remote) eval.Value { return remoteUint{r, r.p.PtrSize()} }
 
 /*
  * Int
  */
 
 type remoteInt struct {
-	r	remote;
-	size	int;
+	r    remote
+	size int
 }
 
 func (v remoteInt) String() string {
@@ -181,35 +181,35 @@ func (v remoteInt) Assign(t *eval.Thread, o eval.Value) {
 	v.Set(t, o.(eval.IntValue).Get(t))
 }
 
-func (v remoteInt) Get(t *eval.Thread) int64	{ return v.aGet(t) }
+func (v remoteInt) Get(t *eval.Thread) int64 { return v.aGet(t) }
 
-func (v remoteInt) aGet(a aborter) int64	{ return int64(v.r.Get(a, v.size)) }
+func (v remoteInt) aGet(a aborter) int64 { return int64(v.r.Get(a, v.size)) }
 
 func (v remoteInt) Set(t *eval.Thread, x int64) {
 	v.aSet(t, x)
 }
 
-func (v remoteInt) aSet(a aborter, x int64)	{ v.r.Set(a, v.size, uint64(x)) }
+func (v remoteInt) aSet(a aborter, x int64) { v.r.Set(a, v.size, uint64(x)) }
 
-func (v remoteInt) addr() remote	{ return v.r }
+func (v remoteInt) addr() remote { return v.r }
 
-func mkInt8(r remote) eval.Value	{ return remoteInt{r, 1} }
+func mkInt8(r remote) eval.Value { return remoteInt{r, 1} }
 
-func mkInt16(r remote) eval.Value	{ return remoteInt{r, 2} }
+func mkInt16(r remote) eval.Value { return remoteInt{r, 2} }
 
-func mkInt32(r remote) eval.Value	{ return remoteInt{r, 4} }
+func mkInt32(r remote) eval.Value { return remoteInt{r, 4} }
 
-func mkInt64(r remote) eval.Value	{ return remoteInt{r, 8} }
+func mkInt64(r remote) eval.Value { return remoteInt{r, 8} }
 
-func mkInt(r remote) eval.Value	{ return remoteInt{r, r.p.IntSize()} }
+func mkInt(r remote) eval.Value { return remoteInt{r, r.p.IntSize()} }
 
 /*
  * Float
  */
 
 type remoteFloat struct {
-	r	remote;
-	size	int;
+	r    remote
+	size int
 }
 
 func (v remoteFloat) String() string {
@@ -225,14 +225,14 @@ func (v remoteFloat) Get(t *eval.Thread) float64 {
 }
 
 func (v remoteFloat) aGet(a aborter) float64 {
-	bits := v.r.Get(a, v.size);
+	bits := v.r.Get(a, v.size)
 	switch v.size {
 	case 4:
 		return float64(v.r.p.ToFloat32(uint32(bits)))
 	case 8:
 		return v.r.p.ToFloat64(bits)
 	}
-	panic("Unexpected float size ", v.size);
+	panic("Unexpected float size ", v.size)
 }
 
 func (v remoteFloat) Set(t *eval.Thread, x float64) {
@@ -240,7 +240,7 @@ func (v remoteFloat) Set(t *eval.Thread, x float64) {
 }
 
 func (v remoteFloat) aSet(a aborter, x float64) {
-	var bits uint64;
+	var bits uint64
 	switch v.size {
 	case 4:
 		bits = uint64(v.r.p.FromFloat32(float32(x)))
@@ -249,23 +249,23 @@ func (v remoteFloat) aSet(a aborter, x float64) {
 	default:
 		panic("Unexpected float size ", v.size)
 	}
-	v.r.Set(a, v.size, bits);
+	v.r.Set(a, v.size, bits)
 }
 
-func (v remoteFloat) addr() remote	{ return v.r }
+func (v remoteFloat) addr() remote { return v.r }
 
-func mkFloat32(r remote) eval.Value	{ return remoteFloat{r, 4} }
+func mkFloat32(r remote) eval.Value { return remoteFloat{r, 4} }
 
-func mkFloat64(r remote) eval.Value	{ return remoteFloat{r, 8} }
+func mkFloat64(r remote) eval.Value { return remoteFloat{r, 8} }
 
-func mkFloat(r remote) eval.Value	{ return remoteFloat{r, r.p.FloatSize()} }
+func mkFloat(r remote) eval.Value { return remoteFloat{r, r.p.FloatSize()} }
 
 /*
  * String
  */
 
 type remoteString struct {
-	r remote;
+	r remote
 }
 
 func (v remoteString) String() string {
@@ -281,16 +281,16 @@ func (v remoteString) Get(t *eval.Thread) string {
 }
 
 func (v remoteString) aGet(a aborter) string {
-	rs := v.r.p.runtime.String.mk(v.r).(remoteStruct);
-	str := proc.Word(rs.field(v.r.p.f.String.Str).(remoteUint).aGet(a));
-	len := rs.field(v.r.p.f.String.Len).(remoteInt).aGet(a);
+	rs := v.r.p.runtime.String.mk(v.r).(remoteStruct)
+	str := proc.Word(rs.field(v.r.p.f.String.Str).(remoteUint).aGet(a))
+	len := rs.field(v.r.p.f.String.Len).(remoteInt).aGet(a)
 
-	bytes := make([]uint8, len);
-	_, err := v.r.p.Peek(str, bytes);
+	bytes := make([]uint8, len)
+	_, err := v.r.p.Peek(str, bytes)
 	if err != nil {
 		a.Abort(err)
 	}
-	return string(bytes);
+	return string(bytes)
 }
 
 func (v remoteString) Set(t *eval.Thread, x string) {
@@ -303,33 +303,33 @@ func (v remoteString) aSet(a aborter, x string) {
 	a.Abort(ReadOnlyError("remote strings cannot be assigned to"))
 }
 
-func mkString(r remote) eval.Value	{ return remoteString{r} }
+func mkString(r remote) eval.Value { return remoteString{r} }
 
 /*
  * Array
  */
 
 type remoteArray struct {
-	r		remote;
-	len		int64;
-	elemType	*remoteType;
+	r        remote
+	len      int64
+	elemType *remoteType
 }
 
 func (v remoteArray) String() string {
-	res := "{";
+	res := "{"
 	for i := int64(0); i < v.len; i++ {
 		if i > 0 {
 			res += ", "
 		}
-		res += v.elem(i).String();
+		res += v.elem(i).String()
 	}
-	return res + "}";
+	return res + "}"
 }
 
 func (v remoteArray) Assign(t *eval.Thread, o eval.Value) {
 	// TODO(austin) Could do a bigger memcpy if o is a
 	// remoteArray in the same Process.
-	oa := o.(eval.ArrayValue);
+	oa := o.(eval.ArrayValue)
 	for i := int64(0); i < v.len; i++ {
 		v.Elem(t, i).Assign(t, oa.Elem(t, i))
 	}
@@ -356,30 +356,30 @@ func (v remoteArray) Sub(i int64, len int64) eval.ArrayValue {
  */
 
 type remoteStruct struct {
-	r	remote;
-	layout	[]remoteStructField;
+	r      remote
+	layout []remoteStructField
 }
 
 type remoteStructField struct {
-	offset		int;
-	fieldType	*remoteType;
+	offset    int
+	fieldType *remoteType
 }
 
 func (v remoteStruct) String() string {
-	res := "{";
+	res := "{"
 	for i := range v.layout {
 		if i > 0 {
 			res += ", "
 		}
-		res += v.field(i).String();
+		res += v.field(i).String()
 	}
-	return res + "}";
+	return res + "}"
 }
 
 func (v remoteStruct) Assign(t *eval.Thread, o eval.Value) {
 	// TODO(austin) Could do a bigger memcpy.
-	oa := o.(eval.StructValue);
-	l := len(v.layout);
+	oa := o.(eval.StructValue)
+	l := len(v.layout)
 	for i := 0; i < l; i++ {
 		v.Field(t, i).Assign(t, oa.Field(t, i))
 	}
@@ -394,11 +394,11 @@ func (v remoteStruct) Field(t *eval.Thread, i int) eval.Value {
 }
 
 func (v remoteStruct) field(i int) eval.Value {
-	f := &v.layout[i];
-	return f.fieldType.mk(v.r.plus(proc.Word(f.offset)));
+	f := &v.layout[i]
+	return f.fieldType.mk(v.r.plus(proc.Word(f.offset)))
 }
 
-func (v remoteStruct) addr() remote	{ return v.r }
+func (v remoteStruct) addr() remote { return v.r }
 
 /*
  * Pointer
@@ -409,17 +409,17 @@ func (v remoteStruct) addr() remote	{ return v.r }
 // remotePtr.Get() will be structs.
 
 type remotePtr struct {
-	r		remote;
-	elemType	*remoteType;
+	r        remote
+	elemType *remoteType
 }
 
 func (v remotePtr) String() string {
 	return tryRVString(func(a aborter) string {
-		e := v.aGet(a);
+		e := v.aGet(a)
 		if e == nil {
 			return "<nil>"
 		}
-		return "&" + e.String();
+		return "&" + e.String()
 	})
 }
 
@@ -432,11 +432,11 @@ func (v remotePtr) Get(t *eval.Thread) eval.Value {
 }
 
 func (v remotePtr) aGet(a aborter) eval.Value {
-	addr := proc.Word(v.r.Get(a, v.r.p.PtrSize()));
+	addr := proc.Word(v.r.Get(a, v.r.p.PtrSize()))
 	if addr == 0 {
 		return nil
 	}
-	return v.elemType.mk(remote{addr, v.r.p});
+	return v.elemType.mk(remote{addr, v.r.p})
 }
 
 func (v remotePtr) Set(t *eval.Thread, x eval.Value) {
@@ -445,34 +445,34 @@ func (v remotePtr) Set(t *eval.Thread, x eval.Value) {
 
 func (v remotePtr) aSet(a aborter, x eval.Value) {
 	if x == nil {
-		v.r.Set(a, v.r.p.PtrSize(), 0);
-		return;
+		v.r.Set(a, v.r.p.PtrSize(), 0)
+		return
 	}
-	xr, ok := x.(remoteValue);
+	xr, ok := x.(remoteValue)
 	if !ok || v.r.p != xr.addr().p {
 		a.Abort(RemoteMismatchError("remote pointer must point within the same process"))
 	}
-	v.r.Set(a, v.r.p.PtrSize(), uint64(xr.addr().base));
+	v.r.Set(a, v.r.p.PtrSize(), uint64(xr.addr().base))
 }
 
-func (v remotePtr) addr() remote	{ return v.r }
+func (v remotePtr) addr() remote { return v.r }
 
 /*
  * Slice
  */
 
 type remoteSlice struct {
-	r		remote;
-	elemType	*remoteType;
+	r        remote
+	elemType *remoteType
 }
 
 func (v remoteSlice) String() string {
 	return tryRVString(func(a aborter) string {
-		b := v.aGet(a).Base;
+		b := v.aGet(a).Base
 		if b == nil {
 			return "<nil>"
 		}
-		return b.String();
+		return b.String()
 	})
 }
 
@@ -485,14 +485,14 @@ func (v remoteSlice) Get(t *eval.Thread) eval.Slice {
 }
 
 func (v remoteSlice) aGet(a aborter) eval.Slice {
-	rs := v.r.p.runtime.Slice.mk(v.r).(remoteStruct);
-	base := proc.Word(rs.field(v.r.p.f.Slice.Array).(remoteUint).aGet(a));
-	nel := rs.field(v.r.p.f.Slice.Len).(remoteInt).aGet(a);
-	cap := rs.field(v.r.p.f.Slice.Cap).(remoteInt).aGet(a);
+	rs := v.r.p.runtime.Slice.mk(v.r).(remoteStruct)
+	base := proc.Word(rs.field(v.r.p.f.Slice.Array).(remoteUint).aGet(a))
+	nel := rs.field(v.r.p.f.Slice.Len).(remoteInt).aGet(a)
+	cap := rs.field(v.r.p.f.Slice.Cap).(remoteInt).aGet(a)
 	if base == 0 {
 		return eval.Slice{nil, nel, cap}
 	}
-	return eval.Slice{remoteArray{remote{base, v.r.p}, nel, v.elemType}, nel, cap};
+	return eval.Slice{remoteArray{remote{base, v.r.p}, nel, v.elemType}, nel, cap}
 }
 
 func (v remoteSlice) Set(t *eval.Thread, x eval.Slice) {
@@ -500,16 +500,16 @@ func (v remoteSlice) Set(t *eval.Thread, x eval.Slice) {
 }
 
 func (v remoteSlice) aSet(a aborter, x eval.Slice) {
-	rs := v.r.p.runtime.Slice.mk(v.r).(remoteStruct);
+	rs := v.r.p.runtime.Slice.mk(v.r).(remoteStruct)
 	if x.Base == nil {
 		rs.field(v.r.p.f.Slice.Array).(remoteUint).aSet(a, 0)
 	} else {
-		ar, ok := x.Base.(remoteArray);
+		ar, ok := x.Base.(remoteArray)
 		if !ok || v.r.p != ar.r.p {
 			a.Abort(RemoteMismatchError("remote slice must point within the same process"))
 		}
-		rs.field(v.r.p.f.Slice.Array).(remoteUint).aSet(a, uint64(ar.r.base));
+		rs.field(v.r.p.f.Slice.Array).(remoteUint).aSet(a, uint64(ar.r.base))
 	}
-	rs.field(v.r.p.f.Slice.Len).(remoteInt).aSet(a, x.Len);
-	rs.field(v.r.p.f.Slice.Cap).(remoteInt).aSet(a, x.Cap);
+	rs.field(v.r.p.f.Slice.Len).(remoteInt).aSet(a, x.Len)
+	rs.field(v.r.p.f.Slice.Cap).(remoteInt).aSet(a, x.Cap)
 }
diff --git a/src/pkg/exp/ogle/vars.go b/src/pkg/exp/ogle/vars.go
index 7ceeb5101f..e6298bc481 100644
--- a/src/pkg/exp/ogle/vars.go
+++ b/src/pkg/exp/ogle/vars.go
@@ -5,11 +5,11 @@
 package ogle
 
 import (
-	"debug/gosym";
-	"debug/proc";
-	"exp/eval";
-	"log";
-	"os";
+	"debug/gosym"
+	"debug/proc"
+	"exp/eval"
+	"log"
+	"os"
 )
 
 /*
@@ -19,8 +19,8 @@ import (
 // A NotOnStack error occurs when attempting to access a variable in a
 // remote frame where that remote frame is not on the current stack.
 type NotOnStack struct {
-	Fn		*gosym.Func;
-	Goroutine	*Goroutine;
+	Fn        *gosym.Func
+	Goroutine *Goroutine
 }
 
 func (e NotOnStack) String() string {
@@ -33,9 +33,9 @@ func (e NotOnStack) String() string {
 // stack and returns a structure containing the local variables of
 // that function.
 type remoteFramePtr struct {
-	p	*Process;
-	fn	*gosym.Func;
-	rt	*remoteType;
+	p  *Process
+	fn *gosym.Func
+	rt *remoteType
 }
 
 func (v remoteFramePtr) String() string {
@@ -48,7 +48,7 @@ func (v remoteFramePtr) Assign(t *eval.Thread, o eval.Value) {
 }
 
 func (v remoteFramePtr) Get(t *eval.Thread) eval.Value {
-	g := v.p.curGoroutine;
+	g := v.p.curGoroutine
 	if g == nil || g.frame == nil {
 		t.Abort(NoCurrentGoroutine{})
 	}
@@ -59,11 +59,11 @@ func (v remoteFramePtr) Get(t *eval.Thread) eval.Value {
 		}
 
 		// TODO(austin): Register for shootdown with f
-		return v.rt.mk(remote{f.fp, v.p});
+		return v.rt.mk(remote{f.fp, v.p})
 	}
 
-	t.Abort(NotOnStack{v.fn, g});
-	panic();
+	t.Abort(NotOnStack{v.fn, g})
+	panic()
 }
 
 func (v remoteFramePtr) Set(t *eval.Thread, x eval.Value) {
@@ -87,10 +87,10 @@ func (v remoteFramePtr) Set(t *eval.Thread, x eval.Value) {
 // represents a package in a remote process.  It's essentially a
 // regular struct, except it cannot be assigned to.
 type remotePackage struct {
-	defs []eval.Value;
+	defs []eval.Value
 }
 
-func (v remotePackage) String() string	{ return "<remote package>" }
+func (v remotePackage) String() string { return "<remote package>" }
 
 func (v remotePackage) Assign(t *eval.Thread, o eval.Value) {
 	t.Abort(ReadOnlyError("remote packages cannot be assigned to"))
@@ -113,10 +113,10 @@ func (v remotePackage) Field(t *eval.Thread, i int) eval.Value {
 // fields for each global and function in that package.
 func (p *Process) populateWorld(w *eval.World) os.Error {
 	type def struct {
-		t	eval.Type;
-		v	eval.Value;
+		t eval.Type
+		v eval.Value
 	}
-	packages := make(map[string]map[string]def);
+	packages := make(map[string]map[string]def)
 
 	for _, s := range p.syms.Syms {
 		if s.ReceiverName() != "" {
@@ -125,27 +125,27 @@ func (p *Process) populateWorld(w *eval.World) os.Error {
 		}
 
 		// Package
-		pkgName := s.PackageName();
+		pkgName := s.PackageName()
 		switch pkgName {
 		case "", "type", "extratype", "string", "go":
 			// "go" is really "go.string"
 			continue
 		}
-		pkg, ok := packages[pkgName];
+		pkg, ok := packages[pkgName]
 		if !ok {
-			pkg = make(map[string]def);
-			packages[pkgName] = pkg;
+			pkg = make(map[string]def)
+			packages[pkgName] = pkg
 		}
 
 		// Symbol name
-		name := s.BaseName();
+		name := s.BaseName()
 		if _, ok := pkg[name]; ok {
-			log.Stderrf("Multiple definitions of symbol %s", s.Name);
-			continue;
+			log.Stderrf("Multiple definitions of symbol %s", s.Name)
+			continue
 		}
 
 		// Symbol type
-		rt, err := p.typeOfSym(&s);
+		rt, err := p.typeOfSym(&s)
 		if err != nil {
 			return err
 		}
@@ -157,19 +157,19 @@ func (p *Process) populateWorld(w *eval.World) os.Error {
 			if rt == nil {
 				continue
 			}
-			pkg[name] = def{rt.Type, rt.mk(remote{proc.Word(s.Value), p})};
+			pkg[name] = def{rt.Type, rt.mk(remote{proc.Word(s.Value), p})}
 
 		case 'T', 't', 'L', 'l':
 			// Function
-			s := s.Func;
+			s := s.Func
 			// TODO(austin): Ideally, this would *also* be
 			// callable.  How does that interact with type
 			// conversion syntax?
-			rt, err := p.makeFrameType(s);
+			rt, err := p.makeFrameType(s)
 			if err != nil {
 				return err
 			}
-			pkg[name] = def{eval.NewPtrType(rt.Type), remoteFramePtr{p, s, rt}};
+			pkg[name] = def{eval.NewPtrType(rt.Type), remoteFramePtr{p, s, rt}}
 		}
 	}
 
@@ -177,25 +177,25 @@ func (p *Process) populateWorld(w *eval.World) os.Error {
 
 	// Define packages
 	for pkgName, defs := range packages {
-		fields := make([]eval.StructField, len(defs));
-		vals := make([]eval.Value, len(defs));
-		i := 0;
+		fields := make([]eval.StructField, len(defs))
+		vals := make([]eval.Value, len(defs))
+		i := 0
 		for name, def := range defs {
-			fields[i].Name = name;
-			fields[i].Type = def.t;
-			vals[i] = def.v;
-			i++;
+			fields[i].Name = name
+			fields[i].Type = def.t
+			vals[i] = def.v
+			i++
 		}
-		pkgType := eval.NewStructType(fields);
-		pkgVal := remotePackage{vals};
+		pkgType := eval.NewStructType(fields)
+		pkgVal := remotePackage{vals}
 
-		err := w.DefineConst(pkgName, pkgType, pkgVal);
+		err := w.DefineConst(pkgName, pkgType, pkgVal)
 		if err != nil {
 			log.Stderrf("while defining package %s: %v", pkgName, err)
 		}
 	}
 
-	return nil;
+	return nil
 }
 
 // typeOfSym returns the type associated with a symbol.  If the symbol
@@ -204,23 +204,23 @@ func (p *Process) typeOfSym(s *gosym.Sym) (*remoteType, os.Error) {
 	if s.GoType == 0 {
 		return nil, nil
 	}
-	addr := proc.Word(s.GoType);
-	var rt *remoteType;
-	err := try(func(a aborter) { rt = parseRemoteType(a, p.runtime.Type.mk(remote{addr, p}).(remoteStruct)) });
+	addr := proc.Word(s.GoType)
+	var rt *remoteType
+	err := try(func(a aborter) { rt = parseRemoteType(a, p.runtime.Type.mk(remote{addr, p}).(remoteStruct)) })
 	if err != nil {
 		return nil, err
 	}
-	return rt, nil;
+	return rt, nil
 }
 
 // makeFrameType constructs a struct type for the frame of a function.
 // The offsets in this struct type are such that the struct can be
 // instantiated at this function's frame pointer.
 func (p *Process) makeFrameType(s *gosym.Func) (*remoteType, os.Error) {
-	n := len(s.Params) + len(s.Locals);
-	fields := make([]eval.StructField, n);
-	layout := make([]remoteStructField, n);
-	i := 0;
+	n := len(s.Params) + len(s.Locals)
+	fields := make([]eval.StructField, n)
+	layout := make([]remoteStructField, n)
+	i := 0
 
 	// TODO(austin): There can be multiple locals/parameters with
 	// the same name.  We probably need liveness information to do
@@ -230,7 +230,7 @@ func (p *Process) makeFrameType(s *gosym.Func) (*remoteType, os.Error) {
 	// things like "i", where there's an obvious right answer.
 
 	for _, param := range s.Params {
-		rt, err := p.typeOfSym(param);
+		rt, err := p.typeOfSym(param)
 		if err != nil {
 			return nil, err
 		}
@@ -240,33 +240,33 @@ func (p *Process) makeFrameType(s *gosym.Func) (*remoteType, os.Error) {
 		}
 		// TODO(austin): Why do local variables carry their
 		// package name?
-		fields[i].Name = param.BaseName();
-		fields[i].Type = rt.Type;
+		fields[i].Name = param.BaseName()
+		fields[i].Type = rt.Type
 		// Parameters have positive offsets from FP
-		layout[i].offset = int(param.Value);
-		layout[i].fieldType = rt;
-		i++;
+		layout[i].offset = int(param.Value)
+		layout[i].fieldType = rt
+		i++
 	}
 
 	for _, local := range s.Locals {
-		rt, err := p.typeOfSym(local);
+		rt, err := p.typeOfSym(local)
 		if err != nil {
 			return nil, err
 		}
 		if rt == nil {
 			continue
 		}
-		fields[i].Name = local.BaseName();
-		fields[i].Type = rt.Type;
+		fields[i].Name = local.BaseName()
+		fields[i].Type = rt.Type
 		// Locals have negative offsets from FP - PtrSize
-		layout[i].offset = -int(local.Value) - p.PtrSize();
-		layout[i].fieldType = rt;
-		i++;
+		layout[i].offset = -int(local.Value) - p.PtrSize()
+		layout[i].fieldType = rt
+		i++
 	}
 
-	fields = fields[0:i];
-	layout = layout[0:i];
-	t := eval.NewStructType(fields);
-	mk := func(r remote) eval.Value { return remoteStruct{r, layout} };
-	return &remoteType{t, 0, 0, mk}, nil;
+	fields = fields[0:i]
+	layout = layout[0:i]
+	t := eval.NewStructType(fields)
+	mk := func(r remote) eval.Value { return remoteStruct{r, layout} }
+	return &remoteType{t, 0, 0, mk}, nil
 }
diff --git a/src/pkg/exp/parser/interface.go b/src/pkg/exp/parser/interface.go
index ca01de2001..495c0c29ee 100644
--- a/src/pkg/exp/parser/interface.go
+++ b/src/pkg/exp/parser/interface.go
@@ -7,15 +7,15 @@
 package oldParser
 
 import (
-	"bytes";
-	"fmt";
-	"go/ast";
-	"go/scanner";
-	"io";
-	"io/ioutil";
-	"os";
-	pathutil "path";
-	"strings";
+	"bytes"
+	"fmt"
+	"go/ast"
+	"go/scanner"
+	"io"
+	"io/ioutil"
+	"os"
+	pathutil "path"
+	"strings"
 )
 
 
@@ -36,18 +36,18 @@ func readSource(filename string, src interface{}) ([]byte, os.Error) {
 				return s.Bytes(), nil
 			}
 		case io.Reader:
-			var buf bytes.Buffer;
-			_, err := io.Copy(&buf, s);
+			var buf bytes.Buffer
+			_, err := io.Copy(&buf, s)
 			if err != nil {
 				return nil, err
 			}
-			return buf.Bytes(), nil;
+			return buf.Bytes(), nil
 		default:
 			return nil, os.ErrorString("invalid source")
 		}
 	}
 
-	return ioutil.ReadFile(filename);
+	return ioutil.ReadFile(filename)
 }
 
 
@@ -57,14 +57,14 @@ func readSource(filename string, src interface{}) ([]byte, os.Error) {
 // may be nil or contain a partial AST.
 //
 func ParseExpr(filename string, src interface{}) (ast.Expr, os.Error) {
-	data, err := readSource(filename, src);
+	data, err := readSource(filename, src)
 	if err != nil {
 		return nil, err
 	}
 
-	var p parser;
-	p.init(filename, data, 0);
-	return p.parseExpr(), p.GetError(scanner.Sorted);
+	var p parser
+	p.init(filename, data, 0)
+	return p.parseExpr(), p.GetError(scanner.Sorted)
 }
 
 
@@ -74,14 +74,14 @@ func ParseExpr(filename string, src interface{}) (ast.Expr, os.Error) {
 // list may be nil or contain partial ASTs.
 //
 func ParseStmtList(filename string, src interface{}) ([]ast.Stmt, os.Error) {
-	data, err := readSource(filename, src);
+	data, err := readSource(filename, src)
 	if err != nil {
 		return nil, err
 	}
 
-	var p parser;
-	p.init(filename, data, 0);
-	return p.parseStmtList(), p.GetError(scanner.Sorted);
+	var p parser
+	p.init(filename, data, 0)
+	return p.parseStmtList(), p.GetError(scanner.Sorted)
 }
 
 
@@ -91,14 +91,14 @@ func ParseStmtList(filename string, src interface{}) ([]ast.Stmt, os.Error) {
 // list may be nil or contain partial ASTs.
 //
 func ParseDeclList(filename string, src interface{}) ([]ast.Decl, os.Error) {
-	data, err := readSource(filename, src);
+	data, err := readSource(filename, src)
 	if err != nil {
 		return nil, err
 	}
 
-	var p parser;
-	p.init(filename, data, 0);
-	return p.parseDeclList(), p.GetError(scanner.Sorted);
+	var p parser
+	p.init(filename, data, 0)
+	return p.parseDeclList(), p.GetError(scanner.Sorted)
 }
 
 
@@ -121,14 +121,14 @@ func ParseDeclList(filename string, src interface{}) ([]ast.Decl, os.Error) {
 // are returned via a scanner.ErrorList which is sorted by file position.
 //
 func ParseFile(filename string, src interface{}, mode uint) (*ast.File, os.Error) {
-	data, err := readSource(filename, src);
+	data, err := readSource(filename, src)
 	if err != nil {
 		return nil, err
 	}
 
-	var p parser;
-	p.init(filename, data, mode);
-	return p.parseFile(), p.GetError(scanner.NoMultiples);
+	var p parser
+	p.init(filename, data, mode)
+	return p.parseFile(), p.GetError(scanner.NoMultiples)
 }
 
 
@@ -139,13 +139,13 @@ func ParseFile(filename string, src interface{}, mode uint) (*ast.File, os.Error
 // flags that control the amount of source text parsed are ignored.
 //
 func ParsePkgFile(pkgname, filename string, mode uint) (*ast.File, os.Error) {
-	src, err := ioutil.ReadFile(filename);
+	src, err := ioutil.ReadFile(filename)
 	if err != nil {
 		return nil, err
 	}
 
 	if pkgname != "" {
-		prog, err := ParseFile(filename, src, PackageClauseOnly);
+		prog, err := ParseFile(filename, src, PackageClauseOnly)
 		if err != nil {
 			return nil, err
 		}
@@ -155,7 +155,7 @@ func ParsePkgFile(pkgname, filename string, mode uint) (*ast.File, os.Error) {
 	}
 
 	// ignore flags that control partial parsing
-	return ParseFile(filename, src, mode&^(PackageClauseOnly|ImportsOnly));
+	return ParseFile(filename, src, mode&^(PackageClauseOnly|ImportsOnly))
 }
 
 
@@ -167,27 +167,27 @@ func ParsePkgFile(pkgname, filename string, mode uint) (*ast.File, os.Error) {
 // Mode flags that control the amount of source text parsed are ignored.
 //
 func ParsePackage(path string, filter func(*os.Dir) bool, mode uint) (*ast.Package, os.Error) {
-	fd, err := os.Open(path, os.O_RDONLY, 0);
+	fd, err := os.Open(path, os.O_RDONLY, 0)
 	if err != nil {
 		return nil, err
 	}
-	defer fd.Close();
+	defer fd.Close()
 
-	list, err := fd.Readdir(-1);
+	list, err := fd.Readdir(-1)
 	if err != nil {
 		return nil, err
 	}
 
-	name := "";
-	files := make(map[string]*ast.File);
+	name := ""
+	files := make(map[string]*ast.File)
 	for i := 0; i < len(list); i++ {
-		entry := &list[i];
+		entry := &list[i]
 		if filter == nil || filter(entry) {
-			src, err := ParsePkgFile(name, pathutil.Join(path, entry.Name), mode);
+			src, err := ParsePkgFile(name, pathutil.Join(path, entry.Name), mode)
 			if err != nil {
 				return nil, err
 			}
-			files[entry.Name] = src;
+			files[entry.Name] = src
 			if name == "" {
 				name = src.Name.Value
 			}
@@ -198,5 +198,5 @@ func ParsePackage(path string, filter func(*os.Dir) bool, mode uint) (*ast.Packa
 		return nil, os.NewError(path + ": no package found")
 	}
 
-	return &ast.Package{name, path, files}, nil;
+	return &ast.Package{name, path, files}, nil
 }
diff --git a/src/pkg/exp/parser/parser.go b/src/pkg/exp/parser/parser.go
index 32360b5d6a..199334b1bf 100644
--- a/src/pkg/exp/parser/parser.go
+++ b/src/pkg/exp/parser/parser.go
@@ -15,11 +15,11 @@
 package oldParser
 
 import (
-	"container/vector";
-	"fmt";
-	"go/ast";
-	"go/scanner";
-	"go/token";
+	"container/vector"
+	"fmt"
+	"go/ast"
+	"go/scanner"
+	"go/token"
 )
 
 
@@ -32,42 +32,42 @@ var noPos token.Position
 // parser functionality.
 //
 const (
-	PackageClauseOnly	uint	= 1 << iota;	// parsing stops after package clause
-	ImportsOnly;			// parsing stops after import declarations
-	ParseComments;			// parse comments and add them to AST
-	Trace;				// print a trace of parsed productions
+	PackageClauseOnly uint = 1 << iota // parsing stops after package clause
+	ImportsOnly            // parsing stops after import declarations
+	ParseComments          // parse comments and add them to AST
+	Trace                  // print a trace of parsed productions
 )
 
 
 // The parser structure holds the parser's internal state.
 type parser struct {
-	scanner.ErrorVector;
-	scanner	scanner.Scanner;
+	scanner.ErrorVector
+	scanner scanner.Scanner
 
 	// Tracing/debugging
-	mode	uint;	// parsing mode
-	trace	bool;	// == (mode & Trace != 0)
-	indent	uint;	// indentation used for tracing output
+	mode   uint // parsing mode
+	trace  bool // == (mode & Trace != 0)
+	indent uint // indentation used for tracing output
 
 	// Comments
-	comments	*ast.CommentGroup;	// list of collected comments
-	lastComment	*ast.CommentGroup;	// last comment in the comments list
-	leadComment	*ast.CommentGroup;	// the last lead comment
-	lineComment	*ast.CommentGroup;	// the last line comment
+	comments    *ast.CommentGroup // list of collected comments
+	lastComment *ast.CommentGroup // last comment in the comments list
+	leadComment *ast.CommentGroup // the last lead comment
+	lineComment *ast.CommentGroup // the last line comment
 
 	// Next token
-	pos	token.Position;	// token position
-	tok	token.Token;	// one token look-ahead
-	lit	[]byte;		// token literal
+	pos token.Position // token position
+	tok token.Token    // one token look-ahead
+	lit []byte         // token literal
 
 	// Non-syntactic parser control
-	optSemi	bool;	// true if semicolon separator is optional in statement list
-	exprLev	int;	// < 0: in control clause, >= 0: in expression
+	optSemi bool // true if semicolon separator is optional in statement list
+	exprLev int  // < 0: in control clause, >= 0: in expression
 
 	// Scopes
-	pkgScope	*ast.Scope;
-	fileScope	*ast.Scope;
-	topScope	*ast.Scope;
+	pkgScope  *ast.Scope
+	fileScope *ast.Scope
+	topScope  *ast.Scope
 }
 
 
@@ -76,15 +76,15 @@ func scannerMode(mode uint) uint {
 	if mode&ParseComments != 0 {
 		return scanner.ScanComments
 	}
-	return 0;
+	return 0
 }
 
 
 func (p *parser) init(filename string, src []byte, mode uint) {
-	p.scanner.Init(filename, src, p, scannerMode(mode));
-	p.mode = mode;
-	p.trace = mode&Trace != 0;	// for convenience (p.trace is used frequently)
-	p.next();
+	p.scanner.Init(filename, src, p, scannerMode(mode))
+	p.mode = mode
+	p.trace = mode&Trace != 0 // for convenience (p.trace is used frequently)
+	p.next()
 }
 
 
@@ -93,29 +93,29 @@ func (p *parser) init(filename string, src []byte, mode uint) {
 
 func (p *parser) printTrace(a ...) {
 	const dots = ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . " +
-		". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
-	const n = uint(len(dots));
-	fmt.Printf("%5d:%3d: ", p.pos.Line, p.pos.Column);
-	i := 2 * p.indent;
+		". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "
+	const n = uint(len(dots))
+	fmt.Printf("%5d:%3d: ", p.pos.Line, p.pos.Column)
+	i := 2 * p.indent
 	for ; i > n; i -= n {
 		fmt.Print(dots)
 	}
-	fmt.Print(dots[0:i]);
-	fmt.Println(a);
+	fmt.Print(dots[0:i])
+	fmt.Println(a)
 }
 
 
 func trace(p *parser, msg string) *parser {
-	p.printTrace(msg, "(");
-	p.indent++;
-	return p;
+	p.printTrace(msg, "(")
+	p.indent++
+	return p
 }
 
 
 // Usage pattern: defer un(trace(p, "..."));
 func un(p *parser) {
-	p.indent--;
-	p.printTrace(")");
+	p.indent--
+	p.printTrace(")")
 }
 
 
@@ -126,7 +126,7 @@ func (p *parser) next0() {
 	// very first token (p.pos.Line == 0) is not initialized (it
 	// is token.ILLEGAL), so don't print it .
 	if p.trace && p.pos.Line > 0 {
-		s := p.tok.String();
+		s := p.tok.String()
 		switch {
 		case p.tok.IsLiteral():
 			p.printTrace(s, string(p.lit))
@@ -137,8 +137,8 @@ func (p *parser) next0() {
 		}
 	}
 
-	p.pos, p.tok, p.lit = p.scanner.Scan();
-	p.optSemi = false;
+	p.pos, p.tok, p.lit = p.scanner.Scan()
+	p.optSemi = false
 }
 
 
@@ -146,7 +146,7 @@ func (p *parser) next0() {
 func (p *parser) consumeComment() (comment *ast.Comment, endline int) {
 	// /*-style comments may end on a different line than where they start.
 	// Scan the comment for '\n' chars and adjust endline accordingly.
-	endline = p.pos.Line;
+	endline = p.pos.Line
 	if p.lit[1] == '*' {
 		for _, b := range p.lit {
 			if b == '\n' {
@@ -155,10 +155,10 @@ func (p *parser) consumeComment() (comment *ast.Comment, endline int) {
 		}
 	}
 
-	comment = &ast.Comment{p.pos, p.lit};
-	p.next0();
+	comment = &ast.Comment{p.pos, p.lit}
+	p.next0()
 
-	return;
+	return
 }
 
 
@@ -168,30 +168,30 @@ func (p *parser) consumeComment() (comment *ast.Comment, endline int) {
 // a comment group.
 //
 func (p *parser) consumeCommentGroup() int {
-	list := new(vector.Vector);
-	endline := p.pos.Line;
+	list := new(vector.Vector)
+	endline := p.pos.Line
 	for p.tok == token.COMMENT && endline+1 >= p.pos.Line {
-		var comment *ast.Comment;
-		comment, endline = p.consumeComment();
-		list.Push(comment);
+		var comment *ast.Comment
+		comment, endline = p.consumeComment()
+		list.Push(comment)
 	}
 
 	// convert list
-	group := make([]*ast.Comment, list.Len());
+	group := make([]*ast.Comment, list.Len())
 	for i := 0; i < list.Len(); i++ {
 		group[i] = list.At(i).(*ast.Comment)
 	}
 
 	// add comment group to the comments list
-	g := &ast.CommentGroup{group, nil};
+	g := &ast.CommentGroup{group, nil}
 	if p.lastComment != nil {
 		p.lastComment.Next = g
 	} else {
 		p.comments = g
 	}
-	p.lastComment = g;
+	p.lastComment = g
 
-	return endline;
+	return endline
 }
 
 
@@ -211,16 +211,16 @@ func (p *parser) consumeCommentGroup() int {
 // stored in the AST.
 //
 func (p *parser) next() {
-	p.leadComment = nil;
-	p.lineComment = nil;
-	line := p.pos.Line;	// current line
-	p.next0();
+	p.leadComment = nil
+	p.lineComment = nil
+	line := p.pos.Line // current line
+	p.next0()
 
 	if p.tok == token.COMMENT {
 		if p.pos.Line == line {
 			// The comment is on same line as previous token; it
 			// cannot be a lead comment but may be a line comment.
-			endline := p.consumeCommentGroup();
+			endline := p.consumeCommentGroup()
 			if p.pos.Line != endline {
 				// The next token is on a different line, thus
 				// the last comment group is a line comment.
@@ -229,7 +229,7 @@ func (p *parser) next() {
 		}
 
 		// consume successor comments, if any
-		endline := -1;
+		endline := -1
 		for p.tok == token.COMMENT {
 			endline = p.consumeCommentGroup()
 		}
@@ -244,26 +244,26 @@ func (p *parser) next() {
 
 
 func (p *parser) errorExpected(pos token.Position, msg string) {
-	msg = "expected " + msg;
+	msg = "expected " + msg
 	if pos.Offset == p.pos.Offset {
 		// the error happened at the current position;
 		// make the error message more specific
-		msg += ", found '" + p.tok.String() + "'";
+		msg += ", found '" + p.tok.String() + "'"
 		if p.tok.IsLiteral() {
 			msg += " " + string(p.lit)
 		}
 	}
-	p.Error(pos, msg);
+	p.Error(pos, msg)
 }
 
 
 func (p *parser) expect(tok token.Token) token.Position {
-	pos := p.pos;
+	pos := p.pos
 	if p.tok != tok {
 		p.errorExpected(pos, "'"+tok.String()+"'")
 	}
-	p.next();	// make progress in any case
-	return pos;
+	p.next() // make progress in any case
+	return pos
 }
 
 
@@ -271,13 +271,13 @@ func (p *parser) expect(tok token.Token) token.Position {
 // Scope support
 
 func openScope(p *parser) *parser {
-	p.topScope = ast.NewScope(p.topScope);
-	return p;
+	p.topScope = ast.NewScope(p.topScope)
+	return p
 }
 
 
 // Usage pattern: defer close(openScope(p));
-func close(p *parser)	{ p.topScope = p.topScope.Outer }
+func close(p *parser) { p.topScope = p.topScope.Outer }
 
 
 func (p *parser) declare(ident *ast.Ident) {
@@ -299,12 +299,12 @@ func (p *parser) declareList(idents []*ast.Ident) {
 
 func (p *parser) parseIdent() *ast.Ident {
 	if p.tok == token.IDENT {
-		x := &ast.Ident{p.pos, string(p.lit)};
-		p.next();
-		return x;
+		x := &ast.Ident{p.pos, string(p.lit)}
+		p.next()
+		return x
 	}
-	p.expect(token.IDENT);	// use expect() error handling
-	return &ast.Ident{p.pos, ""};
+	p.expect(token.IDENT) // use expect() error handling
+	return &ast.Ident{p.pos, ""}
 }
 
 
@@ -313,20 +313,20 @@ func (p *parser) parseIdentList() []*ast.Ident {
 		defer un(trace(p, "IdentList"))
 	}
 
-	list := new(vector.Vector);
-	list.Push(p.parseIdent());
+	list := new(vector.Vector)
+	list.Push(p.parseIdent())
 	for p.tok == token.COMMA {
-		p.next();
-		list.Push(p.parseIdent());
+		p.next()
+		list.Push(p.parseIdent())
 	}
 
 	// convert vector
-	idents := make([]*ast.Ident, list.Len());
+	idents := make([]*ast.Ident, list.Len())
 	for i := 0; i < list.Len(); i++ {
 		idents[i] = list.At(i).(*ast.Ident)
 	}
 
-	return idents;
+	return idents
 }
 
 
@@ -335,20 +335,20 @@ func (p *parser) parseExprList() []ast.Expr {
 		defer un(trace(p, "ExpressionList"))
 	}
 
-	list := new(vector.Vector);
-	list.Push(p.parseExpr());
+	list := new(vector.Vector)
+	list.Push(p.parseExpr())
 	for p.tok == token.COMMA {
-		p.next();
-		list.Push(p.parseExpr());
+		p.next()
+		list.Push(p.parseExpr())
 	}
 
 	// convert list
-	exprs := make([]ast.Expr, list.Len());
+	exprs := make([]ast.Expr, list.Len())
 	for i := 0; i < list.Len(); i++ {
 		exprs[i] = list.At(i).(ast.Expr)
 	}
 
-	return exprs;
+	return exprs
 }
 
 
@@ -360,15 +360,15 @@ func (p *parser) parseType() ast.Expr {
 		defer un(trace(p, "Type"))
 	}
 
-	typ := p.tryType();
+	typ := p.tryType()
 
 	if typ == nil {
-		p.errorExpected(p.pos, "type");
-		p.next();	// make progress
-		return &ast.BadExpr{p.pos};
+		p.errorExpected(p.pos, "type")
+		p.next() // make progress
+		return &ast.BadExpr{p.pos}
 	}
 
-	return typ;
+	return typ
 }
 
 
@@ -377,14 +377,14 @@ func (p *parser) parseQualifiedIdent() ast.Expr {
 		defer un(trace(p, "QualifiedIdent"))
 	}
 
-	var x ast.Expr = p.parseIdent();
+	var x ast.Expr = p.parseIdent()
 	if p.tok == token.PERIOD {
 		// first identifier is a package identifier
-		p.next();
-		sel := p.parseIdent();
-		x = &ast.SelectorExpr{x, sel};
+		p.next()
+		sel := p.parseIdent()
+		x = &ast.SelectorExpr{x, sel}
 	}
-	return x;
+	return x
 }
 
 
@@ -393,7 +393,7 @@ func (p *parser) parseTypeName() ast.Expr {
 		defer un(trace(p, "TypeName"))
 	}
 
-	return p.parseQualifiedIdent();
+	return p.parseQualifiedIdent()
 }
 
 
@@ -402,33 +402,33 @@ func (p *parser) parseArrayType(ellipsisOk bool) ast.Expr {
 		defer un(trace(p, "ArrayType"))
 	}
 
-	lbrack := p.expect(token.LBRACK);
-	var len ast.Expr;
+	lbrack := p.expect(token.LBRACK)
+	var len ast.Expr
 	if ellipsisOk && p.tok == token.ELLIPSIS {
-		len = &ast.Ellipsis{p.pos};
-		p.next();
+		len = &ast.Ellipsis{p.pos}
+		p.next()
 	} else if p.tok != token.RBRACK {
 		len = p.parseExpr()
 	}
-	p.expect(token.RBRACK);
-	elt := p.parseType();
+	p.expect(token.RBRACK)
+	elt := p.parseType()
 
-	return &ast.ArrayType{lbrack, len, elt};
+	return &ast.ArrayType{lbrack, len, elt}
 }
 
 
 func (p *parser) makeIdentList(list *vector.Vector) []*ast.Ident {
-	idents := make([]*ast.Ident, list.Len());
+	idents := make([]*ast.Ident, list.Len())
 	for i := 0; i < list.Len(); i++ {
-		ident, isIdent := list.At(i).(*ast.Ident);
+		ident, isIdent := list.At(i).(*ast.Ident)
 		if !isIdent {
-			pos := list.At(i).(ast.Expr).Pos();
-			p.errorExpected(pos, "identifier");
-			idents[i] = &ast.Ident{pos, ""};
+			pos := list.At(i).(ast.Expr).Pos()
+			p.errorExpected(pos, "identifier")
+			idents[i] = &ast.Ident{pos, ""}
 		}
-		idents[i] = ident;
+		idents[i] = ident
 	}
-	return idents;
+	return idents
 }
 
 
@@ -437,13 +437,13 @@ func (p *parser) parseFieldDecl() *ast.Field {
 		defer un(trace(p, "FieldDecl"))
 	}
 
-	doc := p.leadComment;
+	doc := p.leadComment
 
 	// a list of identifiers looks like a list of type names
-	list := new(vector.Vector);
+	list := new(vector.Vector)
 	for {
 		// TODO(gri): do not allow ()'s here
-		list.Push(p.parseType());
+		list.Push(p.parseType())
 		if p.tok == token.COMMA {
 			p.next()
 		} else {
@@ -452,16 +452,16 @@ func (p *parser) parseFieldDecl() *ast.Field {
 	}
 
 	// if we had a list of identifiers, it must be followed by a type
-	typ := p.tryType();
+	typ := p.tryType()
 
 	// optional tag
-	var tag []*ast.BasicLit;
+	var tag []*ast.BasicLit
 	if p.tok == token.STRING {
 		tag = p.parseStringList(nil)
 	}
 
 	// analyze case
-	var idents []*ast.Ident;
+	var idents []*ast.Ident
 	if typ != nil {
 		// IdentifierList Type
 		idents = p.makeIdentList(list)
@@ -471,12 +471,12 @@ func (p *parser) parseFieldDecl() *ast.Field {
 			// TODO(gri): check that this looks like a type
 			typ = list.At(0).(ast.Expr)
 		} else {
-			p.errorExpected(p.pos, "anonymous field");
-			typ = &ast.BadExpr{p.pos};
+			p.errorExpected(p.pos, "anonymous field")
+			typ = &ast.BadExpr{p.pos}
 		}
 	}
 
-	return &ast.Field{doc, idents, typ, tag, nil};
+	return &ast.Field{doc, idents, typ, tag, nil}
 }
 
 
@@ -485,27 +485,27 @@ func (p *parser) parseStructType() *ast.StructType {
 		defer un(trace(p, "StructType"))
 	}
 
-	pos := p.expect(token.STRUCT);
-	lbrace := p.expect(token.LBRACE);
-	list := new(vector.Vector);
+	pos := p.expect(token.STRUCT)
+	lbrace := p.expect(token.LBRACE)
+	list := new(vector.Vector)
 	for p.tok == token.IDENT || p.tok == token.MUL {
-		f := p.parseFieldDecl();
+		f := p.parseFieldDecl()
 		if p.tok != token.RBRACE {
 			p.expect(token.SEMICOLON)
 		}
-		f.Comment = p.lineComment;
-		list.Push(f);
+		f.Comment = p.lineComment
+		list.Push(f)
 	}
-	rbrace := p.expect(token.RBRACE);
-	p.optSemi = true;
+	rbrace := p.expect(token.RBRACE)
+	p.optSemi = true
 
 	// convert vector
-	fields := make([]*ast.Field, list.Len());
+	fields := make([]*ast.Field, list.Len())
 	for i := list.Len() - 1; i >= 0; i-- {
 		fields[i] = list.At(i).(*ast.Field)
 	}
 
-	return &ast.StructType{pos, lbrace, fields, rbrace, false};
+	return &ast.StructType{pos, lbrace, fields, rbrace, false}
 }
 
 
@@ -514,35 +514,35 @@ func (p *parser) parsePointerType() *ast.StarExpr {
 		defer un(trace(p, "PointerType"))
 	}
 
-	star := p.expect(token.MUL);
-	base := p.parseType();
+	star := p.expect(token.MUL)
+	base := p.parseType()
 
-	return &ast.StarExpr{star, base};
+	return &ast.StarExpr{star, base}
 }
 
 
 func (p *parser) tryParameterType(ellipsisOk bool) ast.Expr {
 	if ellipsisOk && p.tok == token.ELLIPSIS {
-		pos := p.pos;
-		p.next();
+		pos := p.pos
+		p.next()
 		if p.tok != token.RPAREN {
 			// "..." always must be at the very end of a parameter list
 			p.Error(pos, "expected type, found '...'")
 		}
-		return &ast.Ellipsis{pos};
+		return &ast.Ellipsis{pos}
 	}
-	return p.tryType();
+	return p.tryType()
 }
 
 
 func (p *parser) parseParameterType(ellipsisOk bool) ast.Expr {
-	typ := p.tryParameterType(ellipsisOk);
+	typ := p.tryParameterType(ellipsisOk)
 	if typ == nil {
-		p.errorExpected(p.pos, "type");
-		p.next();	// make progress
-		typ = &ast.BadExpr{p.pos};
+		p.errorExpected(p.pos, "type")
+		p.next() // make progress
+		typ = &ast.BadExpr{p.pos}
 	}
-	return typ;
+	return typ
 }
 
 
@@ -552,10 +552,10 @@ func (p *parser) parseParameterDecl(ellipsisOk bool) (*vector.Vector, ast.Expr)
 	}
 
 	// a list of identifiers looks like a list of type names
-	list := new(vector.Vector);
+	list := new(vector.Vector)
 	for {
 		// TODO(gri): do not allow ()'s here
-		list.Push(p.parseParameterType(ellipsisOk));
+		list.Push(p.parseParameterType(ellipsisOk))
 		if p.tok == token.COMMA {
 			p.next()
 		} else {
@@ -564,9 +564,9 @@ func (p *parser) parseParameterDecl(ellipsisOk bool) (*vector.Vector, ast.Expr)
 	}
 
 	// if we had a list of identifiers, it must be followed by a type
-	typ := p.tryParameterType(ellipsisOk);
+	typ := p.tryParameterType(ellipsisOk)
 
-	return list, typ;
+	return list, typ
 }
 
 
@@ -575,18 +575,18 @@ func (p *parser) parseParameterList(ellipsisOk bool) []*ast.Field {
 		defer un(trace(p, "ParameterList"))
 	}
 
-	list, typ := p.parseParameterDecl(ellipsisOk);
+	list, typ := p.parseParameterDecl(ellipsisOk)
 	if typ != nil {
 		// IdentifierList Type
-		idents := p.makeIdentList(list);
-		list.Resize(0, 0);
-		list.Push(&ast.Field{nil, idents, typ, nil, nil});
+		idents := p.makeIdentList(list)
+		list.Resize(0, 0)
+		list.Push(&ast.Field{nil, idents, typ, nil, nil})
 
 		for p.tok == token.COMMA {
-			p.next();
-			idents := p.parseIdentList();
-			typ := p.parseParameterType(ellipsisOk);
-			list.Push(&ast.Field{nil, idents, typ, nil, nil});
+			p.next()
+			idents := p.parseIdentList()
+			typ := p.parseParameterType(ellipsisOk)
+			list.Push(&ast.Field{nil, idents, typ, nil, nil})
 		}
 
 	} else {
@@ -598,12 +598,12 @@ func (p *parser) parseParameterList(ellipsisOk bool) []*ast.Field {
 	}
 
 	// convert list
-	params := make([]*ast.Field, list.Len());
+	params := make([]*ast.Field, list.Len())
 	for i := 0; i < list.Len(); i++ {
 		params[i] = list.At(i).(*ast.Field)
 	}
 
-	return params;
+	return params
 }
 
 
@@ -612,14 +612,14 @@ func (p *parser) parseParameters(ellipsisOk bool) []*ast.Field {
 		defer un(trace(p, "Parameters"))
 	}
 
-	var params []*ast.Field;
-	p.expect(token.LPAREN);
+	var params []*ast.Field
+	p.expect(token.LPAREN)
 	if p.tok != token.RPAREN {
 		params = p.parseParameterList(ellipsisOk)
 	}
-	p.expect(token.RPAREN);
+	p.expect(token.RPAREN)
 
-	return params;
+	return params
 }
 
 
@@ -628,18 +628,18 @@ func (p *parser) parseResult() []*ast.Field {
 		defer un(trace(p, "Result"))
 	}
 
-	var results []*ast.Field;
+	var results []*ast.Field
 	if p.tok == token.LPAREN {
 		results = p.parseParameters(false)
 	} else if p.tok != token.FUNC {
-		typ := p.tryType();
+		typ := p.tryType()
 		if typ != nil {
-			results = make([]*ast.Field, 1);
-			results[0] = &ast.Field{Type: typ};
+			results = make([]*ast.Field, 1)
+			results[0] = &ast.Field{Type: typ}
 		}
 	}
 
-	return results;
+	return results
 }
 
 
@@ -648,10 +648,10 @@ func (p *parser) parseSignature() (params []*ast.Field, results []*ast.Field) {
 		defer un(trace(p, "Signature"))
 	}
 
-	params = p.parseParameters(true);
-	results = p.parseResult();
+	params = p.parseParameters(true)
+	results = p.parseResult()
 
-	return;
+	return
 }
 
 
@@ -660,10 +660,10 @@ func (p *parser) parseFuncType() *ast.FuncType {
 		defer un(trace(p, "FuncType"))
 	}
 
-	pos := p.expect(token.FUNC);
-	params, results := p.parseSignature();
+	pos := p.expect(token.FUNC)
+	params, results := p.parseSignature()
 
-	return &ast.FuncType{pos, params, results};
+	return &ast.FuncType{pos, params, results}
 }
 
 
@@ -672,21 +672,21 @@ func (p *parser) parseMethodSpec() *ast.Field {
 		defer un(trace(p, "MethodSpec"))
 	}
 
-	doc := p.leadComment;
-	var idents []*ast.Ident;
-	var typ ast.Expr;
-	x := p.parseQualifiedIdent();
+	doc := p.leadComment
+	var idents []*ast.Ident
+	var typ ast.Expr
+	x := p.parseQualifiedIdent()
 	if ident, isIdent := x.(*ast.Ident); isIdent && p.tok == token.LPAREN {
 		// method
-		idents = []*ast.Ident{ident};
-		params, results := p.parseSignature();
-		typ = &ast.FuncType{noPos, params, results};
+		idents = []*ast.Ident{ident}
+		params, results := p.parseSignature()
+		typ = &ast.FuncType{noPos, params, results}
 	} else {
 		// embedded interface
 		typ = x
 	}
 
-	return &ast.Field{doc, idents, typ, nil, nil};
+	return &ast.Field{doc, idents, typ, nil, nil}
 }
 
 
@@ -695,27 +695,27 @@ func (p *parser) parseInterfaceType() *ast.InterfaceType {
 		defer un(trace(p, "InterfaceType"))
 	}
 
-	pos := p.expect(token.INTERFACE);
-	lbrace := p.expect(token.LBRACE);
-	list := new(vector.Vector);
+	pos := p.expect(token.INTERFACE)
+	lbrace := p.expect(token.LBRACE)
+	list := new(vector.Vector)
 	for p.tok == token.IDENT {
-		m := p.parseMethodSpec();
+		m := p.parseMethodSpec()
 		if p.tok != token.RBRACE {
 			p.expect(token.SEMICOLON)
 		}
-		m.Comment = p.lineComment;
-		list.Push(m);
+		m.Comment = p.lineComment
+		list.Push(m)
 	}
-	rbrace := p.expect(token.RBRACE);
-	p.optSemi = true;
+	rbrace := p.expect(token.RBRACE)
+	p.optSemi = true
 
 	// convert vector
-	methods := make([]*ast.Field, list.Len());
+	methods := make([]*ast.Field, list.Len())
 	for i := list.Len() - 1; i >= 0; i-- {
 		methods[i] = list.At(i).(*ast.Field)
 	}
 
-	return &ast.InterfaceType{pos, lbrace, methods, rbrace, false};
+	return &ast.InterfaceType{pos, lbrace, methods, rbrace, false}
 }
 
 
@@ -724,13 +724,13 @@ func (p *parser) parseMapType() *ast.MapType {
 		defer un(trace(p, "MapType"))
 	}
 
-	pos := p.expect(token.MAP);
-	p.expect(token.LBRACK);
-	key := p.parseType();
-	p.expect(token.RBRACK);
-	value := p.parseType();
+	pos := p.expect(token.MAP)
+	p.expect(token.LBRACK)
+	key := p.parseType()
+	p.expect(token.RBRACK)
+	value := p.parseType()
 
-	return &ast.MapType{pos, key, value};
+	return &ast.MapType{pos, key, value}
 }
 
 
@@ -739,22 +739,22 @@ func (p *parser) parseChanType() *ast.ChanType {
 		defer un(trace(p, "ChanType"))
 	}
 
-	pos := p.pos;
-	dir := ast.SEND | ast.RECV;
+	pos := p.pos
+	dir := ast.SEND | ast.RECV
 	if p.tok == token.CHAN {
-		p.next();
+		p.next()
 		if p.tok == token.ARROW {
-			p.next();
-			dir = ast.SEND;
+			p.next()
+			dir = ast.SEND
 		}
 	} else {
-		p.expect(token.ARROW);
-		p.expect(token.CHAN);
-		dir = ast.RECV;
+		p.expect(token.ARROW)
+		p.expect(token.CHAN)
+		dir = ast.RECV
 	}
-	value := p.parseType();
+	value := p.parseType()
 
-	return &ast.ChanType{pos, dir, value};
+	return &ast.ChanType{pos, dir, value}
 }
 
 
@@ -777,30 +777,30 @@ func (p *parser) tryRawType(ellipsisOk bool) ast.Expr {
 	case token.CHAN, token.ARROW:
 		return p.parseChanType()
 	case token.LPAREN:
-		lparen := p.pos;
-		p.next();
-		typ := p.parseType();
-		rparen := p.expect(token.RPAREN);
-		return &ast.ParenExpr{lparen, typ, rparen};
+		lparen := p.pos
+		p.next()
+		typ := p.parseType()
+		rparen := p.expect(token.RPAREN)
+		return &ast.ParenExpr{lparen, typ, rparen}
 	}
 
 	// no type found
-	return nil;
+	return nil
 }
 
 
-func (p *parser) tryType() ast.Expr	{ return p.tryRawType(false) }
+func (p *parser) tryType() ast.Expr { return p.tryRawType(false) }
 
 
 // ----------------------------------------------------------------------------
 // Blocks
 
 func makeStmtList(list *vector.Vector) []ast.Stmt {
-	stats := make([]ast.Stmt, list.Len());
+	stats := make([]ast.Stmt, list.Len())
 	for i := 0; i < list.Len(); i++ {
 		stats[i] = list.At(i).(ast.Stmt)
 	}
-	return stats;
+	return stats
 }
 
 
@@ -809,24 +809,24 @@ func (p *parser) parseStmtList() []ast.Stmt {
 		defer un(trace(p, "StatementList"))
 	}
 
-	list := new(vector.Vector);
-	expectSemi := false;
+	list := new(vector.Vector)
+	expectSemi := false
 	for p.tok != token.CASE && p.tok != token.DEFAULT && p.tok != token.RBRACE && p.tok != token.EOF {
 		if expectSemi {
-			p.expect(token.SEMICOLON);
-			expectSemi = false;
+			p.expect(token.SEMICOLON)
+			expectSemi = false
 		}
-		list.Push(p.parseStmt());
+		list.Push(p.parseStmt())
 		if p.tok == token.SEMICOLON {
 			p.next()
 		} else if p.optSemi {
-			p.optSemi = false	// "consume" optional semicolon
+			p.optSemi = false // "consume" optional semicolon
 		} else {
 			expectSemi = true
 		}
 	}
 
-	return makeStmtList(list);
+	return makeStmtList(list)
 }
 
 
@@ -835,14 +835,14 @@ func (p *parser) parseBlockStmt(idents []*ast.Ident) *ast.BlockStmt {
 		defer un(trace(p, "BlockStmt"))
 	}
 
-	defer close(openScope(p));
+	defer close(openScope(p))
 
-	lbrace := p.expect(token.LBRACE);
-	list := p.parseStmtList();
-	rbrace := p.expect(token.RBRACE);
-	p.optSemi = true;
+	lbrace := p.expect(token.LBRACE)
+	list := p.parseStmtList()
+	rbrace := p.expect(token.RBRACE)
+	p.optSemi = true
 
-	return &ast.BlockStmt{lbrace, list, rbrace};
+	return &ast.BlockStmt{lbrace, list, rbrace}
 }
 
 
@@ -854,23 +854,23 @@ func (p *parser) parseStringList(x *ast.BasicLit) []*ast.BasicLit {
 		defer un(trace(p, "StringList"))
 	}
 
-	list := new(vector.Vector);
+	list := new(vector.Vector)
 	if x != nil {
 		list.Push(x)
 	}
 
 	for p.tok == token.STRING {
-		list.Push(&ast.BasicLit{p.pos, token.STRING, p.lit});
-		p.next();
+		list.Push(&ast.BasicLit{p.pos, token.STRING, p.lit})
+		p.next()
 	}
 
 	// convert list
-	strings := make([]*ast.BasicLit, list.Len());
+	strings := make([]*ast.BasicLit, list.Len())
 	for i := 0; i < list.Len(); i++ {
 		strings[i] = list.At(i).(*ast.BasicLit)
 	}
 
-	return strings;
+	return strings
 }
 
 
@@ -879,18 +879,18 @@ func (p *parser) parseFuncTypeOrLit() ast.Expr {
 		defer un(trace(p, "FuncTypeOrLit"))
 	}
 
-	typ := p.parseFuncType();
+	typ := p.parseFuncType()
 	if p.tok != token.LBRACE {
 		// function type only
 		return typ
 	}
 
-	p.exprLev++;
-	body := p.parseBlockStmt(nil);
-	p.optSemi = false;	// function body requires separating ";"
-	p.exprLev--;
+	p.exprLev++
+	body := p.parseBlockStmt(nil)
+	p.optSemi = false // function body requires separating ";"
+	p.exprLev--
 
-	return &ast.FuncLit{typ, body};
+	return &ast.FuncLit{typ, body}
 }
 
 
@@ -907,35 +907,35 @@ func (p *parser) parseOperand() ast.Expr {
 		return p.parseIdent()
 
 	case token.INT, token.FLOAT, token.CHAR, token.STRING:
-		x := &ast.BasicLit{p.pos, p.tok, p.lit};
-		p.next();
+		x := &ast.BasicLit{p.pos, p.tok, p.lit}
+		p.next()
 		if p.tok == token.STRING && p.tok == token.STRING {
 			return &ast.StringList{p.parseStringList(x)}
 		}
-		return x;
+		return x
 
 	case token.LPAREN:
-		lparen := p.pos;
-		p.next();
-		p.exprLev++;
-		x := p.parseExpr();
-		p.exprLev--;
-		rparen := p.expect(token.RPAREN);
-		return &ast.ParenExpr{lparen, x, rparen};
+		lparen := p.pos
+		p.next()
+		p.exprLev++
+		x := p.parseExpr()
+		p.exprLev--
+		rparen := p.expect(token.RPAREN)
+		return &ast.ParenExpr{lparen, x, rparen}
 
 	case token.FUNC:
 		return p.parseFuncTypeOrLit()
 
 	default:
-		t := p.tryRawType(true);	// could be type for composite literal or conversion
+		t := p.tryRawType(true) // could be type for composite literal or conversion
 		if t != nil {
 			return t
 		}
 	}
 
-	p.errorExpected(p.pos, "operand");
-	p.next();	// make progress
-	return &ast.BadExpr{p.pos};
+	p.errorExpected(p.pos, "operand")
+	p.next() // make progress
+	return &ast.BadExpr{p.pos}
 }
 
 
@@ -944,25 +944,25 @@ func (p *parser) parseSelectorOrTypeAssertion(x ast.Expr) ast.Expr {
 		defer un(trace(p, "SelectorOrTypeAssertion"))
 	}
 
-	p.expect(token.PERIOD);
+	p.expect(token.PERIOD)
 	if p.tok == token.IDENT {
 		// selector
-		sel := p.parseIdent();
-		return &ast.SelectorExpr{x, sel};
+		sel := p.parseIdent()
+		return &ast.SelectorExpr{x, sel}
 	}
 
 	// type assertion
-	p.expect(token.LPAREN);
-	var typ ast.Expr;
+	p.expect(token.LPAREN)
+	var typ ast.Expr
 	if p.tok == token.TYPE {
 		// type switch: typ == nil
 		p.next()
 	} else {
 		typ = p.parseType()
 	}
-	p.expect(token.RPAREN);
+	p.expect(token.RPAREN)
 
-	return &ast.TypeAssertExpr{x, typ};
+	return &ast.TypeAssertExpr{x, typ}
 }
 
 
@@ -971,23 +971,23 @@ func (p *parser) parseIndexOrSlice(x ast.Expr) ast.Expr {
 		defer un(trace(p, "IndexOrSlice"))
 	}
 
-	p.expect(token.LBRACK);
-	p.exprLev++;
-	index := p.parseExpr();
+	p.expect(token.LBRACK)
+	p.exprLev++
+	index := p.parseExpr()
 	if p.tok == token.COLON {
-		p.next();
-		var end ast.Expr;
+		p.next()
+		var end ast.Expr
 		if p.tok != token.RBRACK {
 			end = p.parseExpr()
 		}
-		x = &ast.SliceExpr{x, index, end};
+		x = &ast.SliceExpr{x, index, end}
 	} else {
 		x = &ast.IndexExpr{x, index}
 	}
-	p.exprLev--;
-	p.expect(token.RBRACK);
+	p.exprLev--
+	p.expect(token.RBRACK)
 
-	return x;
+	return x
 }
 
 
@@ -996,16 +996,16 @@ func (p *parser) parseCallOrConversion(fun ast.Expr) *ast.CallExpr {
 		defer un(trace(p, "CallOrConversion"))
 	}
 
-	lparen := p.expect(token.LPAREN);
-	p.exprLev++;
-	var args []ast.Expr;
+	lparen := p.expect(token.LPAREN)
+	p.exprLev++
+	var args []ast.Expr
 	if p.tok != token.RPAREN {
 		args = p.parseExprList()
 	}
-	p.exprLev--;
-	rparen := p.expect(token.RPAREN);
+	p.exprLev--
+	rparen := p.expect(token.RPAREN)
 
-	return &ast.CallExpr{fun, lparen, args, rparen};
+	return &ast.CallExpr{fun, lparen, args, rparen}
 }
 
 
@@ -1014,14 +1014,14 @@ func (p *parser) parseElement() ast.Expr {
 		defer un(trace(p, "Element"))
 	}
 
-	x := p.parseExpr();
+	x := p.parseExpr()
 	if p.tok == token.COLON {
-		colon := p.pos;
-		p.next();
-		x = &ast.KeyValueExpr{x, colon, p.parseExpr()};
+		colon := p.pos
+		p.next()
+		x = &ast.KeyValueExpr{x, colon, p.parseExpr()}
 	}
 
-	return x;
+	return x
 }
 
 
@@ -1030,9 +1030,9 @@ func (p *parser) parseElementList() []ast.Expr {
 		defer un(trace(p, "ElementList"))
 	}
 
-	list := new(vector.Vector);
+	list := new(vector.Vector)
 	for p.tok != token.RBRACE && p.tok != token.EOF {
-		list.Push(p.parseElement());
+		list.Push(p.parseElement())
 		if p.tok == token.COMMA {
 			p.next()
 		} else {
@@ -1041,12 +1041,12 @@ func (p *parser) parseElementList() []ast.Expr {
 	}
 
 	// convert list
-	elts := make([]ast.Expr, list.Len());
+	elts := make([]ast.Expr, list.Len())
 	for i := 0; i < list.Len(); i++ {
 		elts[i] = list.At(i).(ast.Expr)
 	}
 
-	return elts;
+	return elts
 }
 
 
@@ -1055,13 +1055,13 @@ func (p *parser) parseCompositeLit(typ ast.Expr) ast.Expr {
 		defer un(trace(p, "CompositeLit"))
 	}
 
-	lbrace := p.expect(token.LBRACE);
-	var elts []ast.Expr;
+	lbrace := p.expect(token.LBRACE)
+	var elts []ast.Expr
 	if p.tok != token.RBRACE {
 		elts = p.parseElementList()
 	}
-	rbrace := p.expect(token.RBRACE);
-	return &ast.CompositeLit{typ, lbrace, elts, rbrace};
+	rbrace := p.expect(token.RBRACE)
+	return &ast.CompositeLit{typ, lbrace, elts, rbrace}
 }
 
 
@@ -1087,24 +1087,24 @@ func (p *parser) checkExpr(x ast.Expr) ast.Expr {
 	case *ast.TypeAssertExpr:
 		if t.Type == nil {
 			// the form X.(type) is only allowed in type switch expressions
-			p.errorExpected(x.Pos(), "expression");
-			x = &ast.BadExpr{x.Pos()};
+			p.errorExpected(x.Pos(), "expression")
+			x = &ast.BadExpr{x.Pos()}
 		}
 	case *ast.CallExpr:
 	case *ast.StarExpr:
 	case *ast.UnaryExpr:
 		if t.Op == token.RANGE {
 			// the range operator is only allowed at the top of a for statement
-			p.errorExpected(x.Pos(), "expression");
-			x = &ast.BadExpr{x.Pos()};
+			p.errorExpected(x.Pos(), "expression")
+			x = &ast.BadExpr{x.Pos()}
 		}
 	case *ast.BinaryExpr:
 	default:
 		// all other nodes are not proper expressions
-		p.errorExpected(x.Pos(), "expression");
-		x = &ast.BadExpr{x.Pos()};
+		p.errorExpected(x.Pos(), "expression")
+		x = &ast.BadExpr{x.Pos()}
 	}
-	return x;
+	return x
 }
 
 
@@ -1115,13 +1115,13 @@ func isTypeName(x ast.Expr) bool {
 	case *ast.BadExpr:
 	case *ast.Ident:
 	case *ast.ParenExpr:
-		return isTypeName(t.X)	// TODO(gri): should (TypeName) be illegal?
+		return isTypeName(t.X) // TODO(gri): should (TypeName) be illegal?
 	case *ast.SelectorExpr:
 		return isTypeName(t.X)
 	default:
-		return false	// all other nodes are not type names
+		return false // all other nodes are not type names
 	}
-	return true;
+	return true
 }
 
 
@@ -1139,9 +1139,9 @@ func isCompositeLitType(x ast.Expr) bool {
 	case *ast.StructType:
 	case *ast.MapType:
 	default:
-		return false	// all other nodes are not legal composite literal types
+		return false // all other nodes are not legal composite literal types
 	}
-	return true;
+	return true
 }
 
 
@@ -1154,18 +1154,18 @@ func (p *parser) checkExprOrType(x ast.Expr) ast.Expr {
 	case *ast.UnaryExpr:
 		if t.Op == token.RANGE {
 			// the range operator is only allowed at the top of a for statement
-			p.errorExpected(x.Pos(), "expression");
-			x = &ast.BadExpr{x.Pos()};
+			p.errorExpected(x.Pos(), "expression")
+			x = &ast.BadExpr{x.Pos()}
 		}
 	case *ast.ArrayType:
 		if len, isEllipsis := t.Len.(*ast.Ellipsis); isEllipsis {
-			p.Error(len.Pos(), "expected array length, found '...'");
-			x = &ast.BadExpr{x.Pos()};
+			p.Error(len.Pos(), "expected array length, found '...'")
+			x = &ast.BadExpr{x.Pos()}
 		}
 	}
 
 	// all other nodes are expressions or types
-	return x;
+	return x
 }
 
 
@@ -1174,8 +1174,8 @@ func (p *parser) parsePrimaryExpr() ast.Expr {
 		defer un(trace(p, "PrimaryExpr"))
 	}
 
-	x := p.parseOperand();
-L:	for {
+	x := p.parseOperand()
+L: for {
 		switch p.tok {
 		case token.PERIOD:
 			x = p.parseSelectorOrTypeAssertion(p.checkExpr(x))
@@ -1194,7 +1194,7 @@ L:	for {
 		}
 	}
 
-	return x;
+	return x
 }
 
 
@@ -1205,20 +1205,20 @@ func (p *parser) parseUnaryExpr() ast.Expr {
 
 	switch p.tok {
 	case token.ADD, token.SUB, token.NOT, token.XOR, token.ARROW, token.AND, token.RANGE:
-		pos, op := p.pos, p.tok;
-		p.next();
-		x := p.parseUnaryExpr();
-		return &ast.UnaryExpr{pos, op, p.checkExpr(x)};
+		pos, op := p.pos, p.tok
+		p.next()
+		x := p.parseUnaryExpr()
+		return &ast.UnaryExpr{pos, op, p.checkExpr(x)}
 
 	case token.MUL:
 		// unary "*" expression or pointer type
-		pos := p.pos;
-		p.next();
-		x := p.parseUnaryExpr();
-		return &ast.StarExpr{pos, p.checkExprOrType(x)};
+		pos := p.pos
+		p.next()
+		x := p.parseUnaryExpr()
+		return &ast.StarExpr{pos, p.checkExprOrType(x)}
 	}
 
-	return p.parsePrimaryExpr();
+	return p.parsePrimaryExpr()
 }
 
 
@@ -1227,17 +1227,17 @@ func (p *parser) parseBinaryExpr(prec1 int) ast.Expr {
 		defer un(trace(p, "BinaryExpr"))
 	}
 
-	x := p.parseUnaryExpr();
+	x := p.parseUnaryExpr()
 	for prec := p.tok.Precedence(); prec >= prec1; prec-- {
 		for p.tok.Precedence() == prec {
-			pos, op := p.pos, p.tok;
-			p.next();
-			y := p.parseBinaryExpr(prec + 1);
-			x = &ast.BinaryExpr{p.checkExpr(x), pos, op, p.checkExpr(y)};
+			pos, op := p.pos, p.tok
+			p.next()
+			y := p.parseBinaryExpr(prec + 1)
+			x = &ast.BinaryExpr{p.checkExpr(x), pos, op, p.checkExpr(y)}
 		}
 	}
 
-	return x;
+	return x
 }
 
 
@@ -1248,7 +1248,7 @@ func (p *parser) parseExpr() ast.Expr {
 		defer un(trace(p, "Expression"))
 	}
 
-	return p.parseBinaryExpr(token.LowestPrec + 1);
+	return p.parseBinaryExpr(token.LowestPrec + 1)
 }
 
 
@@ -1261,19 +1261,19 @@ func (p *parser) parseSimpleStmt(labelOk bool) ast.Stmt {
 		defer un(trace(p, "SimpleStmt"))
 	}
 
-	x := p.parseExprList();
+	x := p.parseExprList()
 
 	switch p.tok {
 	case token.COLON:
 		// labeled statement
-		p.next();
+		p.next()
 		if labelOk && len(x) == 1 {
 			if label, isIdent := x[0].(*ast.Ident); isIdent {
 				return &ast.LabeledStmt{label, p.parseStmt()}
 			}
 		}
-		p.Error(x[0].Pos(), "illegal label declaration");
-		return &ast.BadStmt{x[0].Pos()};
+		p.Error(x[0].Pos(), "illegal label declaration")
+		return &ast.BadStmt{x[0].Pos()}
 
 	case
 		token.DEFINE, token.ASSIGN, token.ADD_ASSIGN,
@@ -1281,13 +1281,13 @@ func (p *parser) parseSimpleStmt(labelOk bool) ast.Stmt {
 		token.REM_ASSIGN, token.AND_ASSIGN, token.OR_ASSIGN,
 		token.XOR_ASSIGN, token.SHL_ASSIGN, token.SHR_ASSIGN, token.AND_NOT_ASSIGN:
 		// assignment statement
-		pos, tok := p.pos, p.tok;
-		p.next();
-		y := p.parseExprList();
+		pos, tok := p.pos, p.tok
+		p.next()
+		y := p.parseExprList()
 		if len(x) > 1 && len(y) > 1 && len(x) != len(y) {
 			p.Error(x[0].Pos(), "arity of lhs doesn't match rhs")
 		}
-		return &ast.AssignStmt{x, pos, tok, y};
+		return &ast.AssignStmt{x, pos, tok, y}
 	}
 
 	if len(x) > 1 {
@@ -1297,23 +1297,23 @@ func (p *parser) parseSimpleStmt(labelOk bool) ast.Stmt {
 
 	if p.tok == token.INC || p.tok == token.DEC {
 		// increment or decrement
-		s := &ast.IncDecStmt{x[0], p.tok};
-		p.next();	// consume "++" or "--"
-		return s;
+		s := &ast.IncDecStmt{x[0], p.tok}
+		p.next() // consume "++" or "--"
+		return s
 	}
 
 	// expression
-	return &ast.ExprStmt{x[0]};
+	return &ast.ExprStmt{x[0]}
 }
 
 
 func (p *parser) parseCallExpr() *ast.CallExpr {
-	x := p.parseExpr();
+	x := p.parseExpr()
 	if call, isCall := x.(*ast.CallExpr); isCall {
 		return call
 	}
-	p.errorExpected(x.Pos(), "function/method call");
-	return nil;
+	p.errorExpected(x.Pos(), "function/method call")
+	return nil
 }
 
 
@@ -1322,12 +1322,12 @@ func (p *parser) parseGoStmt() ast.Stmt {
 		defer un(trace(p, "GoStmt"))
 	}
 
-	pos := p.expect(token.GO);
-	call := p.parseCallExpr();
+	pos := p.expect(token.GO)
+	call := p.parseCallExpr()
 	if call != nil {
 		return &ast.GoStmt{pos, call}
 	}
-	return &ast.BadStmt{pos};
+	return &ast.BadStmt{pos}
 }
 
 
@@ -1336,12 +1336,12 @@ func (p *parser) parseDeferStmt() ast.Stmt {
 		defer un(trace(p, "DeferStmt"))
 	}
 
-	pos := p.expect(token.DEFER);
-	call := p.parseCallExpr();
+	pos := p.expect(token.DEFER)
+	call := p.parseCallExpr()
 	if call != nil {
 		return &ast.DeferStmt{pos, call}
 	}
-	return &ast.BadStmt{pos};
+	return &ast.BadStmt{pos}
 }
 
 
@@ -1350,14 +1350,14 @@ func (p *parser) parseReturnStmt() *ast.ReturnStmt {
 		defer un(trace(p, "ReturnStmt"))
 	}
 
-	pos := p.pos;
-	p.expect(token.RETURN);
-	var x []ast.Expr;
+	pos := p.pos
+	p.expect(token.RETURN)
+	var x []ast.Expr
 	if p.tok != token.SEMICOLON && p.tok != token.CASE && p.tok != token.DEFAULT && p.tok != token.RBRACE {
 		x = p.parseExprList()
 	}
 
-	return &ast.ReturnStmt{pos, x};
+	return &ast.ReturnStmt{pos, x}
 }
 
 
@@ -1366,13 +1366,13 @@ func (p *parser) parseBranchStmt(tok token.Token) *ast.BranchStmt {
 		defer un(trace(p, "BranchStmt"))
 	}
 
-	s := &ast.BranchStmt{p.pos, tok, nil};
-	p.expect(tok);
+	s := &ast.BranchStmt{p.pos, tok, nil}
+	p.expect(tok)
 	if tok != token.FALLTHROUGH && p.tok == token.IDENT {
 		s.Label = p.parseIdent()
 	}
 
-	return s;
+	return s
 }
 
 
@@ -1383,27 +1383,27 @@ func (p *parser) makeExpr(s ast.Stmt) ast.Expr {
 	if es, isExpr := s.(*ast.ExprStmt); isExpr {
 		return p.checkExpr(es.X)
 	}
-	p.Error(s.Pos(), "expected condition, found simple statement");
-	return &ast.BadExpr{s.Pos()};
+	p.Error(s.Pos(), "expected condition, found simple statement")
+	return &ast.BadExpr{s.Pos()}
 }
 
 
 func (p *parser) parseControlClause(isForStmt bool) (s1, s2, s3 ast.Stmt) {
 	if p.tok != token.LBRACE {
-		prevLev := p.exprLev;
-		p.exprLev = -1;
+		prevLev := p.exprLev
+		p.exprLev = -1
 
 		if p.tok != token.SEMICOLON {
 			s1 = p.parseSimpleStmt(false)
 		}
 		if p.tok == token.SEMICOLON {
-			p.next();
+			p.next()
 			if p.tok != token.LBRACE && p.tok != token.SEMICOLON {
 				s2 = p.parseSimpleStmt(false)
 			}
 			if isForStmt {
 				// for statements have a 3rd section
-				p.expect(token.SEMICOLON);
+				p.expect(token.SEMICOLON)
 				if p.tok != token.LBRACE {
 					s3 = p.parseSimpleStmt(false)
 				}
@@ -1412,10 +1412,10 @@ func (p *parser) parseControlClause(isForStmt bool) (s1, s2, s3 ast.Stmt) {
 			s1, s2 = nil, s1
 		}
 
-		p.exprLev = prevLev;
+		p.exprLev = prevLev
 	}
 
-	return s1, s2, s3;
+	return s1, s2, s3
 }
 
 
@@ -1425,18 +1425,18 @@ func (p *parser) parseIfStmt() *ast.IfStmt {
 	}
 
 	// IfStmt block
-	defer close(openScope(p));
+	defer close(openScope(p))
 
-	pos := p.expect(token.IF);
-	s1, s2, _ := p.parseControlClause(false);
-	body := p.parseBlockStmt(nil);
-	var else_ ast.Stmt;
+	pos := p.expect(token.IF)
+	s1, s2, _ := p.parseControlClause(false)
+	body := p.parseBlockStmt(nil)
+	var else_ ast.Stmt
 	if p.tok == token.ELSE {
-		p.next();
-		else_ = p.parseStmt();
+		p.next()
+		else_ = p.parseStmt()
 	}
 
-	return &ast.IfStmt{pos, s1, p.makeExpr(s2), body, else_};
+	return &ast.IfStmt{pos, s1, p.makeExpr(s2), body, else_}
 }
 
 
@@ -1446,22 +1446,22 @@ func (p *parser) parseCaseClause() *ast.CaseClause {
 	}
 
 	// CaseClause block
-	defer close(openScope(p));
+	defer close(openScope(p))
 
 	// SwitchCase
-	pos := p.pos;
-	var x []ast.Expr;
+	pos := p.pos
+	var x []ast.Expr
 	if p.tok == token.CASE {
-		p.next();
-		x = p.parseExprList();
+		p.next()
+		x = p.parseExprList()
 	} else {
 		p.expect(token.DEFAULT)
 	}
 
-	colon := p.expect(token.COLON);
-	body := p.parseStmtList();
+	colon := p.expect(token.COLON)
+	body := p.parseStmtList()
 
-	return &ast.CaseClause{pos, x, colon, body};
+	return &ast.CaseClause{pos, x, colon, body}
 }
 
 
@@ -1470,20 +1470,20 @@ func (p *parser) parseTypeList() []ast.Expr {
 		defer un(trace(p, "TypeList"))
 	}
 
-	list := new(vector.Vector);
-	list.Push(p.parseType());
+	list := new(vector.Vector)
+	list.Push(p.parseType())
 	for p.tok == token.COMMA {
-		p.next();
-		list.Push(p.parseType());
+		p.next()
+		list.Push(p.parseType())
 	}
 
 	// convert list
-	exprs := make([]ast.Expr, list.Len());
+	exprs := make([]ast.Expr, list.Len())
 	for i := 0; i < list.Len(); i++ {
 		exprs[i] = list.At(i).(ast.Expr)
 	}
 
-	return exprs;
+	return exprs
 }
 
 
@@ -1493,22 +1493,22 @@ func (p *parser) parseTypeCaseClause() *ast.TypeCaseClause {
 	}
 
 	// TypeCaseClause block
-	defer close(openScope(p));
+	defer close(openScope(p))
 
 	// TypeSwitchCase
-	pos := p.pos;
-	var types []ast.Expr;
+	pos := p.pos
+	var types []ast.Expr
 	if p.tok == token.CASE {
-		p.next();
-		types = p.parseTypeList();
+		p.next()
+		types = p.parseTypeList()
 	} else {
 		p.expect(token.DEFAULT)
 	}
 
-	colon := p.expect(token.COLON);
-	body := p.parseStmtList();
+	colon := p.expect(token.COLON)
+	body := p.parseStmtList()
 
-	return &ast.TypeCaseClause{pos, types, colon, body};
+	return &ast.TypeCaseClause{pos, types, colon, body}
 }
 
 
@@ -1518,11 +1518,11 @@ func isExprSwitch(s ast.Stmt) bool {
 	}
 	if e, ok := s.(*ast.ExprStmt); ok {
 		if a, ok := e.X.(*ast.TypeAssertExpr); ok {
-			return a.Type != nil	// regular type assertion
+			return a.Type != nil // regular type assertion
 		}
-		return true;
+		return true
 	}
-	return false;
+	return false
 }
 
 
@@ -1532,34 +1532,34 @@ func (p *parser) parseSwitchStmt() ast.Stmt {
 	}
 
 	// SwitchStmt block
-	defer close(openScope(p));
+	defer close(openScope(p))
 
-	pos := p.expect(token.SWITCH);
-	s1, s2, _ := p.parseControlClause(false);
+	pos := p.expect(token.SWITCH)
+	s1, s2, _ := p.parseControlClause(false)
 
 	if isExprSwitch(s2) {
-		lbrace := p.expect(token.LBRACE);
-		cases := new(vector.Vector);
+		lbrace := p.expect(token.LBRACE)
+		cases := new(vector.Vector)
 		for p.tok == token.CASE || p.tok == token.DEFAULT {
 			cases.Push(p.parseCaseClause())
 		}
-		rbrace := p.expect(token.RBRACE);
-		p.optSemi = true;
-		body := &ast.BlockStmt{lbrace, makeStmtList(cases), rbrace};
-		return &ast.SwitchStmt{pos, s1, p.makeExpr(s2), body};
+		rbrace := p.expect(token.RBRACE)
+		p.optSemi = true
+		body := &ast.BlockStmt{lbrace, makeStmtList(cases), rbrace}
+		return &ast.SwitchStmt{pos, s1, p.makeExpr(s2), body}
 	}
 
 	// type switch
 	// TODO(gri): do all the checks!
-	lbrace := p.expect(token.LBRACE);
-	cases := new(vector.Vector);
+	lbrace := p.expect(token.LBRACE)
+	cases := new(vector.Vector)
 	for p.tok == token.CASE || p.tok == token.DEFAULT {
 		cases.Push(p.parseTypeCaseClause())
 	}
-	rbrace := p.expect(token.RBRACE);
-	p.optSemi = true;
-	body := &ast.BlockStmt{lbrace, makeStmtList(cases), rbrace};
-	return &ast.TypeSwitchStmt{pos, s1, s2, body};
+	rbrace := p.expect(token.RBRACE)
+	p.optSemi = true
+	body := &ast.BlockStmt{lbrace, makeStmtList(cases), rbrace}
+	return &ast.TypeSwitchStmt{pos, s1, s2, body}
 }
 
 
@@ -1569,29 +1569,29 @@ func (p *parser) parseCommClause() *ast.CommClause {
 	}
 
 	// CommClause block
-	defer close(openScope(p));
+	defer close(openScope(p))
 
 	// CommCase
-	pos := p.pos;
-	var tok token.Token;
-	var lhs, rhs ast.Expr;
+	pos := p.pos
+	var tok token.Token
+	var lhs, rhs ast.Expr
 	if p.tok == token.CASE {
-		p.next();
+		p.next()
 		if p.tok == token.ARROW {
 			// RecvExpr without assignment
 			rhs = p.parseExpr()
 		} else {
 			// SendExpr or RecvExpr
-			rhs = p.parseExpr();
+			rhs = p.parseExpr()
 			if p.tok == token.ASSIGN || p.tok == token.DEFINE {
 				// RecvExpr with assignment
-				tok = p.tok;
-				p.next();
-				lhs = rhs;
+				tok = p.tok
+				p.next()
+				lhs = rhs
 				if p.tok == token.ARROW {
 					rhs = p.parseExpr()
 				} else {
-					p.expect(token.ARROW)	// use expect() error handling
+					p.expect(token.ARROW) // use expect() error handling
 				}
 			}
 			// else SendExpr
@@ -1600,10 +1600,10 @@ func (p *parser) parseCommClause() *ast.CommClause {
 		p.expect(token.DEFAULT)
 	}
 
-	colon := p.expect(token.COLON);
-	body := p.parseStmtList();
+	colon := p.expect(token.COLON)
+	body := p.parseStmtList()
 
-	return &ast.CommClause{pos, tok, lhs, rhs, colon, body};
+	return &ast.CommClause{pos, tok, lhs, rhs, colon, body}
 }
 
 
@@ -1612,17 +1612,17 @@ func (p *parser) parseSelectStmt() *ast.SelectStmt {
 		defer un(trace(p, "SelectStmt"))
 	}
 
-	pos := p.expect(token.SELECT);
-	lbrace := p.expect(token.LBRACE);
-	cases := new(vector.Vector);
+	pos := p.expect(token.SELECT)
+	lbrace := p.expect(token.LBRACE)
+	cases := new(vector.Vector)
 	for p.tok == token.CASE || p.tok == token.DEFAULT {
 		cases.Push(p.parseCommClause())
 	}
-	rbrace := p.expect(token.RBRACE);
-	p.optSemi = true;
-	body := &ast.BlockStmt{lbrace, makeStmtList(cases), rbrace};
+	rbrace := p.expect(token.RBRACE)
+	p.optSemi = true
+	body := &ast.BlockStmt{lbrace, makeStmtList(cases), rbrace}
 
-	return &ast.SelectStmt{pos, body};
+	return &ast.SelectStmt{pos, body}
 }
 
 
@@ -1632,49 +1632,49 @@ func (p *parser) parseForStmt() ast.Stmt {
 	}
 
 	// ForStmt block
-	defer close(openScope(p));
+	defer close(openScope(p))
 
-	pos := p.expect(token.FOR);
-	s1, s2, s3 := p.parseControlClause(true);
-	body := p.parseBlockStmt(nil);
+	pos := p.expect(token.FOR)
+	s1, s2, s3 := p.parseControlClause(true)
+	body := p.parseBlockStmt(nil)
 
 	if as, isAssign := s2.(*ast.AssignStmt); isAssign {
 		// possibly a for statement with a range clause; check assignment operator
 		if as.Tok != token.ASSIGN && as.Tok != token.DEFINE {
-			p.errorExpected(as.TokPos, "'=' or ':='");
-			return &ast.BadStmt{pos};
+			p.errorExpected(as.TokPos, "'=' or ':='")
+			return &ast.BadStmt{pos}
 		}
 		// check lhs
-		var key, value ast.Expr;
+		var key, value ast.Expr
 		switch len(as.Lhs) {
 		case 2:
-			value = as.Lhs[1];
-			fallthrough;
+			value = as.Lhs[1]
+			fallthrough
 		case 1:
 			key = as.Lhs[0]
 		default:
-			p.errorExpected(as.Lhs[0].Pos(), "1 or 2 expressions");
-			return &ast.BadStmt{pos};
+			p.errorExpected(as.Lhs[0].Pos(), "1 or 2 expressions")
+			return &ast.BadStmt{pos}
 		}
 		// check rhs
 		if len(as.Rhs) != 1 {
-			p.errorExpected(as.Rhs[0].Pos(), "1 expressions");
-			return &ast.BadStmt{pos};
+			p.errorExpected(as.Rhs[0].Pos(), "1 expressions")
+			return &ast.BadStmt{pos}
 		}
 		if rhs, isUnary := as.Rhs[0].(*ast.UnaryExpr); isUnary && rhs.Op == token.RANGE {
 			// rhs is range expression; check lhs
 			return &ast.RangeStmt{pos, key, value, as.TokPos, as.Tok, rhs.X, body}
 		} else {
-			p.errorExpected(s2.Pos(), "range clause");
-			return &ast.BadStmt{pos};
+			p.errorExpected(s2.Pos(), "range clause")
+			return &ast.BadStmt{pos}
 		}
 	} else {
 		// regular for statement
 		return &ast.ForStmt{pos, s1, p.makeExpr(s2), s3, body}
 	}
 
-	panic();	// unreachable
-	return nil;
+	panic() // unreachable
+	return nil
 }
 
 
@@ -1685,13 +1685,13 @@ func (p *parser) parseStmt() ast.Stmt {
 
 	switch p.tok {
 	case token.CONST, token.TYPE, token.VAR:
-		decl, _ := p.parseDecl(false);	// do not consume trailing semicolon
-		return &ast.DeclStmt{decl};
+		decl, _ := p.parseDecl(false) // do not consume trailing semicolon
+		return &ast.DeclStmt{decl}
 	case
 		// tokens that may start a top-level expression
-		token.IDENT, token.INT, token.FLOAT, token.CHAR, token.STRING, token.FUNC, token.LPAREN,	// operand
-		token.LBRACK, token.STRUCT,	// composite type
-		token.MUL, token.AND, token.ARROW, token.ADD, token.SUB, token.XOR:	// unary operators
+		token.IDENT, token.INT, token.FLOAT, token.CHAR, token.STRING, token.FUNC, token.LPAREN, // operand
+		token.LBRACK, token.STRUCT, // composite type
+		token.MUL, token.AND, token.ARROW, token.ADD, token.SUB, token.XOR: // unary operators
 		return p.parseSimpleStmt(true)
 	case token.GO:
 		return p.parseGoStmt()
@@ -1717,9 +1717,9 @@ func (p *parser) parseStmt() ast.Stmt {
 	}
 
 	// no statement found
-	p.errorExpected(p.pos, "statement");
-	p.next();	// make progress
-	return &ast.BadStmt{p.pos};
+	p.errorExpected(p.pos, "statement")
+	p.next() // make progress
+	return &ast.BadStmt{p.pos}
 }
 
 
@@ -1734,10 +1734,10 @@ type parseSpecFunction func(p *parser, doc *ast.CommentGroup, getSemi bool) (spe
 //
 func (p *parser) parseComment(getSemi bool) (comment *ast.CommentGroup, gotSemi bool) {
 	if getSemi && p.tok == token.SEMICOLON {
-		p.next();
-		gotSemi = true;
+		p.next()
+		gotSemi = true
 	}
-	return p.lineComment, gotSemi;
+	return p.lineComment, gotSemi
 }
 
 
@@ -1746,24 +1746,24 @@ func parseImportSpec(p *parser, doc *ast.CommentGroup, getSemi bool) (spec ast.S
 		defer un(trace(p, "ImportSpec"))
 	}
 
-	var ident *ast.Ident;
+	var ident *ast.Ident
 	if p.tok == token.PERIOD {
-		ident = &ast.Ident{p.pos, "."};
-		p.next();
+		ident = &ast.Ident{p.pos, "."}
+		p.next()
 	} else if p.tok == token.IDENT {
 		ident = p.parseIdent()
 	}
 
-	var path []*ast.BasicLit;
+	var path []*ast.BasicLit
 	if p.tok == token.STRING {
 		path = p.parseStringList(nil)
 	} else {
-		p.expect(token.STRING)	// use expect() error handling
+		p.expect(token.STRING) // use expect() error handling
 	}
 
-	comment, gotSemi := p.parseComment(getSemi);
+	comment, gotSemi := p.parseComment(getSemi)
 
-	return &ast.ImportSpec{doc, ident, path, comment}, gotSemi;
+	return &ast.ImportSpec{doc, ident, path, comment}, gotSemi
 }
 
 
@@ -1772,16 +1772,16 @@ func parseConstSpec(p *parser, doc *ast.CommentGroup, getSemi bool) (spec ast.Sp
 		defer un(trace(p, "ConstSpec"))
 	}
 
-	idents := p.parseIdentList();
-	typ := p.tryType();
-	var values []ast.Expr;
+	idents := p.parseIdentList()
+	typ := p.tryType()
+	var values []ast.Expr
 	if typ != nil || p.tok == token.ASSIGN {
-		p.expect(token.ASSIGN);
-		values = p.parseExprList();
+		p.expect(token.ASSIGN)
+		values = p.parseExprList()
 	}
-	comment, gotSemi := p.parseComment(getSemi);
+	comment, gotSemi := p.parseComment(getSemi)
 
-	return &ast.ValueSpec{doc, idents, typ, values, comment}, gotSemi;
+	return &ast.ValueSpec{doc, idents, typ, values, comment}, gotSemi
 }
 
 
@@ -1790,11 +1790,11 @@ func parseTypeSpec(p *parser, doc *ast.CommentGroup, getSemi bool) (spec ast.Spe
 		defer un(trace(p, "TypeSpec"))
 	}
 
-	ident := p.parseIdent();
-	typ := p.parseType();
-	comment, gotSemi := p.parseComment(getSemi);
+	ident := p.parseIdent()
+	typ := p.parseType()
+	comment, gotSemi := p.parseComment(getSemi)
 
-	return &ast.TypeSpec{doc, ident, typ, comment}, gotSemi;
+	return &ast.TypeSpec{doc, ident, typ, comment}, gotSemi
 }
 
 
@@ -1803,16 +1803,16 @@ func parseVarSpec(p *parser, doc *ast.CommentGroup, getSemi bool) (spec ast.Spec
 		defer un(trace(p, "VarSpec"))
 	}
 
-	idents := p.parseIdentList();
-	typ := p.tryType();
-	var values []ast.Expr;
+	idents := p.parseIdentList()
+	typ := p.tryType()
+	var values []ast.Expr
 	if typ == nil || p.tok == token.ASSIGN {
-		p.expect(token.ASSIGN);
-		values = p.parseExprList();
+		p.expect(token.ASSIGN)
+		values = p.parseExprList()
 	}
-	comment, gotSemi := p.parseComment(getSemi);
+	comment, gotSemi := p.parseComment(getSemi)
 
-	return &ast.ValueSpec{doc, idents, typ, values, comment}, gotSemi;
+	return &ast.ValueSpec{doc, idents, typ, values, comment}, gotSemi
 }
 
 
@@ -1821,42 +1821,42 @@ func (p *parser) parseGenDecl(keyword token.Token, f parseSpecFunction, getSemi
 		defer un(trace(p, keyword.String()+"Decl"))
 	}
 
-	doc := p.leadComment;
-	pos := p.expect(keyword);
-	var lparen, rparen token.Position;
-	list := new(vector.Vector);
+	doc := p.leadComment
+	pos := p.expect(keyword)
+	var lparen, rparen token.Position
+	list := new(vector.Vector)
 	if p.tok == token.LPAREN {
-		lparen = p.pos;
-		p.next();
+		lparen = p.pos
+		p.next()
 		for p.tok != token.RPAREN && p.tok != token.EOF {
-			doc := p.leadComment;
-			spec, semi := f(p, doc, true);	// consume semicolon if any
-			list.Push(spec);
+			doc := p.leadComment
+			spec, semi := f(p, doc, true) // consume semicolon if any
+			list.Push(spec)
 			if !semi {
 				break
 			}
 		}
-		rparen = p.expect(token.RPAREN);
+		rparen = p.expect(token.RPAREN)
 
 		if getSemi && p.tok == token.SEMICOLON {
-			p.next();
-			gotSemi = true;
+			p.next()
+			gotSemi = true
 		} else {
 			p.optSemi = true
 		}
 	} else {
-		spec, semi := f(p, nil, getSemi);
-		list.Push(spec);
-		gotSemi = semi;
+		spec, semi := f(p, nil, getSemi)
+		list.Push(spec)
+		gotSemi = semi
 	}
 
 	// convert vector
-	specs := make([]ast.Spec, list.Len());
+	specs := make([]ast.Spec, list.Len())
 	for i := 0; i < list.Len(); i++ {
 		specs[i] = list.At(i).(ast.Spec)
 	}
 
-	return &ast.GenDecl{doc, pos, keyword, lparen, specs, rparen}, gotSemi;
+	return &ast.GenDecl{doc, pos, keyword, lparen, specs, rparen}, gotSemi
 }
 
 
@@ -1865,19 +1865,19 @@ func (p *parser) parseReceiver() *ast.Field {
 		defer un(trace(p, "Receiver"))
 	}
 
-	pos := p.pos;
-	par := p.parseParameters(false);
+	pos := p.pos
+	par := p.parseParameters(false)
 
 	// must have exactly one receiver
 	if len(par) != 1 || len(par) == 1 && len(par[0].Names) > 1 {
-		p.errorExpected(pos, "exactly one receiver");
-		return &ast.Field{Type: &ast.BadExpr{noPos}};
+		p.errorExpected(pos, "exactly one receiver")
+		return &ast.Field{Type: &ast.BadExpr{noPos}}
 	}
 
-	recv := par[0];
+	recv := par[0]
 
 	// recv type must be TypeName or *TypeName
-	base := recv.Type;
+	base := recv.Type
 	if ptr, isPtr := base.(*ast.StarExpr); isPtr {
 		base = ptr.X
 	}
@@ -1885,7 +1885,7 @@ func (p *parser) parseReceiver() *ast.Field {
 		p.errorExpected(base.Pos(), "type name")
 	}
 
-	return recv;
+	return recv
 }
 
 
@@ -1894,23 +1894,23 @@ func (p *parser) parseFunctionDecl() *ast.FuncDecl {
 		defer un(trace(p, "FunctionDecl"))
 	}
 
-	doc := p.leadComment;
-	pos := p.expect(token.FUNC);
+	doc := p.leadComment
+	pos := p.expect(token.FUNC)
 
-	var recv *ast.Field;
+	var recv *ast.Field
 	if p.tok == token.LPAREN {
 		recv = p.parseReceiver()
 	}
 
-	ident := p.parseIdent();
-	params, results := p.parseSignature();
+	ident := p.parseIdent()
+	params, results := p.parseSignature()
 
-	var body *ast.BlockStmt;
+	var body *ast.BlockStmt
 	if p.tok == token.LBRACE {
 		body = p.parseBlockStmt(nil)
 	}
 
-	return &ast.FuncDecl{doc, recv, ident, &ast.FuncType{pos, params, results}, body};
+	return &ast.FuncDecl{doc, recv, ident, &ast.FuncType{pos, params, results}, body}
 }
 
 
@@ -1919,7 +1919,7 @@ func (p *parser) parseDecl(getSemi bool) (decl ast.Decl, gotSemi bool) {
 		defer un(trace(p, "Declaration"))
 	}
 
-	var f parseSpecFunction;
+	var f parseSpecFunction
 	switch p.tok {
 	case token.CONST:
 		f = parseConstSpec
@@ -1931,20 +1931,20 @@ func (p *parser) parseDecl(getSemi bool) (decl ast.Decl, gotSemi bool) {
 		f = parseVarSpec
 
 	case token.FUNC:
-		decl = p.parseFunctionDecl();
-		_, gotSemi := p.parseComment(getSemi);
-		return decl, gotSemi;
+		decl = p.parseFunctionDecl()
+		_, gotSemi := p.parseComment(getSemi)
+		return decl, gotSemi
 
 	default:
-		pos := p.pos;
-		p.errorExpected(pos, "declaration");
-		decl = &ast.BadDecl{pos};
-		gotSemi = getSemi && p.tok == token.SEMICOLON;
-		p.next();	// make progress in any case
-		return decl, gotSemi;
+		pos := p.pos
+		p.errorExpected(pos, "declaration")
+		decl = &ast.BadDecl{pos}
+		gotSemi = getSemi && p.tok == token.SEMICOLON
+		p.next() // make progress in any case
+		return decl, gotSemi
 	}
 
-	return p.parseGenDecl(p.tok, f, getSemi);
+	return p.parseGenDecl(p.tok, f, getSemi)
 }
 
 
@@ -1953,19 +1953,19 @@ func (p *parser) parseDeclList() []ast.Decl {
 		defer un(trace(p, "DeclList"))
 	}
 
-	list := new(vector.Vector);
+	list := new(vector.Vector)
 	for p.tok != token.EOF {
-		decl, _ := p.parseDecl(true);	// consume optional semicolon
-		list.Push(decl);
+		decl, _ := p.parseDecl(true) // consume optional semicolon
+		list.Push(decl)
 	}
 
 	// convert vector
-	decls := make([]ast.Decl, list.Len());
+	decls := make([]ast.Decl, list.Len())
 	for i := 0; i < list.Len(); i++ {
 		decls[i] = list.At(i).(ast.Decl)
 	}
 
-	return decls;
+	return decls
 }
 
 
@@ -1978,47 +1978,47 @@ func (p *parser) parseFile() *ast.File {
 	}
 
 	// file block
-	defer close(openScope(p));
+	defer close(openScope(p))
 
 	// package clause
-	doc := p.leadComment;
-	pos := p.expect(token.PACKAGE);
-	ident := p.parseIdent();
+	doc := p.leadComment
+	pos := p.expect(token.PACKAGE)
+	ident := p.parseIdent()
 
 	// Common error: semicolon after package clause.
 	// Accept and report it for better error synchronization.
 	if p.tok == token.SEMICOLON {
-		p.Error(p.pos, "expected declaration, found ';'");
-		p.next();
+		p.Error(p.pos, "expected declaration, found ';'")
+		p.next()
 	}
 
-	var decls []ast.Decl;
+	var decls []ast.Decl
 
 	// Don't bother parsing the rest if we had errors already.
 	// Likely not a Go source file at all.
 
 	if p.ErrorCount() == 0 && p.mode&PackageClauseOnly == 0 {
 		// import decls
-		list := new(vector.Vector);
+		list := new(vector.Vector)
 		for p.tok == token.IMPORT {
-			decl, _ := p.parseGenDecl(token.IMPORT, parseImportSpec, true);	// consume optional semicolon
-			list.Push(decl);
+			decl, _ := p.parseGenDecl(token.IMPORT, parseImportSpec, true) // consume optional semicolon
+			list.Push(decl)
 		}
 
 		if p.mode&ImportsOnly == 0 {
 			// rest of package body
 			for p.tok != token.EOF {
-				decl, _ := p.parseDecl(true);	// consume optional semicolon
-				list.Push(decl);
+				decl, _ := p.parseDecl(true) // consume optional semicolon
+				list.Push(decl)
 			}
 		}
 
 		// convert declaration list
-		decls = make([]ast.Decl, list.Len());
+		decls = make([]ast.Decl, list.Len())
 		for i := 0; i < list.Len(); i++ {
 			decls[i] = list.At(i).(ast.Decl)
 		}
 	}
 
-	return &ast.File{doc, pos, ident, decls, p.comments};
+	return &ast.File{doc, pos, ident, decls, p.comments}
 }
diff --git a/src/pkg/exp/parser/parser_test.go b/src/pkg/exp/parser/parser_test.go
index e012818157..2aefaa1cff 100644
--- a/src/pkg/exp/parser/parser_test.go
+++ b/src/pkg/exp/parser/parser_test.go
@@ -5,8 +5,8 @@
 package oldParser
 
 import (
-	"os";
-	"testing";
+	"os"
+	"testing"
 )
 
 
@@ -20,7 +20,7 @@ var illegalInputs = []interface{}{
 
 func TestParseIllegalInputs(t *testing.T) {
 	for _, src := range illegalInputs {
-		_, err := ParseFile("", src, 0);
+		_, err := ParseFile("", src, 0)
 		if err == nil {
 			t.Errorf("ParseFile(%v) should have failed", src)
 		}
@@ -37,7 +37,7 @@ var validPrograms = []interface{}{
 
 func TestParseValidPrograms(t *testing.T) {
 	for _, src := range validPrograms {
-		_, err := ParseFile("", src, 0);
+		_, err := ParseFile("", src, 0)
 		if err != nil {
 			t.Errorf("ParseFile(%q): %v", src, err)
 		}
@@ -52,8 +52,9 @@ var validFiles = []string{
 
 
 func TestParse3(t *testing.T) {
+	return // disabled since the parser only accepts old syntax
 	for _, filename := range validFiles {
-		_, err := ParseFile(filename, nil, 0);
+		_, err := ParseFile(filename, nil, 0)
 		if err != nil {
 			t.Errorf("ParseFile(%s): %v", filename, err)
 		}
@@ -69,16 +70,17 @@ func nameFilter(filename string) bool {
 	default:
 		return false
 	}
-	return true;
+	return true
 }
 
 
-func dirFilter(d *os.Dir) bool	{ return nameFilter(d.Name) }
+func dirFilter(d *os.Dir) bool { return nameFilter(d.Name) }
 
 
 func TestParse4(t *testing.T) {
-	path := ".";
-	pkg, err := ParsePackage(path, dirFilter, 0);
+	return // disabled since the parser only accepts old syntax
+	path := "."
+	pkg, err := ParsePackage(path, dirFilter, 0)
 	if err != nil {
 		t.Fatalf("ParsePackage(%s): %v", path, err)
 	}
diff --git a/src/pkg/exp/spacewar/pdp1.go b/src/pkg/exp/spacewar/pdp1.go
index d961030d92..e3abd6807f 100644
--- a/src/pkg/exp/spacewar/pdp1.go
+++ b/src/pkg/exp/spacewar/pdp1.go
@@ -57,10 +57,10 @@
 package pdp1
 
 import (
-	"bufio";
-	"fmt";
-	"os";
-	"io";
+	"bufio"
+	"fmt"
+	"os"
+	"io"
 )
 
 type Word uint32
@@ -69,82 +69,82 @@ const mask = 0777777
 const sign = 0400000
 
 const (
-	_	= iota;	// 00
-	opAND;
-	opIOR;
-	opXOR;
-	opXCT;
-	_;
-	_;
-	opCALJDA;
+	_ = iota // 00
+	opAND
+	opIOR
+	opXOR
+	opXCT
+	_
+	_
+	opCALJDA
 
-	opLAC;	// 10
-	opLIO;
-	opDAC;
-	opDAP;
-	_;
-	opDIO;
-	opDZM;
-	_;
+	opLAC // 10
+	opLIO
+	opDAC
+	opDAP
+	_
+	opDIO
+	opDZM
+	_
 
-	opADD;	// 20
-	opSUB;
-	opIDX;
-	opISP;
-	opSAD;
-	opSAS;
-	opMUS;
-	opDIS;
+	opADD // 20
+	opSUB
+	opIDX
+	opISP
+	opSAD
+	opSAS
+	opMUS
+	opDIS
 
-	opJMP;	// 30
-	opJSP;
-	opSKP;
-	opSFT;
-	opLAW;
-	opIOT;
-	_;
-	opOPR;
+	opJMP // 30
+	opJSP
+	opSKP
+	opSFT
+	opLAW
+	opIOT
+	_
+	opOPR
 )
 
 // A Trapper represents an object with a Trap method.
 // The machine calls the Trap method to implement the
 // PDP-1 IOT instruction.
 type Trapper interface {
-	Trap(y Word);
+	Trap(y Word)
 }
 
 // An M represents the machine state of a PDP-1.
 // Clients can set Display to install an output device.
 type M struct {
-	AC, IO, PC, OV	Word;
-	Mem		[010000]Word;
-	Flag		[7]bool;
-	Sense		[7]bool;
-	Halt		bool;
+	AC, IO, PC, OV Word
+	Mem            [010000]Word
+	Flag           [7]bool
+	Sense          [7]bool
+	Halt           bool
 }
 
 
 // Step runs a single machine instruction.
 func (m *M) Step(t Trapper) os.Error {
-	inst := m.Mem[m.PC];
-	m.PC++;
-	return m.run(inst, t);
+	inst := m.Mem[m.PC]
+	m.PC++
+	return m.run(inst, t)
 }
 
 // Normalize actual 32-bit integer i to 18-bit ones-complement integer.
 // Interpret mod 0777777, because 0777777 == -0 == +0 == 0000000.
 func norm(i Word) Word {
-	i += i >> 18;
-	i &= mask;
+	i += i >> 18
+	i &= mask
 	if i == mask {
 		i = 0
 	}
-	return i;
+	return i
 }
 
 type UnknownInstrError struct {
-	Inst	Word;
-	PC	Word;
+	Inst Word
+	PC   Word
 }
 
 func (e UnknownInstrError) String() string {
@@ -159,18 +159,18 @@ func (e HaltError) String() string {
 
 type LoopError Word
 
-func (e LoopError) String() string	{ return fmt.Sprintf("indirect load looping at %06o", e) }
+func (e LoopError) String() string { return fmt.Sprintf("indirect load looping at %06o", e) }
 
 func (m *M) run(inst Word, t Trapper) os.Error {
-	ib, y := (inst>>12)&1, inst&07777;
-	op := inst >> 13;
+	ib, y := (inst>>12)&1, inst&07777
+	op := inst >> 13
 	if op < opSKP && op != opCALJDA {
 		for n := 0; ib != 0; n++ {
 			if n > 07777 {
 				return LoopError(m.PC - 1)
 			}
-			ib = (m.Mem[y] >> 12) & 1;
-			y = m.Mem[y] & 07777;
+			ib = (m.Mem[y] >> 12) & 1
+			y = m.Mem[y] & 07777
 		}
 	}
 
@@ -184,13 +184,13 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 	case opXCT:
 		m.run(m.Mem[y], t)
 	case opCALJDA:
-		a := y;
+		a := y
 		if ib == 0 {
 			a = 64
 		}
-		m.Mem[a] = m.AC;
-		m.AC = (m.OV << 17) + m.PC;
-		m.PC = a + 1;
+		m.Mem[a] = m.AC
+		m.AC = (m.OV << 17) + m.PC
+		m.PC = a + 1
 	case opLAC:
 		m.AC = m.Mem[y]
 	case opLIO:
@@ -204,22 +204,22 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 	case opDZM:
 		m.Mem[y] = 0
 	case opADD:
-		m.AC += m.Mem[y];
-		m.OV = m.AC >> 18;
-		m.AC = norm(m.AC);
+		m.AC += m.Mem[y]
+		m.OV = m.AC >> 18
+		m.AC = norm(m.AC)
 	case opSUB:
-		diffSigns := (m.AC^m.Mem[y])>>17 == 1;
-		m.AC += m.Mem[y] ^ mask;
-		m.AC = norm(m.AC);
+		diffSigns := (m.AC^m.Mem[y])>>17 == 1
+		m.AC += m.Mem[y] ^ mask
+		m.AC = norm(m.AC)
 		if diffSigns && m.Mem[y]>>17 == m.AC>>17 {
 			m.OV = 1
 		}
 	case opIDX:
-		m.AC = norm(m.Mem[y] + 1);
-		m.Mem[y] = m.AC;
+		m.AC = norm(m.Mem[y] + 1)
+		m.Mem[y] = m.AC
 	case opISP:
-		m.AC = norm(m.Mem[y] + 1);
-		m.Mem[y] = m.AC;
+		m.AC = norm(m.Mem[y] + 1)
+		m.Mem[y] = m.AC
 		if m.AC&sign == 0 {
 			m.PC++
 		}
@@ -233,25 +233,25 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 		}
 	case opMUS:
 		if m.IO&1 == 1 {
-			m.AC += m.Mem[y];
-			m.AC = norm(m.AC);
+			m.AC += m.Mem[y]
+			m.AC = norm(m.AC)
 		}
-		m.IO = (m.IO>>1 | m.AC<<17) & mask;
-		m.AC >>= 1;
+		m.IO = (m.IO>>1 | m.AC<<17) & mask
+		m.AC >>= 1
 	case opDIS:
 		m.AC, m.IO = (m.AC<<1|m.IO>>17)&mask,
-			((m.IO<<1|m.AC>>17)&mask)^1;
+			((m.IO<<1|m.AC>>17)&mask)^1
 		if m.IO&1 == 1 {
 			m.AC = m.AC + (m.Mem[y] ^ mask)
 		} else {
 			m.AC = m.AC + 1 + m.Mem[y]
 		}
-		m.AC = norm(m.AC);
+		m.AC = norm(m.AC)
 	case opJMP:
 		m.PC = y
 	case opJSP:
-		m.AC = (m.OV << 17) + m.PC;
-		m.PC = y;
+		m.AC = (m.OV << 17) + m.PC
+		m.PC = y
 	case opSKP:
 		cond := y&0100 == 0100 && m.AC == 0 ||
 			y&0200 == 0200 && m.AC>>17 == 0 ||
@@ -260,7 +260,7 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 			y&02000 == 02000 && m.IO>>17 == 0 ||
 			y&7 != 0 && !m.Flag[y&7] ||
 			y&070 != 0 && !m.Sense[(y&070)>>3] ||
-			y&070 == 010;
+			y&070 == 010
 		if (ib == 0) == cond {
 			m.PC++
 		}
@@ -273,42 +273,42 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 				continue
 			}
 			switch (inst >> 9) & 017 {
-			case 001:	// rotate AC left
+			case 001: // rotate AC left
 				m.AC = (m.AC<<1 | m.AC>>17) & mask
-			case 002:	// rotate IO left
+			case 002: // rotate IO left
 				m.IO = (m.IO<<1 | m.IO>>17) & mask
-			case 003:	// rotate AC and IO left.
-				w := uint64(m.AC)<<18 | uint64(m.IO);
-				w = w<<1 | w>>35;
-				m.AC = Word(w>>18) & mask;
-				m.IO = Word(w) & mask;
-			case 005:	// shift AC left (excluding sign bit)
+			case 003: // rotate AC and IO left.
+				w := uint64(m.AC)<<18 | uint64(m.IO)
+				w = w<<1 | w>>35
+				m.AC = Word(w>>18) & mask
+				m.IO = Word(w) & mask
+			case 005: // shift AC left (excluding sign bit)
 				m.AC = (m.AC<<1|m.AC>>17)&mask&^sign | m.AC&sign
-			case 006:	// shift IO left (excluding sign bit)
+			case 006: // shift IO left (excluding sign bit)
 				m.IO = (m.IO<<1|m.IO>>17)&mask&^sign | m.IO&sign
-			case 007:	// shift AC and IO left (excluding AC's sign bit)
-				w := uint64(m.AC)<<18 | uint64(m.IO);
-				w = w<<1 | w>>35;
-				m.AC = Word(w>>18)&mask&^sign | m.AC&sign;
-				m.IO = Word(w)&mask&^sign | m.AC&sign;
-			case 011:	// rotate AC right
+			case 007: // shift AC and IO left (excluding AC's sign bit)
+				w := uint64(m.AC)<<18 | uint64(m.IO)
+				w = w<<1 | w>>35
+				m.AC = Word(w>>18)&mask&^sign | m.AC&sign
+				m.IO = Word(w)&mask&^sign | m.AC&sign
+			case 011: // rotate AC right
 				m.AC = (m.AC>>1 | m.AC<<17) & mask
-			case 012:	// rotate IO right
+			case 012: // rotate IO right
 				m.IO = (m.IO>>1 | m.IO<<17) & mask
-			case 013:	// rotate AC and IO right
-				w := uint64(m.AC)<<18 | uint64(m.IO);
-				w = w>>1 | w<<35;
-				m.AC = Word(w>>18) & mask;
-				m.IO = Word(w) & mask;
-			case 015:	// shift AC right (excluding sign bit)
+			case 013: // rotate AC and IO right
+				w := uint64(m.AC)<<18 | uint64(m.IO)
+				w = w>>1 | w<<35
+				m.AC = Word(w>>18) & mask
+				m.IO = Word(w) & mask
+			case 015: // shift AC right (excluding sign bit)
 				m.AC = m.AC>>1 | m.AC&sign
-			case 016:	// shift IO right (excluding sign bit)
+			case 016: // shift IO right (excluding sign bit)
 				m.IO = m.IO>>1 | m.IO&sign
-			case 017:	// shift AC and IO right (excluding AC's sign bit)
-				w := uint64(m.AC)<<18 | uint64(m.IO);
-				w = w >> 1;
-				m.AC = Word(w>>18) | m.AC&sign;
-				m.IO = Word(w) & mask;
+			case 017: // shift AC and IO right (excluding AC's sign bit)
+				w := uint64(m.AC)<<18 | uint64(m.IO)
+				w = w >> 1
+				m.AC = Word(w>>18) | m.AC&sign
+				m.IO = Word(w) & mask
 			default:
 				goto Unknown
 			}
@@ -332,8 +332,8 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 			m.AC ^= mask
 		}
 		if y&0400 == 0400 {
-			m.PC--;
-			return HaltError(m.PC);
+			m.PC--
+			return HaltError(m.PC)
 		}
 		switch i, f := y&7, y&010 == 010; {
 		case i == 7:
@@ -347,43 +347,43 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 	Unknown:
 		return UnknownInstrError{inst, m.PC - 1}
 	}
-	return nil;
+	return nil
 }
 
 // Load loads the machine's memory from a text input file
 // listing octal address-value pairs, one per line, matching the
 // regular expression ^[ +]([0-7]+)\t([0-7]+).
 func (m *M) Load(r io.Reader) os.Error {
-	b := bufio.NewReader(r);
+	b := bufio.NewReader(r)
 	for {
-		line, err := b.ReadString('\n');
+		line, err := b.ReadString('\n')
 		if err != nil {
 			if err != os.EOF {
 				return err
 			}
-			break;
+			break
 		}
 		// look for ^[ +]([0-9]+)\t([0-9]+)
 		if line[0] != ' ' && line[0] != '+' {
 			continue
 		}
-		i := 1;
-		a := Word(0);
+		i := 1
+		a := Word(0)
 		for ; i < len(line) && '0' <= line[i] && line[i] <= '7'; i++ {
 			a = a*8 + Word(line[i]-'0')
 		}
 		if i >= len(line) || line[i] != '\t' || i == 1 {
 			continue
 		}
-		v := Word(0);
-		j := i;
+		v := Word(0)
+		j := i
 		for i++; i < len(line) && '0' <= line[i] && line[i] <= '7'; i++ {
 			v = v*8 + Word(line[i]-'0')
 		}
 		if i == j {
 			continue
 		}
-		m.Mem[a] = v;
+		m.Mem[a] = v
 	}
-	return nil;
+	return nil
 }
diff --git a/src/pkg/exp/spacewar/spacewar.go b/src/pkg/exp/spacewar/spacewar.go
index 40976a4207..a86aa7f247 100644
--- a/src/pkg/exp/spacewar/spacewar.go
+++ b/src/pkg/exp/spacewar/spacewar.go
@@ -24,36 +24,36 @@
 package main
 
 import (
-	"bytes";
-	"exp/draw";
-	"exp/nacl/av";
-	"exp/nacl/srpc";
-	"image";
-	"log";
-	"os";
-	"runtime";
-	"strings";
-	"time";
-	"./pdp1";
+	"bytes"
+	"exp/draw"
+	"exp/nacl/av"
+	"exp/nacl/srpc"
+	"image"
+	"log"
+	"os"
+	"runtime"
+	"strings"
+	"time"
+	"./pdp1"
 )
 
 func main() {
-	runtime.LockOSThread();
+	runtime.LockOSThread()
 	if srpc.Enabled() {
 		go srpc.ServeRuntime()
 	}
 
-	w, err := av.Init(av.SubsystemVideo, 512, 512);
+	w, err := av.Init(av.SubsystemVideo, 512, 512)
 	if err != nil {
 		log.Exitf("av.Init: %s", err)
 	}
 
-	go quitter(w.QuitChan());
+	go quitter(w.QuitChan())
 
-	var m SpacewarPDP1;
-	m.Init(w);
-	m.PC = 4;
-	f := bytes.NewBuffer(strings.Bytes(spacewarCode));
+	var m SpacewarPDP1
+	m.Init(w)
+	m.PC = 4
+	f := bytes.NewBuffer(strings.Bytes(spacewarCode))
 	if err = m.Load(f); err != nil {
 		log.Exitf("loading %s: %s", "spacewar.lst", err)
 	}
@@ -63,12 +63,12 @@ func main() {
 		//	m.Mem[m.PC], m.AC, m.IO, m.OV);
 		err = m.Step()
 	}
-	log.Exitf("step: %s", err);
+	log.Exitf("step: %s", err)
 }
 
 func quitter(c <-chan bool) {
-	<-c;
-	os.Exit(0);
+	<-c
+	os.Exit(0)
 }
 
 // A SpacewarPDP1 is a PDP-1 machine configured to run Spacewar!
@@ -76,49 +76,49 @@ func quitter(c <-chan bool) {
 // display and pauses every second time the program counter reaches
 // instruction 02051.
 type SpacewarPDP1 struct {
-	pdp1.M;
-	nframe		int;
-	frameTime	int64;
-	ctxt		draw.Context;
-	dx, dy		int;
-	screen		draw.Image;
-	ctl		pdp1.Word;
-	kc		<-chan int;
-	colorModel	image.ColorModel;
-	cmap		[]image.Color;
-	pix		[][]uint8;
+	pdp1.M
+	nframe     int
+	frameTime  int64
+	ctxt       draw.Context
+	dx, dy     int
+	screen     draw.Image
+	ctl        pdp1.Word
+	kc         <-chan int
+	colorModel image.ColorModel
+	cmap       []image.Color
+	pix        [][]uint8
 }
 
 func min(a, b int) int {
 	if a < b {
 		return a
 	}
-	return b;
+	return b
 }
 
 func (m *SpacewarPDP1) Init(ctxt draw.Context) {
-	m.ctxt = ctxt;
-	m.kc = ctxt.KeyboardChan();
-	m.screen = ctxt.Screen();
-	m.dx = m.screen.Width();
-	m.dy = m.screen.Height();
-	m.colorModel = m.screen.ColorModel();
-	m.pix = make([][]uint8, m.dy);
+	m.ctxt = ctxt
+	m.kc = ctxt.KeyboardChan()
+	m.screen = ctxt.Screen()
+	m.dx = m.screen.Width()
+	m.dy = m.screen.Height()
+	m.colorModel = m.screen.ColorModel()
+	m.pix = make([][]uint8, m.dy)
 	for i := range m.pix {
 		m.pix[i] = make([]uint8, m.dx)
 	}
-	m.cmap = make([]image.Color, 256);
+	m.cmap = make([]image.Color, 256)
 	for i := range m.cmap {
-		var r, g, b uint8;
-		r = uint8(min(0, 255));
-		g = uint8(min(i*2, 255));
-		b = uint8(min(0, 255));
-		m.cmap[i] = m.colorModel.Convert(image.RGBAColor{r, g, b, 0xff});
+		var r, g, b uint8
+		r = uint8(min(0, 255))
+		g = uint8(min(i*2, 255))
+		b = uint8(min(0, 255))
+		m.cmap[i] = m.colorModel.Convert(image.RGBAColor{r, g, b, 0xff})
 	}
 }
 
 const (
-	frameDelay = 56 * 1e6;	// 56 ms
+	frameDelay = 56 * 1e6 // 56 ms
 )
 
 var ctlBits = [...]pdp1.Word{
@@ -134,35 +134,35 @@ var ctlBits = [...]pdp1.Word{
 
 func (m *SpacewarPDP1) Step() os.Error {
 	if m.PC == 02051 {
-		m.pollInput();
-		m.nframe++;
+		m.pollInput()
+		m.nframe++
 		if m.nframe&1 == 0 {
-			m.flush();
-			t := time.Nanoseconds();
+			m.flush()
+			t := time.Nanoseconds()
 			if t >= m.frameTime+3*frameDelay {
 				m.frameTime = t
 			} else {
-				m.frameTime += frameDelay;
+				m.frameTime += frameDelay
 				for t < m.frameTime {
-					time.Sleep(m.frameTime - t);
-					t = time.Nanoseconds();
+					time.Sleep(m.frameTime - t)
+					t = time.Nanoseconds()
 				}
 			}
 		}
 	}
-	return m.M.Step(m);
+	return m.M.Step(m)
 }
 
 func (m *SpacewarPDP1) Trap(y pdp1.Word) {
 	switch y & 077 {
 	case 7:
-		x := int(m.AC+0400000) & 0777777;
-		y := int(m.IO+0400000) & 0777777;
-		x = x * m.dx / 0777777;
-		y = y * m.dy / 0777777;
+		x := int(m.AC+0400000) & 0777777
+		y := int(m.IO+0400000) & 0777777
+		x = x * m.dx / 0777777
+		y = y * m.dy / 0777777
 		if 0 <= x && x < m.dx && 0 <= y && y < m.dy {
-			n := uint8(min(int(m.pix[y][x])+128, 255));
-			m.pix[y][x] = n;
+			n := uint8(min(int(m.pix[y][x])+128, 255))
+			m.pix[y][x] = n
 		}
 	case 011:
 		m.IO = m.ctl
@@ -173,11 +173,11 @@ func (m *SpacewarPDP1) flush() {
 	// Update screen image; simulate phosphor decay.
 	for y := 0; y < m.dy; y++ {
 		for x := 0; x < m.dx; x++ {
-			m.screen.Set(x, y, m.cmap[m.pix[y][x]]);
-			m.pix[y][x] >>= 1;
+			m.screen.Set(x, y, m.cmap[m.pix[y][x]])
+			m.pix[y][x] >>= 1
 		}
 	}
-	m.ctxt.FlushImage();
+	m.ctxt.FlushImage()
 }
 
 func (m *SpacewarPDP1) pollInput() {
diff --git a/src/pkg/expvar/expvar.go b/src/pkg/expvar/expvar.go
index 3a2e74b267..b8f9bae5d0 100644
--- a/src/pkg/expvar/expvar.go
+++ b/src/pkg/expvar/expvar.go
@@ -8,89 +8,89 @@
 package expvar
 
 import (
-	"bytes";
-	"fmt";
-	"http";
-	"log";
-	"strconv";
-	"sync";
+	"bytes"
+	"fmt"
+	"http"
+	"log"
+	"strconv"
+	"sync"
 )
 
 // Var is an abstract type for all exported variables.
 type Var interface {
-	String() string;
+	String() string
 }
 
 // Int is a 64-bit integer variable, and satisfies the Var interface.
 type Int struct {
-	i	int64;
-	mu	sync.Mutex;
+	i  int64
+	mu sync.Mutex
 }
 
-func (v *Int) String() string	{ return strconv.Itoa64(v.i) }
+func (v *Int) String() string { return strconv.Itoa64(v.i) }
 
 func (v *Int) Add(delta int64) {
-	v.mu.Lock();
-	defer v.mu.Unlock();
-	v.i += delta;
+	v.mu.Lock()
+	defer v.mu.Unlock()
+	v.i += delta
 }
 
 // Map is a string-to-Var map variable, and satisfies the Var interface.
 type Map struct {
-	m	map[string]Var;
-	mu	sync.Mutex;
+	m  map[string]Var
+	mu sync.Mutex
 }
 
 // KeyValue represents a single entry in a Map.
 type KeyValue struct {
-	Key	string;
-	Value	Var;
+	Key   string
+	Value Var
 }
 
 func (v *Map) String() string {
-	v.mu.Lock();
-	defer v.mu.Unlock();
-	b := new(bytes.Buffer);
-	fmt.Fprintf(b, "{");
-	first := true;
+	v.mu.Lock()
+	defer v.mu.Unlock()
+	b := new(bytes.Buffer)
+	fmt.Fprintf(b, "{")
+	first := true
 	for key, val := range v.m {
 		if !first {
 			fmt.Fprintf(b, ", ")
 		}
-		fmt.Fprintf(b, "\"%s\": %v", key, val.String());
-		first = false;
+		fmt.Fprintf(b, "\"%s\": %v", key, val.String())
+		first = false
 	}
-	fmt.Fprintf(b, "}");
-	return b.String();
+	fmt.Fprintf(b, "}")
+	return b.String()
 }
 
 func (v *Map) Init() *Map {
-	v.m = make(map[string]Var);
-	return v;
+	v.m = make(map[string]Var)
+	return v
 }
 
 func (v *Map) Get(key string) Var {
-	v.mu.Lock();
-	defer v.mu.Unlock();
+	v.mu.Lock()
+	defer v.mu.Unlock()
 	if av, ok := v.m[key]; ok {
 		return av
 	}
-	return nil;
+	return nil
 }
 
 func (v *Map) Set(key string, av Var) {
-	v.mu.Lock();
-	defer v.mu.Unlock();
-	v.m[key] = av;
+	v.mu.Lock()
+	defer v.mu.Unlock()
+	v.m[key] = av
 }
 
 func (v *Map) Add(key string, delta int64) {
-	v.mu.Lock();
-	defer v.mu.Unlock();
-	av, ok := v.m[key];
+	v.mu.Lock()
+	defer v.mu.Unlock()
+	av, ok := v.m[key]
 	if !ok {
-		av = new(Int);
-		v.m[key] = av;
+		av = new(Int)
+		v.m[key] = av
 	}
 
 	// Add to Int; ignore otherwise.
@@ -104,29 +104,29 @@ func (v *Map) iterate(c chan<- KeyValue) {
 	for k, v := range v.m {
 		c <- KeyValue{k, v}
 	}
-	close(c);
+	close(c)
 }
 
 func (v *Map) Iter() <-chan KeyValue {
-	c := make(chan KeyValue);
-	go v.iterate(c);
-	return c;
+	c := make(chan KeyValue)
+	go v.iterate(c)
+	return c
 }
 
 // String is a string variable, and satisfies the Var interface.
 type String struct {
-	s string;
+	s string
 }
 
-func (v *String) String() string	{ return strconv.Quote(v.s) }
+func (v *String) String() string { return strconv.Quote(v.s) }
 
-func (v *String) Set(value string)	{ v.s = value }
+func (v *String) Set(value string) { v.s = value }
 
 // IntFunc wraps a func() int64 to create a value that satisfies the Var interface.
 // The function will be called each time the Var is evaluated.
 type IntFunc func() int64
 
-func (v IntFunc) String() string	{ return strconv.Itoa64(v()) }
+func (v IntFunc) String() string { return strconv.Itoa64(v()) }
 
 
 // All published variables.
@@ -137,12 +137,12 @@ var mutex sync.Mutex
 // package's init function when it creates its Vars. If the name is already
 // registered then this will log.Crash.
 func Publish(name string, v Var) {
-	mutex.Lock();
-	defer mutex.Unlock();
+	mutex.Lock()
+	defer mutex.Unlock()
 	if _, existing := vars[name]; existing {
 		log.Crash("Reuse of exported var name:", name)
 	}
-	vars[name] = v;
+	vars[name] = v
 }
 
 // Get retrieves a named exported variable.
@@ -150,35 +150,35 @@ func Get(name string) Var {
 	if v, ok := vars[name]; ok {
 		return v
 	}
-	return nil;
+	return nil
 }
 
 // RemoveAll removes all exported variables.
 // This is for tests; don't call this on a real server.
 func RemoveAll() {
-	mutex.Lock();
-	defer mutex.Unlock();
-	vars = make(map[string]Var);
+	mutex.Lock()
+	defer mutex.Unlock()
+	vars = make(map[string]Var)
 }
 
 // Convenience functions for creating new exported variables.
 
 func NewInt(name string) *Int {
-	v := new(Int);
-	Publish(name, v);
-	return v;
+	v := new(Int)
+	Publish(name, v)
+	return v
 }
 
 func NewMap(name string) *Map {
-	v := new(Map).Init();
-	Publish(name, v);
-	return v;
+	v := new(Map).Init()
+	Publish(name, v)
+	return v
 }
 
 func NewString(name string) *String {
-	v := new(String);
-	Publish(name, v);
-	return v;
+	v := new(String)
+	Publish(name, v)
+	return v
 }
 
 // TODO(rsc): Make sure map access in separate thread is safe.
@@ -186,27 +186,27 @@ func iterate(c chan<- KeyValue) {
 	for k, v := range vars {
 		c <- KeyValue{k, v}
 	}
-	close(c);
+	close(c)
 }
 
 func Iter() <-chan KeyValue {
-	c := make(chan KeyValue);
-	go iterate(c);
-	return c;
+	c := make(chan KeyValue)
+	go iterate(c)
+	return c
 }
 
 func expvarHandler(c *http.Conn, req *http.Request) {
-	c.SetHeader("content-type", "application/json; charset=utf-8");
-	fmt.Fprintf(c, "{\n");
-	first := true;
+	c.SetHeader("content-type", "application/json; charset=utf-8")
+	fmt.Fprintf(c, "{\n")
+	first := true
 	for name, value := range vars {
 		if !first {
 			fmt.Fprintf(c, ",\n")
 		}
-		first = false;
-		fmt.Fprintf(c, "  %q: %s", name, value);
+		first = false
+		fmt.Fprintf(c, "  %q: %s", name, value)
 	}
-	fmt.Fprintf(c, "\n}\n");
+	fmt.Fprintf(c, "\n}\n")
 }
 
-func init()	{ http.Handle("/debug/vars", http.HandlerFunc(expvarHandler)) }
+func init() { http.Handle("/debug/vars", http.HandlerFunc(expvarHandler)) }
diff --git a/src/pkg/expvar/expvar_test.go b/src/pkg/expvar/expvar_test.go
index e64bdc2cc4..51930eb1d7 100644
--- a/src/pkg/expvar/expvar_test.go
+++ b/src/pkg/expvar/expvar_test.go
@@ -5,12 +5,12 @@
 package expvar
 
 import (
-	"json";
-	"testing";
+	"json"
+	"testing"
 )
 
 func TestInt(t *testing.T) {
-	reqs := NewInt("requests");
+	reqs := NewInt("requests")
 	if reqs.i != 0 {
 		t.Errorf("reqs.i = %v, want 4", reqs.i)
 	}
@@ -18,8 +18,8 @@ func TestInt(t *testing.T) {
 		t.Errorf("Get() failed.")
 	}
 
-	reqs.Add(1);
-	reqs.Add(3);
+	reqs.Add(1)
+	reqs.Add(3)
 	if reqs.i != 4 {
 		t.Errorf("reqs.i = %v, want 4", reqs.i)
 	}
@@ -30,12 +30,12 @@ func TestInt(t *testing.T) {
 }
 
 func TestString(t *testing.T) {
-	name := NewString("my-name");
+	name := NewString("my-name")
 	if name.s != "" {
 		t.Errorf("name.s = %q, want \"\"", name.s)
 	}
 
-	name.Set("Mike");
+	name.Set("Mike")
 	if name.s != "Mike" {
 		t.Errorf("name.s = %q, want \"Mike\"", name.s)
 	}
@@ -46,11 +46,11 @@ func TestString(t *testing.T) {
 }
 
 func TestMapCounter(t *testing.T) {
-	colours := NewMap("bike-shed-colours");
+	colours := NewMap("bike-shed-colours")
 
-	colours.Add("red", 1);
-	colours.Add("red", 2);
-	colours.Add("blue", 4);
+	colours.Add("red", 1)
+	colours.Add("red", 2)
+	colours.Add("blue", 4)
 	if x := colours.m["red"].(*Int).i; x != 3 {
 		t.Errorf("colours.m[\"red\"] = %v, want 3", x)
 	}
@@ -60,17 +60,17 @@ func TestMapCounter(t *testing.T) {
 
 	// colours.String() should be '{"red":3, "blue":4}',
 	// though the order of red and blue could vary.
-	s := colours.String();
-	j, err := json.Decode(s);
+	s := colours.String()
+	j, err := json.Decode(s)
 	if err != nil {
 		t.Errorf("colours.String() isn't valid JSON: %v", err)
 	}
-	m, ok := j.(map[string]interface{});
+	m, ok := j.(map[string]interface{})
 	if !ok {
 		t.Error("colours.String() didn't produce a map.")
 	}
-	red := m["red"];
-	x, ok := red.(float64);
+	red := m["red"]
+	x, ok := red.(float64)
 	if !ok {
 		t.Error("red.Kind() is not a number.")
 	}
@@ -80,13 +80,13 @@ func TestMapCounter(t *testing.T) {
 }
 
 func TestIntFunc(t *testing.T) {
-	x := int(4);
-	ix := IntFunc(func() int64 { return int64(x) });
+	x := int(4)
+	ix := IntFunc(func() int64 { return int64(x) })
 	if s := ix.String(); s != "4" {
 		t.Errorf("ix.String() = %v, want 4", s)
 	}
 
-	x++;
+	x++
 	if s := ix.String(); s != "5" {
 		t.Errorf("ix.String() = %v, want 5", s)
 	}
diff --git a/src/pkg/flag/flag.go b/src/pkg/flag/flag.go
index 86a3b3dc10..d57a59c033 100644
--- a/src/pkg/flag/flag.go
+++ b/src/pkg/flag/flag.go
@@ -48,9 +48,9 @@
 package flag
 
 import (
-	"fmt";
-	"os";
-	"strconv";
+	"fmt"
+	"os"
+	"strconv"
 )
 
 // TODO(r): BUG: atob belongs elsewhere
@@ -61,171 +61,171 @@ func atob(str string) (value bool, ok bool) {
 	case "0", "f", "F", "false", "FALSE", "False":
 		return false, true
 	}
-	return false, false;
+	return false, false
 }
 
 // -- Bool Value
 type boolValue struct {
-	p *bool;
+	p *bool
 }
 
 func newBoolValue(val bool, p *bool) *boolValue {
-	*p = val;
-	return &boolValue{p};
+	*p = val
+	return &boolValue{p}
 }
 
 func (b *boolValue) set(s string) bool {
-	v, ok := atob(s);
-	*b.p = v;
-	return ok;
+	v, ok := atob(s)
+	*b.p = v
+	return ok
 }
 
-func (b *boolValue) String() string	{ return fmt.Sprintf("%v", *b.p) }
+func (b *boolValue) String() string { return fmt.Sprintf("%v", *b.p) }
 
 // -- Int Value
 type intValue struct {
-	p *int;
+	p *int
 }
 
 func newIntValue(val int, p *int) *intValue {
-	*p = val;
-	return &intValue{p};
+	*p = val
+	return &intValue{p}
 }
 
 func (i *intValue) set(s string) bool {
-	v, err := strconv.Atoi(s);
-	*i.p = int(v);
-	return err == nil;
+	v, err := strconv.Atoi(s)
+	*i.p = int(v)
+	return err == nil
 }
 
-func (i *intValue) String() string	{ return fmt.Sprintf("%v", *i.p) }
+func (i *intValue) String() string { return fmt.Sprintf("%v", *i.p) }
 
 // -- Int64 Value
 type int64Value struct {
-	p *int64;
+	p *int64
 }
 
 func newInt64Value(val int64, p *int64) *int64Value {
-	*p = val;
-	return &int64Value{p};
+	*p = val
+	return &int64Value{p}
 }
 
 func (i *int64Value) set(s string) bool {
-	v, err := strconv.Atoi64(s);
-	*i.p = v;
-	return err == nil;
+	v, err := strconv.Atoi64(s)
+	*i.p = v
+	return err == nil
 }
 
-func (i *int64Value) String() string	{ return fmt.Sprintf("%v", *i.p) }
+func (i *int64Value) String() string { return fmt.Sprintf("%v", *i.p) }
 
 // -- Uint Value
 type uintValue struct {
-	p *uint;
+	p *uint
 }
 
 func newUintValue(val uint, p *uint) *uintValue {
-	*p = val;
-	return &uintValue{p};
+	*p = val
+	return &uintValue{p}
 }
 
 func (i *uintValue) set(s string) bool {
-	v, err := strconv.Atoui(s);
-	*i.p = uint(v);
-	return err == nil;
+	v, err := strconv.Atoui(s)
+	*i.p = uint(v)
+	return err == nil
 }
 
-func (i *uintValue) String() string	{ return fmt.Sprintf("%v", *i.p) }
+func (i *uintValue) String() string { return fmt.Sprintf("%v", *i.p) }
 
 // -- uint64 Value
 type uint64Value struct {
-	p *uint64;
+	p *uint64
 }
 
 func newUint64Value(val uint64, p *uint64) *uint64Value {
-	*p = val;
-	return &uint64Value{p};
+	*p = val
+	return &uint64Value{p}
 }
 
 func (i *uint64Value) set(s string) bool {
-	v, err := strconv.Atoui64(s);
-	*i.p = uint64(v);
-	return err == nil;
+	v, err := strconv.Atoui64(s)
+	*i.p = uint64(v)
+	return err == nil
 }
 
-func (i *uint64Value) String() string	{ return fmt.Sprintf("%v", *i.p) }
+func (i *uint64Value) String() string { return fmt.Sprintf("%v", *i.p) }
 
 // -- string Value
 type stringValue struct {
-	p *string;
+	p *string
 }
 
 func newStringValue(val string, p *string) *stringValue {
-	*p = val;
-	return &stringValue{p};
+	*p = val
+	return &stringValue{p}
 }
 
 func (s *stringValue) set(val string) bool {
-	*s.p = val;
-	return true;
+	*s.p = val
+	return true
 }
 
-func (s *stringValue) String() string	{ return fmt.Sprintf("%s", *s.p) }
+func (s *stringValue) String() string { return fmt.Sprintf("%s", *s.p) }
 
 // -- Float Value
 type floatValue struct {
-	p *float;
+	p *float
 }
 
 func newFloatValue(val float, p *float) *floatValue {
-	*p = val;
-	return &floatValue{p};
+	*p = val
+	return &floatValue{p}
 }
 
 func (f *floatValue) set(s string) bool {
-	v, err := strconv.Atof(s);
-	*f.p = v;
-	return err == nil;
+	v, err := strconv.Atof(s)
+	*f.p = v
+	return err == nil
 }
 
-func (f *floatValue) String() string	{ return fmt.Sprintf("%v", *f.p) }
+func (f *floatValue) String() string { return fmt.Sprintf("%v", *f.p) }
 
 // -- Float64 Value
 type float64Value struct {
-	p *float64;
+	p *float64
 }
 
 func newFloat64Value(val float64, p *float64) *float64Value {
-	*p = val;
-	return &float64Value{p};
+	*p = val
+	return &float64Value{p}
 }
 
 func (f *float64Value) set(s string) bool {
-	v, err := strconv.Atof64(s);
-	*f.p = v;
-	return err == nil;
+	v, err := strconv.Atof64(s)
+	*f.p = v
+	return err == nil
 }
 
-func (f *float64Value) String() string	{ return fmt.Sprintf("%v", *f.p) }
+func (f *float64Value) String() string { return fmt.Sprintf("%v", *f.p) }
 
 // FlagValue is the interface to the dynamic value stored in a flag.
 // (The default value is represented as a string.)
 type FlagValue interface {
-	String() string;
-	set(string) bool;
+	String() string
+	set(string) bool
 }
 
 // A Flag represents the state of a flag.
 type Flag struct {
-	Name		string;		// name as it appears on command line
-	Usage		string;		// help message
-	Value		FlagValue;	// value as set
-	DefValue	string;		// default value (as text); for usage message
+	Name     string    // name as it appears on command line
+	Usage    string    // help message
+	Value    FlagValue // value as set
+	DefValue string    // default value (as text); for usage message
 }
 
 type allFlags struct {
-	actual		map[string]*Flag;
-	formal		map[string]*Flag;
-	first_arg	int;	// 0 is the program name, 1 is first arg
+	actual    map[string]*Flag
+	formal    map[string]*Flag
+	first_arg int // 0 is the program name, 1 is first arg
 }
 
 var flags *allFlags = &allFlags{make(map[string]*Flag), make(map[string]*Flag), 1}
@@ -246,74 +246,74 @@ func Visit(fn func(*Flag)) {
 
 // Lookup returns the Flag structure of the named flag, returning nil if none exists.
 func Lookup(name string) *Flag {
-	f, ok := flags.formal[name];
+	f, ok := flags.formal[name]
 	if !ok {
 		return nil
 	}
-	return f;
+	return f
 }
 
 // Set sets the value of the named flag.  It returns true if the set succeeded; false if
 // there is no such flag defined.
 func Set(name, value string) bool {
-	f, ok := flags.formal[name];
+	f, ok := flags.formal[name]
 	if !ok {
 		return false
 	}
-	ok = f.Value.set(value);
+	ok = f.Value.set(value)
 	if !ok {
 		return false
 	}
-	flags.actual[name] = f;
-	return true;
+	flags.actual[name] = f
+	return true
 }
 
 // PrintDefaults prints to standard error the default values of all defined flags.
 func PrintDefaults() {
 	VisitAll(func(f *Flag) {
-		format := "  -%s=%s: %s\n";
+		format := "  -%s=%s: %s\n"
 		if _, ok := f.Value.(*stringValue); ok {
 			// put quotes on the value
 			format = "  -%s=%q: %s\n"
 		}
-		fmt.Fprintf(os.Stderr, format, f.Name, f.DefValue, f.Usage);
+		fmt.Fprintf(os.Stderr, format, f.Name, f.DefValue, f.Usage)
 	})
 }
 
 // Usage prints to standard error a default usage message documenting all defined flags.
 // The function is a variable that may be changed to point to a custom function.
 var Usage = func() {
-	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0]);
-	PrintDefaults();
+	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
+	PrintDefaults()
 }
 
-func NFlag() int	{ return len(flags.actual) }
+func NFlag() int { return len(flags.actual) }
 
 // Arg returns the i'th command-line argument.  Arg(0) is the first remaining argument
 // after flags have been processed.
 func Arg(i int) string {
-	i += flags.first_arg;
+	i += flags.first_arg
 	if i < 0 || i >= len(os.Args) {
 		return ""
 	}
-	return os.Args[i];
+	return os.Args[i]
 }
 
 // NArg is the number of arguments remaining after flags have been processed.
-func NArg() int	{ return len(os.Args) - flags.first_arg }
+func NArg() int { return len(os.Args) - flags.first_arg }
 
 // Args returns the non-flag command-line arguments.
-func Args() []string	{ return os.Args[flags.first_arg:] }
+func Args() []string { return os.Args[flags.first_arg:] }
 
 func add(name string, value FlagValue, usage string) {
 	// Remember the default value as a string; it won't change.
-	f := &Flag{name, usage, value, value.String()};
-	_, alreadythere := flags.formal[name];
+	f := &Flag{name, usage, value, value.String()}
+	_, alreadythere := flags.formal[name]
 	if alreadythere {
-		fmt.Fprintln(os.Stderr, "flag redefined:", name);
-		panic("flag redefinition");	// Happens only if flags are declared with identical names
+		fmt.Fprintln(os.Stderr, "flag redefined:", name)
+		panic("flag redefinition") // Happens only if flags are declared with identical names
 	}
-	flags.formal[name] = f;
+	flags.formal[name] = f
 }
 
 // BoolVar defines a bool flag with specified name, default value, and usage string.
@@ -325,9 +325,9 @@ func BoolVar(p *bool, name string, value bool, usage string) {
 // Bool defines a bool flag with specified name, default value, and usage string.
 // The return value is the address of a bool variable that stores the value of the flag.
 func Bool(name string, value bool, usage string) *bool {
-	p := new(bool);
-	BoolVar(p, name, value, usage);
-	return p;
+	p := new(bool)
+	BoolVar(p, name, value, usage)
+	return p
 }
 
 // IntVar defines an int flag with specified name, default value, and usage string.
@@ -339,9 +339,9 @@ func IntVar(p *int, name string, value int, usage string) {
 // Int defines an int flag with specified name, default value, and usage string.
 // The return value is the address of an int variable that stores the value of the flag.
 func Int(name string, value int, usage string) *int {
-	p := new(int);
-	IntVar(p, name, value, usage);
-	return p;
+	p := new(int)
+	IntVar(p, name, value, usage)
+	return p
 }
 
 // Int64Var defines an int64 flag with specified name, default value, and usage string.
@@ -353,9 +353,9 @@ func Int64Var(p *int64, name string, value int64, usage string) {
 // Int64 defines an int64 flag with specified name, default value, and usage string.
 // The return value is the address of an int64 variable that stores the value of the flag.
 func Int64(name string, value int64, usage string) *int64 {
-	p := new(int64);
-	Int64Var(p, name, value, usage);
-	return p;
+	p := new(int64)
+	Int64Var(p, name, value, usage)
+	return p
 }
 
 // UintVar defines a uint flag with specified name, default value, and usage string.
@@ -367,9 +367,9 @@ func UintVar(p *uint, name string, value uint, usage string) {
 // Uint defines a uint flag with specified name, default value, and usage string.
 // The return value is the address of a uint variable that stores the value of the flag.
 func Uint(name string, value uint, usage string) *uint {
-	p := new(uint);
-	UintVar(p, name, value, usage);
-	return p;
+	p := new(uint)
+	UintVar(p, name, value, usage)
+	return p
 }
 
 // Uint64Var defines a uint64 flag with specified name, default value, and usage string.
@@ -381,9 +381,9 @@ func Uint64Var(p *uint64, name string, value uint64, usage string) {
 // Uint64 defines a uint64 flag with specified name, default value, and usage string.
 // The return value is the address of a uint64 variable that stores the value of the flag.
 func Uint64(name string, value uint64, usage string) *uint64 {
-	p := new(uint64);
-	Uint64Var(p, name, value, usage);
-	return p;
+	p := new(uint64)
+	Uint64Var(p, name, value, usage)
+	return p
 }
 
 // StringVar defines a string flag with specified name, default value, and usage string.
@@ -395,9 +395,9 @@ func StringVar(p *string, name, value string, usage string) {
 // String defines a string flag with specified name, default value, and usage string.
 // The return value is the address of a string variable that stores the value of the flag.
 func String(name, value string, usage string) *string {
-	p := new(string);
-	StringVar(p, name, value, usage);
-	return p;
+	p := new(string)
+	StringVar(p, name, value, usage)
+	return p
 }
 
 // FloatVar defines a float flag with specified name, default value, and usage string.
@@ -409,9 +409,9 @@ func FloatVar(p *float, name string, value float, usage string) {
 // Float defines a float flag with specified name, default value, and usage string.
 // The return value is the address of a float variable that stores the value of the flag.
 func Float(name string, value float, usage string) *float {
-	p := new(float);
-	FloatVar(p, name, value, usage);
-	return p;
+	p := new(float)
+	FloatVar(p, name, value, usage)
+	return p
 }
 
 // Float64Var defines a float64 flag with specified name, default value, and usage string.
@@ -423,68 +423,68 @@ func Float64Var(p *float64, name string, value float64, usage string) {
 // Float64 defines a float64 flag with specified name, default value, and usage string.
 // The return value is the address of a float64 variable that stores the value of the flag.
 func Float64(name string, value float64, usage string) *float64 {
-	p := new(float64);
-	Float64Var(p, name, value, usage);
-	return p;
+	p := new(float64)
+	Float64Var(p, name, value, usage)
+	return p
 }
 
 
 func (f *allFlags) parseOne(index int) (ok bool, next int) {
-	s := os.Args[index];
-	f.first_arg = index;	// until proven otherwise
+	s := os.Args[index]
+	f.first_arg = index // until proven otherwise
 	if len(s) == 0 {
 		return false, -1
 	}
 	if s[0] != '-' {
 		return false, -1
 	}
-	num_minuses := 1;
+	num_minuses := 1
 	if len(s) == 1 {
 		return false, index
 	}
 	if s[1] == '-' {
-		num_minuses++;
-		if len(s) == 2 {	// "--" terminates the flags
+		num_minuses++
+		if len(s) == 2 { // "--" terminates the flags
 			return false, index + 1
 		}
 	}
-	name := s[num_minuses:];
+	name := s[num_minuses:]
 	if len(name) == 0 || name[0] == '-' || name[0] == '=' {
-		fmt.Fprintln(os.Stderr, "bad flag syntax:", s);
-		Usage();
-		os.Exit(2);
+		fmt.Fprintln(os.Stderr, "bad flag syntax:", s)
+		Usage()
+		os.Exit(2)
 	}
 
 	// it's a flag. does it have an argument?
-	has_value := false;
-	value := "";
-	for i := 1; i < len(name); i++ {	// equals cannot be first
+	has_value := false
+	value := ""
+	for i := 1; i < len(name); i++ { // equals cannot be first
 		if name[i] == '=' {
-			value = name[i+1:];
-			has_value = true;
-			name = name[0:i];
-			break;
+			value = name[i+1:]
+			has_value = true
+			name = name[0:i]
+			break
 		}
 	}
-	flag, alreadythere := flags.actual[name];
+	flag, alreadythere := flags.actual[name]
 	if alreadythere {
-		fmt.Fprintf(os.Stderr, "flag specified twice: -%s\n", name);
-		Usage();
-		os.Exit(2);
+		fmt.Fprintf(os.Stderr, "flag specified twice: -%s\n", name)
+		Usage()
+		os.Exit(2)
 	}
-	m := flags.formal;
-	flag, alreadythere = m[name];	// BUG
+	m := flags.formal
+	flag, alreadythere = m[name] // BUG
 	if !alreadythere {
-		fmt.Fprintf(os.Stderr, "flag provided but not defined: -%s\n", name);
-		Usage();
-		os.Exit(2);
+		fmt.Fprintf(os.Stderr, "flag provided but not defined: -%s\n", name)
+		Usage()
+		os.Exit(2)
 	}
-	if f, ok := flag.Value.(*boolValue); ok {	// special case: doesn't need an arg
+	if f, ok := flag.Value.(*boolValue); ok { // special case: doesn't need an arg
 		if has_value {
 			if !f.set(value) {
-				fmt.Fprintf(os.Stderr, "invalid boolean value %t for flag: -%s\n", value, name);
-				Usage();
-				os.Exit(2);
+				fmt.Fprintf(os.Stderr, "invalid boolean value %t for flag: -%s\n", value, name)
+				Usage()
+				os.Exit(2)
 			}
 		} else {
 			f.set("true")
@@ -493,34 +493,34 @@ func (f *allFlags) parseOne(index int) (ok bool, next int) {
 		// It must have a value, which might be the next argument.
 		if !has_value && index < len(os.Args)-1 {
 			// value is the next arg
-			has_value = true;
-			index++;
-			value = os.Args[index];
+			has_value = true
+			index++
+			value = os.Args[index]
 		}
 		if !has_value {
-			fmt.Fprintf(os.Stderr, "flag needs an argument: -%s\n", name);
-			Usage();
-			os.Exit(2);
+			fmt.Fprintf(os.Stderr, "flag needs an argument: -%s\n", name)
+			Usage()
+			os.Exit(2)
 		}
-		ok = flag.Value.set(value);
+		ok = flag.Value.set(value)
 		if !ok {
-			fmt.Fprintf(os.Stderr, "invalid value %s for flag: -%s\n", value, name);
-			Usage();
-			os.Exit(2);
+			fmt.Fprintf(os.Stderr, "invalid value %s for flag: -%s\n", value, name)
+			Usage()
+			os.Exit(2)
 		}
 	}
-	flags.actual[name] = flag;
-	return true, index + 1;
+	flags.actual[name] = flag
+	return true, index + 1
 }
 
 // Parse parses the command-line flags.  Must be called after all flags are defined
 // and before any are accessed by the program.
 func Parse() {
 	for i := 1; i < len(os.Args); {
-		ok, next := flags.parseOne(i);
+		ok, next := flags.parseOne(i)
 		if next > 0 {
-			flags.first_arg = next;
-			i = next;
+			flags.first_arg = next
+			i = next
 		}
 		if !ok {
 			break
diff --git a/src/pkg/flag/flag_test.go b/src/pkg/flag/flag_test.go
index 0acfc2f96f..d6e642b2b9 100644
--- a/src/pkg/flag/flag_test.go
+++ b/src/pkg/flag/flag_test.go
@@ -5,35 +5,35 @@
 package flag_test
 
 import (
-	. "flag";
-	"testing";
+	. "flag"
+	"testing"
 )
 
 var (
-	test_bool	= Bool("test_bool", false, "bool value");
-	test_int	= Int("test_int", 0, "int value");
-	test_int64	= Int64("test_int64", 0, "int64 value");
-	test_uint	= Uint("test_uint", 0, "uint value");
-	test_uint64	= Uint64("test_uint64", 0, "uint64 value");
-	test_string	= String("test_string", "0", "string value");
-	test_float	= Float("test_float", 0, "float value");
-	test_float64	= Float("test_float64", 0, "float64 value");
+	test_bool    = Bool("test_bool", false, "bool value")
+	test_int     = Int("test_int", 0, "int value")
+	test_int64   = Int64("test_int64", 0, "int64 value")
+	test_uint    = Uint("test_uint", 0, "uint value")
+	test_uint64  = Uint64("test_uint64", 0, "uint64 value")
+	test_string  = String("test_string", "0", "string value")
+	test_float   = Float("test_float", 0, "float value")
+	test_float64 = Float("test_float64", 0, "float64 value")
 )
 
 func boolString(s string) string {
 	if s == "0" {
 		return "false"
 	}
-	return "true";
+	return "true"
 }
 
 func TestEverything(t *testing.T) {
-	m := make(map[string]*Flag);
-	desired := "0";
+	m := make(map[string]*Flag)
+	desired := "0"
 	visitor := func(f *Flag) {
 		if len(f.Name) > 5 && f.Name[0:5] == "test_" {
-			m[f.Name] = f;
-			ok := false;
+			m[f.Name] = f
+			ok := false
 			switch {
 			case f.Value.String() == desired:
 				ok = true
@@ -44,35 +44,35 @@ func TestEverything(t *testing.T) {
 				t.Error("Visit: bad value", f.Value.String(), "for", f.Name)
 			}
 		}
-	};
-	VisitAll(visitor);
+	}
+	VisitAll(visitor)
 	if len(m) != 8 {
-		t.Error("VisitAll misses some flags");
+		t.Error("VisitAll misses some flags")
 		for k, v := range m {
 			t.Log(k, *v)
 		}
 	}
-	m = make(map[string]*Flag);
-	Visit(visitor);
+	m = make(map[string]*Flag)
+	Visit(visitor)
 	if len(m) != 0 {
-		t.Errorf("Visit sees unset flags");
+		t.Errorf("Visit sees unset flags")
 		for k, v := range m {
 			t.Log(k, *v)
 		}
 	}
 	// Now set all flags
-	Set("test_bool", "true");
-	Set("test_int", "1");
-	Set("test_int64", "1");
-	Set("test_uint", "1");
-	Set("test_uint64", "1");
-	Set("test_string", "1");
-	Set("test_float", "1");
-	Set("test_float64", "1");
-	desired = "1";
-	Visit(visitor);
+	Set("test_bool", "true")
+	Set("test_int", "1")
+	Set("test_int64", "1")
+	Set("test_uint", "1")
+	Set("test_uint64", "1")
+	Set("test_string", "1")
+	Set("test_float", "1")
+	Set("test_float64", "1")
+	desired = "1"
+	Visit(visitor)
 	if len(m) != 8 {
-		t.Error("Visit fails after set");
+		t.Error("Visit fails after set")
 		for k, v := range m {
 			t.Log(k, *v)
 		}
diff --git a/src/pkg/fmt/fmt_test.go b/src/pkg/fmt/fmt_test.go
index 51a159ff1d..78d4cf29a3 100644
--- a/src/pkg/fmt/fmt_test.go
+++ b/src/pkg/fmt/fmt_test.go
@@ -5,27 +5,27 @@
 package fmt_test
 
 import (
-	. "fmt";
-	"io";
-	"malloc";	// for the malloc count test only
-	"math";
-	"strings";
-	"testing";
+	. "fmt"
+	"io"
+	"malloc" // for the malloc count test only
+	"math"
+	"strings"
+	"testing"
 )
 
 func TestFmtInterface(t *testing.T) {
 	var i1 interface{}
-	i1 = "abc";
-	s := Sprintf("%s", i1);
+	i1 = "abc"
+	s := Sprintf("%s", i1)
 	if s != "abc" {
 		t.Errorf(`Sprintf("%%s", empty("abc")) = %q want %q`, s, "abc")
 	}
 }
 
 type fmtTest struct {
-	fmt	string;
-	val	interface{};
-	out	string;
+	fmt string
+	val interface{}
+	out string
 }
 
 const b32 uint32 = 1<<32 - 1
@@ -35,24 +35,24 @@ var array = []int{1, 2, 3, 4, 5}
 var iarray = []interface{}{1, "hello", 2.5, nil}
 
 type A struct {
-	i	int;
-	j	uint;
-	s	string;
-	x	[]int;
+	i int
+	j uint
+	s string
+	x []int
 }
 
 type I int
 
-func (i I) String() string	{ return Sprintf("<%d>", i) }
+func (i I) String() string { return Sprintf("<%d>", i) }
 
 type B struct {
-	i	I;
-	j	int;
+	i I
+	j int
 }
 
 type C struct {
-	i	int;
-	B;
+	i int
+	B
 }
 
 var b byte
@@ -228,16 +228,16 @@ var fmttests = []fmtTest{
 
 func TestSprintf(t *testing.T) {
 	for _, tt := range fmttests {
-		s := Sprintf(tt.fmt, tt.val);
+		s := Sprintf(tt.fmt, tt.val)
 		if i := strings.Index(s, "0x"); i >= 0 && strings.Index(tt.out, "PTR") >= 0 {
-			j := i + 2;
+			j := i + 2
 			for ; j < len(s); j++ {
-				c := s[j];
+				c := s[j]
 				if (c < '0' || c > '9') && (c < 'a' || c > 'f') {
 					break
 				}
 			}
-			s = s[0:i] + "PTR" + s[j:];
+			s = s[0:i] + "PTR" + s[j:]
 		}
 		if s != tt.out {
 			if _, ok := tt.val.(string); ok {
@@ -276,36 +276,36 @@ func BenchmarkSprintfIntInt(b *testing.B) {
 }
 
 func TestCountMallocs(t *testing.T) {
-	mallocs := 0 - malloc.GetStats().Mallocs;
+	mallocs := 0 - malloc.GetStats().Mallocs
 	for i := 0; i < 100; i++ {
 		Sprintf("")
 	}
-	mallocs += malloc.GetStats().Mallocs;
-	Printf("mallocs per Sprintf(\"\"): %d\n", mallocs/100);
-	mallocs = 0 - malloc.GetStats().Mallocs;
+	mallocs += malloc.GetStats().Mallocs
+	Printf("mallocs per Sprintf(\"\"): %d\n", mallocs/100)
+	mallocs = 0 - malloc.GetStats().Mallocs
 	for i := 0; i < 100; i++ {
 		Sprintf("xxx")
 	}
-	mallocs += malloc.GetStats().Mallocs;
-	Printf("mallocs per Sprintf(\"xxx\"): %d\n", mallocs/100);
-	mallocs = 0 - malloc.GetStats().Mallocs;
+	mallocs += malloc.GetStats().Mallocs
+	Printf("mallocs per Sprintf(\"xxx\"): %d\n", mallocs/100)
+	mallocs = 0 - malloc.GetStats().Mallocs
 	for i := 0; i < 100; i++ {
 		Sprintf("%x", i)
 	}
-	mallocs += malloc.GetStats().Mallocs;
-	Printf("mallocs per Sprintf(\"%%x\"): %d\n", mallocs/100);
-	mallocs = 0 - malloc.GetStats().Mallocs;
+	mallocs += malloc.GetStats().Mallocs
+	Printf("mallocs per Sprintf(\"%%x\"): %d\n", mallocs/100)
+	mallocs = 0 - malloc.GetStats().Mallocs
 	for i := 0; i < 100; i++ {
 		Sprintf("%x %x", i, i)
 	}
-	mallocs += malloc.GetStats().Mallocs;
-	Printf("mallocs per Sprintf(\"%%x %%x\"): %d\n", mallocs/100);
+	mallocs += malloc.GetStats().Mallocs
+	Printf("mallocs per Sprintf(\"%%x %%x\"): %d\n", mallocs/100)
 }
 
 type flagPrinter struct{}
 
 func (*flagPrinter) Format(f State, c int) {
-	s := "%";
+	s := "%"
 	for i := 0; i < 128; i++ {
 		if f.Flag(i) {
 			s += string(i)
@@ -317,13 +317,13 @@ func (*flagPrinter) Format(f State, c int) {
 	if p, ok := f.Precision(); ok {
 		s += Sprintf(".%d", p)
 	}
-	s += string(c);
-	io.WriteString(f, "["+s+"]");
+	s += string(c)
+	io.WriteString(f, "["+s+"]")
 }
 
 type flagTest struct {
-	in	string;
-	out	string;
+	in  string
+	out string
 }
 
 var flagtests = []flagTest{
@@ -342,9 +342,9 @@ var flagtests = []flagTest{
 }
 
 func TestFlagParser(t *testing.T) {
-	var flagprinter flagPrinter;
+	var flagprinter flagPrinter
 	for _, tt := range flagtests {
-		s := Sprintf(tt.in, &flagprinter);
+		s := Sprintf(tt.in, &flagprinter)
 		if s != tt.out {
 			t.Errorf("Sprintf(%q, &flagprinter) => %q, want %q", tt.in, s, tt.out)
 		}
@@ -353,23 +353,23 @@ func TestFlagParser(t *testing.T) {
 
 func TestStructPrinter(t *testing.T) {
 	var s struct {
-		a	string;
-		b	string;
-		c	int;
+		a string
+		b string
+		c int
 	}
-	s.a = "abc";
-	s.b = "def";
-	s.c = 123;
+	s.a = "abc"
+	s.b = "def"
+	s.c = 123
 	type Test struct {
-		fmt	string;
-		out	string;
+		fmt string
+		out string
 	}
 	var tests = []Test{
 		Test{"%v", "{abc def 123}"},
 		Test{"%+v", "{a:abc b:def c:123}"},
-	};
+	}
 	for _, tt := range tests {
-		out := Sprintf(tt.fmt, s);
+		out := Sprintf(tt.fmt, s)
 		if out != tt.out {
 			t.Errorf("Sprintf(%q, &s) = %q, want %q", tt.fmt, out, tt.out)
 		}
@@ -379,12 +379,12 @@ func TestStructPrinter(t *testing.T) {
 // Check map printing using substrings so we don't depend on the print order.
 func presentInMap(s string, a []string, t *testing.T) {
 	for i := 0; i < len(a); i++ {
-		loc := strings.Index(s, a[i]);
+		loc := strings.Index(s, a[i])
 		if loc < 0 {
 			t.Errorf("map print: expected to find %q in %q", a[i], s)
 		}
 		// make sure the match ends here
-		loc += len(a[i]);
+		loc += len(a[i])
 		if loc >= len(s) || (s[loc] != ' ' && s[loc] != ']') {
 			t.Errorf("map print: %q not properly terminated in %q", a[i], s)
 		}
@@ -392,26 +392,26 @@ func presentInMap(s string, a []string, t *testing.T) {
 }
 
 func TestMapPrinter(t *testing.T) {
-	m0 := make(map[int]string);
-	s := Sprint(m0);
+	m0 := make(map[int]string)
+	s := Sprint(m0)
 	if s != "map[]" {
 		t.Errorf("empty map printed as %q not %q", s, "map[]")
 	}
-	m1 := map[int]string{1: "one", 2: "two", 3: "three"};
-	a := []string{"1:one", "2:two", "3:three"};
-	presentInMap(Sprintf("%v", m1), a, t);
-	presentInMap(Sprint(m1), a, t);
+	m1 := map[int]string{1: "one", 2: "two", 3: "three"}
+	a := []string{"1:one", "2:two", "3:three"}
+	presentInMap(Sprintf("%v", m1), a, t)
+	presentInMap(Sprint(m1), a, t)
 }
 
 func TestEmptyMap(t *testing.T) {
-	const emptyMapStr = "map[]";
-	var m map[string]int;
-	s := Sprint(m);
+	const emptyMapStr = "map[]"
+	var m map[string]int
+	s := Sprint(m)
 	if s != emptyMapStr {
 		t.Errorf("nil map printed as %q not %q", s, emptyMapStr)
 	}
-	m = make(map[string]int);
-	s = Sprint(m);
+	m = make(map[string]int)
+	s = Sprint(m)
 	if s != emptyMapStr {
 		t.Errorf("empty map printed as %q not %q", s, emptyMapStr)
 	}
diff --git a/src/pkg/fmt/format.go b/src/pkg/fmt/format.go
index b53bcc5a6f..38b234414f 100644
--- a/src/pkg/fmt/format.go
+++ b/src/pkg/fmt/format.go
@@ -5,20 +5,20 @@
 package fmt
 
 import (
-	"bytes";
-	"strconv";
+	"bytes"
+	"strconv"
 )
 
 const (
-	nByte	= 64;
+	nByte = 64
 
-	ldigits	= "0123456789abcdef";
-	udigits	= "0123456789ABCDEF";
+	ldigits = "0123456789abcdef"
+	udigits = "0123456789ABCDEF"
 )
 
 const (
-	signed		= true;
-	unsigned	= false;
+	signed   = true
+	unsigned = false
 )
 
 var padZeroBytes = make([]byte, nByte)
@@ -28,55 +28,55 @@ var newline = []byte{'\n'}
 
 func init() {
 	for i := 0; i < nByte; i++ {
-		padZeroBytes[i] = '0';
-		padSpaceBytes[i] = ' ';
+		padZeroBytes[i] = '0'
+		padSpaceBytes[i] = ' '
 	}
 }
 
 // A fmt is the raw formatter used by Printf etc.
 // It prints into a bytes.Buffer that must be set up externally.
 type fmt struct {
-	intbuf	[nByte]byte;
-	buf	*bytes.Buffer;
+	intbuf [nByte]byte
+	buf    *bytes.Buffer
 	// width, precision
-	wid	int;
-	prec	int;
+	wid  int
+	prec int
 	// flags
-	widPresent	bool;
-	precPresent	bool;
-	minus		bool;
-	plus		bool;
-	sharp		bool;
-	space		bool;
-	zero		bool;
+	widPresent  bool
+	precPresent bool
+	minus       bool
+	plus        bool
+	sharp       bool
+	space       bool
+	zero        bool
 }
 
 func (f *fmt) clearflags() {
-	f.wid = 0;
-	f.widPresent = false;
-	f.prec = 0;
-	f.precPresent = false;
-	f.minus = false;
-	f.plus = false;
-	f.sharp = false;
-	f.space = false;
-	f.zero = false;
+	f.wid = 0
+	f.widPresent = false
+	f.prec = 0
+	f.precPresent = false
+	f.minus = false
+	f.plus = false
+	f.sharp = false
+	f.space = false
+	f.zero = false
 }
 
 func (f *fmt) init(buf *bytes.Buffer) {
-	f.buf = buf;
-	f.clearflags();
+	f.buf = buf
+	f.clearflags()
 }
 
 // Compute left and right padding widths (only one will be non-zero).
 func (f *fmt) computePadding(width int) (padding []byte, leftWidth, rightWidth int) {
-	left := !f.minus;
-	w := f.wid;
+	left := !f.minus
+	w := f.wid
 	if w < 0 {
-		left = false;
-		w = -w;
+		left = false
+		w = -w
 	}
-	w -= width;
+	w -= width
 	if w > 0 {
 		if left && f.zero {
 			return padZeroBytes, w, 0
@@ -88,66 +88,66 @@ func (f *fmt) computePadding(width int) (padding []byte, leftWidth, rightWidth i
 			return padSpaceBytes, 0, w
 		}
 	}
-	return;
+	return
 }
 
 // Generate n bytes of padding.
 func (f *fmt) writePadding(n int, padding []byte) {
 	for n > 0 {
-		m := n;
+		m := n
 		if m > nByte {
 			m = nByte
 		}
-		f.buf.Write(padding[0:m]);
-		n -= m;
+		f.buf.Write(padding[0:m])
+		n -= m
 	}
 }
 
 // Append b to f.buf, padded on left (w > 0) or right (w < 0 or f.minus)
 // clear flags aftewards.
 func (f *fmt) pad(b []byte) {
-	var padding []byte;
-	var left, right int;
+	var padding []byte
+	var left, right int
 	if f.widPresent && f.wid != 0 {
 		padding, left, right = f.computePadding(len(b))
 	}
 	if left > 0 {
 		f.writePadding(left, padding)
 	}
-	f.buf.Write(b);
+	f.buf.Write(b)
 	if right > 0 {
 		f.writePadding(right, padding)
 	}
-	f.clearflags();
+	f.clearflags()
 }
 
 // append s to buf, padded on left (w > 0) or right (w < 0 or f.minus).
 // clear flags aftewards.
 func (f *fmt) padString(s string) {
-	var padding []byte;
-	var left, right int;
+	var padding []byte
+	var left, right int
 	if f.widPresent && f.wid != 0 {
 		padding, left, right = f.computePadding(len(s))
 	}
 	if left > 0 {
 		f.writePadding(left, padding)
 	}
-	f.buf.WriteString(s);
+	f.buf.WriteString(s)
 	if right > 0 {
 		f.writePadding(right, padding)
 	}
-	f.clearflags();
+	f.clearflags()
 }
 
 func putint(buf []byte, base, val uint64, digits string) int {
-	i := len(buf) - 1;
+	i := len(buf) - 1
 	for val >= base {
-		buf[i] = digits[val%base];
-		i--;
-		val /= base;
+		buf[i] = digits[val%base]
+		i--
+		val /= base
 	}
-	buf[i] = digits[val];
-	return i - 1;
+	buf[i] = digits[val]
+	return i - 1
 }
 
 // fmt_boolean formats a boolean.
@@ -162,22 +162,22 @@ func (f *fmt) fmt_boolean(v bool) {
 // integer; interprets prec but not wid.  Once formatted, result is sent to pad()
 // and then flags are cleared.
 func (f *fmt) integer(a int64, base uint64, signedness bool, digits string) {
-	var buf []byte = &f.intbuf;
-	negative := signedness == signed && a < 0;
+	var buf []byte = &f.intbuf
+	negative := signedness == signed && a < 0
 	if negative {
 		a = -a
 	}
 
 	// two ways to ask for extra leading zero digits: %.3d or %03d.
 	// apparently the first cancels the second.
-	prec := 0;
+	prec := 0
 	if f.precPresent {
-		prec = f.prec;
-		f.zero = false;
+		prec = f.prec
+		f.zero = false
 	} else if f.zero && f.widPresent && !f.minus && f.wid > 0 {
-		prec = f.wid;
+		prec = f.wid
 		if negative || f.plus || f.space {
-			prec--	// leave room for sign
+			prec-- // leave room for sign
 		}
 	}
 
@@ -185,18 +185,18 @@ func (f *fmt) integer(a int64, base uint64, signedness bool, digits string) {
 	// a is made into unsigned ua.  we could make things
 	// marginally faster by splitting the 32-bit case out into a separate
 	// block but it's not worth the duplication, so ua has 64 bits.
-	i := len(f.intbuf);
-	ua := uint64(a);
+	i := len(f.intbuf)
+	ua := uint64(a)
 	for ua >= base {
-		i--;
-		buf[i] = digits[ua%base];
-		ua /= base;
+		i--
+		buf[i] = digits[ua%base]
+		ua /= base
 	}
-	i--;
-	buf[i] = digits[ua];
+	i--
+	buf[i] = digits[ua]
 	for i > 0 && prec > nByte-i {
-		i--;
-		buf[i] = '0';
+		i--
+		buf[i] = '0'
 	}
 
 	// Various prefixes: 0x, -, etc.
@@ -204,113 +204,113 @@ func (f *fmt) integer(a int64, base uint64, signedness bool, digits string) {
 		switch base {
 		case 8:
 			if buf[i] != '0' {
-				i--;
-				buf[i] = '0';
+				i--
+				buf[i] = '0'
 			}
 		case 16:
-			i--;
-			buf[i] = 'x' + digits[10] - 'a';
-			i--;
-			buf[i] = '0';
+			i--
+			buf[i] = 'x' + digits[10] - 'a'
+			i--
+			buf[i] = '0'
 		}
 	}
 
 	if negative {
-		i--;
-		buf[i] = '-';
+		i--
+		buf[i] = '-'
 	} else if f.plus {
-		i--;
-		buf[i] = '+';
+		i--
+		buf[i] = '+'
 	} else if f.space {
-		i--;
-		buf[i] = ' ';
+		i--
+		buf[i] = ' '
 	}
-	f.pad(buf[i:]);
+	f.pad(buf[i:])
 }
 
 // fmt_d64 formats an int64 in decimal.
-func (f *fmt) fmt_d64(v int64)	{ f.integer(v, 10, signed, ldigits) }
+func (f *fmt) fmt_d64(v int64) { f.integer(v, 10, signed, ldigits) }
 
 // fmt_d32 formats an int32 in decimal.
-func (f *fmt) fmt_d32(v int32)	{ f.integer(int64(v), 10, signed, ldigits) }
+func (f *fmt) fmt_d32(v int32) { f.integer(int64(v), 10, signed, ldigits) }
 
 // fmt_d formats an int in decimal.
-func (f *fmt) fmt_d(v int)	{ f.integer(int64(v), 10, signed, ldigits) }
+func (f *fmt) fmt_d(v int) { f.integer(int64(v), 10, signed, ldigits) }
 
 // fmt_ud64 formats a uint64 in decimal.
-func (f *fmt) fmt_ud64(v uint64)	{ f.integer(int64(v), 10, unsigned, ldigits) }
+func (f *fmt) fmt_ud64(v uint64) { f.integer(int64(v), 10, unsigned, ldigits) }
 
 // fmt_ud32 formats a uint32 in decimal.
-func (f *fmt) fmt_ud32(v uint32)	{ f.integer(int64(v), 10, unsigned, ldigits) }
+func (f *fmt) fmt_ud32(v uint32) { f.integer(int64(v), 10, unsigned, ldigits) }
 
 // fmt_ud formats a uint in decimal.
-func (f *fmt) fmt_ud(v uint)	{ f.integer(int64(v), 10, unsigned, ldigits) }
+func (f *fmt) fmt_ud(v uint) { f.integer(int64(v), 10, unsigned, ldigits) }
 
 // fmt_x64 formats an int64 in hexadecimal.
-func (f *fmt) fmt_x64(v int64)	{ f.integer(v, 16, signed, ldigits) }
+func (f *fmt) fmt_x64(v int64) { f.integer(v, 16, signed, ldigits) }
 
 // fmt_x32 formats an int32 in hexadecimal.
-func (f *fmt) fmt_x32(v int32)	{ f.integer(int64(v), 16, signed, ldigits) }
+func (f *fmt) fmt_x32(v int32) { f.integer(int64(v), 16, signed, ldigits) }
 
 // fmt_x formats an int in hexadecimal.
-func (f *fmt) fmt_x(v int)	{ f.integer(int64(v), 16, signed, ldigits) }
+func (f *fmt) fmt_x(v int) { f.integer(int64(v), 16, signed, ldigits) }
 
 // fmt_ux64 formats a uint64 in hexadecimal.
-func (f *fmt) fmt_ux64(v uint64)	{ f.integer(int64(v), 16, unsigned, ldigits) }
+func (f *fmt) fmt_ux64(v uint64) { f.integer(int64(v), 16, unsigned, ldigits) }
 
 // fmt_ux32 formats a uint32 in hexadecimal.
-func (f *fmt) fmt_ux32(v uint32)	{ f.integer(int64(v), 16, unsigned, ldigits) }
+func (f *fmt) fmt_ux32(v uint32) { f.integer(int64(v), 16, unsigned, ldigits) }
 
 // fmt_ux formats a uint in hexadecimal.
-func (f *fmt) fmt_ux(v uint)	{ f.integer(int64(v), 16, unsigned, ldigits) }
+func (f *fmt) fmt_ux(v uint) { f.integer(int64(v), 16, unsigned, ldigits) }
 
 // fmt_X64 formats an int64 in upper case hexadecimal.
-func (f *fmt) fmt_X64(v int64)	{ f.integer(v, 16, signed, udigits) }
+func (f *fmt) fmt_X64(v int64) { f.integer(v, 16, signed, udigits) }
 
 // fmt_X32 formats an int32 in upper case hexadecimal.
-func (f *fmt) fmt_X32(v int32)	{ f.integer(int64(v), 16, signed, udigits) }
+func (f *fmt) fmt_X32(v int32) { f.integer(int64(v), 16, signed, udigits) }
 
 // fmt_X formats an int in upper case hexadecimal.
-func (f *fmt) fmt_X(v int)	{ f.integer(int64(v), 16, signed, udigits) }
+func (f *fmt) fmt_X(v int) { f.integer(int64(v), 16, signed, udigits) }
 
 // fmt_uX64 formats a uint64 in upper case hexadecimal.
-func (f *fmt) fmt_uX64(v uint64)	{ f.integer(int64(v), 16, unsigned, udigits) }
+func (f *fmt) fmt_uX64(v uint64) { f.integer(int64(v), 16, unsigned, udigits) }
 
 // fmt_uX32 formats a uint32 in upper case hexadecimal.
-func (f *fmt) fmt_uX32(v uint32)	{ f.integer(int64(v), 16, unsigned, udigits) }
+func (f *fmt) fmt_uX32(v uint32) { f.integer(int64(v), 16, unsigned, udigits) }
 
 // fmt_uX formats a uint in upper case hexadecimal.
-func (f *fmt) fmt_uX(v uint)	{ f.integer(int64(v), 16, unsigned, udigits) }
+func (f *fmt) fmt_uX(v uint) { f.integer(int64(v), 16, unsigned, udigits) }
 
 // fmt_o64 formats an int64 in octal.
-func (f *fmt) fmt_o64(v int64)	{ f.integer(v, 8, signed, ldigits) }
+func (f *fmt) fmt_o64(v int64) { f.integer(v, 8, signed, ldigits) }
 
 // fmt_o32 formats an int32 in octal.
-func (f *fmt) fmt_o32(v int32)	{ f.integer(int64(v), 8, signed, ldigits) }
+func (f *fmt) fmt_o32(v int32) { f.integer(int64(v), 8, signed, ldigits) }
 
 // fmt_o formats an int in octal.
-func (f *fmt) fmt_o(v int)	{ f.integer(int64(v), 8, signed, ldigits) }
+func (f *fmt) fmt_o(v int) { f.integer(int64(v), 8, signed, ldigits) }
 
 // fmt_uo64 formats a uint64 in octal.
-func (f *fmt) fmt_uo64(v uint64)	{ f.integer(int64(v), 8, unsigned, ldigits) }
+func (f *fmt) fmt_uo64(v uint64) { f.integer(int64(v), 8, unsigned, ldigits) }
 
 // fmt_uo32 formats a uint32 in octal.
-func (f *fmt) fmt_uo32(v uint32)	{ f.integer(int64(v), 8, unsigned, ldigits) }
+func (f *fmt) fmt_uo32(v uint32) { f.integer(int64(v), 8, unsigned, ldigits) }
 
 // fmt_uo formats a uint in octal.
-func (f *fmt) fmt_uo(v uint)	{ f.integer(int64(v), 8, unsigned, ldigits) }
+func (f *fmt) fmt_uo(v uint) { f.integer(int64(v), 8, unsigned, ldigits) }
 
 // fmt_b64 formats a uint64 in binary.
-func (f *fmt) fmt_b64(v uint64)	{ f.integer(int64(v), 2, unsigned, ldigits) }
+func (f *fmt) fmt_b64(v uint64) { f.integer(int64(v), 2, unsigned, ldigits) }
 
 // fmt_b32 formats a uint32 in binary.
-func (f *fmt) fmt_b32(v uint32)	{ f.integer(int64(v), 2, unsigned, ldigits) }
+func (f *fmt) fmt_b32(v uint32) { f.integer(int64(v), 2, unsigned, ldigits) }
 
 // fmt_b formats a uint in binary.
-func (f *fmt) fmt_b(v uint)	{ f.integer(int64(v), 2, unsigned, ldigits) }
+func (f *fmt) fmt_b(v uint) { f.integer(int64(v), 2, unsigned, ldigits) }
 
 // fmt_c formats a Unicode character.
-func (f *fmt) fmt_c(v int)	{ f.padString(string(v)) }
+func (f *fmt) fmt_c(v int) { f.padString(string(v)) }
 
 // fmt_s formats a string.
 func (f *fmt) fmt_s(s string) {
@@ -319,43 +319,43 @@ func (f *fmt) fmt_s(s string) {
 			s = s[0:f.prec]
 		}
 	}
-	f.padString(s);
+	f.padString(s)
 }
 
 // fmt_sx formats a string as a hexadecimal encoding of its bytes.
 func (f *fmt) fmt_sx(s string) {
-	t := "";
+	t := ""
 	for i := 0; i < len(s); i++ {
 		if i > 0 && f.space {
 			t += " "
 		}
-		v := s[i];
-		t += string(ldigits[v>>4]);
-		t += string(ldigits[v&0xF]);
+		v := s[i]
+		t += string(ldigits[v>>4])
+		t += string(ldigits[v&0xF])
 	}
-	f.padString(t);
+	f.padString(t)
 }
 
 // fmt_sX formats a string as an uppercase hexadecimal encoding of its bytes.
 func (f *fmt) fmt_sX(s string) {
-	t := "";
+	t := ""
 	for i := 0; i < len(s); i++ {
-		v := s[i];
-		t += string(udigits[v>>4]);
-		t += string(udigits[v&0xF]);
+		v := s[i]
+		t += string(udigits[v>>4])
+		t += string(udigits[v&0xF])
 	}
-	f.padString(t);
+	f.padString(t)
 }
 
 // fmt_q formats a string as a double-quoted, escaped Go string constant.
 func (f *fmt) fmt_q(s string) {
-	var quoted string;
+	var quoted string
 	if f.sharp && strconv.CanBackquote(s) {
 		quoted = "`" + s + "`"
 	} else {
 		quoted = strconv.Quote(s)
 	}
-	f.padString(quoted);
+	f.padString(quoted)
 }
 
 // floating-point
@@ -364,7 +364,7 @@ func doPrec(f *fmt, def int) int {
 	if f.precPresent {
 		return f.prec
 	}
-	return def;
+	return def
 }
 
 // Add a plus sign or space to the floating-point string representation if missing and required.
@@ -376,48 +376,48 @@ func (f *fmt) plusSpace(s string) {
 			s = " " + s
 		}
 	}
-	f.padString(s);
+	f.padString(s)
 }
 
 // fmt_e64 formats a float64 in the form -1.23e+12.
-func (f *fmt) fmt_e64(v float64)	{ f.plusSpace(strconv.Ftoa64(v, 'e', doPrec(f, 6))) }
+func (f *fmt) fmt_e64(v float64) { f.plusSpace(strconv.Ftoa64(v, 'e', doPrec(f, 6))) }
 
 // fmt_E64 formats a float64 in the form -1.23E+12.
-func (f *fmt) fmt_E64(v float64)	{ f.plusSpace(strconv.Ftoa64(v, 'E', doPrec(f, 6))) }
+func (f *fmt) fmt_E64(v float64) { f.plusSpace(strconv.Ftoa64(v, 'E', doPrec(f, 6))) }
 
 // fmt_f64 formats a float64 in the form -1.23.
-func (f *fmt) fmt_f64(v float64)	{ f.plusSpace(strconv.Ftoa64(v, 'f', doPrec(f, 6))) }
+func (f *fmt) fmt_f64(v float64) { f.plusSpace(strconv.Ftoa64(v, 'f', doPrec(f, 6))) }
 
 // fmt_g64 formats a float64 in the 'f' or 'e' form according to size.
-func (f *fmt) fmt_g64(v float64)	{ f.plusSpace(strconv.Ftoa64(v, 'g', doPrec(f, -1))) }
+func (f *fmt) fmt_g64(v float64) { f.plusSpace(strconv.Ftoa64(v, 'g', doPrec(f, -1))) }
 
 // fmt_g64 formats a float64 in the 'f' or 'E' form according to size.
-func (f *fmt) fmt_G64(v float64)	{ f.plusSpace(strconv.Ftoa64(v, 'G', doPrec(f, -1))) }
+func (f *fmt) fmt_G64(v float64) { f.plusSpace(strconv.Ftoa64(v, 'G', doPrec(f, -1))) }
 
 // fmt_fb64 formats a float64 in the form -123p3 (exponent is power of 2).
-func (f *fmt) fmt_fb64(v float64)	{ f.plusSpace(strconv.Ftoa64(v, 'b', 0)) }
+func (f *fmt) fmt_fb64(v float64) { f.plusSpace(strconv.Ftoa64(v, 'b', 0)) }
 
 // float32
 // cannot defer to float64 versions
 // because it will get rounding wrong in corner cases.
 
 // fmt_e32 formats a float32 in the form -1.23e+12.
-func (f *fmt) fmt_e32(v float32)	{ f.plusSpace(strconv.Ftoa32(v, 'e', doPrec(f, 6))) }
+func (f *fmt) fmt_e32(v float32) { f.plusSpace(strconv.Ftoa32(v, 'e', doPrec(f, 6))) }
 
 // fmt_E32 formats a float32 in the form -1.23E+12.
-func (f *fmt) fmt_E32(v float32)	{ f.plusSpace(strconv.Ftoa32(v, 'E', doPrec(f, 6))) }
+func (f *fmt) fmt_E32(v float32) { f.plusSpace(strconv.Ftoa32(v, 'E', doPrec(f, 6))) }
 
 // fmt_f32 formats a float32 in the form -1.23.
-func (f *fmt) fmt_f32(v float32)	{ f.plusSpace(strconv.Ftoa32(v, 'f', doPrec(f, 6))) }
+func (f *fmt) fmt_f32(v float32) { f.plusSpace(strconv.Ftoa32(v, 'f', doPrec(f, 6))) }
 
 // fmt_g32 formats a float32 in the 'f' or 'e' form according to size.
-func (f *fmt) fmt_g32(v float32)	{ f.plusSpace(strconv.Ftoa32(v, 'g', doPrec(f, -1))) }
+func (f *fmt) fmt_g32(v float32) { f.plusSpace(strconv.Ftoa32(v, 'g', doPrec(f, -1))) }
 
 // fmt_G32 formats a float32 in the 'f' or 'E' form according to size.
-func (f *fmt) fmt_G32(v float32)	{ f.plusSpace(strconv.Ftoa32(v, 'G', doPrec(f, -1))) }
+func (f *fmt) fmt_G32(v float32) { f.plusSpace(strconv.Ftoa32(v, 'G', doPrec(f, -1))) }
 
 // fmt_fb32 formats a float32 in the form -123p3 (exponent is power of 2).
-func (f *fmt) fmt_fb32(v float32)	{ f.padString(strconv.Ftoa32(v, 'b', 0)) }
+func (f *fmt) fmt_fb32(v float32) { f.padString(strconv.Ftoa32(v, 'b', 0)) }
 
 // float
 func (x *fmt) f(a float) {
diff --git a/src/pkg/fmt/print.go b/src/pkg/fmt/print.go
index 6fa747c29c..d4ef3c62f6 100644
--- a/src/pkg/fmt/print.go
+++ b/src/pkg/fmt/print.go
@@ -77,25 +77,25 @@ package fmt
 
 
 import (
-	"bytes";
-	"io";
-	"os";
-	"reflect";
-	"utf8";
+	"bytes"
+	"io"
+	"os"
+	"reflect"
+	"utf8"
 )
 
 // Some constants in the form of bytes, to avoid string overhead.
 // Needlessly fastidious, I suppose.
 var (
-	trueBytes	= []byte{'t', 'r', 'u', 'e'};
-	falseBytes	= []byte{'f', 'a', 'l', 's', 'e'};
-	commaSpaceBytes	= []byte{',', ' '};
-	nilAngleBytes	= []byte{'<', 'n', 'i', 'l', '>'};
-	nilParenBytes	= []byte{'(', 'n', 'i', 'l', ')'};
-	nilBytes	= []byte{'n', 'i', 'l'};
-	mapBytes	= []byte{'m', 'a', 'p', '['};
-	missingBytes	= []byte{'m', 'i', 's', 's', 'i', 'n', 'g'};
-	extraBytes	= []byte{'?', '(', 'e', 'x', 't', 'r', 'a', ' '};
+	trueBytes       = []byte{'t', 'r', 'u', 'e'}
+	falseBytes      = []byte{'f', 'a', 'l', 's', 'e'}
+	commaSpaceBytes = []byte{',', ' '}
+	nilAngleBytes   = []byte{'<', 'n', 'i', 'l', '>'}
+	nilParenBytes   = []byte{'(', 'n', 'i', 'l', ')'}
+	nilBytes        = []byte{'n', 'i', 'l'}
+	mapBytes        = []byte{'m', 'a', 'p', '['}
+	missingBytes    = []byte{'m', 'i', 's', 's', 'i', 'n', 'g'}
+	extraBytes      = []byte{'?', '(', 'e', 'x', 't', 'r', 'a', ' '}
 )
 
 // State represents the printer state passed to custom formatters.
@@ -103,21 +103,21 @@ var (
 // the flags and options for the operand's format specifier.
 type State interface {
 	// Write is the function to call to emit formatted output to be printed.
-	Write(b []byte) (ret int, err os.Error);
+	Write(b []byte) (ret int, err os.Error)
 	// Width returns the value of the width option and whether it has been set.
-	Width() (wid int, ok bool);
+	Width() (wid int, ok bool)
 	// Precision returns the value of the precision option and whether it has been set.
-	Precision() (prec int, ok bool);
+	Precision() (prec int, ok bool)
 
 	// Flag returns whether the flag c, a character, has been set.
-	Flag(int) bool;
+	Flag(int) bool
 }
 
 // Formatter is the interface implemented by values with a custom formatter.
 // The implementation of Format may call Sprintf or Fprintf(f) etc.
 // to generate its output.
 type Formatter interface {
-	Format(f State, c int);
+	Format(f State, c int)
 }
 
 // Stringer is implemented by any value that has a String method(),
@@ -125,7 +125,7 @@ type Formatter interface {
 // The String method is used to print values passed as an operand
 // to a %s or %v format or to an unformatted printer such as Print.
 type Stringer interface {
-	String() string;
+	String() string
 }
 
 // GoStringer is implemented by any value that has a GoString() method,
@@ -133,16 +133,16 @@ type Stringer interface {
 // The GoString method is used to print values passed as an operand
 // to a %#v format.
 type GoStringer interface {
-	GoString() string;
+	GoString() string
 }
 
 const allocSize = 32
 
 type pp struct {
-	n	int;
-	buf	bytes.Buffer;
-	runeBuf	[utf8.UTFMax]byte;
-	fmt	fmt;
+	n       int
+	buf     bytes.Buffer
+	runeBuf [utf8.UTFMax]byte
+	fmt     fmt
 }
 
 // A leaky bucket of reusable pp structures.
@@ -150,12 +150,12 @@ var ppFree = make(chan *pp, 100)
 
 // Allocate a new pp struct.  Probably can grab the previous one from ppFree.
 func newPrinter() *pp {
-	p, ok := <-ppFree;
+	p, ok := <-ppFree
 	if !ok {
 		p = new(pp)
 	}
-	p.fmt.init(&p.buf);
-	return p;
+	p.fmt.init(&p.buf)
+	return p
 }
 
 // Save used pp structs in ppFree; avoids an allocation per invocation.
@@ -164,13 +164,13 @@ func (p *pp) free() {
 	if cap(p.buf.Bytes()) > 1024 {
 		return
 	}
-	p.buf.Reset();
-	_ = ppFree <- p;
+	p.buf.Reset()
+	_ = ppFree <- p
 }
 
-func (p *pp) Width() (wid int, ok bool)	{ return p.fmt.wid, p.fmt.widPresent }
+func (p *pp) Width() (wid int, ok bool) { return p.fmt.wid, p.fmt.widPresent }
 
-func (p *pp) Precision() (prec int, ok bool)	{ return p.fmt.prec, p.fmt.precPresent }
+func (p *pp) Precision() (prec int, ok bool) { return p.fmt.prec, p.fmt.precPresent }
 
 func (p *pp) Flag(b int) bool {
 	switch b {
@@ -185,15 +185,15 @@ func (p *pp) Flag(b int) bool {
 	case '0':
 		return p.fmt.zero
 	}
-	return false;
+	return false
 }
 
 func (p *pp) add(c int) {
 	if c < utf8.RuneSelf {
 		p.buf.WriteByte(byte(c))
 	} else {
-		w := utf8.EncodeRune(c, &p.runeBuf);
-		p.buf.Write(p.runeBuf[0:w]);
+		w := utf8.EncodeRune(c, &p.runeBuf)
+		p.buf.Write(p.runeBuf[0:w])
 	}
 }
 
@@ -207,28 +207,28 @@ func (p *pp) Write(b []byte) (ret int, err os.Error) {
 
 // Fprintf formats according to a format specifier and writes to w.
 func Fprintf(w io.Writer, format string, a ...) (n int, error os.Error) {
-	v := reflect.NewValue(a).(*reflect.StructValue);
-	p := newPrinter();
-	p.doprintf(format, v);
-	n64, error := p.buf.WriteTo(w);
-	p.free();
-	return int(n64), error;
+	v := reflect.NewValue(a).(*reflect.StructValue)
+	p := newPrinter()
+	p.doprintf(format, v)
+	n64, error := p.buf.WriteTo(w)
+	p.free()
+	return int(n64), error
 }
 
 // Printf formats according to a format specifier and writes to standard output.
 func Printf(format string, v ...) (n int, errno os.Error) {
-	n, errno = Fprintf(os.Stdout, format, v);
-	return n, errno;
+	n, errno = Fprintf(os.Stdout, format, v)
+	return n, errno
 }
 
 // Sprintf formats according to a format specifier and returns the resulting string.
 func Sprintf(format string, a ...) string {
-	v := reflect.NewValue(a).(*reflect.StructValue);
-	p := newPrinter();
-	p.doprintf(format, v);
-	s := p.buf.String();
-	p.free();
-	return s;
+	v := reflect.NewValue(a).(*reflect.StructValue)
+	p := newPrinter()
+	p.doprintf(format, v)
+	s := p.buf.String()
+	p.free()
+	return s
 }
 
 // These routines do not take a format string
@@ -236,30 +236,30 @@ func Sprintf(format string, a ...) string {
 // Fprint formats using the default formats for its operands and writes to w.
 // Spaces are added between operands when neither is a string.
 func Fprint(w io.Writer, a ...) (n int, error os.Error) {
-	v := reflect.NewValue(a).(*reflect.StructValue);
-	p := newPrinter();
-	p.doprint(v, false, false);
-	n64, error := p.buf.WriteTo(w);
-	p.free();
-	return int(n64), error;
+	v := reflect.NewValue(a).(*reflect.StructValue)
+	p := newPrinter()
+	p.doprint(v, false, false)
+	n64, error := p.buf.WriteTo(w)
+	p.free()
+	return int(n64), error
 }
 
 // Print formats using the default formats for its operands and writes to standard output.
 // Spaces are added between operands when neither is a string.
 func Print(v ...) (n int, errno os.Error) {
-	n, errno = Fprint(os.Stdout, v);
-	return n, errno;
+	n, errno = Fprint(os.Stdout, v)
+	return n, errno
 }
 
 // Sprint formats using the default formats for its operands and returns the resulting string.
 // Spaces are added between operands when neither is a string.
 func Sprint(a ...) string {
-	v := reflect.NewValue(a).(*reflect.StructValue);
-	p := newPrinter();
-	p.doprint(v, false, false);
-	s := p.buf.String();
-	p.free();
-	return s;
+	v := reflect.NewValue(a).(*reflect.StructValue)
+	p := newPrinter()
+	p.doprint(v, false, false)
+	s := p.buf.String()
+	p.free()
+	return s
 }
 
 // These routines end in 'ln', do not take a format string,
@@ -269,30 +269,30 @@ func Sprint(a ...) string {
 // Fprintln formats using the default formats for its operands and writes to w.
 // Spaces are always added between operands and a newline is appended.
 func Fprintln(w io.Writer, a ...) (n int, error os.Error) {
-	v := reflect.NewValue(a).(*reflect.StructValue);
-	p := newPrinter();
-	p.doprint(v, true, true);
-	n64, error := p.buf.WriteTo(w);
-	p.free();
-	return int(n64), error;
+	v := reflect.NewValue(a).(*reflect.StructValue)
+	p := newPrinter()
+	p.doprint(v, true, true)
+	n64, error := p.buf.WriteTo(w)
+	p.free()
+	return int(n64), error
 }
 
 // Println formats using the default formats for its operands and writes to standard output.
 // Spaces are always added between operands and a newline is appended.
 func Println(v ...) (n int, errno os.Error) {
-	n, errno = Fprintln(os.Stdout, v);
-	return n, errno;
+	n, errno = Fprintln(os.Stdout, v)
+	return n, errno
 }
 
 // Sprintln formats using the default formats for its operands and returns the resulting string.
 // Spaces are always added between operands and a newline is appended.
 func Sprintln(a ...) string {
-	v := reflect.NewValue(a).(*reflect.StructValue);
-	p := newPrinter();
-	p.doprint(v, true, true);
-	s := p.buf.String();
-	p.free();
-	return s;
+	v := reflect.NewValue(a).(*reflect.StructValue)
+	p := newPrinter()
+	p.doprint(v, true, true)
+	s := p.buf.String()
+	p.free()
+	return s
 }
 
 
@@ -300,13 +300,13 @@ func Sprintln(a ...) string {
 // If the arg itself is an interface, return a value for
 // the thing inside the interface, not the interface itself.
 func getField(v *reflect.StructValue, i int) reflect.Value {
-	val := v.Field(i);
+	val := v.Field(i)
 	if i, ok := val.(*reflect.InterfaceValue); ok {
 		if inter := i.Interface(); inter != nil {
 			return reflect.NewValue(inter)
 		}
 	}
-	return val;
+	return val
 }
 
 // Getters for the fields of the argument structure.
@@ -315,7 +315,7 @@ func getBool(v reflect.Value) (val bool, ok bool) {
 	if b, ok := v.(*reflect.BoolValue); ok {
 		return b.Get(), true
 	}
-	return;
+	return
 }
 
 func getInt(v reflect.Value) (val int64, signed, ok bool) {
@@ -343,7 +343,7 @@ func getInt(v reflect.Value) (val int64, signed, ok bool) {
 	case *reflect.UintptrValue:
 		return int64(v.Get()), false, true
 	}
-	return;
+	return
 }
 
 func getString(v reflect.Value) (val string, ok bool) {
@@ -353,7 +353,7 @@ func getString(v reflect.Value) (val string, ok bool) {
 	if bytes, ok := v.Interface().([]byte); ok {
 		return string(bytes), true
 	}
-	return;
+	return
 }
 
 func getFloat32(v reflect.Value) (val float32, ok bool) {
@@ -365,7 +365,7 @@ func getFloat32(v reflect.Value) (val float32, ok bool) {
 			return float32(v.Get()), true
 		}
 	}
-	return;
+	return
 }
 
 func getFloat64(v reflect.Value) (val float64, ok bool) {
@@ -377,7 +377,7 @@ func getFloat64(v reflect.Value) (val float64, ok bool) {
 	case *reflect.Float64Value:
 		return float64(v.Get()), true
 	}
-	return;
+	return
 }
 
 func getPtr(v reflect.Value) (val uintptr, ok bool) {
@@ -385,7 +385,7 @@ func getPtr(v reflect.Value) (val uintptr, ok bool) {
 	case *reflect.PtrValue:
 		return uintptr(v.Get()), true
 	}
-	return;
+	return
 }
 
 // Convert ASCII to integer.  n is 0 (and got is false) if no number present.
@@ -394,33 +394,33 @@ func parsenum(s string, start, end int) (n int, got bool, newi int) {
 	if start >= end {
 		return 0, false, end
 	}
-	isnum := false;
-	num := 0;
+	isnum := false
+	num := 0
 	for '0' <= s[start] && s[start] <= '9' {
-		num = num*10 + int(s[start]-'0');
-		start++;
-		isnum = true;
+		num = num*10 + int(s[start]-'0')
+		start++
+		isnum = true
 	}
-	return num, isnum, start;
+	return num, isnum, start
 }
 
 type uintptrGetter interface {
-	Get() uintptr;
+	Get() uintptr
 }
 
 func (p *pp) printField(field reflect.Value, plus, sharp bool, depth int) (was_string bool) {
-	inter := field.Interface();
+	inter := field.Interface()
 	if inter != nil {
 		switch {
 		default:
 			if stringer, ok := inter.(Stringer); ok {
-				p.buf.WriteString(stringer.String());
-				return false;	// this value is not a string
+				p.buf.WriteString(stringer.String())
+				return false // this value is not a string
 			}
 		case sharp:
 			if stringer, ok := inter.(GoStringer); ok {
-				p.buf.WriteString(stringer.GoString());
-				return false;	// this value is not a string
+				p.buf.WriteString(stringer.GoString())
+				return false // this value is not a string
 			}
 		}
 	}
@@ -442,17 +442,17 @@ BigSwitch:
 		if sharp {
 			p.fmt.fmt_q(f.Get())
 		} else {
-			p.fmt.fmt_s(f.Get());
-			was_string = true;
+			p.fmt.fmt_s(f.Get())
+			was_string = true
 		}
 	case *reflect.MapValue:
 		if sharp {
-			p.buf.WriteString(field.Type().String());
-			p.buf.WriteByte('{');
+			p.buf.WriteString(field.Type().String())
+			p.buf.WriteByte('{')
 		} else {
 			p.buf.Write(mapBytes)
 		}
-		keys := f.Keys();
+		keys := f.Keys()
 		for i, key := range keys {
 			if i > 0 {
 				if sharp {
@@ -461,9 +461,9 @@ BigSwitch:
 					p.buf.WriteByte(' ')
 				}
 			}
-			p.printField(key, plus, sharp, depth+1);
-			p.buf.WriteByte(':');
-			p.printField(f.Elem(key), plus, sharp, depth+1);
+			p.printField(key, plus, sharp, depth+1)
+			p.buf.WriteByte(':')
+			p.printField(f.Elem(key), plus, sharp, depth+1)
 		}
 		if sharp {
 			p.buf.WriteByte('}')
@@ -474,10 +474,10 @@ BigSwitch:
 		if sharp {
 			p.buf.WriteString(field.Type().String())
 		}
-		p.add('{');
-		v := f;
-		t := v.Type().(*reflect.StructType);
-		p.fmt.clearflags();	// clear flags for p.printField
+		p.add('{')
+		v := f
+		t := v.Type().(*reflect.StructType)
+		p.fmt.clearflags() // clear flags for p.printField
 		for i := 0; i < v.NumField(); i++ {
 			if i > 0 {
 				if sharp {
@@ -488,19 +488,19 @@ BigSwitch:
 			}
 			if plus || sharp {
 				if f := t.Field(i); f.Name != "" {
-					p.buf.WriteString(f.Name);
-					p.buf.WriteByte(':');
+					p.buf.WriteString(f.Name)
+					p.buf.WriteByte(':')
 				}
 			}
-			p.printField(getField(v, i), plus, sharp, depth+1);
+			p.printField(getField(v, i), plus, sharp, depth+1)
 		}
-		p.buf.WriteByte('}');
+		p.buf.WriteByte('}')
 	case *reflect.InterfaceValue:
-		value := f.Elem();
+		value := f.Elem()
 		if value == nil {
 			if sharp {
-				p.buf.WriteString(field.Type().String());
-				p.buf.Write(nilParenBytes);
+				p.buf.WriteString(field.Type().String())
+				p.buf.Write(nilParenBytes)
 			} else {
 				p.buf.Write(nilAngleBytes)
 			}
@@ -509,8 +509,8 @@ BigSwitch:
 		}
 	case reflect.ArrayOrSliceValue:
 		if sharp {
-			p.buf.WriteString(field.Type().String());
-			p.buf.WriteByte('{');
+			p.buf.WriteString(field.Type().String())
+			p.buf.WriteByte('{')
 		} else {
 			p.buf.WriteByte('[')
 		}
@@ -522,7 +522,7 @@ BigSwitch:
 					p.buf.WriteByte(' ')
 				}
 			}
-			p.printField(f.Elem(i), plus, sharp, depth+1);
+			p.printField(f.Elem(i), plus, sharp, depth+1)
 		}
 		if sharp {
 			p.buf.WriteByte('}')
@@ -530,99 +530,99 @@ BigSwitch:
 			p.buf.WriteByte(']')
 		}
 	case *reflect.PtrValue:
-		v := f.Get();
+		v := f.Get()
 		// pointer to array or slice or struct?  ok at top level
 		// but not embedded (avoid loops)
 		if v != 0 && depth == 0 {
 			switch a := f.Elem().(type) {
 			case reflect.ArrayOrSliceValue:
-				p.buf.WriteByte('&');
-				p.printField(a, plus, sharp, depth+1);
-				break BigSwitch;
+				p.buf.WriteByte('&')
+				p.printField(a, plus, sharp, depth+1)
+				break BigSwitch
 			case *reflect.StructValue:
-				p.buf.WriteByte('&');
-				p.printField(a, plus, sharp, depth+1);
-				break BigSwitch;
+				p.buf.WriteByte('&')
+				p.printField(a, plus, sharp, depth+1)
+				break BigSwitch
 			}
 		}
 		if sharp {
-			p.buf.WriteByte('(');
-			p.buf.WriteString(field.Type().String());
-			p.buf.WriteByte(')');
-			p.buf.WriteByte('(');
+			p.buf.WriteByte('(')
+			p.buf.WriteString(field.Type().String())
+			p.buf.WriteByte(')')
+			p.buf.WriteByte('(')
 			if v == 0 {
 				p.buf.Write(nilBytes)
 			} else {
-				p.fmt.sharp = true;
-				p.fmt.fmt_ux64(uint64(v));
+				p.fmt.sharp = true
+				p.fmt.fmt_ux64(uint64(v))
 			}
-			p.buf.WriteByte(')');
-			break;
+			p.buf.WriteByte(')')
+			break
 		}
 		if v == 0 {
-			p.buf.Write(nilAngleBytes);
-			break;
+			p.buf.Write(nilAngleBytes)
+			break
 		}
-		p.fmt.sharp = true;	// turn 0x on
-		p.fmt.fmt_ux64(uint64(v));
+		p.fmt.sharp = true // turn 0x on
+		p.fmt.fmt_ux64(uint64(v))
 	case uintptrGetter:
-		v := f.Get();
+		v := f.Get()
 		if sharp {
-			p.buf.WriteByte('(');
-			p.buf.WriteString(field.Type().String());
-			p.buf.WriteByte(')');
-			p.buf.WriteByte('(');
+			p.buf.WriteByte('(')
+			p.buf.WriteString(field.Type().String())
+			p.buf.WriteByte(')')
+			p.buf.WriteByte('(')
 			if v == 0 {
 				p.buf.Write(nilBytes)
 			} else {
-				p.fmt.sharp = true;
-				p.fmt.fmt_ux64(uint64(v));
+				p.fmt.sharp = true
+				p.fmt.fmt_ux64(uint64(v))
 			}
-			p.buf.WriteByte(')');
+			p.buf.WriteByte(')')
 		} else {
-			p.fmt.sharp = true;	// turn 0x on
-			p.fmt.fmt_ux64(uint64(f.Get()));
+			p.fmt.sharp = true // turn 0x on
+			p.fmt.fmt_ux64(uint64(f.Get()))
 		}
 	default:
-		v, signed, ok := getInt(field);
+		v, signed, ok := getInt(field)
 		if ok {
 			if signed {
 				p.fmt.fmt_d64(v)
 			} else {
 				if sharp {
-					p.fmt.sharp = true;	// turn on 0x
-					p.fmt.fmt_ux64(uint64(v));
+					p.fmt.sharp = true // turn on 0x
+					p.fmt.fmt_ux64(uint64(v))
 				} else {
 					p.fmt.fmt_ud64(uint64(v))
 				}
 			}
-			break;
+			break
 		}
-		p.buf.WriteByte('?');
-		p.buf.WriteString(field.Type().String());
-		p.buf.WriteByte('?');
+		p.buf.WriteByte('?')
+		p.buf.WriteString(field.Type().String())
+		p.buf.WriteByte('?')
 	}
-	return was_string;
+	return was_string
 }
 
 func (p *pp) doprintf(format string, v *reflect.StructValue) {
-	end := len(format) - 1;
-	fieldnum := 0;	// we process one field per non-trivial format
+	end := len(format) - 1
+	fieldnum := 0 // we process one field per non-trivial format
 	for i := 0; i <= end; {
-		c, w := utf8.DecodeRuneInString(format[i:]);
+		c, w := utf8.DecodeRuneInString(format[i:])
 		if c != '%' || i == end {
 			if w == 1 {
 				p.buf.WriteByte(byte(c))
 			} else {
 				p.buf.WriteString(format[i : i+w])
 			}
-			i += w;
-			continue;
+			i += w
+			continue
 		}
-		i++;
+		i++
 		// flags and widths
-		p.fmt.clearflags();
-	F:	for ; i < end; i++ {
+		p.fmt.clearflags()
+	F: for ; i < end; i++ {
 			switch format[i] {
 			case '#':
 				p.fmt.sharp = true
@@ -639,34 +639,34 @@ func (p *pp) doprintf(format string, v *reflect.StructValue) {
 			}
 		}
 		// do we have 20 (width)?
-		p.fmt.wid, p.fmt.widPresent, i = parsenum(format, i, end);
+		p.fmt.wid, p.fmt.widPresent, i = parsenum(format, i, end)
 		// do we have .20 (precision)?
 		if i < end && format[i] == '.' {
 			p.fmt.prec, p.fmt.precPresent, i = parsenum(format, i+1, end)
 		}
-		c, w = utf8.DecodeRuneInString(format[i:]);
-		i += w;
+		c, w = utf8.DecodeRuneInString(format[i:])
+		i += w
 		// percent is special - absorbs no operand
 		if c == '%' {
-			p.buf.WriteByte('%');	// TODO: should we bother with width & prec?
-			continue;
+			p.buf.WriteByte('%') // TODO: should we bother with width & prec?
+			continue
 		}
-		if fieldnum >= v.NumField() {	// out of operands
-			p.buf.WriteByte('%');
-			p.add(c);
-			p.buf.Write(missingBytes);
-			continue;
+		if fieldnum >= v.NumField() { // out of operands
+			p.buf.WriteByte('%')
+			p.add(c)
+			p.buf.Write(missingBytes)
+			continue
 		}
-		field := getField(v, fieldnum);
-		fieldnum++;
+		field := getField(v, fieldnum)
+		fieldnum++
 
 		// Try formatter except for %T,
 		// which is special and handled internally.
-		inter := field.Interface();
+		inter := field.Interface()
 		if inter != nil && c != 'T' {
 			if formatter, ok := inter.(Formatter); ok {
-				formatter.Format(p, c);
-				continue;
+				formatter.Format(p, c)
+				continue
 			}
 		}
 
@@ -686,7 +686,7 @@ func (p *pp) doprintf(format string, v *reflect.StructValue) {
 		// int
 		case 'b':
 			if v, _, ok := getInt(field); ok {
-				p.fmt.fmt_b64(uint64(v))	// always unsigned
+				p.fmt.fmt_b64(uint64(v)) // always unsigned
 			} else if v, ok := getFloat32(field); ok {
 				p.fmt.fmt_fb32(v)
 			} else if v, ok := getFloat64(field); ok {
@@ -792,8 +792,8 @@ func (p *pp) doprintf(format string, v *reflect.StructValue) {
 			if inter != nil {
 				// if object implements String, use the result.
 				if stringer, ok := inter.(Stringer); ok {
-					p.fmt.fmt_s(stringer.String());
-					break;
+					p.fmt.fmt_s(stringer.String())
+					break
 				}
 			}
 			if v, ok := getString(field); ok {
@@ -814,8 +814,8 @@ func (p *pp) doprintf(format string, v *reflect.StructValue) {
 				if v == 0 {
 					p.buf.Write(nilAngleBytes)
 				} else {
-					p.fmt.fmt_s("0x");
-					p.fmt.fmt_uX64(uint64(v));
+					p.fmt.fmt_s("0x")
+					p.fmt.fmt_uX64(uint64(v))
 				}
 			} else {
 				goto badtype
@@ -823,10 +823,10 @@ func (p *pp) doprintf(format string, v *reflect.StructValue) {
 
 		// arbitrary value; do your best
 		case 'v':
-			plus, sharp := p.fmt.plus, p.fmt.sharp;
-			p.fmt.plus = false;
-			p.fmt.sharp = false;
-			p.printField(field, plus, sharp, 0);
+			plus, sharp := p.fmt.plus, p.fmt.sharp
+			p.fmt.plus = false
+			p.fmt.sharp = false
+			p.printField(field, plus, sharp, 0)
 
 		// the value's type
 		case 'T':
@@ -834,42 +834,42 @@ func (p *pp) doprintf(format string, v *reflect.StructValue) {
 
 		default:
 		badtype:
-			p.buf.WriteByte('%');
-			p.add(c);
-			p.buf.WriteByte('(');
-			p.buf.WriteString(field.Type().String());
-			p.buf.WriteByte('=');
-			p.printField(field, false, false, 0);
-			p.buf.WriteByte(')');
+			p.buf.WriteByte('%')
+			p.add(c)
+			p.buf.WriteByte('(')
+			p.buf.WriteString(field.Type().String())
+			p.buf.WriteByte('=')
+			p.printField(field, false, false, 0)
+			p.buf.WriteByte(')')
 		}
 	}
 	if fieldnum < v.NumField() {
-		p.buf.Write(extraBytes);
+		p.buf.Write(extraBytes)
 		for ; fieldnum < v.NumField(); fieldnum++ {
-			field := getField(v, fieldnum);
-			p.buf.WriteString(field.Type().String());
-			p.buf.WriteByte('=');
-			p.printField(field, false, false, 0);
+			field := getField(v, fieldnum)
+			p.buf.WriteString(field.Type().String())
+			p.buf.WriteByte('=')
+			p.printField(field, false, false, 0)
 			if fieldnum+1 < v.NumField() {
 				p.buf.Write(commaSpaceBytes)
 			}
 		}
-		p.buf.WriteByte(')');
+		p.buf.WriteByte(')')
 	}
 }
 
 func (p *pp) doprint(v *reflect.StructValue, addspace, addnewline bool) {
-	prev_string := false;
+	prev_string := false
 	for fieldnum := 0; fieldnum < v.NumField(); fieldnum++ {
 		// always add spaces if we're doing println
-		field := getField(v, fieldnum);
+		field := getField(v, fieldnum)
 		if fieldnum > 0 {
-			_, is_string := field.(*reflect.StringValue);
+			_, is_string := field.(*reflect.StringValue)
 			if addspace || !is_string && !prev_string {
 				p.buf.WriteByte(' ')
 			}
 		}
-		prev_string = p.printField(field, false, false, 0);
+		prev_string = p.printField(field, false, false, 0)
 	}
 	if addnewline {
 		p.buf.WriteByte('\n')
