commit 515e6a9b12dfe654c86cfd070ee5d6ac144fe116
Author: Alex Brainman <alex.brainman@gmail.com>
Date:   Sun Jul 19 16:06:48 2020 +1000

    runtime: use CreateWaitableTimerEx to implement usleep
    
    @jstarks suggested that recent versions of Windows provide access to high resolution timers. See
    
    https://github.com/golang/go/issues/8687#issuecomment-656259353
    
    for details.
    
    I tried to run this C program on my Windows 10 computer
    
    ```
     #include <stdio.h>
     #include <Windows.h>
    
     #pragma comment(lib, "Winmm.lib")
    
    // Apparently this is already defined when I use msvc cl.
    //#define CREATE_WAITABLE_TIMER_HIGH_RESOLUTION = 0x00000002;
    
    int usleep(HANDLE timer, LONGLONG d) {
            LARGE_INTEGER liDueTime;
            DWORD ret;
            LARGE_INTEGER StartingTime, EndingTime, ElapsedMicroseconds;
            LARGE_INTEGER Frequency;
    
            QueryPerformanceFrequency(&Frequency);
            QueryPerformanceCounter(&StartingTime);
    
            liDueTime.QuadPart = d;
            liDueTime.QuadPart = liDueTime.QuadPart * 10;   // us into 100 of ns units
            liDueTime.QuadPart = -liDueTime.QuadPart;       // negative for relative dure time
    
            if (!SetWaitableTimer(timer, &liDueTime, 0, NULL, NULL, 0)) {
                    printf("SetWaitableTimer failed: errno=%d\n", GetLastError());
                    return 1;
            }
    
            ret = WaitForSingleObject(timer, INFINITE);
            if (ret != WAIT_OBJECT_0) {
                    printf("WaitForSingleObject failed: ret=%d errno=%d\n", ret, GetLastError());
                    return 1;
            }
    
            QueryPerformanceCounter(&EndingTime);
            ElapsedMicroseconds.QuadPart = EndingTime.QuadPart - StartingTime.QuadPart;
            ElapsedMicroseconds.QuadPart *= 1000000;
            ElapsedMicroseconds.QuadPart /= Frequency.QuadPart;
    
            printf("delay is %lld us - slept for %lld us\n", d, ElapsedMicroseconds.QuadPart);
    
            return 0;
    }
    
    int testTimer(DWORD createFlag)
    {
            HANDLE timer;
    
            timer = CreateWaitableTimerEx(NULL, NULL, createFlag, TIMER_ALL_ACCESS);
            if (timer == NULL) {
                    printf("CreateWaitableTimerEx failed: errno=%d\n", GetLastError());
                    return 1;
            }
    
            usleep(timer, 1000LL);
            usleep(timer, 100LL);
            usleep(timer, 10LL);
            usleep(timer, 1LL);
    
            CloseHandle(timer);
    
            return 0;
    }
    
    int main()
    {
            printf("\n1. CREATE_WAITABLE_TIMER_HIGH_RESOLUTION is off - timeBeginPeriod is off\n");
            testTimer(0);
    
            printf("\n2. CREATE_WAITABLE_TIMER_HIGH_RESOLUTION is on - timeBeginPeriod is off\n");
            testTimer(CREATE_WAITABLE_TIMER_HIGH_RESOLUTION);
    
            timeBeginPeriod(1);
    
            printf("\n3. CREATE_WAITABLE_TIMER_HIGH_RESOLUTION is off - timeBeginPeriod is on\n");
            testTimer(0);
    
            printf("\n4. CREATE_WAITABLE_TIMER_HIGH_RESOLUTION is on - timeBeginPeriod is on\n");
            testTimer(CREATE_WAITABLE_TIMER_HIGH_RESOLUTION);
    }
    ```
    
    and I see this output
    
    ```
    1. CREATE_WAITABLE_TIMER_HIGH_RESOLUTION is off - timeBeginPeriod is off
    delay is 1000 us - slept for 4045 us
    delay is 100 us - slept for 3915 us
    delay is 10 us - slept for 3291 us
    delay is 1 us - slept for 2234 us
    
    2. CREATE_WAITABLE_TIMER_HIGH_RESOLUTION is on - timeBeginPeriod is off
    delay is 1000 us - slept for 1076 us
    delay is 100 us - slept for 569 us
    delay is 10 us - slept for 585 us
    delay is 1 us - slept for 17 us
    
    3. CREATE_WAITABLE_TIMER_HIGH_RESOLUTION is off - timeBeginPeriod is on
    delay is 1000 us - slept for 742 us
    delay is 100 us - slept for 893 us
    delay is 10 us - slept for 414 us
    delay is 1 us - slept for 920 us
    
    4. CREATE_WAITABLE_TIMER_HIGH_RESOLUTION is on - timeBeginPeriod is on
    delay is 1000 us - slept for 1466 us
    delay is 100 us - slept for 559 us
    delay is 10 us - slept for 535 us
    delay is 1 us - slept for 5 us
    ```
    
    That shows, that indeed using CREATE_WAITABLE_TIMER_HIGH_RESOLUTION
    will provide sleeps as low as about 500 microseconds, while our
    current approach provides about 1 millisecond sleep.
    
    New approach also does not require for timeBeginPeriod to be on,
    so this change solves long standing problem with go programs draining
    laptop battery, because it calls timeBeginPeriod.
    
    This change will only run on systems where
    CREATE_WAITABLE_TIMER_HIGH_RESOLUTION flag is available. If not
    available, the runtime will fallback to original code that uses
    timeBeginPeriod.
    
    This is how this change affects benchmark reported in issue #14790
    
    name               old time/op  new time/op  delta
    ChanToSyscallPing  1.05ms ± 2%  0.68ms ±11%  -35.43%  (p=0.000 n=10+10)
    
    The benchmark was run with GOMAXPROCS set to 1.
    
    Fixes #8687
    Updates #14790
    
    Change-Id: I5b97ba58289c088c17c05292e12e45285c467eae
    Reviewed-on: https://go-review.googlesource.com/c/go/+/248699
    Run-TryBot: Alex Brainman <alex.brainman@gmail.com>
    TryBot-Result: Go Bot <gobot@golang.org>
    Trust: Alex Brainman <alex.brainman@gmail.com>
    Reviewed-by: Austin Clements <austin@google.com>

 src/runtime/os_windows.go       | 73 +++++++++++++++++++++++++++++++++++++++--
 src/runtime/sys_windows_386.s   | 36 ++++++++++++++++++++
 src/runtime/sys_windows_amd64.s | 32 ++++++++++++++++++
 src/runtime/sys_windows_arm.s   |  5 +++
 4 files changed, 144 insertions(+), 2 deletions(-)
