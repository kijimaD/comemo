commit 4ca2fc4d8b3579dc719e7d6e79c2283bfb026a4d
Author: Russ Cox <rsc@golang.org>
Date:   Wed Jan 21 12:01:38 2015 -0500

    [dev.cc] cmd/new5a etc, cmd/internal/asm: edit to produce working Go code
    
    These assemblers produce byte-for-byte identical output
    to the ones written in C.
    
    They are primarily a proof that cmd/internal/obj can be used
    standalone to produce working object files. (The use via objwriter
    starts by deserializing an already-constructed internal representation,
    so objwriter does not exercise the code in cmd/internal/obj that
    creates such a representation from scratch.)
    
    Change-Id: I1793d8d010046cfb9d8b4d2d4469e7f47a3d3ac7
    Reviewed-on: https://go-review.googlesource.com/3143
    Reviewed-by: Rob Pike <r@golang.org>
    Reviewed-by: Ian Lance Taylor <iant@golang.org>
---
 .gitignore                      |    4 +-
 src/cmd/go/pkg.go               |    4 +
 src/cmd/internal/asm/asm.go     | 1179 +++++----------------------
 src/cmd/internal/asm/lexbody.go |  820 +++++++++----------
 src/cmd/internal/asm/macbody.go |  399 ++++-----
 src/cmd/new5a/a.y               |  296 +++----
 src/cmd/new5a/lex.go            |  231 ++----
 src/cmd/new5a/y.go              | 1315 ++++++++++++++++++++++++++++++
 src/cmd/new6a/a.y               |  303 +++----
 src/cmd/new6a/lex.go            |  233 ++----
 src/cmd/new6a/y.go              | 1313 ++++++++++++++++++++++++++++++
 src/cmd/new8a/a.y               |  313 ++++----
 src/cmd/new8a/lex.go            |  226 ++----
 src/cmd/new8a/y.go              | 1306 ++++++++++++++++++++++++++++++
 src/cmd/new9a/a.y               |  489 +++++------
 src/cmd/new9a/lex.go            |  248 ++----
 src/cmd/new9a/y.go              | 1694 +++++++++++++++++++++++++++++++++++++++
 17 files changed, 7298 insertions(+), 3075 deletions(-)

diff --git a/.gitignore b/.gitignore
index f1c7263237..585cd0f12b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -26,14 +26,12 @@ misc/cgo/life/run.out
 misc/cgo/stdio/run.out
 misc/cgo/testso/main
 misc/dashboard/builder/builder
-src/cmd/?a/y.output
 src/liblink/anames?.c
-src/cmd/cc/y.output
+src/cmd/*/y.output
 src/cmd/cgo/zdefaultcc.go
 src/cmd/dist/dist.dSYM
 src/cmd/gc/mkbuiltin1
 src/cmd/gc/opnames.h
-src/cmd/gc/y.output
 src/cmd/go/zdefaultcc.go
 src/cmd/internal/obj/zbootstrap.go
 src/go/doc/headscan
diff --git a/src/cmd/go/pkg.go b/src/cmd/go/pkg.go
index ccecf6a867..e224eef091 100644
--- a/src/cmd/go/pkg.go
+++ b/src/cmd/go/pkg.go
@@ -396,6 +396,10 @@ var goTools = map[string]targetDir{
 	"cmd/cgo":                              toTool,
 	"cmd/fix":                              toTool,
 	"cmd/link":                             toTool,
+	"cmd/new5a":                            toTool,
+	"cmd/new6a":                            toTool,
+	"cmd/new8a":                            toTool,
+	"cmd/new9a":                            toTool,
 	"cmd/nm":                               toTool,
 	"cmd/objdump":                          toTool,
 	"cmd/objwriter":                        toTool,
diff --git a/src/cmd/internal/asm/asm.go b/src/cmd/internal/asm/asm.go
index 264c119f3d..71c6b1a23c 100644
--- a/src/cmd/internal/asm/asm.go
+++ b/src/cmd/internal/asm/asm.go
@@ -1,4 +1,5 @@
-// Inferno utils/6a/lex.c
+// Inferno utils/6a/a.h and lex.c.
+// http://code.google.com/p/inferno-os/source/browse/utils/6a/a.h
 // http://code.google.com/p/inferno-os/source/browse/utils/6a/lex.c
 //
 //	Copyright © 1994-1999 Lucent Technologies Inc.	All rights reserved.
@@ -28,1075 +29,283 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-package main
+// Package asm holds code shared among the assemblers.
+package asm
+
+import (
+	"flag"
+	"fmt"
+	"log"
+	"os"
+	"path/filepath"
+	"strconv"
+	"strings"
+
+	"cmd/internal/obj"
+)
+
+// Initialized by client.
+var (
+	LSCONST int
+	LCONST  int
+	LFCONST int
+	LNAME   int
+	LVAR    int
+	LLAB    int
+
+	Thechar     rune
+	Thestring   string
+	Thelinkarch *obj.LinkArch
+
+	Arches map[string]*obj.LinkArch
+
+	Cclean  func()
+	Yyparse func()
+	Syminit func(*Sym)
+
+	Lexinit []Lextab
+)
+
+type Lextab struct {
+	Name  string
+	Type  int
+	Value int64
+}
+
+const (
+	MAXALIGN = 7
+	FPCHIP   = 1
+	NSYMB    = 500
+	BUFSIZ   = 8192
+	HISTSZ   = 20
+	EOF      = -1
+	IGN      = -2
+	NHASH    = 503
+	STRINGSZ = 200
+	NMACRO   = 10
+)
 
 const (
-	Plan9   = 1 << 0
-	Unix    = 1 << 1
-	Windows = 1 << 2
+	CLAST = iota
+	CMACARG
+	CMACRO
+	CPREPROC
 )
 
-func systemtype(sys int) int {
-	return sys & Windows
+type Macro struct {
+	Text string
+	Narg int
+	Dots bool
+}
 
-	return sys & Plan9
+type Sym struct {
+	Link      *Sym
+	Ref       *Ref
+	Macro     *Macro
+	Value     int64
+	Type      int
+	Name      string
+	Labelname string
+	Sym       int8
 }
 
-func pathchar() int {
-	return '/'
+type Ref struct {
+	Class int
 }
 
-func Lconv(fp *obj.Fmt) int {
-	return obj.Linklinefmt(ctxt, fp)
+type Io struct {
+	Link *Io
+	P    []byte
+	F    *os.File
+	B    [1024]byte
 }
 
-func dodef(p string) {
-	if nDlist%8 == 0 {
-		Dlist = allocn(Dlist, nDlist*sizeof(string), 8*sizeof(string)).(*string)
-	}
-	Dlist[nDlist] = p
-	nDlist++
+var fi struct {
+	P []byte
 }
 
-var thelinkarch *obj.LinkArch = &x86.Linkamd64
+var (
+	debug    [256]int
+	hash     = map[string]*Sym{}
+	Dlist    []string
+	newflag  int
+	hunk     string
+	include  []string
+	iofree   *Io
+	ionext   *Io
+	iostack  *Io
+	Lineno   int32
+	nerrors  int
+	nhunk    int32
+	ninclude int
+	nsymb    int32
+	nullgen  obj.Addr
+	outfile  string
+	Pass     int
+	PC       int32
+	peekc    int = IGN
+	sym      int
+	symb     string
+	thunk    int32
+	obuf     obj.Biobuf
+	Ctxt     *obj.Link
+	bstdout  obj.Biobuf
+)
+
+func dodef(p string) {
+	Dlist = append(Dlist, p)
+}
 
 func usage() {
-	fmt.Printf("usage: %ca [options] file.c...\n", thechar)
-	main.Flagprint(1)
+	fmt.Printf("usage: %ca [options] file.c...\n", Thechar)
+	flag.PrintDefaults()
 	errorexit()
 }
 
-func main(argc int, argv [XXX]string) {
+func Main() {
 	var p string
 
-	thechar = '6'
-	thestring = "amd64"
-
-	// Allow GOARCH=thestring or GOARCH=thestringsuffix,
+	// Allow GOARCH=Thestring or GOARCH=Thestringsuffix,
 	// but not other values.
-	p = Getgoarch()
+	p = obj.Getgoarch()
 
-	if !strings.HasPrefix(p, thestring) {
-		log.Fatalf("cannot use %cc with GOARCH=%s", thechar, p)
+	if !strings.HasPrefix(p, Thestring) {
+		log.Fatalf("cannot use %cc with GOARCH=%s", Thechar, p)
 	}
-	if p == "amd64p32" {
-		thelinkarch = &x86.Linkamd64p32
+	if p != Thestring {
+		Thelinkarch = Arches[p]
+		if Thelinkarch == nil {
+			log.Fatalf("unknown arch %s", p)
+		}
 	}
 
-	ctxt = obj.Linknew(thelinkarch)
-	ctxt.Diag = yyerror
-	ctxt.Bso = &bstdout
-	ctxt.Enforce_data_order = 1
-	obj.Binit(&bstdout, 1, main.OWRITE)
-	x86.Listinit6()
-	obj.Fmtinstall('L', Lconv)
+	Ctxt = obj.Linknew(Thelinkarch)
+	Ctxt.Diag = Yyerror
+	Ctxt.Bso = &bstdout
+	Ctxt.Enforce_data_order = 1
+	bstdout = *obj.Binitw(os.Stdout)
 
-	ensuresymb(NSYMB)
 	debug = [256]int{}
 	cinit()
 	outfile = ""
 	setinclude(".")
 
-	main.Flagfn1("D", "name[=value]: add #define", dodef)
-	main.Flagfn1("I", "dir: add dir to include path", setinclude)
-	main.Flagcount("S", "print assembly and machine code", &debug['S'])
-	main.Flagcount("m", "debug preprocessor macros", &debug['m'])
-	main.Flagstr("o", "file: set output file", &outfile)
-	main.Flagstr("trimpath", "prefix: remove prefix from recorded source file paths", &ctxt.Trimpath)
+	flag.Var(flagFn(dodef), "D", "name[=value]: add #define")
+	flag.Var(flagFn(setinclude), "I", "dir: add dir to include path")
+	flag.Var((*count)(&debug['S']), "S", "print assembly and machine code")
+	flag.Var((*count)(&debug['m']), "m", "debug preprocessor macros")
+	flag.StringVar(&outfile, "o", "", "file: set output file")
+	flag.StringVar(&Ctxt.Trimpath, "trimpath", "", "prefix: remove prefix from recorded source file paths")
+
+	flag.Parse()
 
-	main.Flagparse(&argc, (**string)(&argv), usage)
-	ctxt.Debugasm = int32(debug['S'])
+	Ctxt.Debugasm = int32(debug['S'])
 
-	if argc < 1 {
+	if flag.NArg() < 1 {
 		usage()
 	}
-	if argc > 1 {
+	if flag.NArg() > 1 {
 		fmt.Printf("can't assemble multiple files\n")
 		errorexit()
 	}
 
-	if assemble(argv[0]) != 0 {
+	if assemble(flag.Arg(0)) != 0 {
 		errorexit()
 	}
 	obj.Bflush(&bstdout)
 	if nerrors > 0 {
 		errorexit()
 	}
-	main.Exits("")
 }
 
 func assemble(file string) int {
-	var ofile string
-	var p string
 	var i int
-	var of int
-
-	ofile = alloc(int32(len(file)) + 3).(string) // +3 for .x\0 (x=thechar)
-	ofile = file
-	p = main.Utfrrune(ofile, uint(pathchar()))
-	if p != "" {
-		include[0] = ofile
-		p = ""
-		p = p[1:]
-	} else {
 
-		p = ofile
-	}
 	if outfile == "" {
-		outfile = p
-		if outfile != "" {
-			p = main.Utfrrune(outfile, '.')
-			if p != "" {
-				if p[1] == 's' && p[2] == 0 {
-					p = ""
-				}
-			}
-			p = main.Utfrune(outfile, 0)
-			p[0] = '.'
-			p[1] = byte(thechar)
-			p[2] = 0
-		} else {
-
-			outfile = "/dev/null"
-		}
+		outfile = strings.TrimSuffix(filepath.Base(file), ".s") + "." + string(Thechar)
 	}
 
-	of = main.Create(outfile, main.OWRITE, 0664)
-	if of < 0 {
-		yyerror("%ca: cannot create %s", thechar, outfile)
+	of, err := os.Create(outfile)
+	if err != nil {
+		Yyerror("%ca: cannot create %s", Thechar, outfile)
 		errorexit()
 	}
 
-	obj.Binit(&obuf, of, main.OWRITE)
-	fmt.Fprintf(&obuf, "go object %s %s %s\n", main.Getgoos(), main.Getgoarch(), main.Getgoversion())
+	obuf = *obj.Binitw(of)
+	fmt.Fprintf(&obuf, "go object %s %s %s\n", obj.Getgoos(), obj.Getgoarch(), obj.Getgoversion())
 	fmt.Fprintf(&obuf, "!\n")
 
-	for pass = 1; pass <= 2; pass++ {
+	for Pass = 1; Pass <= 2; Pass++ {
 		pinit(file)
-		for i = 0; i < nDlist; i++ {
+		for i = 0; i < len(Dlist); i++ {
 			dodefine(Dlist[i])
 		}
-		yyparse()
-		cclean()
+		Yyparse()
+		Cclean()
 		if nerrors != 0 {
 			return nerrors
 		}
 	}
 
-	obj.Writeobj(ctxt, &obuf)
+	obj.Writeobjdirect(Ctxt, &obuf)
 	obj.Bflush(&obuf)
 	return 0
 }
 
-var itab = []struct {
-	name  string
-	type_ uint16
-	value uint16
-}{
-	{"SP", LSP, x86.D_AUTO},
-	{"SB", LSB, x86.D_EXTERN},
-	{"FP", LFP, x86.D_PARAM},
-	{"PC", LPC, x86.D_BRANCH},
-	{"AL", LBREG, x86.D_AL},
-	{"CL", LBREG, x86.D_CL},
-	{"DL", LBREG, x86.D_DL},
-	{"BL", LBREG, x86.D_BL},
-	/*	"SPB",		LBREG,	D_SPB,	*/
-	{"SIB", LBREG, x86.D_SIB},
-	{"DIB", LBREG, x86.D_DIB},
-	{"BPB", LBREG, x86.D_BPB},
-	{"R8B", LBREG, x86.D_R8B},
-	{"R9B", LBREG, x86.D_R9B},
-	{"R10B", LBREG, x86.D_R10B},
-	{"R11B", LBREG, x86.D_R11B},
-	{"R12B", LBREG, x86.D_R12B},
-	{"R13B", LBREG, x86.D_R13B},
-	{"R14B", LBREG, x86.D_R14B},
-	{"R15B", LBREG, x86.D_R15B},
-	{"AH", LBREG, x86.D_AH},
-	{"CH", LBREG, x86.D_CH},
-	{"DH", LBREG, x86.D_DH},
-	{"BH", LBREG, x86.D_BH},
-	{"AX", LLREG, x86.D_AX},
-	{"CX", LLREG, x86.D_CX},
-	{"DX", LLREG, x86.D_DX},
-	{"BX", LLREG, x86.D_BX},
-
-	/*	"SP",		LLREG,	D_SP,	*/
-	{"BP", LLREG, x86.D_BP},
-	{"SI", LLREG, x86.D_SI},
-	{"DI", LLREG, x86.D_DI},
-	{"R8", LLREG, x86.D_R8},
-	{"R9", LLREG, x86.D_R9},
-	{"R10", LLREG, x86.D_R10},
-	{"R11", LLREG, x86.D_R11},
-	{"R12", LLREG, x86.D_R12},
-	{"R13", LLREG, x86.D_R13},
-	{"R14", LLREG, x86.D_R14},
-	{"R15", LLREG, x86.D_R15},
-	{"RARG", LLREG, x86.REGARG},
-	{"F0", LFREG, x86.D_F0 + 0},
-	{"F1", LFREG, x86.D_F0 + 1},
-	{"F2", LFREG, x86.D_F0 + 2},
-	{"F3", LFREG, x86.D_F0 + 3},
-	{"F4", LFREG, x86.D_F0 + 4},
-	{"F5", LFREG, x86.D_F0 + 5},
-	{"F6", LFREG, x86.D_F0 + 6},
-	{"F7", LFREG, x86.D_F0 + 7},
-	{"M0", LMREG, x86.D_M0 + 0},
-	{"M1", LMREG, x86.D_M0 + 1},
-	{"M2", LMREG, x86.D_M0 + 2},
-	{"M3", LMREG, x86.D_M0 + 3},
-	{"M4", LMREG, x86.D_M0 + 4},
-	{"M5", LMREG, x86.D_M0 + 5},
-	{"M6", LMREG, x86.D_M0 + 6},
-	{"M7", LMREG, x86.D_M0 + 7},
-	{"X0", LXREG, x86.D_X0 + 0},
-	{"X1", LXREG, x86.D_X0 + 1},
-	{"X2", LXREG, x86.D_X0 + 2},
-	{"X3", LXREG, x86.D_X0 + 3},
-	{"X4", LXREG, x86.D_X0 + 4},
-	{"X5", LXREG, x86.D_X0 + 5},
-	{"X6", LXREG, x86.D_X0 + 6},
-	{"X7", LXREG, x86.D_X0 + 7},
-	{"X8", LXREG, x86.D_X0 + 8},
-	{"X9", LXREG, x86.D_X0 + 9},
-	{"X10", LXREG, x86.D_X0 + 10},
-	{"X11", LXREG, x86.D_X0 + 11},
-	{"X12", LXREG, x86.D_X0 + 12},
-	{"X13", LXREG, x86.D_X0 + 13},
-	{"X14", LXREG, x86.D_X0 + 14},
-	{"X15", LXREG, x86.D_X0 + 15},
-	{"CS", LSREG, x86.D_CS},
-	{"SS", LSREG, x86.D_SS},
-	{"DS", LSREG, x86.D_DS},
-	{"ES", LSREG, x86.D_ES},
-	{"FS", LSREG, x86.D_FS},
-	{"GS", LSREG, x86.D_GS},
-	{"GDTR", LBREG, x86.D_GDTR},
-	{"IDTR", LBREG, x86.D_IDTR},
-	{"LDTR", LBREG, x86.D_LDTR},
-	{"MSW", LBREG, x86.D_MSW},
-	{"TASK", LBREG, x86.D_TASK},
-	{"CR0", LBREG, x86.D_CR + 0},
-	{"CR1", LBREG, x86.D_CR + 1},
-	{"CR2", LBREG, x86.D_CR + 2},
-	{"CR3", LBREG, x86.D_CR + 3},
-	{"CR4", LBREG, x86.D_CR + 4},
-	{"CR5", LBREG, x86.D_CR + 5},
-	{"CR6", LBREG, x86.D_CR + 6},
-	{"CR7", LBREG, x86.D_CR + 7},
-	{"CR8", LBREG, x86.D_CR + 8},
-	{"CR9", LBREG, x86.D_CR + 9},
-	{"CR10", LBREG, x86.D_CR + 10},
-	{"CR11", LBREG, x86.D_CR + 11},
-	{"CR12", LBREG, x86.D_CR + 12},
-	{"CR13", LBREG, x86.D_CR + 13},
-	{"CR14", LBREG, x86.D_CR + 14},
-	{"CR15", LBREG, x86.D_CR + 15},
-	{"DR0", LBREG, x86.D_DR + 0},
-	{"DR1", LBREG, x86.D_DR + 1},
-	{"DR2", LBREG, x86.D_DR + 2},
-	{"DR3", LBREG, x86.D_DR + 3},
-	{"DR4", LBREG, x86.D_DR + 4},
-	{"DR5", LBREG, x86.D_DR + 5},
-	{"DR6", LBREG, x86.D_DR + 6},
-	{"DR7", LBREG, x86.D_DR + 7},
-	{"TR0", LBREG, x86.D_TR + 0},
-	{"TR1", LBREG, x86.D_TR + 1},
-	{"TR2", LBREG, x86.D_TR + 2},
-	{"TR3", LBREG, x86.D_TR + 3},
-	{"TR4", LBREG, x86.D_TR + 4},
-	{"TR5", LBREG, x86.D_TR + 5},
-	{"TR6", LBREG, x86.D_TR + 6},
-	{"TR7", LBREG, x86.D_TR + 7},
-	{"TLS", LSREG, x86.D_TLS},
-	{"AAA", LTYPE0, x86.AAAA},
-	{"AAD", LTYPE0, x86.AAAD},
-	{"AAM", LTYPE0, x86.AAAM},
-	{"AAS", LTYPE0, x86.AAAS},
-	{"ADCB", LTYPE3, x86.AADCB},
-	{"ADCL", LTYPE3, x86.AADCL},
-	{"ADCQ", LTYPE3, x86.AADCQ},
-	{"ADCW", LTYPE3, x86.AADCW},
-	{"ADDB", LTYPE3, x86.AADDB},
-	{"ADDL", LTYPE3, x86.AADDL},
-	{"ADDQ", LTYPE3, x86.AADDQ},
-	{"ADDW", LTYPE3, x86.AADDW},
-	{"ADJSP", LTYPE2, x86.AADJSP},
-	{"ANDB", LTYPE3, x86.AANDB},
-	{"ANDL", LTYPE3, x86.AANDL},
-	{"ANDQ", LTYPE3, x86.AANDQ},
-	{"ANDW", LTYPE3, x86.AANDW},
-	{"ARPL", LTYPE3, x86.AARPL},
-	{"BOUNDL", LTYPE3, x86.ABOUNDL},
-	{"BOUNDW", LTYPE3, x86.ABOUNDW},
-	{"BSFL", LTYPE3, x86.ABSFL},
-	{"BSFQ", LTYPE3, x86.ABSFQ},
-	{"BSFW", LTYPE3, x86.ABSFW},
-	{"BSRL", LTYPE3, x86.ABSRL},
-	{"BSRQ", LTYPE3, x86.ABSRQ},
-	{"BSRW", LTYPE3, x86.ABSRW},
-	{"BSWAPL", LTYPE1, x86.ABSWAPL},
-	{"BSWAPQ", LTYPE1, x86.ABSWAPQ},
-	{"BTCL", LTYPE3, x86.ABTCL},
-	{"BTCQ", LTYPE3, x86.ABTCQ},
-	{"BTCW", LTYPE3, x86.ABTCW},
-	{"BTL", LTYPE3, x86.ABTL},
-	{"BTQ", LTYPE3, x86.ABTQ},
-	{"BTRL", LTYPE3, x86.ABTRL},
-	{"BTRQ", LTYPE3, x86.ABTRQ},
-	{"BTRW", LTYPE3, x86.ABTRW},
-	{"BTSL", LTYPE3, x86.ABTSL},
-	{"BTSQ", LTYPE3, x86.ABTSQ},
-	{"BTSW", LTYPE3, x86.ABTSW},
-	{"BTW", LTYPE3, x86.ABTW},
-	{"BYTE", LTYPE2, x86.ABYTE},
-	{"CALL", LTYPEC, x86.ACALL},
-	{"CLC", LTYPE0, x86.ACLC},
-	{"CLD", LTYPE0, x86.ACLD},
-	{"CLI", LTYPE0, x86.ACLI},
-	{"CLTS", LTYPE0, x86.ACLTS},
-	{"CMC", LTYPE0, x86.ACMC},
-	{"CMPB", LTYPE4, x86.ACMPB},
-	{"CMPL", LTYPE4, x86.ACMPL},
-	{"CMPQ", LTYPE4, x86.ACMPQ},
-	{"CMPW", LTYPE4, x86.ACMPW},
-	{"CMPSB", LTYPE0, x86.ACMPSB},
-	{"CMPSL", LTYPE0, x86.ACMPSL},
-	{"CMPSQ", LTYPE0, x86.ACMPSQ},
-	{"CMPSW", LTYPE0, x86.ACMPSW},
-	{"CMPXCHG8B", LTYPE1, x86.ACMPXCHG8B},
-	{"CMPXCHGB", LTYPE3, x86.ACMPXCHGB}, /* LTYPE3? */
-	{"CMPXCHGL", LTYPE3, x86.ACMPXCHGL},
-	{"CMPXCHGQ", LTYPE3, x86.ACMPXCHGQ},
-	{"CMPXCHGW", LTYPE3, x86.ACMPXCHGW},
-	{"CPUID", LTYPE0, x86.ACPUID},
-	{"DAA", LTYPE0, x86.ADAA},
-	{"DAS", LTYPE0, x86.ADAS},
-	{"DATA", LTYPED, x86.ADATA},
-	{"DECB", LTYPE1, x86.ADECB},
-	{"DECL", LTYPE1, x86.ADECL},
-	{"DECQ", LTYPE1, x86.ADECQ},
-	{"DECW", LTYPE1, x86.ADECW},
-	{"DIVB", LTYPE2, x86.ADIVB},
-	{"DIVL", LTYPE2, x86.ADIVL},
-	{"DIVQ", LTYPE2, x86.ADIVQ},
-	{"DIVW", LTYPE2, x86.ADIVW},
-	{"EMMS", LTYPE0, x86.AEMMS},
-	{"END", LTYPE0, x86.AEND},
-	{"ENTER", LTYPE2, x86.AENTER},
-	{"GLOBL", LTYPEG, x86.AGLOBL},
-	{"HLT", LTYPE0, x86.AHLT},
-	{"IDIVB", LTYPE2, x86.AIDIVB},
-	{"IDIVL", LTYPE2, x86.AIDIVL},
-	{"IDIVQ", LTYPE2, x86.AIDIVQ},
-	{"IDIVW", LTYPE2, x86.AIDIVW},
-	{"IMULB", LTYPEI, x86.AIMULB},
-	{"IMULL", LTYPEI, x86.AIMULL},
-	{"IMULQ", LTYPEI, x86.AIMULQ},
-	{"IMUL3Q", LTYPEX, x86.AIMUL3Q},
-	{"IMULW", LTYPEI, x86.AIMULW},
-	{"INB", LTYPE0, x86.AINB},
-	{"INL", LTYPE0, x86.AINL},
-	{"INW", LTYPE0, x86.AINW},
-	{"INCB", LTYPE1, x86.AINCB},
-	{"INCL", LTYPE1, x86.AINCL},
-	{"INCQ", LTYPE1, x86.AINCQ},
-	{"INCW", LTYPE1, x86.AINCW},
-	{"INSB", LTYPE0, x86.AINSB},
-	{"INSL", LTYPE0, x86.AINSL},
-	{"INSW", LTYPE0, x86.AINSW},
-	{"INT", LTYPE2, x86.AINT},
-	{"INTO", LTYPE0, x86.AINTO},
-	{"INVD", LTYPE0, x86.AINVD},
-	{"INVLPG", LTYPE2, x86.AINVLPG},
-	{"IRETL", LTYPE0, x86.AIRETL},
-	{"IRETQ", LTYPE0, x86.AIRETQ},
-	{"IRETW", LTYPE0, x86.AIRETW},
-	{"JOS", LTYPER, x86.AJOS},  /* overflow set (OF = 1) */
-	{"JO", LTYPER, x86.AJOS},   /* alternate */
-	{"JOC", LTYPER, x86.AJOC},  /* overflow clear (OF = 0) */
-	{"JNO", LTYPER, x86.AJOC},  /* alternate */
-	{"JCS", LTYPER, x86.AJCS},  /* carry set (CF = 1) */
-	{"JB", LTYPER, x86.AJCS},   /* alternate */
-	{"JC", LTYPER, x86.AJCS},   /* alternate */
-	{"JNAE", LTYPER, x86.AJCS}, /* alternate */
-	{"JLO", LTYPER, x86.AJCS},  /* alternate */
-	{"JCC", LTYPER, x86.AJCC},  /* carry clear (CF = 0) */
-	{"JAE", LTYPER, x86.AJCC},  /* alternate */
-	{"JNB", LTYPER, x86.AJCC},  /* alternate */
-	{"JNC", LTYPER, x86.AJCC},  /* alternate */
-	{"JHS", LTYPER, x86.AJCC},  /* alternate */
-	{"JEQ", LTYPER, x86.AJEQ},  /* equal (ZF = 1) */
-	{"JE", LTYPER, x86.AJEQ},   /* alternate */
-	{"JZ", LTYPER, x86.AJEQ},   /* alternate */
-	{"JNE", LTYPER, x86.AJNE},  /* not equal (ZF = 0) */
-	{"JNZ", LTYPER, x86.AJNE},  /* alternate */
-	{"JLS", LTYPER, x86.AJLS},  /* lower or same (unsigned) (CF = 1 || ZF = 1) */
-	{"JBE", LTYPER, x86.AJLS},  /* alternate */
-	{"JNA", LTYPER, x86.AJLS},  /* alternate */
-	{"JHI", LTYPER, x86.AJHI},  /* higher (unsigned) (CF = 0 && ZF = 0) */
-	{"JA", LTYPER, x86.AJHI},   /* alternate */
-	{"JNBE", LTYPER, x86.AJHI}, /* alternate */
-	{"JMI", LTYPER, x86.AJMI},  /* negative (minus) (SF = 1) */
-	{"JS", LTYPER, x86.AJMI},   /* alternate */
-	{"JPL", LTYPER, x86.AJPL},  /* non-negative (plus) (SF = 0) */
-	{"JNS", LTYPER, x86.AJPL},  /* alternate */
-	{"JPS", LTYPER, x86.AJPS},  /* parity set (PF = 1) */
-	{"JP", LTYPER, x86.AJPS},   /* alternate */
-	{"JPE", LTYPER, x86.AJPS},  /* alternate */
-	{"JPC", LTYPER, x86.AJPC},  /* parity clear (PF = 0) */
-	{"JNP", LTYPER, x86.AJPC},  /* alternate */
-	{"JPO", LTYPER, x86.AJPC},  /* alternate */
-	{"JLT", LTYPER, x86.AJLT},  /* less than (signed) (SF != OF) */
-	{"JL", LTYPER, x86.AJLT},   /* alternate */
-	{"JNGE", LTYPER, x86.AJLT}, /* alternate */
-	{"JGE", LTYPER, x86.AJGE},  /* greater than or equal (signed) (SF = OF) */
-	{"JNL", LTYPER, x86.AJGE},  /* alternate */
-	{"JLE", LTYPER, x86.AJLE},  /* less than or equal (signed) (ZF = 1 || SF != OF) */
-	{"JNG", LTYPER, x86.AJLE},  /* alternate */
-	{"JGT", LTYPER, x86.AJGT},  /* greater than (signed) (ZF = 0 && SF = OF) */
-	{"JG", LTYPER, x86.AJGT},   /* alternate */
-	{"JNLE", LTYPER, x86.AJGT}, /* alternate */
-	{"JCXZL", LTYPER, x86.AJCXZL},
-	{"JCXZQ", LTYPER, x86.AJCXZQ},
-	{"JMP", LTYPEC, x86.AJMP},
-	{"LAHF", LTYPE0, x86.ALAHF},
-	{"LARL", LTYPE3, x86.ALARL},
-	{"LARW", LTYPE3, x86.ALARW},
-	{"LEAL", LTYPE3, x86.ALEAL},
-	{"LEAQ", LTYPE3, x86.ALEAQ},
-	{"LEAW", LTYPE3, x86.ALEAW},
-	{"LEAVEL", LTYPE0, x86.ALEAVEL},
-	{"LEAVEQ", LTYPE0, x86.ALEAVEQ},
-	{"LEAVEW", LTYPE0, x86.ALEAVEW},
-	{"LFENCE", LTYPE0, x86.ALFENCE},
-	{"LOCK", LTYPE0, x86.ALOCK},
-	{"LODSB", LTYPE0, x86.ALODSB},
-	{"LODSL", LTYPE0, x86.ALODSL},
-	{"LODSQ", LTYPE0, x86.ALODSQ},
-	{"LODSW", LTYPE0, x86.ALODSW},
-	{"LONG", LTYPE2, x86.ALONG},
-	{"LOOP", LTYPER, x86.ALOOP},
-	{"LOOPEQ", LTYPER, x86.ALOOPEQ},
-	{"LOOPNE", LTYPER, x86.ALOOPNE},
-	{"LSLL", LTYPE3, x86.ALSLL},
-	{"LSLW", LTYPE3, x86.ALSLW},
-	{"MFENCE", LTYPE0, x86.AMFENCE},
-	{"MODE", LTYPE2, x86.AMODE},
-	{"MOVB", LTYPE3, x86.AMOVB},
-	{"MOVL", LTYPEM, x86.AMOVL},
-	{"MOVQ", LTYPEM, x86.AMOVQ},
-	{"MOVW", LTYPEM, x86.AMOVW},
-	{"MOVBLSX", LTYPE3, x86.AMOVBLSX},
-	{"MOVBLZX", LTYPE3, x86.AMOVBLZX},
-	{"MOVBQSX", LTYPE3, x86.AMOVBQSX},
-	{"MOVBQZX", LTYPE3, x86.AMOVBQZX},
-	{"MOVBWSX", LTYPE3, x86.AMOVBWSX},
-	{"MOVBWZX", LTYPE3, x86.AMOVBWZX},
-	{"MOVLQSX", LTYPE3, x86.AMOVLQSX},
-	{"MOVLQZX", LTYPE3, x86.AMOVLQZX},
-	{"MOVNTIL", LTYPE3, x86.AMOVNTIL},
-	{"MOVNTIQ", LTYPE3, x86.AMOVNTIQ},
-	{"MOVQL", LTYPE3, x86.AMOVQL},
-	{"MOVWLSX", LTYPE3, x86.AMOVWLSX},
-	{"MOVWLZX", LTYPE3, x86.AMOVWLZX},
-	{"MOVWQSX", LTYPE3, x86.AMOVWQSX},
-	{"MOVWQZX", LTYPE3, x86.AMOVWQZX},
-	{"MOVSB", LTYPE0, x86.AMOVSB},
-	{"MOVSL", LTYPE0, x86.AMOVSL},
-	{"MOVSQ", LTYPE0, x86.AMOVSQ},
-	{"MOVSW", LTYPE0, x86.AMOVSW},
-	{"MULB", LTYPE2, x86.AMULB},
-	{"MULL", LTYPE2, x86.AMULL},
-	{"MULQ", LTYPE2, x86.AMULQ},
-	{"MULW", LTYPE2, x86.AMULW},
-	{"NEGB", LTYPE1, x86.ANEGB},
-	{"NEGL", LTYPE1, x86.ANEGL},
-	{"NEGQ", LTYPE1, x86.ANEGQ},
-	{"NEGW", LTYPE1, x86.ANEGW},
-	{"NOP", LTYPEN, x86.ANOP},
-	{"NOTB", LTYPE1, x86.ANOTB},
-	{"NOTL", LTYPE1, x86.ANOTL},
-	{"NOTQ", LTYPE1, x86.ANOTQ},
-	{"NOTW", LTYPE1, x86.ANOTW},
-	{"ORB", LTYPE3, x86.AORB},
-	{"ORL", LTYPE3, x86.AORL},
-	{"ORQ", LTYPE3, x86.AORQ},
-	{"ORW", LTYPE3, x86.AORW},
-	{"OUTB", LTYPE0, x86.AOUTB},
-	{"OUTL", LTYPE0, x86.AOUTL},
-	{"OUTW", LTYPE0, x86.AOUTW},
-	{"OUTSB", LTYPE0, x86.AOUTSB},
-	{"OUTSL", LTYPE0, x86.AOUTSL},
-	{"OUTSW", LTYPE0, x86.AOUTSW},
-	{"PAUSE", LTYPEN, x86.APAUSE},
-	{"POPAL", LTYPE0, x86.APOPAL},
-	{"POPAW", LTYPE0, x86.APOPAW},
-	{"POPFL", LTYPE0, x86.APOPFL},
-	{"POPFQ", LTYPE0, x86.APOPFQ},
-	{"POPFW", LTYPE0, x86.APOPFW},
-	{"POPL", LTYPE1, x86.APOPL},
-	{"POPQ", LTYPE1, x86.APOPQ},
-	{"POPW", LTYPE1, x86.APOPW},
-	{"PUSHAL", LTYPE0, x86.APUSHAL},
-	{"PUSHAW", LTYPE0, x86.APUSHAW},
-	{"PUSHFL", LTYPE0, x86.APUSHFL},
-	{"PUSHFQ", LTYPE0, x86.APUSHFQ},
-	{"PUSHFW", LTYPE0, x86.APUSHFW},
-	{"PUSHL", LTYPE2, x86.APUSHL},
-	{"PUSHQ", LTYPE2, x86.APUSHQ},
-	{"PUSHW", LTYPE2, x86.APUSHW},
-	{"RCLB", LTYPE3, x86.ARCLB},
-	{"RCLL", LTYPE3, x86.ARCLL},
-	{"RCLQ", LTYPE3, x86.ARCLQ},
-	{"RCLW", LTYPE3, x86.ARCLW},
-	{"RCRB", LTYPE3, x86.ARCRB},
-	{"RCRL", LTYPE3, x86.ARCRL},
-	{"RCRQ", LTYPE3, x86.ARCRQ},
-	{"RCRW", LTYPE3, x86.ARCRW},
-	{"RDMSR", LTYPE0, x86.ARDMSR},
-	{"RDPMC", LTYPE0, x86.ARDPMC},
-	{"RDTSC", LTYPE0, x86.ARDTSC},
-	{"REP", LTYPE0, x86.AREP},
-	{"REPN", LTYPE0, x86.AREPN},
-	{"RET", LTYPE0, x86.ARET},
-	{"RETFL", LTYPERT, x86.ARETFL},
-	{"RETFW", LTYPERT, x86.ARETFW},
-	{"RETFQ", LTYPERT, x86.ARETFQ},
-	{"ROLB", LTYPE3, x86.AROLB},
-	{"ROLL", LTYPE3, x86.AROLL},
-	{"ROLQ", LTYPE3, x86.AROLQ},
-	{"ROLW", LTYPE3, x86.AROLW},
-	{"RORB", LTYPE3, x86.ARORB},
-	{"RORL", LTYPE3, x86.ARORL},
-	{"RORQ", LTYPE3, x86.ARORQ},
-	{"RORW", LTYPE3, x86.ARORW},
-	{"RSM", LTYPE0, x86.ARSM},
-	{"SAHF", LTYPE0, x86.ASAHF},
-	{"SALB", LTYPE3, x86.ASALB},
-	{"SALL", LTYPE3, x86.ASALL},
-	{"SALQ", LTYPE3, x86.ASALQ},
-	{"SALW", LTYPE3, x86.ASALW},
-	{"SARB", LTYPE3, x86.ASARB},
-	{"SARL", LTYPE3, x86.ASARL},
-	{"SARQ", LTYPE3, x86.ASARQ},
-	{"SARW", LTYPE3, x86.ASARW},
-	{"SBBB", LTYPE3, x86.ASBBB},
-	{"SBBL", LTYPE3, x86.ASBBL},
-	{"SBBQ", LTYPE3, x86.ASBBQ},
-	{"SBBW", LTYPE3, x86.ASBBW},
-	{"SCASB", LTYPE0, x86.ASCASB},
-	{"SCASL", LTYPE0, x86.ASCASL},
-	{"SCASQ", LTYPE0, x86.ASCASQ},
-	{"SCASW", LTYPE0, x86.ASCASW},
-	{"SETCC", LTYPE1, x86.ASETCC}, /* see JCC etc above for condition codes */
-	{"SETCS", LTYPE1, x86.ASETCS},
-	{"SETEQ", LTYPE1, x86.ASETEQ},
-	{"SETGE", LTYPE1, x86.ASETGE},
-	{"SETGT", LTYPE1, x86.ASETGT},
-	{"SETHI", LTYPE1, x86.ASETHI},
-	{"SETLE", LTYPE1, x86.ASETLE},
-	{"SETLS", LTYPE1, x86.ASETLS},
-	{"SETLT", LTYPE1, x86.ASETLT},
-	{"SETMI", LTYPE1, x86.ASETMI},
-	{"SETNE", LTYPE1, x86.ASETNE},
-	{"SETOC", LTYPE1, x86.ASETOC},
-	{"SETOS", LTYPE1, x86.ASETOS},
-	{"SETPC", LTYPE1, x86.ASETPC},
-	{"SETPL", LTYPE1, x86.ASETPL},
-	{"SETPS", LTYPE1, x86.ASETPS},
-	{"SFENCE", LTYPE0, x86.ASFENCE},
-	{"CDQ", LTYPE0, x86.ACDQ},
-	{"CWD", LTYPE0, x86.ACWD},
-	{"CQO", LTYPE0, x86.ACQO},
-	{"SHLB", LTYPE3, x86.ASHLB},
-	{"SHLL", LTYPES, x86.ASHLL},
-	{"SHLQ", LTYPES, x86.ASHLQ},
-	{"SHLW", LTYPES, x86.ASHLW},
-	{"SHRB", LTYPE3, x86.ASHRB},
-	{"SHRL", LTYPES, x86.ASHRL},
-	{"SHRQ", LTYPES, x86.ASHRQ},
-	{"SHRW", LTYPES, x86.ASHRW},
-	{"STC", LTYPE0, x86.ASTC},
-	{"STD", LTYPE0, x86.ASTD},
-	{"STI", LTYPE0, x86.ASTI},
-	{"STOSB", LTYPE0, x86.ASTOSB},
-	{"STOSL", LTYPE0, x86.ASTOSL},
-	{"STOSQ", LTYPE0, x86.ASTOSQ},
-	{"STOSW", LTYPE0, x86.ASTOSW},
-	{"SUBB", LTYPE3, x86.ASUBB},
-	{"SUBL", LTYPE3, x86.ASUBL},
-	{"SUBQ", LTYPE3, x86.ASUBQ},
-	{"SUBW", LTYPE3, x86.ASUBW},
-	{"SYSCALL", LTYPE0, x86.ASYSCALL},
-	{"SYSRET", LTYPE0, x86.ASYSRET},
-	{"SWAPGS", LTYPE0, x86.ASWAPGS},
-	{"TESTB", LTYPE3, x86.ATESTB},
-	{"TESTL", LTYPE3, x86.ATESTL},
-	{"TESTQ", LTYPE3, x86.ATESTQ},
-	{"TESTW", LTYPE3, x86.ATESTW},
-	{"TEXT", LTYPET, x86.ATEXT},
-	{"VERR", LTYPE2, x86.AVERR},
-	{"VERW", LTYPE2, x86.AVERW},
-	{"QUAD", LTYPE2, x86.AQUAD},
-	{"WAIT", LTYPE0, x86.AWAIT},
-	{"WBINVD", LTYPE0, x86.AWBINVD},
-	{"WRMSR", LTYPE0, x86.AWRMSR},
-	{"WORD", LTYPE2, x86.AWORD},
-	{"XADDB", LTYPE3, x86.AXADDB},
-	{"XADDL", LTYPE3, x86.AXADDL},
-	{"XADDQ", LTYPE3, x86.AXADDQ},
-	{"XADDW", LTYPE3, x86.AXADDW},
-	{"XCHGB", LTYPE3, x86.AXCHGB},
-	{"XCHGL", LTYPE3, x86.AXCHGL},
-	{"XCHGQ", LTYPE3, x86.AXCHGQ},
-	{"XCHGW", LTYPE3, x86.AXCHGW},
-	{"XLAT", LTYPE2, x86.AXLAT},
-	{"XORB", LTYPE3, x86.AXORB},
-	{"XORL", LTYPE3, x86.AXORL},
-	{"XORQ", LTYPE3, x86.AXORQ},
-	{"XORW", LTYPE3, x86.AXORW},
-	{"CMOVLCC", LTYPE3, x86.ACMOVLCC},
-	{"CMOVLCS", LTYPE3, x86.ACMOVLCS},
-	{"CMOVLEQ", LTYPE3, x86.ACMOVLEQ},
-	{"CMOVLGE", LTYPE3, x86.ACMOVLGE},
-	{"CMOVLGT", LTYPE3, x86.ACMOVLGT},
-	{"CMOVLHI", LTYPE3, x86.ACMOVLHI},
-	{"CMOVLLE", LTYPE3, x86.ACMOVLLE},
-	{"CMOVLLS", LTYPE3, x86.ACMOVLLS},
-	{"CMOVLLT", LTYPE3, x86.ACMOVLLT},
-	{"CMOVLMI", LTYPE3, x86.ACMOVLMI},
-	{"CMOVLNE", LTYPE3, x86.ACMOVLNE},
-	{"CMOVLOC", LTYPE3, x86.ACMOVLOC},
-	{"CMOVLOS", LTYPE3, x86.ACMOVLOS},
-	{"CMOVLPC", LTYPE3, x86.ACMOVLPC},
-	{"CMOVLPL", LTYPE3, x86.ACMOVLPL},
-	{"CMOVLPS", LTYPE3, x86.ACMOVLPS},
-	{"CMOVQCC", LTYPE3, x86.ACMOVQCC},
-	{"CMOVQCS", LTYPE3, x86.ACMOVQCS},
-	{"CMOVQEQ", LTYPE3, x86.ACMOVQEQ},
-	{"CMOVQGE", LTYPE3, x86.ACMOVQGE},
-	{"CMOVQGT", LTYPE3, x86.ACMOVQGT},
-	{"CMOVQHI", LTYPE3, x86.ACMOVQHI},
-	{"CMOVQLE", LTYPE3, x86.ACMOVQLE},
-	{"CMOVQLS", LTYPE3, x86.ACMOVQLS},
-	{"CMOVQLT", LTYPE3, x86.ACMOVQLT},
-	{"CMOVQMI", LTYPE3, x86.ACMOVQMI},
-	{"CMOVQNE", LTYPE3, x86.ACMOVQNE},
-	{"CMOVQOC", LTYPE3, x86.ACMOVQOC},
-	{"CMOVQOS", LTYPE3, x86.ACMOVQOS},
-	{"CMOVQPC", LTYPE3, x86.ACMOVQPC},
-	{"CMOVQPL", LTYPE3, x86.ACMOVQPL},
-	{"CMOVQPS", LTYPE3, x86.ACMOVQPS},
-	{"CMOVWCC", LTYPE3, x86.ACMOVWCC},
-	{"CMOVWCS", LTYPE3, x86.ACMOVWCS},
-	{"CMOVWEQ", LTYPE3, x86.ACMOVWEQ},
-	{"CMOVWGE", LTYPE3, x86.ACMOVWGE},
-	{"CMOVWGT", LTYPE3, x86.ACMOVWGT},
-	{"CMOVWHI", LTYPE3, x86.ACMOVWHI},
-	{"CMOVWLE", LTYPE3, x86.ACMOVWLE},
-	{"CMOVWLS", LTYPE3, x86.ACMOVWLS},
-	{"CMOVWLT", LTYPE3, x86.ACMOVWLT},
-	{"CMOVWMI", LTYPE3, x86.ACMOVWMI},
-	{"CMOVWNE", LTYPE3, x86.ACMOVWNE},
-	{"CMOVWOC", LTYPE3, x86.ACMOVWOC},
-	{"CMOVWOS", LTYPE3, x86.ACMOVWOS},
-	{"CMOVWPC", LTYPE3, x86.ACMOVWPC},
-	{"CMOVWPL", LTYPE3, x86.ACMOVWPL},
-	{"CMOVWPS", LTYPE3, x86.ACMOVWPS},
-	{"FMOVB", LTYPE3, x86.AFMOVB},
-	{"FMOVBP", LTYPE3, x86.AFMOVBP},
-	{"FMOVD", LTYPE3, x86.AFMOVD},
-	{"FMOVDP", LTYPE3, x86.AFMOVDP},
-	{"FMOVF", LTYPE3, x86.AFMOVF},
-	{"FMOVFP", LTYPE3, x86.AFMOVFP},
-	{"FMOVL", LTYPE3, x86.AFMOVL},
-	{"FMOVLP", LTYPE3, x86.AFMOVLP},
-	{"FMOVV", LTYPE3, x86.AFMOVV},
-	{"FMOVVP", LTYPE3, x86.AFMOVVP},
-	{"FMOVW", LTYPE3, x86.AFMOVW},
-	{"FMOVWP", LTYPE3, x86.AFMOVWP},
-	{"FMOVX", LTYPE3, x86.AFMOVX},
-	{"FMOVXP", LTYPE3, x86.AFMOVXP},
-	{"FCOMB", LTYPE3, x86.AFCOMB},
-	{"FCOMBP", LTYPE3, x86.AFCOMBP},
-	{"FCOMD", LTYPE3, x86.AFCOMD},
-	{"FCOMDP", LTYPE3, x86.AFCOMDP},
-	{"FCOMDPP", LTYPE3, x86.AFCOMDPP},
-	{"FCOMF", LTYPE3, x86.AFCOMF},
-	{"FCOMFP", LTYPE3, x86.AFCOMFP},
-	{"FCOML", LTYPE3, x86.AFCOML},
-	{"FCOMLP", LTYPE3, x86.AFCOMLP},
-	{"FCOMW", LTYPE3, x86.AFCOMW},
-	{"FCOMWP", LTYPE3, x86.AFCOMWP},
-	{"FUCOM", LTYPE3, x86.AFUCOM},
-	{"FUCOMP", LTYPE3, x86.AFUCOMP},
-	{"FUCOMPP", LTYPE3, x86.AFUCOMPP},
-	{"FADDW", LTYPE3, x86.AFADDW},
-	{"FADDL", LTYPE3, x86.AFADDL},
-	{"FADDF", LTYPE3, x86.AFADDF},
-	{"FADDD", LTYPE3, x86.AFADDD},
-	{"FADDDP", LTYPE3, x86.AFADDDP},
-	{"FSUBDP", LTYPE3, x86.AFSUBDP},
-	{"FSUBW", LTYPE3, x86.AFSUBW},
-	{"FSUBL", LTYPE3, x86.AFSUBL},
-	{"FSUBF", LTYPE3, x86.AFSUBF},
-	{"FSUBD", LTYPE3, x86.AFSUBD},
-	{"FSUBRDP", LTYPE3, x86.AFSUBRDP},
-	{"FSUBRW", LTYPE3, x86.AFSUBRW},
-	{"FSUBRL", LTYPE3, x86.AFSUBRL},
-	{"FSUBRF", LTYPE3, x86.AFSUBRF},
-	{"FSUBRD", LTYPE3, x86.AFSUBRD},
-	{"FMULDP", LTYPE3, x86.AFMULDP},
-	{"FMULW", LTYPE3, x86.AFMULW},
-	{"FMULL", LTYPE3, x86.AFMULL},
-	{"FMULF", LTYPE3, x86.AFMULF},
-	{"FMULD", LTYPE3, x86.AFMULD},
-	{"FDIVDP", LTYPE3, x86.AFDIVDP},
-	{"FDIVW", LTYPE3, x86.AFDIVW},
-	{"FDIVL", LTYPE3, x86.AFDIVL},
-	{"FDIVF", LTYPE3, x86.AFDIVF},
-	{"FDIVD", LTYPE3, x86.AFDIVD},
-	{"FDIVRDP", LTYPE3, x86.AFDIVRDP},
-	{"FDIVRW", LTYPE3, x86.AFDIVRW},
-	{"FDIVRL", LTYPE3, x86.AFDIVRL},
-	{"FDIVRF", LTYPE3, x86.AFDIVRF},
-	{"FDIVRD", LTYPE3, x86.AFDIVRD},
-	{"FXCHD", LTYPE3, x86.AFXCHD},
-	{"FFREE", LTYPE1, x86.AFFREE},
-	{"FLDCW", LTYPE2, x86.AFLDCW},
-	{"FLDENV", LTYPE1, x86.AFLDENV},
-	{"FRSTOR", LTYPE2, x86.AFRSTOR},
-	{"FSAVE", LTYPE1, x86.AFSAVE},
-	{"FSTCW", LTYPE1, x86.AFSTCW},
-	{"FSTENV", LTYPE1, x86.AFSTENV},
-	{"FSTSW", LTYPE1, x86.AFSTSW},
-	{"F2XM1", LTYPE0, x86.AF2XM1},
-	{"FABS", LTYPE0, x86.AFABS},
-	{"FCHS", LTYPE0, x86.AFCHS},
-	{"FCLEX", LTYPE0, x86.AFCLEX},
-	{"FCOS", LTYPE0, x86.AFCOS},
-	{"FDECSTP", LTYPE0, x86.AFDECSTP},
-	{"FINCSTP", LTYPE0, x86.AFINCSTP},
-	{"FINIT", LTYPE0, x86.AFINIT},
-	{"FLD1", LTYPE0, x86.AFLD1},
-	{"FLDL2E", LTYPE0, x86.AFLDL2E},
-	{"FLDL2T", LTYPE0, x86.AFLDL2T},
-	{"FLDLG2", LTYPE0, x86.AFLDLG2},
-	{"FLDLN2", LTYPE0, x86.AFLDLN2},
-	{"FLDPI", LTYPE0, x86.AFLDPI},
-	{"FLDZ", LTYPE0, x86.AFLDZ},
-	{"FNOP", LTYPE0, x86.AFNOP},
-	{"FPATAN", LTYPE0, x86.AFPATAN},
-	{"FPREM", LTYPE0, x86.AFPREM},
-	{"FPREM1", LTYPE0, x86.AFPREM1},
-	{"FPTAN", LTYPE0, x86.AFPTAN},
-	{"FRNDINT", LTYPE0, x86.AFRNDINT},
-	{"FSCALE", LTYPE0, x86.AFSCALE},
-	{"FSIN", LTYPE0, x86.AFSIN},
-	{"FSINCOS", LTYPE0, x86.AFSINCOS},
-	{"FSQRT", LTYPE0, x86.AFSQRT},
-	{"FTST", LTYPE0, x86.AFTST},
-	{"FXAM", LTYPE0, x86.AFXAM},
-	{"FXTRACT", LTYPE0, x86.AFXTRACT},
-	{"FYL2X", LTYPE0, x86.AFYL2X},
-	{"FYL2XP1", LTYPE0, x86.AFYL2XP1},
-	{"ADDPD", LTYPE3, x86.AADDPD},
-	{"ADDPS", LTYPE3, x86.AADDPS},
-	{"ADDSD", LTYPE3, x86.AADDSD},
-	{"ADDSS", LTYPE3, x86.AADDSS},
-	{"ANDNPD", LTYPE3, x86.AANDNPD},
-	{"ANDNPS", LTYPE3, x86.AANDNPS},
-	{"ANDPD", LTYPE3, x86.AANDPD},
-	{"ANDPS", LTYPE3, x86.AANDPS},
-	{"CMPPD", LTYPEXC, x86.ACMPPD},
-	{"CMPPS", LTYPEXC, x86.ACMPPS},
-	{"CMPSD", LTYPEXC, x86.ACMPSD},
-	{"CMPSS", LTYPEXC, x86.ACMPSS},
-	{"COMISD", LTYPE3, x86.ACOMISD},
-	{"COMISS", LTYPE3, x86.ACOMISS},
-	{"CVTPL2PD", LTYPE3, x86.ACVTPL2PD},
-	{"CVTPL2PS", LTYPE3, x86.ACVTPL2PS},
-	{"CVTPD2PL", LTYPE3, x86.ACVTPD2PL},
-	{"CVTPD2PS", LTYPE3, x86.ACVTPD2PS},
-	{"CVTPS2PL", LTYPE3, x86.ACVTPS2PL},
-	{"PF2IW", LTYPE3, x86.APF2IW},
-	{"PF2IL", LTYPE3, x86.APF2IL},
-	{"PF2ID", LTYPE3, x86.APF2IL}, /* syn */
-	{"PI2FL", LTYPE3, x86.API2FL},
-	{"PI2FD", LTYPE3, x86.API2FL}, /* syn */
-	{"PI2FW", LTYPE3, x86.API2FW},
-	{"CVTPS2PD", LTYPE3, x86.ACVTPS2PD},
-	{"CVTSD2SL", LTYPE3, x86.ACVTSD2SL},
-	{"CVTSD2SQ", LTYPE3, x86.ACVTSD2SQ},
-	{"CVTSD2SS", LTYPE3, x86.ACVTSD2SS},
-	{"CVTSL2SD", LTYPE3, x86.ACVTSL2SD},
-	{"CVTSQ2SD", LTYPE3, x86.ACVTSQ2SD},
-	{"CVTSL2SS", LTYPE3, x86.ACVTSL2SS},
-	{"CVTSQ2SS", LTYPE3, x86.ACVTSQ2SS},
-	{"CVTSS2SD", LTYPE3, x86.ACVTSS2SD},
-	{"CVTSS2SL", LTYPE3, x86.ACVTSS2SL},
-	{"CVTSS2SQ", LTYPE3, x86.ACVTSS2SQ},
-	{"CVTTPD2PL", LTYPE3, x86.ACVTTPD2PL},
-	{"CVTTPS2PL", LTYPE3, x86.ACVTTPS2PL},
-	{"CVTTSD2SL", LTYPE3, x86.ACVTTSD2SL},
-	{"CVTTSD2SQ", LTYPE3, x86.ACVTTSD2SQ},
-	{"CVTTSS2SL", LTYPE3, x86.ACVTTSS2SL},
-	{"CVTTSS2SQ", LTYPE3, x86.ACVTTSS2SQ},
-	{"DIVPD", LTYPE3, x86.ADIVPD},
-	{"DIVPS", LTYPE3, x86.ADIVPS},
-	{"DIVSD", LTYPE3, x86.ADIVSD},
-	{"DIVSS", LTYPE3, x86.ADIVSS},
-	{"FXRSTOR", LTYPE2, x86.AFXRSTOR},
-	{"FXRSTOR64", LTYPE2, x86.AFXRSTOR64},
-	{"FXSAVE", LTYPE1, x86.AFXSAVE},
-	{"FXSAVE64", LTYPE1, x86.AFXSAVE64},
-	{"LDMXCSR", LTYPE2, x86.ALDMXCSR},
-	{"MASKMOVOU", LTYPE3, x86.AMASKMOVOU},
-	{"MASKMOVDQU", LTYPE3, x86.AMASKMOVOU}, /* syn */
-	{"MASKMOVQ", LTYPE3, x86.AMASKMOVQ},
-	{"MAXPD", LTYPE3, x86.AMAXPD},
-	{"MAXPS", LTYPE3, x86.AMAXPS},
-	{"MAXSD", LTYPE3, x86.AMAXSD},
-	{"MAXSS", LTYPE3, x86.AMAXSS},
-	{"MINPD", LTYPE3, x86.AMINPD},
-	{"MINPS", LTYPE3, x86.AMINPS},
-	{"MINSD", LTYPE3, x86.AMINSD},
-	{"MINSS", LTYPE3, x86.AMINSS},
-	{"MOVAPD", LTYPE3, x86.AMOVAPD},
-	{"MOVAPS", LTYPE3, x86.AMOVAPS},
-	{"MOVD", LTYPE3, x86.AMOVQ},    /* syn */
-	{"MOVDQ2Q", LTYPE3, x86.AMOVQ}, /* syn */
-	{"MOVO", LTYPE3, x86.AMOVO},
-	{"MOVOA", LTYPE3, x86.AMOVO}, /* syn */
-	{"MOVOU", LTYPE3, x86.AMOVOU},
-	{"MOVHLPS", LTYPE3, x86.AMOVHLPS},
-	{"MOVHPD", LTYPE3, x86.AMOVHPD},
-	{"MOVHPS", LTYPE3, x86.AMOVHPS},
-	{"MOVLHPS", LTYPE3, x86.AMOVLHPS},
-	{"MOVLPD", LTYPE3, x86.AMOVLPD},
-	{"MOVLPS", LTYPE3, x86.AMOVLPS},
-	{"MOVMSKPD", LTYPE3, x86.AMOVMSKPD},
-	{"MOVMSKPS", LTYPE3, x86.AMOVMSKPS},
-	{"MOVNTO", LTYPE3, x86.AMOVNTO},
-	{"MOVNTDQ", LTYPE3, x86.AMOVNTO}, /* syn */
-	{"MOVNTPD", LTYPE3, x86.AMOVNTPD},
-	{"MOVNTPS", LTYPE3, x86.AMOVNTPS},
-	{"MOVNTQ", LTYPE3, x86.AMOVNTQ},
-	{"MOVQOZX", LTYPE3, x86.AMOVQOZX},
-	{"MOVSD", LTYPE3, x86.AMOVSD},
-	{"MOVSS", LTYPE3, x86.AMOVSS},
-	{"MOVUPD", LTYPE3, x86.AMOVUPD},
-	{"MOVUPS", LTYPE3, x86.AMOVUPS},
-	{"MULPD", LTYPE3, x86.AMULPD},
-	{"MULPS", LTYPE3, x86.AMULPS},
-	{"MULSD", LTYPE3, x86.AMULSD},
-	{"MULSS", LTYPE3, x86.AMULSS},
-	{"ORPD", LTYPE3, x86.AORPD},
-	{"ORPS", LTYPE3, x86.AORPS},
-	{"PACKSSLW", LTYPE3, x86.APACKSSLW},
-	{"PACKSSWB", LTYPE3, x86.APACKSSWB},
-	{"PACKUSWB", LTYPE3, x86.APACKUSWB},
-	{"PADDB", LTYPE3, x86.APADDB},
-	{"PADDL", LTYPE3, x86.APADDL},
-	{"PADDQ", LTYPE3, x86.APADDQ},
-	{"PADDSB", LTYPE3, x86.APADDSB},
-	{"PADDSW", LTYPE3, x86.APADDSW},
-	{"PADDUSB", LTYPE3, x86.APADDUSB},
-	{"PADDUSW", LTYPE3, x86.APADDUSW},
-	{"PADDW", LTYPE3, x86.APADDW},
-	{"PAND", LTYPE3, x86.APAND},
-	{"PANDB", LTYPE3, x86.APANDB},
-	{"PANDL", LTYPE3, x86.APANDL},
-	{"PANDSB", LTYPE3, x86.APANDSB},
-	{"PANDSW", LTYPE3, x86.APANDSW},
-	{"PANDUSB", LTYPE3, x86.APANDUSB},
-	{"PANDUSW", LTYPE3, x86.APANDUSW},
-	{"PANDW", LTYPE3, x86.APANDW},
-	{"PANDN", LTYPE3, x86.APANDN},
-	{"PAVGB", LTYPE3, x86.APAVGB},
-	{"PAVGW", LTYPE3, x86.APAVGW},
-	{"PCMPEQB", LTYPE3, x86.APCMPEQB},
-	{"PCMPEQL", LTYPE3, x86.APCMPEQL},
-	{"PCMPEQW", LTYPE3, x86.APCMPEQW},
-	{"PCMPGTB", LTYPE3, x86.APCMPGTB},
-	{"PCMPGTL", LTYPE3, x86.APCMPGTL},
-	{"PCMPGTW", LTYPE3, x86.APCMPGTW},
-	{"PEXTRW", LTYPEX, x86.APEXTRW},
-	{"PINSRW", LTYPEX, x86.APINSRW},
-	{"PINSRD", LTYPEX, x86.APINSRD},
-	{"PINSRQ", LTYPEX, x86.APINSRQ},
-	{"PMADDWL", LTYPE3, x86.APMADDWL},
-	{"PMAXSW", LTYPE3, x86.APMAXSW},
-	{"PMAXUB", LTYPE3, x86.APMAXUB},
-	{"PMINSW", LTYPE3, x86.APMINSW},
-	{"PMINUB", LTYPE3, x86.APMINUB},
-	{"PMOVMSKB", LTYPE3, x86.APMOVMSKB},
-	{"PMULHRW", LTYPE3, x86.APMULHRW},
-	{"PMULHUW", LTYPE3, x86.APMULHUW},
-	{"PMULHW", LTYPE3, x86.APMULHW},
-	{"PMULLW", LTYPE3, x86.APMULLW},
-	{"PMULULQ", LTYPE3, x86.APMULULQ},
-	{"POR", LTYPE3, x86.APOR},
-	{"PSADBW", LTYPE3, x86.APSADBW},
-	{"PSHUFHW", LTYPEX, x86.APSHUFHW},
-	{"PSHUFL", LTYPEX, x86.APSHUFL},
-	{"PSHUFLW", LTYPEX, x86.APSHUFLW},
-	{"PSHUFW", LTYPEX, x86.APSHUFW},
-	{"PSHUFB", LTYPEM, x86.APSHUFB},
-	{"PSLLO", LTYPE3, x86.APSLLO},
-	{"PSLLDQ", LTYPE3, x86.APSLLO}, /* syn */
-	{"PSLLL", LTYPE3, x86.APSLLL},
-	{"PSLLQ", LTYPE3, x86.APSLLQ},
-	{"PSLLW", LTYPE3, x86.APSLLW},
-	{"PSRAL", LTYPE3, x86.APSRAL},
-	{"PSRAW", LTYPE3, x86.APSRAW},
-	{"PSRLO", LTYPE3, x86.APSRLO},
-	{"PSRLDQ", LTYPE3, x86.APSRLO}, /* syn */
-	{"PSRLL", LTYPE3, x86.APSRLL},
-	{"PSRLQ", LTYPE3, x86.APSRLQ},
-	{"PSRLW", LTYPE3, x86.APSRLW},
-	{"PSUBB", LTYPE3, x86.APSUBB},
-	{"PSUBL", LTYPE3, x86.APSUBL},
-	{"PSUBQ", LTYPE3, x86.APSUBQ},
-	{"PSUBSB", LTYPE3, x86.APSUBSB},
-	{"PSUBSW", LTYPE3, x86.APSUBSW},
-	{"PSUBUSB", LTYPE3, x86.APSUBUSB},
-	{"PSUBUSW", LTYPE3, x86.APSUBUSW},
-	{"PSUBW", LTYPE3, x86.APSUBW},
-	{"PUNPCKHBW", LTYPE3, x86.APUNPCKHBW},
-	{"PUNPCKHLQ", LTYPE3, x86.APUNPCKHLQ},
-	{"PUNPCKHQDQ", LTYPE3, x86.APUNPCKHQDQ},
-	{"PUNPCKHWL", LTYPE3, x86.APUNPCKHWL},
-	{"PUNPCKLBW", LTYPE3, x86.APUNPCKLBW},
-	{"PUNPCKLLQ", LTYPE3, x86.APUNPCKLLQ},
-	{"PUNPCKLQDQ", LTYPE3, x86.APUNPCKLQDQ},
-	{"PUNPCKLWL", LTYPE3, x86.APUNPCKLWL},
-	{"PXOR", LTYPE3, x86.APXOR},
-	{"RCPPS", LTYPE3, x86.ARCPPS},
-	{"RCPSS", LTYPE3, x86.ARCPSS},
-	{"RSQRTPS", LTYPE3, x86.ARSQRTPS},
-	{"RSQRTSS", LTYPE3, x86.ARSQRTSS},
-	{"SHUFPD", LTYPEX, x86.ASHUFPD},
-	{"SHUFPS", LTYPEX, x86.ASHUFPS},
-	{"SQRTPD", LTYPE3, x86.ASQRTPD},
-	{"SQRTPS", LTYPE3, x86.ASQRTPS},
-	{"SQRTSD", LTYPE3, x86.ASQRTSD},
-	{"SQRTSS", LTYPE3, x86.ASQRTSS},
-	{"STMXCSR", LTYPE1, x86.ASTMXCSR},
-	{"SUBPD", LTYPE3, x86.ASUBPD},
-	{"SUBPS", LTYPE3, x86.ASUBPS},
-	{"SUBSD", LTYPE3, x86.ASUBSD},
-	{"SUBSS", LTYPE3, x86.ASUBSS},
-	{"UCOMISD", LTYPE3, x86.AUCOMISD},
-	{"UCOMISS", LTYPE3, x86.AUCOMISS},
-	{"UNPCKHPD", LTYPE3, x86.AUNPCKHPD},
-	{"UNPCKHPS", LTYPE3, x86.AUNPCKHPS},
-	{"UNPCKLPD", LTYPE3, x86.AUNPCKLPD},
-	{"UNPCKLPS", LTYPE3, x86.AUNPCKLPS},
-	{"XORPD", LTYPE3, x86.AXORPD},
-	{"XORPS", LTYPE3, x86.AXORPS},
-	{"CRC32B", LTYPE4, x86.ACRC32B},
-	{"CRC32Q", LTYPE4, x86.ACRC32Q},
-	{"PREFETCHT0", LTYPE2, x86.APREFETCHT0},
-	{"PREFETCHT1", LTYPE2, x86.APREFETCHT1},
-	{"PREFETCHT2", LTYPE2, x86.APREFETCHT2},
-	{"PREFETCHNTA", LTYPE2, x86.APREFETCHNTA},
-	{"UNDEF", LTYPE0, x86.AUNDEF},
-	{"AESENC", LTYPE3, x86.AAESENC},
-	{"AESENCLAST", LTYPE3, x86.AAESENCLAST},
-	{"AESDEC", LTYPE3, x86.AAESDEC},
-	{"AESDECLAST", LTYPE3, x86.AAESDECLAST},
-	{"AESIMC", LTYPE3, x86.AAESIMC},
-	{"AESKEYGENASSIST", LTYPEX, x86.AAESKEYGENASSIST},
-	{"PSHUFD", LTYPEX, x86.APSHUFD},
-	{"USEFIELD", LTYPEN, x86.AUSEFIELD},
-	{"PCLMULQDQ", LTYPEX, x86.APCLMULQDQ},
-	{"PCDATA", LTYPEPC, x86.APCDATA},
-	{"FUNCDATA", LTYPEF, x86.AFUNCDATA},
-}
-
 func cinit() {
-	var s *Sym
-	var i int
-
-	nullgen.Type_ = x86.D_NONE
-	nullgen.Index = x86.D_NONE
-
-	nerrors = 0
-	iostack = nil
-	iofree = nil
-	peekc = IGN
-	nhunk = 0
-	for i = 0; i < NHASH; i++ {
-		hash[i] = nil
-	}
-	for i = 0; itab[i].name != ""; i++ {
-		s = slookup(itab[i].name)
-		if s.type_ != LNAME {
-			yyerror("double initialization %s", itab[i].name)
+	for i := 0; i < len(Lexinit); i++ {
+		s := Lookup(Lexinit[i].Name)
+		if s.Type != LNAME {
+			Yyerror("double initialization %s", Lexinit[i].Name)
 		}
-		s.type_ = itab[i].type_
-		s.value = int64(itab[i].value)
+		s.Type = Lexinit[i].Type
+		s.Value = Lexinit[i].Value
 	}
 }
 
-func checkscale(scale int) {
-	switch scale {
-	case 1,
-		2,
-		4,
-		8:
-		return
-	}
-
-	yyerror("scale must be 1248: %d", scale)
-}
-
 func syminit(s *Sym) {
-	s.type_ = LNAME
-	s.value = 0
+	s.Type = LNAME
+	s.Value = 0
 }
 
-func cclean() {
-	var g2 Addr2
+type flagFn func(string)
 
-	g2.from = nullgen
-	g2.to = nullgen
-	outcode(x86.AEND, &g2)
+func (flagFn) String() string {
+	return "<arg>"
 }
 
-var lastpc *obj.Prog
+func (f flagFn) Set(s string) error {
+	f(s)
+	return nil
+}
 
-func outcode(a int, g2 *Addr2) {
-	var p *obj.Prog
-	var pl *obj.Plist
+type yyImpl struct{}
 
-	if pass == 1 {
-		goto out
-	}
+// count is a flag.Value that is like a flag.Bool and a flag.Int.
+// If used as -name, it increments the count, but -name=x sets the count.
+// Used for verbose flag -v.
+type count int
 
-	p = new(obj.Prog)
-	*p = obj.Prog{}
-	p.As = int16(a)
-	p.Lineno = stmtline
-	p.From = g2.from
-	p.To = g2.to
-	p.Pc = int64(pc)
-
-	if lastpc == nil {
-		pl = obj.Linknewplist(ctxt)
-		pl.Firstpc = p
-	} else {
+func (c *count) String() string {
+	return fmt.Sprint(int(*c))
+}
 
-		lastpc.Link = p
+func (c *count) Set(s string) error {
+	switch s {
+	case "true":
+		*c++
+	case "false":
+		*c = 0
+	default:
+		n, err := strconv.Atoi(s)
+		if err != nil {
+			return fmt.Errorf("invalid count %q", s)
+		}
+		*c = count(n)
 	}
-	lastpc = p
+	return nil
+}
 
-out:
-	if a != x86.AGLOBL && a != x86.ADATA {
-		pc++
-	}
+func (c *count) IsBoolFlag() bool {
+	return true
 }
diff --git a/src/cmd/internal/asm/lexbody.go b/src/cmd/internal/asm/lexbody.go
index d835e7b117..df0407c7a9 100644
--- a/src/cmd/internal/asm/lexbody.go
+++ b/src/cmd/internal/asm/lexbody.go
@@ -1,12 +1,12 @@
 // Inferno utils/cc/lexbody
-// http://code.google.com/p/inferno-os/source/browse/utils/cc/lexbody
+// http://code.Google.Com/p/inferno-os/source/browse/utils/cc/lexbody
 //
 //	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
-//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.Net)
 //	Portions Copyright © 1997-1999 Vita Nuova Limited
-//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.Vitanuova.Com)
 //	Portions Copyright © 2004,2006 Bruce Ellis
-//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.Net)
 //	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
 //	Portions Copyright © 2009 The Go Authors.  All rights reserved.
 //
@@ -30,6 +30,17 @@
 
 package asm
 
+import (
+	"bytes"
+	"fmt"
+	"os"
+	"strconv"
+	"strings"
+	"unicode/utf8"
+
+	"cmd/internal/obj"
+)
+
 /*
  * common code for all the assemblers
  */
@@ -82,143 +93,90 @@ func pragincomplete() {
 	}
 }
 
-func Alloc(n int32) interface{} {
-	var p interface{}
-
-	p = make([]byte, n)
-	if p == nil {
-		fmt.Printf("alloc out of mem\n")
-		main.Exits("alloc: out of mem")
-	}
-
-	main.Memset(p, 0, n)
-	return p
-}
-
-func Allocn(p interface{}, n int32, d int32) interface{} {
-	if p == nil {
-		return Alloc(n + d)
-	}
-	p = main.Realloc(p, int(n+d))
-	if p == nil {
-		fmt.Printf("allocn out of mem\n")
-		main.Exits("allocn: out of mem")
-	}
-
-	if d > 0 {
-		main.Memset(p.(string)[n:], 0, d)
-	}
-	return p
-}
-
-func Ensuresymb(n int32) {
-	if new5a.Symb == nil {
-		new5a.Symb = Alloc(new5a.NSYMB + 1).(string)
-		new5a.Nsymb = new5a.NSYMB
-	}
-
-	if n > new5a.Nsymb {
-		new5a.Symb = Allocn(new5a.Symb, new5a.Nsymb, n+1-new5a.Nsymb).(string)
-		new5a.Nsymb = n
-	}
-}
-
-func Setinclude(p string) {
+func setinclude(p string) {
 	var i int
 
 	if p == "" {
 		return
 	}
-	for i = 1; i < new5a.Ninclude; i++ {
-		if p == new5a.Include[i] {
+	for i = 1; i < len(include); i++ {
+		if p == include[i] {
 			return
 		}
 	}
 
-	if new5a.Ninclude%8 == 0 {
-		new5a.Include = Allocn(new5a.Include, new5a.Ninclude*sizeof(string), 8*sizeof(string)).(*string)
-	}
-	new5a.Include[new5a.Ninclude] = p
-	new5a.Ninclude++
+	include = append(include, p)
 }
 
-func Errorexit() {
-	obj.Bflush(&new5a.Bstdout)
-	if new5a.Outfile != "" {
-		main.Remove(new5a.Outfile)
+func errorexit() {
+	obj.Bflush(&bstdout)
+	if outfile != "" {
+		os.Remove(outfile)
 	}
-	main.Exits("error")
+	os.Exit(2)
 }
 
 func pushio() {
-	var i *new5a.Io
+	var i *Io
 
-	i = new5a.Iostack
+	i = iostack
 	if i == nil {
 		Yyerror("botch in pushio")
-		Errorexit()
+		errorexit()
 	}
 
-	i.P = new5a.Fi.p
-	i.C = int16(new5a.Fi.c)
+	i.P = fi.P
 }
 
 func newio() {
-	var i *new5a.Io
+	var i *Io
 	var pushdepth int = 0
 
-	i = new5a.Iofree
+	i = iofree
 	if i == nil {
 		pushdepth++
 		if pushdepth > 1000 {
 			Yyerror("macro/io expansion too deep")
-			Errorexit()
+			errorexit()
 		}
-
-		i = Alloc(sizeof(*i)).(*new5a.Io)
+		i = new(Io)
 	} else {
-
-		new5a.Iofree = i.Link
+		iofree = i.Link
 	}
-	i.C = 0
-	i.F = -1
-	new5a.Ionext = i
+	i.F = nil
+	i.P = nil
+	ionext = i
 }
 
-func newfile(s string, f int) {
-	var i *new5a.Io
+func newfile(s string, f *os.File) {
+	var i *Io
 
-	i = new5a.Ionext
-	i.Link = new5a.Iostack
-	new5a.Iostack = i
-	i.F = int16(f)
-	if f < 0 {
-		i.F = int16(main.Open(s, 0))
-	}
-	if i.F < 0 {
-		Yyerror("%ca: %r: %s", new5a.Thechar, s)
-		Errorexit()
+	i = ionext
+	i.Link = iostack
+	iostack = i
+	i.F = f
+	if f == nil {
+		var err error
+		i.F, err = os.Open(s)
+		if err != nil {
+			Yyerror("%ca: %v", Thechar, err)
+			errorexit()
+		}
 	}
 
-	new5a.Fi.c = 0
-	obj.Linklinehist(new5a.Ctxt, int(new5a.Lineno), s, 0)
-}
-
-func Slookup(s string) *new5a.Sym {
-	Ensuresymb(int32(len(s)))
-	new5a.Symb = s
-	return lookup()
+	fi.P = nil
+	obj.Linklinehist(Ctxt, int(Lineno), s, 0)
 }
 
 var thetext *obj.LSym
 
-func settext(s *obj.LSym) {
+func Settext(s *obj.LSym) {
 	thetext = s
 }
 
-func labellookup(s *new5a.Sym) *new5a.Sym {
+func LabelLookup(s *Sym) *Sym {
 	var p string
-	var lab *new5a.Sym
+	var lab *Sym
 
 	if thetext == nil {
 		s.Labelname = s.Name
@@ -226,134 +184,109 @@ func labellookup(s *new5a.Sym) *new5a.Sym {
 	}
 
 	p = string(fmt.Sprintf("%s.%s", thetext.Name, s.Name))
-	lab = Slookup(p)
+	lab = Lookup(p)
 
 	lab.Labelname = s.Name
 	return lab
 }
 
-func lookup() *new5a.Sym {
-	var s *new5a.Sym
-	var h uint32
-	var p string
-	var c int
-	var l int
-	var r string
-	var w string
-
-	if uint8(new5a.Symb[0]) == 0xc2 && uint8(new5a.Symb[1]) == 0xb7 {
-		// turn leading · into ""·
-		h = uint32(len(new5a.Symb))
-
-		Ensuresymb(int32(h + 2))
-		main.Memmove(new5a.Symb[2:], new5a.Symb, h+1)
-		new5a.Symb[0] = '"'
-		new5a.Symb[1] = '"'
-	}
-
-	w = new5a.Symb
-	for r = w; r[0] != 0; r = r[1:] {
-		// turn · (U+00B7) into .
-		// turn ∕ (U+2215) into /
-		if uint8(r[0]) == 0xc2 && uint8((r[1:])[0]) == 0xb7 {
-
-			w[0] = '.'
-			w = w[1:]
-			r = r[1:]
-		} else if uint8(r[0]) == 0xe2 && uint8((r[1:])[0]) == 0x88 && uint8((r[2:])[0]) == 0x95 {
-			w[0] = '/'
-			w = w[1:]
-			r = r[1:]
-			r = r[1:]
-		} else {
-
-			w[0] = r[0]
-			w = w[1:]
-		}
+func Lookup(symb string) *Sym {
+	// turn leading · into ""·
+	if strings.HasPrefix(symb, "·") {
+		symb = `""` + symb
 	}
 
-	w[0] = '\x00'
+	// turn · (U+00B7) into .
+	// turn ∕ (U+2215) into /
+	symb = strings.Replace(symb, "·", ".", -1)
+	symb = strings.Replace(symb, "∕", "/", -1)
 
-	h = 0
-	for p = new5a.Symb; ; p = p[1:] {
-		c = int(p[0])
-		if !(c != 0) {
-			break
-		}
-		h = h + h + h + uint32(c)
-	}
-	l = (-cap(p) + cap(new5a.Symb)) + 1
-	h &= 0xffffff
-	h %= new5a.NHASH
-	c = int(new5a.Symb[0])
-	for s = new5a.Hash[h]; s != nil; s = s.Link {
-		if int(s.Name[0]) != c {
-			continue
-		}
-		if s.Name == new5a.Symb {
-			return s
-		}
+	s := hash[symb]
+	if s != nil {
+		return s
 	}
 
-	s = Alloc(sizeof(*s)).(*new5a.Sym)
-	s.Name = Alloc(int32(l)).(string)
-	main.Memmove(s.Name, new5a.Symb, l)
-
-	s.Link = new5a.Hash[h]
-	new5a.Hash[h] = s
-	new5a.Syminit(s)
+	s = new(Sym)
+	s.Name = symb
+	syminit(s)
+	hash[symb] = s
 	return s
 }
 
-func ISALPHA(c int) int {
-	if main.Isalpha(c) != 0 {
-		return 1
+func isalnum(c int) bool {
+	return isalpha(c) || isdigit(c)
+}
+
+func isalpha(c int) bool {
+	return 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z'
+}
+
+func isspace(c int) bool {
+	return c == ' ' || c == '\t' || c == '\r' || c == '\n'
+}
+
+func ISALPHA(c int) bool {
+	if isalpha(c) {
+		return true
 	}
-	if c >= main.Runeself {
-		return 1
+	if c >= utf8.RuneSelf {
+		return true
 	}
-	return 0
+	return false
+}
+
+var yybuf bytes.Buffer
+
+func (yyImpl) Error(s string) {
+	Yyerror("%s", s)
+}
+
+type Yylval struct {
+	Sym  *Sym
+	Lval int64
+	Sval string
+	Dval float64
 }
 
-func yylex() int32 {
+func Yylex(yylval *Yylval) int {
 	var c int
 	var c1 int
-	var cp string
-	var s *new5a.Sym
+	var s *Sym
 
-	c = new5a.Peekc
-	if c != new5a.IGN {
-		new5a.Peekc = new5a.IGN
+	c = peekc
+	if c != IGN {
+		peekc = IGN
 		goto l1
 	}
 
 l0:
-	c = new5a.GETC()
+	c = GETC()
 
 l1:
-	if c == new5a.EOF {
-		new5a.Peekc = new5a.EOF
+	if c == EOF {
+		peekc = EOF
 		return -1
 	}
 
-	if main.Isspace(c) != 0 {
+	if isspace(c) {
 		if c == '\n' {
-			new5a.Lineno++
+			Lineno++
 			return ';'
 		}
 
 		goto l0
 	}
 
-	if ISALPHA(c) != 0 {
-		goto talph
+	if ISALPHA(c) {
+		yybuf.Reset()
+		goto aloop
 	}
-	if main.Isdigit(c) != 0 {
+	if isdigit(c) {
 		goto tnum
 	}
 	switch c {
 	case '\n':
-		new5a.Lineno++
+		Lineno++
 		return ';'
 
 	case '#':
@@ -361,280 +294,256 @@ l1:
 		goto l0
 
 	case '.':
-		c = new5a.GETC()
-		if ISALPHA(c) != 0 {
-			cp = new5a.Symb
-			cp[0] = '.'
-			cp = cp[1:]
+		c = GETC()
+		if ISALPHA(c) {
+			yybuf.Reset()
+			yybuf.WriteByte('.')
 			goto aloop
 		}
 
-		if main.Isdigit(c) != 0 {
-			cp = new5a.Symb
-			cp[0] = '.'
-			cp = cp[1:]
+		if isdigit(c) {
+			yybuf.Reset()
+			yybuf.WriteByte('.')
 			goto casedot
 		}
 
-		new5a.Peekc = c
+		peekc = c
 		return '.'
 
 	case '_',
 		'@':
-	talph:
-		cp = new5a.Symb
-
-	aloop:
-		cp[0] = byte(c)
-		cp = cp[1:]
-		c = new5a.GETC()
-		if ISALPHA(c) != 0 || main.Isdigit(c) != 0 || c == '_' || c == '$' {
-			goto aloop
-		}
-		cp = ""
-		new5a.Peekc = c
-		s = lookup()
-		if s.Macro != "" {
-			newio()
-			cp = new5a.Ionext.B
-			macexpand(s, cp)
-			pushio()
-			new5a.Ionext.Link = new5a.Iostack
-			new5a.Iostack = new5a.Ionext
-			new5a.Fi.p = cp
-			new5a.Fi.c = len(cp)
-			if new5a.Peekc != new5a.IGN {
-				cp[new5a.Fi.c] = byte(new5a.Peekc)
-				new5a.Fi.c++
-				cp[new5a.Fi.c] = 0
-				new5a.Peekc = new5a.IGN
-			}
-
-			goto l0
-		}
-
-		if s.Type_ == 0 {
-			s.Type_ = new5a.LNAME
-		}
-		if s.Type_ == new5a.LNAME || s.Type_ == new5a.LVAR || s.Type_ == new5a.LLAB {
-			new5a.Yylval.sym = s
-			return int32(s.Type_)
-		}
-
-		new5a.Yylval.lval = s.Value
-		return int32(s.Type_)
-
-	tnum:
-		cp = new5a.Symb
-		if c != '0' {
-			goto dc
-		}
-		cp[0] = byte(c)
-		cp = cp[1:]
-		c = new5a.GETC()
-		c1 = 3
-		if c == 'x' || c == 'X' {
-			c1 = 4
-			c = new5a.GETC()
-		} else if c < '0' || c > '7' {
-			goto dc
-		}
-		new5a.Yylval.lval = 0
-		for {
-			if c >= '0' && c <= '9' {
-				if c > '7' && c1 == 3 {
-					break
-				}
-				new5a.Yylval.lval = int32(uint64(new5a.Yylval.lval) << uint(c1))
-				new5a.Yylval.lval += int32(c) - '0'
-				c = new5a.GETC()
-				continue
-			}
-
-			if c1 == 3 {
-				break
-			}
-			if c >= 'A' && c <= 'F' {
-				c += 'a' - 'A'
-			}
-			if c >= 'a' && c <= 'f' {
-				new5a.Yylval.lval = int32(uint64(new5a.Yylval.lval) << uint(c1))
-				new5a.Yylval.lval += int32(c) - 'a' + 10
-				c = new5a.GETC()
-				continue
-			}
-
-			break
-		}
-
-		goto ncu
-
-	dc:
-		for {
-			if !(main.Isdigit(c) != 0) {
-				break
-			}
-			cp[0] = byte(c)
-			cp = cp[1:]
-			c = new5a.GETC()
-		}
-
-		if c == '.' {
-			goto casedot
-		}
-		if c == 'e' || c == 'E' {
-			goto casee
-		}
-		cp = ""
-		if sizeof(new5a.Yylval.lval) == sizeof(int64) {
-			new5a.Yylval.lval = int32(main.Strtoll(new5a.Symb, nil, 10))
-		} else {
-
-			new5a.Yylval.lval = int32(main.Strtol(new5a.Symb, nil, 10))
-		}
-
-	ncu:
-		for c == 'U' || c == 'u' || c == 'l' || c == 'L' {
-			c = new5a.GETC()
-		}
-		new5a.Peekc = c
-		return new5a.LCONST
-
-	casedot:
-		for {
-			cp[0] = byte(c)
-			cp = cp[1:]
-			c = new5a.GETC()
-			if !(main.Isdigit(c) != 0) {
-				break
-			}
-		}
-
-		if c == 'e' || c == 'E' {
-			goto casee
-		}
-		goto caseout
-
-	casee:
-		cp[0] = 'e'
-		cp = cp[1:]
-		c = new5a.GETC()
-		if c == '+' || c == '-' {
-			cp[0] = byte(c)
-			cp = cp[1:]
-			c = new5a.GETC()
-		}
-
-		for main.Isdigit(c) != 0 {
-			cp[0] = byte(c)
-			cp = cp[1:]
-			c = new5a.GETC()
-		}
-
-	caseout:
-		cp = ""
-		new5a.Peekc = c
-		if new5a.FPCHIP != 0 /*TypeKind(100016)*/ {
-			new5a.Yylval.dval = main.Atof(new5a.Symb)
-			return new5a.LFCONST
-		}
-
-		Yyerror("assembler cannot interpret fp constants")
-		new5a.Yylval.lval = 1
-		return new5a.LCONST
+		yybuf.Reset()
+		goto aloop
 
 	case '"':
-		main.Memmove(new5a.Yylval.sval, new5a.Nullgen.U.Sval, sizeof(new5a.Yylval.sval))
-		cp = new5a.Yylval.sval
+		var buf bytes.Buffer
 		c1 = 0
 		for {
 			c = escchar('"')
-			if c == new5a.EOF {
+			if c == EOF {
 				break
 			}
-			if c1 < sizeof(new5a.Yylval.sval) {
-				cp[0] = byte(c)
-				cp = cp[1:]
-			}
-			c1++
-		}
-
-		if c1 > sizeof(new5a.Yylval.sval) {
-			Yyerror("string constant too long")
+			buf.WriteByte(byte(c))
 		}
-		return new5a.LSCONST
+		yylval.Sval = buf.String()
+		return LSCONST
 
 	case '\'':
 		c = escchar('\'')
-		if c == new5a.EOF {
+		if c == EOF {
 			c = '\''
 		}
-		if escchar('\'') != new5a.EOF {
+		if escchar('\'') != EOF {
 			Yyerror("missing '")
 		}
-		new5a.Yylval.lval = int32(c)
-		return new5a.LCONST
+		yylval.Lval = int64(c)
+		return LCONST
 
 	case '/':
-		c1 = new5a.GETC()
+		c1 = GETC()
 		if c1 == '/' {
 			for {
-				c = new5a.GETC()
+				c = GETC()
 				if c == '\n' {
 					goto l1
 				}
-				if c == new5a.EOF {
+				if c == EOF {
 					Yyerror("eof in comment")
-					Errorexit()
+					errorexit()
 				}
 			}
 		}
 
 		if c1 == '*' {
 			for {
-				c = new5a.GETC()
+				c = GETC()
 				for c == '*' {
-					c = new5a.GETC()
+					c = GETC()
 					if c == '/' {
 						goto l0
 					}
 				}
 
-				if c == new5a.EOF {
+				if c == EOF {
 					Yyerror("eof in comment")
-					Errorexit()
+					errorexit()
 				}
 
 				if c == '\n' {
-					new5a.Lineno++
+					Lineno++
 				}
 			}
 		}
 
 	default:
-		return int32(c)
+		return int(c)
+	}
+
+	peekc = c1
+	return int(c)
+
+casedot:
+	for {
+		yybuf.WriteByte(byte(c))
+		c = GETC()
+		if !(isdigit(c)) {
+			break
+		}
+	}
+
+	if c == 'e' || c == 'E' {
+		goto casee
+	}
+	goto caseout
+
+casee:
+	yybuf.WriteByte('e')
+	c = GETC()
+	if c == '+' || c == '-' {
+		yybuf.WriteByte(byte(c))
+		c = GETC()
+	}
+
+	for isdigit(c) {
+		yybuf.WriteByte(byte(c))
+		c = GETC()
+	}
+
+caseout:
+	peekc = c
+	if FPCHIP != 0 /*TypeKind(100016)*/ {
+		last = yybuf.String()
+		yylval.Dval = atof(last)
+		return LFCONST
+	}
+
+	Yyerror("assembler cannot interpret fp constants")
+	yylval.Lval = 1
+	return LCONST
+
+aloop:
+	yybuf.WriteByte(byte(c))
+	c = GETC()
+	if ISALPHA(c) || isdigit(c) || c == '_' || c == '$' {
+		goto aloop
+	}
+	peekc = c
+	last = yybuf.String()
+	s = Lookup(last)
+	if s.Macro != nil {
+		newio()
+		ionext.P = macexpand(s)
+		pushio()
+		ionext.Link = iostack
+		iostack = ionext
+		fi.P = ionext.P
+		if peekc != IGN {
+			fi.P = append(fi.P, byte(peekc))
+			peekc = IGN
+		}
+
+		goto l0
+	}
+
+	if s.Type == 0 {
+		s.Type = LNAME
+	}
+	if s.Type == LNAME || s.Type == LVAR || s.Type == LLAB {
+		yylval.Sym = s
+		yylval.Sval = last
+		return int(s.Type)
+	}
+
+	yylval.Lval = s.Value
+	yylval.Sval = last
+	return int(s.Type)
+
+tnum:
+	yybuf.Reset()
+	if c != '0' {
+		goto dc
+	}
+	yybuf.WriteByte(byte(c))
+	c = GETC()
+	c1 = 3
+	if c == 'x' || c == 'X' {
+		c1 = 4
+		c = GETC()
+	} else if c < '0' || c > '7' {
+		goto dc
+	}
+	yylval.Lval = 0
+	for {
+		if c >= '0' && c <= '9' {
+			if c > '7' && c1 == 3 {
+				break
+			}
+			yylval.Lval = int64(uint64(yylval.Lval) << uint(c1))
+			yylval.Lval += int64(c) - '0'
+			c = GETC()
+			continue
+		}
+
+		if c1 == 3 {
+			break
+		}
+		if c >= 'A' && c <= 'F' {
+			c += 'a' - 'A'
+		}
+		if c >= 'a' && c <= 'f' {
+			yylval.Lval = int64(uint64(yylval.Lval) << uint(c1))
+			yylval.Lval += int64(c) - 'a' + 10
+			c = GETC()
+			continue
+		}
+
+		break
 	}
 
-	new5a.Peekc = c1
-	return int32(c)
+	goto ncu
+
+dc:
+	for {
+		if !(isdigit(c)) {
+			break
+		}
+		yybuf.WriteByte(byte(c))
+		c = GETC()
+	}
+
+	if c == '.' {
+		goto casedot
+	}
+	if c == 'e' || c == 'E' {
+		goto casee
+	}
+	last = yybuf.String()
+	yylval.Lval = strtoll(last, nil, 10)
+
+ncu:
+	for c == 'U' || c == 'u' || c == 'l' || c == 'L' {
+		c = GETC()
+	}
+	peekc = c
+	return LCONST
 }
 
 func getc() int {
 	var c int
 
-	c = new5a.Peekc
-	if c != new5a.IGN {
-		new5a.Peekc = new5a.IGN
+	c = peekc
+	if c != IGN {
+		peekc = IGN
 		return c
 	}
 
-	c = new5a.GETC()
+	c = GETC()
 	if c == '\n' {
-		new5a.Lineno++
+		Lineno++
 	}
-	if c == new5a.EOF {
+	if c == EOF {
 		Yyerror("End of file")
-		Errorexit()
+		errorexit()
 	}
 
 	return c
@@ -645,16 +554,16 @@ func getnsc() int {
 
 	for {
 		c = getc()
-		if !(main.Isspace(c) != 0) || c == '\n' {
+		if !isspace(c) || c == '\n' {
 			return c
 		}
 	}
 }
 
 func unget(c int) {
-	new5a.Peekc = c
+	peekc = c
 	if c == '\n' {
-		new5a.Lineno--
+		Lineno--
 	}
 }
 
@@ -666,12 +575,12 @@ loop:
 	c = getc()
 	if c == '\n' {
 		Yyerror("newline in string")
-		return new5a.EOF
+		return EOF
 	}
 
 	if c != '\\' {
 		if c == e {
-			return new5a.EOF
+			return EOF
 		}
 		return c
 	}
@@ -689,7 +598,7 @@ loop:
 			}
 		}
 
-		new5a.Peekc = c
+		peekc = c
 		return l
 	}
 
@@ -717,88 +626,109 @@ loop:
 	return c
 }
 
-func Pinit(f string) {
-	var i int
-	var s *new5a.Sym
-
-	new5a.Lineno = 1
+func pinit(f string) {
+	Lineno = 1
 	newio()
-	newfile(f, -1)
-	new5a.Pc = 0
-	new5a.Peekc = new5a.IGN
-	new5a.Sym = 1
-	for i = 0; i < new5a.NHASH; i++ {
-		for s = new5a.Hash[i]; s != nil; s = s.Link {
-			s.Macro = ""
-		}
+	newfile(f, nil)
+	PC = 0
+	peekc = IGN
+	sym = 1
+	for _, s := range hash {
+		s.Macro = nil
 	}
 }
 
 func filbuf() int {
-	var i *new5a.Io
+	var i *Io
+	var n int
 
 loop:
-	i = new5a.Iostack
+	i = iostack
 	if i == nil {
-		return new5a.EOF
+		return EOF
 	}
-	if i.F < 0 {
+	if i.F == nil {
 		goto pop
 	}
-	new5a.Fi.c = main.Read(int(i.F), i.B, new5a.BUFSIZ) - 1
-	if new5a.Fi.c < 0 {
-		main.Close(int(i.F))
-		obj.Linklinehist(new5a.Ctxt, int(new5a.Lineno), "", 0)
+	n, _ = i.F.Read(i.B[:])
+	if n == 0 {
+		i.F.Close()
+		obj.Linklinehist(Ctxt, int(Lineno), "<pop>", 0)
 		goto pop
 	}
-
-	new5a.Fi.p = i.B[1:]
+	fi.P = i.B[1:n]
 	return int(i.B[0]) & 0xff
 
 pop:
-	new5a.Iostack = i.Link
-	i.Link = new5a.Iofree
-	new5a.Iofree = i
-	i = new5a.Iostack
+	iostack = i.Link
+	i.Link = iofree
+	iofree = i
+	i = iostack
 	if i == nil {
-		return new5a.EOF
+		return EOF
 	}
-	new5a.Fi.p = i.P
-	new5a.Fi.c = int(i.C)
-	new5a.Fi.c--
-	if new5a.Fi.c < 0 {
+	fi.P = i.P
+	if len(fi.P) == 0 {
 		goto loop
 	}
-	tmp8 := new5a.Fi.p
-	new5a.Fi.p = new5a.Fi.p[1:]
+	tmp8 := fi.P
+	fi.P = fi.P[1:]
 	return int(tmp8[0]) & 0xff
 }
 
-func Yyerror(a string, args ...interface{}) {
-	var buf string
-	var arg []interface{}
+var last string
 
+func Yyerror(a string, args ...interface{}) {
 	/*
 	 * hack to intercept message from yaccpar
 	 */
-	if a == "syntax error" {
-
-		Yyerror("syntax error, last name: %s", new5a.Symb)
+	if a == "syntax error" || len(args) == 1 && a == "%s" && args[0] == "syntax error" {
+		Yyerror("syntax error, last name: %s", last)
 		return
 	}
 
-	prfile(new5a.Lineno)
-	main.Va_start(arg, a)
-	obj.Vseprint(buf, buf[sizeof(buf):], a, arg)
-	main.Va_end(arg)
-	fmt.Printf("%s\n", buf)
-	new5a.Nerrors++
-	if new5a.Nerrors > 10 {
+	prfile(Lineno)
+	fmt.Printf("%s\n", fmt.Sprintf(a, args...))
+	nerrors++
+	if nerrors > 10 {
 		fmt.Printf("too many errors\n")
-		Errorexit()
+		errorexit()
 	}
 }
 
 func prfile(l int32) {
-	obj.Linkprfile(new5a.Ctxt, l)
+	obj.Linkprfile(Ctxt, int(l))
+}
+
+func GETC() int {
+	var c int
+	if len(fi.P) == 0 {
+		return filbuf()
+	}
+	c = int(fi.P[0])
+	fi.P = fi.P[1:]
+	return c
+}
+
+func isdigit(c int) bool {
+	return '0' <= c && c <= '9'
+}
+
+func strtoll(s string, p *byte, base int) int64 {
+	if p != nil {
+		panic("strtoll")
+	}
+	n, err := strconv.ParseInt(s, base, 64)
+	if err != nil {
+		return 0
+	}
+	return n
+}
+
+func atof(s string) float64 {
+	f, err := strconv.ParseFloat(s, 64)
+	if err != nil {
+		return 0
+	}
+	return f
 }
diff --git a/src/cmd/internal/asm/macbody.go b/src/cmd/internal/asm/macbody.go
index d8ec242400..337692a08a 100644
--- a/src/cmd/internal/asm/macbody.go
+++ b/src/cmd/internal/asm/macbody.go
@@ -1,12 +1,12 @@
 // Inferno utils/cc/macbody
-// http://code.google.com/p/inferno-os/source/browse/utils/cc/macbody
+// http://code.Google.Com/p/inferno-os/source/browse/utils/cc/macbody
 //
 //	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
-//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.Net)
 //	Portions Copyright © 1997-1999 Vita Nuova Limited
-//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.Vitanuova.Com)
 //	Portions Copyright © 2004,2006 Bruce Ellis
-//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.Net)
 //	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
 //	Portions Copyright © 2009 The Go Authors.  All rights reserved.
 //
@@ -30,6 +30,14 @@
 
 package asm
 
+import (
+	"bytes"
+	"cmd/internal/obj"
+	"fmt"
+	"os"
+	"strings"
+)
+
 const (
 	VARMAC = 0x80
 )
@@ -52,39 +60,32 @@ func getnsn() int32 {
 	return n
 }
 
-func getsym() *new5a.Sym {
+func getsym() *Sym {
 	var c int
-	var cp string
 
 	c = getnsc()
-	if !(main.Isalpha(c) != 0) && c != '_' && c < 0x80 {
+	if !isalpha(c) && c != '_' && c < 0x80 {
 		unget(c)
 		return nil
 	}
 
-	for cp = new5a.Symb; ; {
-		if cp <= new5a.Symb[new5a.NSYMB-4:] {
-			cp[0] = byte(c)
-			cp = cp[1:]
-		}
+	var buf bytes.Buffer
+	for {
+		buf.WriteByte(byte(c))
 		c = getc()
-		if main.Isalnum(c) != 0 || c == '_' || c >= 0x80 {
+		if isalnum(c) || c == '_' || c >= 0x80 {
 			continue
 		}
 		unget(c)
 		break
 	}
-
-	cp = ""
-	if cp > new5a.Symb[new5a.NSYMB-4:] {
-		Yyerror("symbol too large: %s", new5a.Symb)
-	}
-	return lookup()
+	last = buf.String()
+	return Lookup(last)
 }
 
-func getsymdots(dots *int) *new5a.Sym {
+func getsymdots(dots *int) *Sym {
 	var c int
-	var s *new5a.Sym
+	var s *Sym
 
 	s = getsym()
 	if s != nil {
@@ -101,7 +102,7 @@ func getsymdots(dots *int) *new5a.Sym {
 		Yyerror("bad dots in macro")
 	}
 	*dots = 1
-	return Slookup("__VA_ARGS__")
+	return Lookup("__VA_ARGS__")
 }
 
 func getcom() int {
@@ -150,35 +151,28 @@ func getcom() int {
 	return c
 }
 
-func Dodefine(cp string) {
-	var s *new5a.Sym
+func dodefine(cp string) {
+	var s *Sym
 	var p string
-	var l int32
-
-	Ensuresymb(int32(len(cp)))
-	new5a.Symb = cp
-	p = main.Strchr(new5a.Symb, '=')
-	if p != "" {
-		p = ""
-		p = p[1:]
-		s = lookup()
-		l = int32(len(p)) + 2 /* +1 null, +1 nargs */
-		s.Macro = Alloc(l).(string)
-		s.Macro[1:] = p
-	} else {
 
-		s = lookup()
-		s.Macro = "\0001" /* \000 is nargs */
+	if i := strings.Index(cp, "="); i >= 0 {
+		p = cp[i+1:]
+		cp = cp[:i]
+		s = Lookup(cp)
+		s.Macro = &Macro{Text: p}
+	} else {
+		s = Lookup(cp)
+		s.Macro = &Macro{Text: "1"}
 	}
 
-	if new5a.Debug['m'] != 0 {
-		fmt.Printf("#define (-D) %s %s\n", s.Name, s.Macro[1:])
+	if debug['m'] != 0 {
+		fmt.Printf("#define (-D) %s %s\n", s.Name, s.Macro.Text)
 	}
 }
 
 var mactab = []struct {
-	macname string
-	macf    func()
+	Macname string
+	Macf    func()
 }{
 	{"ifdef", nil},  /* macif(0) */
 	{"ifndef", nil}, /* macif(1) */
@@ -193,18 +187,17 @@ var mactab = []struct {
 
 func domacro() {
 	var i int
-	var s *new5a.Sym
+	var s *Sym
 
 	s = getsym()
 	if s == nil {
-		s = Slookup("endif")
+		s = Lookup("endif")
 	}
-	for i = 0; mactab[i].macname != ""; i++ {
-		if s.Name == mactab[i].macname {
-			if mactab[i].macf != nil {
-				(*mactab[i].macf)()
+	for i = 0; i < len(mactab); i++ {
+		if s.Name == mactab[i].Macname {
+			if mactab[i].Macf != nil {
+				mactab[i].Macf()
 			} else {
-
 				macif(i)
 			}
 			return
@@ -216,7 +209,7 @@ func domacro() {
 }
 
 func macund() {
-	var s *new5a.Sym
+	var s *Sym
 
 	s = getsym()
 	macend()
@@ -225,7 +218,7 @@ func macund() {
 		return
 	}
 
-	s.Macro = ""
+	s.Macro = nil
 }
 
 const (
@@ -233,23 +226,21 @@ const (
 )
 
 func macdef() {
-	var s *new5a.Sym
-	var a *new5a.Sym
+	var s *Sym
+	var a *Sym
 	var args [NARG]string
-	var np string
-	var base string
 	var n int
 	var i int
 	var c int
-	var len int
 	var dots int
 	var ischr int
+	var base bytes.Buffer
 
 	s = getsym()
 	if s == nil {
 		goto bad
 	}
-	if s.Macro != "" {
+	if s.Macro != nil {
 		Yyerror("macro redefined: %s", s.Name)
 	}
 	c = getc()
@@ -285,53 +276,41 @@ func macdef() {
 		c = getc()
 	}
 
-	if main.Isspace(c) != 0 {
+	if isspace(c) {
 		if c != '\n' {
 			c = getnsc()
 		}
 	}
-	base = new5a.Hunk
-	len = 1
 	ischr = 0
 	for {
-		if main.Isalpha(c) != 0 || c == '_' {
-			np = new5a.Symb
-			np[0] = byte(c)
-			np = np[1:]
+		if isalpha(c) || c == '_' {
+			var buf bytes.Buffer
+			buf.WriteByte(byte(c))
 			c = getc()
-			for main.Isalnum(c) != 0 || c == '_' {
-				np[0] = byte(c)
-				np = np[1:]
+			for isalnum(c) || c == '_' {
+				buf.WriteByte(byte(c))
 				c = getc()
 			}
 
-			np = ""
+			symb := buf.String()
 			for i = 0; i < n; i++ {
-				if new5a.Symb == args[i] {
+				if symb == args[i] {
 					break
 				}
 			}
 			if i >= n {
-				i = len(new5a.Symb)
-				base = Allocn(base, int32(len), int32(i)).(string)
-				main.Memmove(base[len:], new5a.Symb, i)
-				len += i
+				base.WriteString(symb)
 				continue
 			}
 
-			base = Allocn(base, int32(len), 2).(string)
-			base[len] = '#'
-			len++
-			base[len] = byte('a' + i)
-			len++
+			base.WriteByte('#')
+			base.WriteByte(byte('a' + i))
 			continue
 		}
 
 		if ischr != 0 {
 			if c == '\\' {
-				base = Allocn(base, int32(len), 1).(string)
-				base[len] = byte(c)
-				len++
+				base.WriteByte(byte(c))
 				c = getc()
 			} else if c == ischr {
 				ischr = 0
@@ -339,9 +318,7 @@ func macdef() {
 		} else {
 
 			if c == '"' || c == '\'' {
-				base = Allocn(base, int32(len), 1).(string)
-				base[len] = byte(c)
-				len++
+				base.WriteByte(byte(c))
 				ischr = c
 				c = getc()
 				continue
@@ -384,9 +361,7 @@ func macdef() {
 					continue
 				}
 
-				base = Allocn(base, int32(len), 1).(string)
-				base[len] = '/'
-				len++
+				base.WriteByte('/')
 				continue
 			}
 		}
@@ -404,9 +379,7 @@ func macdef() {
 				}
 			}
 
-			base = Allocn(base, int32(len), 1).(string)
-			base[len] = '\\'
-			len++
+			base.WriteByte('\\')
 			continue
 		}
 
@@ -415,25 +388,14 @@ func macdef() {
 		}
 		if c == '#' {
 			if n > 0 {
-				base = Allocn(base, int32(len), 1).(string)
-				base[len] = byte(c)
-				len++
+				base.WriteByte(byte(c))
 			}
 		}
 
-		base = Allocn(base, int32(len), 1).(string)
-		base[len] = byte(c)
-		len++
-		new5a.Fi.c--
-		var tmp C.int
-		if new5a.Fi.c < 0 {
-			tmp = C.int(filbuf())
-		} else {
-			tmp = new5a.Fi.p[0] & 0xff
-		}
-		c = int(tmp)
+		base.WriteByte(byte(c))
+		c = GETC()
 		if c == '\n' {
-			new5a.Lineno++
+			Lineno++
 		}
 		if c == -1 {
 			Yyerror("eof in a macro: %s", s.Name)
@@ -441,22 +403,13 @@ func macdef() {
 		}
 	}
 
-	for {
-		base = Allocn(base, int32(len), 1).(string)
-		base[len] = 0
-		len++
-		if !(len&3 != 0 /*untyped*/) {
-			break
-		}
+	s.Macro = &Macro{
+		Text: base.String(),
+		Narg: n + 1,
+		Dots: dots != 0,
 	}
-
-	base[0] = byte(n + 1)
-	if dots != 0 {
-		base[0] |= VARMAC
-	}
-	s.Macro = base
-	if new5a.Debug['m'] != 0 {
-		fmt.Printf("#define %s %s\n", s.Name, s.Macro[1:])
+	if debug['m'] != 0 {
+		fmt.Printf("#define %s %s\n", s.Name, s.Macro.Text)
 	}
 	return
 
@@ -470,59 +423,40 @@ bad:
 	macend()
 }
 
-func macexpand(s *new5a.Sym, b string) {
-	var buf string
-	var n int
+func macexpand(s *Sym) []byte {
 	var l int
 	var c int
-	var nargs int
-	var arg [NARG]string
+	var arg []string
+	var out bytes.Buffer
+	var buf bytes.Buffer
 	var cp string
-	var ob string
-	var ecp string
-	var dots int8
 
-	ob = b
-	if s.Macro[0] == 0 {
-		b = s.Macro[1:]
-		if new5a.Debug['m'] != 0 {
-			fmt.Printf("#expand %s %s\n", s.Name, ob)
+	if s.Macro.Narg == 0 {
+		if debug['m'] != 0 {
+			fmt.Printf("#expand %s %s\n", s.Name, s.Macro.Text)
 		}
-		return
+		return []byte(s.Macro.Text)
 	}
 
-	nargs = int(int8(s.Macro[0]&^VARMAC)) - 1
-	dots = int8(s.Macro[0] & VARMAC)
+	nargs := s.Macro.Narg - 1
+	dots := s.Macro.Dots
 
 	c = getnsc()
 	if c != '(' {
 		goto bad
 	}
-	n = 0
 	c = getc()
 	if c != ')' {
 		unget(c)
 		l = 0
-		cp = buf
-		ecp = cp[sizeof(buf)-4:]
-		arg[n] = cp
-		n++
 		for {
-			if cp >= ecp {
-				goto toobig
-			}
 			c = getc()
 			if c == '"' {
 				for {
-					if cp >= ecp {
-						goto toobig
-					}
-					cp[0] = byte(c)
-					cp = cp[1:]
+					buf.WriteByte(byte(c))
 					c = getc()
 					if c == '\\' {
-						cp[0] = byte(c)
-						cp = cp[1:]
+						buf.WriteByte(byte(c))
 						c = getc()
 						continue
 					}
@@ -538,15 +472,10 @@ func macexpand(s *new5a.Sym, b string) {
 
 			if c == '\'' {
 				for {
-					if cp >= ecp {
-						goto toobig
-					}
-					cp[0] = byte(c)
-					cp = cp[1:]
+					buf.WriteByte(byte(c))
 					c = getc()
 					if c == '\\' {
-						cp[0] = byte(c)
-						cp = cp[1:]
+						buf.WriteByte(byte(c))
 						c = getc()
 						continue
 					}
@@ -574,8 +503,7 @@ func macexpand(s *new5a.Sym, b string) {
 						}
 					}
 
-					cp[0] = ' '
-					cp = cp[1:]
+					buf.WriteByte(' ')
 					continue
 
 				case '/':
@@ -594,23 +522,18 @@ func macexpand(s *new5a.Sym, b string) {
 
 			if l == 0 {
 				if c == ',' {
-					if n == nargs && dots != 0 {
-						cp[0] = ','
-						cp = cp[1:]
+					if len(arg) == nargs-1 && dots {
+						buf.WriteByte(',')
 						continue
 					}
 
-					cp = ""
-					cp = cp[1:]
-					arg[n] = cp
-					n++
-					if n > nargs {
-						break
-					}
+					arg = append(arg, buf.String())
+					buf.Reset()
 					continue
 				}
 
 				if c == ')' {
+					arg = append(arg, buf.String())
 					break
 				}
 			}
@@ -618,8 +541,7 @@ func macexpand(s *new5a.Sym, b string) {
 			if c == '\n' {
 				c = ' '
 			}
-			cp[0] = byte(c)
-			cp = cp[1:]
+			buf.WriteByte(byte(c))
 			if c == '(' {
 				l++
 			}
@@ -627,74 +549,60 @@ func macexpand(s *new5a.Sym, b string) {
 				l--
 			}
 		}
-
-		cp = ""
 	}
 
-	if n != nargs {
+	if len(arg) != nargs {
 		Yyerror("argument mismatch expanding: %s", s.Name)
-		b = ""
-		return
+		return nil
 	}
 
-	cp = s.Macro[1:]
-	for {
-		c = int(cp[0])
-		cp = cp[1:]
+	cp = s.Macro.Text
+	for i := 0; i < len(cp); i++ {
+		c = int(cp[i])
 		if c == '\n' {
 			c = ' '
 		}
 		if c != '#' {
-			b[0] = byte(c)
-			b = b[1:]
-			if c == 0 {
-				break
-			}
+			out.WriteByte(byte(c))
 			continue
 		}
 
-		c = int(cp[0])
-		cp = cp[1:]
-		if c == 0 {
+		i++
+		if i >= len(cp) {
 			goto bad
 		}
+		c = int(cp[i])
 		if c == '#' {
-			b[0] = byte(c)
-			b = b[1:]
+			out.WriteByte(byte(c))
 			continue
 		}
 
 		c -= 'a'
-		if c < 0 || c >= n {
+		if c < 0 || c >= len(arg) {
 			continue
 		}
-		b = arg[c]
-		b = b[len(arg[c]):]
+		out.WriteString(arg[c])
 	}
 
-	b = ""
-	if new5a.Debug['m'] != 0 {
-		fmt.Printf("#expand %s %s\n", s.Name, ob)
+	if debug['m'] != 0 {
+		fmt.Printf("#expand %s %s\n", s.Name, out.String())
 	}
-	return
+	return out.Bytes()
 
 bad:
 	Yyerror("syntax in macro expansion: %s", s.Name)
-	b = ""
-	return
-
-toobig:
-	Yyerror("too much text in macro expansion: %s", s.Name)
-	b = ""
+	return nil
 }
 
 func macinc() {
 	var c0 int
 	var c int
 	var i int
-	var f int
-	var str string
+	var buf bytes.Buffer
+	var f *os.File
 	var hp string
+	var str string
+	var symb string
 
 	c0 = getnsc()
 	if c0 != '"' {
@@ -705,7 +613,7 @@ func macinc() {
 		c0 = '>'
 	}
 
-	for hp = str; ; {
+	for {
 		c = getc()
 		if c == c0 {
 			break
@@ -713,41 +621,36 @@ func macinc() {
 		if c == '\n' {
 			goto bad
 		}
-		hp[0] = byte(c)
-		hp = hp[1:]
+		buf.WriteByte(byte(c))
 	}
-
-	hp = ""
+	str = buf.String()
 
 	c = getcom()
 	if c != '\n' {
 		goto bad
 	}
 
-	f = -1
-	for i = 0; i < new5a.Ninclude; i++ {
+	for i = 0; i < len(include); i++ {
 		if i == 0 && c0 == '>' {
 			continue
 		}
-		Ensuresymb(int32(len(new5a.Include[i])) + int32(len(str)) + 2)
-		new5a.Symb = new5a.Include[i]
-		new5a.Symb += "/"
-		if new5a.Symb == "./" {
-			new5a.Symb = ""
+		symb = include[i]
+		symb += "/"
+		if symb == "./" {
+			symb = ""
 		}
-		new5a.Symb += str
-		f = main.Open(new5a.Symb, main.OREAD)
-		if f >= 0 {
+		symb += str
+		var err error
+		f, err = os.Open(symb)
+		if err == nil {
 			break
 		}
 	}
 
-	if f < 0 {
-		new5a.Symb = str
+	if f == nil {
+		symb = str
 	}
-	c = len(new5a.Symb) + 1
-	hp = Alloc(int32(c)).(string)
-	main.Memmove(hp, new5a.Symb, c)
+	hp = symb
 	newio()
 	pushio()
 	newfile(hp, f)
@@ -760,16 +663,16 @@ bad:
 }
 
 func maclin() {
-	var cp string
 	var c int
 	var n int32
+	var buf bytes.Buffer
+	var symb string
 
 	n = getnsn()
 	c = getc()
 	if n < 0 {
 		goto bad
 	}
-
 	for {
 		if c == ' ' || c == '\t' {
 			c = getc()
@@ -780,34 +683,29 @@ func maclin() {
 			break
 		}
 		if c == '\n' {
-			new5a.Symb = "<noname>"
+			symb = "<noname>"
 			goto nn
 		}
 
 		goto bad
 	}
 
-	cp = new5a.Symb
 	for {
 		c = getc()
 		if c == '"' {
 			break
 		}
-		cp[0] = byte(c)
-		cp = cp[1:]
+		buf.WriteByte(byte(c))
 	}
+	symb = buf.String()
 
-	cp = ""
 	c = getcom()
 	if c != '\n' {
 		goto bad
 	}
 
 nn:
-	c = len(new5a.Symb) + 1
-	cp = Alloc(int32(c)).(string)
-	main.Memmove(cp, new5a.Symb, c)
-	obj.Linklinehist(new5a.Ctxt, int(new5a.Lineno), cp, int(n))
+	obj.Linklinehist(Ctxt, int(Lineno), symb, int(n))
 	return
 
 bad:
@@ -820,7 +718,7 @@ func macif(f int) {
 	var c int
 	var l int
 	var bol int
-	var s *new5a.Sym
+	var s *Sym
 
 	if f == 2 {
 		goto skip
@@ -832,7 +730,7 @@ func macif(f int) {
 	if getcom() != '\n' {
 		goto bad
 	}
-	if (s.Macro != "")^f != 0 /*untyped*/ {
+	if (s.Macro != nil) != (f != 0) {
 		return
 	}
 
@@ -842,7 +740,7 @@ skip:
 	for {
 		c = getc()
 		if c != '#' {
-			if !(main.Isspace(c) != 0) {
+			if !isspace(c) {
 				bol = 0
 			}
 			if c == '\n' {
@@ -885,10 +783,11 @@ bad:
 }
 
 func macprag() {
-	var s *new5a.Sym
+	var s *Sym
 	var c0 int
 	var c int
-	var hp string
+	var buf bytes.Buffer
+	var symb string
 
 	s = getsym()
 
@@ -945,7 +844,7 @@ praglib:
 		c0 = '>'
 	}
 
-	for hp = new5a.Symb; ; {
+	for {
 		c = getc()
 		if c == c0 {
 			break
@@ -953,11 +852,10 @@ praglib:
 		if c == '\n' {
 			goto bad
 		}
-		hp[0] = byte(c)
-		hp = hp[1:]
+		buf.WriteByte(byte(c))
 	}
+	symb = buf.String()
 
-	hp = ""
 	c = getcom()
 	if c != '\n' {
 		goto bad
@@ -966,12 +864,7 @@ praglib:
 	/*
 	 * put pragma-line in as a funny history
 	 */
-	c = len(new5a.Symb) + 1
-
-	hp = Alloc(int32(c)).(string)
-	main.Memmove(hp, new5a.Symb, c)
-
-	obj.Linklinehist(new5a.Ctxt, int(new5a.Lineno), hp, -1)
+	obj.Linklinehist(Ctxt, int(Lineno), symb, -1)
 	return
 
 bad:
diff --git a/src/cmd/new5a/a.y b/src/cmd/new5a/a.y
index d365c75343..2ef3907f72 100644
--- a/src/cmd/new5a/a.y
+++ b/src/cmd/new5a/a.y
@@ -29,20 +29,23 @@
 // THE SOFTWARE.
 
 %{
-#include <u.h>
-#include <stdio.h>	/* if we don't, bison will, and a.h re-#defines getc */
-#include <libc.h>
-#include "a.h"
-#include "../../runtime/funcdata.h"
+package main
+
+import (
+	"cmd/internal/asm"
+	"cmd/internal/obj"
+	. "cmd/internal/obj/arm"
+)
 %}
-%union
-{
-	Sym	*sym;
-	int32	lval;
-	double	dval;
-	char	sval[8];
-	Addr	addr;
+
+%union {
+	sym *asm.Sym
+	lval int32
+	dval float64
+	sval string
+	addr obj.Addr
 }
+
 %left	'|'
 %left	'^'
 %left	'&'
@@ -68,30 +71,32 @@
 prog:
 |	prog
 	{
-		stmtline = lineno;
+		stmtline = asm.Lineno;
 	}
 	line
 
 line:
 	LNAME ':'
 	{
-		$1 = labellookup($1);
-		if($1->type == LLAB && $1->value != pc)
-			yyerror("redeclaration of %s", $1->labelname);
-		$1->type = LLAB;
-		$1->value = pc;
+		$1 = asm.LabelLookup($1);
+		if $1.Type == LLAB && $1.Value != int64(asm.PC) {
+			yyerror("redeclaration of %s", $1.Labelname)
+		}
+		$1.Type = LLAB;
+		$1.Value = int64(asm.PC)
 	}
 	line
 |	LNAME '=' expr ';'
 	{
-		$1->type = LVAR;
-		$1->value = $3;
+		$1.Type = LVAR;
+		$1.Value = int64($3);
 	}
 |	LVAR '=' expr ';'
 	{
-		if($1->value != $3)
-			yyerror("redeclaration of %s", $1->name);
-		$1->value = $3;
+		if $1.Value != int64($3) {
+			yyerror("redeclaration of %s", $1.Name)
+		}
+		$1.Value = int64($3);
 	}
 |	';'
 |	inst ';'
@@ -171,20 +176,20 @@ inst:
  */
 |	LTYPE8 cond ioreg ',' '[' reglist ']'
 	{
-		Addr g;
+		var g obj.Addr
 
 		g = nullgen;
-		g.type = D_CONST;
-		g.offset = $6;
+		g.Type_ = D_CONST;
+		g.Offset = int64($6);
 		outcode($1, $2, &$3, NREG, &g);
 	}
 |	LTYPE8 cond '[' reglist ']' ',' ioreg
 	{
-		Addr g;
+		var g obj.Addr
 
 		g = nullgen;
-		g.type = D_CONST;
-		g.offset = $4;
+		g.Type_ = D_CONST;
+		g.Offset = int64($4);
 		outcode($1, $2, &g, NREG, &$7);
 	}
 /*
@@ -192,15 +197,15 @@ inst:
  */
 |	LTYPE9 cond reg ',' ireg ',' reg
 	{
-		outcode($1, $2, &$5, $3.reg, &$7);
+		outcode($1, $2, &$5, int32($3.Reg), &$7);
 	}
 |	LTYPE9 cond reg ',' ireg comma
 	{
-		outcode($1, $2, &$5, $3.reg, &$3);
+		outcode($1, $2, &$5, int32($3.Reg), &$3);
 	}
 |	LTYPE9 cond comma ireg ',' reg
 	{
-		outcode($1, $2, &$4, $6.reg, &$6);
+		outcode($1, $2, &$4, int32($6.Reg), &$6);
 	}
 /*
  * RET
@@ -214,23 +219,23 @@ inst:
  */
 |	LTYPEB name ',' imm
 	{
-		settext($2.sym);
-		$4.type = D_CONST2;
-		$4.offset2 = ArgsSizeUnknown;
+		asm.Settext($2.Sym);
+		$4.Type_ = D_CONST2;
+		$4.Offset2 = -obj.ArgsSizeUnknown;
 		outcode($1, Always, &$2, 0, &$4);
 	}
 |	LTYPEB name ',' con ',' imm
 	{
-		settext($2.sym);
-		$6.type = D_CONST2;
-		$6.offset2 = ArgsSizeUnknown;
+		asm.Settext($2.Sym);
+		$6.Type_ = D_CONST2;
+		$6.Offset2 = -obj.ArgsSizeUnknown;
 		outcode($1, Always, &$2, $4, &$6);
 	}
 |	LTYPEB name ',' con ',' imm '-' con
 	{
-		settext($2.sym);
-		$6.type = D_CONST2;
-		$6.offset2 = $8;
+		asm.Settext($2.Sym);
+		$6.Type_ = D_CONST2;
+		$6.Offset2 = $8;
 		outcode($1, Always, &$2, $4, &$6);
 	}
 /*
@@ -271,18 +276,18 @@ inst:
 	}
 |	LTYPEL cond freg ',' freg comma
 	{
-		outcode($1, $2, &$3, $5.reg, &nullgen);
+		outcode($1, $2, &$3, int32($5.Reg), &nullgen);
 	}
 /*
  * MCR MRC
  */
 |	LTYPEJ cond con ',' expr ',' spreg ',' creg ',' creg oexpr
 	{
-		Addr g;
+		var g obj.Addr
 
 		g = nullgen;
-		g.type = D_CONST;
-		g.offset =
+		g.Type_ = D_CONST;
+		g.Offset = int64(
 			(0xe << 24) |		/* opcode */
 			($1 << 20) |		/* MCR/MRC */
 			($2 << 28) |		/* scond */
@@ -292,7 +297,7 @@ inst:
 			(($9 & 15) << 16) |	/* Crn */
 			(($11 & 15) << 0) |	/* Crm */
 			(($12 & 7) << 5) |	/* coprocessor information */
-			(1<<4);			/* must be set */
+			(1<<4));			/* must be set */
 		outcode(AMRC, Always, &nullgen, NREG, &g);
 	}
 /*
@@ -300,17 +305,17 @@ inst:
  */
 |	LTYPEM cond reg ',' reg ',' regreg
 	{
-		outcode($1, $2, &$3, $5.reg, &$7);
+		outcode($1, $2, &$3, int32($5.Reg), &$7);
 	}
 /*
- * MULA r1,r2,r3,r4: (r1*r2+r3) & 0xffffffff -> r4
+ * MULA r1,r2,r3,r4: (r1*r2+r3) & 0xffffffff . r4
  * MULAW{T,B} r1,r2,r3,r4
  */
 |	LTYPEN cond reg ',' reg ',' reg ',' spreg
 	{
-		$7.type = D_REGREG2;
-		$7.offset = $9;
-		outcode($1, $2, &$3, $5.reg, &$7);
+		$7.Type_ = D_REGREG2;
+		$7.Offset = int64($9);
+		outcode($1, $2, &$3, int32($5.Reg), &$7);
 	}
 /*
  * PLD
@@ -324,8 +329,9 @@ inst:
  */
 |	LTYPEPC gen ',' gen
 	{
-		if($2.type != D_CONST || $4.type != D_CONST)
-			yyerror("arguments to PCDATA must be integer constants");
+		if $2.Type_ != D_CONST || $4.Type_ != D_CONST {
+			yyerror("arguments to PCDATA must be integer constants")
+		}
 		outcode($1, Always, &$2, NREG, &$4);
 	}
 /*
@@ -333,10 +339,12 @@ inst:
  */
 |	LTYPEF gen ',' gen
 	{
-		if($2.type != D_CONST)
-			yyerror("index for FUNCDATA must be integer constant");
-		if($4.type != D_EXTERN && $4.type != D_STATIC && $4.type != D_OREG)
-			yyerror("value for FUNCDATA must be symbol reference");
+		if $2.Type_ != D_CONST {
+			yyerror("index for FUNCDATA must be integer constant")
+		}
+		if $4.Type_ != D_EXTERN && $4.Type_ != D_STATIC && $4.Type_ != D_OREG {
+			yyerror("value for FUNCDATA must be symbol reference")
+		}
  		outcode($1, Always, &$2, NREG, &$4);
 	}
 /*
@@ -353,7 +361,7 @@ cond:
 	}
 |	cond LCOND
 	{
-		$$ = ($1 & ~C_SCOND) | $2;
+		$$ = ($1 & ^ C_SCOND) | $2;
 	}
 |	cond LS
 	{
@@ -367,40 +375,41 @@ rel:
 	con '(' LPC ')'
 	{
 		$$ = nullgen;
-		$$.type = D_BRANCH;
-		$$.offset = $1 + pc;
+		$$.Type_ = D_BRANCH;
+		$$.Offset = int64($1) + int64(asm.PC);
 	}
 |	LNAME offset
 	{
-		$1 = labellookup($1);
+		$1 = asm.LabelLookup($1);
 		$$ = nullgen;
-		if(pass == 2 && $1->type != LLAB)
-			yyerror("undefined label: %s", $1->labelname);
-		$$.type = D_BRANCH;
-		$$.offset = $1->value + $2;
+		if asm.Pass == 2 && $1.Type != LLAB {
+			yyerror("undefined label: %s", $1.Labelname)
+		}
+		$$.Type_ = D_BRANCH;
+		$$.Offset = $1.Value + int64($2);
 	}
 
 ximm:	'$' con
 	{
 		$$ = nullgen;
-		$$.type = D_CONST;
-		$$.offset = $2;
+		$$.Type_ = D_CONST;
+		$$.Offset = int64($2);
 	}
 |	'$' oreg
 	{
 		$$ = $2;
-		$$.type = D_CONST;
+		$$.Type_ = D_CONST;
 	}
 |	'$' '*' '$' oreg
 	{
 		$$ = $4;
-		$$.type = D_OCONST;
+		$$.Type_ = D_OCONST;
 	}
 |	'$' LSCONST
 	{
 		$$ = nullgen;
-		$$.type = D_SCONST;
-		memcpy($$.u.sval, $2, sizeof($$.u.sval));
+		$$.Type_ = D_SCONST;
+		$$.U.Sval = $2
 	}
 |	fcon
 
@@ -408,33 +417,34 @@ fcon:
 	'$' LFCONST
 	{
 		$$ = nullgen;
-		$$.type = D_FCONST;
-		$$.u.dval = $2;
+		$$.Type_ = D_FCONST;
+		$$.U.Dval = $2;
 	}
 |	'$' '-' LFCONST
 	{
 		$$ = nullgen;
-		$$.type = D_FCONST;
-		$$.u.dval = -$3;
+		$$.Type_ = D_FCONST;
+		$$.U.Dval = -$3;
 	}
 
 reglist:
 	spreg
 	{
-		$$ = 1 << $1;
+		$$ = 1 << uint($1);
 	}
 |	spreg '-' spreg
 	{
-		int i;
 		$$=0;
-		for(i=$1; i<=$3; i++)
-			$$ |= 1<<i;
-		for(i=$3; i<=$1; i++)
-			$$ |= 1<<i;
+		for i:=$1; i<=$3; i++ {
+			$$ |= 1<<uint(i)
+		}
+		for i:=$3; i<=$1; i++ {
+			$$ |= 1<<uint(i)
+		}
 	}
 |	spreg comma reglist
 	{
-		$$ = (1<<$1) | $3;
+		$$ = (1<<uint($1)) | $3;
 	}
 
 gen:
@@ -444,25 +454,25 @@ gen:
 |	shift '(' spreg ')'
 	{
 		$$ = $1;
-		$$.reg = $3;
+		$$.Reg = int8($3);
 	}
 |	LPSR
 	{
 		$$ = nullgen;
-		$$.type = D_PSR;
-		$$.reg = $1;
+		$$.Type_ = D_PSR;
+		$$.Reg = int8($1);
 	}
 |	LFCR
 	{
 		$$ = nullgen;
-		$$.type = D_FPCR;
-		$$.reg = $1;
+		$$.Type_ = D_FPCR;
+		$$.Reg = int8($1);
 	}
 |	con
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
-		$$.offset = $1;
+		$$.Type_ = D_OREG;
+		$$.Offset = int64($1);
 	}
 |	oreg
 |	freg
@@ -472,7 +482,7 @@ nireg:
 |	name
 	{
 		$$ = $1;
-		if($1.name != D_EXTERN && $1.name != D_STATIC) {
+		if($1.Name != D_EXTERN && $1.Name != D_STATIC) {
 		}
 	}
 
@@ -480,9 +490,9 @@ ireg:
 	'(' spreg ')'
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
-		$$.reg = $2;
-		$$.offset = 0;
+		$$.Type_ = D_OREG;
+		$$.Reg = int8($2);
+		$$.Offset = 0;
 	}
 
 ioreg:
@@ -490,9 +500,9 @@ ioreg:
 |	con '(' sreg ')'
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
-		$$.reg = $3;
-		$$.offset = $1;
+		$$.Type_ = D_OREG;
+		$$.Reg = int8($3);
+		$$.Offset = int64($1);
 	}
 
 oreg:
@@ -500,8 +510,8 @@ oreg:
 |	name '(' sreg ')'
 	{
 		$$ = $1;
-		$$.type = D_OREG;
-		$$.reg = $3;
+		$$.Type_ = D_OREG;
+		$$.Reg = int8($3);
 	}
 |	ioreg
 
@@ -513,64 +523,66 @@ imsr:
 imm:	'$' con
 	{
 		$$ = nullgen;
-		$$.type = D_CONST;
-		$$.offset = $2;
+		$$.Type_ = D_CONST;
+		$$.Offset = int64($2);
 	}
 
 reg:
 	spreg
 	{
 		$$ = nullgen;
-		$$.type = D_REG;
-		$$.reg = $1;
+		$$.Type_ = D_REG;
+		$$.Reg = int8($1);
 	}
 
 regreg:
 	'(' spreg ',' spreg ')'
 	{
 		$$ = nullgen;
-		$$.type = D_REGREG;
-		$$.reg = $2;
-		$$.offset = $4;
+		$$.Type_ = D_REGREG;
+		$$.Reg = int8($2);
+		$$.Offset = int64($4);
 	}
 
 shift:
 	spreg '<' '<' rcon
 	{
 		$$ = nullgen;
-		$$.type = D_SHIFT;
-		$$.offset = $1 | $4 | (0 << 5);
+		$$.Type_ = D_SHIFT;
+		$$.Offset = int64($1) | int64($4) | (0 << 5);
 	}
 |	spreg '>' '>' rcon
 	{
 		$$ = nullgen;
-		$$.type = D_SHIFT;
-		$$.offset = $1 | $4 | (1 << 5);
+		$$.Type_ = D_SHIFT;
+		$$.Offset = int64($1) | int64($4) | (1 << 5);
 	}
 |	spreg '-' '>' rcon
 	{
 		$$ = nullgen;
-		$$.type = D_SHIFT;
-		$$.offset = $1 | $4 | (2 << 5);
+		$$.Type_ = D_SHIFT;
+		$$.Offset = int64($1) | int64($4) | (2 << 5);
 	}
 |	spreg LAT '>' rcon
 	{
 		$$ = nullgen;
-		$$.type = D_SHIFT;
-		$$.offset = $1 | $4 | (3 << 5);
+		$$.Type_ = D_SHIFT;
+		$$.Offset = int64($1) | int64($4) | (3 << 5);
 	}
 
 rcon:
 	spreg
 	{
-		if($$ < 0 || $$ >= 16)
-			print("register value out of range\n");
+		if $$ < 0 || $$ >= 16 {
+			print("register value out of range\n")
+		}
 		$$ = (($1&15) << 8) | (1 << 4);
 	}
 |	con
 	{
-		if($$ < 0 || $$ >= 32)
-			print("shift value out of range\n");
+		if $$ < 0 || $$ >= 32 {
+			print("shift value out of range\n")
+		}
 		$$ = ($1&31) << 7;
 	}
 
@@ -582,8 +594,9 @@ sreg:
 	}
 |	LR '(' expr ')'
 	{
-		if($3 < 0 || $3 >= NREG)
-			print("register value out of range\n");
+		if $3 < 0 || $3 >= NREG {
+			print("register value out of range\n")
+		}
 		$$ = $3;
 	}
 
@@ -598,8 +611,9 @@ creg:
 	LCREG
 |	LC '(' expr ')'
 	{
-		if($3 < 0 || $3 >= NREG)
-			print("register value out of range\n");
+		if $3 < 0 || $3 >= NREG {
+			print("register value out of range\n")
+		}
 		$$ = $3;
 	}
 
@@ -611,40 +625,40 @@ freg:
 	LFREG
 	{
 		$$ = nullgen;
-		$$.type = D_FREG;
-		$$.reg = $1;
+		$$.Type_ = D_FREG;
+		$$.Reg = int8($1);
 	}
 |	LF '(' con ')'
 	{
 		$$ = nullgen;
-		$$.type = D_FREG;
-		$$.reg = $3;
+		$$.Type_ = D_FREG;
+		$$.Reg = int8($3);
 	}
 
 name:
 	con '(' pointer ')'
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
-		$$.name = $3;
-		$$.sym = nil;
-		$$.offset = $1;
+		$$.Type_ = D_OREG;
+		$$.Name = int8($3);
+		$$.Sym = nil;
+		$$.Offset = int64($1);
 	}
 |	LNAME offset '(' pointer ')'
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
-		$$.name = $4;
-		$$.sym = linklookup(ctxt, $1->name, 0);
-		$$.offset = $2;
+		$$.Type_ = D_OREG;
+		$$.Name = int8($4);
+		$$.Sym = obj.Linklookup(asm.Ctxt, $1.Name, 0);
+		$$.Offset = int64($2);
 	}
 |	LNAME '<' '>' offset '(' LSB ')'
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
-		$$.name = D_STATIC;
-		$$.sym = linklookup(ctxt, $1->name, 1);
-		$$.offset = $4;
+		$$.Type_ = D_OREG;
+		$$.Name = D_STATIC;
+		$$.Sym = obj.Linklookup(asm.Ctxt, $1.Name, 1);
+		$$.Offset = int64($4);
 	}
 
 offset:
@@ -669,7 +683,7 @@ con:
 	LCONST
 |	LVAR
 	{
-		$$ = $1->value;
+		$$ = int32($1.Value);
 	}
 |	'-' con
 	{
@@ -681,7 +695,7 @@ con:
 	}
 |	'~' con
 	{
-		$$ = ~$2;
+		$$ = ^$2;
 	}
 |	'(' expr ')'
 	{
@@ -721,11 +735,11 @@ expr:
 	}
 |	expr '<' '<' expr
 	{
-		$$ = $1 << $4;
+		$$ = $1 << uint($4);
 	}
 |	expr '>' '>' expr
 	{
-		$$ = $1 >> $4;
+		$$ = $1 >> uint($4);
 	}
 |	expr '&' expr
 	{
diff --git a/src/cmd/new5a/lex.go b/src/cmd/new5a/lex.go
index 17255d00cf..81cd2268d6 100644
--- a/src/cmd/new5a/lex.go
+++ b/src/cmd/new5a/lex.go
@@ -28,162 +28,66 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+//go:generate go tool yacc a.y
+
 package main
 
-const (
-	Plan9   = 1 << 0
-	Unix    = 1 << 1
-	Windows = 1 << 2
+import (
+	"cmd/internal/asm"
+	"cmd/internal/obj"
+	"cmd/internal/obj/arm"
 )
 
-func systemtype(sys int) int {
-	return sys & Windows
-
-	return sys & Plan9
-}
-
-func Lconv(fp *obj.Fmt) int {
-	return obj.Linklinefmt(Ctxt, fp)
-}
-
-func dodef(p string) {
-	if nDlist%8 == 0 {
-		Dlist = asm.Allocn(Dlist, nDlist*sizeof(string), 8*sizeof(string)).(*string)
-	}
-	Dlist[nDlist] = p
-	nDlist++
-}
-
-func usage() {
-	fmt.Printf("usage: %ca [options] file.c...\n", Thechar)
-	main.Flagprint(1)
-	asm.Errorexit()
-}
-
-func main(argc int, argv [XXX]string) {
-	var p string
-
-	Thechar = '5'
-	thestring = "arm"
-
-	Ctxt = obj.Linknew(&arm.Linkarm)
-	Ctxt.Diag = asm.Yyerror
-	Ctxt.Bso = &Bstdout
-	Ctxt.Enforce_data_order = 1
-	obj.Binit(&Bstdout, 1, main.OWRITE)
-	arm.Listinit5()
-	obj.Fmtinstall('L', Lconv)
-
-	// Allow GOARCH=thestring or GOARCH=thestringsuffix,
-	// but not other values.
-	p = Getgoarch()
+var (
+	yyerror  = asm.Yyerror
+	nullgen  obj.Addr
+	stmtline int32
+)
 
-	if !strings.HasPrefix(p, thestring) {
-		log.Fatalf("cannot use %cc with GOARCH=%s", Thechar, p)
-	}
+const Always = 14
 
-	asm.Ensuresymb(NSYMB)
-	Debug = [256]int{}
+func main() {
 	cinit()
-	Outfile = ""
-	asm.Setinclude(".")
 
-	main.Flagfn1("D", "name[=value]: add #define", dodef)
-	main.Flagfn1("I", "dir: add dir to include path", asm.Setinclude)
-	main.Flagcount("S", "print assembly and machine code", &Debug['S'])
-	main.Flagcount("m", "debug preprocessor macros", &Debug['m'])
-	main.Flagstr("o", "file: set output file", &Outfile)
-	main.Flagstr("trimpath", "prefix: remove prefix from recorded source file paths", &Ctxt.Trimpath)
+	asm.LSCONST = LSCONST
+	asm.LCONST = LCONST
+	asm.LFCONST = LFCONST
+	asm.LNAME = LNAME
+	asm.LVAR = LVAR
+	asm.LLAB = LLAB
 
-	main.Flagparse(&argc, (**string)(&argv), usage)
-	Ctxt.Debugasm = int32(Debug['S'])
+	asm.Lexinit = lexinit
+	asm.Cclean = cclean
+	asm.Yyparse = yyparse
 
-	if argc < 1 {
-		usage()
-	}
-	if argc > 1 {
-		fmt.Printf("can't assemble multiple files\n")
-		asm.Errorexit()
-	}
+	asm.Thechar = '5'
+	asm.Thestring = "arm"
+	asm.Thelinkarch = &arm.Linkarm
 
-	if assemble(argv[0]) != 0 {
-		asm.Errorexit()
-	}
-	obj.Bflush(&Bstdout)
-	if Nerrors > 0 {
-		asm.Errorexit()
-	}
-	main.Exits("")
+	asm.Main()
 }
 
-func assemble(file string) int {
-	var ofile string
-	var p string
-	var i int
-	var of int
+type yy struct{}
 
-	ofile = asm.Alloc(int32(len(file)) + 3).(string) // +3 for .x\0 (x=thechar)
-	ofile = file
-	p = main.Utfrrune(ofile, '/')
-	if p != "" {
-		Include[0] = ofile
-		p = ""
-		p = p[1:]
-	} else {
-
-		p = ofile
-	}
-	if Outfile == "" {
-		Outfile = p
-		if Outfile != "" {
-			p = main.Utfrrune(Outfile, '.')
-			if p != "" {
-				if p[1] == 's' && p[2] == 0 {
-					p = ""
-				}
-			}
-			p = main.Utfrune(Outfile, 0)
-			p[0] = '.'
-			p[1] = byte(Thechar)
-			p[2] = 0
-		} else {
-
-			Outfile = "/dev/null"
-		}
-	}
-
-	of = main.Create(Outfile, main.OWRITE, 0664)
-	if of < 0 {
-		asm.Yyerror("%ca: cannot create %s", Thechar, Outfile)
-		asm.Errorexit()
-	}
-
-	obj.Binit(&obuf, of, main.OWRITE)
-	fmt.Fprintf(&obuf, "go object %s %s %s\n", main.Getgoos(), main.Getgoarch(), main.Getgoversion())
-	fmt.Fprintf(&obuf, "!\n")
+func (yy) Lex(v *yySymType) int {
+	var av asm.Yylval
+	tok := asm.Yylex(&av)
+	v.sym = av.Sym
+	v.lval = int32(av.Lval)
+	v.sval = av.Sval
+	v.dval = av.Dval
+	return tok
+}
 
-	for pass = 1; pass <= 2; pass++ {
-		asm.Pinit(file)
-		for i = 0; i < nDlist; i++ {
-			asm.Dodefine(Dlist[i])
-		}
-		yyparse()
-		cclean()
-		if Nerrors != 0 {
-			return Nerrors
-		}
-	}
+func (yy) Error(msg string) {
+	asm.Yyerror("%s", msg)
+}
 
-	obj.Writeobj(Ctxt, &obuf)
-	obj.Bflush(&obuf)
-	return 0
+func yyparse() {
+	yyParse(yy{})
 }
 
-var itab = []struct {
-	name  string
-	type_ uint16
-	value uint16
-}{
+var lexinit = []asm.Lextab{
 	{"SP", LSP, arm.D_AUTO},
 	{"SB", LSB, arm.D_EXTERN},
 	{"FP", LFP, arm.D_PARAM},
@@ -394,39 +298,17 @@ var itab = []struct {
 }
 
 func cinit() {
-	var s *Sym
-	var i int
-
-	Nullgen.Type_ = arm.D_NONE
-	Nullgen.Name = arm.D_NONE
-	Nullgen.Reg = arm.NREG
-
-	Nerrors = 0
-	Iostack = nil
-	Iofree = nil
-	Peekc = IGN
-	nhunk = 0
-	for i = 0; i < NHASH; i++ {
-		Hash[i] = nil
-	}
-	for i = 0; itab[i].name != ""; i++ {
-		s = asm.Slookup(itab[i].name)
-		s.Type_ = itab[i].type_
-		s.Value = int32(itab[i].value)
-	}
+	nullgen.Type_ = arm.D_NONE
+	nullgen.Name = arm.D_NONE
+	nullgen.Reg = arm.NREG
 }
 
-func Syminit(s *Sym) {
-	s.Type_ = LNAME
-	s.Value = 0
-}
-
-func isreg(g *obj.Addr) int {
-	return 1
+func isreg(g *obj.Addr) bool {
+	return true
 }
 
 func cclean() {
-	outcode(arm.AEND, Always, &Nullgen, arm.NREG, &Nullgen)
+	outcode(arm.AEND, Always, &nullgen, arm.NREG, &nullgen)
 }
 
 var bcode = []int{
@@ -450,42 +332,41 @@ var bcode = []int{
 
 var lastpc *obj.Prog
 
-func outcode(a int, scond int, g1 *obj.Addr, reg int, g2 *obj.Addr) {
+func outcode(a, scond int32, g1 *obj.Addr, reg int32, g2 *obj.Addr) {
 	var p *obj.Prog
 	var pl *obj.Plist
 
 	/* hack to make B.NE etc. work: turn it into the corresponding conditional */
 	if a == arm.AB {
-
-		a = bcode[scond&0xf]
-		scond = scond&^0xf | Always
+		a = int32(bcode[scond&0xf])
+		scond = (scond &^ 0xf) | Always
 	}
 
-	if pass == 1 {
+	if asm.Pass == 1 {
 		goto out
 	}
 
 	p = new(obj.Prog)
 	*p = obj.Prog{}
+	p.Ctxt = asm.Ctxt
 	p.As = int16(a)
 	p.Lineno = stmtline
 	p.Scond = uint8(scond)
 	p.From = *g1
 	p.Reg = uint8(reg)
 	p.To = *g2
-	p.Pc = int64(Pc)
+	p.Pc = int64(asm.PC)
 
 	if lastpc == nil {
-		pl = obj.Linknewplist(Ctxt)
+		pl = obj.Linknewplist(asm.Ctxt)
 		pl.Firstpc = p
 	} else {
-
 		lastpc.Link = p
 	}
 	lastpc = p
 
 out:
 	if a != arm.AGLOBL && a != arm.ADATA {
-		Pc++
+		asm.PC++
 	}
 }
diff --git a/src/cmd/new5a/y.go b/src/cmd/new5a/y.go
new file mode 100644
index 0000000000..b40c3bd883
--- /dev/null
+++ b/src/cmd/new5a/y.go
@@ -0,0 +1,1315 @@
+//line a.y:32
+package main
+
+import __yyfmt__ "fmt"
+
+//line a.y:32
+import (
+	"cmd/internal/asm"
+	"cmd/internal/obj"
+	. "cmd/internal/obj/arm"
+)
+
+//line a.y:41
+type yySymType struct {
+	yys  int
+	sym  *asm.Sym
+	lval int32
+	dval float64
+	sval string
+	addr obj.Addr
+}
+
+const LTYPE1 = 57346
+const LTYPE2 = 57347
+const LTYPE3 = 57348
+const LTYPE4 = 57349
+const LTYPE5 = 57350
+const LTYPE6 = 57351
+const LTYPE7 = 57352
+const LTYPE8 = 57353
+const LTYPE9 = 57354
+const LTYPEA = 57355
+const LTYPEB = 57356
+const LTYPEC = 57357
+const LTYPED = 57358
+const LTYPEE = 57359
+const LTYPEG = 57360
+const LTYPEH = 57361
+const LTYPEI = 57362
+const LTYPEJ = 57363
+const LTYPEK = 57364
+const LTYPEL = 57365
+const LTYPEM = 57366
+const LTYPEN = 57367
+const LTYPEBX = 57368
+const LTYPEPLD = 57369
+const LCONST = 57370
+const LSP = 57371
+const LSB = 57372
+const LFP = 57373
+const LPC = 57374
+const LTYPEX = 57375
+const LTYPEPC = 57376
+const LTYPEF = 57377
+const LR = 57378
+const LREG = 57379
+const LF = 57380
+const LFREG = 57381
+const LC = 57382
+const LCREG = 57383
+const LPSR = 57384
+const LFCR = 57385
+const LCOND = 57386
+const LS = 57387
+const LAT = 57388
+const LFCONST = 57389
+const LSCONST = 57390
+const LNAME = 57391
+const LLAB = 57392
+const LVAR = 57393
+
+var yyToknames = []string{
+	"'|'",
+	"'^'",
+	"'&'",
+	"'<'",
+	"'>'",
+	"'+'",
+	"'-'",
+	"'*'",
+	"'/'",
+	"'%'",
+	"LTYPE1",
+	"LTYPE2",
+	"LTYPE3",
+	"LTYPE4",
+	"LTYPE5",
+	"LTYPE6",
+	"LTYPE7",
+	"LTYPE8",
+	"LTYPE9",
+	"LTYPEA",
+	"LTYPEB",
+	"LTYPEC",
+	"LTYPED",
+	"LTYPEE",
+	"LTYPEG",
+	"LTYPEH",
+	"LTYPEI",
+	"LTYPEJ",
+	"LTYPEK",
+	"LTYPEL",
+	"LTYPEM",
+	"LTYPEN",
+	"LTYPEBX",
+	"LTYPEPLD",
+	"LCONST",
+	"LSP",
+	"LSB",
+	"LFP",
+	"LPC",
+	"LTYPEX",
+	"LTYPEPC",
+	"LTYPEF",
+	"LR",
+	"LREG",
+	"LF",
+	"LFREG",
+	"LC",
+	"LCREG",
+	"LPSR",
+	"LFCR",
+	"LCOND",
+	"LS",
+	"LAT",
+	"LFCONST",
+	"LSCONST",
+	"LNAME",
+	"LLAB",
+	"LVAR",
+}
+var yyStatenames = []string{}
+
+const yyEofCode = 1
+const yyErrCode = 2
+const yyMaxDepth = 200
+
+//line yacctab:1
+var yyExca = []int{
+	-1, 1,
+	1, -1,
+	-2, 2,
+	-1, 194,
+	67, 59,
+	-2, 48,
+}
+
+const yyNprod = 130
+const yyPrivate = 57344
+
+var yyTokenNames []string
+var yyStates []string
+
+const yyLast = 694
+
+var yyAct = []int{
+
+	123, 317, 71, 83, 98, 104, 200, 77, 82, 193,
+	89, 127, 271, 73, 113, 85, 3, 106, 227, 134,
+	327, 88, 87, 313, 76, 52, 52, 101, 102, 293,
+	283, 278, 84, 84, 270, 72, 81, 81, 70, 69,
+	84, 84, 84, 142, 269, 268, 81, 257, 84, 220,
+	114, 118, 323, 120, 310, 97, 99, 110, 75, 51,
+	60, 131, 132, 133, 103, 103, 294, 138, 140, 143,
+	137, 144, 103, 90, 121, 149, 92, 204, 111, 246,
+	93, 91, 112, 148, 195, 188, 136, 163, 101, 102,
+	156, 94, 145, 146, 157, 162, 43, 45, 151, 147,
+	108, 126, 302, 251, 106, 252, 62, 101, 102, 57,
+	56, 179, 149, 165, 184, 250, 95, 84, 44, 329,
+	194, 81, 322, 186, 182, 109, 320, 189, 316, 116,
+	199, 198, 122, 124, 206, 207, 197, 314, 54, 90,
+	209, 300, 92, 299, 44, 296, 93, 91, 187, 289,
+	286, 84, 222, 282, 260, 81, 256, 255, 218, 219,
+	44, 55, 217, 216, 215, 84, 131, 229, 59, 81,
+	214, 58, 212, 90, 211, 190, 92, 196, 192, 242,
+	93, 91, 84, 230, 191, 181, 81, 232, 233, 234,
+	235, 236, 249, 180, 239, 240, 241, 247, 178, 44,
+	164, 150, 125, 243, 86, 244, 219, 38, 37, 221,
+	254, 258, 34, 35, 36, 261, 262, 259, 264, 210,
+	57, 56, 228, 231, 272, 272, 272, 272, 273, 273,
+	273, 273, 72, 248, 213, 265, 277, 274, 275, 276,
+	245, 266, 267, 306, 57, 161, 158, 319, 318, 54,
+	135, 194, 305, 287, 194, 88, 87, 280, 281, 238,
+	285, 78, 292, 288, 226, 101, 102, 90, 295, 141,
+	92, 225, 55, 54, 93, 91, 224, 253, 100, 59,
+	291, 160, 58, 57, 56, 152, 153, 205, 154, 303,
+	237, 120, 160, 159, 53, 223, 55, 88, 263, 308,
+	307, 105, 105, 74, 129, 130, 58, 301, 7, 105,
+	312, 315, 54, 96, 304, 90, 2, 321, 92, 107,
+	1, 324, 93, 91, 325, 311, 117, 183, 101, 102,
+	101, 102, 284, 139, 155, 55, 309, 290, 8, 328,
+	119, 44, 74, 326, 0, 58, 0, 297, 0, 331,
+	9, 10, 11, 12, 14, 15, 16, 17, 18, 19,
+	20, 21, 22, 33, 0, 23, 24, 27, 25, 26,
+	28, 29, 13, 30, 57, 56, 202, 201, 203, 248,
+	31, 32, 176, 175, 174, 172, 173, 167, 168, 169,
+	170, 171, 88, 87, 0, 4, 0, 5, 101, 102,
+	6, 57, 56, 54, 90, 92, 0, 92, 0, 93,
+	91, 93, 91, 88, 87, 0, 0, 79, 80, 101,
+	102, 202, 201, 203, 53, 0, 55, 169, 170, 171,
+	54, 90, 0, 74, 92, 85, 58, 0, 93, 91,
+	88, 87, 0, 0, 79, 80, 128, 330, 129, 130,
+	0, 53, 0, 55, 0, 57, 56, 0, 0, 0,
+	74, 0, 85, 58, 176, 175, 174, 172, 173, 167,
+	168, 169, 170, 171, 176, 175, 174, 172, 173, 167,
+	168, 169, 170, 171, 54, 0, 57, 56, 0, 0,
+	57, 56, 0, 0, 57, 56, 202, 201, 203, 92,
+	0, 0, 0, 93, 91, 53, 0, 55, 57, 56,
+	0, 0, 57, 56, 74, 54, 0, 58, 0, 54,
+	0, 57, 56, 54, 0, 57, 56, 0, 0, 279,
+	0, 0, 0, 0, 228, 0, 0, 54, 55, 208,
+	0, 54, 55, 0, 185, 59, 55, 0, 58, 59,
+	54, 106, 58, 74, 54, 0, 58, 0, 115, 0,
+	55, 0, 53, 0, 55, 0, 0, 59, 0, 0,
+	58, 59, 0, 55, 58, 0, 0, 55, 0, 0,
+	59, 0, 0, 58, 74, 0, 0, 58, 176, 175,
+	174, 172, 173, 167, 168, 169, 170, 171, 176, 175,
+	174, 172, 173, 167, 168, 169, 170, 171, 176, 175,
+	174, 172, 173, 167, 168, 169, 170, 171, 90, 0,
+	0, 92, 0, 0, 0, 93, 91, 39, 167, 168,
+	169, 170, 171, 101, 102, 0, 0, 0, 40, 41,
+	42, 0, 0, 46, 47, 48, 49, 50, 0, 298,
+	61, 0, 63, 64, 65, 66, 67, 68, 177, 175,
+	174, 172, 173, 167, 168, 169, 170, 171, 166, 176,
+	175, 174, 172, 173, 167, 168, 169, 170, 171, 174,
+	172, 173, 167, 168, 169, 170, 171, 172, 173, 167,
+	168, 169, 170, 171,
+}
+var yyPact = []int{
+
+	-1000, -1000, 336, -1000, 150, 151, -1000, 144, 143, -1000,
+	-1000, -1000, -1000, 79, 79, -1000, -1000, -1000, -1000, -1000,
+	503, 503, -1000, 79, -1000, -1000, -1000, -1000, -1000, -1000,
+	446, 392, 392, 79, -1000, 512, 512, -1000, -1000, 34,
+	34, 365, 53, 10, 79, 499, 53, 34, 274, 276,
+	53, 137, 33, 439, -1000, -1000, 512, 512, 512, 512,
+	238, 579, -55, 344, -27, 344, 211, 579, 579, -1000,
+	31, -1000, 15, -1000, 100, 136, -1000, -1000, 30, -1000,
+	-1000, 15, -1000, -1000, 278, 235, -1000, -1000, 27, -1000,
+	-1000, -1000, -1000, 19, 135, -1000, 336, 604, -1000, 594,
+	133, -1000, -1000, -1000, -1000, -1000, 512, 128, 120, 485,
+	-1000, 228, -1000, -1000, 17, 295, 392, 119, 113, 228,
+	16, 112, 10, -1000, -1000, 481, 382, 9, 279, 512,
+	512, -1000, -1000, -1000, 470, 512, 79, -1000, 109, 107,
+	-1000, -1000, 224, 105, 99, 98, 97, 363, 457, -20,
+	392, 228, 288, 268, 263, 256, 15, -1000, -52, -1000,
+	-1000, 477, 512, 512, 392, -1000, -1000, 512, 512, 512,
+	512, 512, 283, 251, 512, 512, 512, -1000, 228, -1000,
+	228, 392, -1000, -1000, 11, 439, -1000, -1000, 191, -1000,
+	-1000, 228, 49, 36, 95, 363, 10, 92, -1000, 91,
+	-22, -1000, -1000, -1000, 382, 295, -1000, -1000, -1000, 89,
+	-1000, 207, 249, 165, 207, 512, 228, 228, -24, -25,
+	-1000, -1000, -35, 100, 100, 100, 100, 446, -1000, -38,
+	460, -1000, 416, 416, -1000, -1000, -1000, 512, 512, 680,
+	673, 654, 88, -1000, -1000, -1000, 337, 9, -39, 79,
+	228, 85, 228, 228, 84, 228, -53, -1000, -40, -2,
+	-55, -1000, -1000, 80, 79, 584, 78, 76, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	619, 619, 228, -1000, -1000, 35, 516, -1000, -1000, 134,
+	-1000, -1000, 242, -1000, 203, -1000, 207, -1000, 228, -14,
+	228, -1000, -1000, -1000, -1000, 512, -46, -1000, 72, -1000,
+	228, 63, -1000, -1000, 197, 61, 228, 57, -1000, -16,
+	228, -1000, 197, 512, -49, 54, 378, -1000, -1000, 512,
+	-1000, 665,
+}
+var yyPgo = []int{
+
+	0, 4, 19, 339, 6, 11, 10, 0, 1, 12,
+	627, 9, 58, 14, 24, 336, 3, 261, 204, 333,
+	5, 7, 38, 8, 13, 327, 2, 278, 320, 316,
+	16, 313, 308, 82,
+}
+var yyR1 = []int{
+
+	0, 28, 29, 28, 31, 30, 30, 30, 30, 30,
+	30, 32, 32, 32, 32, 32, 32, 32, 32, 32,
+	32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
+	32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
+	32, 32, 32, 32, 32, 10, 10, 10, 33, 33,
+	13, 13, 21, 21, 21, 21, 21, 18, 18, 11,
+	11, 11, 12, 12, 12, 12, 12, 12, 12, 12,
+	12, 25, 25, 24, 26, 26, 23, 23, 23, 27,
+	27, 27, 20, 14, 15, 17, 17, 17, 17, 9,
+	9, 6, 6, 6, 7, 7, 8, 8, 19, 19,
+	16, 16, 22, 22, 22, 5, 5, 5, 4, 4,
+	4, 1, 1, 1, 1, 1, 1, 3, 3, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+}
+var yyR2 = []int{
+
+	0, 0, 0, 3, 0, 4, 4, 4, 1, 2,
+	2, 7, 6, 5, 5, 5, 4, 4, 3, 3,
+	4, 6, 7, 7, 7, 6, 6, 3, 4, 6,
+	8, 6, 4, 3, 5, 5, 7, 6, 12, 7,
+	9, 2, 4, 4, 2, 0, 2, 2, 0, 2,
+	4, 2, 2, 2, 4, 2, 1, 2, 3, 1,
+	3, 3, 1, 1, 1, 4, 1, 1, 1, 1,
+	1, 1, 1, 3, 1, 4, 1, 4, 1, 1,
+	1, 1, 2, 1, 5, 4, 4, 4, 4, 1,
+	1, 1, 1, 4, 1, 1, 1, 4, 1, 1,
+	1, 4, 4, 5, 7, 0, 2, 2, 1, 1,
+	1, 1, 1, 2, 2, 2, 3, 0, 2, 1,
+	3, 3, 3, 3, 3, 4, 4, 3, 3, 3,
+}
+var yyChk = []int{
+
+	-1000, -28, -29, -30, 59, 61, 64, -32, 2, 14,
+	15, 16, 17, 36, 18, 19, 20, 21, 22, 23,
+	24, 25, 26, 29, 30, 32, 33, 31, 34, 35,
+	37, 44, 45, 27, 62, 63, 63, 64, 64, -10,
+	-10, -10, -10, -33, 65, -33, -10, -10, -10, -10,
+	-10, -22, -1, 59, 38, 61, 10, 9, 71, 68,
+	-22, -10, -33, -10, -10, -10, -10, -10, -10, -23,
+	-22, -26, -1, -24, 68, -12, -14, -21, -17, 52,
+	53, -1, -23, -16, -7, 70, -18, 49, 48, -6,
+	39, 47, 42, 46, -12, -33, -31, -2, -1, -2,
+	-27, 54, 55, -14, -20, -17, 70, -27, -12, -33,
+	-24, 68, -33, -13, -1, 59, -33, -27, -26, 66,
+	-1, -14, -33, -7, -33, 65, 68, -5, 7, 9,
+	10, -1, -1, -1, -2, 12, -14, -21, -16, -19,
+	-16, -18, 70, -16, -1, -14, -14, 68, 68, -7,
+	65, 68, 7, 8, 10, 56, -1, -23, 11, 58,
+	57, 10, 68, 68, 65, -30, 64, 9, 10, 11,
+	12, 13, 7, 8, 6, 5, 4, 64, 65, -1,
+	65, 65, -13, -25, -1, 59, -24, -22, 68, -5,
+	-12, 65, 65, -11, -7, 68, 65, -24, -20, -1,
+	-4, 40, 39, 41, 68, 8, -1, -1, 69, -1,
+	-33, 65, 65, 10, 65, 65, 65, 65, -6, -6,
+	69, -12, -7, 7, 8, 8, 8, 70, 57, -1,
+	-2, -12, -2, -2, -2, -2, -2, 7, 8, -2,
+	-2, -2, -7, -14, -14, -12, 68, -5, 42, -7,
+	66, 67, 10, -33, -24, 65, 65, 69, -4, -5,
+	65, -16, -16, 49, -16, -2, -14, -14, 69, 69,
+	69, -9, -7, -1, -9, -9, -9, -23, 69, 69,
+	-2, -2, 65, 69, -33, -11, 65, -7, -11, 65,
+	-33, -14, -20, 69, 68, -21, 65, -33, 65, 65,
+	65, -14, 67, -26, -14, 10, 40, -16, -7, -15,
+	68, -14, -1, 69, 65, -7, 65, -8, 51, 50,
+	65, -7, 65, 68, -7, -8, -2, 69, -3, 65,
+	69, -2,
+}
+var yyDef = []int{
+
+	1, -2, 0, 3, 0, 0, 8, 0, 0, 45,
+	45, 45, 45, 48, 48, 45, 45, 45, 45, 45,
+	0, 0, 45, 48, 45, 45, 45, 45, 45, 45,
+	0, 0, 0, 48, 4, 0, 0, 9, 10, 0,
+	0, 0, 48, 0, 48, 0, 48, 0, 0, 48,
+	48, 0, 0, 105, 111, 112, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 41,
+	76, 78, 0, 74, 0, 0, 62, 63, 64, 66,
+	67, 68, 69, 70, 83, 0, 56, 100, 0, 94,
+	95, 91, 92, 0, 0, 44, 0, 0, 119, 0,
+	0, 46, 47, 79, 80, 81, 0, 0, 0, 0,
+	18, 0, 49, 19, 0, 105, 0, 0, 0, 0,
+	0, 0, 0, 83, 27, 0, 0, 0, 0, 0,
+	0, 113, 114, 115, 0, 0, 48, 33, 0, 0,
+	98, 99, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 52, 53, 0, 55,
+	57, 0, 0, 0, 0, 5, 6, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 7, 0, 82,
+	0, 0, 16, 17, 0, 105, 71, 72, 0, 51,
+	20, 0, 0, 0, -2, 0, 0, 0, 28, 0,
+	0, 108, 109, 110, 0, 105, 106, 107, 116, 0,
+	32, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	73, 42, 0, 0, 0, 0, 0, 0, 58, 0,
+	0, 43, 120, 121, 122, 123, 124, 0, 0, 127,
+	128, 129, 83, 13, 14, 15, 0, 51, 0, 48,
+	0, 0, 0, 0, 48, 0, 0, 102, 0, 0,
+	0, 34, 35, 100, 48, 0, 0, 0, 77, 75,
+	65, 85, 89, 90, 86, 87, 88, 54, 101, 93,
+	125, 126, 12, 50, 21, 0, 0, 60, 61, 48,
+	25, 26, 29, 103, 0, 31, 0, 37, 0, 0,
+	0, 11, 22, 23, 24, 0, 0, 36, 0, 39,
+	0, 0, 30, 104, 0, 0, 0, 0, 96, 0,
+	0, 40, 0, 0, 0, 117, 0, 84, 38, 0,
+	97, 118,
+}
+var yyTok1 = []int{
+
+	1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 70, 13, 6, 3,
+	68, 69, 11, 9, 65, 10, 3, 12, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 62, 64,
+	7, 63, 8, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 66, 3, 67, 5, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 4, 3, 71,
+}
+var yyTok2 = []int{
+
+	2, 3, 14, 15, 16, 17, 18, 19, 20, 21,
+	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
+	42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
+	52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
+}
+var yyTok3 = []int{
+	0,
+}
+
+//line yaccpar:1
+
+/*	parser for yacc output	*/
+
+var yyDebug = 0
+
+type yyLexer interface {
+	Lex(lval *yySymType) int
+	Error(s string)
+}
+
+const yyFlag = -1000
+
+func yyTokname(c int) string {
+	// 4 is TOKSTART above
+	if c >= 4 && c-4 < len(yyToknames) {
+		if yyToknames[c-4] != "" {
+			return yyToknames[c-4]
+		}
+	}
+	return __yyfmt__.Sprintf("tok-%v", c)
+}
+
+func yyStatname(s int) string {
+	if s >= 0 && s < len(yyStatenames) {
+		if yyStatenames[s] != "" {
+			return yyStatenames[s]
+		}
+	}
+	return __yyfmt__.Sprintf("state-%v", s)
+}
+
+func yylex1(lex yyLexer, lval *yySymType) int {
+	c := 0
+	char := lex.Lex(lval)
+	if char <= 0 {
+		c = yyTok1[0]
+		goto out
+	}
+	if char < len(yyTok1) {
+		c = yyTok1[char]
+		goto out
+	}
+	if char >= yyPrivate {
+		if char < yyPrivate+len(yyTok2) {
+			c = yyTok2[char-yyPrivate]
+			goto out
+		}
+	}
+	for i := 0; i < len(yyTok3); i += 2 {
+		c = yyTok3[i+0]
+		if c == char {
+			c = yyTok3[i+1]
+			goto out
+		}
+	}
+
+out:
+	if c == 0 {
+		c = yyTok2[1] /* unknown char */
+	}
+	if yyDebug >= 3 {
+		__yyfmt__.Printf("lex %s(%d)\n", yyTokname(c), uint(char))
+	}
+	return c
+}
+
+func yyParse(yylex yyLexer) int {
+	var yyn int
+	var yylval yySymType
+	var yyVAL yySymType
+	yyS := make([]yySymType, yyMaxDepth)
+
+	Nerrs := 0   /* number of errors */
+	Errflag := 0 /* error recovery flag */
+	yystate := 0
+	yychar := -1
+	yyp := -1
+	goto yystack
+
+ret0:
+	return 0
+
+ret1:
+	return 1
+
+yystack:
+	/* put a state and value onto the stack */
+	if yyDebug >= 4 {
+		__yyfmt__.Printf("char %v in %v\n", yyTokname(yychar), yyStatname(yystate))
+	}
+
+	yyp++
+	if yyp >= len(yyS) {
+		nyys := make([]yySymType, len(yyS)*2)
+		copy(nyys, yyS)
+		yyS = nyys
+	}
+	yyS[yyp] = yyVAL
+	yyS[yyp].yys = yystate
+
+yynewstate:
+	yyn = yyPact[yystate]
+	if yyn <= yyFlag {
+		goto yydefault /* simple state */
+	}
+	if yychar < 0 {
+		yychar = yylex1(yylex, &yylval)
+	}
+	yyn += yychar
+	if yyn < 0 || yyn >= yyLast {
+		goto yydefault
+	}
+	yyn = yyAct[yyn]
+	if yyChk[yyn] == yychar { /* valid shift */
+		yychar = -1
+		yyVAL = yylval
+		yystate = yyn
+		if Errflag > 0 {
+			Errflag--
+		}
+		goto yystack
+	}
+
+yydefault:
+	/* default state action */
+	yyn = yyDef[yystate]
+	if yyn == -2 {
+		if yychar < 0 {
+			yychar = yylex1(yylex, &yylval)
+		}
+
+		/* look through exception table */
+		xi := 0
+		for {
+			if yyExca[xi+0] == -1 && yyExca[xi+1] == yystate {
+				break
+			}
+			xi += 2
+		}
+		for xi += 2; ; xi += 2 {
+			yyn = yyExca[xi+0]
+			if yyn < 0 || yyn == yychar {
+				break
+			}
+		}
+		yyn = yyExca[xi+1]
+		if yyn < 0 {
+			goto ret0
+		}
+	}
+	if yyn == 0 {
+		/* error ... attempt to resume parsing */
+		switch Errflag {
+		case 0: /* brand new error */
+			yylex.Error("syntax error")
+			Nerrs++
+			if yyDebug >= 1 {
+				__yyfmt__.Printf("%s", yyStatname(yystate))
+				__yyfmt__.Printf(" saw %s\n", yyTokname(yychar))
+			}
+			fallthrough
+
+		case 1, 2: /* incompletely recovered error ... try again */
+			Errflag = 3
+
+			/* find a state where "error" is a legal shift action */
+			for yyp >= 0 {
+				yyn = yyPact[yyS[yyp].yys] + yyErrCode
+				if yyn >= 0 && yyn < yyLast {
+					yystate = yyAct[yyn] /* simulate a shift of "error" */
+					if yyChk[yystate] == yyErrCode {
+						goto yystack
+					}
+				}
+
+				/* the current p has no shift on "error", pop stack */
+				if yyDebug >= 2 {
+					__yyfmt__.Printf("error recovery pops state %d\n", yyS[yyp].yys)
+				}
+				yyp--
+			}
+			/* there is no state on the stack with an error shift ... abort */
+			goto ret1
+
+		case 3: /* no shift yet; clobber input char */
+			if yyDebug >= 2 {
+				__yyfmt__.Printf("error recovery discards %s\n", yyTokname(yychar))
+			}
+			if yychar == yyEofCode {
+				goto ret1
+			}
+			yychar = -1
+			goto yynewstate /* try again in the same state */
+		}
+	}
+
+	/* reduction by production yyn */
+	if yyDebug >= 2 {
+		__yyfmt__.Printf("reduce %v in:\n\t%v\n", yyn, yyStatname(yystate))
+	}
+
+	yynt := yyn
+	yypt := yyp
+	_ = yypt // guard against "declared and not used"
+
+	yyp -= yyR2[yyn]
+	// yyp is now the index of $0. Perform the default action. Iff the
+	// reduced production is ε, $1 is possibly out of range.
+	if yyp+1 >= len(yyS) {
+		nyys := make([]yySymType, len(yyS)*2)
+		copy(nyys, yyS)
+		yyS = nyys
+	}
+	yyVAL = yyS[yyp+1]
+
+	/* consult goto table to find next state */
+	yyn = yyR1[yyn]
+	yyg := yyPgo[yyn]
+	yyj := yyg + yyS[yyp].yys + 1
+
+	if yyj >= yyLast {
+		yystate = yyAct[yyg]
+	} else {
+		yystate = yyAct[yyj]
+		if yyChk[yystate] != -yyn {
+			yystate = yyAct[yyg]
+		}
+	}
+	// dummy call; replaced with literal code
+	switch yynt {
+
+	case 2:
+		//line a.y:73
+		{
+			stmtline = asm.Lineno
+		}
+	case 4:
+		//line a.y:80
+		{
+			yyS[yypt-1].sym = asm.LabelLookup(yyS[yypt-1].sym)
+			if yyS[yypt-1].sym.Type == LLAB && yyS[yypt-1].sym.Value != int64(asm.PC) {
+				yyerror("redeclaration of %s", yyS[yypt-1].sym.Labelname)
+			}
+			yyS[yypt-1].sym.Type = LLAB
+			yyS[yypt-1].sym.Value = int64(asm.PC)
+		}
+	case 6:
+		//line a.y:90
+		{
+			yyS[yypt-3].sym.Type = LVAR
+			yyS[yypt-3].sym.Value = int64(yyS[yypt-1].lval)
+		}
+	case 7:
+		//line a.y:95
+		{
+			if yyS[yypt-3].sym.Value != int64(yyS[yypt-1].lval) {
+				yyerror("redeclaration of %s", yyS[yypt-3].sym.Name)
+			}
+			yyS[yypt-3].sym.Value = int64(yyS[yypt-1].lval)
+		}
+	case 11:
+		//line a.y:110
+		{
+			outcode(yyS[yypt-6].lval, yyS[yypt-5].lval, &yyS[yypt-4].addr, yyS[yypt-2].lval, &yyS[yypt-0].addr)
+		}
+	case 12:
+		//line a.y:114
+		{
+			outcode(yyS[yypt-5].lval, yyS[yypt-4].lval, &yyS[yypt-3].addr, yyS[yypt-1].lval, &nullgen)
+		}
+	case 13:
+		//line a.y:118
+		{
+			outcode(yyS[yypt-4].lval, yyS[yypt-3].lval, &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 14:
+		//line a.y:125
+		{
+			outcode(yyS[yypt-4].lval, yyS[yypt-3].lval, &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 15:
+		//line a.y:132
+		{
+			outcode(yyS[yypt-4].lval, yyS[yypt-3].lval, &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 16:
+		//line a.y:139
+		{
+			outcode(yyS[yypt-3].lval, yyS[yypt-2].lval, &nullgen, NREG, &yyS[yypt-0].addr)
+		}
+	case 17:
+		//line a.y:143
+		{
+			outcode(yyS[yypt-3].lval, yyS[yypt-2].lval, &nullgen, NREG, &yyS[yypt-0].addr)
+		}
+	case 18:
+		//line a.y:150
+		{
+			outcode(yyS[yypt-2].lval, Always, &nullgen, NREG, &yyS[yypt-0].addr)
+		}
+	case 19:
+		//line a.y:157
+		{
+			outcode(yyS[yypt-2].lval, Always, &nullgen, NREG, &yyS[yypt-0].addr)
+		}
+	case 20:
+		//line a.y:164
+		{
+			outcode(yyS[yypt-3].lval, yyS[yypt-2].lval, &nullgen, NREG, &yyS[yypt-0].addr)
+		}
+	case 21:
+		//line a.y:171
+		{
+			outcode(yyS[yypt-5].lval, yyS[yypt-4].lval, &yyS[yypt-3].addr, yyS[yypt-1].lval, &nullgen)
+		}
+	case 22:
+		//line a.y:178
+		{
+			var g obj.Addr
+
+			g = nullgen
+			g.Type_ = D_CONST
+			g.Offset = int64(yyS[yypt-1].lval)
+			outcode(yyS[yypt-6].lval, yyS[yypt-5].lval, &yyS[yypt-4].addr, NREG, &g)
+		}
+	case 23:
+		//line a.y:187
+		{
+			var g obj.Addr
+
+			g = nullgen
+			g.Type_ = D_CONST
+			g.Offset = int64(yyS[yypt-3].lval)
+			outcode(yyS[yypt-6].lval, yyS[yypt-5].lval, &g, NREG, &yyS[yypt-0].addr)
+		}
+	case 24:
+		//line a.y:199
+		{
+			outcode(yyS[yypt-6].lval, yyS[yypt-5].lval, &yyS[yypt-2].addr, int32(yyS[yypt-4].addr.Reg), &yyS[yypt-0].addr)
+		}
+	case 25:
+		//line a.y:203
+		{
+			outcode(yyS[yypt-5].lval, yyS[yypt-4].lval, &yyS[yypt-1].addr, int32(yyS[yypt-3].addr.Reg), &yyS[yypt-3].addr)
+		}
+	case 26:
+		//line a.y:207
+		{
+			outcode(yyS[yypt-5].lval, yyS[yypt-4].lval, &yyS[yypt-2].addr, int32(yyS[yypt-0].addr.Reg), &yyS[yypt-0].addr)
+		}
+	case 27:
+		//line a.y:214
+		{
+			outcode(yyS[yypt-2].lval, yyS[yypt-1].lval, &nullgen, NREG, &nullgen)
+		}
+	case 28:
+		//line a.y:221
+		{
+			asm.Settext(yyS[yypt-2].addr.Sym)
+			yyS[yypt-0].addr.Type_ = D_CONST2
+			yyS[yypt-0].addr.Offset2 = -obj.ArgsSizeUnknown
+			outcode(yyS[yypt-3].lval, Always, &yyS[yypt-2].addr, 0, &yyS[yypt-0].addr)
+		}
+	case 29:
+		//line a.y:228
+		{
+			asm.Settext(yyS[yypt-4].addr.Sym)
+			yyS[yypt-0].addr.Type_ = D_CONST2
+			yyS[yypt-0].addr.Offset2 = -obj.ArgsSizeUnknown
+			outcode(yyS[yypt-5].lval, Always, &yyS[yypt-4].addr, yyS[yypt-2].lval, &yyS[yypt-0].addr)
+		}
+	case 30:
+		//line a.y:235
+		{
+			asm.Settext(yyS[yypt-6].addr.Sym)
+			yyS[yypt-2].addr.Type_ = D_CONST2
+			yyS[yypt-2].addr.Offset2 = yyS[yypt-0].lval
+			outcode(yyS[yypt-7].lval, Always, &yyS[yypt-6].addr, yyS[yypt-4].lval, &yyS[yypt-2].addr)
+		}
+	case 31:
+		//line a.y:245
+		{
+			outcode(yyS[yypt-5].lval, Always, &yyS[yypt-4].addr, yyS[yypt-2].lval, &yyS[yypt-0].addr)
+		}
+	case 32:
+		//line a.y:252
+		{
+			outcode(yyS[yypt-3].lval, yyS[yypt-2].lval, &yyS[yypt-1].addr, NREG, &nullgen)
+		}
+	case 33:
+		//line a.y:259
+		{
+			outcode(yyS[yypt-2].lval, Always, &nullgen, NREG, &yyS[yypt-0].addr)
+		}
+	case 34:
+		//line a.y:266
+		{
+			outcode(yyS[yypt-4].lval, yyS[yypt-3].lval, &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 35:
+		//line a.y:270
+		{
+			outcode(yyS[yypt-4].lval, yyS[yypt-3].lval, &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 36:
+		//line a.y:274
+		{
+			outcode(yyS[yypt-6].lval, yyS[yypt-5].lval, &yyS[yypt-4].addr, yyS[yypt-2].lval, &yyS[yypt-0].addr)
+		}
+	case 37:
+		//line a.y:278
+		{
+			outcode(yyS[yypt-5].lval, yyS[yypt-4].lval, &yyS[yypt-3].addr, int32(yyS[yypt-1].addr.Reg), &nullgen)
+		}
+	case 38:
+		//line a.y:285
+		{
+			var g obj.Addr
+
+			g = nullgen
+			g.Type_ = D_CONST
+			g.Offset = int64(
+				(0xe << 24) | /* opcode */
+					(yyS[yypt-11].lval << 20) | /* MCR/MRC */
+					(yyS[yypt-10].lval << 28) | /* scond */
+					((yyS[yypt-9].lval & 15) << 8) | /* coprocessor number */
+					((yyS[yypt-7].lval & 7) << 21) | /* coprocessor operation */
+					((yyS[yypt-5].lval & 15) << 12) | /* arm register */
+					((yyS[yypt-3].lval & 15) << 16) | /* Crn */
+					((yyS[yypt-1].lval & 15) << 0) | /* Crm */
+					((yyS[yypt-0].lval & 7) << 5) | /* coprocessor information */
+					(1 << 4)) /* must be set */
+			outcode(AMRC, Always, &nullgen, NREG, &g)
+		}
+	case 39:
+		//line a.y:297
+		{
+			outcode(yyS[yypt-6].lval, yyS[yypt-5].lval, &yyS[yypt-4].addr, int32(yyS[yypt-2].addr.Reg), &yyS[yypt-0].addr)
+		}
+	case 40:
+		//line a.y:305
+		{
+			yyS[yypt-2].addr.Type_ = D_REGREG2
+			yyS[yypt-2].addr.Offset = int64(yyS[yypt-0].lval)
+			outcode(yyS[yypt-8].lval, yyS[yypt-7].lval, &yyS[yypt-6].addr, int32(yyS[yypt-4].addr.Reg), &yyS[yypt-2].addr)
+		}
+	case 41:
+		//line a.y:314
+		{
+			outcode(yyS[yypt-1].lval, Always, &yyS[yypt-0].addr, NREG, &nullgen)
+		}
+	case 42:
+		//line a.y:321
+		{
+			if yyS[yypt-2].addr.Type_ != D_CONST || yyS[yypt-0].addr.Type_ != D_CONST {
+				yyerror("arguments to PCDATA must be integer constants")
+			}
+			outcode(yyS[yypt-3].lval, Always, &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 43:
+		//line a.y:331
+		{
+			if yyS[yypt-2].addr.Type_ != D_CONST {
+				yyerror("index for FUNCDATA must be integer constant")
+			}
+			if yyS[yypt-0].addr.Type_ != D_EXTERN && yyS[yypt-0].addr.Type_ != D_STATIC && yyS[yypt-0].addr.Type_ != D_OREG {
+				yyerror("value for FUNCDATA must be symbol reference")
+			}
+			outcode(yyS[yypt-3].lval, Always, &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 44:
+		//line a.y:344
+		{
+			outcode(yyS[yypt-1].lval, Always, &nullgen, NREG, &nullgen)
+		}
+	case 45:
+		//line a.y:349
+		{
+			yyVAL.lval = Always
+		}
+	case 46:
+		//line a.y:353
+		{
+			yyVAL.lval = (yyS[yypt-1].lval & ^C_SCOND) | yyS[yypt-0].lval
+		}
+	case 47:
+		//line a.y:357
+		{
+			yyVAL.lval = yyS[yypt-1].lval | yyS[yypt-0].lval
+		}
+	case 50:
+		//line a.y:366
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_BRANCH
+			yyVAL.addr.Offset = int64(yyS[yypt-3].lval) + int64(asm.PC)
+		}
+	case 51:
+		//line a.y:372
+		{
+			yyS[yypt-1].sym = asm.LabelLookup(yyS[yypt-1].sym)
+			yyVAL.addr = nullgen
+			if asm.Pass == 2 && yyS[yypt-1].sym.Type != LLAB {
+				yyerror("undefined label: %s", yyS[yypt-1].sym.Labelname)
+			}
+			yyVAL.addr.Type_ = D_BRANCH
+			yyVAL.addr.Offset = yyS[yypt-1].sym.Value + int64(yyS[yypt-0].lval)
+		}
+	case 52:
+		//line a.y:383
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_CONST
+			yyVAL.addr.Offset = int64(yyS[yypt-0].lval)
+		}
+	case 53:
+		//line a.y:389
+		{
+			yyVAL.addr = yyS[yypt-0].addr
+			yyVAL.addr.Type_ = D_CONST
+		}
+	case 54:
+		//line a.y:394
+		{
+			yyVAL.addr = yyS[yypt-0].addr
+			yyVAL.addr.Type_ = D_OCONST
+		}
+	case 55:
+		//line a.y:399
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_SCONST
+			yyVAL.addr.U.Sval = yyS[yypt-0].sval
+		}
+	case 56:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 57:
+		//line a.y:408
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_FCONST
+			yyVAL.addr.U.Dval = yyS[yypt-0].dval
+		}
+	case 58:
+		//line a.y:414
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_FCONST
+			yyVAL.addr.U.Dval = -yyS[yypt-0].dval
+		}
+	case 59:
+		//line a.y:422
+		{
+			yyVAL.lval = 1 << uint(yyS[yypt-0].lval)
+		}
+	case 60:
+		//line a.y:426
+		{
+			yyVAL.lval = 0
+			for i := yyS[yypt-2].lval; i <= yyS[yypt-0].lval; i++ {
+				yyVAL.lval |= 1 << uint(i)
+			}
+			for i := yyS[yypt-0].lval; i <= yyS[yypt-2].lval; i++ {
+				yyVAL.lval |= 1 << uint(i)
+			}
+		}
+	case 61:
+		//line a.y:436
+		{
+			yyVAL.lval = (1 << uint(yyS[yypt-2].lval)) | yyS[yypt-0].lval
+		}
+	case 62:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 63:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 64:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 65:
+		//line a.y:445
+		{
+			yyVAL.addr = yyS[yypt-3].addr
+			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
+		}
+	case 66:
+		//line a.y:450
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_PSR
+			yyVAL.addr.Reg = int8(yyS[yypt-0].lval)
+		}
+	case 67:
+		//line a.y:456
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_FPCR
+			yyVAL.addr.Reg = int8(yyS[yypt-0].lval)
+		}
+	case 68:
+		//line a.y:462
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Offset = int64(yyS[yypt-0].lval)
+		}
+	case 69:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 70:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 71:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 72:
+		//line a.y:473
+		{
+			yyVAL.addr = yyS[yypt-0].addr
+			if yyS[yypt-0].addr.Name != D_EXTERN && yyS[yypt-0].addr.Name != D_STATIC {
+			}
+		}
+	case 73:
+		//line a.y:481
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
+			yyVAL.addr.Offset = 0
+		}
+	case 74:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 75:
+		//line a.y:491
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
+			yyVAL.addr.Offset = int64(yyS[yypt-3].lval)
+		}
+	case 76:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 77:
+		//line a.y:501
+		{
+			yyVAL.addr = yyS[yypt-3].addr
+			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
+		}
+	case 78:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 79:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 80:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 81:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 82:
+		//line a.y:514
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_CONST
+			yyVAL.addr.Offset = int64(yyS[yypt-0].lval)
+		}
+	case 83:
+		//line a.y:522
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_REG
+			yyVAL.addr.Reg = int8(yyS[yypt-0].lval)
+		}
+	case 84:
+		//line a.y:530
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_REGREG
+			yyVAL.addr.Reg = int8(yyS[yypt-3].lval)
+			yyVAL.addr.Offset = int64(yyS[yypt-1].lval)
+		}
+	case 85:
+		//line a.y:539
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_SHIFT
+			yyVAL.addr.Offset = int64(yyS[yypt-3].lval) | int64(yyS[yypt-0].lval) | (0 << 5)
+		}
+	case 86:
+		//line a.y:545
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_SHIFT
+			yyVAL.addr.Offset = int64(yyS[yypt-3].lval) | int64(yyS[yypt-0].lval) | (1 << 5)
+		}
+	case 87:
+		//line a.y:551
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_SHIFT
+			yyVAL.addr.Offset = int64(yyS[yypt-3].lval) | int64(yyS[yypt-0].lval) | (2 << 5)
+		}
+	case 88:
+		//line a.y:557
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_SHIFT
+			yyVAL.addr.Offset = int64(yyS[yypt-3].lval) | int64(yyS[yypt-0].lval) | (3 << 5)
+		}
+	case 89:
+		//line a.y:565
+		{
+			if yyVAL.lval < 0 || yyVAL.lval >= 16 {
+				print("register value out of range\n")
+			}
+			yyVAL.lval = ((yyS[yypt-0].lval & 15) << 8) | (1 << 4)
+		}
+	case 90:
+		//line a.y:572
+		{
+			if yyVAL.lval < 0 || yyVAL.lval >= 32 {
+				print("shift value out of range\n")
+			}
+			yyVAL.lval = (yyS[yypt-0].lval & 31) << 7
+		}
+	case 91:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 92:
+		//line a.y:582
+		{
+			yyVAL.lval = REGPC
+		}
+	case 93:
+		//line a.y:586
+		{
+			if yyS[yypt-1].lval < 0 || yyS[yypt-1].lval >= NREG {
+				print("register value out of range\n")
+			}
+			yyVAL.lval = yyS[yypt-1].lval
+		}
+	case 94:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 95:
+		//line a.y:596
+		{
+			yyVAL.lval = REGSP
+		}
+	case 96:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 97:
+		//line a.y:603
+		{
+			if yyS[yypt-1].lval < 0 || yyS[yypt-1].lval >= NREG {
+				print("register value out of range\n")
+			}
+			yyVAL.lval = yyS[yypt-1].lval
+		}
+	case 98:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 99:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 100:
+		//line a.y:616
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_FREG
+			yyVAL.addr.Reg = int8(yyS[yypt-0].lval)
+		}
+	case 101:
+		//line a.y:622
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_FREG
+			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
+		}
+	case 102:
+		//line a.y:630
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Name = int8(yyS[yypt-1].lval)
+			yyVAL.addr.Sym = nil
+			yyVAL.addr.Offset = int64(yyS[yypt-3].lval)
+		}
+	case 103:
+		//line a.y:638
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Name = int8(yyS[yypt-1].lval)
+			yyVAL.addr.Sym = obj.Linklookup(asm.Ctxt, yyS[yypt-4].sym.Name, 0)
+			yyVAL.addr.Offset = int64(yyS[yypt-3].lval)
+		}
+	case 104:
+		//line a.y:646
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Name = D_STATIC
+			yyVAL.addr.Sym = obj.Linklookup(asm.Ctxt, yyS[yypt-6].sym.Name, 1)
+			yyVAL.addr.Offset = int64(yyS[yypt-3].lval)
+		}
+	case 105:
+		//line a.y:655
+		{
+			yyVAL.lval = 0
+		}
+	case 106:
+		//line a.y:659
+		{
+			yyVAL.lval = yyS[yypt-0].lval
+		}
+	case 107:
+		//line a.y:663
+		{
+			yyVAL.lval = -yyS[yypt-0].lval
+		}
+	case 108:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 109:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 110:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 111:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 112:
+		//line a.y:675
+		{
+			yyVAL.lval = int32(yyS[yypt-0].sym.Value)
+		}
+	case 113:
+		//line a.y:679
+		{
+			yyVAL.lval = -yyS[yypt-0].lval
+		}
+	case 114:
+		//line a.y:683
+		{
+			yyVAL.lval = yyS[yypt-0].lval
+		}
+	case 115:
+		//line a.y:687
+		{
+			yyVAL.lval = ^yyS[yypt-0].lval
+		}
+	case 116:
+		//line a.y:691
+		{
+			yyVAL.lval = yyS[yypt-1].lval
+		}
+	case 117:
+		//line a.y:696
+		{
+			yyVAL.lval = 0
+		}
+	case 118:
+		//line a.y:700
+		{
+			yyVAL.lval = yyS[yypt-0].lval
+		}
+	case 119:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 120:
+		//line a.y:707
+		{
+			yyVAL.lval = yyS[yypt-2].lval + yyS[yypt-0].lval
+		}
+	case 121:
+		//line a.y:711
+		{
+			yyVAL.lval = yyS[yypt-2].lval - yyS[yypt-0].lval
+		}
+	case 122:
+		//line a.y:715
+		{
+			yyVAL.lval = yyS[yypt-2].lval * yyS[yypt-0].lval
+		}
+	case 123:
+		//line a.y:719
+		{
+			yyVAL.lval = yyS[yypt-2].lval / yyS[yypt-0].lval
+		}
+	case 124:
+		//line a.y:723
+		{
+			yyVAL.lval = yyS[yypt-2].lval % yyS[yypt-0].lval
+		}
+	case 125:
+		//line a.y:727
+		{
+			yyVAL.lval = yyS[yypt-3].lval << uint(yyS[yypt-0].lval)
+		}
+	case 126:
+		//line a.y:731
+		{
+			yyVAL.lval = yyS[yypt-3].lval >> uint(yyS[yypt-0].lval)
+		}
+	case 127:
+		//line a.y:735
+		{
+			yyVAL.lval = yyS[yypt-2].lval & yyS[yypt-0].lval
+		}
+	case 128:
+		//line a.y:739
+		{
+			yyVAL.lval = yyS[yypt-2].lval ^ yyS[yypt-0].lval
+		}
+	case 129:
+		//line a.y:743
+		{
+			yyVAL.lval = yyS[yypt-2].lval | yyS[yypt-0].lval
+		}
+	}
+	goto yystack /* stack new state and value */
+}
diff --git a/src/cmd/new6a/a.y b/src/cmd/new6a/a.y
index 29011c7ffb..f9217a00cd 100644
--- a/src/cmd/new6a/a.y
+++ b/src/cmd/new6a/a.y
@@ -29,20 +29,24 @@
 // THE SOFTWARE.
 
 %{
-#include <u.h>
-#include <stdio.h>	/* if we don't, bison will, and a.h re-#defines getc */
-#include <libc.h>
-#include "a.h"
-#include "../../runtime/funcdata.h"
+package main
+
+import (
+	"cmd/internal/asm"
+	"cmd/internal/obj"
+	"cmd/internal/obj/x86"
+)
 %}
-%union	{
-	Sym	*sym;
-	vlong	lval;
-	double	dval;
-	char	sval[8];
-	Addr	addr;
-	Addr2	addr2;
+
+%union {
+	sym *asm.Sym
+	lval int64
+	dval float64
+	sval string
+	addr obj.Addr
+	addr2 Addr2
 }
+
 %left	'|'
 %left	'^'
 %left	'&'
@@ -66,18 +70,19 @@
 prog:
 |	prog 
 	{
-		stmtline = lineno;
+		stmtline = asm.Lineno;
 	}
 	line
 
 line:
 	LNAME ':'
 	{
-		$1 = labellookup($1);
-		if($1->type == LLAB && $1->value != pc)
-			yyerror("redeclaration of %s (%s)", $1->labelname, $1->name);
-		$1->type = LLAB;
-		$1->value = pc;
+		$1 = asm.LabelLookup($1);
+		if $1.Type == LLAB && $1.Value != int64(asm.PC) {
+			yyerror("redeclaration of %s (%s)", $1.Labelname, $1.Name);
+		}
+		$1.Type = LLAB;
+		$1.Value = int64(asm.PC)
 	}
 	line
 |	';'
@@ -87,34 +92,35 @@ line:
 inst:
 	LNAME '=' expr
 	{
-		$1->type = LVAR;
-		$1->value = $3;
+		$1.Type = LVAR;
+		$1.Value = $3;
 	}
 |	LVAR '=' expr
 	{
-		if($1->value != $3)
-			yyerror("redeclaration of %s", $1->name);
-		$1->value = $3;
-	}
-|	LTYPE0 nonnon	{ outcode($1, &$2); }
-|	LTYPE1 nonrem	{ outcode($1, &$2); }
-|	LTYPE2 rimnon	{ outcode($1, &$2); }
-|	LTYPE3 rimrem	{ outcode($1, &$2); }
-|	LTYPE4 remrim	{ outcode($1, &$2); }
-|	LTYPER nonrel	{ outcode($1, &$2); }
-|	LTYPED spec1	{ outcode($1, &$2); }
-|	LTYPET spec2	{ outcode($1, &$2); }
-|	LTYPEC spec3	{ outcode($1, &$2); }
-|	LTYPEN spec4	{ outcode($1, &$2); }
-|	LTYPES spec5	{ outcode($1, &$2); }
-|	LTYPEM spec6	{ outcode($1, &$2); }
-|	LTYPEI spec7	{ outcode($1, &$2); }
-|	LTYPEXC spec8	{ outcode($1, &$2); }
-|	LTYPEX spec9	{ outcode($1, &$2); }
-|	LTYPERT spec10	{ outcode($1, &$2); }
-|	LTYPEG spec11	{ outcode($1, &$2); }
-|	LTYPEPC spec12	{ outcode($1, &$2); }
-|	LTYPEF spec13	{ outcode($1, &$2); }
+		if $1.Value != $3 {
+			yyerror("redeclaration of %s", $1.Name);
+		}
+		$1.Value = $3;
+	}
+|	LTYPE0 nonnon	{ outcode(int($1), &$2); }
+|	LTYPE1 nonrem	{ outcode(int($1), &$2); }
+|	LTYPE2 rimnon	{ outcode(int($1), &$2); }
+|	LTYPE3 rimrem	{ outcode(int($1), &$2); }
+|	LTYPE4 remrim	{ outcode(int($1), &$2); }
+|	LTYPER nonrel	{ outcode(int($1), &$2); }
+|	LTYPED spec1	{ outcode(int($1), &$2); }
+|	LTYPET spec2	{ outcode(int($1), &$2); }
+|	LTYPEC spec3	{ outcode(int($1), &$2); }
+|	LTYPEN spec4	{ outcode(int($1), &$2); }
+|	LTYPES spec5	{ outcode(int($1), &$2); }
+|	LTYPEM spec6	{ outcode(int($1), &$2); }
+|	LTYPEI spec7	{ outcode(int($1), &$2); }
+|	LTYPEXC spec8	{ outcode(int($1), &$2); }
+|	LTYPEX spec9	{ outcode(int($1), &$2); }
+|	LTYPERT spec10	{ outcode(int($1), &$2); }
+|	LTYPEG spec11	{ outcode(int($1), &$2); }
+|	LTYPEPC spec12	{ outcode(int($1), &$2); }
+|	LTYPEF spec13	{ outcode(int($1), &$2); }
 
 nonnon:
 	{
@@ -186,22 +192,22 @@ spec1:	/* DATA */
 	nam '/' con ',' imm
 	{
 		$$.from = $1;
-		$$.from.scale = $3;
+		$$.from.Scale = int8($3);
 		$$.to = $5;
 	}
 
 spec2:	/* TEXT */
 	mem ',' imm2
 	{
-		settext($1.sym);
+		asm.Settext($1.Sym);
 		$$.from = $1;
 		$$.to = $3;
 	}
 |	mem ',' con ',' imm2
 	{
-		settext($1.sym);
+		asm.Settext($1.Sym);
 		$$.from = $1;
-		$$.from.scale = $3;
+		$$.from.Scale = int8($3);
 		$$.to = $5;
 	}
 
@@ -231,9 +237,10 @@ spec5:	/* SHL/SHR */
 	{
 		$$.from = $1;
 		$$.to = $3;
-		if($$.from.index != D_NONE)
+		if $$.from.Index != x86.D_NONE {
 			yyerror("dp shift with lhs index");
-		$$.from.index = $5;
+		}
+		$$.from.Index = uint8($5);
 	}
 
 spec6:	/* MOVW/MOVL */
@@ -246,9 +253,10 @@ spec6:	/* MOVW/MOVL */
 	{
 		$$.from = $1;
 		$$.to = $3;
-		if($$.to.index != D_NONE)
+		if $$.to.Index != x86.D_NONE {
 			yyerror("dp move with lhs index");
-		$$.to.index = $5;
+		}
+		$$.to.Index = uint8($5);
 	}
 
 spec7:
@@ -273,7 +281,7 @@ spec8:	/* CMPPS/CMPPD */
 	{
 		$$.from = $1;
 		$$.to = $3;
-		$$.to.offset = $5;
+		$$.to.Offset = $5;
 	}
 
 spec9:	/* shufl */
@@ -281,9 +289,10 @@ spec9:	/* shufl */
 	{
 		$$.from = $3;
 		$$.to = $5;
-		if($1.type != D_CONST)
+		if $1.Type_ != x86.D_CONST {
 			yyerror("illegal constant");
-		$$.to.offset = $1.offset;
+		}
+		$$.to.Offset = $1.Offset;
 	}
 
 spec10:	/* RET/RETF */
@@ -306,15 +315,16 @@ spec11:	/* GLOBL */
 |	mem ',' con ',' imm
 	{
 		$$.from = $1;
-		$$.from.scale = $3;
+		$$.from.Scale = int8($3);
 		$$.to = $5;
 	}
 
-spec12:	/* PCDATA */
+spec12:	/* asm.PCDATA */
 	rim ',' rim
 	{
-		if($1.type != D_CONST || $3.type != D_CONST)
-			yyerror("arguments to PCDATA must be integer constants");
+		if $1.Type_ != x86.D_CONST || $3.Type_ != x86.D_CONST {
+			yyerror("arguments to asm.PCDATA must be integer constants");
+		}
 		$$.from = $1;
 		$$.to = $3;
 	}
@@ -322,10 +332,12 @@ spec12:	/* PCDATA */
 spec13:	/* FUNCDATA */
 	rim ',' rim
 	{
-		if($1.type != D_CONST)
+		if $1.Type_ != x86.D_CONST {
 			yyerror("index for FUNCDATA must be integer constant");
-		if($3.type != D_EXTERN && $3.type != D_STATIC)
+		}
+		if $3.Type_ != x86.D_EXTERN && $3.Type_ != x86.D_STATIC {
 			yyerror("value for FUNCDATA must be symbol reference");
+		}
 		$$.from = $1;
 		$$.to = $3;
 	}
@@ -356,110 +368,111 @@ rel:
 	con '(' LPC ')'
 	{
 		$$ = nullgen;
-		$$.type = D_BRANCH;
-		$$.offset = $1 + pc;
+		$$.Type_ = x86.D_BRANCH;
+		$$.Offset = $1 + int64(asm.PC);
 	}
 |	LNAME offset
 	{
-		$1 = labellookup($1);
+		$1 = asm.LabelLookup($1);
 		$$ = nullgen;
-		if(pass == 2 && $1->type != LLAB)
-			yyerror("undefined label: %s", $1->labelname);
-		$$.type = D_BRANCH;
-		$$.offset = $1->value + $2;
+		if asm.Pass == 2 && $1.Type != LLAB {
+			yyerror("undefined label: %s", $1.Labelname);
+		}
+		$$.Type_ = x86.D_BRANCH;
+		$$.Offset = $1.Value + $2;
 	}
 
 reg:
 	LBREG
 	{
 		$$ = nullgen;
-		$$.type = $1;
+		$$.Type_ = int16($1);
 	}
 |	LFREG
 	{
 		$$ = nullgen;
-		$$.type = $1;
+		$$.Type_ = int16($1);
 	}
 |	LLREG
 	{
 		$$ = nullgen;
-		$$.type = $1;
+		$$.Type_ = int16($1);
 	}
 |	LMREG
 	{
 		$$ = nullgen;
-		$$.type = $1;
+		$$.Type_ = int16($1);
 	}
 |	LSP
 	{
 		$$ = nullgen;
-		$$.type = D_SP;
+		$$.Type_ = x86.D_SP;
 	}
 |	LSREG
 	{
 		$$ = nullgen;
-		$$.type = $1;
+		$$.Type_ = int16($1);
 	}
 |	LXREG
 	{
 		$$ = nullgen;
-		$$.type = $1;
+		$$.Type_ = int16($1);
 	}
 imm2:
 	'$' con2
 	{
 		$$ = nullgen;
-		$$.type = D_CONST;
-		$$.offset = $2;
+		$$.Type_ = x86.D_CONST;
+		$$.Offset = $2;
 	}
 
 imm:
 	'$' con
 	{
 		$$ = nullgen;
-		$$.type = D_CONST;
-		$$.offset = $2;
+		$$.Type_ = x86.D_CONST;
+		$$.Offset = $2;
 	}
 |	'$' nam
 	{
 		$$ = $2;
-		$$.index = $2.type;
-		$$.type = D_ADDR;
+		$$.Index = uint8($2.Type_);
+		$$.Type_ = x86.D_ADDR;
 		/*
-		if($2.type == D_AUTO || $2.type == D_PARAM)
+		if($2.Type_ == x86.D_AUTO || $2.Type_ == x86.D_PARAM)
 			yyerror("constant cannot be automatic: %s",
-				$2.sym->name);
+				$2.sym.Name);
 		 */
 	}
 |	'$' LSCONST
 	{
 		$$ = nullgen;
-		$$.type = D_SCONST;
-		memcpy($$.u.sval, $2, sizeof($$.u.sval));
+		$$.Type_ = x86.D_SCONST;
+		$$.U.Sval = ($2+"\x00\x00\x00\x00\x00\x00\x00\x00")[:8]
 	}
 |	'$' LFCONST
 	{
 		$$ = nullgen;
-		$$.type = D_FCONST;
-		$$.u.dval = $2;
+		$$.Type_ = x86.D_FCONST;
+		$$.U.Dval = $2;
 	}
 |	'$' '(' LFCONST ')'
 	{
 		$$ = nullgen;
-		$$.type = D_FCONST;
-		$$.u.dval = $3;
+		$$.Type_ = x86.D_FCONST;
+		$$.U.Dval = $3;
 	}
 |	'$' '(' '-' LFCONST ')'
 	{
 		$$ = nullgen;
-		$$.type = D_FCONST;
-		$$.u.dval = -$4;
+		$$.Type_ = x86.D_FCONST;
+		$$.U.Dval = -$4;
 	}
 |	'$' '-' LFCONST
 	{
 		$$ = nullgen;
-		$$.type = D_FCONST;
-		$$.u.dval = -$3;
+		$$.Type_ = x86.D_FCONST;
+		$$.U.Dval = -$3;
 	}
 
 mem:
@@ -470,79 +483,79 @@ omem:
 	con
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+D_NONE;
-		$$.offset = $1;
+		$$.Type_ = x86.D_INDIR+x86.D_NONE;
+		$$.Offset = $1;
 	}
 |	con '(' LLREG ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+$3;
-		$$.offset = $1;
+		$$.Type_ = int16(x86.D_INDIR+$3);
+		$$.Offset = $1;
 	}
 |	con '(' LSP ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+D_SP;
-		$$.offset = $1;
+		$$.Type_ = int16(x86.D_INDIR+x86.D_SP);
+		$$.Offset = $1;
 	}
 |	con '(' LSREG ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+$3;
-		$$.offset = $1;
+		$$.Type_ = int16(x86.D_INDIR+$3);
+		$$.Offset = $1;
 	}
 |	con '(' LLREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+D_NONE;
-		$$.offset = $1;
-		$$.index = $3;
-		$$.scale = $5;
-		checkscale($$.scale);
+		$$.Type_ = int16(x86.D_INDIR+x86.D_NONE);
+		$$.Offset = $1;
+		$$.Index = uint8($3);
+		$$.Scale = int8($5);
+		checkscale($$.Scale);
 	}
 |	con '(' LLREG ')' '(' LLREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+$3;
-		$$.offset = $1;
-		$$.index = $6;
-		$$.scale = $8;
-		checkscale($$.scale);
+		$$.Type_ = int16(x86.D_INDIR+$3);
+		$$.Offset = $1;
+		$$.Index = uint8($6);
+		$$.Scale = int8($8);
+		checkscale($$.Scale);
 	}
 |	con '(' LLREG ')' '(' LSREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+$3;
-		$$.offset = $1;
-		$$.index = $6;
-		$$.scale = $8;
-		checkscale($$.scale);
+		$$.Type_ = int16(x86.D_INDIR+$3);
+		$$.Offset = $1;
+		$$.Index = uint8($6);
+		$$.Scale = int8($8);
+		checkscale($$.Scale);
 	}
 |	'(' LLREG ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+$2;
+		$$.Type_ = int16(x86.D_INDIR+$2);
 	}
 |	'(' LSP ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+D_SP;
+		$$.Type_ = int16(x86.D_INDIR+x86.D_SP);
 	}
 |	'(' LLREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+D_NONE;
-		$$.index = $2;
-		$$.scale = $4;
-		checkscale($$.scale);
+		$$.Type_ = int16(x86.D_INDIR+x86.D_NONE);
+		$$.Index = uint8($2);
+		$$.Scale = int8($4);
+		checkscale($$.Scale);
 	}
 |	'(' LLREG ')' '(' LLREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+$2;
-		$$.index = $5;
-		$$.scale = $7;
-		checkscale($$.scale);
+		$$.Type_ = int16(x86.D_INDIR+$2);
+		$$.Index = uint8($5);
+		$$.Scale = int8($7);
+		checkscale($$.Scale);
 	}
 
 nmem:
@@ -553,25 +566,25 @@ nmem:
 |	nam '(' LLREG '*' con ')'
 	{
 		$$ = $1;
-		$$.index = $3;
-		$$.scale = $5;
-		checkscale($$.scale);
+		$$.Index = uint8($3);
+		$$.Scale = int8($5);
+		checkscale($$.Scale);
 	}
 
 nam:
 	LNAME offset '(' pointer ')'
 	{
 		$$ = nullgen;
-		$$.type = $4;
-		$$.sym = linklookup(ctxt, $1->name, 0);
-		$$.offset = $2;
+		$$.Type_ = int16($4);
+		$$.Sym = obj.Linklookup(asm.Ctxt, $1.Name, 0);
+		$$.Offset = $2;
 	}
 |	LNAME '<' '>' offset '(' LSB ')'
 	{
 		$$ = nullgen;
-		$$.type = D_STATIC;
-		$$.sym = linklookup(ctxt, $1->name, 1);
-		$$.offset = $4;
+		$$.Type_ = x86.D_STATIC;
+		$$.Sym = obj.Linklookup(asm.Ctxt, $1.Name, 1);
+		$$.Offset = $4;
 	}
 
 offset:
@@ -591,7 +604,7 @@ pointer:
 	LSB
 |	LSP
 	{
-		$$ = D_AUTO;
+		$$ = x86.D_AUTO;
 	}
 |	LFP
 
@@ -599,7 +612,7 @@ con:
 	LCONST
 |	LVAR
 	{
-		$$ = $1->value;
+		$$ = $1.Value;
 	}
 |	'-' con
 	{
@@ -611,7 +624,7 @@ con:
 	}
 |	'~' con
 	{
-		$$ = ~$2;
+		$$ = ^$2;
 	}
 |	'(' expr ')'
 	{
@@ -621,23 +634,19 @@ con:
 con2:
 	LCONST
 	{
-		$$ = ($1 & 0xffffffffLL) +
-			((vlong)ArgsSizeUnknown << 32);
+		$$ = int64(uint64($1 & 0xffffffff) + (obj.ArgsSizeUnknown<<32))
 	}
 |	'-' LCONST
 	{
-		$$ = (-$2 & 0xffffffffLL) +
-			((vlong)ArgsSizeUnknown << 32);
+		$$ = int64(uint64(-$2 & 0xffffffff) + (obj.ArgsSizeUnknown<<32))
 	}
 |	LCONST '-' LCONST
 	{
-		$$ = ($1 & 0xffffffffLL) +
-			(($3 & 0xffffLL) << 32);
+		$$ = ($1 & 0xffffffff) + (($3 & 0xffff) << 32);
 	}
 |	'-' LCONST '-' LCONST
 	{
-		$$ = (-$2 & 0xffffffffLL) +
-			(($4 & 0xffffLL) << 32);
+		$$ = (-$2 & 0xffffffff) + (($4 & 0xffff) << 32);
 	}
 
 expr:
@@ -664,11 +673,11 @@ expr:
 	}
 |	expr '<' '<' expr
 	{
-		$$ = $1 << $4;
+		$$ = $1 << uint($4);
 	}
 |	expr '>' '>' expr
 	{
-		$$ = $1 >> $4;
+		$$ = $1 >> uint($4);
 	}
 |	expr '&' expr
 	{
diff --git a/src/cmd/new6a/lex.go b/src/cmd/new6a/lex.go
index 264c119f3d..4a61f63195 100644
--- a/src/cmd/new6a/lex.go
+++ b/src/cmd/new6a/lex.go
@@ -28,171 +28,67 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+//go:generate go tool yacc a.y
+
 package main
 
-const (
-	Plan9   = 1 << 0
-	Unix    = 1 << 1
-	Windows = 1 << 2
+import (
+	"cmd/internal/asm"
+	"cmd/internal/obj"
+	"cmd/internal/obj/x86"
 )
 
-func systemtype(sys int) int {
-	return sys & Windows
-
-	return sys & Plan9
-}
-
-func pathchar() int {
-	return '/'
-}
+var (
+	yyerror  = asm.Yyerror
+	nullgen  obj.Addr
+	stmtline int32
+)
 
-func Lconv(fp *obj.Fmt) int {
-	return obj.Linklinefmt(ctxt, fp)
-}
+func main() {
+	cinit()
 
-func dodef(p string) {
-	if nDlist%8 == 0 {
-		Dlist = allocn(Dlist, nDlist*sizeof(string), 8*sizeof(string)).(*string)
+	asm.LSCONST = LSCONST
+	asm.LCONST = LCONST
+	asm.LFCONST = LFCONST
+	asm.LNAME = LNAME
+	asm.LVAR = LVAR
+	asm.LLAB = LLAB
+
+	asm.Thechar = '6'
+	asm.Thestring = "amd64"
+	asm.Thelinkarch = &x86.Linkamd64
+	asm.Arches = map[string]*obj.LinkArch{
+		"amd64p32": &x86.Linkamd64p32,
 	}
-	Dlist[nDlist] = p
-	nDlist++
-}
 
-var thelinkarch *obj.LinkArch = &x86.Linkamd64
+	asm.Lexinit = lexinit
+	asm.Cclean = cclean
+	asm.Yyparse = yyparse
 
-func usage() {
-	fmt.Printf("usage: %ca [options] file.c...\n", thechar)
-	main.Flagprint(1)
-	errorexit()
+	asm.Main()
 }
 
-func main(argc int, argv [XXX]string) {
-	var p string
-
-	thechar = '6'
-	thestring = "amd64"
-
-	// Allow GOARCH=thestring or GOARCH=thestringsuffix,
-	// but not other values.
-	p = Getgoarch()
-
-	if !strings.HasPrefix(p, thestring) {
-		log.Fatalf("cannot use %cc with GOARCH=%s", thechar, p)
-	}
-	if p == "amd64p32" {
-		thelinkarch = &x86.Linkamd64p32
-	}
-
-	ctxt = obj.Linknew(thelinkarch)
-	ctxt.Diag = yyerror
-	ctxt.Bso = &bstdout
-	ctxt.Enforce_data_order = 1
-	obj.Binit(&bstdout, 1, main.OWRITE)
-	x86.Listinit6()
-	obj.Fmtinstall('L', Lconv)
-
-	ensuresymb(NSYMB)
-	debug = [256]int{}
-	cinit()
-	outfile = ""
-	setinclude(".")
-
-	main.Flagfn1("D", "name[=value]: add #define", dodef)
-	main.Flagfn1("I", "dir: add dir to include path", setinclude)
-	main.Flagcount("S", "print assembly and machine code", &debug['S'])
-	main.Flagcount("m", "debug preprocessor macros", &debug['m'])
-	main.Flagstr("o", "file: set output file", &outfile)
-	main.Flagstr("trimpath", "prefix: remove prefix from recorded source file paths", &ctxt.Trimpath)
-
-	main.Flagparse(&argc, (**string)(&argv), usage)
-	ctxt.Debugasm = int32(debug['S'])
-
-	if argc < 1 {
-		usage()
-	}
-	if argc > 1 {
-		fmt.Printf("can't assemble multiple files\n")
-		errorexit()
-	}
+type yy struct{}
 
-	if assemble(argv[0]) != 0 {
-		errorexit()
-	}
-	obj.Bflush(&bstdout)
-	if nerrors > 0 {
-		errorexit()
-	}
-	main.Exits("")
+func (yy) Lex(v *yySymType) int {
+	var av asm.Yylval
+	tok := asm.Yylex(&av)
+	v.sym = av.Sym
+	v.lval = av.Lval
+	v.sval = av.Sval
+	v.dval = av.Dval
+	return tok
 }
 
-func assemble(file string) int {
-	var ofile string
-	var p string
-	var i int
-	var of int
-
-	ofile = alloc(int32(len(file)) + 3).(string) // +3 for .x\0 (x=thechar)
-	ofile = file
-	p = main.Utfrrune(ofile, uint(pathchar()))
-	if p != "" {
-		include[0] = ofile
-		p = ""
-		p = p[1:]
-	} else {
-
-		p = ofile
-	}
-	if outfile == "" {
-		outfile = p
-		if outfile != "" {
-			p = main.Utfrrune(outfile, '.')
-			if p != "" {
-				if p[1] == 's' && p[2] == 0 {
-					p = ""
-				}
-			}
-			p = main.Utfrune(outfile, 0)
-			p[0] = '.'
-			p[1] = byte(thechar)
-			p[2] = 0
-		} else {
-
-			outfile = "/dev/null"
-		}
-	}
-
-	of = main.Create(outfile, main.OWRITE, 0664)
-	if of < 0 {
-		yyerror("%ca: cannot create %s", thechar, outfile)
-		errorexit()
-	}
-
-	obj.Binit(&obuf, of, main.OWRITE)
-	fmt.Fprintf(&obuf, "go object %s %s %s\n", main.Getgoos(), main.Getgoarch(), main.Getgoversion())
-	fmt.Fprintf(&obuf, "!\n")
-
-	for pass = 1; pass <= 2; pass++ {
-		pinit(file)
-		for i = 0; i < nDlist; i++ {
-			dodefine(Dlist[i])
-		}
-		yyparse()
-		cclean()
-		if nerrors != 0 {
-			return nerrors
-		}
-	}
+func (yy) Error(msg string) {
+	asm.Yyerror("%s", msg)
+}
 
-	obj.Writeobj(ctxt, &obuf)
-	obj.Bflush(&obuf)
-	return 0
+func yyparse() {
+	yyParse(yy{})
 }
 
-var itab = []struct {
-	name  string
-	type_ uint16
-	value uint16
-}{
+var lexinit = []asm.Lextab{
 	{"SP", LSP, x86.D_AUTO},
 	{"SB", LSB, x86.D_EXTERN},
 	{"FP", LFP, x86.D_PARAM},
@@ -1019,31 +915,11 @@ var itab = []struct {
 }
 
 func cinit() {
-	var s *Sym
-	var i int
-
 	nullgen.Type_ = x86.D_NONE
 	nullgen.Index = x86.D_NONE
-
-	nerrors = 0
-	iostack = nil
-	iofree = nil
-	peekc = IGN
-	nhunk = 0
-	for i = 0; i < NHASH; i++ {
-		hash[i] = nil
-	}
-	for i = 0; itab[i].name != ""; i++ {
-		s = slookup(itab[i].name)
-		if s.type_ != LNAME {
-			yyerror("double initialization %s", itab[i].name)
-		}
-		s.type_ = itab[i].type_
-		s.value = int64(itab[i].value)
-	}
 }
 
-func checkscale(scale int) {
+func checkscale(scale int8) {
 	switch scale {
 	case 1,
 		2,
@@ -1055,11 +931,6 @@ func checkscale(scale int) {
 	yyerror("scale must be 1248: %d", scale)
 }
 
-func syminit(s *Sym) {
-	s.type_ = LNAME
-	s.value = 0
-}
-
 func cclean() {
 	var g2 Addr2
 
@@ -1070,24 +941,30 @@ func cclean() {
 
 var lastpc *obj.Prog
 
+type Addr2 struct {
+	from obj.Addr
+	to   obj.Addr
+}
+
 func outcode(a int, g2 *Addr2) {
 	var p *obj.Prog
 	var pl *obj.Plist
 
-	if pass == 1 {
+	if asm.Pass == 1 {
 		goto out
 	}
 
 	p = new(obj.Prog)
 	*p = obj.Prog{}
+	p.Ctxt = asm.Ctxt
 	p.As = int16(a)
 	p.Lineno = stmtline
 	p.From = g2.from
 	p.To = g2.to
-	p.Pc = int64(pc)
+	p.Pc = int64(asm.PC)
 
 	if lastpc == nil {
-		pl = obj.Linknewplist(ctxt)
+		pl = obj.Linknewplist(asm.Ctxt)
 		pl.Firstpc = p
 	} else {
 
@@ -1097,6 +974,6 @@ func outcode(a int, g2 *Addr2) {
 
 out:
 	if a != x86.AGLOBL && a != x86.ADATA {
-		pc++
+		asm.PC++
 	}
 }
diff --git a/src/cmd/new6a/y.go b/src/cmd/new6a/y.go
new file mode 100644
index 0000000000..505efc0524
--- /dev/null
+++ b/src/cmd/new6a/y.go
@@ -0,0 +1,1313 @@
+//line a.y:32
+package main
+
+import __yyfmt__ "fmt"
+
+//line a.y:32
+import (
+	"cmd/internal/asm"
+	"cmd/internal/obj"
+	"cmd/internal/obj/x86"
+)
+
+//line a.y:41
+type yySymType struct {
+	yys   int
+	sym   *asm.Sym
+	lval  int64
+	dval  float64
+	sval  string
+	addr  obj.Addr
+	addr2 Addr2
+}
+
+const LTYPE0 = 57346
+const LTYPE1 = 57347
+const LTYPE2 = 57348
+const LTYPE3 = 57349
+const LTYPE4 = 57350
+const LTYPEC = 57351
+const LTYPED = 57352
+const LTYPEN = 57353
+const LTYPER = 57354
+const LTYPET = 57355
+const LTYPEG = 57356
+const LTYPEPC = 57357
+const LTYPES = 57358
+const LTYPEM = 57359
+const LTYPEI = 57360
+const LTYPEXC = 57361
+const LTYPEX = 57362
+const LTYPERT = 57363
+const LTYPEF = 57364
+const LCONST = 57365
+const LFP = 57366
+const LPC = 57367
+const LSB = 57368
+const LBREG = 57369
+const LLREG = 57370
+const LSREG = 57371
+const LFREG = 57372
+const LMREG = 57373
+const LXREG = 57374
+const LFCONST = 57375
+const LSCONST = 57376
+const LSP = 57377
+const LNAME = 57378
+const LLAB = 57379
+const LVAR = 57380
+
+var yyToknames = []string{
+	"'|'",
+	"'^'",
+	"'&'",
+	"'<'",
+	"'>'",
+	"'+'",
+	"'-'",
+	"'*'",
+	"'/'",
+	"'%'",
+	"LTYPE0",
+	"LTYPE1",
+	"LTYPE2",
+	"LTYPE3",
+	"LTYPE4",
+	"LTYPEC",
+	"LTYPED",
+	"LTYPEN",
+	"LTYPER",
+	"LTYPET",
+	"LTYPEG",
+	"LTYPEPC",
+	"LTYPES",
+	"LTYPEM",
+	"LTYPEI",
+	"LTYPEXC",
+	"LTYPEX",
+	"LTYPERT",
+	"LTYPEF",
+	"LCONST",
+	"LFP",
+	"LPC",
+	"LSB",
+	"LBREG",
+	"LLREG",
+	"LSREG",
+	"LFREG",
+	"LMREG",
+	"LXREG",
+	"LFCONST",
+	"LSCONST",
+	"LSP",
+	"LNAME",
+	"LLAB",
+	"LVAR",
+}
+var yyStatenames = []string{}
+
+const yyEofCode = 1
+const yyErrCode = 2
+const yyMaxDepth = 200
+
+//line yacctab:1
+var yyExca = []int{
+	-1, 1,
+	1, -1,
+	-2, 2,
+}
+
+const yyNprod = 134
+const yyPrivate = 57344
+
+var yyTokenNames []string
+var yyStates []string
+
+const yyLast = 565
+
+var yyAct = []int{
+
+	49, 61, 186, 123, 38, 3, 81, 80, 51, 62,
+	47, 188, 269, 268, 267, 71, 70, 118, 86, 48,
+	263, 69, 84, 256, 75, 101, 103, 99, 85, 209,
+	112, 254, 59, 112, 170, 242, 240, 82, 238, 222,
+	220, 211, 55, 54, 210, 64, 171, 111, 241, 235,
+	113, 112, 93, 95, 97, 120, 121, 122, 212, 107,
+	109, 55, 133, 128, 174, 145, 52, 138, 119, 71,
+	115, 129, 208, 232, 112, 136, 139, 169, 55, 54,
+	86, 53, 231, 230, 84, 52, 73, 142, 143, 56,
+	85, 146, 224, 60, 144, 131, 130, 223, 57, 82,
+	53, 154, 52, 153, 37, 132, 152, 66, 56, 151,
+	150, 149, 37, 148, 147, 72, 155, 53, 141, 137,
+	135, 68, 73, 134, 62, 56, 176, 177, 127, 34,
+	114, 32, 31, 112, 120, 28, 229, 29, 71, 30,
+	228, 185, 187, 57, 183, 252, 253, 40, 42, 45,
+	41, 43, 46, 195, 194, 44, 248, 112, 112, 112,
+	112, 112, 166, 168, 112, 112, 112, 247, 182, 167,
+	237, 213, 173, 257, 198, 199, 200, 201, 202, 219,
+	120, 205, 206, 207, 184, 114, 196, 197, 165, 164,
+	163, 161, 162, 156, 157, 158, 159, 160, 184, 264,
+	227, 166, 168, 258, 112, 112, 140, 218, 167, 216,
+	236, 55, 54, 55, 54, 239, 246, 261, 217, 260,
+	35, 233, 234, 226, 255, 243, 214, 244, 181, 33,
+	124, 249, 125, 126, 251, 52, 250, 52, 172, 90,
+	116, 189, 190, 191, 192, 193, 259, 117, 89, 245,
+	53, 7, 53, 125, 126, 73, 262, 73, 56, 62,
+	56, 265, 266, 9, 10, 11, 12, 13, 17, 15,
+	18, 14, 16, 25, 26, 19, 20, 21, 22, 23,
+	24, 27, 55, 54, 83, 156, 157, 158, 159, 160,
+	39, 158, 159, 160, 204, 4, 175, 8, 203, 5,
+	6, 110, 2, 55, 54, 1, 52, 77, 108, 106,
+	40, 42, 45, 41, 43, 46, 105, 104, 44, 87,
+	102, 53, 55, 54, 100, 79, 50, 52, 98, 56,
+	96, 40, 42, 45, 41, 43, 46, 94, 92, 44,
+	57, 88, 53, 55, 54, 83, 52, 50, 78, 62,
+	56, 76, 74, 65, 63, 58, 221, 67, 215, 225,
+	0, 53, 0, 0, 55, 54, 73, 52, 0, 56,
+	0, 40, 42, 45, 41, 43, 46, 0, 0, 44,
+	87, 0, 53, 0, 0, 55, 54, 50, 52, 0,
+	56, 0, 40, 42, 45, 41, 43, 46, 0, 0,
+	44, 57, 0, 53, 0, 0, 0, 91, 50, 52,
+	0, 56, 0, 40, 42, 45, 41, 43, 46, 55,
+	54, 44, 57, 0, 53, 0, 0, 0, 36, 50,
+	0, 0, 56, 0, 0, 0, 55, 54, 0, 0,
+	55, 54, 0, 52, 0, 0, 0, 40, 42, 45,
+	41, 43, 46, 55, 54, 44, 57, 0, 53, 0,
+	52, 0, 0, 50, 52, 0, 56, 0, 40, 42,
+	45, 41, 43, 46, 0, 53, 44, 52, 0, 53,
+	73, 0, 188, 56, 50, 55, 54, 56, 0, 0,
+	72, 0, 53, 0, 55, 179, 0, 73, 55, 54,
+	56, 163, 161, 162, 156, 157, 158, 159, 160, 52,
+	161, 162, 156, 157, 158, 159, 160, 0, 52, 180,
+	0, 0, 52, 0, 53, 0, 0, 0, 178, 73,
+	0, 0, 56, 53, 0, 57, 0, 53, 73, 0,
+	0, 56, 50, 0, 0, 56, 165, 164, 163, 161,
+	162, 156, 157, 158, 159, 160, 164, 163, 161, 162,
+	156, 157, 158, 159, 160,
+}
+var yyPact = []int{
+
+	-1000, -1000, 249, -1000, 86, -1000, 89, 82, 80, 77,
+	376, 294, 294, 410, 69, 97, 489, 273, 355, 294,
+	294, 294, 110, -46, -46, 489, 294, 294, -1000, 33,
+	-1000, -1000, 33, -1000, -1000, -1000, 410, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, 17,
+	202, 15, -1000, -1000, 33, 33, 33, 223, -1000, 76,
+	-1000, -1000, 52, -1000, 71, -1000, 68, -1000, 444, -1000,
+	67, 14, 244, 33, -1000, 194, -1000, 66, -1000, 334,
+	-1000, -1000, -1000, 431, -1000, -1000, 12, 223, -1000, -1000,
+	-1000, 410, -1000, 62, -1000, 61, -1000, 59, -1000, 58,
+	-1000, 57, -1000, -1000, -1000, 54, -1000, 51, -1000, 49,
+	249, 542, -1000, 542, -1000, 124, 23, -8, 184, 134,
+	-1000, -1000, -1000, 11, 288, 33, 33, -1000, -1000, -1000,
+	-1000, -1000, 485, 476, 410, 294, -1000, 444, 149, -1000,
+	33, 427, -1000, -1000, -1000, 163, 11, 410, 410, 410,
+	410, 410, 204, 294, 294, -1000, 33, 33, 33, 33,
+	33, 291, 286, 33, 33, 33, 18, -10, -13, 5,
+	33, -1000, -1000, 215, 173, 244, -1000, -1000, -14, 313,
+	-1000, -1000, -1000, -1000, -15, 45, -1000, 40, 190, 91,
+	87, -1000, 31, 30, -1000, 21, -1000, -1000, 280, 280,
+	-1000, -1000, -1000, 33, 33, 503, 495, 551, -4, 33,
+	-1000, -1000, 132, -16, 33, -18, -1000, -1000, -1000, -5,
+	-1000, -19, -1000, -46, -44, -1000, 239, 183, 129, 117,
+	33, 110, -46, 276, 276, 107, -23, 213, -1000, -31,
+	-1000, 137, -1000, -1000, -1000, 170, 236, -1000, -1000, -1000,
+	-1000, -1000, 208, 206, -1000, 33, -1000, -34, -1000, 166,
+	33, 33, -40, -1000, -1000, -41, -42, -1000, -1000, -1000,
+}
+var yyPgo = []int{
+
+	0, 0, 359, 17, 358, 3, 290, 1, 2, 4,
+	8, 6, 93, 32, 7, 10, 19, 229, 357, 220,
+	355, 354, 353, 352, 351, 348, 341, 338, 337, 330,
+	328, 324, 320, 317, 309, 308, 305, 302, 5, 301,
+	300,
+}
+var yyR1 = []int{
+
+	0, 36, 37, 36, 39, 38, 38, 38, 38, 40,
+	40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+	40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+	17, 17, 21, 22, 20, 20, 19, 19, 18, 18,
+	18, 23, 24, 24, 25, 25, 26, 26, 27, 27,
+	28, 28, 29, 29, 29, 30, 31, 32, 32, 33,
+	33, 34, 35, 12, 12, 14, 14, 14, 14, 14,
+	14, 13, 13, 11, 11, 9, 9, 9, 9, 9,
+	9, 9, 8, 7, 7, 7, 7, 7, 7, 7,
+	6, 6, 15, 15, 15, 15, 15, 15, 15, 15,
+	15, 15, 15, 16, 16, 10, 10, 5, 5, 5,
+	4, 4, 4, 1, 1, 1, 1, 1, 1, 2,
+	2, 2, 2, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3,
+}
+var yyR2 = []int{
+
+	0, 0, 0, 3, 0, 4, 1, 2, 2, 3,
+	3, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	0, 1, 3, 3, 2, 1, 2, 1, 2, 1,
+	3, 5, 3, 5, 2, 1, 1, 1, 3, 5,
+	3, 5, 2, 1, 3, 5, 5, 0, 1, 3,
+	5, 3, 3, 1, 1, 1, 1, 2, 2, 1,
+	1, 1, 1, 4, 2, 1, 1, 1, 1, 1,
+	1, 1, 2, 2, 2, 2, 2, 4, 5, 3,
+	1, 1, 1, 4, 4, 4, 6, 9, 9, 3,
+	3, 5, 8, 1, 6, 5, 7, 0, 2, 2,
+	1, 1, 1, 1, 1, 2, 2, 2, 3, 1,
+	2, 3, 4, 1, 3, 3, 3, 3, 3, 4,
+	4, 3, 3, 3,
+}
+var yyChk = []int{
+
+	-1000, -36, -37, -38, 46, 50, -40, 2, 48, 14,
+	15, 16, 17, 18, 22, 20, 23, 19, 21, 26,
+	27, 28, 29, 30, 31, 24, 25, 32, 49, 51,
+	50, 50, 51, -17, 52, -19, 52, -12, -9, -6,
+	37, 40, 38, 41, 45, 39, 42, -15, -16, -1,
+	53, -10, 33, 48, 10, 9, 56, 46, -20, -13,
+	-12, -7, 55, -21, -13, -22, -12, -18, 52, -11,
+	-7, -1, 46, 53, -23, -10, -24, -6, -25, 52,
+	-14, -11, -16, 11, -9, -15, -1, 46, -26, -17,
+	-19, 52, -27, -13, -28, -13, -29, -13, -30, -9,
+	-31, -7, -32, -7, -33, -6, -34, -13, -35, -13,
+	-39, -3, -1, -3, -12, 53, 38, 45, -3, 53,
+	-1, -1, -1, -5, 7, 9, 10, 52, -1, -10,
+	44, 43, 53, 10, 52, 52, -11, 52, 53, -5,
+	12, 52, -14, -9, -15, 53, -5, 52, 52, 52,
+	52, 52, 52, 52, 52, -38, 9, 10, 11, 12,
+	13, 7, 8, 6, 5, 4, 38, 45, 39, 54,
+	11, 54, 54, 38, 53, 8, -1, -1, 43, 10,
+	43, -12, -13, -11, 35, -1, -8, -1, 55, -12,
+	-12, -12, -12, -12, -7, -1, -13, -13, -3, -3,
+	-3, -3, -3, 7, 8, -3, -3, -3, 54, 11,
+	54, 54, 53, -1, 11, -4, 36, 45, 34, -5,
+	54, 43, 54, 52, 52, -2, 33, 10, 49, 49,
+	52, 52, 52, -3, -3, 53, -1, 38, 54, -1,
+	54, 53, 54, -7, -8, 10, 33, 38, 39, -1,
+	-9, -7, 38, 39, 54, 11, 54, 36, 33, 10,
+	11, 11, -1, 54, 33, -1, -1, 54, 54, 54,
+}
+var yyDef = []int{
+
+	1, -2, 0, 3, 0, 6, 0, 0, 0, 30,
+	0, 0, 0, 0, 0, 0, 0, 0, 30, 0,
+	0, 0, 0, 0, 57, 0, 0, 0, 4, 0,
+	7, 8, 0, 11, 31, 12, 0, 37, 63, 64,
+	75, 76, 77, 78, 79, 80, 81, 90, 91, 92,
+	0, 103, 113, 114, 0, 0, 0, 107, 13, 35,
+	71, 72, 0, 14, 0, 15, 0, 16, 0, 39,
+	0, 0, 107, 0, 17, 0, 18, 0, 19, 0,
+	45, 65, 66, 0, 69, 70, 92, 107, 20, 46,
+	47, 31, 21, 0, 22, 0, 23, 53, 24, 0,
+	25, 0, 26, 58, 27, 0, 28, 0, 29, 0,
+	0, 9, 123, 10, 36, 0, 0, 0, 0, 0,
+	115, 116, 117, 0, 0, 0, 0, 34, 83, 84,
+	85, 86, 0, 0, 0, 0, 38, 0, 0, 74,
+	0, 0, 44, 67, 68, 0, 74, 0, 0, 52,
+	0, 0, 0, 0, 0, 5, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 99,
+	0, 100, 118, 0, 0, 107, 108, 109, 0, 0,
+	89, 32, 33, 40, 0, 0, 42, 0, 0, 48,
+	50, 54, 0, 0, 59, 0, 61, 62, 124, 125,
+	126, 127, 128, 0, 0, 131, 132, 133, 93, 0,
+	94, 95, 0, 0, 0, 0, 110, 111, 112, 0,
+	87, 0, 73, 0, 0, 82, 119, 0, 0, 0,
+	0, 0, 0, 129, 130, 0, 0, 0, 101, 0,
+	105, 0, 88, 41, 43, 0, 120, 49, 51, 55,
+	56, 60, 0, 0, 96, 0, 104, 0, 121, 0,
+	0, 0, 0, 106, 122, 0, 0, 102, 97, 98,
+}
+var yyTok1 = []int{
+
+	1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 55, 13, 6, 3,
+	53, 54, 11, 9, 52, 10, 3, 12, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 49, 50,
+	7, 51, 8, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 5, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 4, 3, 56,
+}
+var yyTok2 = []int{
+
+	2, 3, 14, 15, 16, 17, 18, 19, 20, 21,
+	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
+	42, 43, 44, 45, 46, 47, 48,
+}
+var yyTok3 = []int{
+	0,
+}
+
+//line yaccpar:1
+
+/*	parser for yacc output	*/
+
+var yyDebug = 0
+
+type yyLexer interface {
+	Lex(lval *yySymType) int
+	Error(s string)
+}
+
+const yyFlag = -1000
+
+func yyTokname(c int) string {
+	// 4 is TOKSTART above
+	if c >= 4 && c-4 < len(yyToknames) {
+		if yyToknames[c-4] != "" {
+			return yyToknames[c-4]
+		}
+	}
+	return __yyfmt__.Sprintf("tok-%v", c)
+}
+
+func yyStatname(s int) string {
+	if s >= 0 && s < len(yyStatenames) {
+		if yyStatenames[s] != "" {
+			return yyStatenames[s]
+		}
+	}
+	return __yyfmt__.Sprintf("state-%v", s)
+}
+
+func yylex1(lex yyLexer, lval *yySymType) int {
+	c := 0
+	char := lex.Lex(lval)
+	if char <= 0 {
+		c = yyTok1[0]
+		goto out
+	}
+	if char < len(yyTok1) {
+		c = yyTok1[char]
+		goto out
+	}
+	if char >= yyPrivate {
+		if char < yyPrivate+len(yyTok2) {
+			c = yyTok2[char-yyPrivate]
+			goto out
+		}
+	}
+	for i := 0; i < len(yyTok3); i += 2 {
+		c = yyTok3[i+0]
+		if c == char {
+			c = yyTok3[i+1]
+			goto out
+		}
+	}
+
+out:
+	if c == 0 {
+		c = yyTok2[1] /* unknown char */
+	}
+	if yyDebug >= 3 {
+		__yyfmt__.Printf("lex %s(%d)\n", yyTokname(c), uint(char))
+	}
+	return c
+}
+
+func yyParse(yylex yyLexer) int {
+	var yyn int
+	var yylval yySymType
+	var yyVAL yySymType
+	yyS := make([]yySymType, yyMaxDepth)
+
+	Nerrs := 0   /* number of errors */
+	Errflag := 0 /* error recovery flag */
+	yystate := 0
+	yychar := -1
+	yyp := -1
+	goto yystack
+
+ret0:
+	return 0
+
+ret1:
+	return 1
+
+yystack:
+	/* put a state and value onto the stack */
+	if yyDebug >= 4 {
+		__yyfmt__.Printf("char %v in %v\n", yyTokname(yychar), yyStatname(yystate))
+	}
+
+	yyp++
+	if yyp >= len(yyS) {
+		nyys := make([]yySymType, len(yyS)*2)
+		copy(nyys, yyS)
+		yyS = nyys
+	}
+	yyS[yyp] = yyVAL
+	yyS[yyp].yys = yystate
+
+yynewstate:
+	yyn = yyPact[yystate]
+	if yyn <= yyFlag {
+		goto yydefault /* simple state */
+	}
+	if yychar < 0 {
+		yychar = yylex1(yylex, &yylval)
+	}
+	yyn += yychar
+	if yyn < 0 || yyn >= yyLast {
+		goto yydefault
+	}
+	yyn = yyAct[yyn]
+	if yyChk[yyn] == yychar { /* valid shift */
+		yychar = -1
+		yyVAL = yylval
+		yystate = yyn
+		if Errflag > 0 {
+			Errflag--
+		}
+		goto yystack
+	}
+
+yydefault:
+	/* default state action */
+	yyn = yyDef[yystate]
+	if yyn == -2 {
+		if yychar < 0 {
+			yychar = yylex1(yylex, &yylval)
+		}
+
+		/* look through exception table */
+		xi := 0
+		for {
+			if yyExca[xi+0] == -1 && yyExca[xi+1] == yystate {
+				break
+			}
+			xi += 2
+		}
+		for xi += 2; ; xi += 2 {
+			yyn = yyExca[xi+0]
+			if yyn < 0 || yyn == yychar {
+				break
+			}
+		}
+		yyn = yyExca[xi+1]
+		if yyn < 0 {
+			goto ret0
+		}
+	}
+	if yyn == 0 {
+		/* error ... attempt to resume parsing */
+		switch Errflag {
+		case 0: /* brand new error */
+			yylex.Error("syntax error")
+			Nerrs++
+			if yyDebug >= 1 {
+				__yyfmt__.Printf("%s", yyStatname(yystate))
+				__yyfmt__.Printf(" saw %s\n", yyTokname(yychar))
+			}
+			fallthrough
+
+		case 1, 2: /* incompletely recovered error ... try again */
+			Errflag = 3
+
+			/* find a state where "error" is a legal shift action */
+			for yyp >= 0 {
+				yyn = yyPact[yyS[yyp].yys] + yyErrCode
+				if yyn >= 0 && yyn < yyLast {
+					yystate = yyAct[yyn] /* simulate a shift of "error" */
+					if yyChk[yystate] == yyErrCode {
+						goto yystack
+					}
+				}
+
+				/* the current p has no shift on "error", pop stack */
+				if yyDebug >= 2 {
+					__yyfmt__.Printf("error recovery pops state %d\n", yyS[yyp].yys)
+				}
+				yyp--
+			}
+			/* there is no state on the stack with an error shift ... abort */
+			goto ret1
+
+		case 3: /* no shift yet; clobber input char */
+			if yyDebug >= 2 {
+				__yyfmt__.Printf("error recovery discards %s\n", yyTokname(yychar))
+			}
+			if yychar == yyEofCode {
+				goto ret1
+			}
+			yychar = -1
+			goto yynewstate /* try again in the same state */
+		}
+	}
+
+	/* reduction by production yyn */
+	if yyDebug >= 2 {
+		__yyfmt__.Printf("reduce %v in:\n\t%v\n", yyn, yyStatname(yystate))
+	}
+
+	yynt := yyn
+	yypt := yyp
+	_ = yypt // guard against "declared and not used"
+
+	yyp -= yyR2[yyn]
+	// yyp is now the index of $0. Perform the default action. Iff the
+	// reduced production is ε, $1 is possibly out of range.
+	if yyp+1 >= len(yyS) {
+		nyys := make([]yySymType, len(yyS)*2)
+		copy(nyys, yyS)
+		yyS = nyys
+	}
+	yyVAL = yyS[yyp+1]
+
+	/* consult goto table to find next state */
+	yyn = yyR1[yyn]
+	yyg := yyPgo[yyn]
+	yyj := yyg + yyS[yyp].yys + 1
+
+	if yyj >= yyLast {
+		yystate = yyAct[yyg]
+	} else {
+		yystate = yyAct[yyj]
+		if yyChk[yystate] != -yyn {
+			yystate = yyAct[yyg]
+		}
+	}
+	// dummy call; replaced with literal code
+	switch yynt {
+
+	case 2:
+		//line a.y:72
+		{
+			stmtline = asm.Lineno
+		}
+	case 4:
+		//line a.y:79
+		{
+			yyS[yypt-1].sym = asm.LabelLookup(yyS[yypt-1].sym)
+			if yyS[yypt-1].sym.Type == LLAB && yyS[yypt-1].sym.Value != int64(asm.PC) {
+				yyerror("redeclaration of %s (%s)", yyS[yypt-1].sym.Labelname, yyS[yypt-1].sym.Name)
+			}
+			yyS[yypt-1].sym.Type = LLAB
+			yyS[yypt-1].sym.Value = int64(asm.PC)
+		}
+	case 9:
+		//line a.y:94
+		{
+			yyS[yypt-2].sym.Type = LVAR
+			yyS[yypt-2].sym.Value = yyS[yypt-0].lval
+		}
+	case 10:
+		//line a.y:99
+		{
+			if yyS[yypt-2].sym.Value != yyS[yypt-0].lval {
+				yyerror("redeclaration of %s", yyS[yypt-2].sym.Name)
+			}
+			yyS[yypt-2].sym.Value = yyS[yypt-0].lval
+		}
+	case 11:
+		//line a.y:105
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 12:
+		//line a.y:106
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 13:
+		//line a.y:107
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 14:
+		//line a.y:108
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 15:
+		//line a.y:109
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 16:
+		//line a.y:110
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 17:
+		//line a.y:111
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 18:
+		//line a.y:112
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 19:
+		//line a.y:113
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 20:
+		//line a.y:114
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 21:
+		//line a.y:115
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 22:
+		//line a.y:116
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 23:
+		//line a.y:117
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 24:
+		//line a.y:118
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 25:
+		//line a.y:119
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 26:
+		//line a.y:120
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 27:
+		//line a.y:121
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 28:
+		//line a.y:122
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 29:
+		//line a.y:123
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 30:
+		//line a.y:126
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = nullgen
+		}
+	case 31:
+		//line a.y:131
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = nullgen
+		}
+	case 32:
+		//line a.y:138
+		{
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 33:
+		//line a.y:145
+		{
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 34:
+		//line a.y:152
+		{
+			yyVAL.addr2.from = yyS[yypt-1].addr
+			yyVAL.addr2.to = nullgen
+		}
+	case 35:
+		//line a.y:157
+		{
+			yyVAL.addr2.from = yyS[yypt-0].addr
+			yyVAL.addr2.to = nullgen
+		}
+	case 36:
+		//line a.y:164
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 37:
+		//line a.y:169
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 38:
+		//line a.y:176
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 39:
+		//line a.y:181
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 40:
+		//line a.y:186
+		{
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 41:
+		//line a.y:193
+		{
+			yyVAL.addr2.from = yyS[yypt-4].addr
+			yyVAL.addr2.from.Scale = int8(yyS[yypt-2].lval)
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 42:
+		//line a.y:201
+		{
+			asm.Settext(yyS[yypt-2].addr.Sym)
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 43:
+		//line a.y:207
+		{
+			asm.Settext(yyS[yypt-4].addr.Sym)
+			yyVAL.addr2.from = yyS[yypt-4].addr
+			yyVAL.addr2.from.Scale = int8(yyS[yypt-2].lval)
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 44:
+		//line a.y:216
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 45:
+		//line a.y:221
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 46:
+		yyVAL.addr2 = yyS[yypt-0].addr2
+	case 47:
+		yyVAL.addr2 = yyS[yypt-0].addr2
+	case 48:
+		//line a.y:232
+		{
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 49:
+		//line a.y:237
+		{
+			yyVAL.addr2.from = yyS[yypt-4].addr
+			yyVAL.addr2.to = yyS[yypt-2].addr
+			if yyVAL.addr2.from.Index != x86.D_NONE {
+				yyerror("dp shift with lhs index")
+			}
+			yyVAL.addr2.from.Index = uint8(yyS[yypt-0].lval)
+		}
+	case 50:
+		//line a.y:248
+		{
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 51:
+		//line a.y:253
+		{
+			yyVAL.addr2.from = yyS[yypt-4].addr
+			yyVAL.addr2.to = yyS[yypt-2].addr
+			if yyVAL.addr2.to.Index != x86.D_NONE {
+				yyerror("dp move with lhs index")
+			}
+			yyVAL.addr2.to.Index = uint8(yyS[yypt-0].lval)
+		}
+	case 52:
+		//line a.y:264
+		{
+			yyVAL.addr2.from = yyS[yypt-1].addr
+			yyVAL.addr2.to = nullgen
+		}
+	case 53:
+		//line a.y:269
+		{
+			yyVAL.addr2.from = yyS[yypt-0].addr
+			yyVAL.addr2.to = nullgen
+		}
+	case 54:
+		//line a.y:274
+		{
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 55:
+		//line a.y:281
+		{
+			yyVAL.addr2.from = yyS[yypt-4].addr
+			yyVAL.addr2.to = yyS[yypt-2].addr
+			yyVAL.addr2.to.Offset = yyS[yypt-0].lval
+		}
+	case 56:
+		//line a.y:289
+		{
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+			if yyS[yypt-4].addr.Type_ != x86.D_CONST {
+				yyerror("illegal constant")
+			}
+			yyVAL.addr2.to.Offset = yyS[yypt-4].addr.Offset
+		}
+	case 57:
+		//line a.y:299
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = nullgen
+		}
+	case 58:
+		//line a.y:304
+		{
+			yyVAL.addr2.from = yyS[yypt-0].addr
+			yyVAL.addr2.to = nullgen
+		}
+	case 59:
+		//line a.y:311
+		{
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 60:
+		//line a.y:316
+		{
+			yyVAL.addr2.from = yyS[yypt-4].addr
+			yyVAL.addr2.from.Scale = int8(yyS[yypt-2].lval)
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 61:
+		//line a.y:324
+		{
+			if yyS[yypt-2].addr.Type_ != x86.D_CONST || yyS[yypt-0].addr.Type_ != x86.D_CONST {
+				yyerror("arguments to asm.PCDATA must be integer constants")
+			}
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 62:
+		//line a.y:334
+		{
+			if yyS[yypt-2].addr.Type_ != x86.D_CONST {
+				yyerror("index for FUNCDATA must be integer constant")
+			}
+			if yyS[yypt-0].addr.Type_ != x86.D_EXTERN && yyS[yypt-0].addr.Type_ != x86.D_STATIC {
+				yyerror("value for FUNCDATA must be symbol reference")
+			}
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 63:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 64:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 65:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 66:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 67:
+		//line a.y:353
+		{
+			yyVAL.addr = yyS[yypt-0].addr
+		}
+	case 68:
+		//line a.y:357
+		{
+			yyVAL.addr = yyS[yypt-0].addr
+		}
+	case 69:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 70:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 71:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 72:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 73:
+		//line a.y:369
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = x86.D_BRANCH
+			yyVAL.addr.Offset = yyS[yypt-3].lval + int64(asm.PC)
+		}
+	case 74:
+		//line a.y:375
+		{
+			yyS[yypt-1].sym = asm.LabelLookup(yyS[yypt-1].sym)
+			yyVAL.addr = nullgen
+			if asm.Pass == 2 && yyS[yypt-1].sym.Type != LLAB {
+				yyerror("undefined label: %s", yyS[yypt-1].sym.Labelname)
+			}
+			yyVAL.addr.Type_ = x86.D_BRANCH
+			yyVAL.addr.Offset = yyS[yypt-1].sym.Value + yyS[yypt-0].lval
+		}
+	case 75:
+		//line a.y:387
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+		}
+	case 76:
+		//line a.y:392
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+		}
+	case 77:
+		//line a.y:397
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+		}
+	case 78:
+		//line a.y:402
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+		}
+	case 79:
+		//line a.y:407
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = x86.D_SP
+		}
+	case 80:
+		//line a.y:412
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+		}
+	case 81:
+		//line a.y:417
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+		}
+	case 82:
+		//line a.y:423
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = x86.D_CONST
+			yyVAL.addr.Offset = yyS[yypt-0].lval
+		}
+	case 83:
+		//line a.y:431
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = x86.D_CONST
+			yyVAL.addr.Offset = yyS[yypt-0].lval
+		}
+	case 84:
+		//line a.y:437
+		{
+			yyVAL.addr = yyS[yypt-0].addr
+			yyVAL.addr.Index = uint8(yyS[yypt-0].addr.Type_)
+			yyVAL.addr.Type_ = x86.D_ADDR
+			/*
+				if($2.Type_ == x86.D_AUTO || $2.Type_ == x86.D_PARAM)
+					yyerror("constant cannot be automatic: %s",
+						$2.sym.Name);
+			*/
+		}
+	case 85:
+		//line a.y:447
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = x86.D_SCONST
+			yyVAL.addr.U.Sval = (yyS[yypt-0].sval + "\x00\x00\x00\x00\x00\x00\x00\x00")[:8]
+		}
+	case 86:
+		//line a.y:453
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = x86.D_FCONST
+			yyVAL.addr.U.Dval = yyS[yypt-0].dval
+		}
+	case 87:
+		//line a.y:459
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = x86.D_FCONST
+			yyVAL.addr.U.Dval = yyS[yypt-1].dval
+		}
+	case 88:
+		//line a.y:465
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = x86.D_FCONST
+			yyVAL.addr.U.Dval = -yyS[yypt-1].dval
+		}
+	case 89:
+		//line a.y:471
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = x86.D_FCONST
+			yyVAL.addr.U.Dval = -yyS[yypt-0].dval
+		}
+	case 90:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 91:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 92:
+		//line a.y:483
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = x86.D_INDIR + x86.D_NONE
+			yyVAL.addr.Offset = yyS[yypt-0].lval
+		}
+	case 93:
+		//line a.y:489
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(x86.D_INDIR + yyS[yypt-1].lval)
+			yyVAL.addr.Offset = yyS[yypt-3].lval
+		}
+	case 94:
+		//line a.y:495
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(x86.D_INDIR + x86.D_SP)
+			yyVAL.addr.Offset = yyS[yypt-3].lval
+		}
+	case 95:
+		//line a.y:501
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(x86.D_INDIR + yyS[yypt-1].lval)
+			yyVAL.addr.Offset = yyS[yypt-3].lval
+		}
+	case 96:
+		//line a.y:507
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(x86.D_INDIR + x86.D_NONE)
+			yyVAL.addr.Offset = yyS[yypt-5].lval
+			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
+			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
+			checkscale(yyVAL.addr.Scale)
+		}
+	case 97:
+		//line a.y:516
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(x86.D_INDIR + yyS[yypt-6].lval)
+			yyVAL.addr.Offset = yyS[yypt-8].lval
+			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
+			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
+			checkscale(yyVAL.addr.Scale)
+		}
+	case 98:
+		//line a.y:525
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(x86.D_INDIR + yyS[yypt-6].lval)
+			yyVAL.addr.Offset = yyS[yypt-8].lval
+			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
+			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
+			checkscale(yyVAL.addr.Scale)
+		}
+	case 99:
+		//line a.y:534
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(x86.D_INDIR + yyS[yypt-1].lval)
+		}
+	case 100:
+		//line a.y:539
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(x86.D_INDIR + x86.D_SP)
+		}
+	case 101:
+		//line a.y:544
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(x86.D_INDIR + x86.D_NONE)
+			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
+			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
+			checkscale(yyVAL.addr.Scale)
+		}
+	case 102:
+		//line a.y:552
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(x86.D_INDIR + yyS[yypt-6].lval)
+			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
+			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
+			checkscale(yyVAL.addr.Scale)
+		}
+	case 103:
+		//line a.y:562
+		{
+			yyVAL.addr = yyS[yypt-0].addr
+		}
+	case 104:
+		//line a.y:566
+		{
+			yyVAL.addr = yyS[yypt-5].addr
+			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
+			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
+			checkscale(yyVAL.addr.Scale)
+		}
+	case 105:
+		//line a.y:575
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(yyS[yypt-1].lval)
+			yyVAL.addr.Sym = obj.Linklookup(asm.Ctxt, yyS[yypt-4].sym.Name, 0)
+			yyVAL.addr.Offset = yyS[yypt-3].lval
+		}
+	case 106:
+		//line a.y:582
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = x86.D_STATIC
+			yyVAL.addr.Sym = obj.Linklookup(asm.Ctxt, yyS[yypt-6].sym.Name, 1)
+			yyVAL.addr.Offset = yyS[yypt-3].lval
+		}
+	case 107:
+		//line a.y:590
+		{
+			yyVAL.lval = 0
+		}
+	case 108:
+		//line a.y:594
+		{
+			yyVAL.lval = yyS[yypt-0].lval
+		}
+	case 109:
+		//line a.y:598
+		{
+			yyVAL.lval = -yyS[yypt-0].lval
+		}
+	case 110:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 111:
+		//line a.y:605
+		{
+			yyVAL.lval = x86.D_AUTO
+		}
+	case 112:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 113:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 114:
+		//line a.y:613
+		{
+			yyVAL.lval = yyS[yypt-0].sym.Value
+		}
+	case 115:
+		//line a.y:617
+		{
+			yyVAL.lval = -yyS[yypt-0].lval
+		}
+	case 116:
+		//line a.y:621
+		{
+			yyVAL.lval = yyS[yypt-0].lval
+		}
+	case 117:
+		//line a.y:625
+		{
+			yyVAL.lval = ^yyS[yypt-0].lval
+		}
+	case 118:
+		//line a.y:629
+		{
+			yyVAL.lval = yyS[yypt-1].lval
+		}
+	case 119:
+		//line a.y:635
+		{
+			yyVAL.lval = int64(uint64(yyS[yypt-0].lval&0xffffffff) + (obj.ArgsSizeUnknown << 32))
+		}
+	case 120:
+		//line a.y:639
+		{
+			yyVAL.lval = int64(uint64(-yyS[yypt-0].lval&0xffffffff) + (obj.ArgsSizeUnknown << 32))
+		}
+	case 121:
+		//line a.y:643
+		{
+			yyVAL.lval = (yyS[yypt-2].lval & 0xffffffff) + ((yyS[yypt-0].lval & 0xffff) << 32)
+		}
+	case 122:
+		//line a.y:647
+		{
+			yyVAL.lval = (-yyS[yypt-2].lval & 0xffffffff) + ((yyS[yypt-0].lval & 0xffff) << 32)
+		}
+	case 123:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 124:
+		//line a.y:654
+		{
+			yyVAL.lval = yyS[yypt-2].lval + yyS[yypt-0].lval
+		}
+	case 125:
+		//line a.y:658
+		{
+			yyVAL.lval = yyS[yypt-2].lval - yyS[yypt-0].lval
+		}
+	case 126:
+		//line a.y:662
+		{
+			yyVAL.lval = yyS[yypt-2].lval * yyS[yypt-0].lval
+		}
+	case 127:
+		//line a.y:666
+		{
+			yyVAL.lval = yyS[yypt-2].lval / yyS[yypt-0].lval
+		}
+	case 128:
+		//line a.y:670
+		{
+			yyVAL.lval = yyS[yypt-2].lval % yyS[yypt-0].lval
+		}
+	case 129:
+		//line a.y:674
+		{
+			yyVAL.lval = yyS[yypt-3].lval << uint(yyS[yypt-0].lval)
+		}
+	case 130:
+		//line a.y:678
+		{
+			yyVAL.lval = yyS[yypt-3].lval >> uint(yyS[yypt-0].lval)
+		}
+	case 131:
+		//line a.y:682
+		{
+			yyVAL.lval = yyS[yypt-2].lval & yyS[yypt-0].lval
+		}
+	case 132:
+		//line a.y:686
+		{
+			yyVAL.lval = yyS[yypt-2].lval ^ yyS[yypt-0].lval
+		}
+	case 133:
+		//line a.y:690
+		{
+			yyVAL.lval = yyS[yypt-2].lval | yyS[yypt-0].lval
+		}
+	}
+	goto yystack /* stack new state and value */
+}
diff --git a/src/cmd/new8a/a.y b/src/cmd/new8a/a.y
index c810d38577..65081dd102 100644
--- a/src/cmd/new8a/a.y
+++ b/src/cmd/new8a/a.y
@@ -29,24 +29,28 @@
 // THE SOFTWARE.
 
 %{
-#include <u.h>
-#include <stdio.h>	/* if we don't, bison will, and a.h re-#defines getc */
-#include <libc.h>
-#include "a.h"
-#include "../../runtime/funcdata.h"
+package main
+
+import (
+	"cmd/internal/asm"
+	"cmd/internal/obj"
+	. "cmd/internal/obj/i386"
+)
 %}
-%union	{
-	Sym	*sym;
-	int32	lval;
-	struct {
-		int32 v1;
-		int32 v2;
-	} con2;
-	double	dval;
-	char	sval[8];
-	Addr	addr;
-	Addr2	addr2;
+
+%union {
+	sym *asm.Sym
+	lval int64
+	con2 struct {
+		v1 int32
+		v2 int32
+	}
+	dval float64
+	sval string
+	addr obj.Addr
+	addr2 Addr2
 }
+
 %left	'|'
 %left	'^'
 %left	'&'
@@ -69,18 +73,19 @@
 prog:
 |	prog
 	{
-		stmtline = lineno;
+		stmtline = asm.Lineno;
 	}
 	line
 
 line:
 	LNAME ':'
 	{
-		$1 = labellookup($1);
-		if($1->type == LLAB && $1->value != pc)
-			yyerror("redeclaration of %s", $1->labelname);
-		$1->type = LLAB;
-		$1->value = pc;
+		$1 = asm.LabelLookup($1);
+		if $1.Type == LLAB && $1.Value != int64(asm.PC) {
+			yyerror("redeclaration of %s", $1.Labelname)
+		}
+		$1.Type = LLAB;
+		$1.Value = int64(asm.PC)
 	}
 	line
 |	';'
@@ -90,33 +95,34 @@ line:
 inst:
 	LNAME '=' expr
 	{
-		$1->type = LVAR;
-		$1->value = $3;
+		$1.Type = LVAR;
+		$1.Value = $3;
 	}
 |	LVAR '=' expr
 	{
-		if($1->value != $3)
-			yyerror("redeclaration of %s", $1->name);
-		$1->value = $3;
-	}
-|	LTYPE0 nonnon	{ outcode($1, &$2); }
-|	LTYPE1 nonrem	{ outcode($1, &$2); }
-|	LTYPE2 rimnon	{ outcode($1, &$2); }
-|	LTYPE3 rimrem	{ outcode($1, &$2); }
-|	LTYPE4 remrim	{ outcode($1, &$2); }
-|	LTYPER nonrel	{ outcode($1, &$2); }
-|	LTYPED spec1	{ outcode($1, &$2); }
-|	LTYPET spec2	{ outcode($1, &$2); }
-|	LTYPEC spec3	{ outcode($1, &$2); }
-|	LTYPEN spec4	{ outcode($1, &$2); }
-|	LTYPES spec5	{ outcode($1, &$2); }
-|	LTYPEM spec6	{ outcode($1, &$2); }
-|	LTYPEI spec7	{ outcode($1, &$2); }
-|	LTYPEG spec8	{ outcode($1, &$2); }
-|	LTYPEXC spec9	{ outcode($1, &$2); }
-|	LTYPEX spec10	{ outcode($1, &$2); }
-|	LTYPEPC spec11	{ outcode($1, &$2); }
-|	LTYPEF spec12	{ outcode($1, &$2); }
+		if $1.Value != int64($3) {
+			yyerror("redeclaration of %s", $1.Name);
+		}
+		$1.Value = $3;
+	}
+|	LTYPE0 nonnon	{ outcode(int($1), &$2); }
+|	LTYPE1 nonrem	{ outcode(int($1), &$2); }
+|	LTYPE2 rimnon	{ outcode(int($1), &$2); }
+|	LTYPE3 rimrem	{ outcode(int($1), &$2); }
+|	LTYPE4 remrim	{ outcode(int($1), &$2); }
+|	LTYPER nonrel	{ outcode(int($1), &$2); }
+|	LTYPED spec1	{ outcode(int($1), &$2); }
+|	LTYPET spec2	{ outcode(int($1), &$2); }
+|	LTYPEC spec3	{ outcode(int($1), &$2); }
+|	LTYPEN spec4	{ outcode(int($1), &$2); }
+|	LTYPES spec5	{ outcode(int($1), &$2); }
+|	LTYPEM spec6	{ outcode(int($1), &$2); }
+|	LTYPEI spec7	{ outcode(int($1), &$2); }
+|	LTYPEG spec8	{ outcode(int($1), &$2); }
+|	LTYPEXC spec9	{ outcode(int($1), &$2); }
+|	LTYPEX spec10	{ outcode(int($1), &$2); }
+|	LTYPEPC spec11	{ outcode(int($1), &$2); }
+|	LTYPEF spec12	{ outcode(int($1), &$2); }
 
 nonnon:
 	{
@@ -188,22 +194,22 @@ spec1:	/* DATA */
 	nam '/' con ',' imm
 	{
 		$$.from = $1;
-		$$.from.scale = $3;
+		$$.from.Scale = int8($3);
 		$$.to = $5;
 	}
 
 spec2:	/* TEXT */
 	mem ',' imm2
 	{
-		settext($1.sym);
+		asm.Settext($1.Sym);
 		$$.from = $1;
 		$$.to = $3;
 	}
 |	mem ',' con ',' imm2
 	{
-		settext($1.sym);
+		asm.Settext($1.Sym);
 		$$.from = $1;
-		$$.from.scale = $3;
+		$$.from.Scale = int8($3);
 		$$.to = $5;
 	}
 
@@ -222,8 +228,8 @@ spec3:	/* JMP/CALL */
 	{
 		$$.from = nullgen;
 		$$.to = $2;
-		$$.to.index = $2.type;
-		$$.to.type = D_INDIR+D_ADDR;
+		$$.to.Index = uint8($2.Type_)
+		$$.to.Type_ = D_INDIR+D_ADDR;
 	}
 
 spec4:	/* NOP */
@@ -240,9 +246,10 @@ spec5:	/* SHL/SHR */
 	{
 		$$.from = $1;
 		$$.to = $3;
-		if($$.from.index != D_NONE)
+		if $$.from.Index != D_NONE {
 			yyerror("dp shift with lhs index");
-		$$.from.index = $5;
+		}
+		$$.from.Index = uint8($5);
 	}
 
 spec6:	/* MOVW/MOVL */
@@ -255,9 +262,10 @@ spec6:	/* MOVW/MOVL */
 	{
 		$$.from = $1;
 		$$.to = $3;
-		if($$.to.index != D_NONE)
+		if $$.to.Index != D_NONE {
 			yyerror("dp move with lhs index");
-		$$.to.index = $5;
+		}
+		$$.to.Index = uint8($5);
 	}
 
 spec7:
@@ -286,7 +294,7 @@ spec8:	/* GLOBL */
 |	mem ',' con ',' imm
 	{
 		$$.from = $1;
-		$$.from.scale = $3;
+		$$.from.Scale = int8($3);
 		$$.to = $5;
 	}
 
@@ -295,7 +303,7 @@ spec9:	/* CMPPS/CMPPD */
 	{
 		$$.from = $1;
 		$$.to = $3;
-		$$.to.offset = $5;
+		$$.to.Offset = $5;
 	}
 
 spec10:	/* PINSRD */
@@ -303,16 +311,18 @@ spec10:	/* PINSRD */
 	{
 		$$.from = $3;
 		$$.to = $5;
-		if($1.type != D_CONST)
-			yyerror("illegal constant");
-		$$.to.offset = $1.offset;
+		if $1.Type_ != D_CONST {
+			yyerror("illegal constant")
+		}
+		$$.to.Offset = $1.Offset;
 	}
 
 spec11:	/* PCDATA */
 	rim ',' rim
 	{
-		if($1.type != D_CONST || $3.type != D_CONST)
+		if $1.Type_ != D_CONST || $3.Type_ != D_CONST {
 			yyerror("arguments to PCDATA must be integer constants");
+		}
 		$$.from = $1;
 		$$.to = $3;
 	}
@@ -320,10 +330,12 @@ spec11:	/* PCDATA */
 spec12:	/* FUNCDATA */
 	rim ',' rim
 	{
-		if($1.type != D_CONST)
+		if $1.Type_ != D_CONST {
 			yyerror("index for FUNCDATA must be integer constant");
-		if($3.type != D_EXTERN && $3.type != D_STATIC)
+		}
+		if $3.Type_ != D_EXTERN && $3.Type_ != D_STATIC {
 			yyerror("value for FUNCDATA must be symbol reference");
+		}
  		$$.from = $1;
  		$$.to = $3;
  	}
@@ -355,129 +367,130 @@ rel:
 	con '(' LPC ')'
 	{
 		$$ = nullgen;
-		$$.type = D_BRANCH;
-		$$.offset = $1 + pc;
+		$$.Type_ = D_BRANCH;
+		$$.Offset = $1 + int64(asm.PC);
 	}
 |	LNAME offset
 	{
-		$1 = labellookup($1);
+		$1 = asm.LabelLookup($1);
 		$$ = nullgen;
-		if(pass == 2 && $1->type != LLAB)
-			yyerror("undefined label: %s", $1->labelname);
-		$$.type = D_BRANCH;
-		$$.offset = $1->value + $2;
+		if asm.Pass == 2 && $1.Type != LLAB {
+			yyerror("undefined label: %s", $1.Labelname);
+		}
+		$$.Type_ = D_BRANCH;
+		$$.Offset = $1.Value + $2;
 	}
 
 reg:
 	LBREG
 	{
 		$$ = nullgen;
-		$$.type = $1;
+		$$.Type_ = int16($1);
 	}
 |	LFREG
 	{
 		$$ = nullgen;
-		$$.type = $1;
+		$$.Type_ = int16($1);
 	}
 |	LLREG
 	{
 		$$ = nullgen;
-		$$.type = $1;
+		$$.Type_ = int16($1);
 	}
 |	LXREG
 	{
 		$$ = nullgen;
-		$$.type = $1;
+		$$.Type_ = int16($1);
 	}
 |	LSP
 	{
 		$$ = nullgen;
-		$$.type = D_SP;
+		$$.Type_ = D_SP;
 	}
 |	LSREG
 	{
 		$$ = nullgen;
-		$$.type = $1;
+		$$.Type_ = int16($1);
 	}
 
 imm:
 	'$' con
 	{
 		$$ = nullgen;
-		$$.type = D_CONST;
-		$$.offset = $2;
+		$$.Type_ = D_CONST;
+		$$.Offset = $2;
 	}
 |	'$' nam
 	{
 		$$ = $2;
-		$$.index = $2.type;
-		$$.type = D_ADDR;
+		$$.Index = uint8($2.Type_);
+		$$.Type_ = D_ADDR;
 		/*
-		if($2.type == D_AUTO || $2.type == D_PARAM)
+		if($2.Type_ == D_AUTO || $2.Type_ == D_PARAM)
 			yyerror("constant cannot be automatic: %s",
-				$2.sym->name);
+				$2.Sym.name);
 		 */
 	}
 |	'$' LSCONST
 	{
 		$$ = nullgen;
-		$$.type = D_SCONST;
-		memcpy($$.u.sval, $2, sizeof($$.u.sval));
+		$$.Type_ = D_SCONST;
+		$$.U.Sval = $2
 	}
 |	'$' LFCONST
 	{
 		$$ = nullgen;
-		$$.type = D_FCONST;
-		$$.u.dval = $2;
+		$$.Type_ = D_FCONST;
+		$$.U.Dval = $2;
 	}
 |	'$' '(' LFCONST ')'
 	{
 		$$ = nullgen;
-		$$.type = D_FCONST;
-		$$.u.dval = $3;
+		$$.Type_ = D_FCONST;
+		$$.U.Dval = $3;
 	}
 |	'$' '(' '-' LFCONST ')'
 	{
 		$$ = nullgen;
-		$$.type = D_FCONST;
-		$$.u.dval = -$4;
+		$$.Type_ = D_FCONST;
+		$$.U.Dval = -$4;
 	}
 |	'$' '-' LFCONST
 	{
 		$$ = nullgen;
-		$$.type = D_FCONST;
-		$$.u.dval = -$3;
+		$$.Type_ = D_FCONST;
+		$$.U.Dval = -$3;
 	}
 
 imm2:
 	'$' con2
 	{
 		$$ = nullgen;
-		$$.type = D_CONST2;
-		$$.offset = $2.v1;
-		$$.offset2 = $2.v2;
+		$$.Type_ = D_CONST2;
+		$$.Offset = int64($2.v1);
+		$$.Offset2 = int32($2.v2);
 	}
 
 con2:
 	LCONST
 	{
-		$$.v1 = $1;
-		$$.v2 = ArgsSizeUnknown;
+		$$.v1 = int32($1);
+		$$.v2 = -obj.ArgsSizeUnknown
 	}
 |	'-' LCONST
 	{
-		$$.v1 = -$2;
-		$$.v2 = ArgsSizeUnknown;
+		$$.v1 = int32(-$2);
+		$$.v2 = -obj.ArgsSizeUnknown;
 	}
 |	LCONST '-' LCONST
 	{
-		$$.v1 = $1;
-		$$.v2 = $3;
+		$$.v1 = int32($1);
+		$$.v2 = int32($3);
 	}
 |	'-' LCONST '-' LCONST
 	{
-		$$.v1 = -$2;
-		$$.v2 = $4;
+		$$.v1 = int32(-$2);
+		$$.v2 = int32($4);
 	}
 
 mem:
@@ -488,79 +501,79 @@ omem:
 	con
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+D_NONE;
-		$$.offset = $1;
+		$$.Type_ = D_INDIR+D_NONE;
+		$$.Offset = $1;
 	}
 |	con '(' LLREG ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+$3;
-		$$.offset = $1;
+		$$.Type_ = int16(D_INDIR+$3);
+		$$.Offset = $1;
 	}
 |	con '(' LSP ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+D_SP;
-		$$.offset = $1;
+		$$.Type_ = D_INDIR+D_SP;
+		$$.Offset = $1;
 	}
 |	con '(' LLREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+D_NONE;
-		$$.offset = $1;
-		$$.index = $3;
-		$$.scale = $5;
-		checkscale($$.scale);
+		$$.Type_ = D_INDIR+D_NONE;
+		$$.Offset = $1;
+		$$.Index = uint8($3);
+		$$.Scale = int8($5);
+		checkscale($$.Scale);
 	}
 |	con '(' LLREG ')' '(' LLREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+$3;
-		$$.offset = $1;
-		$$.index = $6;
-		$$.scale = $8;
-		checkscale($$.scale);
+		$$.Type_ = int16(D_INDIR+$3);
+		$$.Offset = $1;
+		$$.Index = uint8($6);
+		$$.Scale = int8($8);
+		checkscale($$.Scale);
 	}
 |	con '(' LLREG ')' '(' LSREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+$3;
-		$$.offset = $1;
-		$$.index = $6;
-		$$.scale = $8;
-		checkscale($$.scale);
+		$$.Type_ = int16(D_INDIR+$3);
+		$$.Offset = $1;
+		$$.Index = uint8($6);
+		$$.Scale = int8($8);
+		checkscale($$.Scale);
 	}
 |	'(' LLREG ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+$2;
+		$$.Type_ = int16(D_INDIR+$2);
 	}
 |	'(' LSP ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+D_SP;
+		$$.Type_ = D_INDIR+D_SP;
 	}
 |	con '(' LSREG ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+$3;
-		$$.offset = $1;
+		$$.Type_ = int16(D_INDIR+$3);
+		$$.Offset = $1;
 	}
 |	'(' LLREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+D_NONE;
-		$$.index = $2;
-		$$.scale = $4;
-		checkscale($$.scale);
+		$$.Type_ = D_INDIR+D_NONE;
+		$$.Index = uint8($2);
+		$$.Scale = int8($4);
+		checkscale($$.Scale);
 	}
 |	'(' LLREG ')' '(' LLREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.type = D_INDIR+$2;
-		$$.index = $5;
-		$$.scale = $7;
-		checkscale($$.scale);
+		$$.Type_ = int16(D_INDIR+$2);
+		$$.Index = uint8($5);
+		$$.Scale = int8($7);
+		checkscale($$.Scale);
 	}
 
 nmem:
@@ -571,25 +584,25 @@ nmem:
 |	nam '(' LLREG '*' con ')'
 	{
 		$$ = $1;
-		$$.index = $3;
-		$$.scale = $5;
-		checkscale($$.scale);
+		$$.Index = uint8($3);
+		$$.Scale = int8($5);
+		checkscale($$.Scale);
 	}
 
 nam:
 	LNAME offset '(' pointer ')'
 	{
 		$$ = nullgen;
-		$$.type = $4;
-		$$.sym = linklookup(ctxt, $1->name, 0);
-		$$.offset = $2;
+		$$.Type_ = int16($4);
+		$$.Sym = obj.Linklookup(asm.Ctxt, $1.Name, 0);
+		$$.Offset = $2;
 	}
 |	LNAME '<' '>' offset '(' LSB ')'
 	{
 		$$ = nullgen;
-		$$.type = D_STATIC;
-		$$.sym = linklookup(ctxt, $1->name, 1);
-		$$.offset = $4;
+		$$.Type_ = D_STATIC;
+		$$.Sym = obj.Linklookup(asm.Ctxt, $1.Name, 1);
+		$$.Offset = $4;
 	}
 
 offset:
@@ -617,7 +630,7 @@ con:
 	LCONST
 |	LVAR
 	{
-		$$ = $1->value;
+		$$ = $1.Value;
 	}
 |	'-' con
 	{
@@ -629,7 +642,7 @@ con:
 	}
 |	'~' con
 	{
-		$$ = ~$2;
+		$$ = ^$2;
 	}
 |	'(' expr ')'
 	{
@@ -660,11 +673,11 @@ expr:
 	}
 |	expr '<' '<' expr
 	{
-		$$ = $1 << $4;
+		$$ = $1 << uint($4);
 	}
 |	expr '>' '>' expr
 	{
-		$$ = $1 >> $4;
+		$$ = $1 >> uint($4);
 	}
 |	expr '&' expr
 	{
diff --git a/src/cmd/new8a/lex.go b/src/cmd/new8a/lex.go
index f9ea92a92f..3aebe6b2ec 100644
--- a/src/cmd/new8a/lex.go
+++ b/src/cmd/new8a/lex.go
@@ -28,166 +28,64 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+//go:generate go tool yacc a.y
+
 package main
 
-const (
-	Plan9   = 1 << 0
-	Unix    = 1 << 1
-	Windows = 1 << 2
+import (
+	"cmd/internal/asm"
+	"cmd/internal/obj"
+	"cmd/internal/obj/i386"
 )
 
-func systemtype(sys int) int {
-	return sys & Windows
-
-	return sys & Plan9
-}
-
-func pathchar() int {
-	return '/'
-}
-
-func Lconv(fp *obj.Fmt) int {
-	return obj.Linklinefmt(ctxt, fp)
-}
-
-func dodef(p string) {
-	if nDlist%8 == 0 {
-		Dlist = allocn(Dlist, nDlist*sizeof(string), 8*sizeof(string)).(*string)
-	}
-	Dlist[nDlist] = p
-	nDlist++
-}
-
-func usage() {
-	fmt.Printf("usage: %ca [options] file.c...\n", thechar)
-	main.Flagprint(1)
-	errorexit()
-}
-
-func main(argc int, argv [XXX]string) {
-	var p string
-
-	thechar = '8'
-	thestring = "386"
-
-	ctxt = obj.Linknew(&i386.Link386)
-	ctxt.Diag = yyerror
-	ctxt.Bso = &bstdout
-	ctxt.Enforce_data_order = 1
-	obj.Binit(&bstdout, 1, main.OWRITE)
-	i386.Listinit8()
-	obj.Fmtinstall('L', Lconv)
-
-	// Allow GOARCH=thestring or GOARCH=thestringsuffix,
-	// but not other values.
-	p = Getgoarch()
-
-	if !strings.HasPrefix(p, thestring) {
-		log.Fatalf("cannot use %cc with GOARCH=%s", thechar, p)
-	}
+var (
+	yyerror  = asm.Yyerror
+	nullgen  obj.Addr
+	stmtline int32
+)
 
-	ensuresymb(NSYMB)
-	debug = [256]int{}
+func main() {
 	cinit()
-	outfile = ""
-	setinclude(".")
 
-	main.Flagfn1("D", "name[=value]: add #define", dodef)
-	main.Flagfn1("I", "dir: add dir to include path", setinclude)
-	main.Flagcount("S", "print assembly and machine code", &debug['S'])
-	main.Flagcount("m", "debug preprocessor macros", &debug['m'])
-	main.Flagstr("o", "file: set output file", &outfile)
-	main.Flagstr("trimpath", "prefix: remove prefix from recorded source file paths", &ctxt.Trimpath)
+	asm.LSCONST = LSCONST
+	asm.LCONST = LCONST
+	asm.LFCONST = LFCONST
+	asm.LNAME = LNAME
+	asm.LVAR = LVAR
+	asm.LLAB = LLAB
 
-	main.Flagparse(&argc, (**string)(&argv), usage)
-	ctxt.Debugasm = int32(debug['S'])
+	asm.Lexinit = lexinit
+	asm.Cclean = cclean
+	asm.Yyparse = yyparse
 
-	if argc < 1 {
-		usage()
-	}
-	if argc > 1 {
-		fmt.Printf("can't assemble multiple files\n")
-		errorexit()
-	}
+	asm.Thechar = '8'
+	asm.Thestring = "386"
+	asm.Thelinkarch = &i386.Link386
 
-	if assemble(argv[0]) != 0 {
-		errorexit()
-	}
-	obj.Bflush(&bstdout)
-	if nerrors > 0 {
-		errorexit()
-	}
-	main.Exits("")
+	asm.Main()
 }
 
-func assemble(file string) int {
-	var ofile string
-	var p string
-	var i int
-	var of int
-
-	ofile = alloc(int32(len(file)) + 3).(string) // +3 for .x\0 (x=thechar)
-	ofile = file
-	p = main.Utfrrune(ofile, uint(pathchar()))
-	if p != "" {
-		include[0] = ofile
-		p = ""
-		p = p[1:]
-	} else {
-
-		p = ofile
-	}
-	if outfile == "" {
-		outfile = p
-		if outfile != "" {
-			p = main.Utfrrune(outfile, '.')
-			if p != "" {
-				if p[1] == 's' && p[2] == 0 {
-					p = ""
-				}
-			}
-			p = main.Utfrune(outfile, 0)
-			p[0] = '.'
-			p[1] = byte(thechar)
-			p[2] = 0
-		} else {
-
-			outfile = "/dev/null"
-		}
-	}
-
-	of = main.Create(outfile, main.OWRITE, 0664)
-	if of < 0 {
-		yyerror("%ca: cannot create %s", thechar, outfile)
-		errorexit()
-	}
+type yy struct{}
 
-	obj.Binit(&obuf, of, main.OWRITE)
-	fmt.Fprintf(&obuf, "go object %s %s %s\n", main.Getgoos(), main.Getgoarch(), main.Getgoversion())
-	fmt.Fprintf(&obuf, "!\n")
+func (yy) Lex(v *yySymType) int {
+	var av asm.Yylval
+	tok := asm.Yylex(&av)
+	v.sym = av.Sym
+	v.lval = av.Lval
+	v.sval = av.Sval
+	v.dval = av.Dval
+	return tok
+}
 
-	for pass = 1; pass <= 2; pass++ {
-		pinit(file)
-		for i = 0; i < nDlist; i++ {
-			dodefine(Dlist[i])
-		}
-		yyparse()
-		cclean()
-		if nerrors != 0 {
-			return nerrors
-		}
-	}
+func (yy) Error(msg string) {
+	asm.Yyerror("%s", msg)
+}
 
-	obj.Writeobj(ctxt, &obuf)
-	obj.Bflush(&obuf)
-	return 0
+func yyparse() {
+	yyParse(yy{})
 }
 
-var itab = []struct {
-	name  string
-	type_ uint16
-	value uint16
-}{
+var lexinit = []asm.Lextab{
 	{"SP", LSP, i386.D_AUTO},
 	{"SB", LSB, i386.D_EXTERN},
 	{"FP", LFP, i386.D_PARAM},
@@ -804,31 +702,11 @@ var itab = []struct {
 }
 
 func cinit() {
-	var s *Sym
-	var i int
-
 	nullgen.Type_ = i386.D_NONE
 	nullgen.Index = i386.D_NONE
-
-	nerrors = 0
-	iostack = nil
-	iofree = nil
-	peekc = IGN
-	nhunk = 0
-	for i = 0; i < NHASH; i++ {
-		hash[i] = nil
-	}
-	for i = 0; itab[i].name != ""; i++ {
-		s = slookup(itab[i].name)
-		if s.type_ != LNAME {
-			yyerror("double initialization %s", itab[i].name)
-		}
-		s.type_ = itab[i].type_
-		s.value = int32(itab[i].value)
-	}
 }
 
-func checkscale(scale int) {
+func checkscale(scale int8) {
 	switch scale {
 	case 1,
 		2,
@@ -840,9 +718,9 @@ func checkscale(scale int) {
 	yyerror("scale must be 1248: %d", scale)
 }
 
-func syminit(s *Sym) {
-	s.type_ = LNAME
-	s.value = 0
+func syminit(s *asm.Sym) {
+	s.Type = LNAME
+	s.Value = 0
 }
 
 func cclean() {
@@ -855,24 +733,30 @@ func cclean() {
 
 var lastpc *obj.Prog
 
+type Addr2 struct {
+	from obj.Addr
+	to   obj.Addr
+}
+
 func outcode(a int, g2 *Addr2) {
 	var p *obj.Prog
 	var pl *obj.Plist
 
-	if pass == 1 {
+	if asm.Pass == 1 {
 		goto out
 	}
 
 	p = new(obj.Prog)
 	*p = obj.Prog{}
+	p.Ctxt = asm.Ctxt
 	p.As = int16(a)
 	p.Lineno = stmtline
 	p.From = g2.from
 	p.To = g2.to
-	p.Pc = int64(pc)
+	p.Pc = int64(asm.PC)
 
 	if lastpc == nil {
-		pl = obj.Linknewplist(ctxt)
+		pl = obj.Linknewplist(asm.Ctxt)
 		pl.Firstpc = p
 	} else {
 
@@ -882,6 +766,6 @@ func outcode(a int, g2 *Addr2) {
 
 out:
 	if a != i386.AGLOBL && a != i386.ADATA {
-		pc++
+		asm.PC++
 	}
 }
diff --git a/src/cmd/new8a/y.go b/src/cmd/new8a/y.go
new file mode 100644
index 0000000000..e1ac614018
--- /dev/null
+++ b/src/cmd/new8a/y.go
@@ -0,0 +1,1306 @@
+//line a.y:32
+package main
+
+import __yyfmt__ "fmt"
+
+//line a.y:32
+import (
+	"cmd/internal/asm"
+	"cmd/internal/obj"
+	. "cmd/internal/obj/i386"
+)
+
+//line a.y:41
+type yySymType struct {
+	yys  int
+	sym  *asm.Sym
+	lval int64
+	con2 struct {
+		v1 int32
+		v2 int32
+	}
+	dval  float64
+	sval  string
+	addr  obj.Addr
+	addr2 Addr2
+}
+
+const LTYPE0 = 57346
+const LTYPE1 = 57347
+const LTYPE2 = 57348
+const LTYPE3 = 57349
+const LTYPE4 = 57350
+const LTYPEC = 57351
+const LTYPED = 57352
+const LTYPEN = 57353
+const LTYPER = 57354
+const LTYPET = 57355
+const LTYPES = 57356
+const LTYPEM = 57357
+const LTYPEI = 57358
+const LTYPEG = 57359
+const LTYPEXC = 57360
+const LTYPEX = 57361
+const LTYPEPC = 57362
+const LTYPEF = 57363
+const LCONST = 57364
+const LFP = 57365
+const LPC = 57366
+const LSB = 57367
+const LBREG = 57368
+const LLREG = 57369
+const LSREG = 57370
+const LFREG = 57371
+const LXREG = 57372
+const LFCONST = 57373
+const LSCONST = 57374
+const LSP = 57375
+const LNAME = 57376
+const LLAB = 57377
+const LVAR = 57378
+
+var yyToknames = []string{
+	"'|'",
+	"'^'",
+	"'&'",
+	"'<'",
+	"'>'",
+	"'+'",
+	"'-'",
+	"'*'",
+	"'/'",
+	"'%'",
+	"LTYPE0",
+	"LTYPE1",
+	"LTYPE2",
+	"LTYPE3",
+	"LTYPE4",
+	"LTYPEC",
+	"LTYPED",
+	"LTYPEN",
+	"LTYPER",
+	"LTYPET",
+	"LTYPES",
+	"LTYPEM",
+	"LTYPEI",
+	"LTYPEG",
+	"LTYPEXC",
+	"LTYPEX",
+	"LTYPEPC",
+	"LTYPEF",
+	"LCONST",
+	"LFP",
+	"LPC",
+	"LSB",
+	"LBREG",
+	"LLREG",
+	"LSREG",
+	"LFREG",
+	"LXREG",
+	"LFCONST",
+	"LSCONST",
+	"LSP",
+	"LNAME",
+	"LLAB",
+	"LVAR",
+}
+var yyStatenames = []string{}
+
+const yyEofCode = 1
+const yyErrCode = 2
+const yyMaxDepth = 200
+
+//line yacctab:1
+var yyExca = []int{
+	-1, 1,
+	1, -1,
+	-2, 2,
+}
+
+const yyNprod = 132
+const yyPrivate = 57344
+
+var yyTokenNames []string
+var yyStates []string
+
+const yyLast = 586
+
+var yyAct = []int{
+
+	47, 37, 59, 185, 45, 120, 80, 3, 49, 78,
+	60, 187, 268, 57, 267, 69, 208, 68, 85, 82,
+	84, 67, 83, 169, 73, 100, 62, 102, 46, 109,
+	266, 115, 109, 92, 94, 96, 262, 255, 253, 104,
+	106, 241, 239, 237, 221, 219, 81, 210, 209, 109,
+	170, 240, 234, 117, 118, 119, 231, 207, 211, 173,
+	108, 125, 144, 110, 168, 135, 116, 69, 112, 126,
+	230, 229, 109, 133, 53, 52, 136, 223, 85, 82,
+	84, 142, 83, 222, 143, 153, 152, 139, 141, 151,
+	58, 150, 145, 149, 148, 53, 52, 50, 147, 146,
+	138, 36, 113, 134, 64, 132, 81, 131, 114, 36,
+	124, 51, 33, 31, 30, 154, 71, 29, 50, 54,
+	27, 228, 28, 175, 176, 227, 111, 220, 165, 167,
+	109, 117, 51, 55, 166, 69, 247, 71, 184, 186,
+	54, 182, 142, 246, 183, 143, 181, 165, 167, 236,
+	192, 172, 191, 166, 251, 252, 109, 109, 109, 109,
+	109, 256, 183, 109, 109, 109, 195, 196, 263, 257,
+	212, 226, 217, 245, 215, 53, 130, 137, 34, 117,
+	218, 111, 216, 38, 260, 259, 32, 197, 198, 199,
+	200, 201, 254, 225, 204, 205, 206, 89, 50, 121,
+	75, 122, 123, 109, 109, 88, 98, 128, 127, 235,
+	55, 213, 51, 258, 238, 122, 123, 129, 203, 244,
+	54, 174, 180, 202, 6, 242, 107, 243, 157, 158,
+	159, 249, 248, 250, 232, 233, 2, 188, 189, 190,
+	1, 193, 194, 105, 39, 41, 44, 40, 42, 103,
+	7, 43, 101, 99, 97, 261, 95, 93, 91, 87,
+	264, 265, 9, 10, 11, 12, 13, 17, 15, 18,
+	14, 16, 19, 20, 21, 22, 23, 24, 25, 26,
+	53, 52, 79, 163, 162, 160, 161, 155, 156, 157,
+	158, 159, 4, 76, 8, 74, 5, 72, 63, 61,
+	53, 52, 140, 50, 56, 65, 224, 39, 41, 44,
+	40, 42, 214, 0, 43, 86, 0, 51, 0, 0,
+	0, 77, 48, 50, 60, 54, 0, 39, 41, 44,
+	40, 42, 53, 52, 43, 86, 0, 51, 0, 0,
+	0, 0, 48, 0, 60, 54, 155, 156, 157, 158,
+	159, 0, 53, 52, 0, 50, 0, 0, 0, 39,
+	41, 44, 40, 42, 0, 0, 43, 55, 0, 51,
+	0, 0, 53, 52, 48, 50, 60, 54, 0, 39,
+	41, 44, 40, 42, 0, 0, 43, 55, 0, 51,
+	0, 0, 0, 90, 48, 50, 0, 54, 0, 39,
+	41, 44, 40, 42, 53, 52, 43, 55, 0, 51,
+	0, 0, 0, 35, 48, 0, 0, 54, 0, 0,
+	53, 52, 0, 0, 53, 52, 0, 50, 0, 0,
+	0, 39, 41, 44, 40, 42, 0, 0, 43, 55,
+	0, 51, 0, 50, 53, 52, 48, 50, 0, 54,
+	0, 39, 41, 44, 40, 42, 0, 51, 43, 53,
+	52, 51, 71, 0, 60, 54, 48, 50, 0, 54,
+	164, 163, 162, 160, 161, 155, 156, 157, 158, 159,
+	0, 51, 50, 0, 53, 52, 71, 0, 187, 54,
+	53, 52, 0, 0, 70, 0, 51, 0, 0, 0,
+	66, 71, 0, 60, 54, 53, 178, 50, 0, 0,
+	0, 53, 52, 50, 0, 53, 52, 0, 171, 70,
+	0, 51, 179, 0, 0, 0, 71, 51, 50, 54,
+	0, 0, 71, 0, 50, 54, 0, 177, 50, 0,
+	0, 0, 51, 0, 0, 0, 55, 71, 51, 0,
+	54, 0, 51, 48, 0, 0, 54, 71, 0, 0,
+	54, 164, 163, 162, 160, 161, 155, 156, 157, 158,
+	159, 162, 160, 161, 155, 156, 157, 158, 159, 160,
+	161, 155, 156, 157, 158, 159,
+}
+var yyPact = []int{
+
+	-1000, -1000, 248, -1000, 73, -1000, 69, 66, 64, 62,
+	363, 323, 323, 395, 450, 89, 502, 271, 343, 323,
+	323, 323, 502, 208, -43, 323, 323, -1000, 506, -1000,
+	-1000, 506, -1000, -1000, -1000, 395, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, 17, 65, 15,
+	-1000, -1000, 506, 506, 506, 192, -1000, 60, -1000, -1000,
+	166, -1000, 57, -1000, 55, -1000, 475, -1000, 53, 14,
+	206, 506, -1000, 165, -1000, 50, -1000, 291, -1000, 395,
+	-1000, -1000, -1000, -1000, -1000, 11, 192, -1000, -1000, -1000,
+	395, -1000, 49, -1000, 48, -1000, 44, -1000, 43, -1000,
+	41, -1000, 39, -1000, 36, -1000, 35, 248, 557, -1000,
+	557, -1000, 91, 12, -2, 466, 114, -1000, -1000, -1000,
+	8, 213, 506, 506, -1000, -1000, -1000, -1000, -1000, 496,
+	481, 395, 323, -1000, 475, 128, -1000, 506, 435, -1000,
+	415, -1000, -1000, -1000, 110, 8, 395, 395, 395, 411,
+	395, 395, 323, 323, -1000, 506, 506, 506, 506, 506,
+	216, 210, 506, 506, 506, 5, -4, -5, 7, 506,
+	-1000, -1000, 200, 139, 206, -1000, -1000, -7, 86, -1000,
+	-1000, -1000, -1000, -8, 33, -1000, 27, 161, 78, 74,
+	-1000, -1000, 21, 20, 6, -1000, -1000, 217, 217, -1000,
+	-1000, -1000, 506, 506, 572, 565, 278, 1, 506, -1000,
+	-1000, 112, -9, 506, -10, -1000, -1000, -1000, 0, -1000,
+	-11, -1000, -43, -42, -1000, 209, 141, 106, 98, -43,
+	506, 208, 337, 337, 117, -14, 181, -1000, -15, -1000,
+	126, -1000, -1000, -1000, 137, 203, -1000, -1000, -1000, -1000,
+	-1000, 174, 173, -1000, 506, -1000, -16, -1000, 136, 506,
+	506, -22, -1000, -1000, -38, -40, -1000, -1000, -1000,
+}
+var yyPgo = []int{
+
+	0, 0, 31, 312, 5, 306, 183, 2, 3, 1,
+	8, 6, 90, 13, 9, 4, 28, 186, 305, 178,
+	304, 299, 298, 297, 295, 293, 259, 258, 257, 256,
+	254, 253, 252, 249, 243, 240, 236, 7, 226, 224,
+}
+var yyR1 = []int{
+
+	0, 35, 36, 35, 38, 37, 37, 37, 37, 39,
+	39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
+	39, 39, 39, 39, 39, 39, 39, 39, 39, 17,
+	17, 21, 22, 20, 20, 19, 19, 18, 18, 18,
+	23, 24, 24, 25, 25, 25, 26, 26, 27, 27,
+	28, 28, 29, 29, 29, 30, 30, 31, 32, 33,
+	34, 12, 12, 14, 14, 14, 14, 14, 14, 14,
+	13, 13, 11, 11, 9, 9, 9, 9, 9, 9,
+	7, 7, 7, 7, 7, 7, 7, 8, 5, 5,
+	5, 5, 6, 6, 15, 15, 15, 15, 15, 15,
+	15, 15, 15, 15, 15, 16, 16, 10, 10, 4,
+	4, 4, 3, 3, 3, 1, 1, 1, 1, 1,
+	1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2,
+}
+var yyR2 = []int{
+
+	0, 0, 0, 3, 0, 4, 1, 2, 2, 3,
+	3, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 0,
+	1, 3, 3, 2, 1, 2, 1, 2, 1, 3,
+	5, 3, 5, 2, 1, 2, 1, 1, 3, 5,
+	3, 5, 2, 1, 3, 3, 5, 5, 5, 3,
+	3, 1, 1, 1, 1, 2, 2, 1, 1, 1,
+	1, 1, 4, 2, 1, 1, 1, 1, 1, 1,
+	2, 2, 2, 2, 4, 5, 3, 2, 1, 2,
+	3, 4, 1, 1, 1, 4, 4, 6, 9, 9,
+	3, 3, 4, 5, 8, 1, 6, 5, 7, 0,
+	2, 2, 1, 1, 1, 1, 1, 2, 2, 2,
+	3, 1, 3, 3, 3, 3, 3, 4, 4, 3,
+	3, 3,
+}
+var yyChk = []int{
+
+	-1000, -35, -36, -37, 44, 48, -39, 2, 46, 14,
+	15, 16, 17, 18, 22, 20, 23, 19, 21, 24,
+	25, 26, 27, 28, 29, 30, 31, 47, 49, 48,
+	48, 49, -17, 50, -19, 50, -12, -9, -6, 36,
+	39, 37, 40, 43, 38, -15, -16, -1, 51, -10,
+	32, 46, 10, 9, 54, 44, -20, -13, -12, -7,
+	53, -21, -13, -22, -12, -18, 50, -11, -7, -1,
+	44, 51, -23, -10, -24, -6, -25, 50, -14, 11,
+	-11, -16, -9, -15, -7, -1, 44, -26, -17, -19,
+	50, -27, -13, -28, -13, -29, -13, -30, -6, -31,
+	-9, -32, -7, -33, -13, -34, -13, -38, -2, -1,
+	-2, -12, 51, 37, 43, -2, 51, -1, -1, -1,
+	-4, 7, 9, 10, 50, -1, -10, 42, 41, 51,
+	10, 50, 50, -11, 50, 51, -4, 12, 50, -14,
+	11, -10, -9, -15, 51, -4, 50, 50, 50, 50,
+	50, 50, 50, 50, -37, 9, 10, 11, 12, 13,
+	7, 8, 6, 5, 4, 37, 43, 38, 52, 11,
+	52, 52, 37, 51, 8, -1, -1, 41, 10, 41,
+	-12, -13, -11, 34, -1, -8, -1, 53, -12, -12,
+	-12, -7, -1, -12, -12, -13, -13, -2, -2, -2,
+	-2, -2, 7, 8, -2, -2, -2, 52, 11, 52,
+	52, 51, -1, 11, -3, 35, 43, 33, -4, 52,
+	41, 52, 50, 50, -5, 32, 10, 47, 47, 50,
+	50, 50, -2, -2, 51, -1, 37, 52, -1, 52,
+	51, 52, -7, -8, 10, 32, 37, 38, -7, -1,
+	-9, 37, 38, 52, 11, 52, 35, 32, 10, 11,
+	11, -1, 52, 32, -1, -1, 52, 52, 52,
+}
+var yyDef = []int{
+
+	1, -2, 0, 3, 0, 6, 0, 0, 0, 29,
+	0, 0, 0, 0, 0, 0, 0, 0, 29, 0,
+	0, 0, 0, 0, 0, 0, 0, 4, 0, 7,
+	8, 0, 11, 30, 12, 0, 36, 61, 62, 74,
+	75, 76, 77, 78, 79, 92, 93, 94, 0, 105,
+	115, 116, 0, 0, 0, 109, 13, 34, 70, 71,
+	0, 14, 0, 15, 0, 16, 0, 38, 0, 0,
+	109, 0, 17, 0, 18, 0, 19, 0, 44, 0,
+	63, 64, 67, 68, 69, 94, 109, 20, 46, 47,
+	30, 21, 0, 22, 0, 23, 53, 24, 0, 25,
+	0, 26, 0, 27, 0, 28, 0, 0, 9, 121,
+	10, 35, 0, 0, 0, 0, 0, 117, 118, 119,
+	0, 0, 0, 0, 33, 80, 81, 82, 83, 0,
+	0, 0, 0, 37, 0, 0, 73, 0, 0, 43,
+	0, 45, 65, 66, 0, 73, 0, 0, 52, 0,
+	0, 0, 0, 0, 5, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 100, 0,
+	101, 120, 0, 0, 109, 110, 111, 0, 0, 86,
+	31, 32, 39, 0, 0, 41, 0, 0, 48, 50,
+	54, 55, 0, 0, 0, 59, 60, 122, 123, 124,
+	125, 126, 0, 0, 129, 130, 131, 95, 0, 96,
+	102, 0, 0, 0, 0, 112, 113, 114, 0, 84,
+	0, 72, 0, 0, 87, 88, 0, 0, 0, 0,
+	0, 0, 127, 128, 0, 0, 0, 103, 0, 107,
+	0, 85, 40, 42, 0, 89, 49, 51, 56, 57,
+	58, 0, 0, 97, 0, 106, 0, 90, 0, 0,
+	0, 0, 108, 91, 0, 0, 104, 98, 99,
+}
+var yyTok1 = []int{
+
+	1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 53, 13, 6, 3,
+	51, 52, 11, 9, 50, 10, 3, 12, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 47, 48,
+	7, 49, 8, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 5, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 4, 3, 54,
+}
+var yyTok2 = []int{
+
+	2, 3, 14, 15, 16, 17, 18, 19, 20, 21,
+	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
+	42, 43, 44, 45, 46,
+}
+var yyTok3 = []int{
+	0,
+}
+
+//line yaccpar:1
+
+/*	parser for yacc output	*/
+
+var yyDebug = 0
+
+type yyLexer interface {
+	Lex(lval *yySymType) int
+	Error(s string)
+}
+
+const yyFlag = -1000
+
+func yyTokname(c int) string {
+	// 4 is TOKSTART above
+	if c >= 4 && c-4 < len(yyToknames) {
+		if yyToknames[c-4] != "" {
+			return yyToknames[c-4]
+		}
+	}
+	return __yyfmt__.Sprintf("tok-%v", c)
+}
+
+func yyStatname(s int) string {
+	if s >= 0 && s < len(yyStatenames) {
+		if yyStatenames[s] != "" {
+			return yyStatenames[s]
+		}
+	}
+	return __yyfmt__.Sprintf("state-%v", s)
+}
+
+func yylex1(lex yyLexer, lval *yySymType) int {
+	c := 0
+	char := lex.Lex(lval)
+	if char <= 0 {
+		c = yyTok1[0]
+		goto out
+	}
+	if char < len(yyTok1) {
+		c = yyTok1[char]
+		goto out
+	}
+	if char >= yyPrivate {
+		if char < yyPrivate+len(yyTok2) {
+			c = yyTok2[char-yyPrivate]
+			goto out
+		}
+	}
+	for i := 0; i < len(yyTok3); i += 2 {
+		c = yyTok3[i+0]
+		if c == char {
+			c = yyTok3[i+1]
+			goto out
+		}
+	}
+
+out:
+	if c == 0 {
+		c = yyTok2[1] /* unknown char */
+	}
+	if yyDebug >= 3 {
+		__yyfmt__.Printf("lex %s(%d)\n", yyTokname(c), uint(char))
+	}
+	return c
+}
+
+func yyParse(yylex yyLexer) int {
+	var yyn int
+	var yylval yySymType
+	var yyVAL yySymType
+	yyS := make([]yySymType, yyMaxDepth)
+
+	Nerrs := 0   /* number of errors */
+	Errflag := 0 /* error recovery flag */
+	yystate := 0
+	yychar := -1
+	yyp := -1
+	goto yystack
+
+ret0:
+	return 0
+
+ret1:
+	return 1
+
+yystack:
+	/* put a state and value onto the stack */
+	if yyDebug >= 4 {
+		__yyfmt__.Printf("char %v in %v\n", yyTokname(yychar), yyStatname(yystate))
+	}
+
+	yyp++
+	if yyp >= len(yyS) {
+		nyys := make([]yySymType, len(yyS)*2)
+		copy(nyys, yyS)
+		yyS = nyys
+	}
+	yyS[yyp] = yyVAL
+	yyS[yyp].yys = yystate
+
+yynewstate:
+	yyn = yyPact[yystate]
+	if yyn <= yyFlag {
+		goto yydefault /* simple state */
+	}
+	if yychar < 0 {
+		yychar = yylex1(yylex, &yylval)
+	}
+	yyn += yychar
+	if yyn < 0 || yyn >= yyLast {
+		goto yydefault
+	}
+	yyn = yyAct[yyn]
+	if yyChk[yyn] == yychar { /* valid shift */
+		yychar = -1
+		yyVAL = yylval
+		yystate = yyn
+		if Errflag > 0 {
+			Errflag--
+		}
+		goto yystack
+	}
+
+yydefault:
+	/* default state action */
+	yyn = yyDef[yystate]
+	if yyn == -2 {
+		if yychar < 0 {
+			yychar = yylex1(yylex, &yylval)
+		}
+
+		/* look through exception table */
+		xi := 0
+		for {
+			if yyExca[xi+0] == -1 && yyExca[xi+1] == yystate {
+				break
+			}
+			xi += 2
+		}
+		for xi += 2; ; xi += 2 {
+			yyn = yyExca[xi+0]
+			if yyn < 0 || yyn == yychar {
+				break
+			}
+		}
+		yyn = yyExca[xi+1]
+		if yyn < 0 {
+			goto ret0
+		}
+	}
+	if yyn == 0 {
+		/* error ... attempt to resume parsing */
+		switch Errflag {
+		case 0: /* brand new error */
+			yylex.Error("syntax error")
+			Nerrs++
+			if yyDebug >= 1 {
+				__yyfmt__.Printf("%s", yyStatname(yystate))
+				__yyfmt__.Printf(" saw %s\n", yyTokname(yychar))
+			}
+			fallthrough
+
+		case 1, 2: /* incompletely recovered error ... try again */
+			Errflag = 3
+
+			/* find a state where "error" is a legal shift action */
+			for yyp >= 0 {
+				yyn = yyPact[yyS[yyp].yys] + yyErrCode
+				if yyn >= 0 && yyn < yyLast {
+					yystate = yyAct[yyn] /* simulate a shift of "error" */
+					if yyChk[yystate] == yyErrCode {
+						goto yystack
+					}
+				}
+
+				/* the current p has no shift on "error", pop stack */
+				if yyDebug >= 2 {
+					__yyfmt__.Printf("error recovery pops state %d\n", yyS[yyp].yys)
+				}
+				yyp--
+			}
+			/* there is no state on the stack with an error shift ... abort */
+			goto ret1
+
+		case 3: /* no shift yet; clobber input char */
+			if yyDebug >= 2 {
+				__yyfmt__.Printf("error recovery discards %s\n", yyTokname(yychar))
+			}
+			if yychar == yyEofCode {
+				goto ret1
+			}
+			yychar = -1
+			goto yynewstate /* try again in the same state */
+		}
+	}
+
+	/* reduction by production yyn */
+	if yyDebug >= 2 {
+		__yyfmt__.Printf("reduce %v in:\n\t%v\n", yyn, yyStatname(yystate))
+	}
+
+	yynt := yyn
+	yypt := yyp
+	_ = yypt // guard against "declared and not used"
+
+	yyp -= yyR2[yyn]
+	// yyp is now the index of $0. Perform the default action. Iff the
+	// reduced production is ε, $1 is possibly out of range.
+	if yyp+1 >= len(yyS) {
+		nyys := make([]yySymType, len(yyS)*2)
+		copy(nyys, yyS)
+		yyS = nyys
+	}
+	yyVAL = yyS[yyp+1]
+
+	/* consult goto table to find next state */
+	yyn = yyR1[yyn]
+	yyg := yyPgo[yyn]
+	yyj := yyg + yyS[yyp].yys + 1
+
+	if yyj >= yyLast {
+		yystate = yyAct[yyg]
+	} else {
+		yystate = yyAct[yyj]
+		if yyChk[yystate] != -yyn {
+			yystate = yyAct[yyg]
+		}
+	}
+	// dummy call; replaced with literal code
+	switch yynt {
+
+	case 2:
+		//line a.y:75
+		{
+			stmtline = asm.Lineno
+		}
+	case 4:
+		//line a.y:82
+		{
+			yyS[yypt-1].sym = asm.LabelLookup(yyS[yypt-1].sym)
+			if yyS[yypt-1].sym.Type == LLAB && yyS[yypt-1].sym.Value != int64(asm.PC) {
+				yyerror("redeclaration of %s", yyS[yypt-1].sym.Labelname)
+			}
+			yyS[yypt-1].sym.Type = LLAB
+			yyS[yypt-1].sym.Value = int64(asm.PC)
+		}
+	case 9:
+		//line a.y:97
+		{
+			yyS[yypt-2].sym.Type = LVAR
+			yyS[yypt-2].sym.Value = yyS[yypt-0].lval
+		}
+	case 10:
+		//line a.y:102
+		{
+			if yyS[yypt-2].sym.Value != int64(yyS[yypt-0].lval) {
+				yyerror("redeclaration of %s", yyS[yypt-2].sym.Name)
+			}
+			yyS[yypt-2].sym.Value = yyS[yypt-0].lval
+		}
+	case 11:
+		//line a.y:108
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 12:
+		//line a.y:109
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 13:
+		//line a.y:110
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 14:
+		//line a.y:111
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 15:
+		//line a.y:112
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 16:
+		//line a.y:113
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 17:
+		//line a.y:114
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 18:
+		//line a.y:115
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 19:
+		//line a.y:116
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 20:
+		//line a.y:117
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 21:
+		//line a.y:118
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 22:
+		//line a.y:119
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 23:
+		//line a.y:120
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 24:
+		//line a.y:121
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 25:
+		//line a.y:122
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 26:
+		//line a.y:123
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 27:
+		//line a.y:124
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 28:
+		//line a.y:125
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr2)
+		}
+	case 29:
+		//line a.y:128
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = nullgen
+		}
+	case 30:
+		//line a.y:133
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = nullgen
+		}
+	case 31:
+		//line a.y:140
+		{
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 32:
+		//line a.y:147
+		{
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 33:
+		//line a.y:154
+		{
+			yyVAL.addr2.from = yyS[yypt-1].addr
+			yyVAL.addr2.to = nullgen
+		}
+	case 34:
+		//line a.y:159
+		{
+			yyVAL.addr2.from = yyS[yypt-0].addr
+			yyVAL.addr2.to = nullgen
+		}
+	case 35:
+		//line a.y:166
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 36:
+		//line a.y:171
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 37:
+		//line a.y:178
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 38:
+		//line a.y:183
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 39:
+		//line a.y:188
+		{
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 40:
+		//line a.y:195
+		{
+			yyVAL.addr2.from = yyS[yypt-4].addr
+			yyVAL.addr2.from.Scale = int8(yyS[yypt-2].lval)
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 41:
+		//line a.y:203
+		{
+			asm.Settext(yyS[yypt-2].addr.Sym)
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 42:
+		//line a.y:209
+		{
+			asm.Settext(yyS[yypt-4].addr.Sym)
+			yyVAL.addr2.from = yyS[yypt-4].addr
+			yyVAL.addr2.from.Scale = int8(yyS[yypt-2].lval)
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 43:
+		//line a.y:218
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 44:
+		//line a.y:223
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 45:
+		//line a.y:228
+		{
+			yyVAL.addr2.from = nullgen
+			yyVAL.addr2.to = yyS[yypt-0].addr
+			yyVAL.addr2.to.Index = uint8(yyS[yypt-0].addr.Type_)
+			yyVAL.addr2.to.Type_ = D_INDIR + D_ADDR
+		}
+	case 46:
+		yyVAL.addr2 = yyS[yypt-0].addr2
+	case 47:
+		yyVAL.addr2 = yyS[yypt-0].addr2
+	case 48:
+		//line a.y:241
+		{
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 49:
+		//line a.y:246
+		{
+			yyVAL.addr2.from = yyS[yypt-4].addr
+			yyVAL.addr2.to = yyS[yypt-2].addr
+			if yyVAL.addr2.from.Index != D_NONE {
+				yyerror("dp shift with lhs index")
+			}
+			yyVAL.addr2.from.Index = uint8(yyS[yypt-0].lval)
+		}
+	case 50:
+		//line a.y:257
+		{
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 51:
+		//line a.y:262
+		{
+			yyVAL.addr2.from = yyS[yypt-4].addr
+			yyVAL.addr2.to = yyS[yypt-2].addr
+			if yyVAL.addr2.to.Index != D_NONE {
+				yyerror("dp move with lhs index")
+			}
+			yyVAL.addr2.to.Index = uint8(yyS[yypt-0].lval)
+		}
+	case 52:
+		//line a.y:273
+		{
+			yyVAL.addr2.from = yyS[yypt-1].addr
+			yyVAL.addr2.to = nullgen
+		}
+	case 53:
+		//line a.y:278
+		{
+			yyVAL.addr2.from = yyS[yypt-0].addr
+			yyVAL.addr2.to = nullgen
+		}
+	case 54:
+		//line a.y:283
+		{
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 55:
+		//line a.y:290
+		{
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 56:
+		//line a.y:295
+		{
+			yyVAL.addr2.from = yyS[yypt-4].addr
+			yyVAL.addr2.from.Scale = int8(yyS[yypt-2].lval)
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 57:
+		//line a.y:303
+		{
+			yyVAL.addr2.from = yyS[yypt-4].addr
+			yyVAL.addr2.to = yyS[yypt-2].addr
+			yyVAL.addr2.to.Offset = yyS[yypt-0].lval
+		}
+	case 58:
+		//line a.y:311
+		{
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+			if yyS[yypt-4].addr.Type_ != D_CONST {
+				yyerror("illegal constant")
+			}
+			yyVAL.addr2.to.Offset = yyS[yypt-4].addr.Offset
+		}
+	case 59:
+		//line a.y:322
+		{
+			if yyS[yypt-2].addr.Type_ != D_CONST || yyS[yypt-0].addr.Type_ != D_CONST {
+				yyerror("arguments to PCDATA must be integer constants")
+			}
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 60:
+		//line a.y:332
+		{
+			if yyS[yypt-2].addr.Type_ != D_CONST {
+				yyerror("index for FUNCDATA must be integer constant")
+			}
+			if yyS[yypt-0].addr.Type_ != D_EXTERN && yyS[yypt-0].addr.Type_ != D_STATIC {
+				yyerror("value for FUNCDATA must be symbol reference")
+			}
+			yyVAL.addr2.from = yyS[yypt-2].addr
+			yyVAL.addr2.to = yyS[yypt-0].addr
+		}
+	case 61:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 62:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 63:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 64:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 65:
+		//line a.y:351
+		{
+			yyVAL.addr = yyS[yypt-0].addr
+		}
+	case 66:
+		//line a.y:355
+		{
+			yyVAL.addr = yyS[yypt-0].addr
+		}
+	case 67:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 68:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 69:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 70:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 71:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 72:
+		//line a.y:368
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_BRANCH
+			yyVAL.addr.Offset = yyS[yypt-3].lval + int64(asm.PC)
+		}
+	case 73:
+		//line a.y:374
+		{
+			yyS[yypt-1].sym = asm.LabelLookup(yyS[yypt-1].sym)
+			yyVAL.addr = nullgen
+			if asm.Pass == 2 && yyS[yypt-1].sym.Type != LLAB {
+				yyerror("undefined label: %s", yyS[yypt-1].sym.Labelname)
+			}
+			yyVAL.addr.Type_ = D_BRANCH
+			yyVAL.addr.Offset = yyS[yypt-1].sym.Value + yyS[yypt-0].lval
+		}
+	case 74:
+		//line a.y:386
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+		}
+	case 75:
+		//line a.y:391
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+		}
+	case 76:
+		//line a.y:396
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+		}
+	case 77:
+		//line a.y:401
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+		}
+	case 78:
+		//line a.y:406
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_SP
+		}
+	case 79:
+		//line a.y:411
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+		}
+	case 80:
+		//line a.y:418
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_CONST
+			yyVAL.addr.Offset = yyS[yypt-0].lval
+		}
+	case 81:
+		//line a.y:424
+		{
+			yyVAL.addr = yyS[yypt-0].addr
+			yyVAL.addr.Index = uint8(yyS[yypt-0].addr.Type_)
+			yyVAL.addr.Type_ = D_ADDR
+			/*
+				if($2.Type_ == D_AUTO || $2.Type_ == D_PARAM)
+					yyerror("constant cannot be automatic: %s",
+						$2.Sym.name);
+			*/
+		}
+	case 82:
+		//line a.y:434
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_SCONST
+			yyVAL.addr.U.Sval = yyS[yypt-0].sval
+		}
+	case 83:
+		//line a.y:440
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_FCONST
+			yyVAL.addr.U.Dval = yyS[yypt-0].dval
+		}
+	case 84:
+		//line a.y:446
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_FCONST
+			yyVAL.addr.U.Dval = yyS[yypt-1].dval
+		}
+	case 85:
+		//line a.y:452
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_FCONST
+			yyVAL.addr.U.Dval = -yyS[yypt-1].dval
+		}
+	case 86:
+		//line a.y:458
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_FCONST
+			yyVAL.addr.U.Dval = -yyS[yypt-0].dval
+		}
+	case 87:
+		//line a.y:466
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_CONST2
+			yyVAL.addr.Offset = int64(yyS[yypt-0].con2.v1)
+			yyVAL.addr.Offset2 = int32(yyS[yypt-0].con2.v2)
+		}
+	case 88:
+		//line a.y:475
+		{
+			yyVAL.con2.v1 = int32(yyS[yypt-0].lval)
+			yyVAL.con2.v2 = -obj.ArgsSizeUnknown
+		}
+	case 89:
+		//line a.y:480
+		{
+			yyVAL.con2.v1 = int32(-yyS[yypt-0].lval)
+			yyVAL.con2.v2 = -obj.ArgsSizeUnknown
+		}
+	case 90:
+		//line a.y:485
+		{
+			yyVAL.con2.v1 = int32(yyS[yypt-2].lval)
+			yyVAL.con2.v2 = int32(yyS[yypt-0].lval)
+		}
+	case 91:
+		//line a.y:490
+		{
+			yyVAL.con2.v1 = int32(-yyS[yypt-2].lval)
+			yyVAL.con2.v2 = int32(yyS[yypt-0].lval)
+		}
+	case 92:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 93:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 94:
+		//line a.y:501
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_INDIR + D_NONE
+			yyVAL.addr.Offset = yyS[yypt-0].lval
+		}
+	case 95:
+		//line a.y:507
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(D_INDIR + yyS[yypt-1].lval)
+			yyVAL.addr.Offset = yyS[yypt-3].lval
+		}
+	case 96:
+		//line a.y:513
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_INDIR + D_SP
+			yyVAL.addr.Offset = yyS[yypt-3].lval
+		}
+	case 97:
+		//line a.y:519
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_INDIR + D_NONE
+			yyVAL.addr.Offset = yyS[yypt-5].lval
+			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
+			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
+			checkscale(yyVAL.addr.Scale)
+		}
+	case 98:
+		//line a.y:528
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(D_INDIR + yyS[yypt-6].lval)
+			yyVAL.addr.Offset = yyS[yypt-8].lval
+			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
+			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
+			checkscale(yyVAL.addr.Scale)
+		}
+	case 99:
+		//line a.y:537
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(D_INDIR + yyS[yypt-6].lval)
+			yyVAL.addr.Offset = yyS[yypt-8].lval
+			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
+			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
+			checkscale(yyVAL.addr.Scale)
+		}
+	case 100:
+		//line a.y:546
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(D_INDIR + yyS[yypt-1].lval)
+		}
+	case 101:
+		//line a.y:551
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_INDIR + D_SP
+		}
+	case 102:
+		//line a.y:556
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(D_INDIR + yyS[yypt-1].lval)
+			yyVAL.addr.Offset = yyS[yypt-3].lval
+		}
+	case 103:
+		//line a.y:562
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_INDIR + D_NONE
+			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
+			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
+			checkscale(yyVAL.addr.Scale)
+		}
+	case 104:
+		//line a.y:570
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(D_INDIR + yyS[yypt-6].lval)
+			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
+			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
+			checkscale(yyVAL.addr.Scale)
+		}
+	case 105:
+		//line a.y:580
+		{
+			yyVAL.addr = yyS[yypt-0].addr
+		}
+	case 106:
+		//line a.y:584
+		{
+			yyVAL.addr = yyS[yypt-5].addr
+			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
+			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
+			checkscale(yyVAL.addr.Scale)
+		}
+	case 107:
+		//line a.y:593
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(yyS[yypt-1].lval)
+			yyVAL.addr.Sym = obj.Linklookup(asm.Ctxt, yyS[yypt-4].sym.Name, 0)
+			yyVAL.addr.Offset = yyS[yypt-3].lval
+		}
+	case 108:
+		//line a.y:600
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_STATIC
+			yyVAL.addr.Sym = obj.Linklookup(asm.Ctxt, yyS[yypt-6].sym.Name, 1)
+			yyVAL.addr.Offset = yyS[yypt-3].lval
+		}
+	case 109:
+		//line a.y:608
+		{
+			yyVAL.lval = 0
+		}
+	case 110:
+		//line a.y:612
+		{
+			yyVAL.lval = yyS[yypt-0].lval
+		}
+	case 111:
+		//line a.y:616
+		{
+			yyVAL.lval = -yyS[yypt-0].lval
+		}
+	case 112:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 113:
+		//line a.y:623
+		{
+			yyVAL.lval = D_AUTO
+		}
+	case 114:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 115:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 116:
+		//line a.y:631
+		{
+			yyVAL.lval = yyS[yypt-0].sym.Value
+		}
+	case 117:
+		//line a.y:635
+		{
+			yyVAL.lval = -yyS[yypt-0].lval
+		}
+	case 118:
+		//line a.y:639
+		{
+			yyVAL.lval = yyS[yypt-0].lval
+		}
+	case 119:
+		//line a.y:643
+		{
+			yyVAL.lval = ^yyS[yypt-0].lval
+		}
+	case 120:
+		//line a.y:647
+		{
+			yyVAL.lval = yyS[yypt-1].lval
+		}
+	case 121:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 122:
+		//line a.y:654
+		{
+			yyVAL.lval = yyS[yypt-2].lval + yyS[yypt-0].lval
+		}
+	case 123:
+		//line a.y:658
+		{
+			yyVAL.lval = yyS[yypt-2].lval - yyS[yypt-0].lval
+		}
+	case 124:
+		//line a.y:662
+		{
+			yyVAL.lval = yyS[yypt-2].lval * yyS[yypt-0].lval
+		}
+	case 125:
+		//line a.y:666
+		{
+			yyVAL.lval = yyS[yypt-2].lval / yyS[yypt-0].lval
+		}
+	case 126:
+		//line a.y:670
+		{
+			yyVAL.lval = yyS[yypt-2].lval % yyS[yypt-0].lval
+		}
+	case 127:
+		//line a.y:674
+		{
+			yyVAL.lval = yyS[yypt-3].lval << uint(yyS[yypt-0].lval)
+		}
+	case 128:
+		//line a.y:678
+		{
+			yyVAL.lval = yyS[yypt-3].lval >> uint(yyS[yypt-0].lval)
+		}
+	case 129:
+		//line a.y:682
+		{
+			yyVAL.lval = yyS[yypt-2].lval & yyS[yypt-0].lval
+		}
+	case 130:
+		//line a.y:686
+		{
+			yyVAL.lval = yyS[yypt-2].lval ^ yyS[yypt-0].lval
+		}
+	case 131:
+		//line a.y:690
+		{
+			yyVAL.lval = yyS[yypt-2].lval | yyS[yypt-0].lval
+		}
+	}
+	goto yystack /* stack new state and value */
+}
diff --git a/src/cmd/new9a/a.y b/src/cmd/new9a/a.y
index b366146156..25b3ca689a 100644
--- a/src/cmd/new9a/a.y
+++ b/src/cmd/new9a/a.y
@@ -28,20 +28,24 @@
 // THE SOFTWARE.
 
 %{
-#include <u.h>
-#include <stdio.h>	/* if we don't, bison will, and a.h re-#defines getc */
-#include <libc.h>
-#include "a.h"
-#include "../../runtime/funcdata.h"
+package main
+
+import (
+	"cmd/internal/asm"
+	"cmd/internal/obj"
+	. "cmd/internal/obj/ppc64"
+)
 %}
+
 %union
 {
-	Sym	*sym;
-	vlong	lval;
-	double	dval;
-	char	sval[8];
-	Addr	addr;
+	sym *asm.Sym
+	lval int64
+	dval float64
+	sval string
+	addr obj.Addr
 }
+
 %left	'|'
 %left	'^'
 %left	'&'
@@ -69,27 +73,29 @@ prog:
 line:
 	LNAME ':'
 	{
-		$1 = labellookup($1);
-		if($1->type == LLAB && $1->value != pc)
-			yyerror("redeclaration of %s", $1->labelname);
-		$1->type = LLAB;
-		$1->value = pc;
+		$1 = asm.LabelLookup($1);
+		if $1.Type == LLAB && $1.Value != int64(asm.PC) {
+			yyerror("redeclaration of %s", $1.Labelname)
+		}
+		$1.Type = LLAB;
+		$1.Value = int64(asm.PC);
 	}
 	line
 |	LNAME '=' expr ';'
 	{
-		$1->type = LVAR;
-		$1->value = $3;
+		$1.Type = LVAR;
+		$1.Value = $3;
 	}
 |	LVAR '=' expr ';'
 	{
-		if($1->value != $3)
-			yyerror("redeclaration of %s", $1->name);
-		$1->value = $3;
+		if $1.Value != $3 {
+			yyerror("redeclaration of %s", $1.Name)
+		}
+		$1.Value = $3;
 	}
 |	LSCHED ';'
 	{
-		nosched = $1;
+		nosched = int($1);
 	}
 |	';'
 |	inst ';'
@@ -101,126 +107,126 @@ inst:
  */
 	LMOVW rreg ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVW addr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVW regaddr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVB rreg ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVB addr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVB regaddr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 /*
  * load floats
  */
 |	LFMOV addr ',' freg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LFMOV regaddr ',' freg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LFMOV fimm ',' freg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LFMOV freg ',' freg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LFMOV freg ',' addr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LFMOV freg ',' regaddr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 /*
  * store ints and bytes
  */
 |	LMOVW rreg ',' addr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVW rreg ',' regaddr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVB rreg ',' addr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVB rreg ',' regaddr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 /*
  * store floats
  */
 |	LMOVW freg ',' addr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVW freg ',' regaddr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 /*
  * floating point status
  */
 |	LMOVW fpscr ',' freg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVW freg ','  fpscr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVW freg ',' imm ',' fpscr
 	{
-		outgcode($1, &$2, NREG, &$4, &$6);
+		outgcode(int($1), &$2, NREG, &$4, &$6);
 	}
 |	LMOVW fpscr ',' creg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVW imm ',' fpscrf
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMTFSB imm ',' con
 	{
-		outcode($1, &$2, $4, &nullgen);
+		outcode(int($1), &$2, int($4), &nullgen);
 	}
 /*
  * field moves (mtcrf)
  */
 |	LMOVW rreg ',' imm ',' lcr
 	{
-		outgcode($1, &$2, NREG, &$4, &$6);
+		outgcode(int($1), &$2, NREG, &$4, &$6);
 	}
 |	LMOVW rreg ',' creg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVW rreg ',' lcr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 /*
  * integer operations
@@ -230,84 +236,84 @@ inst:
  */
 |	LADDW rreg ',' sreg ',' rreg
 	{
-		outcode($1, &$2, $4, &$6);
+		outcode(int($1), &$2, int($4), &$6);
 	}
 |	LADDW imm ',' sreg ',' rreg
 	{
-		outcode($1, &$2, $4, &$6);
+		outcode(int($1), &$2, int($4), &$6);
 	}
 |	LADDW rreg ',' imm ',' rreg
 	{
-		outgcode($1, &$2, NREG, &$4, &$6);
+		outgcode(int($1), &$2, NREG, &$4, &$6);
 	}
 |	LADDW rreg ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LADDW imm ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LLOGW rreg ',' sreg ',' rreg
 	{
-		outcode($1, &$2, $4, &$6);
+		outcode(int($1), &$2, int($4), &$6);
 	}
 |	LLOGW rreg ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LSHW rreg ',' sreg ',' rreg
 	{
-		outcode($1, &$2, $4, &$6);
+		outcode(int($1), &$2, int($4), &$6);
 	}
 |	LSHW rreg ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LSHW imm ',' sreg ',' rreg
 	{
-		outcode($1, &$2, $4, &$6);
+		outcode(int($1), &$2, int($4), &$6);
 	}
 |	LSHW imm ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LABS rreg ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LABS rreg
 	{
-		outcode($1, &$2, NREG, &$2);
+		outcode(int($1), &$2, NREG, &$2);
 	}
 /*
  * multiply-accumulate
  */
 |	LMA rreg ',' sreg ',' rreg
 	{
-		outcode($1, &$2, $4, &$6);
+		outcode(int($1), &$2, int($4), &$6);
 	}
 /*
  * move immediate: macro for cau+or, addi, addis, and other combinations
  */
 |	LMOVW imm ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVW ximm ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 /*
  * condition register operations
  */
 |	LCROP cbit ',' cbit
 	{
-		outcode($1, &$2, $4.reg, &$4);
+		outcode(int($1), &$2, int($4.Reg), &$4);
 	}
 |	LCROP cbit ',' con ',' cbit
 	{
-		outcode($1, &$2, $4, &$6);
+		outcode(int($1), &$2, int($4), &$6);
 	}
 /*
  * condition register moves
@@ -315,35 +321,35 @@ inst:
  */
 |	LMOVW creg ',' creg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVW psr ',' creg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVW lcr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVW psr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVW xlreg ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVW rreg ',' xlreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVW creg ',' psr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVW rreg ',' psr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 /*
  * branch, branch conditional
@@ -352,170 +358,170 @@ inst:
  */
 |	LBRA rel
 	{
-		outcode($1, &nullgen, NREG, &$2);
+		outcode(int($1), &nullgen, NREG, &$2);
 	}
 |	LBRA addr
 	{
-		outcode($1, &nullgen, NREG, &$2);
+		outcode(int($1), &nullgen, NREG, &$2);
 	}
 |	LBRA '(' xlreg ')'
 	{
-		outcode($1, &nullgen, NREG, &$3);
+		outcode(int($1), &nullgen, NREG, &$3);
 	}
 |	LBRA ',' rel
 	{
-		outcode($1, &nullgen, NREG, &$3);
+		outcode(int($1), &nullgen, NREG, &$3);
 	}
 |	LBRA ',' addr
 	{
-		outcode($1, &nullgen, NREG, &$3);
+		outcode(int($1), &nullgen, NREG, &$3);
 	}
 |	LBRA ',' '(' xlreg ')'
 	{
-		outcode($1, &nullgen, NREG, &$4);
+		outcode(int($1), &nullgen, NREG, &$4);
 	}
 |	LBRA creg ',' rel
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LBRA creg ',' addr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LBRA creg ',' '(' xlreg ')'
 	{
-		outcode($1, &$2, NREG, &$5);
+		outcode(int($1), &$2, NREG, &$5);
 	}
 |	LBRA con ',' rel
 	{
-		outcode($1, &nullgen, $2, &$4);
+		outcode(int($1), &nullgen, int($2), &$4);
 	}
 |	LBRA con ',' addr
 	{
-		outcode($1, &nullgen, $2, &$4);
+		outcode(int($1), &nullgen, int($2), &$4);
 	}
 |	LBRA con ',' '(' xlreg ')'
 	{
-		outcode($1, &nullgen, $2, &$5);
+		outcode(int($1), &nullgen, int($2), &$5);
 	}
 |	LBRA con ',' con ',' rel
 	{
-		Addr g;
+		var g obj.Addr
 		g = nullgen;
-		g.type = D_CONST;
-		g.offset = $2;
-		outcode($1, &g, $4, &$6);
+		g.Type_ = D_CONST;
+		g.Offset = $2;
+		outcode(int($1), &g, int($4), &$6);
 	}
 |	LBRA con ',' con ',' addr
 	{
-		Addr g;
+		var g obj.Addr
 		g = nullgen;
-		g.type = D_CONST;
-		g.offset = $2;
-		outcode($1, &g, $4, &$6);
+		g.Type_ = D_CONST;
+		g.Offset = $2;
+		outcode(int($1), &g, int($4), &$6);
 	}
 |	LBRA con ',' con ',' '(' xlreg ')'
 	{
-		Addr g;
+		var g obj.Addr
 		g = nullgen;
-		g.type = D_CONST;
-		g.offset = $2;
-		outcode($1, &g, $4, &$7);
+		g.Type_ = D_CONST;
+		g.Offset = $2;
+		outcode(int($1), &g, int($4), &$7);
 	}
 /*
  * conditional trap
  */
 |	LTRAP rreg ',' sreg
 	{
-		outcode($1, &$2, $4, &nullgen);
+		outcode(int($1), &$2, int($4), &nullgen);
 	}
 |	LTRAP imm ',' sreg
 	{
-		outcode($1, &$2, $4, &nullgen);
+		outcode(int($1), &$2, int($4), &nullgen);
 	}
 |	LTRAP rreg comma
 	{
-		outcode($1, &$2, NREG, &nullgen);
+		outcode(int($1), &$2, NREG, &nullgen);
 	}
 |	LTRAP comma
 	{
-		outcode($1, &nullgen, NREG, &nullgen);
+		outcode(int($1), &nullgen, NREG, &nullgen);
 	}
 /*
  * floating point operate
  */
 |	LFCONV freg ',' freg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LFADD freg ',' freg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LFADD freg ',' freg ',' freg
 	{
-		outcode($1, &$2, $4.reg, &$6);
+		outcode(int($1), &$2, int($4.Reg), &$6);
 	}
 |	LFMA freg ',' freg ',' freg ',' freg
 	{
-		outgcode($1, &$2, $4.reg, &$6, &$8);
+		outgcode(int($1), &$2, int($4.Reg), &$6, &$8);
 	}
 |	LFCMP freg ',' freg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LFCMP freg ',' freg ',' creg
 	{
-		outcode($1, &$2, $6.reg, &$4);
+		outcode(int($1), &$2, int($6.Reg), &$4);
 	}
 /*
  * CMP
  */
 |	LCMP rreg ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LCMP rreg ',' imm
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LCMP rreg ',' rreg ',' creg
 	{
-		outcode($1, &$2, $6.reg, &$4);
+		outcode(int($1), &$2, int($6.Reg), &$4);
 	}
 |	LCMP rreg ',' imm ',' creg
 	{
-		outcode($1, &$2, $6.reg, &$4);
+		outcode(int($1), &$2, int($6.Reg), &$4);
 	}
 /*
  * rotate and mask
  */
 |	LRLWM  imm ',' rreg ',' imm ',' rreg
 	{
-		outgcode($1, &$2, $4.reg, &$6, &$8);
+		outgcode(int($1), &$2, int($4.Reg), &$6, &$8);
 	}
 |	LRLWM  imm ',' rreg ',' mask ',' rreg
 	{
-		outgcode($1, &$2, $4.reg, &$6, &$8);
+		outgcode(int($1), &$2, int($4.Reg), &$6, &$8);
 	}
 |	LRLWM  rreg ',' rreg ',' imm ',' rreg
 	{
-		outgcode($1, &$2, $4.reg, &$6, &$8);
+		outgcode(int($1), &$2, int($4.Reg), &$6, &$8);
 	}
 |	LRLWM  rreg ',' rreg ',' mask ',' rreg
 	{
-		outgcode($1, &$2, $4.reg, &$6, &$8);
+		outgcode(int($1), &$2, int($4.Reg), &$6, &$8);
 	}
 /*
  * load/store multiple
  */
 |	LMOVMW addr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LMOVMW rreg ',' addr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 /*
  * various indexed load/store
@@ -523,165 +529,169 @@ inst:
  */
 |	LXLD regaddr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LXLD regaddr ',' imm ',' rreg
 	{
-		outgcode($1, &$2, NREG, &$4, &$6);
+		outgcode(int($1), &$2, NREG, &$4, &$6);
 	}
 |	LXST rreg ',' regaddr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LXST rreg ',' imm ',' regaddr
 	{
-		outgcode($1, &$2, NREG, &$4, &$6);
+		outgcode(int($1), &$2, NREG, &$4, &$6);
 	}
 |	LXMV regaddr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LXMV rreg ',' regaddr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LXOP regaddr
 	{
-		outcode($1, &$2, NREG, &nullgen);
+		outcode(int($1), &$2, NREG, &nullgen);
 	}
 /*
  * NOP
  */
 |	LNOP comma
 	{
-		outcode($1, &nullgen, NREG, &nullgen);
+		outcode(int($1), &nullgen, NREG, &nullgen);
 	}
 |	LNOP rreg comma
 	{
-		outcode($1, &$2, NREG, &nullgen);
+		outcode(int($1), &$2, NREG, &nullgen);
 	}
 |	LNOP freg comma
 	{
-		outcode($1, &$2, NREG, &nullgen);
+		outcode(int($1), &$2, NREG, &nullgen);
 	}
 |	LNOP ',' rreg
 	{
-		outcode($1, &nullgen, NREG, &$3);
+		outcode(int($1), &nullgen, NREG, &$3);
 	}
 |	LNOP ',' freg
 	{
-		outcode($1, &nullgen, NREG, &$3);
+		outcode(int($1), &nullgen, NREG, &$3);
 	}
 |	LNOP imm /* SYSCALL $num: load $num to R0 before syscall and restore R0 to 0 afterwards. */
 	{
-		outcode($1, &$2, NREG, &nullgen);
+		outcode(int($1), &$2, NREG, &nullgen);
 	}
 /*
  * word
  */
 |	LWORD imm comma
 	{
-		outcode($1, &$2, NREG, &nullgen);
+		outcode(int($1), &$2, NREG, &nullgen);
 	}
 |	LWORD ximm comma
 	{
-		outcode($1, &$2, NREG, &nullgen);
+		outcode(int($1), &$2, NREG, &nullgen);
 	}
 /*
  * PCDATA
  */
 |	LPCDAT imm ',' imm
 	{
-		if($2.type != D_CONST || $4.type != D_CONST)
-			yyerror("arguments to PCDATA must be integer constants");
-		outcode($1, &$2, NREG, &$4);
+		if $2.Type_ != D_CONST || $4.Type_ != D_CONST {
+			yyerror("arguments to PCDATA must be integer constants")
+		}
+		outcode(int($1), &$2, NREG, &$4);
 	}
 /*
  * FUNCDATA
  */
 |	LFUNCDAT imm ',' addr
 	{
-		if($2.type != D_CONST)
-			yyerror("index for FUNCDATA must be integer constant");
-		if($4.type != D_EXTERN && $4.type != D_STATIC && $4.type != D_OREG)
-			yyerror("value for FUNCDATA must be symbol reference");
- 		outcode($1, &$2, NREG, &$4);
+		if $2.Type_ != D_CONST {
+			yyerror("index for FUNCDATA must be integer constant")
+		}
+		if $4.Type_ != D_EXTERN && $4.Type_ != D_STATIC && $4.Type_ != D_OREG {
+			yyerror("value for FUNCDATA must be symbol reference")
+		}
+ 		outcode(int($1), &$2, NREG, &$4);
 	}
 /*
  * END
  */
 |	LEND comma
 	{
-		outcode($1, &nullgen, NREG, &nullgen);
+		outcode(int($1), &nullgen, NREG, &nullgen);
 	}
 /*
  * TEXT/GLOBL
  */
 |	LTEXT name ',' imm
 	{
-		settext($2.sym);
-		outcode($1, &$2, NREG, &$4);
+		asm.Settext($2.Sym);
+		outcode(int($1), &$2, NREG, &$4);
 	}
 |	LTEXT name ',' con ',' imm
 	{
-		settext($2.sym);
-		$6.offset &= 0xffffffffull;
-		$6.offset |= (vlong)ArgsSizeUnknown << 32;
-		outcode($1, &$2, $4, &$6);
+		asm.Settext($2.Sym);
+		$6.Offset &= 0xffffffff;
+		$6.Offset |= -obj.ArgsSizeUnknown << 32;
+		outcode(int($1), &$2, int($4), &$6);
 	}
 |	LTEXT name ',' con ',' imm '-' con
 	{
-		settext($2.sym);
-		$6.offset &= 0xffffffffull;
-		$6.offset |= ($8 & 0xffffffffull) << 32;
-		outcode($1, &$2, $4, &$6);
+		asm.Settext($2.Sym);
+		$6.Offset &= 0xffffffff;
+		$6.Offset |= ($8 & 0xffffffff) << 32;
+		outcode(int($1), &$2, int($4), &$6);
 	}
 /*
  * DATA
  */
 |	LDATA name '/' con ',' imm
 	{
-		outcode($1, &$2, $4, &$6);
+		outcode(int($1), &$2, int($4), &$6);
 	}
 |	LDATA name '/' con ',' ximm
 	{
-		outcode($1, &$2, $4, &$6);
+		outcode(int($1), &$2, int($4), &$6);
 	}
 |	LDATA name '/' con ',' fimm
 	{
-		outcode($1, &$2, $4, &$6);
+		outcode(int($1), &$2, int($4), &$6);
 	}
 /*
  * RETURN
  */
 |	LRETRN	comma
 	{
-		outcode($1, &nullgen, NREG, &nullgen);
+		outcode(int($1), &nullgen, NREG, &nullgen);
 	}
 
 rel:
 	con '(' LPC ')'
 	{
 		$$ = nullgen;
-		$$.type = D_BRANCH;
-		$$.offset = $1 + pc;
+		$$.Type_ = D_BRANCH;
+		$$.Offset = $1 + int64(asm.PC);
 	}
 |	LNAME offset
 	{
-		$1 = labellookup($1);
+		$1 = asm.LabelLookup($1);
 		$$ = nullgen;
-		if(pass == 2 && $1->type != LLAB)
-			yyerror("undefined label: %s", $1->labelname);
-		$$.type = D_BRANCH;
-		$$.offset = $1->value + $2;
+		if asm.Pass == 2 && $1.Type != LLAB {
+			yyerror("undefined label: %s", $1.Labelname)
+		}
+		$$.Type_ = D_BRANCH;
+		$$.Offset = $1.Value + $2;
 	}
 
 rreg:
 	sreg
 	{
 		$$ = nullgen;
-		$$.type = D_REG;
-		$$.reg = $1;
+		$$.Type_ = D_REG;
+		$$.Reg = int8($1);
 	}
 
 xlreg:
@@ -692,45 +702,45 @@ lr:
 	LLR
 	{
 		$$ = nullgen;
-		$$.type = D_SPR;
-		$$.offset = $1;
+		$$.Type_ = D_SPR;
+		$$.Offset = $1;
 	}
 
 lcr:
 	LCR
 	{
 		$$ = nullgen;
-		$$.type = D_CREG;
-		$$.reg = NREG;	/* whole register */
+		$$.Type_ = D_CREG;
+		$$.Reg = NREG;	/* whole register */
 	}
 
 ctr:
 	LCTR
 	{
 		$$ = nullgen;
-		$$.type = D_SPR;
-		$$.offset = $1;
+		$$.Type_ = D_SPR;
+		$$.Offset = $1;
 	}
 
 msr:
 	LMSR
 	{
 		$$ = nullgen;
-		$$.type = D_MSR;
+		$$.Type_ = D_MSR;
 	}
 
 psr:
 	LSPREG
 	{
 		$$ = nullgen;
-		$$.type = D_SPR;
-		$$.offset = $1;
+		$$.Type_ = D_SPR;
+		$$.Offset = $1;
 	}
 |	LSPR '(' con ')'
 	{
 		$$ = nullgen;
-		$$.type = $1;
-		$$.offset = $3;
+		$$.Type_ = int16($1);
+		$$.Offset = $3;
 	}
 |	msr
 
@@ -738,115 +748,118 @@ fpscr:
 	LFPSCR
 	{
 		$$ = nullgen;
-		$$.type = D_FPSCR;
-		$$.reg = NREG;
+		$$.Type_ = D_FPSCR;
+		$$.Reg = NREG;
 	}
 
 fpscrf:
 	LFPSCR '(' con ')'
 	{
 		$$ = nullgen;
-		$$.type = D_FPSCR;
-		$$.reg = $3;
+		$$.Type_ = D_FPSCR;
+		$$.Reg = int8($3);
 	}
 
 freg:
 	LFREG
 	{
 		$$ = nullgen;
-		$$.type = D_FREG;
-		$$.reg = $1;
+		$$.Type_ = D_FREG;
+		$$.Reg = int8($1);
 	}
 |	LF '(' con ')'
 	{
 		$$ = nullgen;
-		$$.type = D_FREG;
-		$$.reg = $3;
+		$$.Type_ = D_FREG;
+		$$.Reg = int8($3);
 	}
 
 creg:
 	LCREG
 	{
 		$$ = nullgen;
-		$$.type = D_CREG;
-		$$.reg = $1;
+		$$.Type_ = D_CREG;
+		$$.Reg = int8($1);
 	}
 |	LCR '(' con ')'
 	{
 		$$ = nullgen;
-		$$.type = D_CREG;
-		$$.reg = $3;
+		$$.Type_ = D_CREG;
+		$$.Reg = int8($3);
 	}
 
 
 cbit:	con
 	{
 		$$ = nullgen;
-		$$.type = D_REG;
-		$$.reg = $1;
+		$$.Type_ = D_REG;
+		$$.Reg = int8($1);
 	}
 
 mask:
 	con ',' con
 	{
-		int mb, me;
-		uint32 v;
+		var mb, me int
+		var v uint32
 
 		$$ = nullgen;
-		$$.type = D_CONST;
-		mb = $1;
-		me = $3;
+		$$.Type_ = D_CONST;
+		mb = int($1);
+		me = int($3);
 		if(mb < 0 || mb > 31 || me < 0 || me > 31){
 			yyerror("illegal mask start/end value(s)");
-			mb = me = 0;
+			mb = 0
+			me = 0;
 		}
-		if(mb <= me)
-			v = ((uint32)~0L>>mb) & (~0L<<(31-me));
-		else
-			v = ~(((uint32)~0L>>(me+1)) & (~0L<<(31-(mb-1))));
-		$$.offset = v;
+		if mb <= me {
+			v = (^uint32(0)>>uint(mb)) & (^uint32(0)<<uint(31-me))
+		} else {
+			v = (^uint32(0)>>uint(me+1)) & (^uint32(0)<<uint(31-(mb-1)))
+		}
+		$$.Offset = int64(v);
 	}
 
 ximm:
 	'$' addr
 	{
 		$$ = $2;
-		$$.type = D_CONST;
+		$$.Type_ = D_CONST;
 	}
 |	'$' LSCONST
 	{
 		$$ = nullgen;
-		$$.type = D_SCONST;
-		memcpy($$.u.sval, $2, sizeof($$.u.sval));
+		$$.Type_ = D_SCONST;
+		$$.U.Sval = $2
 	}
 
 fimm:
 	'$' LFCONST
 	{
 		$$ = nullgen;
-		$$.type = D_FCONST;
-		$$.u.dval = $2;
+		$$.Type_ = D_FCONST;
+		$$.U.Dval = $2;
 	}
 |	'$' '-' LFCONST
 	{
 		$$ = nullgen;
-		$$.type = D_FCONST;
-		$$.u.dval = -$3;
+		$$.Type_ = D_FCONST;
+		$$.U.Dval = -$3;
 	}
 
 imm:	'$' con
 	{
 		$$ = nullgen;
-		$$.type = D_CONST;
-		$$.offset = $2;
+		$$.Type_ = D_CONST;
+		$$.Offset = $2;
 	}
 
 sreg:
 	LREG
 |	LR '(' con ')'
 	{
-		if($$ < 0 || $$ >= NREG)
-			print("register value out of range\n");
+		if $$ < 0 || $$ >= NREG {
+			print("register value out of range\n")
+		}
 		$$ = $3;
 	}
 
@@ -854,17 +867,17 @@ regaddr:
 	'(' sreg ')'
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
-		$$.reg = $2;
-		$$.offset = 0;
+		$$.Type_ = D_OREG;
+		$$.Reg = int8($2);
+		$$.Offset = 0;
 	}
 |	'(' sreg '+' sreg ')'
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
-		$$.reg = $2;
-		$$.scale = $4;
-		$$.offset = 0;
+		$$.Type_ = D_OREG;
+		$$.Reg = int8($2);
+		$$.Scale = int8($4);
+		$$.Offset = 0;
 	}
 
 addr:
@@ -872,35 +885,35 @@ addr:
 |	con '(' sreg ')'
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
-		$$.reg = $3;
-		$$.offset = $1;
+		$$.Type_ = D_OREG;
+		$$.Reg = int8($3);
+		$$.Offset = $1;
 	}
 
 name:
 	con '(' pointer ')'
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
-		$$.name = $3;
-		$$.sym = nil;
-		$$.offset = $1;
+		$$.Type_ = D_OREG;
+		$$.Name = int8($3);
+		$$.Sym = nil;
+		$$.Offset = $1;
 	}
 |	LNAME offset '(' pointer ')'
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
-		$$.name = $4;
-		$$.sym = linklookup(ctxt, $1->name, 0);
-		$$.offset = $2;
+		$$.Type_ = D_OREG;
+		$$.Name = int8($4);
+		$$.Sym = obj.Linklookup(asm.Ctxt, $1.Name, 0);
+		$$.Offset = $2;
 	}
 |	LNAME '<' '>' offset '(' LSB ')'
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
-		$$.name = D_STATIC;
-		$$.sym = linklookup(ctxt, $1->name, 0);
-		$$.offset = $4;
+		$$.Type_ = D_OREG;
+		$$.Name = D_STATIC;
+		$$.Sym = obj.Linklookup(asm.Ctxt, $1.Name, 0);
+		$$.Offset = $4;
 	}
 
 comma:
@@ -928,7 +941,7 @@ con:
 	LCONST
 |	LVAR
 	{
-		$$ = $1->value;
+		$$ = $1.Value;
 	}
 |	'-' con
 	{
@@ -940,7 +953,7 @@ con:
 	}
 |	'~' con
 	{
-		$$ = ~$2;
+		$$ = ^$2;
 	}
 |	'(' expr ')'
 	{
@@ -971,11 +984,11 @@ expr:
 	}
 |	expr '<' '<' expr
 	{
-		$$ = $1 << $4;
+		$$ = $1 << uint($4);
 	}
 |	expr '>' '>' expr
 	{
-		$$ = $1 >> $4;
+		$$ = $1 >> uint($4);
 	}
 |	expr '&' expr
 	{
diff --git a/src/cmd/new9a/lex.go b/src/cmd/new9a/lex.go
index 9fad91f72a..1cc835f98d 100644
--- a/src/cmd/new9a/lex.go
+++ b/src/cmd/new9a/lex.go
@@ -27,172 +27,67 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+//go:generate go tool yacc a.y
+
 package main
 
-const (
-	Plan9   = 1 << 0
-	Unix    = 1 << 1
-	Windows = 1 << 2
+import (
+	"cmd/internal/asm"
+	"cmd/internal/obj"
+	"cmd/internal/obj/ppc64"
 )
 
-func systemtype(sys int) int {
-	return sys & Windows
-
-	return sys & Plan9
-}
-
-func pathchar() int {
-	return '/'
-}
-
-func Lconv(fp *obj.Fmt) int {
-	return obj.Linklinefmt(ctxt, fp)
-}
-
-func dodef(p string) {
-	if nDlist%8 == 0 {
-		Dlist = allocn(Dlist, nDlist*sizeof(string), 8*sizeof(string)).(*string)
-	}
-	Dlist[nDlist] = p
-	nDlist++
-}
-
-var thelinkarch *obj.LinkArch = &ppc64.Linkppc64
-
-func usage() {
-	fmt.Printf("usage: %ca [options] file.c...\n", thechar)
-	main.Flagprint(1)
-	errorexit()
-}
-
-func main(argc int, argv [XXX]string) {
-	var p string
-
-	thechar = '9'
-	thestring = "ppc64"
-
-	// Allow GOARCH=thestring or GOARCH=thestringsuffix,
-	// but not other values.
-	p = Getgoarch()
-
-	if !strings.HasPrefix(p, thestring) {
-		log.Fatalf("cannot use %cc with GOARCH=%s", thechar, p)
-	}
-	if p == "ppc64le" {
-		thelinkarch = &ppc64.Linkppc64le
-	}
-
-	ctxt = obj.Linknew(thelinkarch)
-	ctxt.Diag = yyerror
-	ctxt.Bso = &bstdout
-	ctxt.Enforce_data_order = 1
-	obj.Binit(&bstdout, 1, main.OWRITE)
-	ppc64.Listinit9()
-	obj.Fmtinstall('L', Lconv)
+var (
+	yyerror = asm.Yyerror
+	nullgen obj.Addr
+)
 
-	ensuresymb(NSYMB)
-	debug = [256]int{}
+func main() {
 	cinit()
-	outfile = ""
-	setinclude(".")
 
-	main.Flagfn1("D", "name[=value]: add #define", dodef)
-	main.Flagfn1("I", "dir: add dir to include path", setinclude)
-	main.Flagcount("S", "print assembly and machine code", &debug['S'])
-	main.Flagcount("m", "debug preprocessor macros", &debug['m'])
-	main.Flagstr("o", "file: set output file", &outfile)
-	main.Flagstr("trimpath", "prefix: remove prefix from recorded source file paths", &ctxt.Trimpath)
-
-	main.Flagparse(&argc, (**string)(&argv), usage)
-	ctxt.Debugasm = int32(debug['S'])
-
-	if argc < 1 {
-		usage()
-	}
-	if argc > 1 {
-		fmt.Printf("can't assemble multiple files\n")
-		errorexit()
+	asm.LSCONST = LSCONST
+	asm.LCONST = LCONST
+	asm.LFCONST = LFCONST
+	asm.LNAME = LNAME
+	asm.LVAR = LVAR
+	asm.LLAB = LLAB
+
+	asm.Lexinit = lexinit
+	asm.Cclean = cclean
+	asm.Yyparse = yyparse
+
+	asm.Thechar = '9'
+	asm.Thestring = "ppc64"
+	asm.Thelinkarch = &ppc64.Linkppc64
+	asm.Arches = map[string]*obj.LinkArch{
+		"ppc64le": &ppc64.Linkppc64le,
 	}
 
-	if assemble(argv[0]) != 0 {
-		errorexit()
-	}
-	obj.Bflush(&bstdout)
-	if nerrors > 0 {
-		errorexit()
-	}
-	main.Exits("")
+	asm.Main()
 }
 
-func assemble(file string) int {
-	var ofile string
-	var p string
-	var i int
-	var of int
-
-	ofile = alloc(int32(len(file)) + 3).(string) // +3 for .x\0 (x=thechar)
-	ofile = file
-	p = main.Utfrrune(ofile, uint(pathchar()))
-	if p != "" {
-		include[0] = ofile
-		p = ""
-		p = p[1:]
-	} else {
-
-		p = ofile
-	}
-	if outfile == "" {
-		outfile = p
-		if outfile != "" {
-			p = main.Utfrrune(outfile, '.')
-			if p != "" {
-				if p[1] == 's' && p[2] == 0 {
-					p = ""
-				}
-			}
-			p = main.Utfrune(outfile, 0)
-			p[0] = '.'
-			p[1] = byte(thechar)
-			p[2] = 0
-		} else {
-
-			outfile = "/dev/null"
-		}
-	}
-
-	of = main.Create(outfile, main.OWRITE, 0664)
-	if of < 0 {
-		yyerror("%ca: cannot create %s", thechar, outfile)
-		errorexit()
-	}
+type yy struct{}
 
-	obj.Binit(&obuf, of, main.OWRITE)
-	fmt.Fprintf(&obuf, "go object %s %s %s\n", main.Getgoos(), main.Getgoarch(), main.Getgoversion())
-	fmt.Fprintf(&obuf, "!\n")
+func (yy) Lex(v *yySymType) int {
+	var av asm.Yylval
+	tok := asm.Yylex(&av)
+	v.sym = av.Sym
+	v.lval = av.Lval
+	v.sval = av.Sval
+	v.dval = av.Dval
+	return tok
+}
 
-	for pass = 1; pass <= 2; pass++ {
-		nosched = 0
-		pinit(file)
-		for i = 0; i < nDlist; i++ {
-			dodefine(Dlist[i])
-		}
-		yyparse()
-		cclean()
-		if nerrors != 0 {
-			return nerrors
-		}
-	}
+func (yy) Error(msg string) {
+	asm.Yyerror("%s", msg)
+}
 
-	obj.Writeobj(ctxt, &obuf)
-	obj.Bflush(&obuf)
-	return 0
+func yyparse() {
+	nosched = 0
+	yyParse(yy{})
 }
 
-var itab = []struct {
-	name  string
-	type_ uint16
-	value uint16
-}{
+var lexinit = []asm.Lextab{
 	{"SP", LSP, ppc64.D_AUTO},
 	{"SB", LSB, ppc64.D_EXTERN},
 	{"FP", LFP, ppc64.D_PARAM},
@@ -549,7 +444,6 @@ var itab = []struct {
 	{"ECIWX", LXLD, ppc64.AECIWX},
 	{"ECOWX", LXST, ppc64.AECOWX},
 	{"LWAR", LXLD, ppc64.ALWAR},
-	{"LWAR", LXLD, ppc64.ALWAR},
 	{"STWCCC", LXST, ppc64.ASTWCCC},
 	{"EIEIO", LRETRN, ppc64.AEIEIO},
 	{"TLBIE", LNOP, ppc64.ATLBIE},
@@ -571,33 +465,10 @@ var itab = []struct {
 }
 
 func cinit() {
-	var s *Sym
-	var i int
-
 	nullgen.Type_ = ppc64.D_NONE
 	nullgen.Name = ppc64.D_NONE
 	nullgen.Reg = ppc64.NREG
 	nullgen.Scale = ppc64.NREG // replaced Gen.xreg with Prog.scale
-
-	nerrors = 0
-
-	iostack = nil
-	iofree = nil
-	peekc = IGN
-	nhunk = 0
-	for i = 0; i < NHASH; i++ {
-		hash[i] = nil
-	}
-	for i = 0; itab[i].name != ""; i++ {
-		s = slookup(itab[i].name)
-		s.type_ = itab[i].type_
-		s.value = int64(itab[i].value)
-	}
-}
-
-func syminit(s *Sym) {
-	s.type_ = LNAME
-	s.value = 0
 }
 
 func cclean() {
@@ -605,12 +476,13 @@ func cclean() {
 }
 
 var lastpc *obj.Prog
+var nosched int
 
 func outcode(a int, g1 *obj.Addr, reg int, g2 *obj.Addr) {
 	var p *obj.Prog
 	var pl *obj.Plist
 
-	if pass == 1 {
+	if asm.Pass == 1 {
 		goto out
 	}
 
@@ -626,43 +498,42 @@ func outcode(a int, g1 *obj.Addr, reg int, g2 *obj.Addr) {
 		reg = int(g2.Scale)
 	}
 
-	p = ctxt.Arch.Prg()
+	p = asm.Ctxt.Arch.Prg()
 	p.As = int16(a)
-	p.Lineno = lineno
+	p.Lineno = asm.Lineno
 	if nosched != 0 {
 		p.Mark |= ppc64.NOSCHED
 	}
 	p.From = *g1
 	p.Reg = uint8(reg)
 	p.To = *g2
-	p.Pc = int64(pc)
+	p.Pc = int64(asm.PC)
 
 	if lastpc == nil {
-		pl = obj.Linknewplist(ctxt)
+		pl = obj.Linknewplist(asm.Ctxt)
 		pl.Firstpc = p
 	} else {
-
 		lastpc.Link = p
 	}
 	lastpc = p
 
 out:
 	if a != ppc64.AGLOBL && a != ppc64.ADATA {
-		pc++
+		asm.PC++
 	}
 }
 
-func outgcode(a int, g1 *obj.Addr, reg int, g2 *obj.Addr, g3 *obj.Addr) {
+func outgcode(a int, g1 *obj.Addr, reg int, g2, g3 *obj.Addr) {
 	var p *obj.Prog
 	var pl *obj.Plist
 
-	if pass == 1 {
+	if asm.Pass == 1 {
 		goto out
 	}
 
-	p = ctxt.Arch.Prg()
+	p = asm.Ctxt.Arch.Prg()
 	p.As = int16(a)
-	p.Lineno = lineno
+	p.Lineno = asm.Lineno
 	if nosched != 0 {
 		p.Mark |= ppc64.NOSCHED
 	}
@@ -670,19 +541,18 @@ func outgcode(a int, g1 *obj.Addr, reg int, g2 *obj.Addr, g3 *obj.Addr) {
 	p.Reg = uint8(reg)
 	p.From3 = *g2
 	p.To = *g3
-	p.Pc = int64(pc)
+	p.Pc = int64(asm.PC)
 
 	if lastpc == nil {
-		pl = obj.Linknewplist(ctxt)
+		pl = obj.Linknewplist(asm.Ctxt)
 		pl.Firstpc = p
 	} else {
-
 		lastpc.Link = p
 	}
 	lastpc = p
 
 out:
 	if a != ppc64.AGLOBL && a != ppc64.ADATA {
-		pc++
+		asm.PC++
 	}
 }
diff --git a/src/cmd/new9a/y.go b/src/cmd/new9a/y.go
new file mode 100644
index 0000000000..bb844ff152
--- /dev/null
+++ b/src/cmd/new9a/y.go
@@ -0,0 +1,1694 @@
+//line a.y:31
+package main
+
+import __yyfmt__ "fmt"
+
+//line a.y:31
+import (
+	"cmd/internal/asm"
+	"cmd/internal/obj"
+	. "cmd/internal/obj/ppc64"
+)
+
+//line a.y:40
+type yySymType struct {
+	yys  int
+	sym  *asm.Sym
+	lval int64
+	dval float64
+	sval string
+	addr obj.Addr
+}
+
+const LMOVW = 57346
+const LMOVB = 57347
+const LABS = 57348
+const LLOGW = 57349
+const LSHW = 57350
+const LADDW = 57351
+const LCMP = 57352
+const LCROP = 57353
+const LBRA = 57354
+const LFMOV = 57355
+const LFCONV = 57356
+const LFCMP = 57357
+const LFADD = 57358
+const LFMA = 57359
+const LTRAP = 57360
+const LXORW = 57361
+const LNOP = 57362
+const LEND = 57363
+const LRETT = 57364
+const LWORD = 57365
+const LTEXT = 57366
+const LDATA = 57367
+const LRETRN = 57368
+const LCONST = 57369
+const LSP = 57370
+const LSB = 57371
+const LFP = 57372
+const LPC = 57373
+const LCREG = 57374
+const LFLUSH = 57375
+const LREG = 57376
+const LFREG = 57377
+const LR = 57378
+const LCR = 57379
+const LF = 57380
+const LFPSCR = 57381
+const LLR = 57382
+const LCTR = 57383
+const LSPR = 57384
+const LSPREG = 57385
+const LSEG = 57386
+const LMSR = 57387
+const LPCDAT = 57388
+const LFUNCDAT = 57389
+const LSCHED = 57390
+const LXLD = 57391
+const LXST = 57392
+const LXOP = 57393
+const LXMV = 57394
+const LRLWM = 57395
+const LMOVMW = 57396
+const LMOVEM = 57397
+const LMOVFL = 57398
+const LMTFSB = 57399
+const LMA = 57400
+const LFCONST = 57401
+const LSCONST = 57402
+const LNAME = 57403
+const LLAB = 57404
+const LVAR = 57405
+
+var yyToknames = []string{
+	"'|'",
+	"'^'",
+	"'&'",
+	"'<'",
+	"'>'",
+	"'+'",
+	"'-'",
+	"'*'",
+	"'/'",
+	"'%'",
+	"LMOVW",
+	"LMOVB",
+	"LABS",
+	"LLOGW",
+	"LSHW",
+	"LADDW",
+	"LCMP",
+	"LCROP",
+	"LBRA",
+	"LFMOV",
+	"LFCONV",
+	"LFCMP",
+	"LFADD",
+	"LFMA",
+	"LTRAP",
+	"LXORW",
+	"LNOP",
+	"LEND",
+	"LRETT",
+	"LWORD",
+	"LTEXT",
+	"LDATA",
+	"LRETRN",
+	"LCONST",
+	"LSP",
+	"LSB",
+	"LFP",
+	"LPC",
+	"LCREG",
+	"LFLUSH",
+	"LREG",
+	"LFREG",
+	"LR",
+	"LCR",
+	"LF",
+	"LFPSCR",
+	"LLR",
+	"LCTR",
+	"LSPR",
+	"LSPREG",
+	"LSEG",
+	"LMSR",
+	"LPCDAT",
+	"LFUNCDAT",
+	"LSCHED",
+	"LXLD",
+	"LXST",
+	"LXOP",
+	"LXMV",
+	"LRLWM",
+	"LMOVMW",
+	"LMOVEM",
+	"LMOVFL",
+	"LMTFSB",
+	"LMA",
+	"LFCONST",
+	"LSCONST",
+	"LNAME",
+	"LLAB",
+	"LVAR",
+}
+var yyStatenames = []string{}
+
+const yyEofCode = 1
+const yyErrCode = 2
+const yyMaxDepth = 200
+
+//line yacctab:1
+var yyExca = []int{
+	-1, 1,
+	1, -1,
+	-2, 0,
+}
+
+const yyNprod = 183
+const yyPrivate = 57344
+
+var yyTokenNames []string
+var yyStates []string
+
+const yyLast = 885
+
+var yyAct = []int{
+
+	46, 52, 88, 421, 100, 431, 103, 169, 2, 92,
+	64, 83, 56, 276, 93, 95, 96, 98, 99, 50,
+	54, 111, 49, 271, 55, 444, 119, 121, 123, 443,
+	126, 128, 432, 131, 89, 136, 72, 411, 73, 78,
+	77, 125, 125, 92, 115, 116, 117, 118, 410, 72,
+	61, 73, 72, 62, 73, 132, 400, 51, 161, 399,
+	78, 442, 381, 380, 202, 440, 377, 75, 366, 53,
+	91, 94, 92, 97, 365, 364, 78, 77, 112, 363,
+	81, 82, 133, 275, 120, 92, 125, 146, 75, 107,
+	134, 135, 137, 138, 72, 361, 73, 59, 59, 59,
+	145, 147, 360, 76, 75, 314, 101, 108, 102, 65,
+	401, 79, 359, 196, 110, 59, 282, 203, 195, 202,
+	183, 164, 74, 159, 76, 141, 141, 114, 45, 102,
+	92, 48, 79, 229, 222, 201, 202, 166, 109, 168,
+	76, 167, 85, 87, 106, 105, 162, 439, 79, 244,
+	252, 253, 165, 231, 261, 263, 223, 267, 268, 269,
+	124, 250, 127, 129, 438, 173, 174, 175, 437, 251,
+	436, 256, 435, 249, 392, 258, 265, 286, 289, 290,
+	186, 391, 390, 389, 388, 387, 386, 385, 301, 303,
+	305, 307, 309, 310, 199, 384, 383, 382, 376, 312,
+	375, 374, 291, 292, 293, 294, 247, 316, 319, 257,
+	373, 315, 330, 332, 333, 334, 372, 336, 248, 340,
+	371, 370, 259, 369, 358, 264, 266, 357, 228, 227,
+	326, 327, 328, 329, 226, 114, 59, 219, 218, 59,
+	217, 216, 215, 214, 213, 300, 212, 211, 210, 209,
+	278, 163, 208, 207, 279, 280, 281, 206, 204, 284,
+	285, 47, 84, 86, 59, 200, 194, 193, 192, 331,
+	59, 104, 191, 298, 337, 339, 78, 77, 190, 122,
+	246, 189, 313, 255, 342, 188, 344, 113, 199, 322,
+	187, 368, 347, 348, 349, 350, 351, 185, 182, 354,
+	355, 356, 181, 59, 75, 57, 367, 180, 288, 179,
+	178, 72, 177, 73, 296, 59, 345, 176, 346, 158,
+	130, 157, 156, 155, 139, 154, 153, 143, 152, 78,
+	77, 378, 151, 150, 379, 149, 148, 44, 74, 43,
+	76, 42, 40, 41, 297, 60, 63, 396, 79, 338,
+	72, 341, 73, 61, 184, 262, 62, 75, 197, 65,
+	433, 78, 77, 230, 110, 61, 160, 72, 62, 73,
+	402, 403, 404, 405, 406, 407, 408, 441, 397, 353,
+	65, 409, 395, 61, 283, 110, 62, 412, 352, 75,
+	425, 74, 424, 76, 429, 430, 171, 172, 60, 205,
+	245, 79, 7, 254, 144, 415, 416, 1, 78, 77,
+	69, 393, 394, 183, 72, 61, 73, 260, 62, 220,
+	221, 297, 71, 224, 225, 76, 70, 434, 287, 0,
+	102, 160, 0, 79, 295, 58, 75, 446, 447, 0,
+	449, 450, 78, 77, 0, 420, 423, 398, 0, 427,
+	428, 0, 317, 320, 417, 418, 419, 65, 445, 72,
+	0, 73, 110, 0, 101, 270, 0, 335, 199, 0,
+	75, 0, 76, 140, 142, 422, 422, 102, 61, 343,
+	79, 62, 0, 242, 241, 240, 238, 239, 233, 234,
+	235, 236, 237, 299, 302, 304, 306, 308, 0, 311,
+	0, 273, 272, 274, 74, 0, 76, 72, 270, 73,
+	324, 60, 325, 90, 79, 273, 272, 274, 170, 165,
+	171, 172, 426, 65, 0, 0, 448, 0, 110, 451,
+	173, 8, 0, 68, 67, 0, 80, 233, 234, 235,
+	236, 237, 0, 9, 10, 16, 14, 15, 13, 25,
+	18, 19, 11, 21, 24, 22, 23, 20, 277, 32,
+	36, 0, 33, 37, 38, 39, 0, 78, 77, 0,
+	0, 78, 77, 273, 272, 274, 323, 0, 0, 72,
+	0, 73, 362, 0, 0, 34, 35, 5, 28, 29,
+	31, 30, 26, 27, 0, 75, 12, 17, 0, 75,
+	3, 0, 4, 0, 65, 6, 72, 61, 73, 66,
+	62, 63, 81, 82, 68, 67, 0, 80, 78, 77,
+	241, 240, 238, 239, 233, 234, 235, 236, 237, 78,
+	77, 76, 413, 74, 0, 76, 102, 0, 92, 79,
+	60, 0, 64, 79, 78, 77, 75, 0, 78, 77,
+	0, 65, 0, 72, 0, 73, 66, 75, 0, 81,
+	82, 68, 67, 0, 80, 0, 0, 78, 77, 63,
+	0, 0, 75, 235, 236, 237, 75, 0, 0, 72,
+	74, 73, 76, 78, 77, 0, 0, 60, 0, 92,
+	79, 74, 0, 76, 0, 75, 78, 77, 60, 0,
+	92, 79, 72, 0, 73, 0, 74, 0, 76, 164,
+	74, 75, 76, 102, 78, 77, 79, 102, 78, 77,
+	79, 0, 0, 0, 75, 0, 0, 0, 0, 78,
+	77, 76, 0, 0, 0, 0, 102, 0, 0, 79,
+	0, 0, 75, 0, 0, 109, 75, 76, 0, 0,
+	0, 0, 414, 0, 0, 79, 0, 75, 74, 0,
+	76, 0, 0, 0, 0, 102, 0, 0, 79, 238,
+	239, 233, 234, 235, 236, 237, 109, 0, 76, 0,
+	109, 0, 76, 321, 0, 0, 79, 318, 0, 0,
+	79, 109, 0, 76, 0, 0, 0, 0, 198, 0,
+	0, 79, 242, 241, 240, 238, 239, 233, 234, 235,
+	236, 237, 242, 241, 240, 238, 239, 233, 234, 235,
+	236, 237, 240, 238, 239, 233, 234, 235, 236, 237,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 243, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 232,
+}
+var yyPact = []int{
+
+	-1000, 529, -1000, 268, 266, 263, -1000, 261, 52, 562,
+	267, 433, -71, -8, 323, -8, 323, 323, 399, 67,
+	50, 308, 308, 308, 308, 323, -8, 635, -36, 323,
+	8, -36, 5, -70, -71, -71, 158, 687, 687, 158,
+	-1000, 399, 399, -1000, -1000, -1000, 259, 258, 256, 255,
+	251, 249, 248, 246, 245, 244, 242, -1000, -1000, 45,
+	658, -1000, 68, -1000, 639, -1000, 59, -1000, 63, -1000,
+	-1000, -1000, -1000, 61, 511, -1000, -1000, 399, 399, 399,
+	-1000, -1000, -1000, 240, 235, 233, 232, 230, 225, 221,
+	344, 220, 399, 213, 208, 204, 201, 195, 191, 190,
+	189, -1000, 399, -1000, -1000, 30, 720, 188, 58, 511,
+	59, 181, 180, -1000, -1000, 176, 175, 172, 171, 170,
+	169, 167, 166, 165, 164, 323, 163, 161, 160, -1000,
+	-1000, 158, 158, 370, -1000, 158, 158, 157, 152, -1000,
+	151, 55, 351, -1000, 529, 808, -1000, 798, 609, 323,
+	323, 620, 338, 306, 323, 481, 415, 323, 323, 463,
+	4, 479, 399, -1000, -1000, 45, 399, 399, 399, 38,
+	376, 399, 399, -1000, -1000, -1000, 267, 323, 323, 308,
+	308, 308, 320, -1000, 275, 399, -1000, -8, 323, 323,
+	323, 323, 323, 323, 399, 26, -1000, -1000, 30, 41,
+	709, 705, 535, 38, 323, -1000, 323, 308, 308, 308,
+	308, -8, 323, 323, 323, 687, -8, -37, 323, -36,
+	-1000, -1000, -1000, -1000, -1000, -1000, -71, 687, 558, 477,
+	399, -1000, -1000, 399, 399, 399, 399, 399, 381, 371,
+	399, 399, 399, -1000, -1000, -1000, -1000, 150, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, 147, -1000, -1000,
+	-1000, -1000, 34, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	23, 16, -1000, -1000, -1000, -1000, 323, -1000, 0, -4,
+	-5, -11, 477, 387, -1000, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, 146,
+	144, -1000, 143, -1000, 139, -1000, 133, -1000, 124, -1000,
+	-1000, 123, -1000, 121, -1000, -13, -1000, -1000, 30, -1000,
+	-1000, 30, -14, -17, -1000, -1000, -1000, 120, 119, 118,
+	110, 109, 108, 107, -1000, -1000, -1000, 106, -1000, 105,
+	-1000, -1000, -1000, -1000, -1000, 104, 97, 662, 662, -1000,
+	-1000, -1000, 399, 399, 762, 816, 615, 300, 297, 399,
+	-1000, -1000, -20, -1000, -1000, -1000, -1000, -23, 32, 323,
+	323, 323, 323, 323, 323, 323, 399, -1000, -31, -42,
+	674, -1000, 308, 308, 317, 317, 317, 558, 558, 323,
+	-36, -71, -75, 528, 528, -1000, -1000, -1000, -47, -1000,
+	-1000, 321, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, 30, -1000, 95, -1000, -1000, -1000,
+	93, 91, 87, 70, -12, -1000, -1000, 367, -1000, -1000,
+	-1000, 51, -1000, -50, -54, 308, 323, 323, 399, 323,
+	323, 399, 352, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000,
+}
+var yyPgo = []int{
+
+	0, 87, 58, 23, 7, 305, 251, 0, 131, 435,
+	69, 22, 12, 426, 422, 57, 1, 2, 6, 20,
+	24, 4, 19, 417, 410, 3, 407, 8, 404, 402,
+	287,
+}
+var yyR1 = []int{
+
+	0, 26, 26, 28, 27, 27, 27, 27, 27, 27,
+	27, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+	29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+	29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+	29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+	29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+	29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+	29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+	29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+	29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+	29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+	29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+	29, 29, 29, 29, 18, 18, 7, 12, 12, 13,
+	20, 14, 24, 19, 19, 19, 22, 23, 11, 11,
+	10, 10, 21, 25, 16, 16, 17, 17, 15, 5,
+	5, 8, 8, 6, 6, 9, 9, 9, 30, 30,
+	4, 4, 4, 3, 3, 3, 1, 1, 1, 1,
+	1, 1, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2,
+}
+var yyR2 = []int{
+
+	0, 0, 2, 0, 4, 4, 4, 2, 1, 2,
+	2, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+	4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+	4, 6, 4, 4, 4, 6, 4, 4, 6, 6,
+	6, 4, 4, 6, 4, 6, 4, 6, 4, 4,
+	2, 6, 4, 4, 4, 6, 4, 4, 4, 4,
+	4, 4, 4, 4, 2, 2, 4, 3, 3, 5,
+	4, 4, 6, 4, 4, 6, 6, 6, 8, 4,
+	4, 3, 2, 4, 4, 6, 8, 4, 6, 4,
+	4, 6, 6, 8, 8, 8, 8, 4, 4, 4,
+	6, 4, 6, 4, 4, 2, 2, 3, 3, 3,
+	3, 2, 3, 3, 4, 4, 2, 4, 6, 8,
+	6, 6, 6, 2, 4, 2, 1, 1, 1, 1,
+	1, 1, 1, 1, 4, 1, 1, 4, 1, 4,
+	1, 4, 1, 3, 2, 2, 2, 3, 2, 1,
+	4, 3, 5, 1, 4, 4, 5, 7, 0, 1,
+	0, 2, 2, 1, 1, 1, 1, 1, 2, 2,
+	2, 3, 1, 3, 3, 3, 3, 3, 4, 4,
+	3, 3, 3,
+}
+var yyChk = []int{
+
+	-1000, -26, -27, 71, 73, 58, 76, -29, 2, 14,
+	15, 23, 67, 19, 17, 18, 16, 68, 21, 22,
+	28, 24, 26, 27, 25, 20, 63, 64, 59, 60,
+	62, 61, 30, 33, 56, 57, 31, 34, 35, 36,
+	74, 75, 75, 76, 76, 76, -7, -6, -8, -11,
+	-22, -15, -16, -10, -19, -20, -12, -5, -9, -1,
+	78, 45, 48, 49, 80, 42, 47, 53, 52, -24,
+	-13, -14, 44, 46, 71, 37, 73, 10, 9, 81,
+	55, 50, 51, -7, -6, -8, -6, -8, -17, -11,
+	80, -15, 80, -7, -15, -7, -7, -15, -7, -7,
+	-21, -1, 78, -18, -6, 78, 77, -10, -1, 71,
+	47, -7, -15, -30, 77, -11, -11, -11, -11, -7,
+	-15, -7, -6, -7, -8, 78, -7, -8, -7, -8,
+	-30, -7, -11, 77, -15, -15, -16, -15, -15, -30,
+	-9, -1, -9, -30, -28, -2, -1, -2, 77, 77,
+	77, 77, 77, 77, 77, 77, 77, 77, 77, 78,
+	-5, -2, 78, -6, 70, -1, 78, 78, 78, -4,
+	7, 9, 10, -1, -1, -1, 77, 77, 77, 77,
+	77, 77, 77, 69, 10, 77, -1, 77, 77, 77,
+	77, 77, 77, 77, 77, -12, -18, -6, 78, -1,
+	77, 77, 78, -4, 77, -30, 77, 77, 77, 77,
+	77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
+	-30, -30, -7, -11, -30, -30, 77, 77, 77, 78,
+	12, -27, 76, 9, 10, 11, 12, 13, 7, 8,
+	6, 5, 4, 76, -7, -6, -8, -15, -10, -20,
+	-12, -19, -7, -7, -6, -8, -22, -15, -11, -10,
+	-23, -7, 49, -7, -10, -19, -10, -7, -7, -7,
+	-5, -3, 39, 38, 40, 79, 9, 79, -1, -1,
+	-1, -1, 78, 8, -1, -1, -7, -6, -8, -7,
+	-7, -11, -11, -11, -11, -6, -8, 69, -1, -5,
+	-15, -7, -5, -7, -5, -7, -5, -7, -5, -7,
+	-7, -5, -21, -1, 79, -12, -18, -6, 78, -18,
+	-6, 78, -1, 41, -5, -5, -11, -11, -11, -11,
+	-7, -15, -7, -7, -7, -6, -7, -15, -8, -15,
+	-7, -8, -15, -6, -15, -1, -1, -2, -2, -2,
+	-2, -2, 7, 8, -2, -2, -2, 77, 77, 78,
+	79, 79, -5, 79, 79, 79, 79, -3, -4, 77,
+	77, 77, 77, 77, 77, 77, 77, 79, -12, -12,
+	77, 79, 77, 77, 77, 77, 77, 77, 77, 77,
+	77, 77, 77, -2, -2, -20, 47, -22, -1, 79,
+	79, 78, -7, -7, -7, -7, -7, -7, -7, -21,
+	79, 79, -18, -6, 78, -11, -11, -10, -10, -10,
+	-15, -25, -1, -15, -25, -7, -8, -15, -15, -16,
+	-17, 80, 79, 39, -12, 77, 77, 77, 77, 77,
+	77, 10, 10, 79, 79, -11, -7, -7, -1, -7,
+	-7, -1,
+}
+var yyDef = []int{
+
+	1, -2, 2, 0, 0, 0, 8, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	158, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 158, 0, 0, 0, 158, 0, 0, 158,
+	3, 0, 0, 7, 9, 10, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 126, 153, 0,
+	0, 138, 0, 136, 0, 140, 130, 133, 0, 135,
+	127, 128, 149, 0, 160, 166, 167, 0, 0, 0,
+	132, 129, 131, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 50, 0,
+	0, 142, 0, 64, 65, 0, 0, 0, 0, 160,
+	0, 158, 0, 82, 159, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 105,
+	106, 158, 158, 159, 111, 158, 158, 0, 0, 116,
+	0, 0, 0, 123, 0, 0, 172, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 144, 145, 148, 0, 0, 0, 0,
+	0, 0, 0, 168, 169, 170, 0, 0, 0, 0,
+	0, 0, 0, 146, 0, 0, 148, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 67, 68, 0, 0,
+	0, 0, 0, 125, 159, 81, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	107, 108, 109, 110, 112, 113, 0, 0, 0, 0,
+	0, 4, 5, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 6, 11, 23, 24, 0, 36, 37,
+	61, 63, 12, 13, 27, 28, 30, 0, 29, 32,
+	33, 52, 0, 53, 56, 62, 57, 59, 58, 60,
+	0, 0, 163, 164, 165, 151, 0, 171, 0, 0,
+	0, 0, 0, 160, 161, 162, 14, 25, 26, 15,
+	16, 17, 18, 19, 20, 21, 22, 147, 34, 126,
+	0, 41, 126, 42, 126, 44, 126, 46, 126, 48,
+	49, 0, 54, 142, 66, 0, 70, 71, 0, 73,
+	74, 0, 0, 0, 79, 80, 83, 84, 0, 87,
+	89, 90, 0, 0, 97, 98, 99, 0, 101, 0,
+	103, 104, 114, 115, 117, 0, 0, 173, 174, 175,
+	176, 177, 0, 0, 180, 181, 182, 0, 0, 0,
+	154, 155, 0, 139, 141, 134, 150, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 69, 0, 0,
+	0, 124, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 178, 179, 35, 130, 31, 0, 152,
+	156, 0, 38, 40, 39, 43, 45, 47, 51, 55,
+	72, 75, 76, 77, 0, 85, 0, 88, 91, 92,
+	0, 0, 0, 0, 0, 100, 102, 118, 120, 121,
+	122, 0, 137, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 157, 78, 86, 93, 94, 143, 95,
+	96, 119,
+}
+var yyTok1 = []int{
+
+	1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 80, 13, 6, 3,
+	78, 79, 11, 9, 77, 10, 3, 12, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 74, 76,
+	7, 75, 8, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 5, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 4, 3, 81,
+}
+var yyTok2 = []int{
+
+	2, 3, 14, 15, 16, 17, 18, 19, 20, 21,
+	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
+	42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
+	52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
+	62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
+	72, 73,
+}
+var yyTok3 = []int{
+	0,
+}
+
+//line yaccpar:1
+
+/*	parser for yacc output	*/
+
+var yyDebug = 0
+
+type yyLexer interface {
+	Lex(lval *yySymType) int
+	Error(s string)
+}
+
+const yyFlag = -1000
+
+func yyTokname(c int) string {
+	// 4 is TOKSTART above
+	if c >= 4 && c-4 < len(yyToknames) {
+		if yyToknames[c-4] != "" {
+			return yyToknames[c-4]
+		}
+	}
+	return __yyfmt__.Sprintf("tok-%v", c)
+}
+
+func yyStatname(s int) string {
+	if s >= 0 && s < len(yyStatenames) {
+		if yyStatenames[s] != "" {
+			return yyStatenames[s]
+		}
+	}
+	return __yyfmt__.Sprintf("state-%v", s)
+}
+
+func yylex1(lex yyLexer, lval *yySymType) int {
+	c := 0
+	char := lex.Lex(lval)
+	if char <= 0 {
+		c = yyTok1[0]
+		goto out
+	}
+	if char < len(yyTok1) {
+		c = yyTok1[char]
+		goto out
+	}
+	if char >= yyPrivate {
+		if char < yyPrivate+len(yyTok2) {
+			c = yyTok2[char-yyPrivate]
+			goto out
+		}
+	}
+	for i := 0; i < len(yyTok3); i += 2 {
+		c = yyTok3[i+0]
+		if c == char {
+			c = yyTok3[i+1]
+			goto out
+		}
+	}
+
+out:
+	if c == 0 {
+		c = yyTok2[1] /* unknown char */
+	}
+	if yyDebug >= 3 {
+		__yyfmt__.Printf("lex %s(%d)\n", yyTokname(c), uint(char))
+	}
+	return c
+}
+
+func yyParse(yylex yyLexer) int {
+	var yyn int
+	var yylval yySymType
+	var yyVAL yySymType
+	yyS := make([]yySymType, yyMaxDepth)
+
+	Nerrs := 0   /* number of errors */
+	Errflag := 0 /* error recovery flag */
+	yystate := 0
+	yychar := -1
+	yyp := -1
+	goto yystack
+
+ret0:
+	return 0
+
+ret1:
+	return 1
+
+yystack:
+	/* put a state and value onto the stack */
+	if yyDebug >= 4 {
+		__yyfmt__.Printf("char %v in %v\n", yyTokname(yychar), yyStatname(yystate))
+	}
+
+	yyp++
+	if yyp >= len(yyS) {
+		nyys := make([]yySymType, len(yyS)*2)
+		copy(nyys, yyS)
+		yyS = nyys
+	}
+	yyS[yyp] = yyVAL
+	yyS[yyp].yys = yystate
+
+yynewstate:
+	yyn = yyPact[yystate]
+	if yyn <= yyFlag {
+		goto yydefault /* simple state */
+	}
+	if yychar < 0 {
+		yychar = yylex1(yylex, &yylval)
+	}
+	yyn += yychar
+	if yyn < 0 || yyn >= yyLast {
+		goto yydefault
+	}
+	yyn = yyAct[yyn]
+	if yyChk[yyn] == yychar { /* valid shift */
+		yychar = -1
+		yyVAL = yylval
+		yystate = yyn
+		if Errflag > 0 {
+			Errflag--
+		}
+		goto yystack
+	}
+
+yydefault:
+	/* default state action */
+	yyn = yyDef[yystate]
+	if yyn == -2 {
+		if yychar < 0 {
+			yychar = yylex1(yylex, &yylval)
+		}
+
+		/* look through exception table */
+		xi := 0
+		for {
+			if yyExca[xi+0] == -1 && yyExca[xi+1] == yystate {
+				break
+			}
+			xi += 2
+		}
+		for xi += 2; ; xi += 2 {
+			yyn = yyExca[xi+0]
+			if yyn < 0 || yyn == yychar {
+				break
+			}
+		}
+		yyn = yyExca[xi+1]
+		if yyn < 0 {
+			goto ret0
+		}
+	}
+	if yyn == 0 {
+		/* error ... attempt to resume parsing */
+		switch Errflag {
+		case 0: /* brand new error */
+			yylex.Error("syntax error")
+			Nerrs++
+			if yyDebug >= 1 {
+				__yyfmt__.Printf("%s", yyStatname(yystate))
+				__yyfmt__.Printf(" saw %s\n", yyTokname(yychar))
+			}
+			fallthrough
+
+		case 1, 2: /* incompletely recovered error ... try again */
+			Errflag = 3
+
+			/* find a state where "error" is a legal shift action */
+			for yyp >= 0 {
+				yyn = yyPact[yyS[yyp].yys] + yyErrCode
+				if yyn >= 0 && yyn < yyLast {
+					yystate = yyAct[yyn] /* simulate a shift of "error" */
+					if yyChk[yystate] == yyErrCode {
+						goto yystack
+					}
+				}
+
+				/* the current p has no shift on "error", pop stack */
+				if yyDebug >= 2 {
+					__yyfmt__.Printf("error recovery pops state %d\n", yyS[yyp].yys)
+				}
+				yyp--
+			}
+			/* there is no state on the stack with an error shift ... abort */
+			goto ret1
+
+		case 3: /* no shift yet; clobber input char */
+			if yyDebug >= 2 {
+				__yyfmt__.Printf("error recovery discards %s\n", yyTokname(yychar))
+			}
+			if yychar == yyEofCode {
+				goto ret1
+			}
+			yychar = -1
+			goto yynewstate /* try again in the same state */
+		}
+	}
+
+	/* reduction by production yyn */
+	if yyDebug >= 2 {
+		__yyfmt__.Printf("reduce %v in:\n\t%v\n", yyn, yyStatname(yystate))
+	}
+
+	yynt := yyn
+	yypt := yyp
+	_ = yypt // guard against "declared and not used"
+
+	yyp -= yyR2[yyn]
+	// yyp is now the index of $0. Perform the default action. Iff the
+	// reduced production is ε, $1 is possibly out of range.
+	if yyp+1 >= len(yyS) {
+		nyys := make([]yySymType, len(yyS)*2)
+		copy(nyys, yyS)
+		yyS = nyys
+	}
+	yyVAL = yyS[yyp+1]
+
+	/* consult goto table to find next state */
+	yyn = yyR1[yyn]
+	yyg := yyPgo[yyn]
+	yyj := yyg + yyS[yyp].yys + 1
+
+	if yyj >= yyLast {
+		yystate = yyAct[yyg]
+	} else {
+		yystate = yyAct[yyj]
+		if yyChk[yystate] != -yyn {
+			yystate = yyAct[yyg]
+		}
+	}
+	// dummy call; replaced with literal code
+	switch yynt {
+
+	case 3:
+		//line a.y:75
+		{
+			yyS[yypt-1].sym = asm.LabelLookup(yyS[yypt-1].sym)
+			if yyS[yypt-1].sym.Type == LLAB && yyS[yypt-1].sym.Value != int64(asm.PC) {
+				yyerror("redeclaration of %s", yyS[yypt-1].sym.Labelname)
+			}
+			yyS[yypt-1].sym.Type = LLAB
+			yyS[yypt-1].sym.Value = int64(asm.PC)
+		}
+	case 5:
+		//line a.y:85
+		{
+			yyS[yypt-3].sym.Type = LVAR
+			yyS[yypt-3].sym.Value = yyS[yypt-1].lval
+		}
+	case 6:
+		//line a.y:90
+		{
+			if yyS[yypt-3].sym.Value != yyS[yypt-1].lval {
+				yyerror("redeclaration of %s", yyS[yypt-3].sym.Name)
+			}
+			yyS[yypt-3].sym.Value = yyS[yypt-1].lval
+		}
+	case 7:
+		//line a.y:97
+		{
+			nosched = int(yyS[yypt-1].lval)
+		}
+	case 11:
+		//line a.y:109
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 12:
+		//line a.y:113
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 13:
+		//line a.y:117
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 14:
+		//line a.y:121
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 15:
+		//line a.y:125
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 16:
+		//line a.y:129
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 17:
+		//line a.y:136
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 18:
+		//line a.y:140
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 19:
+		//line a.y:144
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 20:
+		//line a.y:148
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 21:
+		//line a.y:152
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 22:
+		//line a.y:156
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 23:
+		//line a.y:163
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 24:
+		//line a.y:167
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 25:
+		//line a.y:171
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 26:
+		//line a.y:175
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 27:
+		//line a.y:182
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 28:
+		//line a.y:186
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 29:
+		//line a.y:193
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 30:
+		//line a.y:197
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 31:
+		//line a.y:201
+		{
+			outgcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, NREG, &yyS[yypt-2].addr, &yyS[yypt-0].addr)
+		}
+	case 32:
+		//line a.y:205
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 33:
+		//line a.y:209
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 34:
+		//line a.y:213
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, int(yyS[yypt-0].lval), &nullgen)
+		}
+	case 35:
+		//line a.y:220
+		{
+			outgcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, NREG, &yyS[yypt-2].addr, &yyS[yypt-0].addr)
+		}
+	case 36:
+		//line a.y:224
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 37:
+		//line a.y:228
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 38:
+		//line a.y:238
+		{
+			outcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, int(yyS[yypt-2].lval), &yyS[yypt-0].addr)
+		}
+	case 39:
+		//line a.y:242
+		{
+			outcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, int(yyS[yypt-2].lval), &yyS[yypt-0].addr)
+		}
+	case 40:
+		//line a.y:246
+		{
+			outgcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, NREG, &yyS[yypt-2].addr, &yyS[yypt-0].addr)
+		}
+	case 41:
+		//line a.y:250
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 42:
+		//line a.y:254
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 43:
+		//line a.y:258
+		{
+			outcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, int(yyS[yypt-2].lval), &yyS[yypt-0].addr)
+		}
+	case 44:
+		//line a.y:262
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 45:
+		//line a.y:266
+		{
+			outcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, int(yyS[yypt-2].lval), &yyS[yypt-0].addr)
+		}
+	case 46:
+		//line a.y:270
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 47:
+		//line a.y:274
+		{
+			outcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, int(yyS[yypt-2].lval), &yyS[yypt-0].addr)
+		}
+	case 48:
+		//line a.y:278
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 49:
+		//line a.y:282
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 50:
+		//line a.y:286
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 51:
+		//line a.y:293
+		{
+			outcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, int(yyS[yypt-2].lval), &yyS[yypt-0].addr)
+		}
+	case 52:
+		//line a.y:300
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 53:
+		//line a.y:304
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 54:
+		//line a.y:311
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, int(yyS[yypt-0].addr.Reg), &yyS[yypt-0].addr)
+		}
+	case 55:
+		//line a.y:315
+		{
+			outcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, int(yyS[yypt-2].lval), &yyS[yypt-0].addr)
+		}
+	case 56:
+		//line a.y:323
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 57:
+		//line a.y:327
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 58:
+		//line a.y:331
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 59:
+		//line a.y:335
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 60:
+		//line a.y:339
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 61:
+		//line a.y:343
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 62:
+		//line a.y:347
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 63:
+		//line a.y:351
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 64:
+		//line a.y:360
+		{
+			outcode(int(yyS[yypt-1].lval), &nullgen, NREG, &yyS[yypt-0].addr)
+		}
+	case 65:
+		//line a.y:364
+		{
+			outcode(int(yyS[yypt-1].lval), &nullgen, NREG, &yyS[yypt-0].addr)
+		}
+	case 66:
+		//line a.y:368
+		{
+			outcode(int(yyS[yypt-3].lval), &nullgen, NREG, &yyS[yypt-1].addr)
+		}
+	case 67:
+		//line a.y:372
+		{
+			outcode(int(yyS[yypt-2].lval), &nullgen, NREG, &yyS[yypt-0].addr)
+		}
+	case 68:
+		//line a.y:376
+		{
+			outcode(int(yyS[yypt-2].lval), &nullgen, NREG, &yyS[yypt-0].addr)
+		}
+	case 69:
+		//line a.y:380
+		{
+			outcode(int(yyS[yypt-4].lval), &nullgen, NREG, &yyS[yypt-1].addr)
+		}
+	case 70:
+		//line a.y:384
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 71:
+		//line a.y:388
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 72:
+		//line a.y:392
+		{
+			outcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, NREG, &yyS[yypt-1].addr)
+		}
+	case 73:
+		//line a.y:396
+		{
+			outcode(int(yyS[yypt-3].lval), &nullgen, int(yyS[yypt-2].lval), &yyS[yypt-0].addr)
+		}
+	case 74:
+		//line a.y:400
+		{
+			outcode(int(yyS[yypt-3].lval), &nullgen, int(yyS[yypt-2].lval), &yyS[yypt-0].addr)
+		}
+	case 75:
+		//line a.y:404
+		{
+			outcode(int(yyS[yypt-5].lval), &nullgen, int(yyS[yypt-4].lval), &yyS[yypt-1].addr)
+		}
+	case 76:
+		//line a.y:408
+		{
+			var g obj.Addr
+			g = nullgen
+			g.Type_ = D_CONST
+			g.Offset = yyS[yypt-4].lval
+			outcode(int(yyS[yypt-5].lval), &g, int(yyS[yypt-2].lval), &yyS[yypt-0].addr)
+		}
+	case 77:
+		//line a.y:416
+		{
+			var g obj.Addr
+			g = nullgen
+			g.Type_ = D_CONST
+			g.Offset = yyS[yypt-4].lval
+			outcode(int(yyS[yypt-5].lval), &g, int(yyS[yypt-2].lval), &yyS[yypt-0].addr)
+		}
+	case 78:
+		//line a.y:424
+		{
+			var g obj.Addr
+			g = nullgen
+			g.Type_ = D_CONST
+			g.Offset = yyS[yypt-6].lval
+			outcode(int(yyS[yypt-7].lval), &g, int(yyS[yypt-4].lval), &yyS[yypt-1].addr)
+		}
+	case 79:
+		//line a.y:435
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, int(yyS[yypt-0].lval), &nullgen)
+		}
+	case 80:
+		//line a.y:439
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, int(yyS[yypt-0].lval), &nullgen)
+		}
+	case 81:
+		//line a.y:443
+		{
+			outcode(int(yyS[yypt-2].lval), &yyS[yypt-1].addr, NREG, &nullgen)
+		}
+	case 82:
+		//line a.y:447
+		{
+			outcode(int(yyS[yypt-1].lval), &nullgen, NREG, &nullgen)
+		}
+	case 83:
+		//line a.y:454
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 84:
+		//line a.y:458
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 85:
+		//line a.y:462
+		{
+			outcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, int(yyS[yypt-2].addr.Reg), &yyS[yypt-0].addr)
+		}
+	case 86:
+		//line a.y:466
+		{
+			outgcode(int(yyS[yypt-7].lval), &yyS[yypt-6].addr, int(yyS[yypt-4].addr.Reg), &yyS[yypt-2].addr, &yyS[yypt-0].addr)
+		}
+	case 87:
+		//line a.y:470
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 88:
+		//line a.y:474
+		{
+			outcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, int(yyS[yypt-0].addr.Reg), &yyS[yypt-2].addr)
+		}
+	case 89:
+		//line a.y:481
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 90:
+		//line a.y:485
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 91:
+		//line a.y:489
+		{
+			outcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, int(yyS[yypt-0].addr.Reg), &yyS[yypt-2].addr)
+		}
+	case 92:
+		//line a.y:493
+		{
+			outcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, int(yyS[yypt-0].addr.Reg), &yyS[yypt-2].addr)
+		}
+	case 93:
+		//line a.y:500
+		{
+			outgcode(int(yyS[yypt-7].lval), &yyS[yypt-6].addr, int(yyS[yypt-4].addr.Reg), &yyS[yypt-2].addr, &yyS[yypt-0].addr)
+		}
+	case 94:
+		//line a.y:504
+		{
+			outgcode(int(yyS[yypt-7].lval), &yyS[yypt-6].addr, int(yyS[yypt-4].addr.Reg), &yyS[yypt-2].addr, &yyS[yypt-0].addr)
+		}
+	case 95:
+		//line a.y:508
+		{
+			outgcode(int(yyS[yypt-7].lval), &yyS[yypt-6].addr, int(yyS[yypt-4].addr.Reg), &yyS[yypt-2].addr, &yyS[yypt-0].addr)
+		}
+	case 96:
+		//line a.y:512
+		{
+			outgcode(int(yyS[yypt-7].lval), &yyS[yypt-6].addr, int(yyS[yypt-4].addr.Reg), &yyS[yypt-2].addr, &yyS[yypt-0].addr)
+		}
+	case 97:
+		//line a.y:519
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 98:
+		//line a.y:523
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 99:
+		//line a.y:531
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 100:
+		//line a.y:535
+		{
+			outgcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, NREG, &yyS[yypt-2].addr, &yyS[yypt-0].addr)
+		}
+	case 101:
+		//line a.y:539
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 102:
+		//line a.y:543
+		{
+			outgcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, NREG, &yyS[yypt-2].addr, &yyS[yypt-0].addr)
+		}
+	case 103:
+		//line a.y:547
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 104:
+		//line a.y:551
+		{
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 105:
+		//line a.y:555
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr, NREG, &nullgen)
+		}
+	case 106:
+		//line a.y:562
+		{
+			outcode(int(yyS[yypt-1].lval), &nullgen, NREG, &nullgen)
+		}
+	case 107:
+		//line a.y:566
+		{
+			outcode(int(yyS[yypt-2].lval), &yyS[yypt-1].addr, NREG, &nullgen)
+		}
+	case 108:
+		//line a.y:570
+		{
+			outcode(int(yyS[yypt-2].lval), &yyS[yypt-1].addr, NREG, &nullgen)
+		}
+	case 109:
+		//line a.y:574
+		{
+			outcode(int(yyS[yypt-2].lval), &nullgen, NREG, &yyS[yypt-0].addr)
+		}
+	case 110:
+		//line a.y:578
+		{
+			outcode(int(yyS[yypt-2].lval), &nullgen, NREG, &yyS[yypt-0].addr)
+		}
+	case 111:
+		//line a.y:582
+		{
+			outcode(int(yyS[yypt-1].lval), &yyS[yypt-0].addr, NREG, &nullgen)
+		}
+	case 112:
+		//line a.y:589
+		{
+			outcode(int(yyS[yypt-2].lval), &yyS[yypt-1].addr, NREG, &nullgen)
+		}
+	case 113:
+		//line a.y:593
+		{
+			outcode(int(yyS[yypt-2].lval), &yyS[yypt-1].addr, NREG, &nullgen)
+		}
+	case 114:
+		//line a.y:600
+		{
+			if yyS[yypt-2].addr.Type_ != D_CONST || yyS[yypt-0].addr.Type_ != D_CONST {
+				yyerror("arguments to PCDATA must be integer constants")
+			}
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 115:
+		//line a.y:610
+		{
+			if yyS[yypt-2].addr.Type_ != D_CONST {
+				yyerror("index for FUNCDATA must be integer constant")
+			}
+			if yyS[yypt-0].addr.Type_ != D_EXTERN && yyS[yypt-0].addr.Type_ != D_STATIC && yyS[yypt-0].addr.Type_ != D_OREG {
+				yyerror("value for FUNCDATA must be symbol reference")
+			}
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 116:
+		//line a.y:623
+		{
+			outcode(int(yyS[yypt-1].lval), &nullgen, NREG, &nullgen)
+		}
+	case 117:
+		//line a.y:630
+		{
+			asm.Settext(yyS[yypt-2].addr.Sym)
+			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
+		}
+	case 118:
+		//line a.y:635
+		{
+			asm.Settext(yyS[yypt-4].addr.Sym)
+			yyS[yypt-0].addr.Offset &= 0xffffffff
+			yyS[yypt-0].addr.Offset |= -obj.ArgsSizeUnknown << 32
+			outcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, int(yyS[yypt-2].lval), &yyS[yypt-0].addr)
+		}
+	case 119:
+		//line a.y:642
+		{
+			asm.Settext(yyS[yypt-6].addr.Sym)
+			yyS[yypt-2].addr.Offset &= 0xffffffff
+			yyS[yypt-2].addr.Offset |= (yyS[yypt-0].lval & 0xffffffff) << 32
+			outcode(int(yyS[yypt-7].lval), &yyS[yypt-6].addr, int(yyS[yypt-4].lval), &yyS[yypt-2].addr)
+		}
+	case 120:
+		//line a.y:652
+		{
+			outcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, int(yyS[yypt-2].lval), &yyS[yypt-0].addr)
+		}
+	case 121:
+		//line a.y:656
+		{
+			outcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, int(yyS[yypt-2].lval), &yyS[yypt-0].addr)
+		}
+	case 122:
+		//line a.y:660
+		{
+			outcode(int(yyS[yypt-5].lval), &yyS[yypt-4].addr, int(yyS[yypt-2].lval), &yyS[yypt-0].addr)
+		}
+	case 123:
+		//line a.y:667
+		{
+			outcode(int(yyS[yypt-1].lval), &nullgen, NREG, &nullgen)
+		}
+	case 124:
+		//line a.y:673
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_BRANCH
+			yyVAL.addr.Offset = yyS[yypt-3].lval + int64(asm.PC)
+		}
+	case 125:
+		//line a.y:679
+		{
+			yyS[yypt-1].sym = asm.LabelLookup(yyS[yypt-1].sym)
+			yyVAL.addr = nullgen
+			if asm.Pass == 2 && yyS[yypt-1].sym.Type != LLAB {
+				yyerror("undefined label: %s", yyS[yypt-1].sym.Labelname)
+			}
+			yyVAL.addr.Type_ = D_BRANCH
+			yyVAL.addr.Offset = yyS[yypt-1].sym.Value + yyS[yypt-0].lval
+		}
+	case 126:
+		//line a.y:691
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_REG
+			yyVAL.addr.Reg = int8(yyS[yypt-0].lval)
+		}
+	case 127:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 128:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 129:
+		//line a.y:703
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_SPR
+			yyVAL.addr.Offset = yyS[yypt-0].lval
+		}
+	case 130:
+		//line a.y:711
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_CREG
+			yyVAL.addr.Reg = NREG /* whole register */
+		}
+	case 131:
+		//line a.y:718
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_SPR
+			yyVAL.addr.Offset = yyS[yypt-0].lval
+		}
+	case 132:
+		//line a.y:726
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_MSR
+		}
+	case 133:
+		//line a.y:733
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_SPR
+			yyVAL.addr.Offset = yyS[yypt-0].lval
+		}
+	case 134:
+		//line a.y:739
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = int16(yyS[yypt-3].lval)
+			yyVAL.addr.Offset = yyS[yypt-1].lval
+		}
+	case 135:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 136:
+		//line a.y:748
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_FPSCR
+			yyVAL.addr.Reg = NREG
+		}
+	case 137:
+		//line a.y:756
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_FPSCR
+			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
+		}
+	case 138:
+		//line a.y:764
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_FREG
+			yyVAL.addr.Reg = int8(yyS[yypt-0].lval)
+		}
+	case 139:
+		//line a.y:770
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_FREG
+			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
+		}
+	case 140:
+		//line a.y:778
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_CREG
+			yyVAL.addr.Reg = int8(yyS[yypt-0].lval)
+		}
+	case 141:
+		//line a.y:784
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_CREG
+			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
+		}
+	case 142:
+		//line a.y:792
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_REG
+			yyVAL.addr.Reg = int8(yyS[yypt-0].lval)
+		}
+	case 143:
+		//line a.y:800
+		{
+			var mb, me int
+			var v uint32
+
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_CONST
+			mb = int(yyS[yypt-2].lval)
+			me = int(yyS[yypt-0].lval)
+			if mb < 0 || mb > 31 || me < 0 || me > 31 {
+				yyerror("illegal mask start/end value(s)")
+				mb = 0
+				me = 0
+			}
+			if mb <= me {
+				v = (^uint32(0) >> uint(mb)) & (^uint32(0) << uint(31-me))
+			} else {
+				v = (^uint32(0) >> uint(me+1)) & (^uint32(0) << uint(31-(mb-1)))
+			}
+			yyVAL.addr.Offset = int64(v)
+		}
+	case 144:
+		//line a.y:823
+		{
+			yyVAL.addr = yyS[yypt-0].addr
+			yyVAL.addr.Type_ = D_CONST
+		}
+	case 145:
+		//line a.y:828
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_SCONST
+			yyVAL.addr.U.Sval = yyS[yypt-0].sval
+		}
+	case 146:
+		//line a.y:836
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_FCONST
+			yyVAL.addr.U.Dval = yyS[yypt-0].dval
+		}
+	case 147:
+		//line a.y:842
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_FCONST
+			yyVAL.addr.U.Dval = -yyS[yypt-0].dval
+		}
+	case 148:
+		//line a.y:849
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_CONST
+			yyVAL.addr.Offset = yyS[yypt-0].lval
+		}
+	case 149:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 150:
+		//line a.y:858
+		{
+			if yyVAL.lval < 0 || yyVAL.lval >= NREG {
+				print("register value out of range\n")
+			}
+			yyVAL.lval = yyS[yypt-1].lval
+		}
+	case 151:
+		//line a.y:867
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
+			yyVAL.addr.Offset = 0
+		}
+	case 152:
+		//line a.y:874
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Reg = int8(yyS[yypt-3].lval)
+			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
+			yyVAL.addr.Offset = 0
+		}
+	case 153:
+		yyVAL.addr = yyS[yypt-0].addr
+	case 154:
+		//line a.y:885
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
+			yyVAL.addr.Offset = yyS[yypt-3].lval
+		}
+	case 155:
+		//line a.y:894
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Name = int8(yyS[yypt-1].lval)
+			yyVAL.addr.Sym = nil
+			yyVAL.addr.Offset = yyS[yypt-3].lval
+		}
+	case 156:
+		//line a.y:902
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Name = int8(yyS[yypt-1].lval)
+			yyVAL.addr.Sym = obj.Linklookup(asm.Ctxt, yyS[yypt-4].sym.Name, 0)
+			yyVAL.addr.Offset = yyS[yypt-3].lval
+		}
+	case 157:
+		//line a.y:910
+		{
+			yyVAL.addr = nullgen
+			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Name = D_STATIC
+			yyVAL.addr.Sym = obj.Linklookup(asm.Ctxt, yyS[yypt-6].sym.Name, 0)
+			yyVAL.addr.Offset = yyS[yypt-3].lval
+		}
+	case 160:
+		//line a.y:922
+		{
+			yyVAL.lval = 0
+		}
+	case 161:
+		//line a.y:926
+		{
+			yyVAL.lval = yyS[yypt-0].lval
+		}
+	case 162:
+		//line a.y:930
+		{
+			yyVAL.lval = -yyS[yypt-0].lval
+		}
+	case 163:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 164:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 165:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 166:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 167:
+		//line a.y:942
+		{
+			yyVAL.lval = yyS[yypt-0].sym.Value
+		}
+	case 168:
+		//line a.y:946
+		{
+			yyVAL.lval = -yyS[yypt-0].lval
+		}
+	case 169:
+		//line a.y:950
+		{
+			yyVAL.lval = yyS[yypt-0].lval
+		}
+	case 170:
+		//line a.y:954
+		{
+			yyVAL.lval = ^yyS[yypt-0].lval
+		}
+	case 171:
+		//line a.y:958
+		{
+			yyVAL.lval = yyS[yypt-1].lval
+		}
+	case 172:
+		yyVAL.lval = yyS[yypt-0].lval
+	case 173:
+		//line a.y:965
+		{
+			yyVAL.lval = yyS[yypt-2].lval + yyS[yypt-0].lval
+		}
+	case 174:
+		//line a.y:969
+		{
+			yyVAL.lval = yyS[yypt-2].lval - yyS[yypt-0].lval
+		}
+	case 175:
+		//line a.y:973
+		{
+			yyVAL.lval = yyS[yypt-2].lval * yyS[yypt-0].lval
+		}
+	case 176:
+		//line a.y:977
+		{
+			yyVAL.lval = yyS[yypt-2].lval / yyS[yypt-0].lval
+		}
+	case 177:
+		//line a.y:981
+		{
+			yyVAL.lval = yyS[yypt-2].lval % yyS[yypt-0].lval
+		}
+	case 178:
+		//line a.y:985
+		{
+			yyVAL.lval = yyS[yypt-3].lval << uint(yyS[yypt-0].lval)
+		}
+	case 179:
+		//line a.y:989
+		{
+			yyVAL.lval = yyS[yypt-3].lval >> uint(yyS[yypt-0].lval)
+		}
+	case 180:
+		//line a.y:993
+		{
+			yyVAL.lval = yyS[yypt-2].lval & yyS[yypt-0].lval
+		}
+	case 181:
+		//line a.y:997
+		{
+			yyVAL.lval = yyS[yypt-2].lval ^ yyS[yypt-0].lval
+		}
+	case 182:
+		//line a.y:1001
+		{
+			yyVAL.lval = yyS[yypt-2].lval | yyS[yypt-0].lval
+		}
+	}
+	goto yystack /* stack new state and value */
+}
