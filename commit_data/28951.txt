commit 795ad07b3be3cb51e07d502409f815f7d1f97305
Author: Michael Matloob <matloob@golang.org>
Date:   Thu Jul 28 13:04:41 2016 -0400

    cmd: generate DWARF for functions in compile instead of link.
    
    This is a copy of golang.org/cl/22092 by Ryan Brown.
    
    Here's his original comment:
    On my machine this increases the average time for 'go build cmd/go' from
    2.25s to 2.36s. I tried to measure compile and link separately but saw
    no significant change.
    
    Change-Id: If0d2b756d52a0d30d4eda526929c82794d89dd7b
    Reviewed-on: https://go-review.googlesource.com/25311
    Run-TryBot: Michael Matloob <matloob@golang.org>
    TryBot-Result: Gobot Gobot <gobot@golang.org>
    Reviewed-by: David Crawshaw <crawshaw@golang.org>
---
 src/cmd/dist/buildtool.go                          |    1 +
 src/cmd/internal/dwarf/dwarf.go                    |  609 +++++++++
 .../internal/ld => internal/dwarf}/dwarf_defs.go   |   35 +-
 src/cmd/internal/obj/objfile.go                    |   92 ++
 src/cmd/internal/obj/plist.go                      |    1 +
 src/cmd/link/internal/ld/data.go                   |   10 +-
 src/cmd/link/internal/ld/dwarf.go                  | 1438 ++++++--------------
 src/cmd/link/internal/ld/objfile.go                |   32 +
 src/cmd/link/internal/ld/symtab.go                 |    2 +
 9 files changed, 1195 insertions(+), 1025 deletions(-)

diff --git a/src/cmd/dist/buildtool.go b/src/cmd/dist/buildtool.go
index a535316ca0..6f16fc976f 100644
--- a/src/cmd/dist/buildtool.go
+++ b/src/cmd/dist/buildtool.go
@@ -41,6 +41,7 @@ var bootstrapDirs = []string{
 	"compile/internal/s390x",
 	"internal/bio",
 	"internal/gcprog",
+	"internal/dwarf",
 	"internal/obj",
 	"internal/obj/arm",
 	"internal/obj/arm64",
diff --git a/src/cmd/internal/dwarf/dwarf.go b/src/cmd/internal/dwarf/dwarf.go
new file mode 100644
index 0000000000..58dcf4e55d
--- /dev/null
+++ b/src/cmd/internal/dwarf/dwarf.go
@@ -0,0 +1,609 @@
+// Copyright 2016 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package dwarf generates DWARF debugging information.
+// DWARF generation is split between the compiler and the linker,
+// this package contains the shared code.
+package dwarf
+
+import (
+	"fmt"
+	"strings"
+)
+
+// InfoPrefix is the prefix for all the symbols containing DWARF info entries.
+const InfoPrefix = "go.info."
+
+// Sym represents a symbol.
+type Sym interface {
+}
+
+// A Var represents a local variable or a function parameter.
+type Var struct {
+	Name   string
+	Abbrev int // Either DW_ABRV_AUTO or DW_ABRV_PARAM
+	Offset int32
+	Type   Sym
+	Link   *Var
+}
+
+// A Context specifies how to add data to a Sym.
+type Context interface {
+	PtrSize() int
+	AddInt(s Sym, size int, i int64)
+	AddBytes(s Sym, b []byte)
+	AddAddress(s Sym, t interface{}, ofs int64)
+	AddSectionOffset(s Sym, size int, t interface{}, ofs int64)
+	AddString(s Sym, v string)
+	SymValue(s Sym) int64
+}
+
+// AppendUleb128 appends v to b using DWARF's unsigned LEB128 encoding.
+func AppendUleb128(b []byte, v uint64) []byte {
+	for {
+		c := uint8(v & 0x7f)
+		v >>= 7
+		if v != 0 {
+			c |= 0x80
+		}
+		b = append(b, c)
+		if c&0x80 == 0 {
+			break
+		}
+	}
+	return b
+}
+
+// AppendSleb128 appends v to b using DWARF's signed LEB128 encoding.
+func AppendSleb128(b []byte, v int64) []byte {
+	for {
+		c := uint8(v & 0x7f)
+		s := uint8(v & 0x40)
+		v >>= 7
+		if (v != -1 || s == 0) && (v != 0 || s != 0) {
+			c |= 0x80
+		}
+		b = append(b, c)
+		if c&0x80 == 0 {
+			break
+		}
+	}
+	return b
+}
+
+var encbuf [20]byte
+
+// AppendUleb128 appends v to s using DWARF's unsigned LEB128 encoding.
+func Uleb128put(ctxt Context, s Sym, v int64) {
+	b := AppendUleb128(encbuf[:0], uint64(v))
+	ctxt.AddBytes(s, b)
+}
+
+// AppendUleb128 appends v to s using DWARF's signed LEB128 encoding.
+func Sleb128put(ctxt Context, s Sym, v int64) {
+	b := AppendSleb128(encbuf[:0], v)
+	ctxt.AddBytes(s, b)
+}
+
+/*
+ * Defining Abbrevs.  This is hardcoded, and there will be
+ * only a handful of them.  The DWARF spec places no restriction on
+ * the ordering of attributes in the Abbrevs and DIEs, and we will
+ * always write them out in the order of declaration in the abbrev.
+ */
+type dwAttrForm struct {
+	attr uint16
+	form uint8
+}
+
+// Go-specific type attributes.
+const (
+	DW_AT_go_kind = 0x2900
+	DW_AT_go_key  = 0x2901
+	DW_AT_go_elem = 0x2902
+
+	DW_AT_internal_location = 253 // params and locals; not emitted
+)
+
+// Index into the abbrevs table below.
+// Keep in sync with ispubname() and ispubtype() below.
+// ispubtype considers >= NULLTYPE public
+const (
+	DW_ABRV_NULL = iota
+	DW_ABRV_COMPUNIT
+	DW_ABRV_FUNCTION
+	DW_ABRV_VARIABLE
+	DW_ABRV_AUTO
+	DW_ABRV_PARAM
+	DW_ABRV_STRUCTFIELD
+	DW_ABRV_FUNCTYPEPARAM
+	DW_ABRV_DOTDOTDOT
+	DW_ABRV_ARRAYRANGE
+	DW_ABRV_NULLTYPE
+	DW_ABRV_BASETYPE
+	DW_ABRV_ARRAYTYPE
+	DW_ABRV_CHANTYPE
+	DW_ABRV_FUNCTYPE
+	DW_ABRV_IFACETYPE
+	DW_ABRV_MAPTYPE
+	DW_ABRV_PTRTYPE
+	DW_ABRV_BARE_PTRTYPE // only for void*, no DW_AT_type attr to please gdb 6.
+	DW_ABRV_SLICETYPE
+	DW_ABRV_STRINGTYPE
+	DW_ABRV_STRUCTTYPE
+	DW_ABRV_TYPEDECL
+	DW_NABRV
+)
+
+type dwAbbrev struct {
+	tag      uint8
+	children uint8
+	attr     []dwAttrForm
+}
+
+var abbrevs = [DW_NABRV]dwAbbrev{
+	/* The mandatory DW_ABRV_NULL entry. */
+	{0, 0, []dwAttrForm{}},
+
+	/* COMPUNIT */
+	{
+		DW_TAG_compile_unit,
+		DW_CHILDREN_yes,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+			{DW_AT_language, DW_FORM_data1},
+			{DW_AT_low_pc, DW_FORM_addr},
+			{DW_AT_high_pc, DW_FORM_addr},
+			{DW_AT_stmt_list, DW_FORM_data4},
+			{DW_AT_comp_dir, DW_FORM_string},
+		},
+	},
+
+	/* FUNCTION */
+	{
+		DW_TAG_subprogram,
+		DW_CHILDREN_yes,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+			{DW_AT_low_pc, DW_FORM_addr},
+			{DW_AT_high_pc, DW_FORM_addr},
+			{DW_AT_external, DW_FORM_flag},
+		},
+	},
+
+	/* VARIABLE */
+	{
+		DW_TAG_variable,
+		DW_CHILDREN_no,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+			{DW_AT_location, DW_FORM_block1},
+			{DW_AT_type, DW_FORM_ref_addr},
+			{DW_AT_external, DW_FORM_flag},
+		},
+	},
+
+	/* AUTO */
+	{
+		DW_TAG_variable,
+		DW_CHILDREN_no,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+			{DW_AT_location, DW_FORM_block1},
+			{DW_AT_type, DW_FORM_ref_addr},
+		},
+	},
+
+	/* PARAM */
+	{
+		DW_TAG_formal_parameter,
+		DW_CHILDREN_no,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+			{DW_AT_location, DW_FORM_block1},
+			{DW_AT_type, DW_FORM_ref_addr},
+		},
+	},
+
+	/* STRUCTFIELD */
+	{
+		DW_TAG_member,
+		DW_CHILDREN_no,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+			{DW_AT_data_member_location, DW_FORM_block1},
+			{DW_AT_type, DW_FORM_ref_addr},
+		},
+	},
+
+	/* FUNCTYPEPARAM */
+	{
+		DW_TAG_formal_parameter,
+		DW_CHILDREN_no,
+
+		// No name!
+		[]dwAttrForm{
+			{DW_AT_type, DW_FORM_ref_addr},
+		},
+	},
+
+	/* DOTDOTDOT */
+	{
+		DW_TAG_unspecified_parameters,
+		DW_CHILDREN_no,
+		[]dwAttrForm{},
+	},
+
+	/* ARRAYRANGE */
+	{
+		DW_TAG_subrange_type,
+		DW_CHILDREN_no,
+
+		// No name!
+		[]dwAttrForm{
+			{DW_AT_type, DW_FORM_ref_addr},
+			{DW_AT_count, DW_FORM_udata},
+		},
+	},
+
+	// Below here are the types considered public by ispubtype
+	/* NULLTYPE */
+	{
+		DW_TAG_unspecified_type,
+		DW_CHILDREN_no,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+		},
+	},
+
+	/* BASETYPE */
+	{
+		DW_TAG_base_type,
+		DW_CHILDREN_no,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+			{DW_AT_encoding, DW_FORM_data1},
+			{DW_AT_byte_size, DW_FORM_data1},
+			{DW_AT_go_kind, DW_FORM_data1},
+		},
+	},
+
+	/* ARRAYTYPE */
+	// child is subrange with upper bound
+	{
+		DW_TAG_array_type,
+		DW_CHILDREN_yes,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+			{DW_AT_type, DW_FORM_ref_addr},
+			{DW_AT_byte_size, DW_FORM_udata},
+			{DW_AT_go_kind, DW_FORM_data1},
+		},
+	},
+
+	/* CHANTYPE */
+	{
+		DW_TAG_typedef,
+		DW_CHILDREN_no,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+			{DW_AT_type, DW_FORM_ref_addr},
+			{DW_AT_go_kind, DW_FORM_data1},
+			{DW_AT_go_elem, DW_FORM_ref_addr},
+		},
+	},
+
+	/* FUNCTYPE */
+	{
+		DW_TAG_subroutine_type,
+		DW_CHILDREN_yes,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+			// {DW_AT_type,	DW_FORM_ref_addr},
+			{DW_AT_go_kind, DW_FORM_data1},
+		},
+	},
+
+	/* IFACETYPE */
+	{
+		DW_TAG_typedef,
+		DW_CHILDREN_yes,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+			{DW_AT_type, DW_FORM_ref_addr},
+			{DW_AT_go_kind, DW_FORM_data1},
+		},
+	},
+
+	/* MAPTYPE */
+	{
+		DW_TAG_typedef,
+		DW_CHILDREN_no,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+			{DW_AT_type, DW_FORM_ref_addr},
+			{DW_AT_go_kind, DW_FORM_data1},
+			{DW_AT_go_key, DW_FORM_ref_addr},
+			{DW_AT_go_elem, DW_FORM_ref_addr},
+		},
+	},
+
+	/* PTRTYPE */
+	{
+		DW_TAG_pointer_type,
+		DW_CHILDREN_no,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+			{DW_AT_type, DW_FORM_ref_addr},
+			{DW_AT_go_kind, DW_FORM_data1},
+		},
+	},
+
+	/* BARE_PTRTYPE */
+	{
+		DW_TAG_pointer_type,
+		DW_CHILDREN_no,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+		},
+	},
+
+	/* SLICETYPE */
+	{
+		DW_TAG_structure_type,
+		DW_CHILDREN_yes,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+			{DW_AT_byte_size, DW_FORM_udata},
+			{DW_AT_go_kind, DW_FORM_data1},
+			{DW_AT_go_elem, DW_FORM_ref_addr},
+		},
+	},
+
+	/* STRINGTYPE */
+	{
+		DW_TAG_structure_type,
+		DW_CHILDREN_yes,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+			{DW_AT_byte_size, DW_FORM_udata},
+			{DW_AT_go_kind, DW_FORM_data1},
+		},
+	},
+
+	/* STRUCTTYPE */
+	{
+		DW_TAG_structure_type,
+		DW_CHILDREN_yes,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+			{DW_AT_byte_size, DW_FORM_udata},
+			{DW_AT_go_kind, DW_FORM_data1},
+		},
+	},
+
+	/* TYPEDECL */
+	{
+		DW_TAG_typedef,
+		DW_CHILDREN_no,
+		[]dwAttrForm{
+			{DW_AT_name, DW_FORM_string},
+			{DW_AT_type, DW_FORM_ref_addr},
+		},
+	},
+}
+
+// GetAbbrev returns the contents of the .debug_abbrev section.
+func GetAbbrev() []byte {
+	var buf []byte
+	for i := 1; i < DW_NABRV; i++ {
+		// See section 7.5.3
+		buf = AppendUleb128(buf, uint64(i))
+
+		buf = AppendUleb128(buf, uint64(abbrevs[i].tag))
+		buf = append(buf, byte(abbrevs[i].children))
+		for _, f := range abbrevs[i].attr {
+			buf = AppendUleb128(buf, uint64(f.attr))
+			buf = AppendUleb128(buf, uint64(f.form))
+		}
+		buf = append(buf, 0, 0)
+	}
+	return append(buf, 0)
+}
+
+/*
+ * Debugging Information Entries and their attributes.
+ */
+
+// DWAttr represents an attribute of a DWDie.
+//
+// For DW_CLS_string and _block, value should contain the length, and
+// data the data, for _reference, value is 0 and data is a DWDie* to
+// the referenced instance, for all others, value is the whole thing
+// and data is null.
+type DWAttr struct {
+	Link  *DWAttr
+	Atr   uint16 // DW_AT_
+	Cls   uint8  // DW_CLS_
+	Value int64
+	Data  interface{}
+}
+
+// DWDie represents a DWARF debug info entry.
+type DWDie struct {
+	Abbrev int
+	Link   *DWDie
+	Child  *DWDie
+	Attr   *DWAttr
+	Sym    Sym
+}
+
+func putattr(ctxt Context, s Sym, abbrev int, form int, cls int, value int64, data interface{}) error {
+	switch form {
+	case DW_FORM_addr: // address
+		ctxt.AddAddress(s, data, value)
+
+	case DW_FORM_block1: // block
+		if cls == DW_CLS_ADDRESS {
+			ctxt.AddInt(s, 1, int64(1+ctxt.PtrSize()))
+			ctxt.AddInt(s, 1, DW_OP_addr)
+			ctxt.AddAddress(s, data, 0)
+			break
+		}
+
+		value &= 0xff
+		ctxt.AddInt(s, 1, value)
+		p := data.([]byte)[:value]
+		ctxt.AddBytes(s, p)
+
+	case DW_FORM_block2: // block
+		value &= 0xffff
+
+		ctxt.AddInt(s, 2, value)
+		p := data.([]byte)[:value]
+		ctxt.AddBytes(s, p)
+
+	case DW_FORM_block4: // block
+		value &= 0xffffffff
+
+		ctxt.AddInt(s, 4, value)
+		p := data.([]byte)[:value]
+		ctxt.AddBytes(s, p)
+
+	case DW_FORM_block: // block
+		Uleb128put(ctxt, s, value)
+
+		p := data.([]byte)[:value]
+		ctxt.AddBytes(s, p)
+
+	case DW_FORM_data1: // constant
+		ctxt.AddInt(s, 1, value)
+
+	case DW_FORM_data2: // constant
+		ctxt.AddInt(s, 2, value)
+
+	case DW_FORM_data4: // constant, {line,loclist,mac,rangelist}ptr
+		if cls == DW_CLS_PTR { // DW_AT_stmt_list
+			ctxt.AddSectionOffset(s, 4, data, 0)
+			break
+		}
+		ctxt.AddInt(s, 4, value)
+
+	case DW_FORM_data8: // constant, {line,loclist,mac,rangelist}ptr
+		ctxt.AddInt(s, 8, value)
+
+	case DW_FORM_sdata: // constant
+		Sleb128put(ctxt, s, value)
+
+	case DW_FORM_udata: // constant
+		Uleb128put(ctxt, s, value)
+
+	case DW_FORM_string: // string
+		str := data.(string)
+		ctxt.AddString(s, str)
+		// TODO(ribrdb): verify padded strings are never used and remove this
+		for i := int64(len(str)); i < value; i++ {
+			ctxt.AddInt(s, 1, 0)
+		}
+
+	case DW_FORM_flag: // flag
+		if value != 0 {
+			ctxt.AddInt(s, 1, 1)
+		} else {
+			ctxt.AddInt(s, 1, 0)
+		}
+
+	// In DWARF 2 (which is what we claim to generate),
+	// the ref_addr is the same size as a normal address.
+	// In DWARF 3 it is always 32 bits, unless emitting a large
+	// (> 4 GB of debug info aka "64-bit") unit, which we don't implement.
+	case DW_FORM_ref_addr: // reference to a DIE in the .info section
+		if data == nil {
+			return fmt.Errorf("dwarf: null reference in %d", abbrev)
+		} else {
+			ctxt.AddSectionOffset(s, ctxt.PtrSize(), data, 0)
+		}
+
+	case DW_FORM_ref1, // reference within the compilation unit
+		DW_FORM_ref2,      // reference
+		DW_FORM_ref4,      // reference
+		DW_FORM_ref8,      // reference
+		DW_FORM_ref_udata, // reference
+
+		DW_FORM_strp,     // string
+		DW_FORM_indirect: // (see Section 7.5.3)
+		fallthrough
+	default:
+		return fmt.Errorf("dwarf: unsupported attribute form %d / class %d", form, cls)
+	}
+	return nil
+}
+
+// PutAttrs writes the attributes for a DIE to symbol 's'.
+//
+// Note that we can (and do) add arbitrary attributes to a DIE, but
+// only the ones actually listed in the Abbrev will be written out.
+func PutAttrs(ctxt Context, s Sym, abbrev int, attr *DWAttr) {
+Outer:
+	for _, f := range abbrevs[abbrev].attr {
+		for ap := attr; ap != nil; ap = ap.Link {
+			if ap.Atr == f.attr {
+				putattr(ctxt, s, abbrev, int(f.form), int(ap.Cls), ap.Value, ap.Data)
+				continue Outer
+			}
+		}
+
+		putattr(ctxt, s, abbrev, int(f.form), 0, 0, nil)
+	}
+}
+
+// HasChildren returns true if 'die' uses an abbrev that supports children.
+func HasChildren(die *DWDie) bool {
+	return abbrevs[die.Abbrev].children != 0
+}
+
+// PutFunc writes a DIE for a function to s.
+// It also writes child DIEs for each variable in vars.
+func PutFunc(ctxt Context, s Sym, name string, external bool, startPC Sym, size int64, vars *Var) {
+	Uleb128put(ctxt, s, DW_ABRV_FUNCTION)
+	putattr(ctxt, s, DW_ABRV_FUNCTION, DW_FORM_string, DW_CLS_STRING, int64(len(name)), name)
+	putattr(ctxt, s, DW_ABRV_FUNCTION, DW_FORM_addr, DW_CLS_ADDRESS, 0, startPC)
+	putattr(ctxt, s, DW_ABRV_FUNCTION, DW_FORM_addr, DW_CLS_ADDRESS, size+ctxt.SymValue(startPC), startPC)
+	var ev int64
+	if external {
+		ev = 1
+	}
+	putattr(ctxt, s, DW_ABRV_FUNCTION, DW_FORM_flag, DW_CLS_FLAG, ev, 0)
+	names := make(map[string]bool)
+	for v := vars; v != nil; v = v.Link {
+		if strings.Contains(v.Name, ".autotmp_") {
+			continue
+		}
+		var n string
+		if names[v.Name] {
+			n = fmt.Sprintf("%s#%d", v.Name, len(names))
+		} else {
+			n = v.Name
+		}
+		names[n] = true
+
+		// Drop the package prefix from locals and arguments.
+		if i := strings.LastIndex(n, "."); i >= 0 {
+			n = n[i+1:]
+		}
+
+		Uleb128put(ctxt, s, int64(v.Abbrev))
+		putattr(ctxt, s, v.Abbrev, DW_FORM_string, DW_CLS_STRING, int64(len(n)), n)
+		loc := append(encbuf[:0], DW_OP_call_frame_cfa)
+		if v.Offset != 0 {
+			loc = append(loc, DW_OP_consts)
+			loc = AppendSleb128(loc, int64(v.Offset))
+			loc = append(loc, DW_OP_plus)
+		}
+		putattr(ctxt, s, v.Abbrev, DW_FORM_block1, DW_CLS_BLOCK, int64(len(loc)), loc)
+		putattr(ctxt, s, v.Abbrev, DW_FORM_ref_addr, DW_CLS_REFERENCE, 0, v.Type)
+
+	}
+	Uleb128put(ctxt, s, 0)
+}
diff --git a/src/cmd/link/internal/ld/dwarf_defs.go b/src/cmd/internal/dwarf/dwarf_defs.go
similarity index 93%
rename from src/cmd/link/internal/ld/dwarf_defs.go
rename to src/cmd/internal/dwarf/dwarf_defs.go
index c52879cbbe..d1870b579f 100644
--- a/src/cmd/link/internal/ld/dwarf_defs.go
+++ b/src/cmd/internal/dwarf/dwarf_defs.go
@@ -2,40 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package ld
-
-// TODO/NICETOHAVE:
-//   - eliminate DW_CLS_ if not used
-//   - package info in compilation units
-//   - assign global variables and types to their packages
-//   - gdb uses c syntax, meaning clumsy quoting is needed for go identifiers. eg
-//     ptype struct '[]uint8' and qualifiers need to be quoted away
-//   - lexical scoping is lost, so gdb gets confused as to which 'obj.i' you mean.
-//   - file:line info for variables
-//   - make strings a typedef so prettyprinters can see the underlying string type
-//
-// Copyright 2010 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-/*
- * Emit debug_abbrevs, debug_info and debug_line sections to current
- * offset in cout.
- */
-
-/*
- * Add the dwarf section names to the ELF
- * s[ection]h[eader]str[ing]tab.  Prerequisite for
- * dwarfaddelfheaders().
- */
-
-/*
- * Add section headers pointing to the sections emitted in
- * dwarfemitdebugsections.
- */
-// Copyright 2010 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
+package dwarf
 
 // Cut, pasted, tr-and-awk'ed from tables in
 // http://dwarfstd.org/doc/Dwarf3.pdf
diff --git a/src/cmd/internal/obj/objfile.go b/src/cmd/internal/obj/objfile.go
index a1fdee6070..3c0da30621 100644
--- a/src/cmd/internal/obj/objfile.go
+++ b/src/cmd/internal/obj/objfile.go
@@ -109,6 +109,7 @@ package obj
 
 import (
 	"bufio"
+	"cmd/internal/dwarf"
 	"cmd/internal/sys"
 	"fmt"
 	"log"
@@ -506,3 +507,94 @@ type relocByOff []Reloc
 func (x relocByOff) Len() int           { return len(x) }
 func (x relocByOff) Less(i, j int) bool { return x[i].Off < x[j].Off }
 func (x relocByOff) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
+
+// implement dwarf.Context
+type dwCtxt struct{ *Link }
+
+func (c dwCtxt) PtrSize() int {
+	return c.Arch.PtrSize
+}
+func (c dwCtxt) AddInt(s dwarf.Sym, size int, i int64) {
+	ls := s.(*LSym)
+	ls.WriteInt(c.Link, ls.Size, size, i)
+}
+func (c dwCtxt) AddBytes(s dwarf.Sym, b []byte) {
+	ls := s.(*LSym)
+	ls.WriteBytes(c.Link, ls.Size, b)
+}
+func (c dwCtxt) AddString(s dwarf.Sym, v string) {
+	ls := s.(*LSym)
+	ls.WriteString(c.Link, ls.Size, len(v), v)
+	ls.WriteInt(c.Link, ls.Size, 1, 0)
+}
+func (c dwCtxt) SymValue(s dwarf.Sym) int64 {
+	return 0
+}
+func (c dwCtxt) AddAddress(s dwarf.Sym, data interface{}, value int64) {
+	rsym := data.(*LSym)
+	ls := s.(*LSym)
+	size := c.PtrSize()
+	ls.WriteAddr(c.Link, ls.Size, size, rsym, value)
+}
+func (c dwCtxt) AddSectionOffset(s dwarf.Sym, size int, t interface{}, ofs int64) {
+	ls := s.(*LSym)
+	rsym := t.(*LSym)
+	ls.WriteAddr(c.Link, ls.Size, size, rsym, ofs)
+	r := &ls.R[len(ls.R)-1]
+	r.Type = R_DWARFREF
+}
+
+func gendwarf(ctxt *Link, text []*LSym) []*LSym {
+	dctxt := dwCtxt{ctxt}
+	var dw []*LSym
+
+	for _, s := range text {
+		dsym := Linklookup(ctxt, dwarf.InfoPrefix+s.Name, int(s.Version))
+		if dsym.Size != 0 {
+			continue
+		}
+		dw = append(dw, dsym)
+		dsym.Type = SDWARFINFO
+		dsym.Dupok = s.Dupok
+		var vars dwarf.Var
+		var abbrev int
+		var offs int32
+		for a := s.Autom; a != nil; a = a.Link {
+			switch a.Name {
+			case NAME_AUTO:
+				abbrev = dwarf.DW_ABRV_AUTO
+				offs = a.Aoffset
+				if ctxt.FixedFrameSize() == 0 {
+					offs -= int32(ctxt.Arch.PtrSize)
+				}
+				if Framepointer_enabled(Getgoos(), Getgoarch()) {
+					offs -= int32(ctxt.Arch.PtrSize)
+				}
+
+			case NAME_PARAM:
+				abbrev = dwarf.DW_ABRV_PARAM
+				offs = a.Aoffset + int32(ctxt.FixedFrameSize())
+
+			default:
+				continue
+			}
+			typename := dwarf.InfoPrefix + a.Gotype.Name[len("type."):]
+			dwvar := &dwarf.Var{
+				Name:   a.Asym.Name,
+				Abbrev: abbrev,
+				Offset: int32(offs),
+				Type:   Linklookup(ctxt, typename, 0),
+			}
+			dws := &vars.Link
+			for ; *dws != nil; dws = &(*dws).Link {
+				if offs <= (*dws).Offset {
+					break
+				}
+			}
+			dwvar.Link = *dws
+			*dws = dwvar
+		}
+		dwarf.PutFunc(dctxt, dsym, s.Name, s.Version == 0, s, s.Size, vars.Link)
+	}
+	return dw
+}
diff --git a/src/cmd/internal/obj/plist.go b/src/cmd/internal/obj/plist.go
index e55dbeca1e..3c046d1621 100644
--- a/src/cmd/internal/obj/plist.go
+++ b/src/cmd/internal/obj/plist.go
@@ -209,6 +209,7 @@ func flushplist(ctxt *Link, freeProgs bool) {
 
 	// Add to running list in ctxt.
 	ctxt.Text = append(ctxt.Text, text...)
+	ctxt.Data = append(ctxt.Data, gendwarf(ctxt, text)...)
 	ctxt.Plist = nil
 	ctxt.Plast = nil
 	ctxt.Curp = nil
diff --git a/src/cmd/link/internal/ld/data.go b/src/cmd/link/internal/ld/data.go
index 57a0dad491..4d0c9c3d10 100644
--- a/src/cmd/link/internal/ld/data.go
+++ b/src/cmd/link/internal/ld/data.go
@@ -342,8 +342,14 @@ func relocsym(s *LSym) {
 		if r.Sym != nil && (r.Sym.Type&(obj.SMASK|obj.SHIDDEN) == 0 || r.Sym.Type&obj.SMASK == obj.SXREF) {
 			// When putting the runtime but not main into a shared library
 			// these symbols are undefined and that's OK.
-			if Buildmode == BuildmodeShared && (r.Sym.Name == "main.main" || r.Sym.Name == "main.init") {
-				r.Sym.Type = obj.SDYNIMPORT
+			if Buildmode == BuildmodeShared {
+				if r.Sym.Name == "main.main" || r.Sym.Name == "main.init" {
+					r.Sym.Type = obj.SDYNIMPORT
+				} else if strings.HasPrefix(r.Sym.Name, "go.info.") {
+					// Skip go.info symbols. They are only needed to communicate
+					// DWARF info between the compiler and linker.
+					continue
+				}
 			} else {
 				Diag("%s: not defined", r.Sym.Name)
 				continue
diff --git a/src/cmd/link/internal/ld/dwarf.go b/src/cmd/link/internal/ld/dwarf.go
index fa7105f620..9e55db4933 100644
--- a/src/cmd/link/internal/ld/dwarf.go
+++ b/src/cmd/link/internal/ld/dwarf.go
@@ -15,6 +15,7 @@
 package ld
 
 import (
+	"cmd/internal/dwarf"
 	"cmd/internal/obj"
 	"fmt"
 	"log"
@@ -22,505 +23,146 @@ import (
 	"strings"
 )
 
-const infoprefix = "go.dwarf.info."
+type dwCtxt struct{}
 
-/*
- * Offsets and sizes of the debug_* sections in the cout file.
- */
-var abbrevsym *LSym
-var arangessec *LSym
-var framesec *LSym
-var infosec *LSym
-var linesec *LSym
-
-var gdbscript string
-
-/*
- *  Basic I/O
- */
-func addrput(s *LSym, addr int64) {
-	switch SysArch.PtrSize {
-	case 4:
-		Adduint32(Ctxt, s, uint32(addr))
-
-	case 8:
-		Adduint64(Ctxt, s, uint64(addr))
-	}
+func (c dwCtxt) PtrSize() int {
+	return SysArch.PtrSize
 }
-
-func appendUleb128(b []byte, v uint64) []byte {
-	for {
-		c := uint8(v & 0x7f)
-		v >>= 7
-		if v != 0 {
-			c |= 0x80
-		}
-		b = append(b, c)
-		if c&0x80 == 0 {
-			break
-		}
-	}
-	return b
+func (c dwCtxt) AddInt(s dwarf.Sym, size int, i int64) {
+	ls := s.(*LSym)
+	adduintxx(Ctxt, ls, uint64(i), size)
 }
-
-func appendSleb128(b []byte, v int64) []byte {
-	for {
-		c := uint8(v & 0x7f)
-		s := uint8(v & 0x40)
-		v >>= 7
-		if (v != -1 || s == 0) && (v != 0 || s != 0) {
-			c |= 0x80
-		}
-		b = append(b, c)
-		if c&0x80 == 0 {
-			break
-		}
-	}
-	return b
+func (c dwCtxt) AddBytes(s dwarf.Sym, b []byte) {
+	ls := s.(*LSym)
+	Addbytes(Ctxt, ls, b)
+}
+func (c dwCtxt) AddString(s dwarf.Sym, v string) {
+	Addstring(s.(*LSym), v)
+}
+func (c dwCtxt) SymValue(s dwarf.Sym) int64 {
+	return s.(*LSym).Value
 }
 
-var encbuf [10]byte
-
-func uleb128put(s *LSym, v int64) {
-	b := appendUleb128(encbuf[:0], uint64(v))
-	Addbytes(Ctxt, s, b)
+func (c dwCtxt) AddAddress(s dwarf.Sym, data interface{}, value int64) {
+	if value != 0 {
+		value -= (data.(*LSym)).Value
+	}
+	Addaddrplus(Ctxt, s.(*LSym), data.(*LSym), value)
 }
 
-func sleb128put(s *LSym, v int64) {
-	b := appendSleb128(encbuf[:0], v)
-	Addbytes(Ctxt, s, b)
+func (c dwCtxt) AddSectionOffset(s dwarf.Sym, size int, t interface{}, ofs int64) {
+	ls := s.(*LSym)
+	switch size {
+	default:
+		Diag("invalid size %d in adddwarfref\n", size)
+		fallthrough
+	case SysArch.PtrSize:
+		Addaddr(Ctxt, ls, t.(*LSym))
+	case 4:
+		addaddrplus4(Ctxt, ls, t.(*LSym), 0)
+	}
+	r := &ls.R[len(ls.R)-1]
+	r.Type = obj.R_DWARFREF
+	r.Add = ofs
 }
 
 /*
- * Defining Abbrevs.  This is hardcoded, and there will be
- * only a handful of them.  The DWARF spec places no restriction on
- * the ordering of attributes in the Abbrevs and DIEs, and we will
- * always write them out in the order of declaration in the abbrev.
+ * Offsets and sizes of the debug_* sections in the cout file.
  */
-type DWAttrForm struct {
-	attr uint16
-	form uint8
-}
-
-// Go-specific type attributes.
-const (
-	DW_AT_go_kind = 0x2900
-	DW_AT_go_key  = 0x2901
-	DW_AT_go_elem = 0x2902
-
-	DW_AT_internal_location = 253 // params and locals; not emitted
-)
-
-// Index into the abbrevs table below.
-// Keep in sync with ispubname() and ispubtype() below.
-// ispubtype considers >= NULLTYPE public
-const (
-	DW_ABRV_NULL = iota
-	DW_ABRV_COMPUNIT
-	DW_ABRV_FUNCTION
-	DW_ABRV_VARIABLE
-	DW_ABRV_AUTO
-	DW_ABRV_PARAM
-	DW_ABRV_STRUCTFIELD
-	DW_ABRV_FUNCTYPEPARAM
-	DW_ABRV_DOTDOTDOT
-	DW_ABRV_ARRAYRANGE
-	DW_ABRV_NULLTYPE
-	DW_ABRV_BASETYPE
-	DW_ABRV_ARRAYTYPE
-	DW_ABRV_CHANTYPE
-	DW_ABRV_FUNCTYPE
-	DW_ABRV_IFACETYPE
-	DW_ABRV_MAPTYPE
-	DW_ABRV_PTRTYPE
-	DW_ABRV_BARE_PTRTYPE // only for void*, no DW_AT_type attr to please gdb 6.
-	DW_ABRV_SLICETYPE
-	DW_ABRV_STRINGTYPE
-	DW_ABRV_STRUCTTYPE
-	DW_ABRV_TYPEDECL
-	DW_NABRV
-)
-
-type DWAbbrev struct {
-	tag      uint8
-	children uint8
-	attr     []DWAttrForm
-}
+var abbrevsym *LSym
+var arangessec *LSym
+var framesec *LSym
+var infosec *LSym
+var linesec *LSym
 
-var abbrevs = [DW_NABRV]DWAbbrev{
-	/* The mandatory DW_ABRV_NULL entry. */
-	{0, 0, []DWAttrForm{}},
-
-	/* COMPUNIT */
-	{
-		DW_TAG_compile_unit,
-		DW_CHILDREN_yes,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-			{DW_AT_language, DW_FORM_data1},
-			{DW_AT_low_pc, DW_FORM_addr},
-			{DW_AT_high_pc, DW_FORM_addr},
-			{DW_AT_stmt_list, DW_FORM_data4},
-			{DW_AT_comp_dir, DW_FORM_string},
-		},
-	},
-
-	/* FUNCTION */
-	{
-		DW_TAG_subprogram,
-		DW_CHILDREN_yes,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-			{DW_AT_low_pc, DW_FORM_addr},
-			{DW_AT_high_pc, DW_FORM_addr},
-			{DW_AT_external, DW_FORM_flag},
-		},
-	},
-
-	/* VARIABLE */
-	{
-		DW_TAG_variable,
-		DW_CHILDREN_no,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-			{DW_AT_location, DW_FORM_block1},
-			{DW_AT_type, DW_FORM_ref_addr},
-			{DW_AT_external, DW_FORM_flag},
-		},
-	},
-
-	/* AUTO */
-	{
-		DW_TAG_variable,
-		DW_CHILDREN_no,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-			{DW_AT_location, DW_FORM_block1},
-			{DW_AT_type, DW_FORM_ref_addr},
-		},
-	},
-
-	/* PARAM */
-	{
-		DW_TAG_formal_parameter,
-		DW_CHILDREN_no,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-			{DW_AT_location, DW_FORM_block1},
-			{DW_AT_type, DW_FORM_ref_addr},
-		},
-	},
-
-	/* STRUCTFIELD */
-	{
-		DW_TAG_member,
-		DW_CHILDREN_no,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-			{DW_AT_data_member_location, DW_FORM_block1},
-			{DW_AT_type, DW_FORM_ref_addr},
-		},
-	},
-
-	/* FUNCTYPEPARAM */
-	{
-		DW_TAG_formal_parameter,
-		DW_CHILDREN_no,
-
-		// No name!
-		[]DWAttrForm{
-			{DW_AT_type, DW_FORM_ref_addr},
-		},
-	},
-
-	/* DOTDOTDOT */
-	{
-		DW_TAG_unspecified_parameters,
-		DW_CHILDREN_no,
-		[]DWAttrForm{},
-	},
-
-	/* ARRAYRANGE */
-	{
-		DW_TAG_subrange_type,
-		DW_CHILDREN_no,
-
-		// No name!
-		[]DWAttrForm{
-			{DW_AT_type, DW_FORM_ref_addr},
-			{DW_AT_count, DW_FORM_udata},
-		},
-	},
-
-	// Below here are the types considered public by ispubtype
-	/* NULLTYPE */
-	{
-		DW_TAG_unspecified_type,
-		DW_CHILDREN_no,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-		},
-	},
-
-	/* BASETYPE */
-	{
-		DW_TAG_base_type,
-		DW_CHILDREN_no,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-			{DW_AT_encoding, DW_FORM_data1},
-			{DW_AT_byte_size, DW_FORM_data1},
-			{DW_AT_go_kind, DW_FORM_data1},
-		},
-	},
-
-	/* ARRAYTYPE */
-	// child is subrange with upper bound
-	{
-		DW_TAG_array_type,
-		DW_CHILDREN_yes,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-			{DW_AT_type, DW_FORM_ref_addr},
-			{DW_AT_byte_size, DW_FORM_udata},
-			{DW_AT_go_kind, DW_FORM_data1},
-		},
-	},
-
-	/* CHANTYPE */
-	{
-		DW_TAG_typedef,
-		DW_CHILDREN_no,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-			{DW_AT_type, DW_FORM_ref_addr},
-			{DW_AT_go_kind, DW_FORM_data1},
-			{DW_AT_go_elem, DW_FORM_ref_addr},
-		},
-	},
-
-	/* FUNCTYPE */
-	{
-		DW_TAG_subroutine_type,
-		DW_CHILDREN_yes,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-			// {DW_AT_type,	DW_FORM_ref_addr},
-			{DW_AT_go_kind, DW_FORM_data1},
-		},
-	},
-
-	/* IFACETYPE */
-	{
-		DW_TAG_typedef,
-		DW_CHILDREN_yes,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-			{DW_AT_type, DW_FORM_ref_addr},
-			{DW_AT_go_kind, DW_FORM_data1},
-		},
-	},
-
-	/* MAPTYPE */
-	{
-		DW_TAG_typedef,
-		DW_CHILDREN_no,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-			{DW_AT_type, DW_FORM_ref_addr},
-			{DW_AT_go_kind, DW_FORM_data1},
-			{DW_AT_go_key, DW_FORM_ref_addr},
-			{DW_AT_go_elem, DW_FORM_ref_addr},
-		},
-	},
-
-	/* PTRTYPE */
-	{
-		DW_TAG_pointer_type,
-		DW_CHILDREN_no,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-			{DW_AT_type, DW_FORM_ref_addr},
-			{DW_AT_go_kind, DW_FORM_data1},
-		},
-	},
-
-	/* BARE_PTRTYPE */
-	{
-		DW_TAG_pointer_type,
-		DW_CHILDREN_no,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-		},
-	},
-
-	/* SLICETYPE */
-	{
-		DW_TAG_structure_type,
-		DW_CHILDREN_yes,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-			{DW_AT_byte_size, DW_FORM_udata},
-			{DW_AT_go_kind, DW_FORM_data1},
-			{DW_AT_go_elem, DW_FORM_ref_addr},
-		},
-	},
-
-	/* STRINGTYPE */
-	{
-		DW_TAG_structure_type,
-		DW_CHILDREN_yes,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-			{DW_AT_byte_size, DW_FORM_udata},
-			{DW_AT_go_kind, DW_FORM_data1},
-		},
-	},
-
-	/* STRUCTTYPE */
-	{
-		DW_TAG_structure_type,
-		DW_CHILDREN_yes,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-			{DW_AT_byte_size, DW_FORM_udata},
-			{DW_AT_go_kind, DW_FORM_data1},
-		},
-	},
-
-	/* TYPEDECL */
-	{
-		DW_TAG_typedef,
-		DW_CHILDREN_no,
-		[]DWAttrForm{
-			{DW_AT_name, DW_FORM_string},
-			{DW_AT_type, DW_FORM_ref_addr},
-		},
-	},
-}
+var gdbscript string
 
 var dwarfp *LSym
 
-func writeabbrev() *LSym {
+func writeabbrev(syms []*LSym) []*LSym {
 	s := Linklookup(Ctxt, ".debug_abbrev", 0)
 	s.Type = obj.SDWARFSECT
 	abbrevsym = s
-
-	for i := 1; i < DW_NABRV; i++ {
-		// See section 7.5.3
-		uleb128put(s, int64(i))
-
-		uleb128put(s, int64(abbrevs[i].tag))
-		Adduint8(Ctxt, s, abbrevs[i].children)
-		for _, f := range abbrevs[i].attr {
-			uleb128put(s, int64(f.attr))
-			uleb128put(s, int64(f.form))
-		}
-		uleb128put(s, 0)
-		uleb128put(s, 0)
-	}
-
-	Adduint8(Ctxt, s, 0)
-	return s
-}
-
-/*
- * Debugging Information Entries and their attributes.
- */
-
-// For DW_CLS_string and _block, value should contain the length, and
-// data the data, for _reference, value is 0 and data is a DWDie* to
-// the referenced instance, for all others, value is the whole thing
-// and data is null.
-
-type DWAttr struct {
-	link  *DWAttr
-	atr   uint16 // DW_AT_
-	cls   uint8  // DW_CLS_
-	value int64
-	data  interface{}
-}
-
-type DWDie struct {
-	abbrev int
-	link   *DWDie
-	child  *DWDie
-	attr   *DWAttr
-	sym    *LSym
+	Addbytes(Ctxt, s, dwarf.GetAbbrev())
+	return append(syms, s)
 }
 
 /*
  * Root DIEs for compilation units, types and global variables.
  */
-var dwroot DWDie
+var dwroot dwarf.DWDie
 
-var dwtypes DWDie
+var dwtypes dwarf.DWDie
 
-var dwglobals DWDie
+var dwglobals dwarf.DWDie
 
-func newattr(die *DWDie, attr uint16, cls int, value int64, data interface{}) *DWAttr {
-	a := new(DWAttr)
-	a.link = die.attr
-	die.attr = a
-	a.atr = attr
-	a.cls = uint8(cls)
-	a.value = value
-	a.data = data
+func newattr(die *dwarf.DWDie, attr uint16, cls int, value int64, data interface{}) *dwarf.DWAttr {
+	a := new(dwarf.DWAttr)
+	a.Link = die.Attr
+	die.Attr = a
+	a.Atr = attr
+	a.Cls = uint8(cls)
+	a.Value = value
+	a.Data = data
 	return a
 }
 
 // Each DIE (except the root ones) has at least 1 attribute: its
 // name. getattr moves the desired one to the front so
 // frequently searched ones are found faster.
-func getattr(die *DWDie, attr uint16) *DWAttr {
-	if die.attr.atr == attr {
-		return die.attr
+func getattr(die *dwarf.DWDie, attr uint16) *dwarf.DWAttr {
+	if die.Attr.Atr == attr {
+		return die.Attr
 	}
 
-	a := die.attr
-	b := a.link
+	a := die.Attr
+	b := a.Link
 	for b != nil {
-		if b.atr == attr {
-			a.link = b.link
-			b.link = die.attr
-			die.attr = b
+		if b.Atr == attr {
+			a.Link = b.Link
+			b.Link = die.Attr
+			die.Attr = b
 			return b
 		}
 
 		a = b
-		b = b.link
+		b = b.Link
 	}
 
 	return nil
 }
 
-// Every DIE has at least a DW_AT_name attribute (but it will only be
+// Every DIE has at least a AT_name attribute (but it will only be
 // written out if it is listed in the abbrev).
-func newdie(parent *DWDie, abbrev int, name string, version int) *DWDie {
-	die := new(DWDie)
-	die.abbrev = abbrev
-	die.link = parent.child
-	parent.child = die
-
-	newattr(die, DW_AT_name, DW_CLS_STRING, int64(len(name)), name)
-
-	if name != "" && (abbrev <= DW_ABRV_VARIABLE || abbrev >= DW_ABRV_NULLTYPE) {
-		if abbrev != DW_ABRV_VARIABLE || version == 0 {
-			die.sym = Linklookup(Ctxt, infoprefix+name, version)
-			die.sym.Attr |= AttrHidden
-			die.sym.Type = obj.SDWARFINFO
+func newdie(parent *dwarf.DWDie, abbrev int, name string, version int) *dwarf.DWDie {
+	die := new(dwarf.DWDie)
+	die.Abbrev = abbrev
+	die.Link = parent.Child
+	parent.Child = die
+
+	newattr(die, dwarf.DW_AT_name, dwarf.DW_CLS_STRING, int64(len(name)), name)
+
+	if name != "" && (abbrev <= dwarf.DW_ABRV_VARIABLE || abbrev >= dwarf.DW_ABRV_NULLTYPE) {
+		if abbrev != dwarf.DW_ABRV_VARIABLE || version == 0 {
+			sym := Linklookup(Ctxt, dwarf.InfoPrefix+name, version)
+			sym.Attr |= AttrHidden
+			sym.Type = obj.SDWARFINFO
+			die.Sym = sym
 		}
 	}
 
 	return die
 }
 
-func walktypedef(die *DWDie) *DWDie {
+func walktypedef(die *dwarf.DWDie) *dwarf.DWDie {
+	if die == nil {
+		return nil
+	}
 	// Resolve typedef if present.
-	if die.abbrev == DW_ABRV_TYPEDECL {
-		for attr := die.attr; attr != nil; attr = attr.link {
-			if attr.atr == DW_AT_type && attr.cls == DW_CLS_REFERENCE && attr.data != nil {
-				return attr.data.(*DWDie)
+	if die.Abbrev == dwarf.DW_ABRV_TYPEDECL {
+		for attr := die.Attr; attr != nil; attr = attr.Link {
+			if attr.Atr == dwarf.DW_AT_type && attr.Cls == dwarf.DW_CLS_REFERENCE && attr.Data != nil {
+				return attr.Data.(*dwarf.DWDie)
 			}
 		}
 	}
@@ -537,11 +179,11 @@ func walksymtypedef(s *LSym) *LSym {
 
 // Find child by AT_name using hashtable if available or linear scan
 // if not.
-func findchild(die *DWDie, name string) *DWDie {
-	var prev *DWDie
+func findchild(die *dwarf.DWDie, name string) *dwarf.DWDie {
+	var prev *dwarf.DWDie
 	for ; die != prev; prev, die = die, walktypedef(die) {
-		for a := die.child; a != nil; a = a.link {
-			if name == getattr(a, DW_AT_name).data {
+		for a := die.Child; a != nil; a = a.Link {
+			if name == getattr(a, dwarf.DW_AT_name).Data {
 				return a
 			}
 		}
@@ -551,14 +193,17 @@ func findchild(die *DWDie, name string) *DWDie {
 }
 
 // Used to avoid string allocation when looking up dwarf symbols
-var prefixBuf = []byte(infoprefix)
+var prefixBuf = []byte(dwarf.InfoPrefix)
 
 func find(name string) *LSym {
 	n := append(prefixBuf, name...)
 	// The string allocation below is optimized away because it is only used in a map lookup.
 	s := Linkrlookup(Ctxt, string(n), 0)
-	prefixBuf = n[:len(infoprefix)]
-	return s
+	prefixBuf = n[:len(dwarf.InfoPrefix)]
+	if s != nil && s.Type == obj.SDWARFINFO {
+		return s
+	}
+	return nil
 }
 
 func mustFind(name string) *LSym {
@@ -585,182 +230,54 @@ func adddwarfref(ctxt *Link, s *LSym, t *LSym, size int) int64 {
 	return result
 }
 
-func newrefattr(die *DWDie, attr uint16, ref *LSym) *DWAttr {
+func newrefattr(die *dwarf.DWDie, attr uint16, ref *LSym) *dwarf.DWAttr {
 	if ref == nil {
 		return nil
 	}
-	return newattr(die, attr, DW_CLS_REFERENCE, 0, ref)
+	return newattr(die, attr, dwarf.DW_CLS_REFERENCE, 0, ref)
 }
 
-func putattr(s *LSym, abbrev int, form int, cls int, value int64, data interface{}) {
-	switch form {
-	case DW_FORM_addr: // address
-		if Linkmode == LinkExternal {
-			value -= (data.(*LSym)).Value
-			Addaddrplus(Ctxt, s, data.(*LSym), value)
-			break
-		}
-
-		addrput(s, value)
-
-	case DW_FORM_block1: // block
-		if cls == DW_CLS_ADDRESS {
-			Adduint8(Ctxt, s, uint8(1+SysArch.PtrSize))
-			Adduint8(Ctxt, s, DW_OP_addr)
-			Addaddr(Ctxt, s, data.(*LSym))
-			break
-		}
-
-		value &= 0xff
-		Adduint8(Ctxt, s, uint8(value))
-		p := data.([]byte)
-		for i := 0; int64(i) < value; i++ {
-			Adduint8(Ctxt, s, p[i])
-		}
-
-	case DW_FORM_block2: // block
-		value &= 0xffff
-
-		Adduint16(Ctxt, s, uint16(value))
-		p := data.([]byte)
-		for i := 0; int64(i) < value; i++ {
-			Adduint8(Ctxt, s, p[i])
-		}
-
-	case DW_FORM_block4: // block
-		value &= 0xffffffff
-
-		Adduint32(Ctxt, s, uint32(value))
-		p := data.([]byte)
-		for i := 0; int64(i) < value; i++ {
-			Adduint8(Ctxt, s, p[i])
-		}
-
-	case DW_FORM_block: // block
-		uleb128put(s, value)
-
-		p := data.([]byte)
-		for i := 0; int64(i) < value; i++ {
-			Adduint8(Ctxt, s, p[i])
-		}
-
-	case DW_FORM_data1: // constant
-		Adduint8(Ctxt, s, uint8(value))
-
-	case DW_FORM_data2: // constant
-		Adduint16(Ctxt, s, uint16(value))
-
-	case DW_FORM_data4: // constant, {line,loclist,mac,rangelist}ptr
-		if Linkmode == LinkExternal && cls == DW_CLS_PTR {
-			adddwarfref(Ctxt, s, linesec, 4)
-			break
-		}
-
-		Adduint32(Ctxt, s, uint32(value))
-
-	case DW_FORM_data8: // constant, {line,loclist,mac,rangelist}ptr
-		Adduint64(Ctxt, s, uint64(value))
-
-	case DW_FORM_sdata: // constant
-		sleb128put(s, value)
-
-	case DW_FORM_udata: // constant
-		uleb128put(s, value)
-
-	case DW_FORM_string: // string
-		str := data.(string)
-		Addstring(s, str)
-		for i := int64(len(str)); i < value; i++ {
-			Adduint8(Ctxt, s, 0)
-		}
-
-	case DW_FORM_flag: // flag
-		if value != 0 {
-			Adduint8(Ctxt, s, 1)
-		} else {
-			Adduint8(Ctxt, s, 0)
-		}
-
-		// In DWARF 2 (which is what we claim to generate),
-	// the ref_addr is the same size as a normal address.
-	// In DWARF 3 it is always 32 bits, unless emitting a large
-	// (> 4 GB of debug info aka "64-bit") unit, which we don't implement.
-	case DW_FORM_ref_addr: // reference to a DIE in the .info section
-		if data == nil {
-			Diag("dwarf: null reference in %d", abbrev)
-			if SysArch.PtrSize == 8 {
-				Adduint64(Ctxt, s, 0) // invalid dwarf, gdb will complain.
-			} else {
-				Adduint32(Ctxt, s, 0) // invalid dwarf, gdb will complain.
-			}
-		} else {
-			dsym := data.(*LSym)
-			adddwarfref(Ctxt, s, dsym, SysArch.PtrSize)
-		}
-
-	case DW_FORM_ref1, // reference within the compilation unit
-		DW_FORM_ref2,      // reference
-		DW_FORM_ref4,      // reference
-		DW_FORM_ref8,      // reference
-		DW_FORM_ref_udata, // reference
-
-		DW_FORM_strp,     // string
-		DW_FORM_indirect: // (see Section 7.5.3)
-		fallthrough
-	default:
-		Exitf("dwarf: unsupported attribute form %d / class %d", form, cls)
+func putdies(ctxt dwarf.Context, syms []*LSym, die *dwarf.DWDie) []*LSym {
+	for ; die != nil; die = die.Link {
+		syms = putdie(ctxt, syms, die)
 	}
-}
-
-// Note that we can (and do) add arbitrary attributes to a DIE, but
-// only the ones actually listed in the Abbrev will be written out.
-func putattrs(s *LSym, abbrev int, attr *DWAttr) {
-Outer:
-	for _, f := range abbrevs[abbrev].attr {
-		for ap := attr; ap != nil; ap = ap.link {
-			if ap.atr == f.attr {
-				putattr(s, abbrev, int(f.form), int(ap.cls), ap.value, ap.data)
-				continue Outer
-			}
-		}
+	Adduint8(Ctxt, syms[len(syms)-1], 0)
 
-		putattr(s, abbrev, int(f.form), 0, 0, nil)
-	}
+	return syms
 }
 
-func putdies(prev *LSym, die *DWDie) *LSym {
-	for ; die != nil; die = die.link {
-		prev = putdie(prev, die)
+func dtolsym(s dwarf.Sym) *LSym {
+	if s == nil {
+		return nil
 	}
-	Adduint8(Ctxt, prev, 0)
-	return prev
+	return s.(*LSym)
 }
 
-func putdie(prev *LSym, die *DWDie) *LSym {
-	s := die.sym
+func putdie(ctxt dwarf.Context, syms []*LSym, die *dwarf.DWDie) []*LSym {
+	s := dtolsym(die.Sym)
 	if s == nil {
-		s = prev
+		s = syms[len(syms)-1]
 	} else {
 		if s.Attr.OnList() {
 			log.Fatalf("symbol %s listed multiple times", s.Name)
 		}
 		s.Attr |= AttrOnList
-		prev.Next = s
+		syms = append(syms, s)
 	}
-	uleb128put(s, int64(die.abbrev))
-	putattrs(s, die.abbrev, die.attr)
-	if abbrevs[die.abbrev].children != 0 {
-		return putdies(s, die.child)
+	dwarf.Uleb128put(ctxt, s, int64(die.Abbrev))
+	dwarf.PutAttrs(ctxt, s, die.Abbrev, die.Attr)
+	if dwarf.HasChildren(die) {
+		return putdies(ctxt, syms, die.Child)
 	}
-	return s
+	return syms
 }
 
-func reverselist(list **DWDie) {
+func reverselist(list **dwarf.DWDie) {
 	curr := *list
-	var prev *DWDie
+	var prev *dwarf.DWDie
 	for curr != nil {
-		var next *DWDie = curr.link
-		curr.link = prev
+		var next *dwarf.DWDie = curr.Link
+		curr.Link = prev
 		prev = curr
 		curr = next
 	}
@@ -768,26 +285,26 @@ func reverselist(list **DWDie) {
 	*list = prev
 }
 
-func reversetree(list **DWDie) {
+func reversetree(list **dwarf.DWDie) {
 	reverselist(list)
-	for die := *list; die != nil; die = die.link {
-		if abbrevs[die.abbrev].children != 0 {
-			reversetree(&die.child)
+	for die := *list; die != nil; die = die.Link {
+		if dwarf.HasChildren(die) {
+			reversetree(&die.Child)
 		}
 	}
 }
 
-func newmemberoffsetattr(die *DWDie, offs int32) {
+func newmemberoffsetattr(die *dwarf.DWDie, offs int32) {
 	var block [20]byte
-	b := append(block[:0], DW_OP_plus_uconst)
-	b = appendUleb128(b, uint64(offs))
-	newattr(die, DW_AT_data_member_location, DW_CLS_BLOCK, int64(len(b)), b)
+	b := append(block[:0], dwarf.DW_OP_plus_uconst)
+	b = dwarf.AppendUleb128(b, uint64(offs))
+	newattr(die, dwarf.DW_AT_data_member_location, dwarf.DW_CLS_BLOCK, int64(len(b)), b)
 }
 
-// GDB doesn't like DW_FORM_addr for DW_AT_location, so emit a
+// GDB doesn't like FORM_addr for AT_location, so emit a
 // location expression that evals to a const.
-func newabslocexprattr(die *DWDie, addr int64, sym *LSym) {
-	newattr(die, DW_AT_location, DW_CLS_ADDRESS, addr, sym)
+func newabslocexprattr(die *dwarf.DWDie, addr int64, sym *LSym) {
+	newattr(die, dwarf.DW_AT_location, dwarf.DW_CLS_ADDRESS, addr, sym)
 	// below
 }
 
@@ -801,7 +318,7 @@ func lookup_or_diag(n string) *LSym {
 	return s
 }
 
-func dotypedef(parent *DWDie, name string, def *DWDie) {
+func dotypedef(parent *dwarf.DWDie, name string, def *dwarf.DWDie) {
 	// Only emit typedefs for real names.
 	if strings.HasPrefix(name, "map[") {
 		return
@@ -819,17 +336,18 @@ func dotypedef(parent *DWDie, name string, def *DWDie) {
 		Diag("dwarf: bad def in dotypedef")
 	}
 
-	def.sym = Linklookup(Ctxt, def.sym.Name+"..def", 0)
-	def.sym.Attr |= AttrHidden
-	def.sym.Type = obj.SDWARFINFO
+	sym := Linklookup(Ctxt, dtolsym(def.Sym).Name+"..def", 0)
+	sym.Attr |= AttrHidden
+	sym.Type = obj.SDWARFINFO
+	def.Sym = sym
 
 	// The typedef entry must be created after the def,
 	// so that future lookups will find the typedef instead
 	// of the real definition. This hooks the typedef into any
 	// circular definition loops, so that gdb can understand them.
-	die := newdie(parent, DW_ABRV_TYPEDECL, name, 0)
+	die := newdie(parent, dwarf.DW_ABRV_TYPEDECL, name, 0)
 
-	newrefattr(die, DW_AT_type, def.sym)
+	newrefattr(die, dwarf.DW_AT_type, sym)
 }
 
 // Define gotype, for composite ones recurse into constituents.
@@ -851,29 +369,29 @@ func defgotype(gotype *LSym) *LSym {
 		return sdie
 	}
 
-	return newtype(gotype).sym
+	return newtype(gotype).Sym.(*LSym)
 }
 
-func newtype(gotype *LSym) *DWDie {
+func newtype(gotype *LSym) *dwarf.DWDie {
 	name := gotype.Name[5:] // could also decode from Type.string
 	kind := decodetype_kind(gotype)
 	bytesize := decodetype_size(gotype)
 
-	var die *DWDie
+	var die *dwarf.DWDie
 	switch kind {
 	case obj.KindBool:
-		die = newdie(&dwtypes, DW_ABRV_BASETYPE, name, 0)
-		newattr(die, DW_AT_encoding, DW_CLS_CONSTANT, DW_ATE_boolean, 0)
-		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0)
+		die = newdie(&dwtypes, dwarf.DW_ABRV_BASETYPE, name, 0)
+		newattr(die, dwarf.DW_AT_encoding, dwarf.DW_CLS_CONSTANT, dwarf.DW_ATE_boolean, 0)
+		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 
 	case obj.KindInt,
 		obj.KindInt8,
 		obj.KindInt16,
 		obj.KindInt32,
 		obj.KindInt64:
-		die = newdie(&dwtypes, DW_ABRV_BASETYPE, name, 0)
-		newattr(die, DW_AT_encoding, DW_CLS_CONSTANT, DW_ATE_signed, 0)
-		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0)
+		die = newdie(&dwtypes, dwarf.DW_ABRV_BASETYPE, name, 0)
+		newattr(die, dwarf.DW_AT_encoding, dwarf.DW_CLS_CONSTANT, dwarf.DW_ATE_signed, 0)
+		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 
 	case obj.KindUint,
 		obj.KindUint8,
@@ -881,71 +399,71 @@ func newtype(gotype *LSym) *DWDie {
 		obj.KindUint32,
 		obj.KindUint64,
 		obj.KindUintptr:
-		die = newdie(&dwtypes, DW_ABRV_BASETYPE, name, 0)
-		newattr(die, DW_AT_encoding, DW_CLS_CONSTANT, DW_ATE_unsigned, 0)
-		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0)
+		die = newdie(&dwtypes, dwarf.DW_ABRV_BASETYPE, name, 0)
+		newattr(die, dwarf.DW_AT_encoding, dwarf.DW_CLS_CONSTANT, dwarf.DW_ATE_unsigned, 0)
+		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 
 	case obj.KindFloat32,
 		obj.KindFloat64:
-		die = newdie(&dwtypes, DW_ABRV_BASETYPE, name, 0)
-		newattr(die, DW_AT_encoding, DW_CLS_CONSTANT, DW_ATE_float, 0)
-		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0)
+		die = newdie(&dwtypes, dwarf.DW_ABRV_BASETYPE, name, 0)
+		newattr(die, dwarf.DW_AT_encoding, dwarf.DW_CLS_CONSTANT, dwarf.DW_ATE_float, 0)
+		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 
 	case obj.KindComplex64,
 		obj.KindComplex128:
-		die = newdie(&dwtypes, DW_ABRV_BASETYPE, name, 0)
-		newattr(die, DW_AT_encoding, DW_CLS_CONSTANT, DW_ATE_complex_float, 0)
-		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0)
+		die = newdie(&dwtypes, dwarf.DW_ABRV_BASETYPE, name, 0)
+		newattr(die, dwarf.DW_AT_encoding, dwarf.DW_CLS_CONSTANT, dwarf.DW_ATE_complex_float, 0)
+		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 
 	case obj.KindArray:
-		die = newdie(&dwtypes, DW_ABRV_ARRAYTYPE, name, 0)
+		die = newdie(&dwtypes, dwarf.DW_ABRV_ARRAYTYPE, name, 0)
 		dotypedef(&dwtypes, name, die)
-		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0)
+		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 		s := decodetype_arrayelem(gotype)
-		newrefattr(die, DW_AT_type, defgotype(s))
-		fld := newdie(die, DW_ABRV_ARRAYRANGE, "range", 0)
+		newrefattr(die, dwarf.DW_AT_type, defgotype(s))
+		fld := newdie(die, dwarf.DW_ABRV_ARRAYRANGE, "range", 0)
 
 		// use actual length not upper bound; correct for 0-length arrays.
-		newattr(fld, DW_AT_count, DW_CLS_CONSTANT, decodetype_arraylen(gotype), 0)
+		newattr(fld, dwarf.DW_AT_count, dwarf.DW_CLS_CONSTANT, decodetype_arraylen(gotype), 0)
 
-		newrefattr(fld, DW_AT_type, mustFind("uintptr"))
+		newrefattr(fld, dwarf.DW_AT_type, mustFind("uintptr"))
 
 	case obj.KindChan:
-		die = newdie(&dwtypes, DW_ABRV_CHANTYPE, name, 0)
-		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0)
+		die = newdie(&dwtypes, dwarf.DW_ABRV_CHANTYPE, name, 0)
+		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 		s := decodetype_chanelem(gotype)
-		newrefattr(die, DW_AT_go_elem, defgotype(s))
+		newrefattr(die, dwarf.DW_AT_go_elem, defgotype(s))
 		// Save elem type for synthesizechantypes. We could synthesize here
 		// but that would change the order of DIEs we output.
-		newrefattr(die, DW_AT_type, s)
+		newrefattr(die, dwarf.DW_AT_type, s)
 
 	case obj.KindFunc:
-		die = newdie(&dwtypes, DW_ABRV_FUNCTYPE, name, 0)
+		die = newdie(&dwtypes, dwarf.DW_ABRV_FUNCTYPE, name, 0)
 		dotypedef(&dwtypes, name, die)
-		newrefattr(die, DW_AT_type, mustFind("void"))
+		newrefattr(die, dwarf.DW_AT_type, mustFind("void"))
 		nfields := decodetype_funcincount(gotype)
-		var fld *DWDie
+		var fld *dwarf.DWDie
 		var s *LSym
 		for i := 0; i < nfields; i++ {
 			s = decodetype_funcintype(gotype, i)
-			fld = newdie(die, DW_ABRV_FUNCTYPEPARAM, s.Name[5:], 0)
-			newrefattr(fld, DW_AT_type, defgotype(s))
+			fld = newdie(die, dwarf.DW_ABRV_FUNCTYPEPARAM, s.Name[5:], 0)
+			newrefattr(fld, dwarf.DW_AT_type, defgotype(s))
 		}
 
 		if decodetype_funcdotdotdot(gotype) {
-			newdie(die, DW_ABRV_DOTDOTDOT, "...", 0)
+			newdie(die, dwarf.DW_ABRV_DOTDOTDOT, "...", 0)
 		}
 		nfields = decodetype_funcoutcount(gotype)
 		for i := 0; i < nfields; i++ {
 			s = decodetype_funcouttype(gotype, i)
-			fld = newdie(die, DW_ABRV_FUNCTYPEPARAM, s.Name[5:], 0)
-			newrefattr(fld, DW_AT_type, defptrto(defgotype(s)))
+			fld = newdie(die, dwarf.DW_ABRV_FUNCTYPEPARAM, s.Name[5:], 0)
+			newrefattr(fld, dwarf.DW_AT_type, defptrto(defgotype(s)))
 		}
 
 	case obj.KindInterface:
-		die = newdie(&dwtypes, DW_ABRV_IFACETYPE, name, 0)
+		die = newdie(&dwtypes, dwarf.DW_ABRV_IFACETYPE, name, 0)
 		dotypedef(&dwtypes, name, die)
-		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0)
+		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 		nfields := int(decodetype_ifacemethodcount(gotype))
 		var s *LSym
 		if nfields == 0 {
@@ -953,43 +471,43 @@ func newtype(gotype *LSym) *DWDie {
 		} else {
 			s = lookup_or_diag("type.runtime.iface")
 		}
-		newrefattr(die, DW_AT_type, defgotype(s))
+		newrefattr(die, dwarf.DW_AT_type, defgotype(s))
 
 	case obj.KindMap:
-		die = newdie(&dwtypes, DW_ABRV_MAPTYPE, name, 0)
+		die = newdie(&dwtypes, dwarf.DW_ABRV_MAPTYPE, name, 0)
 		s := decodetype_mapkey(gotype)
-		newrefattr(die, DW_AT_go_key, defgotype(s))
+		newrefattr(die, dwarf.DW_AT_go_key, defgotype(s))
 		s = decodetype_mapvalue(gotype)
-		newrefattr(die, DW_AT_go_elem, defgotype(s))
+		newrefattr(die, dwarf.DW_AT_go_elem, defgotype(s))
 		// Save gotype for use in synthesizemaptypes. We could synthesize here,
 		// but that would change the order of the DIEs.
-		newrefattr(die, DW_AT_type, gotype)
+		newrefattr(die, dwarf.DW_AT_type, gotype)
 
 	case obj.KindPtr:
-		die = newdie(&dwtypes, DW_ABRV_PTRTYPE, name, 0)
+		die = newdie(&dwtypes, dwarf.DW_ABRV_PTRTYPE, name, 0)
 		dotypedef(&dwtypes, name, die)
 		s := decodetype_ptrelem(gotype)
-		newrefattr(die, DW_AT_type, defgotype(s))
+		newrefattr(die, dwarf.DW_AT_type, defgotype(s))
 
 	case obj.KindSlice:
-		die = newdie(&dwtypes, DW_ABRV_SLICETYPE, name, 0)
+		die = newdie(&dwtypes, dwarf.DW_ABRV_SLICETYPE, name, 0)
 		dotypedef(&dwtypes, name, die)
-		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0)
+		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 		s := decodetype_arrayelem(gotype)
 		elem := defgotype(s)
-		newrefattr(die, DW_AT_go_elem, elem)
+		newrefattr(die, dwarf.DW_AT_go_elem, elem)
 
 	case obj.KindString:
-		die = newdie(&dwtypes, DW_ABRV_STRINGTYPE, name, 0)
-		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0)
+		die = newdie(&dwtypes, dwarf.DW_ABRV_STRINGTYPE, name, 0)
+		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 
 	case obj.KindStruct:
-		die = newdie(&dwtypes, DW_ABRV_STRUCTTYPE, name, 0)
+		die = newdie(&dwtypes, dwarf.DW_ABRV_STRUCTTYPE, name, 0)
 		dotypedef(&dwtypes, name, die)
-		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0)
+		newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, bytesize, 0)
 		nfields := decodetype_structfieldcount(gotype)
 		var f string
-		var fld *DWDie
+		var fld *dwarf.DWDie
 		var s *LSym
 		for i := 0; i < nfields; i++ {
 			f = decodetype_structfieldname(gotype, i)
@@ -997,21 +515,21 @@ func newtype(gotype *LSym) *DWDie {
 			if f == "" {
 				f = s.Name[5:] // skip "type."
 			}
-			fld = newdie(die, DW_ABRV_STRUCTFIELD, f, 0)
-			newrefattr(fld, DW_AT_type, defgotype(s))
+			fld = newdie(die, dwarf.DW_ABRV_STRUCTFIELD, f, 0)
+			newrefattr(fld, dwarf.DW_AT_type, defgotype(s))
 			newmemberoffsetattr(fld, int32(decodetype_structfieldoffs(gotype, i)))
 		}
 
 	case obj.KindUnsafePointer:
-		die = newdie(&dwtypes, DW_ABRV_BARE_PTRTYPE, name, 0)
+		die = newdie(&dwtypes, dwarf.DW_ABRV_BARE_PTRTYPE, name, 0)
 
 	default:
 		Diag("dwarf: definition of unknown kind %d: %s", kind, gotype.Name)
-		die = newdie(&dwtypes, DW_ABRV_TYPEDECL, name, 0)
-		newrefattr(die, DW_AT_type, mustFind("<unspecified>"))
+		die = newdie(&dwtypes, dwarf.DW_ABRV_TYPEDECL, name, 0)
+		newrefattr(die, dwarf.DW_AT_type, mustFind("<unspecified>"))
 	}
 
-	newattr(die, DW_AT_go_kind, DW_CLS_CONSTANT, int64(kind), 0)
+	newattr(die, dwarf.DW_AT_go_kind, dwarf.DW_CLS_CONSTANT, int64(kind), 0)
 
 	if _, ok := prototypedies[gotype.Name]; ok {
 		prototypedies[gotype.Name] = die
@@ -1021,7 +539,7 @@ func newtype(gotype *LSym) *DWDie {
 }
 
 func nameFromDIESym(dwtype *LSym) string {
-	return strings.TrimSuffix(dwtype.Name[len(infoprefix):], "..def")
+	return strings.TrimSuffix(dwtype.Name[len(dwarf.InfoPrefix):], "..def")
 }
 
 // Find or construct *T given T.
@@ -1029,9 +547,9 @@ func defptrto(dwtype *LSym) *LSym {
 	ptrname := "*" + nameFromDIESym(dwtype)
 	die := find(ptrname)
 	if die == nil {
-		pdie := newdie(&dwtypes, DW_ABRV_PTRTYPE, ptrname, 0)
-		newrefattr(pdie, DW_AT_type, dwtype)
-		return pdie.sym
+		pdie := newdie(&dwtypes, dwarf.DW_ABRV_PTRTYPE, ptrname, 0)
+		newrefattr(pdie, dwarf.DW_AT_type, dwtype)
+		return dtolsym(pdie.Sym)
 	}
 
 	return die
@@ -1040,44 +558,44 @@ func defptrto(dwtype *LSym) *LSym {
 // Copies src's children into dst. Copies attributes by value.
 // DWAttr.data is copied as pointer only. If except is one of
 // the top-level children, it will not be copied.
-func copychildrenexcept(dst *DWDie, src *DWDie, except *DWDie) {
-	for src = src.child; src != nil; src = src.link {
+func copychildrenexcept(dst *dwarf.DWDie, src *dwarf.DWDie, except *dwarf.DWDie) {
+	for src = src.Child; src != nil; src = src.Link {
 		if src == except {
 			continue
 		}
-		c := newdie(dst, src.abbrev, getattr(src, DW_AT_name).data.(string), 0)
-		for a := src.attr; a != nil; a = a.link {
-			newattr(c, a.atr, int(a.cls), a.value, a.data)
+		c := newdie(dst, src.Abbrev, getattr(src, dwarf.DW_AT_name).Data.(string), 0)
+		for a := src.Attr; a != nil; a = a.Link {
+			newattr(c, a.Atr, int(a.Cls), a.Value, a.Data)
 		}
 		copychildrenexcept(c, src, nil)
 	}
 
-	reverselist(&dst.child)
+	reverselist(&dst.Child)
 }
 
-func copychildren(dst *DWDie, src *DWDie) {
+func copychildren(dst *dwarf.DWDie, src *dwarf.DWDie) {
 	copychildrenexcept(dst, src, nil)
 }
 
-// Search children (assumed to have DW_TAG_member) for the one named
-// field and set its DW_AT_type to dwtype
-func substitutetype(structdie *DWDie, field string, dwtype *LSym) {
+// Search children (assumed to have TAG_member) for the one named
+// field and set its AT_type to dwtype
+func substitutetype(structdie *dwarf.DWDie, field string, dwtype *LSym) {
 	child := findchild(structdie, field)
 	if child == nil {
 		Exitf("dwarf substitutetype: %s does not have member %s",
-			getattr(structdie, DW_AT_name).data, field)
+			getattr(structdie, dwarf.DW_AT_name).Data, field)
 		return
 	}
 
-	a := getattr(child, DW_AT_type)
+	a := getattr(child, dwarf.DW_AT_type)
 	if a != nil {
-		a.data = dwtype
+		a.Data = dwtype
 	} else {
-		newrefattr(child, DW_AT_type, dwtype)
+		newrefattr(child, dwarf.DW_AT_type, dwtype)
 	}
 }
 
-func findprotodie(name string) *DWDie {
+func findprotodie(name string) *dwarf.DWDie {
 	die, ok := prototypedies[name]
 	if ok && die == nil {
 		defgotype(lookup_or_diag(name))
@@ -1086,32 +604,32 @@ func findprotodie(name string) *DWDie {
 	return die
 }
 
-func synthesizestringtypes(die *DWDie) {
+func synthesizestringtypes(die *dwarf.DWDie) {
 	prototype := walktypedef(findprotodie("type.runtime.stringStructDWARF"))
 	if prototype == nil {
 		return
 	}
 
-	for ; die != nil; die = die.link {
-		if die.abbrev != DW_ABRV_STRINGTYPE {
+	for ; die != nil; die = die.Link {
+		if die.Abbrev != dwarf.DW_ABRV_STRINGTYPE {
 			continue
 		}
 		copychildren(die, prototype)
 	}
 }
 
-func synthesizeslicetypes(die *DWDie) {
+func synthesizeslicetypes(die *dwarf.DWDie) {
 	prototype := walktypedef(findprotodie("type.runtime.slice"))
 	if prototype == nil {
 		return
 	}
 
-	for ; die != nil; die = die.link {
-		if die.abbrev != DW_ABRV_SLICETYPE {
+	for ; die != nil; die = die.Link {
+		if die.Abbrev != dwarf.DW_ABRV_SLICETYPE {
 			continue
 		}
 		copychildren(die, prototype)
-		elem := getattr(die, DW_AT_go_elem).data.(*LSym)
+		elem := getattr(die, dwarf.DW_AT_go_elem).Data.(*LSym)
 		substitutetype(die, "array", defptrto(elem))
 	}
 }
@@ -1135,19 +653,19 @@ const (
 	BucketSize = 8
 )
 
-func mkinternaltype(abbrev int, typename, keyname, valname string, f func(*DWDie)) *LSym {
+func mkinternaltype(abbrev int, typename, keyname, valname string, f func(*dwarf.DWDie)) *LSym {
 	name := mkinternaltypename(typename, keyname, valname)
-	symname := infoprefix + name
+	symname := dwarf.InfoPrefix + name
 	s := Linkrlookup(Ctxt, symname, 0)
-	if s != nil {
+	if s != nil && s.Type == obj.SDWARFINFO {
 		return s
 	}
 	die := newdie(&dwtypes, abbrev, name, 0)
 	f(die)
-	return die.sym
+	return dtolsym(die.Sym)
 }
 
-func synthesizemaptypes(die *DWDie) {
+func synthesizemaptypes(die *dwarf.DWDie) {
 	hash := walktypedef(findprotodie("type.runtime.hmap"))
 	bucket := walktypedef(findprotodie("type.runtime.bmap"))
 
@@ -1155,11 +673,11 @@ func synthesizemaptypes(die *DWDie) {
 		return
 	}
 
-	for ; die != nil; die = die.link {
-		if die.abbrev != DW_ABRV_MAPTYPE {
+	for ; die != nil; die = die.Link {
+		if die.Abbrev != dwarf.DW_ABRV_MAPTYPE {
 			continue
 		}
-		gotype := getattr(die, DW_AT_type).data.(*LSym)
+		gotype := getattr(die, dwarf.DW_AT_type).Data.(*LSym)
 		keytype := decodetype_mapkey(gotype)
 		valtype := decodetype_mapvalue(gotype)
 		keysize, valsize := decodetype_size(keytype), decodetype_size(valtype)
@@ -1178,70 +696,70 @@ func synthesizemaptypes(die *DWDie) {
 
 		// Construct type to represent an array of BucketSize keys
 		keyname := nameFromDIESym(keytype)
-		dwhks := mkinternaltype(DW_ABRV_ARRAYTYPE, "[]key", keyname, "", func(dwhk *DWDie) {
-			newattr(dwhk, DW_AT_byte_size, DW_CLS_CONSTANT, BucketSize*keysize, 0)
+		dwhks := mkinternaltype(dwarf.DW_ABRV_ARRAYTYPE, "[]key", keyname, "", func(dwhk *dwarf.DWDie) {
+			newattr(dwhk, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, BucketSize*keysize, 0)
 			t := keytype
 			if indirect_key {
 				t = defptrto(keytype)
 			}
-			newrefattr(dwhk, DW_AT_type, t)
-			fld := newdie(dwhk, DW_ABRV_ARRAYRANGE, "size", 0)
-			newattr(fld, DW_AT_count, DW_CLS_CONSTANT, BucketSize, 0)
-			newrefattr(fld, DW_AT_type, mustFind("uintptr"))
+			newrefattr(dwhk, dwarf.DW_AT_type, t)
+			fld := newdie(dwhk, dwarf.DW_ABRV_ARRAYRANGE, "size", 0)
+			newattr(fld, dwarf.DW_AT_count, dwarf.DW_CLS_CONSTANT, BucketSize, 0)
+			newrefattr(fld, dwarf.DW_AT_type, mustFind("uintptr"))
 		})
 
 		// Construct type to represent an array of BucketSize values
 		valname := nameFromDIESym(valtype)
-		dwhvs := mkinternaltype(DW_ABRV_ARRAYTYPE, "[]val", valname, "", func(dwhv *DWDie) {
-			newattr(dwhv, DW_AT_byte_size, DW_CLS_CONSTANT, BucketSize*valsize, 0)
+		dwhvs := mkinternaltype(dwarf.DW_ABRV_ARRAYTYPE, "[]val", valname, "", func(dwhv *dwarf.DWDie) {
+			newattr(dwhv, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, BucketSize*valsize, 0)
 			t := valtype
 			if indirect_val {
 				t = defptrto(valtype)
 			}
-			newrefattr(dwhv, DW_AT_type, t)
-			fld := newdie(dwhv, DW_ABRV_ARRAYRANGE, "size", 0)
-			newattr(fld, DW_AT_count, DW_CLS_CONSTANT, BucketSize, 0)
-			newrefattr(fld, DW_AT_type, mustFind("uintptr"))
+			newrefattr(dwhv, dwarf.DW_AT_type, t)
+			fld := newdie(dwhv, dwarf.DW_ABRV_ARRAYRANGE, "size", 0)
+			newattr(fld, dwarf.DW_AT_count, dwarf.DW_CLS_CONSTANT, BucketSize, 0)
+			newrefattr(fld, dwarf.DW_AT_type, mustFind("uintptr"))
 		})
 
 		// Construct bucket<K,V>
-		dwhbs := mkinternaltype(DW_ABRV_STRUCTTYPE, "bucket", keyname, valname, func(dwhb *DWDie) {
+		dwhbs := mkinternaltype(dwarf.DW_ABRV_STRUCTTYPE, "bucket", keyname, valname, func(dwhb *dwarf.DWDie) {
 			// Copy over all fields except the field "data" from the generic
 			// bucket. "data" will be replaced with keys/values below.
 			copychildrenexcept(dwhb, bucket, findchild(bucket, "data"))
 
-			fld := newdie(dwhb, DW_ABRV_STRUCTFIELD, "keys", 0)
-			newrefattr(fld, DW_AT_type, dwhks)
+			fld := newdie(dwhb, dwarf.DW_ABRV_STRUCTFIELD, "keys", 0)
+			newrefattr(fld, dwarf.DW_AT_type, dwhks)
 			newmemberoffsetattr(fld, BucketSize)
-			fld = newdie(dwhb, DW_ABRV_STRUCTFIELD, "values", 0)
-			newrefattr(fld, DW_AT_type, dwhvs)
+			fld = newdie(dwhb, dwarf.DW_ABRV_STRUCTFIELD, "values", 0)
+			newrefattr(fld, dwarf.DW_AT_type, dwhvs)
 			newmemberoffsetattr(fld, BucketSize+BucketSize*int32(keysize))
-			fld = newdie(dwhb, DW_ABRV_STRUCTFIELD, "overflow", 0)
-			newrefattr(fld, DW_AT_type, defptrto(dwhb.sym))
+			fld = newdie(dwhb, dwarf.DW_ABRV_STRUCTFIELD, "overflow", 0)
+			newrefattr(fld, dwarf.DW_AT_type, defptrto(dtolsym(dwhb.Sym)))
 			newmemberoffsetattr(fld, BucketSize+BucketSize*(int32(keysize)+int32(valsize)))
 			if SysArch.RegSize > SysArch.PtrSize {
-				fld = newdie(dwhb, DW_ABRV_STRUCTFIELD, "pad", 0)
-				newrefattr(fld, DW_AT_type, mustFind("uintptr"))
+				fld = newdie(dwhb, dwarf.DW_ABRV_STRUCTFIELD, "pad", 0)
+				newrefattr(fld, dwarf.DW_AT_type, mustFind("uintptr"))
 				newmemberoffsetattr(fld, BucketSize+BucketSize*(int32(keysize)+int32(valsize))+int32(SysArch.PtrSize))
 			}
 
-			newattr(dwhb, DW_AT_byte_size, DW_CLS_CONSTANT, BucketSize+BucketSize*keysize+BucketSize*valsize+int64(SysArch.RegSize), 0)
+			newattr(dwhb, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, BucketSize+BucketSize*keysize+BucketSize*valsize+int64(SysArch.RegSize), 0)
 		})
 
 		// Construct hash<K,V>
-		dwhs := mkinternaltype(DW_ABRV_STRUCTTYPE, "hash", keyname, valname, func(dwh *DWDie) {
+		dwhs := mkinternaltype(dwarf.DW_ABRV_STRUCTTYPE, "hash", keyname, valname, func(dwh *dwarf.DWDie) {
 			copychildren(dwh, hash)
 			substitutetype(dwh, "buckets", defptrto(dwhbs))
 			substitutetype(dwh, "oldbuckets", defptrto(dwhbs))
-			newattr(dwh, DW_AT_byte_size, DW_CLS_CONSTANT, getattr(hash, DW_AT_byte_size).value, nil)
+			newattr(dwh, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, getattr(hash, dwarf.DW_AT_byte_size).Value, nil)
 		})
 
 		// make map type a pointer to hash<K,V>
-		newrefattr(die, DW_AT_type, defptrto(dwhs))
+		newrefattr(die, dwarf.DW_AT_type, defptrto(dwhs))
 	}
 }
 
-func synthesizechantypes(die *DWDie) {
+func synthesizechantypes(die *dwarf.DWDie) {
 	sudog := walktypedef(findprotodie("type.runtime.sudog"))
 	waitq := walktypedef(findprotodie("type.runtime.waitq"))
 	hchan := walktypedef(findprotodie("type.runtime.hchan"))
@@ -1249,19 +767,19 @@ func synthesizechantypes(die *DWDie) {
 		return
 	}
 
-	sudogsize := int(getattr(sudog, DW_AT_byte_size).value)
+	sudogsize := int(getattr(sudog, dwarf.DW_AT_byte_size).Value)
 
-	for ; die != nil; die = die.link {
-		if die.abbrev != DW_ABRV_CHANTYPE {
+	for ; die != nil; die = die.Link {
+		if die.Abbrev != dwarf.DW_ABRV_CHANTYPE {
 			continue
 		}
-		elemgotype := getattr(die, DW_AT_type).data.(*LSym)
+		elemgotype := getattr(die, dwarf.DW_AT_type).Data.(*LSym)
 		elemsize := decodetype_size(elemgotype)
 		elemname := elemgotype.Name[5:]
 		elemtype := walksymtypedef(defgotype(elemgotype))
 
 		// sudog<T>
-		dwss := mkinternaltype(DW_ABRV_STRUCTTYPE, "sudog", elemname, "", func(dws *DWDie) {
+		dwss := mkinternaltype(dwarf.DW_ABRV_STRUCTTYPE, "sudog", elemname, "", func(dws *dwarf.DWDie) {
 			copychildren(dws, sudog)
 			substitutetype(dws, "elem", elemtype)
 			if elemsize > 8 {
@@ -1269,27 +787,27 @@ func synthesizechantypes(die *DWDie) {
 			} else {
 				elemsize = 0
 			}
-			newattr(dws, DW_AT_byte_size, DW_CLS_CONSTANT, int64(sudogsize)+elemsize, nil)
+			newattr(dws, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, int64(sudogsize)+elemsize, nil)
 		})
 
 		// waitq<T>
-		dwws := mkinternaltype(DW_ABRV_STRUCTTYPE, "waitq", elemname, "", func(dww *DWDie) {
+		dwws := mkinternaltype(dwarf.DW_ABRV_STRUCTTYPE, "waitq", elemname, "", func(dww *dwarf.DWDie) {
 
 			copychildren(dww, waitq)
 			substitutetype(dww, "first", defptrto(dwss))
 			substitutetype(dww, "last", defptrto(dwss))
-			newattr(dww, DW_AT_byte_size, DW_CLS_CONSTANT, getattr(waitq, DW_AT_byte_size).value, nil)
+			newattr(dww, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, getattr(waitq, dwarf.DW_AT_byte_size).Value, nil)
 		})
 
 		// hchan<T>
-		dwhs := mkinternaltype(DW_ABRV_STRUCTTYPE, "hchan", elemname, "", func(dwh *DWDie) {
+		dwhs := mkinternaltype(dwarf.DW_ABRV_STRUCTTYPE, "hchan", elemname, "", func(dwh *dwarf.DWDie) {
 			copychildren(dwh, hchan)
 			substitutetype(dwh, "recvq", dwws)
 			substitutetype(dwh, "sendq", dwws)
-			newattr(dwh, DW_AT_byte_size, DW_CLS_CONSTANT, getattr(hchan, DW_AT_byte_size).value, nil)
+			newattr(dwh, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, getattr(hchan, dwarf.DW_AT_byte_size).Value, nil)
 		})
 
-		newrefattr(die, DW_AT_type, defptrto(dwhs))
+		newrefattr(die, dwarf.DW_AT_type, defptrto(dwhs))
 	}
 }
 
@@ -1307,7 +825,7 @@ func defdwsymb(sym *LSym, s string, t int, v int64, size int64, ver int, gotype
 		return
 	}
 
-	var dv *DWDie
+	var dv *dwarf.DWDie
 
 	var dt *LSym
 	switch t {
@@ -1315,10 +833,10 @@ func defdwsymb(sym *LSym, s string, t int, v int64, size int64, ver int, gotype
 		return
 
 	case 'd', 'b', 'D', 'B':
-		dv = newdie(&dwglobals, DW_ABRV_VARIABLE, s, ver)
+		dv = newdie(&dwglobals, dwarf.DW_ABRV_VARIABLE, s, ver)
 		newabslocexprattr(dv, v, sym)
 		if ver == 0 {
-			newattr(dv, DW_AT_external, DW_CLS_FLAG, 1, 0)
+			newattr(dv, dwarf.DW_AT_external, dwarf.DW_CLS_FLAG, 1, 0)
 		}
 		fallthrough
 
@@ -1327,16 +845,20 @@ func defdwsymb(sym *LSym, s string, t int, v int64, size int64, ver int, gotype
 	}
 
 	if dv != nil {
-		newrefattr(dv, DW_AT_type, dt)
+		newrefattr(dv, dwarf.DW_AT_type, dt)
 	}
 }
 
-func movetomodule(parent *DWDie) {
-	die := dwroot.child.child
-	for die.link != nil {
-		die = die.link
+func movetomodule(parent *dwarf.DWDie) {
+	die := dwroot.Child.Child
+	if die == nil {
+		dwroot.Child.Child = parent.Child
+		return
+	}
+	for die.Link != nil {
+		die = die.Link
 	}
-	die.link = parent.child
+	die.Link = parent.Child
 }
 
 // If the pcln table contains runtime/runtime.go, use that to set gdbscript path.
@@ -1364,7 +886,7 @@ const (
 	OPCODE_BASE = 10
 )
 
-func putpclcdelta(s *LSym, delta_pc int64, delta_lc int64) {
+func putpclcdelta(ctxt dwarf.Context, s *LSym, delta_pc int64, delta_lc int64) {
 	if LINE_BASE <= delta_lc && delta_lc < LINE_BASE+LINE_RANGE {
 		var opcode int64 = OPCODE_BASE + (delta_lc - LINE_BASE) + (LINE_RANGE * delta_pc)
 		if OPCODE_BASE <= opcode && opcode < 256 {
@@ -1374,32 +896,13 @@ func putpclcdelta(s *LSym, delta_pc int64, delta_lc int64) {
 	}
 
 	if delta_pc != 0 {
-		Adduint8(Ctxt, s, DW_LNS_advance_pc)
-		sleb128put(s, delta_pc)
+		Adduint8(Ctxt, s, dwarf.DW_LNS_advance_pc)
+		dwarf.Sleb128put(ctxt, s, delta_pc)
 	}
 
-	Adduint8(Ctxt, s, DW_LNS_advance_line)
-	sleb128put(s, delta_lc)
-	Adduint8(Ctxt, s, DW_LNS_copy)
-}
-
-func newcfaoffsetattr(die *DWDie, offs int32) {
-	var block [20]byte
-	b := append(block[:0], DW_OP_call_frame_cfa)
-
-	if offs != 0 {
-		b = append(b, DW_OP_consts)
-		b = appendSleb128(b, int64(offs))
-		b = append(b, DW_OP_plus)
-	}
-
-	newattr(die, DW_AT_location, DW_CLS_BLOCK, int64(len(b)), b)
-}
-
-func mkvarname(name string, da int) string {
-	buf := fmt.Sprintf("%s#%d", name, da)
-	n := buf
-	return n
+	Adduint8(Ctxt, s, dwarf.DW_LNS_advance_line)
+	dwarf.Sleb128put(ctxt, s, delta_lc)
+	Adduint8(Ctxt, s, dwarf.DW_LNS_copy)
 }
 
 /*
@@ -1413,7 +916,8 @@ func getCompilationDir() string {
 	return "/"
 }
 
-func writelines(prev *LSym) *LSym {
+func writelines(syms []*LSym) ([]*LSym, []*LSym) {
+	var dwarfctxt dwarf.Context = dwCtxt{}
 	if linesec == nil {
 		linesec = Linklookup(Ctxt, ".debug_line", 0)
 	}
@@ -1421,26 +925,27 @@ func writelines(prev *LSym) *LSym {
 	linesec.R = linesec.R[:0]
 
 	ls := linesec
-	prev.Next = ls
+	syms = append(syms, ls)
+	var funcs []*LSym
 
 	unitstart := int64(-1)
 	headerstart := int64(-1)
 	headerend := int64(-1)
 	epc := int64(0)
 	var epcs *LSym
-	var dwinfo *DWDie
+	var dwinfo *dwarf.DWDie
 
-	lang := DW_LANG_Go
+	lang := dwarf.DW_LANG_Go
 
 	s := Ctxt.Textp[0]
 
-	dwinfo = newdie(&dwroot, DW_ABRV_COMPUNIT, "go", 0)
-	newattr(dwinfo, DW_AT_language, DW_CLS_CONSTANT, int64(lang), 0)
-	newattr(dwinfo, DW_AT_stmt_list, DW_CLS_PTR, 0, 0)
-	newattr(dwinfo, DW_AT_low_pc, DW_CLS_ADDRESS, s.Value, s)
+	dwinfo = newdie(&dwroot, dwarf.DW_ABRV_COMPUNIT, "go", 0)
+	newattr(dwinfo, dwarf.DW_AT_language, dwarf.DW_CLS_CONSTANT, int64(lang), 0)
+	newattr(dwinfo, dwarf.DW_AT_stmt_list, dwarf.DW_CLS_PTR, 0, linesec)
+	newattr(dwinfo, dwarf.DW_AT_low_pc, dwarf.DW_CLS_ADDRESS, s.Value, s)
 	// OS X linker requires compilation dir or absolute path in comp unit name to output debug info.
 	compDir := getCompilationDir()
-	newattr(dwinfo, DW_AT_comp_dir, DW_CLS_STRING, int64(len(compDir)), compDir)
+	newattr(dwinfo, dwarf.DW_AT_comp_dir, dwarf.DW_CLS_STRING, int64(len(compDir)), compDir)
 
 	// Write .debug_line Line Number Program Header (sec 6.2.4)
 	// Fields marked with (*) must be changed for 64-bit dwarf
@@ -1482,31 +987,36 @@ func writelines(prev *LSym) *LSym {
 	headerend = ls.Size
 
 	Adduint8(Ctxt, ls, 0) // start extended opcode
-	uleb128put(ls, 1+int64(SysArch.PtrSize))
-	Adduint8(Ctxt, ls, DW_LNE_set_address)
+	dwarf.Uleb128put(dwarfctxt, ls, 1+int64(SysArch.PtrSize))
+	Adduint8(Ctxt, ls, dwarf.DW_LNE_set_address)
 
 	pc := s.Value
 	line := 1
 	file := 1
-	if Linkmode == LinkExternal {
-		Addaddr(Ctxt, ls, s)
-	} else {
-		addrput(ls, pc)
-	}
+	Addaddr(Ctxt, ls, s)
 
 	var pcfile Pciter
 	var pcline Pciter
 	for _, Ctxt.Cursym = range Ctxt.Textp {
 		s := Ctxt.Cursym
 
-		dwfunc := newdie(dwinfo, DW_ABRV_FUNCTION, s.Name, int(s.Version))
-		newattr(dwfunc, DW_AT_low_pc, DW_CLS_ADDRESS, s.Value, s)
 		epc = s.Value + s.Size
 		epcs = s
-		newattr(dwfunc, DW_AT_high_pc, DW_CLS_ADDRESS, epc, s)
-		if s.Version == 0 {
-			newattr(dwfunc, DW_AT_external, DW_CLS_FLAG, 1, 0)
+
+		dsym := Linklookup(Ctxt, dwarf.InfoPrefix+s.Name, int(s.Version))
+		dsym.Attr |= AttrHidden
+		dsym.Type = obj.SDWARFINFO
+		for _, r := range dsym.R {
+			if r.Type == obj.R_DWARFREF && r.Sym.Size == 0 {
+				if Buildmode == BuildmodeShared {
+					// These type symbols may not be present in BuildmodeShared. Skip.
+					continue
+				}
+				n := nameFromDIESym(r.Sym)
+				defgotype(Linklookup(Ctxt, "type."+n, 0))
+			}
 		}
+		funcs = append(funcs, dsym)
 
 		if s.FuncInfo == nil {
 			continue
@@ -1529,12 +1039,12 @@ func writelines(prev *LSym) *LSym {
 			}
 
 			if int32(file) != pcfile.value {
-				Adduint8(Ctxt, ls, DW_LNS_set_file)
-				uleb128put(ls, int64(pcfile.value))
+				Adduint8(Ctxt, ls, dwarf.DW_LNS_set_file)
+				dwarf.Uleb128put(dwarfctxt, ls, int64(pcfile.value))
 				file = int(pcfile.value)
 			}
 
-			putpclcdelta(ls, s.Value+int64(pcline.pc)-pc, int64(pcline.value)-int64(line))
+			putpclcdelta(dwarfctxt, ls, s.Value+int64(pcline.pc)-pc, int64(pcline.value)-int64(line))
 
 			pc = s.Value + int64(pcline.pc)
 			line = int(pcline.value)
@@ -1545,80 +1055,18 @@ func writelines(prev *LSym) *LSym {
 			}
 			epc += s.Value
 		}
-
-		var (
-			dt, da int
-			offs   int64
-		)
-		for _, a := range s.FuncInfo.Autom {
-			switch a.Name {
-			case obj.A_AUTO:
-				dt = DW_ABRV_AUTO
-				offs = int64(a.Aoffset)
-				if !haslinkregister() {
-					offs -= int64(SysArch.PtrSize)
-				}
-				if obj.Framepointer_enabled(obj.Getgoos(), obj.Getgoarch()) {
-					// The frame pointer is saved
-					// between the CFA and the
-					// autos.
-					offs -= int64(SysArch.PtrSize)
-				}
-
-			case obj.A_PARAM:
-				dt = DW_ABRV_PARAM
-				offs = int64(a.Aoffset) + Ctxt.FixedFrameSize()
-
-			default:
-				continue
-			}
-
-			if strings.Contains(a.Asym.Name, ".autotmp_") {
-				continue
-			}
-			var n string
-			if findchild(dwfunc, a.Asym.Name) != nil {
-				n = mkvarname(a.Asym.Name, da)
-			} else {
-				n = a.Asym.Name
-			}
-
-			// Drop the package prefix from locals and arguments.
-			if i := strings.LastIndex(n, "."); i >= 0 {
-				n = n[i+1:]
-			}
-
-			dwvar := newdie(dwfunc, dt, n, 0)
-			newcfaoffsetattr(dwvar, int32(offs))
-			newrefattr(dwvar, DW_AT_type, defgotype(a.Gotype))
-
-			// push dwvar down dwfunc->child to preserve order
-			newattr(dwvar, DW_AT_internal_location, DW_CLS_CONSTANT, offs, nil)
-
-			dwfunc.child = dwvar.link // take dwvar out from the top of the list
-			dws := &dwfunc.child
-			for ; *dws != nil; dws = &(*dws).link {
-				if offs > getattr(*dws, DW_AT_internal_location).value {
-					break
-				}
-			}
-			dwvar.link = *dws
-			*dws = dwvar
-
-			da++
-		}
 	}
 
 	Adduint8(Ctxt, ls, 0) // start extended opcode
-	uleb128put(ls, 1)
-	Adduint8(Ctxt, ls, DW_LNE_end_sequence)
+	dwarf.Uleb128put(dwarfctxt, ls, 1)
+	Adduint8(Ctxt, ls, dwarf.DW_LNE_end_sequence)
 
-	newattr(dwinfo, DW_AT_high_pc, DW_CLS_ADDRESS, epc+1, epcs)
+	newattr(dwinfo, dwarf.DW_AT_high_pc, dwarf.DW_CLS_ADDRESS, epc+1, epcs)
 
 	setuint32(Ctxt, ls, unit_length_offset, uint32(ls.Size-unitstart))
 	setuint32(Ctxt, ls, header_length_offset, uint32(headerend-headerstart))
 
-	return ls
+	return syms, funcs
 }
 
 /*
@@ -1630,64 +1078,65 @@ const (
 
 // appendPCDeltaCFA appends per-PC CFA deltas to b and returns the final slice.
 func appendPCDeltaCFA(b []byte, deltapc, cfa int64) []byte {
-	b = append(b, DW_CFA_def_cfa_offset_sf)
-	b = appendSleb128(b, cfa/dataAlignmentFactor)
+	b = append(b, dwarf.DW_CFA_def_cfa_offset_sf)
+	b = dwarf.AppendSleb128(b, cfa/dataAlignmentFactor)
 
 	switch {
 	case deltapc < 0x40:
-		b = append(b, uint8(DW_CFA_advance_loc+deltapc))
+		b = append(b, uint8(dwarf.DW_CFA_advance_loc+deltapc))
 	case deltapc < 0x100:
-		b = append(b, DW_CFA_advance_loc1)
+		b = append(b, dwarf.DW_CFA_advance_loc1)
 		b = append(b, uint8(deltapc))
 	case deltapc < 0x10000:
-		b = append(b, DW_CFA_advance_loc2)
+		b = append(b, dwarf.DW_CFA_advance_loc2)
 		b = Thearch.Append16(b, uint16(deltapc))
 	default:
-		b = append(b, DW_CFA_advance_loc4)
+		b = append(b, dwarf.DW_CFA_advance_loc4)
 		b = Thearch.Append32(b, uint32(deltapc))
 	}
 	return b
 }
 
-func writeframes(prev *LSym) *LSym {
+func writeframes(syms []*LSym) []*LSym {
+	var dwarfctxt dwarf.Context = dwCtxt{}
 	if framesec == nil {
 		framesec = Linklookup(Ctxt, ".debug_frame", 0)
 	}
 	framesec.Type = obj.SDWARFSECT
 	framesec.R = framesec.R[:0]
 	fs := framesec
-	prev.Next = fs
+	syms = append(syms, fs)
 
 	// Emit the CIE, Section 6.4.1
 	cieReserve := uint32(16)
 	if haslinkregister() {
 		cieReserve = 32
 	}
-	Adduint32(Ctxt, fs, cieReserve)           // initial length, must be multiple of pointer size
-	Adduint32(Ctxt, fs, 0xffffffff)           // cid.
-	Adduint8(Ctxt, fs, 3)                     // dwarf version (appendix F)
-	Adduint8(Ctxt, fs, 0)                     // augmentation ""
-	uleb128put(fs, 1)                         // code_alignment_factor
-	sleb128put(fs, dataAlignmentFactor)       // all CFI offset calculations include multiplication with this factor
-	uleb128put(fs, int64(Thearch.Dwarfreglr)) // return_address_register
+	Adduint32(Ctxt, fs, cieReserve)                            // initial length, must be multiple of thearch.ptrsize
+	Adduint32(Ctxt, fs, 0xffffffff)                            // cid.
+	Adduint8(Ctxt, fs, 3)                                      // dwarf version (appendix F)
+	Adduint8(Ctxt, fs, 0)                                      // augmentation ""
+	dwarf.Uleb128put(dwarfctxt, fs, 1)                         // code_alignment_factor
+	dwarf.Sleb128put(dwarfctxt, fs, dataAlignmentFactor)       // all CFI offset calculations include multiplication with this factor
+	dwarf.Uleb128put(dwarfctxt, fs, int64(Thearch.Dwarfreglr)) // return_address_register
 
-	Adduint8(Ctxt, fs, DW_CFA_def_cfa)        // Set the current frame address..
-	uleb128put(fs, int64(Thearch.Dwarfregsp)) // ...to use the value in the platform's SP register (defined in l.go)...
+	Adduint8(Ctxt, fs, dwarf.DW_CFA_def_cfa)                   // Set the current frame address..
+	dwarf.Uleb128put(dwarfctxt, fs, int64(Thearch.Dwarfregsp)) // ...to use the value in the platform's SP register (defined in l.go)...
 	if haslinkregister() {
-		uleb128put(fs, int64(0)) // ...plus a 0 offset.
+		dwarf.Uleb128put(dwarfctxt, fs, int64(0)) // ...plus a 0 offset.
 
-		Adduint8(Ctxt, fs, DW_CFA_same_value) // The platform's link register is unchanged during the prologue.
-		uleb128put(fs, int64(Thearch.Dwarfreglr))
+		Adduint8(Ctxt, fs, dwarf.DW_CFA_same_value) // The platform's link register is unchanged during the prologue.
+		dwarf.Uleb128put(dwarfctxt, fs, int64(Thearch.Dwarfreglr))
 
-		Adduint8(Ctxt, fs, DW_CFA_val_offset)     // The previous value...
-		uleb128put(fs, int64(Thearch.Dwarfregsp)) // ...of the platform's SP register...
-		uleb128put(fs, int64(0))                  // ...is CFA+0.
+		Adduint8(Ctxt, fs, dwarf.DW_CFA_val_offset)                // The previous value...
+		dwarf.Uleb128put(dwarfctxt, fs, int64(Thearch.Dwarfregsp)) // ...of the platform's SP register...
+		dwarf.Uleb128put(dwarfctxt, fs, int64(0))                  // ...is CFA+0.
 	} else {
-		uleb128put(fs, int64(SysArch.PtrSize)) // ...plus the word size (because the call instruction implicitly adds one word to the frame).
+		dwarf.Uleb128put(dwarfctxt, fs, int64(SysArch.PtrSize)) // ...plus the word size (because the call instruction implicitly adds one word to the frame).
 
-		Adduint8(Ctxt, fs, DW_CFA_offset_extended)                  // The previous value...
-		uleb128put(fs, int64(Thearch.Dwarfreglr))                   // ...of the return address...
-		uleb128put(fs, int64(-SysArch.PtrSize)/dataAlignmentFactor) // ...is saved at [CFA - (PtrSize/4)].
+		Adduint8(Ctxt, fs, dwarf.DW_CFA_offset_extended)                             // The previous value...
+		dwarf.Uleb128put(dwarfctxt, fs, int64(Thearch.Dwarfreglr))                   // ...of the return address...
+		dwarf.Uleb128put(dwarfctxt, fs, int64(-SysArch.PtrSize)/dataAlignmentFactor) // ...is saved at [CFA - (PtrSize/4)].
 	}
 
 	// 4 is to exclude the length field.
@@ -1729,14 +1178,14 @@ func writeframes(prev *LSym) *LSym {
 				if pcsp.value > 0 {
 					// The return address is preserved at (CFA-frame_size)
 					// after a stack frame has been allocated.
-					deltaBuf = append(deltaBuf, DW_CFA_offset_extended_sf)
-					deltaBuf = appendUleb128(deltaBuf, uint64(Thearch.Dwarfreglr))
-					deltaBuf = appendSleb128(deltaBuf, -int64(pcsp.value)/dataAlignmentFactor)
+					deltaBuf = append(deltaBuf, dwarf.DW_CFA_offset_extended_sf)
+					deltaBuf = dwarf.AppendUleb128(deltaBuf, uint64(Thearch.Dwarfreglr))
+					deltaBuf = dwarf.AppendSleb128(deltaBuf, -int64(pcsp.value)/dataAlignmentFactor)
 				} else {
 					// The return address is restored into the link register
 					// when a stack frame has been de-allocated.
-					deltaBuf = append(deltaBuf, DW_CFA_same_value)
-					deltaBuf = appendUleb128(deltaBuf, uint64(Thearch.Dwarfreglr))
+					deltaBuf = append(deltaBuf, dwarf.DW_CFA_same_value)
+					deltaBuf = dwarf.AppendUleb128(deltaBuf, uint64(Thearch.Dwarfreglr))
 				}
 				deltaBuf = appendPCDeltaCFA(deltaBuf, int64(nextpc)-int64(pcsp.pc), int64(pcsp.value))
 			} else {
@@ -1758,10 +1207,10 @@ func writeframes(prev *LSym) *LSym {
 			Adduint32(Ctxt, fs, 0) // CIE offset
 		}
 		Addaddr(Ctxt, fs, s)
-		addrput(fs, s.Size) // address range
+		adduintxx(Ctxt, fs, uint64(s.Size), SysArch.PtrSize) // address range
 		Addbytes(Ctxt, fs, deltaBuf)
 	}
-	return fs
+	return syms
 }
 
 /*
@@ -1771,23 +1220,24 @@ const (
 	COMPUNITHEADERSIZE = 4 + 2 + 4 + 1
 )
 
-func writeinfo(prev *LSym) *LSym {
+func writeinfo(syms []*LSym, funcs []*LSym) []*LSym {
 	if infosec == nil {
 		infosec = Linklookup(Ctxt, ".debug_info", 0)
 	}
 	infosec.R = infosec.R[:0]
 	infosec.Type = obj.SDWARFINFO
 	infosec.Attr |= AttrReachable
-	prev.Next, prev = infosec, infosec
+	syms = append(syms, infosec)
 
 	if arangessec == nil {
 		arangessec = Linklookup(Ctxt, ".dwarfaranges", 0)
 	}
 	arangessec.R = arangessec.R[:0]
 
-	for compunit := dwroot.child; compunit != nil; compunit = compunit.link {
-		s := compunit.sym
-		prev.Next, prev = s, s
+	var dwarfctxt dwarf.Context = dwCtxt{}
+
+	for compunit := dwroot.Child; compunit != nil; compunit = compunit.Link {
+		s := dtolsym(compunit.Sym)
 
 		// Write .debug_info Compilation Unit Header (sec 7.5.1)
 		// Fields marked with (*) must be changed for 64-bit dwarf
@@ -1800,61 +1250,70 @@ func writeinfo(prev *LSym) *LSym {
 
 		Adduint8(Ctxt, s, uint8(SysArch.PtrSize)) // address_size
 
-		prev = putdie(prev, compunit)
-		cusize := s.Size - 4 // exclude the length field.
-		for child := s.Next; child != nil; child = child.Next {
+		dwarf.Uleb128put(dwarfctxt, s, int64(compunit.Abbrev))
+		dwarf.PutAttrs(dwarfctxt, s, compunit.Abbrev, compunit.Attr)
+
+		cu := []*LSym{s}
+		if funcs != nil {
+			cu = append(cu, funcs...)
+			funcs = nil
+		}
+		cu = putdies(dwarfctxt, cu, compunit.Child)
+		var cusize int64
+		for _, child := range cu {
 			cusize += child.Size
 		}
-
+		cusize -= 4 // exclude the length field.
 		setuint32(Ctxt, s, 0, uint32(cusize))
-		newattr(compunit, DW_AT_byte_size, DW_CLS_CONSTANT, cusize, 0)
+		newattr(compunit, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, cusize, 0)
+		syms = append(syms, cu...)
 	}
-	return prev
+	return syms
 }
 
 /*
  *  Emit .debug_pubnames/_types.  _info must have been written before,
  *  because we need die->offs and infoo/infosize;
  */
-func ispubname(die *DWDie) bool {
-	switch die.abbrev {
-	case DW_ABRV_FUNCTION, DW_ABRV_VARIABLE:
-		a := getattr(die, DW_AT_external)
-		return a != nil && a.value != 0
+func ispubname(die *dwarf.DWDie) bool {
+	switch die.Abbrev {
+	case dwarf.DW_ABRV_FUNCTION, dwarf.DW_ABRV_VARIABLE:
+		a := getattr(die, dwarf.DW_AT_external)
+		return a != nil && a.Value != 0
 	}
 
 	return false
 }
 
-func ispubtype(die *DWDie) bool {
-	return die.abbrev >= DW_ABRV_NULLTYPE
+func ispubtype(die *dwarf.DWDie) bool {
+	return die.Abbrev >= dwarf.DW_ABRV_NULLTYPE
 }
 
-func writepub(sname string, ispub func(*DWDie) bool, prev *LSym) *LSym {
+func writepub(sname string, ispub func(*dwarf.DWDie) bool, syms []*LSym) []*LSym {
 	s := Linklookup(Ctxt, sname, 0)
 	s.Type = obj.SDWARFSECT
-	prev.Next = s
+	syms = append(syms, s)
 
-	for compunit := dwroot.child; compunit != nil; compunit = compunit.link {
+	for compunit := dwroot.Child; compunit != nil; compunit = compunit.Link {
 		sectionstart := s.Size
-		culength := uint32(getattr(compunit, DW_AT_byte_size).value) + 4
+		culength := uint32(getattr(compunit, dwarf.DW_AT_byte_size).Value) + 4
 
 		// Write .debug_pubnames/types	Header (sec 6.1.1)
-		Adduint32(Ctxt, s, 0)                 // unit_length (*), will be filled in later.
-		Adduint16(Ctxt, s, 2)                 // dwarf version (appendix F)
-		adddwarfref(Ctxt, s, compunit.sym, 4) // debug_info_offset (of the Comp unit Header)
-		Adduint32(Ctxt, s, culength)          // debug_info_length
+		Adduint32(Ctxt, s, 0)                          // unit_length (*), will be filled in later.
+		Adduint16(Ctxt, s, 2)                          // dwarf version (appendix F)
+		adddwarfref(Ctxt, s, dtolsym(compunit.Sym), 4) // debug_info_offset (of the Comp unit Header)
+		Adduint32(Ctxt, s, culength)                   // debug_info_length
 
-		for die := compunit.child; die != nil; die = die.link {
+		for die := compunit.Child; die != nil; die = die.Link {
 			if !ispub(die) {
 				continue
 			}
-			dwa := getattr(die, DW_AT_name)
-			name := dwa.data.(string)
-			if die.sym == nil {
+			dwa := getattr(die, dwarf.DW_AT_name)
+			name := dwa.Data.(string)
+			if die.Sym == nil {
 				fmt.Println("Missing sym for ", name)
 			}
-			adddwarfref(Ctxt, s, die.sym, 4)
+			adddwarfref(Ctxt, s, dtolsym(die.Sym), 4)
 			Addstring(s, name)
 		}
 
@@ -1863,26 +1322,26 @@ func writepub(sname string, ispub func(*DWDie) bool, prev *LSym) *LSym {
 		setuint32(Ctxt, s, sectionstart, uint32(s.Size-sectionstart)-4) // exclude the length field.
 	}
 
-	return s
+	return syms
 }
 
 /*
  *  emit .debug_aranges.  _info must have been written before,
- *  because we need die->offs of dw_globals.
+ *  because we need die->offs of dwarf.DW_globals.
  */
-func writearanges(prev *LSym) *LSym {
+func writearanges(syms []*LSym) []*LSym {
 	s := Linklookup(Ctxt, ".debug_aranges", 0)
 	s.Type = obj.SDWARFSECT
 	// The first tuple is aligned to a multiple of the size of a single tuple
 	// (twice the size of an address)
 	headersize := int(Rnd(4+2+4+1+1, int64(SysArch.PtrSize*2))) // don't count unit_length field itself
 
-	for compunit := dwroot.child; compunit != nil; compunit = compunit.link {
-		b := getattr(compunit, DW_AT_low_pc)
+	for compunit := dwroot.Child; compunit != nil; compunit = compunit.Link {
+		b := getattr(compunit, dwarf.DW_AT_low_pc)
 		if b == nil {
 			continue
 		}
-		e := getattr(compunit, DW_AT_high_pc)
+		e := getattr(compunit, dwarf.DW_AT_high_pc)
 		if e == nil {
 			continue
 		}
@@ -1892,7 +1351,7 @@ func writearanges(prev *LSym) *LSym {
 		Adduint32(Ctxt, s, unitlength) // unit_length (*)
 		Adduint16(Ctxt, s, 2)          // dwarf version (appendix F)
 
-		adddwarfref(Ctxt, s, compunit.sym, 4)
+		adddwarfref(Ctxt, s, dtolsym(compunit.Sym), 4)
 
 		Adduint8(Ctxt, s, uint8(SysArch.PtrSize)) // address_size
 		Adduint8(Ctxt, s, 0)                      // segment_size
@@ -1901,33 +1360,31 @@ func writearanges(prev *LSym) *LSym {
 			Adduint8(Ctxt, s, 0)
 		}
 
-		Addaddrplus(Ctxt, s, b.data.(*LSym), b.value-(b.data.(*LSym)).Value)
-		addrput(s, e.value-b.value)
-		addrput(s, 0)
-		addrput(s, 0)
+		Addaddrplus(Ctxt, s, b.Data.(*LSym), b.Value-(b.Data.(*LSym)).Value)
+		adduintxx(Ctxt, s, uint64(e.Value-b.Value), SysArch.PtrSize)
+		adduintxx(Ctxt, s, 0, SysArch.PtrSize)
+		adduintxx(Ctxt, s, 0, SysArch.PtrSize)
 	}
 	if s.Size > 0 {
-		prev.Next = s
-		prev = s
+		syms = append(syms, s)
 	}
-	return prev
+	return syms
 }
 
-func writegdbscript(prev *LSym) *LSym {
+func writegdbscript(syms []*LSym) []*LSym {
 
 	if gdbscript != "" {
 		s := Linklookup(Ctxt, ".debug_gdb_scripts", 0)
 		s.Type = obj.SDWARFSECT
-		prev.Next = s
-		prev = s
+		syms = append(syms, s)
 		Adduint8(Ctxt, s, 1) // magic 1 byte?
 		Addstring(s, gdbscript)
 	}
 
-	return prev
+	return syms
 }
 
-var prototypedies map[string]*DWDie
+var prototypedies map[string]*dwarf.DWDie
 
 /*
  * This is the main entry point for generating dwarf.  After emitting
@@ -1960,21 +1417,21 @@ func dwarfgeneratedebugsyms() {
 	}
 
 	// For diagnostic messages.
-	newattr(&dwtypes, DW_AT_name, DW_CLS_STRING, int64(len("dwtypes")), "dwtypes")
+	newattr(&dwtypes, dwarf.DW_AT_name, dwarf.DW_CLS_STRING, int64(len("dwtypes")), "dwtypes")
 
 	// Some types that must exist to define other ones.
-	newdie(&dwtypes, DW_ABRV_NULLTYPE, "<unspecified>", 0)
+	newdie(&dwtypes, dwarf.DW_ABRV_NULLTYPE, "<unspecified>", 0)
 
-	newdie(&dwtypes, DW_ABRV_NULLTYPE, "void", 0)
-	newdie(&dwtypes, DW_ABRV_BARE_PTRTYPE, "unsafe.Pointer", 0)
+	newdie(&dwtypes, dwarf.DW_ABRV_NULLTYPE, "void", 0)
+	newdie(&dwtypes, dwarf.DW_ABRV_BARE_PTRTYPE, "unsafe.Pointer", 0)
 
-	die := newdie(&dwtypes, DW_ABRV_BASETYPE, "uintptr", 0) // needed for array size
-	newattr(die, DW_AT_encoding, DW_CLS_CONSTANT, DW_ATE_unsigned, 0)
-	newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, int64(SysArch.PtrSize), 0)
-	newattr(die, DW_AT_go_kind, DW_CLS_CONSTANT, obj.KindUintptr, 0)
+	die := newdie(&dwtypes, dwarf.DW_ABRV_BASETYPE, "uintptr", 0) // needed for array size
+	newattr(die, dwarf.DW_AT_encoding, dwarf.DW_CLS_CONSTANT, dwarf.DW_ATE_unsigned, 0)
+	newattr(die, dwarf.DW_AT_byte_size, dwarf.DW_CLS_CONSTANT, int64(SysArch.PtrSize), 0)
+	newattr(die, dwarf.DW_AT_go_kind, dwarf.DW_CLS_CONSTANT, obj.KindUintptr, 0)
 
 	// Prototypes needed for type synthesis.
-	prototypedies = map[string]*DWDie{
+	prototypedies = map[string]*dwarf.DWDie{
 		"type.runtime.stringStructDWARF": nil,
 		"type.runtime.slice":             nil,
 		"type.runtime.hmap":              nil,
@@ -1992,33 +1449,36 @@ func dwarfgeneratedebugsyms() {
 
 	genasmsym(defdwsymb)
 
-	dwarfp = writeabbrev()
-	last := dwarfp
-	last = writelines(last)
-	last = writeframes(last)
+	syms := writeabbrev(nil)
+	syms, funcs := writelines(syms)
+	syms = writeframes(syms)
 
-	synthesizestringtypes(dwtypes.child)
-	synthesizeslicetypes(dwtypes.child)
-	synthesizemaptypes(dwtypes.child)
-	synthesizechantypes(dwtypes.child)
+	synthesizestringtypes(dwtypes.Child)
+	synthesizeslicetypes(dwtypes.Child)
+	synthesizemaptypes(dwtypes.Child)
+	synthesizechantypes(dwtypes.Child)
 
-	reversetree(&dwroot.child)
-	reversetree(&dwtypes.child)
-	reversetree(&dwglobals.child)
+	reversetree(&dwroot.Child)
+	reversetree(&dwtypes.Child)
+	reversetree(&dwglobals.Child)
 
 	movetomodule(&dwtypes)
 	movetomodule(&dwglobals)
 
 	// Need to reorder symbols so SDWARFINFO is after all SDWARFSECT
 	// (but we need to generate dies before writepub)
-	writeinfo(last)
-	infosyms := last.Next
-
-	last = writepub(".debug_pubnames", ispubname, last)
-	last = writepub(".debug_pubtypes", ispubtype, last)
-	last = writearanges(last)
-	last = writegdbscript(last)
-	last.Next = infosyms
+	infosyms := writeinfo(nil, funcs)
+
+	syms = writepub(".debug_pubnames", ispubname, syms)
+	syms = writepub(".debug_pubtypes", ispubtype, syms)
+	syms = writearanges(syms)
+	syms = writegdbscript(syms)
+	syms = append(syms, infosyms...)
+	dwarfp = syms[0]
+	for i := 1; i < len(syms); i++ {
+		syms[i-1].Next = syms[i]
+	}
+	syms[len(syms)-1].Next = nil
 }
 
 /*
diff --git a/src/cmd/link/internal/ld/objfile.go b/src/cmd/link/internal/ld/objfile.go
index 4db6489d00..834738178c 100644
--- a/src/cmd/link/internal/ld/objfile.go
+++ b/src/cmd/link/internal/ld/objfile.go
@@ -111,6 +111,7 @@ import (
 	"bufio"
 	"bytes"
 	"cmd/internal/bio"
+	"cmd/internal/dwarf"
 	"cmd/internal/obj"
 	"crypto/sha1"
 	"encoding/base64"
@@ -401,6 +402,37 @@ overwrite:
 			r.ctxt.Textp = append(r.ctxt.Textp, s)
 		}
 	}
+	if s.Type == obj.SDWARFINFO {
+		r.patchDWARFName(s)
+	}
+}
+
+func (r *objReader) patchDWARFName(s *LSym) {
+	// This is kind of ugly. Really the package name should not
+	// even be included here.
+	if s.Size < 1 || s.P[0] != dwarf.DW_ABRV_FUNCTION {
+		return
+	}
+	e := bytes.IndexByte(s.P, 0)
+	if e == -1 {
+		return
+	}
+	p := bytes.Index(s.P[:e], emptyPkg)
+	if p == -1 {
+		return
+	}
+	pkgprefix := []byte(r.pkg + ".")
+	patched := bytes.Replace(s.P[:e], emptyPkg, pkgprefix, -1)
+
+	s.P = append(patched, s.P[e:]...)
+	delta := int64(len(s.P)) - s.Size
+	s.Size = int64(len(s.P))
+	for i := range s.R {
+		r := &s.R[i]
+		if r.Off > int32(e) {
+			r.Off += int32(delta)
+		}
+	}
 }
 
 func (r *objReader) readFull(b []byte) {
diff --git a/src/cmd/link/internal/ld/symtab.go b/src/cmd/link/internal/ld/symtab.go
index 06d7792be3..b8ffef89ac 100644
--- a/src/cmd/link/internal/ld/symtab.go
+++ b/src/cmd/link/internal/ld/symtab.go
@@ -269,6 +269,8 @@ func Asmplan9sym() {
 
 var symt *LSym
 
+var encbuf [10]byte
+
 func Wputb(w uint16) { Cwrite(Append16b(encbuf[:0], w)) }
 func Lputb(l uint32) { Cwrite(Append32b(encbuf[:0], l)) }
 func Vputb(v uint64) { Cwrite(Append64b(encbuf[:0], v)) }
