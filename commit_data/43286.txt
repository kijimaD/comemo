commit b328ab1d1e245fbf9273b6d6a89871fd9dbf036a
Author: Jeremy Faller <jeremy@golang.org>
Date:   Mon Mar 9 11:08:04 2020 -0400

    [dev.link] cmd/link: remove global datap, moved to *Link
    
    This change moves datap from global space into the link context. Rather
    than having it exist in context, we could have it returned from dodata,
    and pass it as a parameter, but it is used in awkward places in the
    Arch functions. Easiest for now is just keeping it in the context, until
    we more formally move it to slices of loader.Sym.
    
    This is a largely non-functional change.
    
    Change-Id: Ica93bd857c39913ad470a61c63bc8d21704d6308
    Reviewed-on: https://go-review.googlesource.com/c/go/+/222664
    Reviewed-by: Than McIntosh <thanm@google.com>
    Reviewed-by: Cherry Zhang <cherryyz@google.com>
---
 src/cmd/link/internal/ld/data.go  | 14 +++++---------
 src/cmd/link/internal/ld/elf.go   |  8 ++++----
 src/cmd/link/internal/ld/lib.go   |  2 +-
 src/cmd/link/internal/ld/link.go  |  2 ++
 src/cmd/link/internal/ld/macho.go |  4 ++--
 src/cmd/link/internal/ld/pe.go    |  6 +++---
 src/cmd/link/internal/ld/xcoff.go |  2 +-
 7 files changed, 18 insertions(+), 20 deletions(-)

diff --git a/src/cmd/link/internal/ld/data.go b/src/cmd/link/internal/ld/data.go
index 603630c6bc..5682997b79 100644
--- a/src/cmd/link/internal/ld/data.go
+++ b/src/cmd/link/internal/ld/data.go
@@ -586,7 +586,7 @@ func (ctxt *Link) reloc() {
 		wg.Done()
 	}()
 	go func() {
-		for _, s := range datap {
+		for _, s := range ctxt.datap {
 			relocsym(target, reporter, lookup, syms, s)
 		}
 		wg.Done()
@@ -844,14 +844,14 @@ func writeDatblkToOutBuf(ctxt *Link, out *OutBuf, addr int64, size int64) {
 		ctxt.Logf("datblk [%#x,%#x) at offset %#x\n", addr, addr+size, ctxt.Out.Offset())
 	}
 
-	blk(out, datap, addr, size, zeros[:])
+	blk(out, ctxt.datap, addr, size, zeros[:])
 
 	/* again for printing */
 	if !*flagA {
 		return
 	}
 
-	syms := datap
+	syms := ctxt.datap
 	for i, sym := range syms {
 		if sym.Value >= addr {
 			syms = syms[i:]
@@ -1277,10 +1277,6 @@ func makeRelroForSharedLib(target *Link, data *[sym.SXREF][]*sym.Symbol) {
 	}
 }
 
-// datap is a collection of reachable data symbols in address order.
-// Generated by dodata.
-var datap []*sym.Symbol
-
 func (ctxt *Link) dodata() {
 	// Give zeros sized symbols space if necessary.
 	fixZeroSizedSymbols(ctxt)
@@ -1798,7 +1794,7 @@ func (ctxt *Link) dodata() {
 	}
 
 	for symn := sym.SELFRXSECT; symn < sym.SXREF; symn++ {
-		datap = append(datap, data[symn]...)
+		ctxt.datap = append(ctxt.datap, data[symn]...)
 	}
 
 	dwarfGenerateDebugSyms(ctxt)
@@ -2344,7 +2340,7 @@ func (ctxt *Link) address() []*sym.Segment {
 		}
 	}
 
-	for _, s := range datap {
+	for _, s := range ctxt.datap {
 		if s.Sect != nil {
 			s.Value += int64(s.Sect.Vaddr)
 		}
diff --git a/src/cmd/link/internal/ld/elf.go b/src/cmd/link/internal/ld/elf.go
index 078b0a55db..28802f1bd8 100644
--- a/src/cmd/link/internal/ld/elf.go
+++ b/src/cmd/link/internal/ld/elf.go
@@ -1415,18 +1415,18 @@ func Elfemitreloc(ctxt *Link) {
 		if sect.Name == ".text" {
 			elfrelocsect(ctxt, sect, ctxt.Textp)
 		} else {
-			elfrelocsect(ctxt, sect, datap)
+			elfrelocsect(ctxt, sect, ctxt.datap)
 		}
 	}
 
 	for _, sect := range Segrodata.Sections {
-		elfrelocsect(ctxt, sect, datap)
+		elfrelocsect(ctxt, sect, ctxt.datap)
 	}
 	for _, sect := range Segrelrodata.Sections {
-		elfrelocsect(ctxt, sect, datap)
+		elfrelocsect(ctxt, sect, ctxt.datap)
 	}
 	for _, sect := range Segdata.Sections {
-		elfrelocsect(ctxt, sect, datap)
+		elfrelocsect(ctxt, sect, ctxt.datap)
 	}
 	for _, sect := range Segdwarf.Sections {
 		elfrelocsect(ctxt, sect, dwarfp)
diff --git a/src/cmd/link/internal/ld/lib.go b/src/cmd/link/internal/ld/lib.go
index 1537bc662b..833ec25a58 100644
--- a/src/cmd/link/internal/ld/lib.go
+++ b/src/cmd/link/internal/ld/lib.go
@@ -2605,7 +2605,7 @@ func (ctxt *Link) undef() {
 	for _, s := range ctxt.Textp {
 		undefsym(ctxt, s)
 	}
-	for _, s := range datap {
+	for _, s := range ctxt.datap {
 		undefsym(ctxt, s)
 	}
 	if nerrors > 0 {
diff --git a/src/cmd/link/internal/ld/link.go b/src/cmd/link/internal/ld/link.go
index e867857a18..2777904cca 100644
--- a/src/cmd/link/internal/ld/link.go
+++ b/src/cmd/link/internal/ld/link.go
@@ -91,6 +91,8 @@ type Link struct {
 
 	cgo_export_static  map[string]bool
 	cgo_export_dynamic map[string]bool
+
+	datap []*sym.Symbol
 }
 
 type cgodata struct {
diff --git a/src/cmd/link/internal/ld/macho.go b/src/cmd/link/internal/ld/macho.go
index 3f45cc029a..0f36cd0cbe 100644
--- a/src/cmd/link/internal/ld/macho.go
+++ b/src/cmd/link/internal/ld/macho.go
@@ -1060,10 +1060,10 @@ func Machoemitreloc(ctxt *Link) {
 
 	machorelocsect(ctxt, Segtext.Sections[0], ctxt.Textp)
 	for _, sect := range Segtext.Sections[1:] {
-		machorelocsect(ctxt, sect, datap)
+		machorelocsect(ctxt, sect, ctxt.datap)
 	}
 	for _, sect := range Segdata.Sections {
-		machorelocsect(ctxt, sect, datap)
+		machorelocsect(ctxt, sect, ctxt.datap)
 	}
 	for _, sect := range Segdwarf.Sections {
 		machorelocsect(ctxt, sect, dwarfp)
diff --git a/src/cmd/link/internal/ld/pe.go b/src/cmd/link/internal/ld/pe.go
index fdfb9962e5..81fae75072 100644
--- a/src/cmd/link/internal/ld/pe.go
+++ b/src/cmd/link/internal/ld/pe.go
@@ -543,8 +543,8 @@ func (f *peFile) emitRelocations(ctxt *Link) {
 		syms   []*sym.Symbol
 	}{
 		{f.textSect, &Segtext, ctxt.Textp},
-		{f.rdataSect, &Segrodata, datap},
-		{f.dataSect, &Segdata, datap},
+		{f.rdataSect, &Segrodata, ctxt.datap},
+		{f.dataSect, &Segdata, ctxt.datap},
 	}
 	for _, s := range sects {
 		s.peSect.emitRelocations(ctxt.Out, func() int {
@@ -1434,7 +1434,7 @@ func addPEBaseReloc(ctxt *Link) {
 	for _, s := range ctxt.Textp {
 		addPEBaseRelocSym(ctxt, s, &rt)
 	}
-	for _, s := range datap {
+	for _, s := range ctxt.datap {
 		addPEBaseRelocSym(ctxt, s, &rt)
 	}
 
diff --git a/src/cmd/link/internal/ld/xcoff.go b/src/cmd/link/internal/ld/xcoff.go
index 55a404cfb0..74889b3833 100644
--- a/src/cmd/link/internal/ld/xcoff.go
+++ b/src/cmd/link/internal/ld/xcoff.go
@@ -1630,7 +1630,7 @@ func (f *xcoffFile) emitRelocations(ctxt *Link, fileoff int64) {
 				if sect.Name == ".text" {
 					n += relocsect(sect, ctxt.Textp, 0)
 				} else {
-					n += relocsect(sect, datap, 0)
+					n += relocsect(sect, ctxt.datap, 0)
 				}
 			}
 		}
